{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T22:26:51.328Z",
  "appVersion": "1.0.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - TC-23",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 383
    },
    "areas": [
      {
        "id": "10",
        "name": "Ciência da Computação",
        "description": "Área dedicada ao estudo de fundamentos teóricos e práticos da computação, incluindo algoritmos, complexidade e teoria da computação.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Análise de Algoritmos e Complexidade Computacional",
            "description": "Ordem de funções, recursividade e recorrência, emparelhamento de padrões, paradigmas de programação (divisão e conquista, método guloso, programação dinâmica), algoritmos numéricos avançados, codificação de Huffman, problemas da mochila, caixeiro viajante, clique e coloração, Máquina de Turing, algoritmos não-determinísticos, classe NP, Teorema de Cook e reduções polinomiais.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Ordem de Funções",
                "description": "Estudo da análise assintótica para comparar o crescimento de funções e determinar a complexidade de algoritmos.",
                "totalSkills": 50,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Notação Big-O",
                    "description": "Definição e uso da notação O(f(n)) para limite superior assintótico do crescimento de funções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1.1",
                        "name": "Definição Formal da Notação Big-O",
                        "description": "Compreensão da definição matemática precisa da notação O(f(n)), que estabelece um limite superior assintótico para o crescimento de funções, ignorando constantes e termos de ordem inferior.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1.1",
                            "name": "Enunciar a definição formal de Big-O",
                            "description": "Explicar verbalmente e matematicamente que g(n) ∈ O(f(n)) se existirem constantes c > 0 e n₀ > 0 tais que, para todo n ≥ n₀, 0 ≤ g(n) ≤ c · f(n), destacando o foco no comportamento assintótico para n grande.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes individuais da definição formal",
                                  "subSteps": [
                                    "Identifique g(n) como a função cujo crescimento queremos limitar e f(n) como a função de referência.",
                                    "Explique que c > 0 é uma constante positiva que escala f(n) para englobar g(n).",
                                    "Descreva n₀ > 0 como o limiar a partir do qual a desigualdade vale para todo n ≥ n₀.",
                                    "Analise a desigualdade 0 ≤ g(n) ≤ c · f(n), destacando que g(n) é não-negativa e limitada por múltiplo de f(n).",
                                    "Reflita sobre o contexto assintótico: foco no comportamento para n tendendo ao infinito."
                                  ],
                                  "verification": "Liste e defina verbalmente cada componente (g(n), f(n), c, n₀, desigualdade) sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, caneta, quadro branco ou ferramenta digital de anotações.",
                                  "tips": "Use analogias como 'c é o multiplicador de segurança' e 'n₀ é o ponto de partida da estrada longa'.",
                                  "learningObjective": "Dominar o significado preciso de cada símbolo e sua inter-relação na definição.",
                                  "commonMistakes": "Confundir c (constante) com n₀ (limiar) ou ignorar a condição 'para todo n ≥ n₀'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar a declaração matemática formal",
                                  "subSteps": [
                                    "Escreva a definição completa 5 vezes: 'g(n) ∈ O(f(n)) se existirem c > 0 e n₀ > 0 tais que para todo n ≥ n₀, 0 ≤ g(n) ≤ c · f(n)'.",
                                    "Recite em voz alta 10 vezes, variando a velocidade.",
                                    "Cubra o texto e reescreva de memória, corrigindo erros imediatamente.",
                                    "Compare sua versão com a original, anotando discrepâncias.",
                                    "Repita até acertar 3 vezes consecutivas sem erros."
                                  ],
                                  "verification": "Escreva a fórmula exata de memória e recite perfeitamente em gravação de áudio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ficha de estudo com a definição, gravador de voz ou app de notas.",
                                  "tips": "Associe a fórmula a uma mnemônica como 'Cresce com N zero, Zero menor que C vezes F'.",
                                  "learningObjective": "Internalizar a notação matemática precisa para recitação fluida.",
                                  "commonMistakes": "Esquecer '0 ≤' ou inverter a ordem de c e n₀ na existência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver a explicação verbal detalhada",
                                  "subSteps": [
                                    "Explique cada parte em palavras simples: comece por 'g(n) está em O de f(n) se...'.",
                                    "Inclua exemplos numéricos simples, como g(n)=2n e f(n)=n com c=3, n₀=1.",
                                    "Pratique transições suaves entre matemática e verbal.",
                                    "Grave-se explicando e ouça para melhorar clareza.",
                                    "Adapte para públicos diferentes: técnico vs. iniciante."
                                  ],
                                  "verification": "Grave uma explicação de 1 minuto e verifique se cobre todos os componentes claramente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gravador de áudio/vídeo, espelho para prática oral.",
                                  "tips": "Fale devagar, pausando após cada componente para enfatizar.",
                                  "learningObjective": "Traduzir a fórmula rigorosa em linguagem acessível e precisa.",
                                  "commonMistakes": "Usar termos vagos como 'cresce mais devagar' sem mencionar constantes ou limiar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar a enunciação completa com ênfase assintótica",
                                  "subSteps": [
                                    "Enuncie a definição completa: matemática + verbal + assintótico ('foco no limite superior para n grande').",
                                    "Aplique a uma função exemplo: mostre verbalmente por que 3n+5 ∈ O(n).",
                                    "Responda perguntas hipotéticas como 'Por que não importa para n pequeno?'.",
                                    "Pratique em duplas ou autoquestionamento 5 vezes.",
                                    "Registre uma versão final polida."
                                  ],
                                  "verification": "Demonstre enunciação fluida em 30 segundos, respondendo 3 perguntas sobre ela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de funções, parceiro de estudo ou auto-gravação.",
                                  "tips": "Sempre termine com: 'Isso captura o comportamento assintótico dominante'.",
                                  "learningObjective": "Integrar memorização, explicação e contexto para enunciação mestre.",
                                  "commonMistakes": "Omitir o foco assintótico ou confundir Big-O com Theta."
                                }
                              ],
                              "practicalExample": "Para provar que o tempo de um algoritmo de ordenação é O(n²), enuncie: 'O tempo g(n) = n²/2 ∈ O(n²) pois existem c=1 e n₀=1 tal que para n ≥ 1, 0 ≤ n²/2 ≤ 1·n², focando no crescimento para entradas grandes.'",
                              "finalVerifications": [
                                "Recita a definição matemática sem erros.",
                                "Explica verbalmente todos os componentes corretamente.",
                                "Destaca o foco assintótico espontaneamente.",
                                "Aplica a definição a um exemplo simples.",
                                "Responde perguntas sobre exceções ou variações.",
                                "Enuncia em menos de 45 segundos com clareza."
                              ],
                              "assessmentCriteria": [
                                "Precisão absoluta da fórmula matemática (100% correto).",
                                "Completude: inclui c, n₀, desigualdade e assintótico.",
                                "Clareza verbal: linguagem acessível sem ambiguidades.",
                                "Profundidade: explica implicações para análise de algoritmos.",
                                "Fluência: sem hesitações ou pausas longas.",
                                "Correção conceitual: distingue Big-O de outras notações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Limites, desigualdades e análise assintótica.",
                                "Cálculo: Comportamento de funções para n → ∞.",
                                "Estatística: Modelagem de crescimento de dados.",
                                "Física: Análise de escalas em sistemas complexos."
                              ],
                              "realWorldApplication": "Em entrevistas de programação ou design de software, enunciar Big-O permite justificar escolhas de algoritmos eficientes, como preferir O(n log n) sobre O(n²) para big data em empresas como Google."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.1.2",
                            "name": "Identificar constantes c e n₀ em provas simples",
                            "description": "Dado um par de funções g(n) e f(n), encontrar valores específicos de c e n₀ que satisfazem a desigualdade da definição Big-O, como provar que 3n² + 2n ∈ O(n²) com c=4 e n₀=1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal de Big-O",
                                  "subSteps": [
                                    "Leia a definição: g(n) ∈ O(f(n)) se existem constantes c > 0 e n₀ > 0 tais que para todo n ≥ n₀, 0 ≤ g(n) ≤ c * f(n).",
                                    "Identifique g(n) como a função a provar (ex: 3n² + 2n) e f(n) como a função de referência (ex: n²).",
                                    "Escreva a desigualdade necessária: 3n² + 2n ≤ c * n² para n ≥ n₀.",
                                    "Divida ambos os lados por f(n) para obter g(n)/f(n) ≤ c.",
                                    "Calcule o limite lim (n→∞) g(n)/f(n) para entender o comportamento assintótico."
                                  ],
                                  "verification": "Confirme que você pode reescrever a desigualdade corretamente em um papel ou editor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência à definição Big-O (livro ou notas)"
                                  ],
                                  "tips": "Sempre comece pela definição para ancorar o raciocínio.",
                                  "learningObjective": "Compreender precisamente os requisitos matemáticos da notação Big-O.",
                                  "commonMistakes": "Confundir Big-O com Theta ou Omega; ignorar o '0 ≤' na desigualdade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simplificar g(n)/f(n) e Encontrar Limite Assintótico",
                                  "subSteps": [
                                    "Compute g(n)/f(n): para 3n² + 2n / n² = 3 + 2/n.",
                                    "Analise o limite: lim (n→∞) (3 + 2/n) = 3, sugerindo c próximo de 3 ou maior.",
                                    "Expanda g(n) em termos dominantes: o termo n² domina.",
                                    "Escreva g(n)/f(n) ≤ algum valor para n grande.",
                                    "Teste valores pequenos de n para ver onde começa a valer."
                                  ],
                                  "verification": "Calcule g(n)/f(n) para n=1,10,100 e veja se aproxima do limite.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/Jupyter para plots",
                                    "Gráfico de g(n)/f(n)"
                                  ],
                                  "tips": "Use divisão polinomial para simplificar frações racionais.",
                                  "learningObjective": "Dominar a análise assintótica via limites para guiar escolha de c.",
                                  "commonMistakes": "Esquecer termos menores; assumir limite exato como c sem margem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar n₀ Inicial e Calcular c Correspondente",
                                  "subSteps": [
                                    "Escolha n₀=1 como inicial e compute max g(n)/f(n) para n≥1.",
                                    "Para n=1: (3+2)/1=5; sugira c=5.",
                                    "Teste c=4: verifique 3n²+2n ≤4n² → 2n ≤ n² → n≥2, então ajuste n₀=2.",
                                    "Para c=4, n₀=1: cheque n=1: 5≤4? Não; n=2:14≤16 sim.",
                                    "Itere: encontre menor c ou n₀ que funcione para todos n≥n₀."
                                  ],
                                  "verification": "Crie tabela para n=1 a 10 mostrando g(n) ≤ c f(n).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou tabela em papel",
                                    "Função para compute g(n)/f(n)"
                                  ],
                                  "tips": "Comece com n₀ pequeno e aumente se necessário; c deve cobrir picos iniciais.",
                                  "learningObjective": "Aprender a balancear c e n₀ empiricamente.",
                                  "commonMistakes": "Escolher c muito apertado sem checar todos n; ignorar n inteiros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Refinar a Prova",
                                  "subSteps": [
                                    "Prove algebricamente: 3n² + 2n ≤ 4n² para n≥1? Rearrange: 2n ≤ n² → n(n-2)≥0 para n≥2.",
                                    "Confirme para n₀=1 com c=5 ou n₀=2 com c=4.",
                                    "Teste n grandes (1000) para validar.",
                                    "Documente: 'Escolhemos c=4, n₀=2 pois para n≥2, 3+2/n ≤4'.",
                                    "Compare com provas padrão."
                                  ],
                                  "verification": "A desigualdade segura para 10 valores consecutivos de n≥n₀.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de LaTeX ou Word para prova formal",
                                    "Exemplos de provas Big-O"
                                  ],
                                  "tips": "Prefira prova algébrica sobre tabela para generalidade.",
                                  "learningObjective": "Consolidar prova com verificação rigorosa.",
                                  "commonMistakes": "Não testar suficientes n; falhar em prova algébrica."
                                }
                              ],
                              "practicalExample": "Para provar 3n² + 2n ∈ O(n²): Compute (3n² + 2n)/n² = 3 + 2/n. Para n≥1, 3 + 2/n ≤ 5, então c=5, n₀=1. Ou para c=4, note 3 + 2/n ≤4 quando 2/n≤1 i.e. n≥2, então n₀=2.",
                              "finalVerifications": [
                                "Identifica corretamente g(n) e f(n) da desigualdade.",
                                "Encontra c e n₀ válidos com prova algébrica ou tabela.",
                                "Explica por que o par funciona para todo n≥n₀.",
                                "Ajusta c/n₀ se inicial falha.",
                                "Compara com limite assintótico.",
                                "Aplica a pares novos como 5n² + n ∈ O(n²)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de c e n₀ (corretos e mínimos razoáveis).",
                                "Rigor na verificação (cobertura de n≥n₀).",
                                "Clareza na explicação algébrica ou limite.",
                                "Eficiência no processo (poucas iterações).",
                                "Generalização para exemplos similares.",
                                "Ausência de erros matemáticos comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e desigualdades polinomiais.",
                                "Programação: Implementar testes em loop para validar c/n₀.",
                                "Estatística: Análise assintótica similar a convergência de estimadores.",
                                "Engenharia de Software: Avaliar complexidade em design de algoritmos."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, identificar c e n₀ ajuda a comparar tempos de execução reais de sorting algorithms (ex: provar bubble sort O(n²) vs quicksort O(n log n) em prática), guiando escolhas em software escalável como bancos de dados ou ML training."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.1.3",
                            "name": "Diferenciar Big-O de limites estritos",
                            "description": "Comparar Big-O com notações Theta e Omega, explicando que Big-O fornece apenas um limite superior, permitindo que g(n) cresça mais devagar que f(n), mas não necessariamente no mesmo ritmo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Formais de Big-O, Ω e Θ",
                                  "subSteps": [
                                    "Leia a definição formal de Big-O: g(n) = O(f(n)) se ∃ c > 0 e n0 tal que 0 ≤ g(n) ≤ c f(n) para todo n ≥ n0.",
                                    "Estude Ω: g(n) = Ω(f(n)) se ∃ c > 0 e n0 tal que 0 ≤ c f(n) ≤ g(n) para n ≥ n0.",
                                    "Analise Θ: g(n) = Θ(f(n)) se g(n) = O(f(n)) e g(n) = Ω(f(n)).",
                                    "Anote as diferenças chave: Big-O é limite superior (upper bound), permite g(n) crescer mais devagar; Ω é inferior (lower bound); Θ é tight bound.",
                                    "Compare com limites estritos: Big-O não requer g(n) ~ f(n), apenas g(n) ≤ f(n) assintoticamente."
                                  ],
                                  "verification": "Recite as três definições sem consultar notas e identifique pelo menos duas diferenças entre Big-O e Θ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Referências: CLRS capítulo 3 ou Khan Academy Asymptotic Notation"
                                  ],
                                  "tips": "Use notação matemática precisa com símbolos ∀, ∃ e ≤.",
                                  "learningObjective": "Compreender as definições exatas e identificar que Big-O é apenas upper bound não-tight.",
                                  "commonMistakes": "Confundir Big-O como tight bound igual a Θ; ignorar constantes c e n0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos Numéricos e Gráficos",
                                  "subSteps": [
                                    "Escolha pares de funções: f(n)=n², g1(n)=n (O mas não Θ), g2(n)=n² (Θ), g3(n)=n³ (não O).",
                                    "Calcule valores para n=10,100,1000 e verifique desigualdades com c=1,2 etc.",
                                    "Plote gráficos simples de g(n) vs f(n) em papel ou ferramenta online para visualizar bounds.",
                                    "Identifique casos onde Big-O é loose (g cresce mais devagar) vs tight.",
                                    "Discuta por que Big-O permite 'mais devagar': foco em worst-case upper limit."
                                  ],
                                  "verification": "Crie tabela com 3 exemplos mostrando se é O, Ω, Θ e explique um loose bound.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou Python/Desmos para plots",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Comece com n grandes para ver comportamento assintótico ignorar constantes.",
                                  "learningObjective": "Visualizar e quantificar diferenças entre upper bound loose e tight bounds.",
                                  "commonMistakes": "Focar em pequenos n onde constantes dominam; assumir igualdade exata em Big-O."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar com Limites Estritos e Notações Alternativas",
                                  "subSteps": [
                                    "Defina limite estrito: lim (n→∞) g(n)/f(n) = L finito >0 para Θ-like.",
                                    "Mostre que Big-O permite lim ≤ ∞ (incluindo 0, loose).",
                                    "Exemplo: g(n)=n log n vs f(n)=n²: O mas lim=0 (mais devagar).",
                                    "Compare Ω (lim ≥0 finito ou ∞) e discuta simetria.",
                                    "Escreva pseudocódigo para verificar bounds computacionalmente."
                                  ],
                                  "verification": "Explique com fórmula limite por que Big-O permite g(n) 'mais devagar' que f(n).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto para fórmulas LaTeX",
                                    "Ferramenta como Wolfram Alpha para limites"
                                  ],
                                  "tips": "Lembre: Big-O é para upper bound, útil em worst-case sem precisão tight.",
                                  "learningObjective": "Diferenciar Big-O de bounds tight via limites assintóticos.",
                                  "commonMistakes": "Equiparar Big-O a lim=1; confundir com little-o (lim=0 estrito)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Classificação e Aplicação Inicial",
                                  "subSteps": [
                                    "Classifique 5 pares de funções: n vs n², 2n vs n, n! vs 2^n etc. como O/Ω/Θ.",
                                    "Crie contraexemplo onde alguém usa Big-O como tight e corrija.",
                                    "Resolva problema: 'Prove n = O(n²) mas não Θ(n²)'.",
                                    "Aplique a um algoritmo simples: insertion sort worst-case.",
                                    "Autoavalie respostas com definições do step 1."
                                  ],
                                  "verification": "Liste 3 pares corretamente classificados com justificativa breve.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de funções comuns em complexidade (busque online)",
                                    "Temporizador"
                                  ],
                                  "tips": "Sempre pergunte: 'É upper bound? Pode ser loose?'",
                                  "learningObjective": "Aplicar conceitos para classificar bounds corretamente.",
                                  "commonMistakes": "Classificar tudo como Θ por 'parecido'; ignorar assintótico."
                                }
                              ],
                              "practicalExample": "Analisando merge sort: tempo T(n) = 2T(n/2) + O(n). Solução é O(n log n), mas provamos Θ(n log n). Big-O dá upper bound loose inicialmente, mas refinamos para Θ mostrando matching lower bound.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença Big-O vs Θ com exemplo.",
                                "Classificar corretamente 3 pares funções como O mas não Θ.",
                                "Desenhar gráfico ilustrando loose upper bound.",
                                "Provar simples: n log n = O(n²) usando definição formal.",
                                "Identificar erro comum: 'Big-O significa exato' e corrigir."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (sem omissões).",
                                "Correta identificação de loose vs tight bounds em exemplos.",
                                "Uso apropriado de limites assintóticos para suporte.",
                                "Clareza em explicações e visualizações.",
                                "Capacidade de aplicar a algoritmos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Assintótica e Limites (Cálculo III).",
                                "Física: Ordens de Magnitude em Escalas (e.g., crescimento exponencial).",
                                "Engenharia de Software: Estimativas de Performance e Benchmarking.",
                                "Economia: Análise de Custos Margonais e Bounds em Modelos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usa-se Big-O para garantir que um algoritmo roda em tempo aceitável no worst-case (upper bound), mesmo se o tight bound for melhor, evitando surpresas em grandes inputs como buscas em big data."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.1.2",
                        "name": "Propriedades e Regras de Crescimento Assintótico",
                        "description": "Exploração das propriedades algébricas da Big-O, como transitividade, aditividade e multiplicatividade, para simplificar análises de complexidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.2.1",
                            "name": "Aplicar regras de soma e produto em Big-O",
                            "description": "Usar propriedades como O(f(n)) + O(g(n)) = O(max(f(n), g(n))) e O(f(n)) · O(g(n)) = O(f(n) · g(n)) para simplificar expressões como O(n² + n) = O(n²) ou O(n log n · log n) = O(n (log n)²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as regras fundamentais de soma e produto em Big-O",
                                  "subSteps": [
                                    "Leia a definição da regra de soma: O(f(n)) + O(g(n)) = O(max(f(n), g(n)))",
                                    "Estude exemplos: O(n²) + O(n) = O(n²) porque n² cresce mais rápido que n",
                                    "Aprenda a regra de produto: O(f(n)) · O(g(n)) = O(f(n) · g(n))",
                                    "Analise exemplos: O(n log n) · O(log n) = O(n (log n)²)",
                                    "Compare crescimento usando tabelas de funções comuns (n, n log n, n², etc.)"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as duas regras com um exemplo cada",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Tabela de hierarquia Big-O (impressa ou online)"
                                  ],
                                  "tips": "Sempre identifique o termo dominante comparando coeficientes de crescimento",
                                  "learningObjective": "Memorizar e compreender as regras de soma e produto em notação Big-O",
                                  "commonMistakes": [
                                    "Confundir soma com produto",
                                    "Ignorar termos dominantes menores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar aplicação da regra de soma em expressões simples",
                                  "subSteps": [
                                    "Simplifique O(n² + n): identifique max(n², n) = n²",
                                    "Trabalhe O(n + log n + 1): max é n",
                                    "Exercite O(n³ + n² log n): compare n³ vs n² log n (n³ domina)",
                                    "Crie sua própria expressão com 3 termos e simplifique",
                                    "Verifique usando limites: lim (n→∞) [termo menor / dominante] = 0"
                                  ],
                                  "verification": "Simplifique corretamente 4 expressões de soma fornecidas ou criadas",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para logaritmos",
                                    "Exercícios impressos ou editor de texto"
                                  ],
                                  "tips": "Ordene termos por ordem crescente para visualizar o dominante facilmente",
                                  "learningObjective": "Aplicar com precisão a regra de soma para eliminar termos não-dominantes",
                                  "commonMistakes": [
                                    "Manter todos os termos",
                                    "Errar na comparação de crescimento (ex: achar log n > n)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar aplicação da regra de produto em expressões",
                                  "subSteps": [
                                    "Simplifique O(n log n · log n): resulta em O(n (log n)²)",
                                    "Aplique em O(n · n): O(n²)",
                                    "Trabalhe O((n²) · log n): O(n² log n)",
                                    "Multiplique expressões compostas: O(n + m) · O(log n) = O((n+m) log n)",
                                    "Expanda e reordene: pratique com parênteses para clareza"
                                  ],
                                  "verification": "Resolva 4 problemas de produto e justifique cada multiplicação",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para anotações algébricas",
                                    "Ferramenta online como Desmos para plotar"
                                  ],
                                  "tips": "Use notação com parênteses para evitar ambiguidades em multiplicações",
                                  "learningObjective": "Dominar a multiplicação de classes de complexidade Big-O",
                                  "commonMistakes": [
                                    "Adicionar em vez de multiplicar produtos",
                                    "Esquecer de elevar potências em produtos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar regras de soma e produto em expressões complexas",
                                  "subSteps": [
                                    "Simplifique O(n² + n log n · log n): primeiro produto → O(n² + n (log n)²) → soma O(n²)",
                                    "Exercite O((n + m)² · log n): expanda e aplique regras",
                                    "Analise O(n² log n + n³): soma com n³ dominante",
                                    "Crie e resolva 2 expressões próprias com soma e produto misturados",
                                    "Valide plotando curvas de crescimento para confirmação visual"
                                  ],
                                  "verification": "Simplifique 3 expressões complexas mistas com justificativa passo a passo",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos online (Wolfram Alpha)",
                                    "Lista de exercícios avançados"
                                  ],
                                  "tips": "Resolva parênteses internos primeiro, depois some/produtos externos",
                                  "learningObjective": "Integrar regras de soma e produto para simplificações reais de algoritmos",
                                  "commonMistakes": [
                                    "Aplicar soma antes de produto",
                                    "Perder termos durante expansões"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e refinar simplificações com análise assintótica",
                                  "subSteps": [
                                    "Use limite L'Hôpital para confirmar dominância em casos duvidosos",
                                    "Compare com hierarquia Big-O: constante < log < linear < n log n < polinomial",
                                    "Teste com valores grandes de n (ex: n=10^6) numericamente",
                                    "Revise erros anteriores e corrija 2 simplificações falhas",
                                    "Documente um 'fluxograma' pessoal para aplicar regras"
                                  ],
                                  "verification": "Confirme 5 simplificações anteriores com método de limite ou numérico",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Referência de limites assintóticos"
                                  ],
                                  "tips": "Para dúvidas, sempre recorra a lim (f(n)/g(n)) = 0 ou ∞",
                                  "learningObjective": "Desenvolver confiança em verificações independentes de simplificações Big-O",
                                  "commonMistakes": [
                                    "Confiar só em intuição sem verificação",
                                    "Ignorar constantes em análises finitas"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o tempo de um algoritmo de ordenação: T(n) = 2n² + 3n log n + 5n. Simplifique: produto não aplica diretamente, soma → O(n² + n log n + n) = O(n²), pois n² domina.",
                              "finalVerifications": [
                                "Simplificar corretamente 10 expressões mistas de soma/produto",
                                "Explicar regras em uma prova oral de 5 minutos",
                                "Plotar e comparar 3 curvas de complexidade simplificada vs original",
                                "Identificar termo dominante em 5 cenários de algoritmos reais",
                                "Criar e resolver 3 problemas originais sem erros",
                                "Passar em quiz com 90% de acerto sobre regras"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de termos dominantes (peso 30%)",
                                "Justificativa passo a passo clara e lógica (peso 25%)",
                                "Correta aplicação de soma vs produto (peso 20%)",
                                "Uso de verificações assintóticas quando necessário (peso 15%)",
                                "Criatividade em exemplos próprios (peso 10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e assintóticos",
                                "Física: Modelagem de crescimento exponencial em sistemas dinâmicos",
                                "Engenharia de Software: Otimização de performance em projetos",
                                "Economia: Análise de escalabilidade em modelos de custo",
                                "Estatística: Complexidade em algoritmos de machine learning"
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, simplificar Big-O de algoritmos como merge sort (O(n log n)) vs bubble sort (O(n²)) ajuda a escolher soluções escaláveis para big data, economizando tempo e recursos em empresas como Google ou Amazon."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2.2",
                            "name": "Ocultar constantes e termos inferiores",
                            "description": "Demonstrar que constantes multiplicativas e termos de ordem inferior podem ser absorvidos na Big-O, provando que 5n³ + 10n² + 7 ∈ O(n³) sem analisar coeficientes exatos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Relembrar a definição formal da Notação Big-O",
                                  "subSteps": [
                                    "Estudar a definição: f(n) ∈ O(g(n)) se existem constantes c > 0 e n₀ ≥ 0 tais que para todo n ≥ n₀, 0 ≤ f(n) ≤ c · g(n).",
                                    "Entender o foco no comportamento assintótico para n → ∞.",
                                    "Discutir o papel das constantes c e n₀ na absorção de fatores.",
                                    "Analisar um exemplo simples: mostrar que 3n + 2 ∈ O(n).",
                                    "Diferenciar Big-O de análise exata de tempo de execução."
                                  ],
                                  "verification": "Escrever e explicar a definição formal em suas próprias palavras.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional",
                                    "Referência de livro de algoritmos"
                                  ],
                                  "tips": "Visualize gráficos de funções para n grande para intuitar o limite superior.",
                                  "learningObjective": "Compreender a definição precisa de Big-O e seu foco assintótico.",
                                  "commonMistakes": "Confundir Big-O com igualdade exata ou ignorar a existência de c e n₀."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o termo dominante em funções polinomiais",
                                  "subSteps": [
                                    "Decompor a função em termos: por exemplo, 5n³ + 10n² + 7.",
                                    "Comparar graus dos polinômios: o maior grau é o dominante (n³).",
                                    "Explicar por que termos de grau inferior crescem mais devagar.",
                                    "Usar limites: lim (n→∞) [termo_inferior / termo_dominante] = 0.",
                                    "Praticar com 2-3 polinômios diferentes."
                                  ],
                                  "verification": "Listar o termo dominante e justificar com limite para uma função dada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfica online como Desmos"
                                  ],
                                  "tips": "Sempre ordene termos por grau decrescente para facilitar.",
                                  "learningObjective": "Saber identificar e justificar o termo de maior ordem em polinômios.",
                                  "commonMistakes": "Considerar coeficientes como decisivos para dominância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a absorção de constantes e termos inferiores",
                                  "subSteps": [
                                    "Estimar limites superiores: para n ≥ 1, n² ≤ n³, n⁰ ≤ n³.",
                                    "Aplicar desigualdades: 10n² ≤ 10n³, 7 ≤ 7n³.",
                                    "Somar: 5n³ + 10n² + 7 ≤ 5n³ + 10n³ + 7n³ = 22n³.",
                                    "Concluir: f(n) ≤ 22 · n³ para n ≥ 1, logo ∈ O(n³).",
                                    "Generalizar para qualquer polinômio de grau k."
                                  ],
                                  "verification": "Escrever a prova completa para 5n³ + 10n² + 7 ∈ O(n³).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para fórmulas LaTeX opcional"
                                  ],
                                  "tips": "Escolha n₀ = 1 para simplificar estimativas em polinômios.",
                                  "learningObjective": "Dominar a técnica de prova por desigualdades para Big-O.",
                                  "commonMistakes": "Analisar coeficientes exatos ou esquecer n ≥ n₀."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e generalizar a propriedade",
                                  "subSteps": [
                                    "Resolver exercício: prove 4n⁴ + 20n³ + 100n² + 5 ∈ O(n⁴).",
                                    "Usar limites alternativos: lim (f(n)/g(n)) < ∞ implica O(g(n)).",
                                    "Discutir por que não precisamos de c exato.",
                                    "Aplicar a uma função não polinomial simples, como n² + n log n ∈ O(n²).",
                                    "Resumir regras: ignore constantes e termos o(n^k)."
                                  ],
                                  "verification": "Provar dois exemplos adicionais corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Lista de exercícios impressa"
                                  ],
                                  "tips": "Pratique com funções variadas para reforçar intuição.",
                                  "learningObjective": "Aplicar e generalizar a ocultação de constantes e termos inferiores.",
                                  "commonMistakes": "Sobrestimar termos inferiores ou usar Big-O para casos exatos."
                                }
                              ],
                              "practicalExample": "Considere o tempo de um algoritmo de ordenação: T(n) = 3n² + 5n + 10. Prove que T(n) ∈ O(n²) mostrando T(n) ≤ 18n² para n ≥ 1, ignorando análise precisa de hardware.",
                              "finalVerifications": [
                                "Pode provar 5n³ + 10n² + 7 ∈ O(n³) usando desigualdades.",
                                "Identifica corretamente o termo dominante em polinômios arbitrários.",
                                "Explica verbalmente por que constantes são 'ocultadas'.",
                                "Usa limites para confirmar dominância.",
                                "Evita erros como focar em coeficientes exatos.",
                                "Generaliza para funções de graus variados."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na prova (desigualdades e constantes c, n₀).",
                                "Clareza e estrutura na explicação dos passos.",
                                "Identificação precisa do termo dominante.",
                                "Uso apropriado de limites ou gráficos para suporte.",
                                "Generalização sem exceções inválidas.",
                                "Ausência de análise desnecessária de coeficientes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e limites de funções.",
                                "Física: Leis de escala em sistemas complexos (ex: crescimento populacional).",
                                "Economia: Modelos de custo marginal e crescimento exponencial/polinomial.",
                                "Engenharia: Dimensionamento de sistemas e eficiência energética."
                              ],
                              "realWorldApplication": "Na análise de algoritmos reais, como em machine learning (treinamento de redes neurais O(n³)), permite comparar soluções focando no crescimento com o tamanho dos dados, ignorando constantes de hardware para decisões de design escalável."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2.3",
                            "name": "Verificar transitividade da Big-O",
                            "description": "Provar que se g(n) ∈ O(f(n)) e f(n) ∈ O(h(n)), então g(n) ∈ O(h(n)), aplicando em cadeias como n² ∈ O(n³) e n ∈ O(n²) implicando n ∈ O(n³).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recapitular a Definição Formal de Notação Big-O",
                                  "subSteps": [
                                    "Leia a definição: f(n) ∈ O(g(n)) se existem constantes c > 0 e n₀ ≥ 0 tais que para todo n ≥ n₀, 0 ≤ f(n) ≤ c * g(n).",
                                    "Escreva a definição em suas próprias palavras, destacando os elementos chave: função dominante, constante c e ponto inicial n₀.",
                                    "Identifique exemplos simples: confirme que n² ∈ O(n³) significa n² ≤ c * n³ para grandes n.",
                                    "Desenhe um gráfico mental comparando funções para visualizar dominância assintótica.",
                                    "Pratique reescrevendo a definição para g(n) ∈ O(f(n))."
                                  ],
                                  "verification": "Escreva a definição corretamente sem consultar notas e aplique-a a um exemplo básico como 2n ∈ O(n).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência de livro de algoritmos (ex: CLRS Capítulo 3)",
                                    "Calculadora para testes numéricos"
                                  ],
                                  "tips": "Foquem em 'assintótico' – ignore constantes baixas e foque no crescimento para grandes n.",
                                  "learningObjective": "Compreender precisamente o que significa uma função estar em Big-O de outra.",
                                  "commonMistakes": [
                                    "Confundir Big-O com Theta (tight bound)",
                                    "Ignorar o 'para todo n ≥ n₀'",
                                    "Pensar que Big-O é exata, não upper bound"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer as Premissas da Transitividade",
                                  "subSteps": [
                                    "Assuma g(n) ∈ O(f(n)): existe c₁ > 0 e n₁ tal que 0 ≤ g(n) ≤ c₁ * f(n) para n ≥ n₁.",
                                    "Assuma f(n) ∈ O(h(n)): existe c₂ > 0 e n₂ tal que 0 ≤ f(n) ≤ c₂ * h(n) para n ≥ n₂.",
                                    "Defina n₀ = max(n₁, n₂) para unificar os pontos iniciais.",
                                    "Escreva as duas desigualdades lado a lado para visualização.",
                                    "Verifique com números: teste n=10 para funções exemplo como g=n, f=n², h=n³."
                                  ],
                                  "verification": "Liste as constantes c₁, c₂, n₀ e desigualdades escritas corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Software como Desmos para plotar funções",
                                    "Exemplos de funções polinomiais"
                                  ],
                                  "tips": "Sempre use 'existem constantes positivas' – não tente encontrar valores exatos ainda.",
                                  "learningObjective": "Formalizar as hipóteses dadas para a prova de transitividade.",
                                  "commonMistakes": [
                                    "Esquecer que funções são não-negativas",
                                    "Não alinhar os n₀ corretamente",
                                    "Confundir ordem das funções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Transitividade Combinando Desigualdades",
                                  "subSteps": [
                                    "Substitua f(n) na primeira desigualdade: g(n) ≤ c₁ * f(n) ≤ c₁ * (c₂ * h(n)) = (c₁ c₂) * h(n).",
                                    "Defina c = c₁ * c₂ (nova constante positiva).",
                                    "Confirme que para n ≥ n₀, 0 ≤ g(n) ≤ c * h(n), satisfazendo g(n) ∈ O(h(n)).",
                                    "Generalize: a propriedade vale para qualquer cadeia finita de Big-O.",
                                    "Teste algebricamente com logaritmos ou exponenciais simples."
                                  ],
                                  "verification": "Escreva a prova completa em 4-5 linhas e verifique se cada passo lógico flui.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou app de notas (ex: OneNote)",
                                    "Tabela de funções de crescimento comum"
                                  ],
                                  "tips": "A multiplicação de constantes é chave – Big-O absorve fatores constantes.",
                                  "learningObjective": "Derivar logicamente a conclusão da transitividade a partir das premissas.",
                                  "commonMistakes": [
                                    "Esquecer de multiplicar c₁ e c₂",
                                    "Não definir n₀ como máximo",
                                    "Aplicar desigualdades para n pequenos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar com Exemplos Práticos",
                                  "subSteps": [
                                    "Aplique ao exemplo: n² ∈ O(n³) (c=1, n₀=1), n ∈ O(n²) (c=1, n₀=1) → n ∈ O(n³) (c=1).",
                                    "Crie cadeia mais longa: n ∈ O(n log n) → n log n ∈ O(n²) → n ∈ O(n²).",
                                    "Teste numericamente: para n=1000, verifique g(n) ≤ c h(n).",
                                    "Contra-exemplo falho: tente provar algo falso como n³ ∉ O(n²) para praticar.",
                                    "Documente 2 exemplos originais envolvendo funções reais de algoritmos."
                                  ],
                                  "verification": "Resolva 3 exemplos independentes corretamente, incluindo um inventado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para cálculos",
                                    "Lista de complexidades de algoritmos comuns"
                                  ],
                                  "tips": "Use limites: lim (g/h) finito implica Big-O.",
                                  "learningObjective": "Aplicar a propriedade em cadeias reais para solidificar compreensão.",
                                  "commonMistakes": [
                                    "Ignorar crescimento assintótico em testes numéricos pequenos",
                                    "Confundir ∈ com ==",
                                    "Não testar n grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de quicksort: worst-case T(n) ∈ O(n²), mas com pivot médio T(n) ∈ O(n log n). Pela transitividade, T(n) ∈ O(n²) ainda vale, permitindo upper bound conservador em comparações de algoritmos.",
                              "finalVerifications": [
                                "Provar transitividade para g(n)=n³, f(n)=n⁴, h(n)=n⁵ sem erros.",
                                "Explicar verbalmente por que c = c₁ c₂ funciona.",
                                "Identificar erro em uma prova falha fornecida.",
                                "Aplicar a n log n ∈ O(n²) via intermediária.",
                                "Confirmar que Big-Omega não é transitiva da mesma forma.",
                                "Resolver cadeia de 3 funções: log n → n → n²."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e uso de constantes/notação.",
                                "Lógica impecável na derivação da desigualdade composta.",
                                "Correta generalização para cadeias arbitrárias.",
                                "Exemplos relevantes com verificação numérica/assintótica.",
                                "Identificação de erros comuns em contra-exemplos.",
                                "Clareza na escrita da prova formal."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Desigualdades e limites assintóticos (Cálculo I).",
                                "Lógica: Provas por substituição e transitividade em relações.",
                                "Física: Análise assintótica em modelos de crescimento exponencial.",
                                "Economia: Bounding custos em otimização de recursos.",
                                "Engenharia de Software: Estimativas de performance em design de sistemas."
                              ],
                              "realWorldApplication": "Ao comparar algoritmos em projetos de software, use transitividade para provar que um algoritmo O(n log n) é viável onde upper bounds O(n²) são aceitáveis, como em buscas em grandes datasets sem precisar reprovar desde zero."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.1.3",
                        "name": "Aplicação da Notação Big-O em Algoritmos",
                        "description": "Uso prático da Big-O para analisar o crescimento assintótico da complexidade temporal e espacial de algoritmos simples.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.3.1",
                            "name": "Classificar funções comuns em Big-O",
                            "description": "Determinar a classe Big-O para funções típicas como log n (O(log n)), n^k (O(n^k)), 2^n (O(2^n)), ordenando-as por crescimento: constantes < logarítmicas < lineares < polinomiais < exponenciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as classes principais de complexidade Big-O",
                                  "subSteps": [
                                    "Defina O(1) como tempo constante, independente do tamanho da entrada.",
                                    "Explique O(log n) para funções logarítmicas, como divisão sucessiva.",
                                    "Descreva O(n) para crescimento linear.",
                                    "Detalhe O(n^k) para polinomiais, onde k > 1.",
                                    "Introduza O(2^n) para crescimento exponencial."
                                  ],
                                  "verification": "Liste verbalmente ou por escrito as 5 classes principais com exemplos simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráficos de funções Big-O (impressos ou online: Khan Academy Big-O graphs)"
                                  ],
                                  "tips": "Visualize gráficos de crescimento para fixar a hierarquia.",
                                  "learningObjective": "Compreender as definições e características de cada classe Big-O comum.",
                                  "commonMistakes": [
                                    "Confundir O(n) com O(n^2), ignorando o expoente.",
                                    "Pensar que log n cresce mais rápido que n."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e classificar funções comuns",
                                  "subSteps": [
                                    "Analise funções como log n → O(log n).",
                                    "Classifique n^k, ex: n^2 → O(n^2), n^3 → O(n^3).",
                                    "Identifique 2^n → O(2^n).",
                                    "Ignore termos de ordem inferior: 3n^2 + n → O(n^2).",
                                    "Pratique com 5 funções mistas."
                                  ],
                                  "verification": "Classifique corretamente 5 funções dadas sem olhar referências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 10 funções para prática (criar ou baixar de GeeksforGeeks)",
                                    "Calculadora para logs opcionais"
                                  ],
                                  "tips": "Sempre pegue o termo dominante com maior crescimento.",
                                  "learningObjective": "Aplicar regras de dominância para classificar funções precisamente.",
                                  "commonMistakes": [
                                    "Incluir todos os termos na classificação final.",
                                    "Confundir log n com n log n."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ordenar funções por ordem de crescimento assintótico",
                                  "subSteps": [
                                    "Lembre a hierarquia: O(1) < O(log n) < O(n) < O(n^k) < O(2^n).",
                                    "Compare pares: O(n) vs O(n^2) → n^2 cresce mais rápido.",
                                    "Ordene uma lista de 5 classes mistas.",
                                    "Crie uma tabela ou gráfico mental da ordem.",
                                    "Teste com limites: para n→∞, qual domina?",
                                    "],",
                                    "verificationTime30min",
                                    "materialsLista10funçõesprática",
                                    "tipsUselemitedelim(n→∞)paracomparar",
                                    "learningObjectiveDominiodetotalordemdecrescimento",
                                    "commonMistakesNãoaceitarqueO(nlogn)estáentreO(n)O(n^2)",
                                    "mistakes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar classificação em exemplos de algoritmos",
                                  "subSteps": [
                                    "Classifique busca linear: O(n).",
                                    "Busca binária: O(log n).",
                                    "Bubble sort: O(n^2).",
                                    "Fibonacci recursivo: O(2^n).",
                                    "Ordene as complexidades desses algoritmos."
                                  ],
                                  "verification": "Explique Big-O para 4 algoritmos com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigos de algoritmos básicos",
                                    "Ferramenta online como Big-O Cheat Sheet"
                                  ],
                                  "tips": "Pense no pior caso (upper bound) para Big-O.",
                                  "learningObjective": "Conectar classificação teórica a algoritmos reais.",
                                  "commonMistakes": [
                                    "Classificar pelo melhor caso em vez de pior caso.",
                                    "Ignorar recorrências simples."
                                  ]
                                }
                              ],
                              "practicalExample": "Dadas as funções: 5, log2(n), 4n + 10, n^3 - 2n, 3^n. Classificações: O(1), O(log n), O(n), O(n^3), O(3^n). Ordem crescente: O(1) < O(log n) < O(n) < O(n^3) < O(3^n). Exemplo em algoritmo: Merge Sort é O(n log n), entre linear e quadrático.",
                              "finalVerifications": [
                                "Classifica corretamente pelo menos 8/10 funções comuns.",
                                "Ordena uma lista de 6 classes Big-O sem erros.",
                                "Explica dominância em 3 exemplos compostos.",
                                "Identifica hierarquia completa: constante a exponencial.",
                                "Aplica a um algoritmo simples como busca binária."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do termo dominante (90%+).",
                                "Correta ordenação assintótica em comparações.",
                                "Justificativa clara para cada classificação.",
                                "Uso apropriado de limites para n→∞.",
                                "Integração com exemplos algorítmicos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de crescimento de funções e limites.",
                                "Física: Modelagem de decaimento/decrescimento exponencial.",
                                "Economia: Análise de crescimento populacional ou composto.",
                                "Estatística: Complexidade em análise de dados grandes."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, classificar Big-O ajuda a escolher algoritmos eficientes para grandes datasets, como otimizar buscas em apps (O(log n) vs O(n)) ou evitar exponenciais em IA, economizando tempo e recursos em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3.2",
                            "name": "Analisar complexidade de laços e algoritmos lineares",
                            "description": "Calcular Big-O para estruturas como laços simples O(n), laços aninhados O(n²) e algoritmos de busca linear O(n), ignorando constantes de inicialização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender análise de laços simples O(n)",
                                  "subSteps": [
                                    "Identifique um laço simples que itera uma vez sobre n elementos.",
                                    "Conte o número de operações básicas dentro do laço (atribuições, comparações).",
                                    "Ignore constantes de inicialização fora do laço.",
                                    "Conclua que o crescimento é linear, resultando em O(n).",
                                    "Escreva a notação Big-O formal."
                                  ],
                                  "verification": "Escreva a análise Big-O para um laço simples de soma de array e confirme O(n).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de código ou pseudocódigo",
                                    "Exemplos de laços simples"
                                  ],
                                  "tips": "Foquem apenas nas operações dominantes dentro do laço; multiplique iterações por operações internas.",
                                  "learningObjective": "Dominar o cálculo de complexidade para laços que executam n iterações.",
                                  "commonMistakes": [
                                    "Incluir tempo de inicialização como parte do O(n)",
                                    "Confundir com O(1) para laços fixos",
                                    "Contar operações constantes como variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar laços aninhados O(n²)",
                                  "subSteps": [
                                    "Identifique laços duplos onde o externo roda n vezes e o interno também n vezes.",
                                    "Calcule iterações totais: n * n = n².",
                                    "Conte operações dentro do laço interno e multiplique pelo total de iterações.",
                                    "Ignore constantes e foque no termo quadrático dominante.",
                                    "Aplique a notação Big-O como O(n²)."
                                  ],
                                  "verification": "Analise um laço aninhado para impressão de matriz e verifique O(n²).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo de laços aninhados",
                                    "Planilha para contar iterações",
                                    "Calculadora"
                                  ],
                                  "tips": "Visualize como um grid n x n; total de células é n².",
                                  "learningObjective": "Calcular complexidade para estruturas quadráticas comuns.",
                                  "commonMistakes": [
                                    "Assumir O(2n) em vez de O(n²)",
                                    "Ignorar aninhamento assimétrico",
                                    "Contar apenas o laço externo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar complexidade de busca linear O(n)",
                                  "subSteps": [
                                    "Descreva busca linear: percorrer lista sequencialmente até encontrar o elemento.",
                                    "No pior caso, verifica todos n elementos.",
                                    "Conte comparações: até n no pior caso.",
                                    "Ignore otimizações constantes e foque em O(n).",
                                    "Compare com cenários médio e melhor caso (ainda O(n) no pior)."
                                  ],
                                  "verification": "Implemente busca linear em pseudocódigo e derive O(n) para pior caso.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de exemplo com 10 elementos",
                                    "Pseudocódigo",
                                    "Ferramenta de contagem de passos"
                                  ],
                                  "tips": "Pense no pior caso: elemento no final ou ausente.",
                                  "learningObjective": "Aplicar Big-O a algoritmos de busca não ordenados.",
                                  "commonMistakes": [
                                    "Confundir com busca binária O(log n)",
                                    "Assumir O(1) médio sem contexto",
                                    "Esquecer pior caso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar análise integrada e verificação",
                                  "subSteps": [
                                    "Combine laços simples, aninhados e busca em um algoritmo composto.",
                                    "Identifique termo dominante (ex: O(n²) domina O(n)).",
                                    "Ignore constantes em todos os componentes.",
                                    "Teste com exemplos variados e valide cálculos.",
                                    "Documente análises em um relatório resumido."
                                  ],
                                  "verification": "Analise um algoritmo misto (busca + laço aninhado) e confirme complexidade total.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Códigos de exemplo mistos",
                                    "Tabela de complexidades",
                                    "Peer review opcional"
                                  ],
                                  "tips": "Sempre pergunte: 'Quanto cresce com n dobrado?'",
                                  "learningObjective": "Integrar análises para algoritmos reais complexos.",
                                  "commonMistakes": [
                                    "Somar complexidades em vez de multiplicar",
                                    "Não descartar termos inferiores",
                                    "Sobreestimar por constantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise este pseudocódigo de Bubble Sort (laços aninhados):\npara i de 1 a n-1:\n  para j de 1 a n-i:\n    se array[j] > array[j+1] troque\nResultado: O(n²) devido a n*(n-1)/2 ≈ n² iterações.",
                              "finalVerifications": [
                                "Corretamente deriva O(n) para laço simples de soma.",
                                "Identifica O(n²) em laços duplos sem erros de contagem.",
                                "Explica O(n) para busca linear no pior caso.",
                                "Ignora corretamente constantes em todos os exemplos.",
                                "Aplica análise a um algoritmo misto com termo dominante correto.",
                                "Documenta justificativas claras para cada cálculo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de iterações e operações (90%+ correto).",
                                "Justificativa clara do termo dominante e descarte de constantes.",
                                "Uso correto de notação Big-O sem ambiguidades.",
                                "Identificação precisa de casos pior/médio quando aplicável.",
                                "Capacidade de generalizar para variações do algoritmo.",
                                "Clareza e estrutura na documentação da análise."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries e somas (n + n²/2 para aninhados).",
                                "Física: Modelagem de crescimento populacional linear/quadrático.",
                                "Economia: Análise de custo-benefício em escalas (custo O(n) vs O(n²)).",
                                "Estatística: Complexidade em análise de dados lineares."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, analisar Big-O de laços garante que apps escalem para milhões de usuários, evitando lentidão em buscas lineares em grandes bancos de dados ou laços aninhados em processamentos de imagem."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Notação Big-Ω",
                    "description": "Definição e uso da notação Ω(f(n)) para limite inferior assintótico do crescimento de funções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Definição Formal da Notação Big-Ω",
                        "description": "Compreensão da definição matemática precisa da notação Ω(f(n)), que descreve o limite inferior assintótico do crescimento de uma função g(n), indicando que g(n) cresce pelo menos tão rápido quanto f(n) para valores suficientemente grandes de n.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Enunciar a definição formal de Ω(f(n))",
                            "description": "Escrever corretamente a definição: Uma função g(n) pertence a Ω(f(n)) se existirem constantes positivas c e n₀ tais que g(n) ≥ c · f(n) para todo n ≥ n₀, assumindo f(n) > 0 e g(n) ≥ 0 para grandes n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de funções assintóticas",
                                  "subSteps": [
                                    "Leia a definição de funções positivas: f(n) > 0 e g(n) ≥ 0 para grandes n.",
                                    "Entenda o conceito de limite inferior em análise assintótica.",
                                    "Identifique os elementos chave: constantes c > 0, n₀ > 0, desigualdade g(n) ≥ c · f(n).",
                                    "Anote os símbolos matemáticos envolvidos: Ω, ≥, para todo n ≥ n₀.",
                                    "Compare com notações semelhantes como O e Θ para contextualizar."
                                  ],
                                  "verification": "Liste corretamente os 5 elementos chave sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Algoritmos (ex: CLRS, capítulo de análise assintótica)",
                                    "Acesso a Khan Academy ou Wikipedia sobre Big-O"
                                  ],
                                  "tips": "Use diagramas para visualizar o crescimento de g(n) acima de c*f(n).",
                                  "learningObjective": "Compreender os pré-requisitos e componentes da definição de Big-Ω.",
                                  "commonMistakes": [
                                    "Confundir com Big-O (limite superior)",
                                    "Esquecer que c e n₀ são positivos",
                                    "Ignorar a condição para grandes n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar a estrutura verbal da definição",
                                  "subSteps": [
                                    "Repita verbalmente: 'g(n) pertence a Ω(f(n)) se...'.",
                                    "Divida em partes: existência de c > 0 e n₀ tal que...",
                                    "Pratique a frase completa 5 vezes em voz alta.",
                                    "Escreva a definição em palavras naturais antes dos símbolos.",
                                    "Grave-se recitando e ouça para autoavaliação."
                                  ],
                                  "verification": "Recite a definição verbalmente com 100% de precisão em 3 tentativas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gravador de voz (celular)",
                                    "Espelho para prática oral"
                                  ],
                                  "tips": "Associe mnemônicos: 'Cresce Constante vezes para n₀ ou mais'.",
                                  "learningObjective": "Internalizar a definição em linguagem natural.",
                                  "commonMistakes": [
                                    "Trocar '≥' por '≤'",
                                    "Omitir 'positivas' para c e n₀",
                                    "Dizer 'para algum n' em vez de 'para todo n ≥ n₀'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever a definição formal com notação matemática precisa",
                                  "subSteps": [
                                    "Escreva: g(n) ∈ Ω(f(n)) se ∃ c > 0, n₀ > 0 tais que g(n) ≥ c · f(n) ∀ n ≥ n₀.",
                                    "Verifique símbolos: use ∈ para pertence, ∃ para existe, ∀ para para todo.",
                                    "Inclua assunções: assumindo f(n) > 0 e g(n) ≥ 0 para n grandes.",
                                    "Copie 3 vezes variando o formato (inline, display math).",
                                    "Compare com referência oficial para exatidão."
                                  ],
                                  "verification": "Produza uma escrita idêntica à definição padrão sem erros tipográficos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "LaTeX editor online (Overleaf gratuito)",
                                    "Referência: Cormen et al. página de Big-Omega"
                                  ],
                                  "tips": "Pratique em LaTeX para precisão: \\Omega(f(n)), \\geq, \\exists.",
                                  "learningObjective": "Dominar a notação matemática exata da definição.",
                                  "commonMistakes": [
                                    "Usar = em vez de ≥",
                                    "Escrever O(f(n)) por engano",
                                    "Colocar lim n→∞ incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar a definição em exemplos simples",
                                  "subSteps": [
                                    "Pegue f(n) = n, g(n) = 2n: encontre c=2, n₀=1.",
                                    "Teste f(n)=n², g(n)=n: refute mostrando que não satisfaz.",
                                    "Escreva a definição aplicada: '2n ∈ Ω(n) pois ∃ c=2...'.",
                                    "Crie seu próprio exemplo com f(n)=log n, g(n)=1.",
                                    "Explique por que as assunções de positividade importam."
                                  ],
                                  "verification": "Aplique corretamente em 2 exemplos e refute 1 incorreto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "Planilha Excel para plotar funções"
                                  ],
                                  "tips": "Plote gráficos para visualizar g(n) ≥ c f(n).",
                                  "learningObjective": "Consolidar a definição através de aplicação prática.",
                                  "commonMistakes": [
                                    "Escolher c negativo",
                                    "Ignorar n₀ finito",
                                    "Confundir com crescimento exato (Θ)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para provar que o tempo de um algoritmo de ordenação por inserção T(n) = O(n²) implica n² ∈ Ω(n) no pior caso: Escolha c=1, n₀=1, pois n² ≥ 1·n para n≥1, satisfazendo a definição formal.",
                              "finalVerifications": [
                                "Recite a definição completa sem hesitação em menos de 30 segundos.",
                                "Escreva a notação matemática sem erros em 1 minuto.",
                                "Aplique a definição corretamente a um exemplo novo.",
                                "Diferencie Ω de O e Θ verbalmente.",
                                "Identifique erros em uma definição mal escrita.",
                                "Explique o papel das constantes c e n₀."
                              ],
                              "assessmentCriteria": [
                                "Precisão na enunciação verbal (100% das palavras chave).",
                                "Correção dos símbolos matemáticos (∈, ∃, ∀, ≥).",
                                "Inclusão de todas as assunções (c>0, n₀>0, f>0, g≥0).",
                                "Capacidade de aplicação em exemplos simples.",
                                "Fluência na recitação e escrita sob tempo.",
                                "Distinção clara de notações relacionadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Desigualdades e limites (cálculo I).",
                                "Matemática: Teoria dos conjuntos (pertence ∈).",
                                "Física: Análise assintótica em modelagem de crescimento exponencial.",
                                "Engenharia de Software: Análise de complexidade em design de sistemas."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, engenheiros de software usam a definição de Ω(f(n)) para garantir que um algoritmo tenha um tempo de execução no pior caso pelo menos proporcional a f(n), como em buscas não otimizadas onde Ω(n) é o limite inferior teórico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Identificar os elementos chave da definição",
                            "description": "Explicar os papéis das constantes c (fator de escala positivo) e n₀ (limiar assintótico), e como eles garantem o comportamento de limite inferior para n tendendo ao infinito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal da Notação Big-Ω",
                                  "subSteps": [
                                    "Leia a definição exata: f(n) = Ω(g(n)) se existem constantes c > 0 e n₀ > 0 tais que para todo n ≥ n₀, 0 ≤ c · g(n) ≤ f(n).",
                                    "Identifique os componentes principais: f(n), g(n), c, n₀ e a desigualdade.",
                                    "Anote a definição em suas próprias palavras, destacando o que significa 'limite inferior'.",
                                    "Compare com Big-O para notar a direção da desigualdade (≥ em vez de ≤).",
                                    "Desenhe um gráfico simples de f(n) e c·g(n) para visualizar o comportamento assintótico."
                                  ],
                                  "verification": "Você pode recitar a definição completa e identificar todos os elementos chave sem olhar para o papel?",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a um livro-texto de análise de algoritmos ou site como GeeksforGeeks"
                                  ],
                                  "tips": "Use cores diferentes para destacar c, n₀ e a desigualdade ao anotar.",
                                  "learningObjective": "Compreender a estrutura matemática da definição de Big-Ω.",
                                  "commonMistakes": [
                                    "Confundir a desigualdade com Big-O (lembre: Big-Ω é limite inferior, então f(n) ≥ c·g(n)).",
                                    "Esquecer que c > 0 e n₀ > 0 são positivos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Papel da Constante c (Fator de Escala Positivo)",
                                  "subSteps": [
                                    "Explique por que c deve ser positivo: garante que c·g(n) seja uma escala útil e não trivial.",
                                    "Teste com exemplos numéricos: para f(n) = n² e g(n) = n, encontre um c=1 tal que n² ≥ 1·n para n grande.",
                                    "Discuta como c ajusta a 'proporção' entre f(n) e g(n), permitindo flexibilidade na comparação.",
                                    "Verifique falhas: se c=0, a desigualdade sempre vale, mas é trivial; se c negativo, pode inverter sentidos.",
                                    "Calcule c para pares de funções simples como f(n)=2n e g(n)=n (c=1.5 funciona)."
                                  ],
                                  "verification": "Você pode escolher um c válido para uma dada f(n) e g(n) e justificar por quê?",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python para plotar funções",
                                    "Folha de exemplos de funções"
                                  ],
                                  "tips": "Comece com c=1 e ajuste para cima ou baixo até satisfazer a desigualdade.",
                                  "learningObjective": "Entender como c escala g(n) para formar um limite inferior não-trivial para f(n).",
                                  "commonMistakes": [
                                    "Escolher c negativo ou zero.",
                                    "Ignorar que c é fixo para todo n ≥ n₀."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Papel de n₀ (Limiar Assintótico)",
                                  "subSteps": [
                                    "Defina n₀ como o ponto a partir do qual a desigualdade deve valer para todo n ≥ n₀.",
                                    "Encontre n₀ para exemplos: para f(n)=n² e g(n)=n com c=1, n₀=1 basta.",
                                    "Teste com funções que crescem diferente inicialmente: f(n)=n + sin(n), g(n)=n, encontre n₀ onde sin(n) não interfere.",
                                    "Discuta o 'assintótico': n₀ ignora comportamento para n pequeno, focando em n → ∞.",
                                    "Prove para um caso: mostre que para n ≥ n₀, a desigualdade segura."
                                  ],
                                  "verification": "Dado f(n), g(n) e c, você pode encontrar e validar um n₀?",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de funções (use Desmos ou similar)",
                                    "Tabela para testar valores de n"
                                  ],
                                  "tips": "Teste valores crescentes de n até a desigualdade falhar e defina n₀ logo após.",
                                  "learningObjective": "Compreender n₀ como o threshold para comportamento assintótico dominante.",
                                  "commonMistakes": [
                                    "Definir n₀=0 ou 1 sempre, sem verificar.",
                                    "Confundir n₀ com o domínio total de n."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar c e n₀ para Garantir Limite Inferior Assintótico",
                                  "subSteps": [
                                    "Combine: c e n₀ juntos asseguram f(n) ≥ c·g(n) para n grande, provando f cresce pelo menos como g.",
                                    "Aplique a uma prova completa: prove 2n² + n = Ω(n²) encontrando c=1.5, n₀=1.",
                                    "Discuta limite n → ∞: a existência de c e n₀ implica lim inf f(n)/g(n) ≥ c > 0.",
                                    "Compare com contraexemplos: mostre por que sem c>0 ou n₀, não é Big-Ω.",
                                    "Resuma em um fluxograma: Definição → Escolha c → Escolha n₀ → Verifique ∀n ≥ n₀."
                                  ],
                                  "verification": "Você pode explicar verbalmente como c e n₀ garantem o limite inferior?",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fluxograma em papel",
                                    "Exemplos de provas de livros-textos"
                                  ],
                                  "tips": "Use a frase 'a partir de n₀, f é pelo menos c vezes g' como mnemônico.",
                                  "learningObjective": "Dominar como c e n₀ validam o crescimento assintótico mínimo de f sobre g.",
                                  "commonMistakes": [
                                    "Focar só em um sem o outro.",
                                    "Esquecer a quantificação 'existem c, n₀ tal que para todo n ≥ n₀'."
                                  ]
                                }
                              ],
                              "practicalExample": "Prove que o tempo de um algoritmo de ordenação por inserção T(n) = n²/2 ≈ Ω(n²). Escolha c=0.4 e n₀=1: para n≥1, n²/2 ≥ 0.4 n² (pois 0.5 ≥ 0.4). Isso mostra que o algoritmo leva pelo menos proporcionalmente a n² tempo para entradas grandes.",
                              "finalVerifications": [
                                "Recitar a definição de Big-Ω incluindo papéis exatos de c e n₀.",
                                "Identificar c e n₀ em uma prova dada de f(n) = Ω(g(n)).",
                                "Explicar por que c>0 é essencial para não-trivialidade.",
                                "Encontrar c e n₀ para um novo par de funções simples.",
                                "Diferenciar Big-Ω de Big-O usando c e n₀.",
                                "Desenhar gráfico mostrando região n≥n₀ onde desigualdade vale."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de c como fator de escala positivo.",
                                "Correta descrição de n₀ como limiar assintótico.",
                                "Explicação clara de como ambos garantem f(n) ≥ c g(n) para n→∞.",
                                "Uso correto de exemplos numéricos para validar escolhas de c e n₀.",
                                "Ausência de confusão com notações Big-O ou Θ.",
                                "Capacidade de generalizar para novas funções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Limites e análise assintótica (lim inf f(n)/g(n) ≥ c).",
                                "Cálculo: Comportamento de funções para n→∞ e desigualdades.",
                                "Estatística: Análise de complexidade em dados grandes (Big Data).",
                                "Física: Modelagem assintótica de crescimento exponencial em sistemas.",
                                "Engenharia de Software: Previsão de performance escalável."
                              ],
                              "realWorldApplication": "Em análise de algoritmos para bancos ou apps de streaming, use Big-Ω para garantir que um algoritmo de busca nunca seja pior que O(n) em tempo médio, ajudando a escolher soluções escaláveis para milhões de usuários, evitando gargalos em picos de tráfego."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Diferenciar Ω de limites não-assintóticos",
                            "description": "Comparar a definição de Ω(f(n)) com desigualdades finitas, destacando que a notação ignora constantes e termos de baixa ordem, focando no comportamento assintótico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal da Notação Big-Ω",
                                  "subSteps": [
                                    "Leia a definição: g(n) é Ω(f(n)) se existem constantes c > 0 e n₀ tal que para todo n ≥ n₀, g(n) ≥ c · f(n).",
                                    "Identifique os componentes chave: existência de c e n₀, desigualdade para n suficientemente grande.",
                                    "Note que Ω descreve crescimento assintótico inferior, ignorando constantes e termos de baixa ordem.",
                                    "Escreva a definição em suas próprias palavras.",
                                    "Compare com Big-O para reforçar o conceito de lower bound."
                                  ],
                                  "verification": "Escreva a definição formal de Ω(f(n)) corretamente, incluindo condições de c e n₀.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Algoritmos (ex: CLRS Capítulo 3), folha de papel, calculadora"
                                  ],
                                  "tips": "Use notação matemática precisa; pratique escrevendo símbolos como ∀n ≥ n₀.",
                                  "learningObjective": "Compreender os elementos constitutivos da notação Big-Ω e seu foco assintótico.",
                                  "commonMistakes": "Confundir com igualdade exata ou ignorar a existência de n₀ (assumir para todo n)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Desigualdades Finitas e Não-Assintóticas",
                                  "subSteps": [
                                    "Defina desigualdades finitas: g(n) ≥ k · f(n) para todo n ≥ 1, com k constante fixa, sem n₀.",
                                    "Examine exemplos: n² ≥ n para todo n ≥ 1 (verdadeiro), mas não captura assintótica.",
                                    "Discuta limitações: não ignora termos de baixa ordem; aplica-se a todos n, não apenas grandes.",
                                    "Compare com limites tradicionais: lim (n→∞) g(n)/f(n) ≥ c vs. desigualdades globais.",
                                    "Liste 3 exemplos de funções onde desigualdades finitas falham para pequenos n."
                                  ],
                                  "verification": "Forneça um exemplo de desigualdade finita e explique por que ela não é assintótica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta, exemplos de funções polinomiais (n, n², 2n+1)"
                                  ],
                                  "tips": "Teste desigualdades em valores pequenos de n (n=1,2) para ver falhas.",
                                  "learningObjective": "Distinguir desigualdades que valem para todos n das que valem apenas assintoticamente.",
                                  "commonMistakes": "Assumir que toda desigualdade finita implica Ω; ignorar contraexemplos para n pequenos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Chave entre Ω e Limites Não-Assintóticos",
                                  "subSteps": [
                                    "Liste diferenças: Ω requer n₀ (assintótico), finitas requerem para todo n; Ω permite c flexível.",
                                    "Analise impacto de constantes: Ω absorve-as, finitas não.",
                                    "Estude termos de baixa ordem: Ω ignora (ex: 2n² + n é Ω(n²)), finitas não.",
                                    "Crie uma tabela comparativa com colunas: Definição, Escopo, Constantes, Exemplos.",
                                    "Debata: 'Por que assintótico é útil em algoritmos?' (foco em grandes n)."
                                  ],
                                  "verification": "Complete uma tabela comparativa com pelo menos 4 diferenças claras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela, exemplos de funções (n log n, n²)"
                                  ],
                                  "tips": "Use setas na tabela para mostrar 'ignora' vs. 'exige exatidão'.",
                                  "learningObjective": "Mapear precisamente as distinções conceituais e práticas entre os dois.",
                                  "commonMistakes": "Misturar Big-O com Ω; esquecer que Ω é lower bound, não upper."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Diferenciação em Exemplos Práticos",
                                  "subSteps": [
                                    "Prove: n² é Ω(n) usando definição Ω (escolha c=1, n₀=1).",
                                    "Mostre desigualdade finita: n² ≥ n para n≥1, mas discuta se é estritamente necessário.",
                                    "Contraexemplo: 2n + sin(n) ≥ n para n grande? Verifique assintótico vs. finito.",
                                    "Resolva exercício: É n log n = Ω(n)? Justifique diferenças.",
                                    "Crie seu próprio par de funções e diferencie."
                                  ],
                                  "verification": "Resolva 2 provas: uma Ω correta e uma onde finita falha assintoticamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou software como Desmos, folhas para provas"
                                  ],
                                  "tips": "Sempre especifique c e n₀ explicitamente nas provas.",
                                  "learningObjective": "Aplicar a diferenciação para validar ou refutar afirmações sobre funções.",
                                  "commonMistakes": "Escolher c inadequado; não testar n₀ com valores numéricos."
                                }
                              ],
                              "practicalExample": "Considere g(n) = 3n² + 2n. Para Ω(n²): escolha c=2, n₀=1, pois 3n² + 2n ≥ 2n² para n≥1. Desigualdade finita falha se tentarmos 3n² + 2n ≥ k n² para k>3 em n pequenos, mas Ω ignora isso focando em assintótico.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre Ω e desigualdades finitas sem hesitação.",
                                "Prove corretamente que n! é Ω(2^n) com c e n₀ específicos.",
                                "Identifique erro em: 'n² ≥ 0.5 n para todo n implica Ω(n)'.",
                                "Crie tabela comparativa precisa.",
                                "Diferencie Ω de limite lim g(n)/f(n) = ∞.",
                                "Aplique a um algoritmo real (ex: lower bound de ordenação)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de Ω (inclui c, n₀, ≥).",
                                "Correta distinção de escopo (assintótico vs. finito).",
                                "Uso correto de exemplos com provas numéricas.",
                                "Identificação de erros comuns em afirmações de notação.",
                                "Clareza em tabelas ou comparações visuais.",
                                "Aplicação independente a novas funções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e séries infinitas (comportamento assintótico).",
                                "Física: Modelos assintóticos em mecânica (ex: trajetórias para t→∞).",
                                "Economia: Análise de crescimento exponencial vs. polinomial em modelos econômicos.",
                                "Engenharia: Estimativas de complexidade em sistemas embarcados."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, usar Ω para provar lower bounds irredutíveis, como Ω(n log n) para ordenação por comparação, guiando otimizações sem se preocupar com constantes de implementação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Propriedades e Relações da Notação Big-Ω",
                        "description": "Exploração das propriedades algébricas da notação Big-Ω, como transitividade, aditividade e relações com outras notações assintóticas (Big-O e Θ).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Aplicar propriedades básicas de Ω",
                            "description": "Demonstrar que se g(n) ∈ Ω(f(n)) e f(n) ∈ Ω(h(n)), então g(n) ∈ Ω(h(n)) (transitividade), e que Ω(f(n) + g(n)) = Ω(max(f(n), g(n))).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal da Notação Big-Ω",
                                  "subSteps": [
                                    "Leia a definição: g(n) ∈ Ω(f(n)) se existem constantes c > 0 e n0 tais que para todo n ≥ n0, g(n) ≥ c * f(n).",
                                    "Identifique exemplos simples: n² ∈ Ω(n), pois n² ≥ 1 * n para n ≥ 1.",
                                    "Diferencie de Big-O: Ω é cota inferior assintótica.",
                                    "Pratique com funções polinomiais: verifique se 2n³ + n ∈ Ω(n³).",
                                    "Anote contraexemplos onde a condição falha."
                                  ],
                                  "verification": "Escreva a definição de cor e valide 3 exemplos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de funções comuns de complexidade (n, n log n, n²)"
                                  ],
                                  "tips": "Sempre especifique c e n0 para tornar concreto.",
                                  "learningObjective": "Compreender precisamente o que significa g ∈ Ω(f).",
                                  "commonMistakes": "Confundir com Big-O (cota superior); ignorar 'para n suficientemente grande'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar a Transitividade de Big-Ω",
                                  "subSteps": [
                                    "Assuma g(n) ∈ Ω(f(n)): ∃ c1 > 0, n1 s.t. g(n) ≥ c1 f(n) para n ≥ n1.",
                                    "Assuma f(n) ∈ Ω(h(n)): ∃ c2 > 0, n2 s.t. f(n) ≥ c2 h(n) para n ≥ n2.",
                                    "Combine: g(n) ≥ c1 c2 h(n) para n ≥ max(n1, n2), com c = c1 c2 > 0.",
                                    "Conclua g(n) ∈ Ω(h(n)) pela definição.",
                                    "Teste com exemplo: g(n)=n², f(n)=n log n, h(n)=n."
                                  ],
                                  "verification": "Escreva a prova formal e aplique a um trio de funções específicas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de funções: n, n log n, n², n³"
                                  ],
                                  "tips": "Use n0 = max(n1,n2) para simplificar o domínio.",
                                  "learningObjective": "Demonstrar transitividade usando composição de desigualdades.",
                                  "commonMistakes": "Esquecer de multiplicar constantes c1 e c2; não lidar com n0 adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Propriedade da Soma: Ω(f + g) = Ω(max(f, g))",
                                  "subSteps": [
                                    "Mostre Ω(f + g) ⊆ Ω(max(f,g)): assuma sem perda de generalidade f ≥ g, então f + g ≤ 2f, logo max(f,g) ∈ Ω(f+g).",
                                    "Mostre o inverso: f + g ≥ max(f,g), logo max(f,g) ∈ Ω(f+g).",
                                    "Conclua igualdade por ambas direções.",
                                    "Exemplo: f(n)=n², g(n)=n → f+g = n² + n ∈ Ω(n²) e vice-versa.",
                                    "Generalize para múltiplas funções."
                                  ],
                                  "verification": "Escreva prova bidirecional e valide com 2 pares de funções.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráficos de funções para visualização (opcional: Desmos ou papel)"
                                  ],
                                  "tips": "Assuma f(n) ≥ g(n) para n grande sem perda de generalidade.",
                                  "learningObjective": "Entender como somas são dominadas pelo termo maior.",
                                  "commonMistakes": "Ignorar direção inversa; confundir com Big-O da soma (min)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar as Propriedades em Análise de Algoritmos",
                                  "subSteps": [
                                    "Escolha algoritmo: Merge Sort T(n) ∈ Ω(n log n).",
                                    "Use transitividade: compare com Quick Sort médio Ω(n log n).",
                                    "Aplique soma: T(n) = 2T(n/2) + Ω(n) → Ω(n log n).",
                                    "Verifique com max: iterações + recursão dominadas por log n.",
                                    "Crie contraexemplo onde soma não é max."
                                  ],
                                  "verification": "Analise complexidade de 1 algoritmo usando ambas propriedades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo de algoritmos (Merge Sort, etc.)",
                                    "Papel para recorrências"
                                  ],
                                  "tips": "Sempre justifique assintoticamente, não numericamente.",
                                  "learningObjective": "Integrar propriedades em provas reais de complexidade.",
                                  "commonMistakes": "Aplicar numericamente em vez de assintoticamente; ignorar constantes."
                                }
                              ],
                              "practicalExample": "Para Merge Sort: recursão 2T(n/2) ∈ Ω(n log n) por Master Theorem. Adicione custo de merge Ω(n): total ∈ Ω(n log n + n) = Ω(n log n) = Ω(max(n log n, n)). Transitividade com Bubble Sort Ω(n²) não aplica diretamente, mas para lower bounds em buscas.",
                              "finalVerifications": [
                                "Prova transitividade com c, n0 explícitos para trio de funções.",
                                "Prova soma/max com ambas direções e exemplo numérico para n=1000.",
                                "Analise 1 algoritmo real usando propriedade.",
                                "Identifique erro em prova falsa fornecida.",
                                "Compare Ω com Θ em contexto de lower bound.",
                                "Gere contraexemplo onde suposição falha."
                              ],
                              "assessmentCriteria": [
                                "Prova formal completa com constantes e domínios.",
                                "Exemplos concretos com funções específicas e verificação numérica.",
                                "Aplicação correta em análise algorítmica.",
                                "Identificação precisa de erros comuns.",
                                "Clareza na distinção entre direções das inclusões.",
                                "Generalização apropriada sem overclaims."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de ordem em funções reais (análise assintótica).",
                                "Física: Modelagem de crescimento em sistemas dinâmicos (ex: epidemias Ω(n)).",
                                "Economia: Análise de custos marginais crescentes (Ω quadrático).",
                                "Engenharia de Software: Garantias de performance em specs."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos para big data (ex: Hadoop MapReduce), provar lower bounds Ω(n log n) para sorting garante que soluções lineares são impossíveis, guiando escolhas de hardware e escalabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Relacionar Ω com Big-O e Θ",
                            "description": "Explicar que f(n) ∈ Θ(g(n)) implica f(n) ∈ Ω(g(n)) e f(n) ∈ O(g(n)), e identificar casos onde Ω é estrita (lower bound sem upper bound correspondente).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de Big-O, Big-Ω e Big-Θ",
                                  "subSteps": [
                                    "Defina Big-O: f(n) ∈ O(g(n)) se existem constantes c > 0 e n0 tal que para todo n ≥ n0, f(n) ≤ c * g(n).",
                                    "Defina Big-Ω: f(n) ∈ Ω(g(n)) se existem constantes c > 0 e n0 tal que para todo n ≥ n0, f(n) ≥ c * g(n).",
                                    "Defina Big-Θ: f(n) ∈ Θ(g(n)) se f(n) ∈ O(g(n)) e f(n) ∈ Ω(g(n)), ou seja, c1 * g(n) ≤ f(n) ≤ c2 * g(n) para constantes c1, c2 > 0.",
                                    "Compare visualmente com gráficos ou tabelas de crescimento assintótico.",
                                    "Pratique com exemplos simples como f(n) = n^2 e g(n) = n."
                                  ],
                                  "verification": "Escreva as definições formais e identifique corretamente três pares de funções que satisfazem cada notação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel, calculadora, recurso online como Khan Academy ou Wikipedia sobre notação assintótica.",
                                  "tips": "Use limites para entender o comportamento assintótico: lim (n→∞) f(n)/g(n) finito e positivo para Θ.",
                                  "learningObjective": "Compreender precisamente as definições matemáticas de O, Ω e Θ para basear relações posteriores.",
                                  "commonMistakes": "Confundir upper bound (O) com lower bound (Ω); ignorar constantes e n0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Implicação de Θ para O e Ω",
                                  "subSteps": [
                                    "Prove que se f(n) ∈ Θ(g(n)), então f(n) ∈ O(g(n)): Como Θ inclui upper bound.",
                                    "Prove que se f(n) ∈ Θ(g(n)), então f(n) ∈ Ω(g(n)): Como Θ inclui lower bound.",
                                    "Desenhe diagramas de Venn mostrando Θ ⊆ O e Θ ⊆ Ω.",
                                    "Teste com exemplos: f(n) = 3n^2 + 2n ∈ Θ(n^2), verifique O(n^2) e Ω(n^2).",
                                    "Escreva a implicação formal: f ∈ Θ(g) ⇒ f ∈ O(g) ∧ f ∈ Ω(g)."
                                  ],
                                  "verification": "Forneça prova escrita curta e classifique corretamente 5 funções em relação a g(n) = n log n.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno para provas, software como Desmos para plotar funções.",
                                  "tips": "Lembre-se: Θ é 'tight bound' (apertado), O é upper (superior), Ω é lower (inferior).",
                                  "learningObjective": "Dominar as implicações lógicas e matemáticas entre as notações.",
                                  "commonMistakes": "Achar que O implica Θ (não é tight); inverter O e Ω."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Casos de Ω Estrita (Lower Bound sem Upper Correspondente)",
                                  "subSteps": [
                                    "Defina Ω estrita: f(n) ∈ Ω(g(n)) mas f(n) ∉ O(g(n)), significando crescimento pelo menos g(n) mas potencialmente mais rápido.",
                                    "Exemplo: f(n) = n^2 ∈ Ω(n) (pois n^2 ≥ c*n para c=1, n≥1), mas f(n) ∉ O(n) (cresce mais rápido).",
                                    "Outro exemplo: f(n) = 2^n ∈ Ω(n^100) (exponencial domina polinomial), mas não O(n^100).",
                                    "Compare com Θ: Em Θ, bounds são equivalentes assintoticamente.",
                                    "Crie tabela comparando O, Ω, Θ para funções comuns."
                                  ],
                                  "verification": "Forneça 3 exemplos onde f ∈ Ω(g) mas não ∈ O(g), com justificativa lim (f/g) = ∞.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela de complexidades (O(1), O(n), etc.), Python para plotar ou calcular limites.",
                                  "tips": "Use limite superior infinito para confirmar não-O: lim (n→∞) f(n)/g(n) = ∞.",
                                  "learningObjective": "Reconhecer cenários onde apenas lower bound aplica, sem tight ou upper.",
                                  "commonMistakes": "Confundir com O estrita (f ∈ O(g) mas não Θ(g)); exemplos errados como polinomiais iguais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Sintetizar Conhecimentos com Exercícios Práticos",
                                  "subSteps": [
                                    "Resolva problemas: Dado f(n) ∈ Θ(n^2), prove ∈ Ω(n^2) e O(n^2).",
                                    "Identifique em código: Análise de merge sort (Θ(n log n)) vs. worst-case quicksort (O(n^2) mas Ω(n log n)).",
                                    "Crie contraexemplo: Função em Ω(n) mas não Θ(n).",
                                    "Discuta propriedades: Transitividade e simetria em Ω.",
                                    "Revise tudo com quiz autoavaliado."
                                  ],
                                  "verification": "Resolva 5 exercícios mistos corretamente, incluindo provas e classificações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exercícios impressos ou online (LeetCode, GeeksforGeeks), timer.",
                                  "tips": "Sempre pergunte: Há lower e upper bounds iguais? Se sim, Θ.",
                                  "learningObjective": "Integrar conceitos para análise fluida de complexidades.",
                                  "commonMistakes": "Ignorar casos assintóticos (foco em pequenos n); confundir notações em algoritmos reais."
                                }
                              ],
                              "practicalExample": "Ao analisar quicksort: No pior caso, T(n) ∈ Ω(n^2) (lower bound devido a partições ruins), mas não Θ(n^2) em geral, pois média é Θ(n log n). Isso mostra Ω estrita sem upper correspondente no pior caso.",
                              "finalVerifications": [
                                "Explicar verbalmente por que Θ(g) implica O(g) e Ω(g).",
                                "Classificar corretamente f(n) = n^3 + n ∈ Θ(n^3), O(n^3), Ω(n^3).",
                                "Identificar exemplo de f ∈ Ω(n log n) mas ∉ O(n log n), como 2^n.",
                                "Provar lim (n→∞) (n^2 / n) = ∞, confirmando n^2 ∉ O(n).",
                                "Desenhar diagrama de Venn preciso de O, Ω, Θ.",
                                "Analisar complexidade de um algoritmo simples usando as relações."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (100% correto).",
                                "Provas lógicas claras e concisas para implicações.",
                                "Identificação correta de 80%+ exemplos de Ω estrita.",
                                "Uso adequado de limites para verificações assintóticas.",
                                "Aplicação coerente em contextos algorítmicos reais.",
                                "Ausência de confusões entre upper/lower bounds."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e assintóticos (Cálculo I/II).",
                                "Matemática Discreta: Relações de ordem e funções crescentes.",
                                "Engenharia de Software: Otimização de performance e profiling.",
                                "Física: Modelagem de crescimento exponencial vs. polinomial em simulações."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, use para provar que um algoritmo de busca é pelo menos linear Ω(n) no pior caso (sem upper tight), guiando escolhas como índices para evitar cenários onde lower bound domina sem otimização."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Verificar pertença usando limites",
                            "description": "Usar o limite lim (n→∞) g(n)/f(n) ≥ c > 0 para provar que g(n) ∈ Ω(f(n)), e refutar casos onde o limite é zero.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Teorema do Limite para Notação Big-Ω",
                                  "subSteps": [
                                    "Revise a definição formal de g(n) ∈ Ω(f(n)): existe c > 0 e n0 tal que para todo n ≥ n0, g(n) ≥ c * f(n).",
                                    "Estude o teorema: se lim (n→∞) g(n)/f(n) = L onde L ≥ c > 0 (ou ∞), então g(n) ∈ Ω(f(n)).",
                                    "Aprenda que se o limite for 0, isso refuta a pertença (não prova Ω, mas pode indicar Θ ou o outro).",
                                    "Identifique funções comuns: polinomiais, exponenciais, logarítmicas.",
                                    "Anote exemplos iniciais: n^2 / n → ∞, logo n^2 ∈ Ω(n)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o teorema e dê um exemplo correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, notas de aula sobre notações assintóticas, calculadora simbólica (opcional).",
                                  "tips": "Lembre-se: limite ≥ c > 0 prova Ω; ∞ conta como limite positivo infinito.",
                                  "learningObjective": "Compreender a base teórica do teste de limite para Big-Ω.",
                                  "commonMistakes": "Confundir com Big-O (limite ≤ c prova O, não Ω); ignorar ∞ como limite válido."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Limites de Razões g(n)/f(n)",
                                  "subSteps": [
                                    "Escolha pares de funções: ex. g(n)=n^2+ n, f(n)=n.",
                                    "Simplifique a razão: (n^2 + n)/n = n + 1.",
                                    "Aplique regras de limite: lim (n→∞) (n + 1) = ∞.",
                                    "Pratique com logaritmos: lim (n log n)/n = 0 por L'Hôpital.",
                                    "Use ferramentas para casos complexos: Wolfram Alpha para verificação."
                                  ],
                                  "verification": "Calcule 3 limites manualmente e confira com uma calculadora ou software.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora gráfica ou app (Desmos/Wolfram), tabela de limites comuns.",
                                  "tips": "Sempre divida pelo termo dominante; use L'Hôpital para ∞/∞ ou 0/0.",
                                  "learningObjective": "Dominar cálculo de limites assintóticos para funções algorítmicas.",
                                  "commonMistakes": "Esquecer de simplificar antes do limite; tratar ∞ como número finito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar Pertença em Ω(f(n)) Usando Limite Positivo",
                                  "subSteps": [
                                    "Selecione exemplo: prove 2n^2 ∈ Ω(n^2). Razão: 2n^2 / n^2 = 2 → 2 ≥ 1 > 0.",
                                    "Escreva prova formal: lim = 2 > 0, logo existe c=1, n0=1 satisfazendo a def.",
                                    "Teste caso ∞: n! / 2^n → ∞? Não, mas para Stirling approx. pratique n^2 / log n → ∞.",
                                    "Documente: função, razão, limite, conclusão.",
                                    "Repita para 3 exemplos variados."
                                  ],
                                  "verification": "Escreva provas completas para 2 exemplos e autoavalie correção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de exercícios com pares de funções, editor de texto.",
                                  "tips": "Escolha c menor que L para segurança; prove bidirecional se suspeitar Θ.",
                                  "learningObjective": "Aplicar teorema para provar corretamente pertença em Ω.",
                                  "commonMistakes": "Afirmar prova se limite finito mas <0 (impossível para funções positivas); omitir n0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refutar Pertença Quando Limite é Zero",
                                  "subSteps": [
                                    "Exemplo refutação: n ∈ Ω(n^2)? lim n/n^2 = 1/n → 0, não ≥ c>0.",
                                    "Explique: limite 0 implica para qualquer c>0, existe n grande com g(n) < c f(n), violando def.",
                                    "Pratique: log n ∈ Ω(n)? lim (log n)/n = 0 → refutado.",
                                    "Contraexemplo: encontre n onde g(n) << f(n).",
                                    "Compare com Big-O: aqui prova o(n^2), mas não Ω."
                                  ],
                                  "verification": "Refute 2 casos com limite 0 e justifique por que não é Ω.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Lista de funções comuns em algoritmos, software de plotagem.",
                                  "tips": "Limite 0 refuta Ω mas não prova nada sobre O; sempre cheque positividade.",
                                  "learningObjective": "Saber refutar incorretamente classificações usando limite zero.",
                                  "commonMistakes": "Pensar que limite 0 prova o(f(n)); confundir refutação com prova negativa completa."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Integrar com Exercícios Mistos",
                                  "subSteps": [
                                    "Resolva 5 problemas mistos: 3 provas, 2 refutações.",
                                    "Ex: Prove n^3 ∈ Ω(n^2 log n)? lim n^3 / (n^2 log n) = ∞.",
                                    "Avalie pares ambíguos: use mais testes se limite indefinido.",
                                    "Crie seu próprio par e resolva.",
                                    "Revise erros dos passos anteriores."
                                  ],
                                  "verification": "Acertar 90% em quiz de 10 questões similares.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exercícios impressos ou online (LeetCode asymptotics), timer.",
                                  "tips": "Varie funções: inclua fatoriais, exponenciais para desafio.",
                                  "learningObjective": "Consolidar habilidade através de prática integrada.",
                                  "commonMistakes": "Ignorar constantes; não considerar n→∞ adequadamente."
                                }
                              ],
                              "practicalExample": "Provar que o tempo de um algoritmo de ordenação por inserção T(n) = n^2/2 ∈ Ω(n^2): lim (n^2/2)/n^2 = 1/2 > 0, logo sim. Refutar T(n)=n log n ∈ Ω(n^2): lim (n log n)/n^2 = 0, não pertence.",
                              "finalVerifications": [
                                "Calcula corretamente limite para 5 pares de funções diferentes.",
                                "Escreve prova formal de Ω para limite positivo ou ∞.",
                                "Refuta adequadamente 3 casos com limite 0, explicando violação da definição.",
                                "Identifica erros em provas fornecidas.",
                                "Aplica a pares reais de complexidades algorítmicas.",
                                "Discute limitações do teste (ex: oscilações)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de limites (100% correto).",
                                "Clareza na redação de provas formais (inclui c, n0).",
                                "Correta interpretação: positivo/∞=prova, 0=refutação.",
                                "Uso de simplificações adequadas e regras de limite.",
                                "Capacidade de lidar com funções não-polinomiais.",
                                "Identificação de common mistakes em exemplos alheios."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo: Regras de L'Hôpital e limites ao infinito.",
                                "Matemática Discreta: Funções geradoras e assintóticas.",
                                "Estatística: Análise de crescimento de dados em ML.",
                                "Física Computacional: Modelagem de simulações complexas."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, usar para provar limites inferiores de tempo/espaço, como mostrar que QuickSort é Ω(n log n) no pior caso, auxiliando na escolha de algoritmos escaláveis em software de big data."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Aplicações e Exemplos Práticos de Big-Ω",
                        "description": "Uso da notação Big-Ω na análise de algoritmos para estabelecer limites inferiores no tempo de execução ou espaço, com exemplos concretos de funções comuns.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Provar Ω para funções polinomiais",
                            "description": "Mostrar que n² ∈ Ω(n) provando a existência de c=1 e n₀=1, pois n² ≥ 1·n para n≥1, e estender para funções como 3n² + 2n ∈ Ω(n²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal de Notação Big-Ω",
                                  "subSteps": [
                                    "Leia a definição exata: f(n) ∈ Ω(g(n)) se existem constantes c > 0 e n₀ ≥ 0 tais que para todo n ≥ n₀, 0 ≤ c · g(n) ≤ f(n).",
                                    "Identifique os elementos chave: função f(n) (limite inferior), g(n) (referência), constante c e ponto inicial n₀.",
                                    "Escreva a definição em suas próprias palavras e desenhe um gráfico ilustrando f(n) acima de c·g(n) para n ≥ n₀.",
                                    "Compare com Big-O: Ω é lower bound (mínimo), O é upper bound (máximo).",
                                    "Resolva um exercício simples: verifique se n ∈ Ω(1)."
                                  ],
                                  "verification": "Escreva a definição corretamente e prove n ∈ Ω(1) com c=1, n₀=1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas de análise de algoritmos",
                                    "Calculadora gráfica opcional"
                                  ],
                                  "tips": "Foquem em desigualdades: f(n) deve crescer pelo menos tão rápido quanto c·g(n).",
                                  "learningObjective": "Dominar a definição precisa de Big-Ω e diferenciá-la de outras notações assintóticas.",
                                  "commonMistakes": [
                                    "Confundir Ω com O (invertendo bounds)",
                                    "Esquecer a condição n ≥ n₀",
                                    "Usar c ≤ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que n² ∈ Ω(n)",
                                  "subSteps": [
                                    "Escolha c = 1 e n₀ = 1 como sugerido.",
                                    "Verifique a desigualdade: para n ≥ 1, n² ≥ 1 · n? Simplifique: n² - n ≥ 0 → n(n - 1) ≥ 0, verdadeiro para n ≥ 1.",
                                    "Escreva a prova formal: 'Existem c=1 >0 e n₀=1 tal que ∀n≥1, n² ≥ 1·n'.",
                                    "Teste valores: n=1 (1≥1), n=2 (4≥2), n=10 (100≥10).",
                                    "Desenhe gráficos de n² e n para visualizar o bound."
                                  ],
                                  "verification": "Escreva a prova completa e teste com 3 valores de n ≥ n₀.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para cálculos",
                                    "Software como Desmos para gráficos"
                                  ],
                                  "tips": "Sempre teste a desigualdade nos pontos críticos como n=n₀.",
                                  "learningObjective": "Aplicar a definição para provar um caso simples de polinomial quadrático sobre linear.",
                                  "commonMistakes": [
                                    "Escolher n₀=0 (n² < n para n<1)",
                                    "Não justificar por que a desigualdade holds para todo n≥n₀",
                                    "Omitir c>0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalizar a Prova para Funções Polinomiais",
                                  "subSteps": [
                                    "Entenda que para polinomiais, o termo de maior grau domina assintoticamente.",
                                    "Para f(n) = a_k n^k + ... ∈ Ω(n^m) onde k ≥ m, escolha c = a_k / 2, n₀ grande o suficiente para dominância.",
                                    "Prove genericamente: |f(n) - a_k n^k| ≤ (1/2) a_k n^k para n grande, então f(n) ≥ (1/2) a_k n^k ≥ c n^m.",
                                    "Aplique a n³ ∈ Ω(n²): c=1, n₀=1 (n³ ≥ n² para n≥1).",
                                    "Exercício: Prove 5n² + 3n ∈ Ω(n²)."
                                  ],
                                  "verification": "Escreva prova genérica e prove o exercício fornecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Livro de CLRS (Capítulo de Assintóticas)"
                                  ],
                                  "tips": "Ignore termos de graus menores para grandes n; foque no leading term.",
                                  "learningObjective": "Generalizar provas de Big-Ω para qualquer polinomial baseado no grau dominante.",
                                  "commonMistakes": [
                                    "Não escolher n₀ grande o suficiente para dominância",
                                    "Confundir graus (k < m falha)",
                                    "Esquecer fator positivo no leading coefficient"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Exemplo Específico: 3n² + 2n ∈ Ω(n²)",
                                  "subSteps": [
                                    "Identifique leading term: 3n², então mire c relacionado a 3.",
                                    "Escolha c=1, procure n₀ tal que 3n² + 2n ≥ 1·n² para n≥n₀ → 2n² + 2n ≥ 0 (sempre verdadeiro para n≥1).",
                                    "Ou c=2: 3n² + 2n ≥ 2n² → n² + 2n ≥ 0 (n₀=1).",
                                    "Escreva prova formal com c=1, n₀=1.",
                                    "Teste: n=1 (5≥1), n=5 (80≥25)."
                                  ],
                                  "verification": "Escreva prova com c, n₀ e verifique 5 valores de n.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha para testes numéricos"
                                  ],
                                  "tips": "Simplifique rearranjando: f(n) - c g(n) ≥ 0.",
                                  "learningObjective": "Executar prova completa para polinomial não-mono com termos inferiores.",
                                  "commonMistakes": [
                                    "c muito grande (desigualdade falha)",
                                    "n₀ inadequado",
                                    "Não testar numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de um algoritmo de multiplicação de matrizes ingênuo O(n³), prove que tempo T(n) = 2n³ + 5n² ∈ Ω(n³) com c=1, n₀=1 (2n³ + 5n² ≥ n³ → n³ + 5n² ≥ 0).",
                              "finalVerifications": [
                                "Pode definir Big-Ω e provar n² ∈ Ω(n) sem olhar notas?",
                                "Generaliza corretamente para polinomiais de graus diferentes?",
                                "Prova 3n² + 2n ∈ Ω(n²) com c e n₀ explícitos?",
                                "Identifica erros em provas fornecidas incorretas?",
                                "Aplica a um exemplo de algoritmo real?",
                                "Diferencia Ω de O em contextos práticos?"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na escolha de c > 0 e n₀.",
                                "Justificativa completa da desigualdade para todo n ≥ n₀.",
                                "Uso apropriado de simplificações assintóticas (dominância de termos).",
                                "Testes numéricos e gráficos para suporte visual.",
                                "Clareza na escrita da prova formal.",
                                "Generalização precisa para classes de funções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e limites.",
                                "Engenharia de Software: Análise de performance de algoritmos.",
                                "Física: Modelagem de crescimento exponencial vs. polinomial em simulações.",
                                "Economia: Análise de custo mínimo em escalabilidade de sistemas."
                              ],
                              "realWorldApplication": "Ao projetar algoritmos eficientes, como em machine learning, provar que o tempo de treinamento T(n) ∈ Ω(n²) garante planejamento de recursos mínimos para datasets grandes, evitando subestimações em sistemas distribuídos como Spark ou TensorFlow."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Analisar algoritmos com lower bounds",
                            "description": "Estabelecer que o algoritmo de busca linear tem tempo T(n) ∈ Ω(n), pois em pior caso deve examinar pelo menos n elementos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Lower Bound e Notação Big-Ω",
                                  "subSteps": [
                                    "Defina lower bound como o limite inferior teórico para o tempo de execução de um algoritmo.",
                                    "Explique que T(n) ∈ Ω(g(n)) significa que o tempo de execução é pelo menos proporcional a g(n) para grandes n.",
                                    "Diferencie de upper bound (Big-O) e tight bound (Theta).",
                                    "Estude exemplos simples como comparação de elementos.",
                                    "Revise propriedades matemáticas da notação assintótica."
                                  ],
                                  "verification": "Escreva uma definição precisa de Ω(n) e dê um exemplo não relacionado à busca linear.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Algoritmos (ex: CLRS), capítulo de análise assintótica",
                                    "Folha de papel e caneta"
                                  ],
                                  "tips": "Use analogias como 'mínimo de passos para atravessar uma ponte longa'.",
                                  "learningObjective": "Compreender formalmente lower bounds e sua representação com Big-Ω.",
                                  "commonMistakes": "Confundir Ω com O, achando que Ω é upper bound em vez de lower bound."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Algoritmo de Busca Linear",
                                  "subSteps": [
                                    "Descreva o pseudocódigo da busca linear: percorrer array sequencialmente até encontrar o elemento.",
                                    "Identifique entradas: array não ordenado de n elementos e chave de busca.",
                                    "Calcule o número de comparações no melhor caso (1) e caso médio (~n/2).",
                                    "Foque no pior caso: elemento não presente ou no final.",
                                    "Conte operações básicas (acessos a memória, comparações)."
                                  ],
                                  "verification": "Implemente ou simule busca linear em um array de 10 elementos e registre comparações no pior caso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código ou simulador online (ex: Python IDLE)",
                                    "Array de teste: [3,7,1,9,4] buscando 2"
                                  ],
                                  "tips": "Sempre anote o contador de iterações durante a simulação.",
                                  "learningObjective": "Mapear o comportamento do algoritmo de busca linear em diferentes casos.",
                                  "commonMistakes": "Ignorar custos de acessos a índices ou assumir array ordenado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer o Argumento de Lower Bound para o Pior Caso",
                                  "subSteps": [
                                    "Argumente adversarialmente: para provar presença/ausência, verifique todos n elementos no pior caso.",
                                    "Prove por contradição: se menos de n verificações, existe um elemento não checado que poderia ser a chave.",
                                    "Formalize: qualquer algoritmo de busca em estrutura não ordenada requer Ω(n) no pior caso.",
                                    "Compare com pigeonhole principle para solidificar o argumento.",
                                    "Discuta generalização para problemas de busca em listas não ordenadas."
                                  ],
                                  "verification": "Escreva uma prova curta (3-5 linhas) mostrando por que <n verificações falham.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para prova por contradição",
                                    "Exemplos de arrays pequenos (n=3, n=4)"
                                  ],
                                  "tips": "Pense como um 'adversário' que escolhe a posição da chave para maximizar trabalho.",
                                  "learningObjective": "Construir argumento lógico para lower bound baseado em informação teórica.",
                                  "commonMistakes": "Aplicar argumento a casos médios em vez de pior caso; esquecer estruturas não ordenadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar T(n) ∈ Ω(n) e Verificar",
                                  "subSteps": [
                                    "Escreva T(n) ≥ c*n para algum c>0 e n≥n0, provando Ω(n).",
                                    "Use contagens exatas do Step 2 para escolher c (ex: c=1 para comparações).",
                                    "Gere gráficos ou tabela de T(n)/n para n=10,100,1000 simulando.",
                                    "Discuta implicações: busca linear é ótima para não ordenado.",
                                    "Teste com código real medindo tempo."
                                  ],
                                  "verification": "Produza equação formal e gráfico mostrando T(n)/n constante ou crescente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou Python para plotar (matplotlib)",
                                    "Código de busca linear com timer"
                                  ],
                                  "tips": "Use n grandes para assintótica, mas valide com pequenos para intuição.",
                                  "learningObjective": "Formalizar lower bound matematicamente e validá-lo empiricamente.",
                                  "commonMistakes": "Escolher c inválido (muito grande); confundir com Big-O do algoritmo."
                                }
                              ],
                              "practicalExample": "Considere buscar o número 42 em uma lista não ordenada de 100 nomes de alunos [Ana, João, ..., Pedro]. No pior caso (42 não presente), o algoritmo verifica todos 100, provando T(100) ≥ 100 comparações, logo T(n) ∈ Ω(n).",
                              "finalVerifications": [
                                "Prova escrita confirma que qualquer algoritmo requer pelo menos n verificações no pior caso.",
                                "Simulação em código mostra T(n) ≥ 0.5n em testes com n=50,100,500.",
                                "Gráfico de T(n)/n estabiliza acima de constante positiva.",
                                "Explicação oral correta diferencia lower bound de upper bound.",
                                "Generalização correta para outros problemas lineares.",
                                "Identificação de cenários onde lower bound é tight (Theta)."
                              ],
                              "assessmentCriteria": [
                                "Precisão do argumento adversarial (deve cobrir contradição).",
                                "Correção matemática da definição Ω(n) com constantes c e n0.",
                                "Validação empírica com simulações múltiplas.",
                                "Clareza na distinção de pior caso vs. médio/melhor.",
                                "Capacidade de generalizar para algoritmos similares.",
                                "Ausência de confusões com notações Big-O ou Theta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por contradição e princípio da casa dos pombos.",
                                "Lógica e Filosofia: Argumentação adversarial e limites teóricos.",
                                "Estatística: Análise de casos extremos e distribuições uniformes.",
                                "Engenharia de Software: Implicações em design de dados (hash vs. linear)."
                              ],
                              "realWorldApplication": "Em bancos de dados sem índices (ex: logs de logs não estruturados), analisar busca linear justifica custo de indexação; otimiza decisões em apps mobile com memória limitada onde ordenar custa O(n log n)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Construir contraexemplos para refutação",
                            "description": "Refutar afirmações falsas como log n ∈ Ω(n), mostrando que para qualquer c>0, existe n grande onde log n < c n não segura (limite =0).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal de Notação Big-Ω",
                                  "subSteps": [
                                    "Leia e memorize a definição: f(n) ∈ Ω(g(n)) se ∃ c > 0 e n₀ tal que ∀ n ≥ n₀, f(n) ≥ c · g(n).",
                                    "Identifique os quantificadores: 'existe c > 0' e 'para todo n grande'.",
                                    "Discuta com exemplos verdadeiros, como n ∈ Ω(n) com c=1.",
                                    "Anote contraexemplos intuitivos onde funções crescem mais devagar, como constantes em Ω(n).",
                                    "Desenhe um gráfico comparando funções para visualizar o conceito."
                                  ],
                                  "verification": "Escreva a definição de Ω de memória e explique verbalmente um exemplo verdadeiro e um falso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, acesso a um recurso online sobre notação assintótica (ex: CLRS capítulo 3).",
                                  "tips": "Foque nos quantificadores ∀ e ∃; eles são cruciais para contraexemplos.",
                                  "learningObjective": "Compreender precisamente quando uma afirmação de Ω é verdadeira ou falsa.",
                                  "commonMistakes": "Confundir Ω com O (Ω é limite inferior, O é superior); ignorar 'para todo n grande'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Comportamento Assintótico Relativo de log n e n",
                                  "subSteps": [
                                    "Calcule o limite lim (n→∞) log n / n = 0 usando L'Hôpital ou conhecimento prévio.",
                                    "Plote log n e n para n de 1 a 1000 para visualizar que log n cresce muito mais devagar.",
                                    "Teste numericamente: para c=1, encontre n onde log₂ n < n (sempre verdadeiro para n>1).",
                                    "Generalize: como limite=0, log n / n → 0, então log n = o(n).",
                                    "Registre valores: log₂(1000)≈10 vs 1000; log₂(1e6)≈20 vs 1e6."
                                  ],
                                  "verification": "Mostre cálculos do limite e um gráfico ou tabela numérica provando log n << n.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou Python/Jupyter para plots (matplotlib), papel para limite.",
                                  "tips": "Use log base 2 para CS; lembre que qualquer log é o(qualquer polinômio).",
                                  "learningObjective": "Reconhecer que limite f/g → 0 implica f ∉ Ω(g).",
                                  "commonMistakes": "Usar log natural vs base 2 (não importa assintoticamente); esquecer n→∞."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Contraexemplo Formal",
                                  "subSteps": [
                                    "Assuma por contradição: suponha ∃ c>0 tal que ∀ n≥n₀, log n ≥ c n.",
                                    "Como lim log n / n =0, ∀ c>0, ∃ n₁ tal que ∀ n≥n₁, log n / n < c, i.e., log n < c n.",
                                    "Escolha n₁ > n₀ arbitrário; então para n=max(n₀,n₁), contradição.",
                                    "Formalize: Para qualquer c>0, defina n₁ tal que log n₁ / n₁ < c; então log n₁ < c n₁ viola a suposição.",
                                    "Escreva a prova em notação ε-δ adaptada para assintótica."
                                  ],
                                  "verification": "Escreva uma prova curta (3-5 linhas) mostrando que nenhum c funciona.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para prova, editor de texto ou LaTeX online para formalizar.",
                                  "tips": "Comece com 'para todo c>0' e use o limite diretamente para existir n grande.",
                                  "learningObjective": "Construir prova por contradição usando limites para refutar Ω.",
                                  "commonMistakes": "Esquecer 'para todo c>0'; confundir com prova existencial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Apresentar o Contraexemplo",
                                  "subSteps": [
                                    "Teste com c específico: c=0.1, encontre n onde log₂ n < 0.1 n (ex: n=100, log≈6.6 <10).",
                                    "Generalize para qualquer c: resolva n > (log n)/c iterativamente.",
                                    "Escreva um parágrafo resumindo a refutação.",
                                    "Crie um slide ou diagrama visualizando o contraexemplo.",
                                    "Discuta implicações: log n = O(n^ε) para ε>0, mas não Ω(n)."
                                  ],
                                  "verification": "Apresente a refutação oralmente ou em escrita, respondendo perguntas sobre c arbitrário.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software de plot (Desmos ou Python), timer para testes numéricos.",
                                  "tips": "Sempre teste numericamente antes de formalizar; ajuda a intuir.",
                                  "learningObjective": "Validar contraexemplos numericamente e formalmente.",
                                  "commonMistakes": "Achar que um c falha basta (não: precisa para todo c)."
                                }
                              ],
                              "practicalExample": "Para refutar 'n log n ∈ Ω(n²)': mostre lim (n log n)/n² =0. Para c=1, log n < n para n grande (fácil de ver), formalize com limite.",
                              "finalVerifications": [
                                "Pode escrever a definição de Ω sem erros.",
                                "Calcula corretamente lim log n / n =0.",
                                "Constrói prova por contradição para qualquer c>0.",
                                "Fornece n explícito para c dado (ex: c=0.01, n=1e6).",
                                "Explica verbalmente por que log n ∉ Ω(n).",
                                "Identifica função correta: log n ∈ Ω(1), mas o(n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de Ω (quantificadores corretos).",
                                "Correto uso de limite para mostrar violação.",
                                "Formalização clara do contraexemplo (para todo c).",
                                "Evidências numéricas/gráficas de suporte.",
                                "Ausência de erros lógicos (ex: confusão com Big-O).",
                                "Clareza na apresentação da refutação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e provas por contradição.",
                                "Lógica: Quantificadores universais e existenciais em provas.",
                                "Física: Comparação de crescimento em modelos de escala (ex: tempo vs tamanho).",
                                "Filosofia: Refutação de conjecturas por contraexemplos."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, refuta claims errados como 'busca binária (O(log n)) é tão ruim quanto linear scan (Ω(n)) no pior caso', guiando escolha de algoritmos eficientes em software real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.4",
                            "name": "Usar Ω em comparações de ordem de crescimento",
                            "description": "Classificar funções como n!, 2^n, n^log n em termos de Ω, provando hierarquias como 2^n ∈ Ω(n^k) para qualquer k constante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal e Intuitiva de Big-Ω",
                                  "subSteps": [
                                    "Estude a definição: f(n) ∈ Ω(g(n)) iff existem constantes c > 0 e n₀ tal que 0 ≤ c · g(n) ≤ f(n) para todo n ≥ n₀",
                                    "Compare com Big-O (upper bound) e Big-Θ (tight bound), destacando que Ω foca em lower bounds",
                                    "Analise exemplos simples: prove que n² ∈ Ω(n) usando c=1 e n₀=1",
                                    "Visualize graficamente o crescimento para funções como log n e n",
                                    "Pratique reescrevendo desigualdades em termos de Ω"
                                  ],
                                  "verification": "Escreva a definição em suas palavras e prove um exemplo básico como 2n ∈ Ω(n)",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Capítulo de CLRS sobre notação assintótica",
                                    "Khan Academy: Análise Assintótica",
                                    "Papel e lápis para gráficos"
                                  ],
                                  "tips": [
                                    "Lembre-se: Ω significa 'pelo menos tão grande quanto' assintoticamente",
                                    "Use gráficos para intuição inicial"
                                  ],
                                  "learningObjective": "Definir precisamente Big-Ω e diferenciá-la de O e Θ com exemplos",
                                  "commonMistakes": [
                                    "Confundir Ω com O (invertendo bounds)",
                                    "Esquecer a existência de c > 0 e n₀",
                                    "Ignorar o termo 0 ≤"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Técnicas de Prova para Relações Big-Ω",
                                  "subSteps": [
                                    "Aprenda prova por limites: se lim inf f(n)/g(n) = L > 0, então f ∈ Ω(g)",
                                    "Estude indução matemática para funções exponenciais e polinomiais",
                                    "Pratique manipulação algébrica: expanda e isole termos dominantes",
                                    "Use desigualdades conhecidas como Stirling para n! ≈ √(2πn) (n/e)^n",
                                    "Aplique L'Hôpital para limites indeterminados em comparações"
                                  ],
                                  "verification": "Prove usando limite que n log n ∈ Ω(n) e verifique com valores numéricos",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "CLRS Seção 3.1-3.2",
                                    "Wolfram Alpha para verificar limites",
                                    "Calculadora científica"
                                  ],
                                  "tips": [
                                    "Sempre verifique assintoticamente para n → ∞",
                                    "Comece com casos pequenos para intuição"
                                  ],
                                  "learningObjective": "Aplicar pelo menos duas técnicas de prova (limites e indução) em comparações Ω",
                                  "commonMistakes": [
                                    "Aplicar L'Hôpital incorretamente sem forma ∞/∞",
                                    "Esquecer normalização em limites",
                                    "Não especificar c e n₀ explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar Hierarquia de Funções Comuns Usando Big-Ω",
                                  "subSteps": [
                                    "Liste funções: log n, n, n log n, n^k, 2^n, n!, e ordene-as assintoticamente",
                                    "Prove pairwise: ex. 2^n ∈ Ω(n log n), n! ∈ Ω(2^n)",
                                    "Use tabela de crescimento para memorizar: polinomial < exponencial < fatorial",
                                    "Compare n^{log n} com outras: mostre n^{log n} ∈ Ω(n^k) para k fixo",
                                    "Pratique inversões: quando g ∉ Ω(f)"
                                  ],
                                  "verification": "Crie uma tabela classificando 5 funções com provas curtas para cada par",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabela de crescimento assintótico (Wikipedia)",
                                    "Python/Jupyter para plotar log(log n) vs n",
                                    "Folha de exercícios de algoritmos"
                                  ],
                                  "tips": [
                                    "Memorize: qualquer exponencial domina polinomial",
                                    "Use log para simplificar: log(2^n) = n log 2 >> k log n"
                                  ],
                                  "learningObjective": "Classificar corretamente funções comuns em hierarquia Ω",
                                  "commonMistakes": [
                                    "Subestimar fatorial vs exponencial",
                                    "Confundir n^{log n} com (log n)^n",
                                    "Ignorar bases em exponenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Hierarquias Específicas como 2^n ∈ Ω(n^k)",
                                  "subSteps": [
                                    "Prove 2^n ∈ Ω(n^k) por indução: base n=1, passo assume para n, mostra para 2n",
                                    "Use limite: lim (2^n / n^k) = ∞ > 0, logo ∈ Ω",
                                    "Generalize para qualquer base b>1 e polinômio",
                                    "Aplique a n!: mostre n! ∈ Ω(2^n) via série de Stirling ou indução",
                                    "Teste com k grande: ex. 2^n vs n^{100}"
                                  ],
                                  "verification": "Escreva prova completa para 2^n ∈ Ω(n^{100}) com c e n₀ explícitos",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "CLRS Exercícios 3.1",
                                    "ProofWiki: Big Omega Notation",
                                    "SymPy para limites simbólicos"
                                  ],
                                  "tips": [
                                    "Indução em potências de 2 simplifica",
                                    "Escolha n₀ grande o suficiente para dominância"
                                  ],
                                  "learningObjective": "Provar hierarquias chave como exponencial domina polinomial em Ω",
                                  "commonMistakes": [
                                    "Falhar na hipótese indutiva para exponenciais",
                                    "Não lidar com k não-inteiro",
                                    "Confundir ∈ Ω com ∈ O"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Aplicações e Verificações Integradas",
                                  "subSteps": [
                                    "Resolva problemas: classifique f(n) = 3^n + n^5 em Ω",
                                    "Compare n! e 2^n: prove n! ∈ Ω(2^n)",
                                    "Crie contraexemplos: mostre n^k ∉ Ω(2^n)",
                                    "Integre com Big-O: discuta Θ quando aplicável",
                                    "Revise todas provas anteriores"
                                  ],
                                  "verification": "Resolva 3 problemas independentes e autoavalie",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exercícios de LeetCode/HackerRank em complexidade",
                                    "Anki para flashcards de hierarquias"
                                  ],
                                  "tips": [
                                    "Sempre pergunte: 'É lower bound?'",
                                    "Pratique verbalizando provas"
                                  ],
                                  "learningObjective": "Aplicar Ω fluentemente em classificações e provas",
                                  "commonMistakes": [
                                    "Overgeneralizar sem prova",
                                    "Misturar notações em problemas mistos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de algoritmo de backtracking para TSP (Traveling Salesman Problem), prove que o tempo T(n) ∈ Ω(2^n / n) usando Ω para lower bound exponencial, mostrando que brute-force não pode ser polinomial.",
                              "finalVerifications": [
                                "Classifique corretamente: n! ∈ Ω(2^n) ∈ Ω(n^{log n}) ∈ Ω(n^k)",
                                "Prove 2^n ∈ Ω(n^k) para qualquer k constante com c e n₀ explícitos",
                                "Identifique erro em prova falha: ex. lim n^k / 2^n = 0 implica n^k ∉ Ω(2^n)",
                                "Compare n^{log n} vs 2^n usando logaritmos",
                                "Aplique em exemplo real: lower bound para SAT solver",
                                "Crie tabela hierárquica com 6 funções"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: desigualdades corretas e limites/indução válidos",
                                "Especificidade: c > 0 e n₀ sempre definidos",
                                "Completude: todos passos da prova presentes sem lacunas",
                                "Clareza: notação consistente e explicações lógicas",
                                "Generalização: aplica a famílias de funções (ex. qualquer k)",
                                "Criatividade: usa múltiplas técnicas quando possível"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo (limites, indução, séries de Stirling)",
                                "Física: Modelos de crescimento populacional/decay exponencial",
                                "Economia: Análise de custo em otimização combinatória",
                                "Engenharia: Dimensionamento de sistemas (hardware limits por complexidade)"
                              ],
                              "realWorldApplication": "Na criptografia, prova que quebrar RSA requer Ω(2^{k/2}) tempo via lower bounds em fatoração, guiando escolhas de tamanho de chave e justificando por que algoritmos eficientes são improváveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Notação Big-Θ",
                    "description": "Definição e uso da notação Θ(f(n)) para limites superior e inferior assintóticos apertados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Definição Formal da Notação Big-Θ",
                        "description": "Compreensão da definição matemática precisa da notação Θ(f(n)), que descreve funções com limites assintóticos superior e inferior apertados.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Reconhecer a definição de Θ(f(n))",
                            "description": "Identificar que g(n) = Θ(f(n)) se existem constantes c1, c2 > 0 e n0 tal que para todo n ≥ n0, c1 f(n) ≤ g(n) ≤ c2 f(n), representando crescimento assintótico idêntico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Pré-requisitos de Notações Assintóticas",
                                  "subSteps": [
                                    "Relembre a definição de Big-O: g(n) = O(f(n)) se existem c>0 e n0 tal que g(n) ≤ c f(n) para n ≥ n0.",
                                    "Relembre a definição de Big-Ω: g(n) = Ω(f(n)) se existem c>0 e n0 tal que g(n) ≥ c f(n) para n ≥ n0.",
                                    "Entenda que Θ combina ambos os limites superior e inferior.",
                                    "Compare as três notações com um diagrama mental: O é limite superior, Ω inferior, Θ ambos.",
                                    "Liste funções comuns como n, n log n, n^2 para praticar intuição."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre O, Ω e Θ com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência rápida de notações assintóticas (livro ou PDF)"
                                  ],
                                  "tips": "Use analogias: O é 'no pior caso até', Ω 'no melhor caso pelo menos', Θ 'sempre por volta de'.",
                                  "learningObjective": "Compreender como Θ(f(n)) integra O e Ω para crescimento idêntico.",
                                  "commonMistakes": [
                                    "Confundir Θ com O (Θ é mais restritivo)",
                                    "Ignorar que c1 e c2 devem ser positivos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e Recitar a Definição Formal de Θ(f(n))",
                                  "subSteps": [
                                    "Leia a definição: g(n) = Θ(f(n)) se existem c1, c2 > 0 e n0 tal que para todo n ≥ n0, c1 f(n) ≤ g(n) ≤ c2 f(n).",
                                    "Divida em partes: constantes positivas c1 e c2, ponto n0, desigualdade dupla.",
                                    "Escreva a definição 5 vezes de memória.",
                                    "Cubra a definição e recite em voz alta.",
                                    "Explique o significado: crescimento assintótico idêntico, ignorando constantes e termos inferiores."
                                  ],
                                  "verification": "Recite a definição perfeitamente sem olhar, incluindo todas as condições.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Cartão de memória (flashcard app como Anki)",
                                    "Vídeo curto sobre notação Θ (Khan Academy ou similar)"
                                  ],
                                  "tips": "Associe a símbolo Θ (theta) com 'sanduíche': g(n) espremida entre c1 f(n) e c2 f(n).",
                                  "learningObjective": "Internalizar a definição exata para reconhecimento imediato.",
                                  "commonMistakes": [
                                    "Esquecer 'c1, c2 > 0'",
                                    "Omitir 'para todo n ≥ n0'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dissecar os Componentes da Definição",
                                  "subSteps": [
                                    "Analise c1 e c2: constantes positivas que 'normalizam' g(n) e f(n).",
                                    "Explique n0: ponto a partir do qual a desigualdade vale para todos n maiores.",
                                    "Desenhe gráfico: plote f(n), c1 f(n), c2 f(n) e g(n) para n grande.",
                                    "Discuta 'assintótico': foco em n → ∞, ignorando comportamento para n pequeno.",
                                    "Questione: por que duas constantes? (Para capturar ambos os lados)."
                                  ],
                                  "verification": "Descreva cada componente e seu papel em uma tabela ou parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de plotagem como Desmos ou Python Matplotlib",
                                    "Papel para esboços gráficos"
                                  ],
                                  "tips": "Pense em limites: lim inf g(n)/f(n) >0 e lim sup g(n)/f(n) < ∞.",
                                  "learningObjective": "Entender o papel matemático de cada elemento na definição.",
                                  "commonMistakes": [
                                    "Achar que n0 é fixo para todas funções",
                                    "Confundir com igualdade exata g(n)=f(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Reconhecimento com Exemplos e Contraexemplos",
                                  "subSteps": [
                                    "Pegue g(n)=2n^2 + n: encontre c1=1, c2=3, n0=1 e verifique desigualdade.",
                                    "Teste contraexemplo: g(n)=n^3 não é Θ(n^2), pois cresce mais rápido.",
                                    "Identifique em lista: classifique 5 pares g(n), f(n) como Θ ou não.",
                                    "Prove trivial: n^2 = Θ(n^2) com c1=c2=1, n0=1.",
                                    "Crie seu próprio exemplo e verifique."
                                  ],
                                  "verification": "Resolva 3 exercícios de identificação corretamente, mostrando cálculos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de exercícios impressa ou online (ex: GeeksforGeeks)",
                                    "Calculadora para verificações numéricas"
                                  ],
                                  "tips": "Sempre teste numericamente para n=10,100 para validar.",
                                  "learningObjective": "Aplicar a definição para reconhecer Θ(f(n)) em contextos reais.",
                                  "commonMistakes": [
                                    "Escolher c1 ou c2 que não funcionam para todo n ≥ n0",
                                    "Ignorar termos dominantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para g(n) = 3n^2 + 2n + 1 e f(n) = n^2, escolha c1 = 2, c2 = 6, n0 = 1. Verifique: para n ≥ 1, 2n^2 ≤ 3n^2 + 2n + 1 ≤ 6n^2 (divida por n^2: 2 ≤ 3 + 2/n + 1/n^2 ≤ 6, verdadeiro assintoticamente).",
                              "finalVerifications": [
                                "Recitar a definição completa sem erros.",
                                "Identificar corretamente c1, c2, n0 para um exemplo dado.",
                                "Explicar por que uma função não é Θ de outra.",
                                "Desenhar gráfico ilustrando o 'sanduíche' assintótico.",
                                "Classificar 5 pares de funções como Θ ou não com justificativa.",
                                "Diferenciar Θ de O e Ω em um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na recitação da definição (100% das condições).",
                                "Corretude matemática nas provas de limites (c1, c2 válidos para n ≥ n0).",
                                "Capacidade de identificar contraexemplos intuitivamente.",
                                "Uso correto de gráficos ou testes numéricos para suporte.",
                                "Explicação clara do significado assintótico.",
                                "Aplicação consistente em novos exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e assintóticos em cálculo.",
                                "Física: Ordem de magnitude em escalas de crescimento (ex: forças gravitacionais).",
                                "Engenharia de Software: Otimização de performance de algoritmos.",
                                "Economia: Análise de crescimento exponencial vs polinomial em modelos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, reconhecer que o tempo de um algoritmo de ordenação como Merge Sort é Θ(n log n) permite prever escalabilidade para grandes datasets, guiando escolhas de implementação em sistemas como bancos de dados ou machine learning."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Diferenciar limites superior e inferior assintóticos",
                            "description": "Explicar como Θ(f(n)) combina o limite superior (Big-O) e inferior (Big-Ω) apertados, garantindo que g(n) e f(n) crescem na mesma ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Big-O e Big-Ω",
                                  "subSteps": [
                                    "Leia a definição formal de Big-O: f(n) = O(g(n)) se existem c > 0 e n0 tal que 0 ≤ f(n) ≤ c g(n) para todo n ≥ n0.",
                                    "Leia a definição formal de Big-Ω: f(n) = Ω(g(n)) se existem c > 0 e n0 tal que 0 ≤ c g(n) ≤ f(n) para todo n ≥ n0.",
                                    "Anote as diferenças chave: Big-O é limite superior (f cresce no máximo como g), Big-Ω é limite inferior (f cresce pelo menos como g).",
                                    "Desenhe gráficos simples de funções para visualizar: uma linha acima (O) e abaixo (Ω).",
                                    "Compare com exemplos numéricos para n=10, 100, 1000."
                                  ],
                                  "verification": "Escreva as definições de Big-O e Big-Ω de memória e identifique corretamente qual é superior e qual é inferior.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a notas de aula ou livro de algoritmos (ex: CLRS)",
                                    "Calculadora para valores grandes"
                                  ],
                                  "tips": "Use setas nos gráficos: ↓ para superior (O), ↑ para inferior (Ω).",
                                  "learningObjective": "Dominar as definições formais e intuitivas de limites assintóticos superior e inferior.",
                                  "commonMistakes": [
                                    "Confundir as desigualdades (inverter c g(n) ≤ f(n) com f(n) ≤ c g(n))",
                                    "Ignorar a constante c e n0 na definição formal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Combinação em Big-Θ",
                                  "subSteps": [
                                    "Defina Big-Θ: f(n) = Θ(g(n)) se f(n) = O(g(n)) E f(n) = Ω(g(n)), significando limites apertados.",
                                    "Escreva matematicamente: existem c1, c2 > 0 e n0 tal que c1 g(n) ≤ f(n) ≤ c2 g(n) para n ≥ n0.",
                                    "Visualize como 'sanduíche': g(n) escalada inferior e superior apertando f(n).",
                                    "Prove um exemplo simples: mostre que n² = Θ(n²) encontrando c1=1, c2=1.",
                                    "Discuta por que Θ é mais preciso que O ou Ω isolados."
                                  ],
                                  "verification": "Esboce o 'sanduíche' gráfico para f(n)=2n² e g(n)=n², marcando c1 e c2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos em papel ou ferramenta como Desmos/GeoGebra",
                                    "Referência formal de notação assintótica"
                                  ],
                                  "tips": "Pense em Θ como 'equivalente assintótico' – mesma taxa de crescimento exata.",
                                  "learningObjective": "Compreender como Θ integra superior e inferior para bounds tight.",
                                  "commonMistakes": [
                                    "Achar que Θ requer c1=c2",
                                    "Esquecer que é conjunção AND de O e Ω"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Limites Superior e Inferior em Contextos",
                                  "subSteps": [
                                    "Compare cenários: O permite f crescer mais devagar que g? Não. Ω permite mais rápido? Não.",
                                    "Analise exemplo: n log n = O(n²) (superior frouxo), mas Ω(n) (inferior frouxo); Θ(n log n) é tight.",
                                    "Crie tabela: coluna O (exemplos onde falha Ω), coluna Ω (onde falha O), coluna Θ (ambos).",
                                    "Discuta implicações: O para worst-case upper bound, Ω para best-case lower bound, Θ para tight anytime.",
                                    "Resolva exercício: Diferencie por que 2^n ≠ Θ(n!) mas é O(n!)."
                                  ],
                                  "verification": "Preencha tabela com 3 exemplos para cada coluna corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Lista de funções comuns (n, n², 2^n, n!)"
                                  ],
                                  "tips": "Lembre: superior 'teto', inferior 'piso' – Θ é quando teto e piso se encontram.",
                                  "learningObjective": "Distinguir quando usar cada notação e por que Θ é 'apertado'.",
                                  "commonMistakes": [
                                    "Confundir tight com exato (Θ é assintótico, não igualdade)",
                                    "Aplicar O como tight sem verificar Ω"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Diferenciação",
                                  "subSteps": [
                                    "Escolha f(n)=n² + n; prove O(n²), Ω(n²), logo Θ(n²), destacando diferenças.",
                                    "Teste numericamente: calcule ratios f(n)/g(n) para n grande, veja convergência entre c1 e c2.",
                                    "Crie contraexemplo: f(n)=n se n par, n² se ímpar – não Θ(n) nem Θ(n²).",
                                    "Resuma diferenças em bullet points: superior (upper bound), inferior (lower bound), ambos (tight).",
                                    "Auto-teste com pergunta: 'Qual notação garante crescimento exato?'"
                                  ],
                                  "verification": "Prove Θ para um f(n) dado, identificando explicitamente partes O e Ω.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para simulações numéricas",
                                    "Exemplos de funções polinomiais/exponenciais"
                                  ],
                                  "tips": "Use limite lim f(n)/g(n) = L finito >0 para confirmar Θ.",
                                  "learningObjective": "Aplicar diferenciação em provas e exemplos reais.",
                                  "commonMistakes": [
                                    "Ignorar termos dominantes em polinômios",
                                    "Não testar n→∞"
                                  ]
                                }
                              ],
                              "practicalExample": "Para analisar o algoritmo de ordenação QuickSort, prove que seu tempo é Θ(n log n) em média: mostre Ω(n log n) como lower bound (inferior, pois qualquer comparação-based sort precisa disso) e O(n log n) como upper bound (superior, pela recursão balanceada), diferenciando que sem ambos não é tight.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença entre Big-O (superior) e Big-Ω (inferior).",
                                "Provar Θ(n²) para f(n)=3n² + 2n com c1, c2, n0 explícitos.",
                                "Identificar erro em prova falsa: 'n² = O(n)'.",
                                "Desenhar sanduíche gráfico correto para Θ.",
                                "Classificar 5 funções: qual é O(n²) mas não Ω(n²)?",
                                "Discutir por que Θ é preferido em análise precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais de O, Ω e Θ (100% correto).",
                                "Capacidade de diferenciar superior/inferior em exemplos (sem confusão).",
                                "Provas completas com c, n0 e justificativa assintótica.",
                                "Uso correto de gráficos/tabelas para visualização.",
                                "Identificação de erros comuns em contraexemplos.",
                                "Aplicação em contexto real de algoritmos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Limites e análise assintótica em cálculo.",
                                "Física: Modelagem de complexidade em simulações numéricas.",
                                "Engenharia de Software: Otimização de performance em sistemas.",
                                "Economia: Análise de crescimento em modelos de custo."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usar Θ para garantir que um algoritmo de busca em grafo (ex: Dijkstra) tem complexidade tight Θ(|V| + |E|), diferenciando upper bound para alocação de memória (O) e lower bound para acessos mínimos (Ω), otimizando apps como GPS ou redes sociais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Interpretar Θ(f(n)) em contextos algorítmicos",
                            "description": "Aplicar a definição para descrever o tempo de execução exato de algoritmos, como Θ(n log n) para merge sort.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal de Notação Big-Θ",
                                  "subSteps": [
                                    "Leia a definição: Θ(f(n)) significa que há constantes c1, c2 > 0 e n0 tal que para todo n ≥ n0, c1 * f(n) ≤ g(n) ≤ c2 * f(n).",
                                    "Identifique os componentes: função g(n) (tempo real), f(n) (função teta), limites inferior e superior.",
                                    "Compare com Big-O e Big-Ω para entender que Θ é o 'sanduíche' exato.",
                                    "Anote exemplos matemáticos simples, como Θ(n) para soma linear.",
                                    "Desenhe um gráfico assintótico ilustrando os limites c1 e c2."
                                  ],
                                  "verification": "Escreva a definição de Θ(f(n)) de cor e explique verbalmente os limites para um par ou professor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Acesso a Khan Academy ou CLRS (Capítulo de Análise Assintótica)"
                                  ],
                                  "tips": "Use analogias como 'sanduíche' para lembrar os limites apertados.",
                                  "learningObjective": "Compreender precisamente o que significa 'tempo exato' em Θ(f(n)).",
                                  "commonMistakes": [
                                    "Confundir com Big-O (apenas limite superior)",
                                    "Ignorar as constantes c1 e c2",
                                    "Pensar que Θ ignora constantes (não, elas existem mas são ocultas assintoticamente)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estruturas de Algoritmos Básicos",
                                  "subSteps": [
                                    "Escolha algoritmos simples: soma de array (Θ(n)), busca linear (Θ(n)).",
                                    "Conte o número exato de operações em termos de n (loops, comparações).",
                                    "Ignore constantes de baixo nível (atribuições), foque em dominantes.",
                                    "Escreva T(n) = soma exata e simplifique para Θ(f(n)).",
                                    "Verifique limites: encontre c1, c2 e n0 para validar."
                                  ],
                                  "verification": "Para soma de array, prove que T(n) = n+1 está em Θ(n) com c1=0.5, c2=2, n0=1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código como Python ou pseudocódigo",
                                    "Calculadora para somas"
                                  ],
                                  "tips": "Comece contando operações linha por linha no código.",
                                  "learningObjective": "Mapear código para contagens de operações e simplificar para Θ.",
                                  "commonMistakes": [
                                    "Contar operações não-essenciais como variáveis locais",
                                    "Esquecer casos base (n=0)",
                                    "Não testar com n pequeno para encontrar n0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Merge Sort como Exemplo Padrão",
                                  "subSteps": [
                                    "Descreva recursão: T(n) = 2T(n/2) + Θ(n).",
                                    "Resolva recorrência usando Árvore de Recursão ou Teorema Mestre: Θ(n log n).",
                                    "Conte merges: n comparações por nível, log n níveis.",
                                    "Encontre c1 e c2: para n=2^k, prove limites.",
                                    "Implemente merge sort e meça tempos empíricos para validar assintótica."
                                  ],
                                  "verification": "Escreva prova de Θ(n log n) para merge sort, incluindo recorrência resolvida.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Implementação de merge sort em Python",
                                    "Ferramenta de profiling como timeit",
                                    "CLRS ou notas de aula"
                                  ],
                                  "tips": "Desenhe a árvore de recursão para n=8 para visualizar.",
                                  "learningObjective": "Interpretar Θ(n log n) especificamente para divide-and-conquer.",
                                  "commonMistakes": [
                                    "Confundir log n com ln(n) (use log2)",
                                    "Ignorar o Θ(n) no merge",
                                    "Assumir sem prova que é exato"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Verificar com Múltiplos Algoritmos",
                                  "subSteps": [
                                    "Analise quicksort médio: Θ(n log n), worst Θ(n^2).",
                                    "Compare bubble sort: Θ(n^2).",
                                    "Crie tabela: Algoritmo | T(n) exato | Θ(f(n)) | Razão.",
                                    "Teste casos edge: n=1, n pequeno.",
                                    "Discuta por que Θ descreve 'exato' apesar de constantes ocultas."
                                  ],
                                  "verification": "Classifique 3 algoritmos com Θ correta e justifique um com limites c1/c2.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Lista de algoritmos comuns (GeeksforGeeks)",
                                    "Planilha Excel para tabelas"
                                  ],
                                  "tips": "Use partitioning mental para quicksort médio.",
                                  "learningObjective": "Generalizar interpretação de Θ para contextos variados.",
                                  "commonMistakes": [
                                    "Misturar casos médio/worst",
                                    "Não distinguir Θ de O empírico",
                                    "Sobrestimar funções dominantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao analisar merge sort: Conte 2T(n/2) + n → por Mestre, Θ(n log n). Prove: para n=2^k, total ops ~ n k = n log n, com c1=1, c2=2.",
                              "finalVerifications": [
                                "Explicar Θ(n log n) para merge sort sem consultar notas.",
                                "Provar limites c1/c2 para soma linear Θ(n).",
                                "Identificar Θ(n^2) em bubble sort e contrastar com quicksort.",
                                "Resolver recorrência simples T(n)=2T(n/2)+n.",
                                "Discutir por que quicksort worst é Θ(n^2), não Θ(n log n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação da definição formal (inclui c1,c2,n0).",
                                "Correta identificação de funções dominantes em T(n).",
                                "Provas válidas de limites assintóticos.",
                                "Uso correto de recursão e teoremas (ex: Mestre).",
                                "Diferenciação clara entre Θ, O e Ω.",
                                "Aplicação consistente a exemplos concretos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Limites e análise assintótica (cálculo).",
                                "Matemática: Recorrências e séries (álgebra avançada).",
                                "Física: Modelagem de crescimento exponencial vs logarítmico.",
                                "Economia: Análise de custo-benefício em escalabilidade."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usar Θ(n log n) para escolher merge sort em bancos de dados grandes (ex: ordenação de milhões de registros no Google Search), evitando Θ(n^2) que trava em escala."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Relações com Outras Notações Assintóticas",
                        "description": "Análise das conexões entre Θ(f(n)), Big-O e Big-Ω, destacando quando usar cada uma.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Comparar Θ(f(n)) com O(f(n)) e Ω(f(n))",
                            "description": "Entender que Θ(f(n)) ⊆ O(f(n)) e Θ(f(n)) ⊆ Ω(f(n)), mas O e Ω são mais amplos, enquanto Θ é mais preciso para análise apertada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Formais das Notações Assintóticas",
                                  "subSteps": [
                                    "Estude a definição formal de Big-O: g(n) = O(f(n)) se existem constantes c > 0 e n0 tal que g(n) ≤ c * f(n) para n ≥ n0.",
                                    "Analise Big-Ω: g(n) = Ω(f(n)) se g(n) ≥ c * f(n) para constantes c > 0 e n ≥ n0.",
                                    "Compreenda Big-Θ: g(n) = Θ(f(n)) se g(n) = O(f(n)) e g(n) = Ω(f(n)), significando limites superior e inferior apertados.",
                                    "Compare verbalmente: O é cota superior, Ω é inferior, Θ é ambas.",
                                    "Anote as diferenças em um quadro comparativo."
                                  ],
                                  "verification": "Recite as definições e o quadro comparativo sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência: 'Introduction to Algorithms' de Cormen (Capítulo 3)"
                                  ],
                                  "tips": "Visualize com gráficos de funções crescendo para entender bounds.",
                                  "learningObjective": "Dominar as definições exatas e intuitivas de O, Ω e Θ.",
                                  "commonMistakes": [
                                    "Confundir O como bound exato (é loose upper)",
                                    "Ignorar constantes c e n0",
                                    "Pensar que Θ ignora constantes (não, é tight)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender as Relações de Inclusão Matemáticas",
                                  "subSteps": [
                                    "Prove que Θ(f(n)) ⊆ O(f(n)): Todo algoritmo Θ tem bound superior O.",
                                    "Prove que Θ(f(n)) ⊆ Ω(f(n)): Todo algoritmo Θ tem bound inferior Ω.",
                                    "Discuta por que O e Ω são mais amplos: Exemplos onde algo é O mas não Θ (ex: n^2 e n alternados).",
                                    "Use limites: lim sup g/f ≤ c para O, lim inf g/f ≥ c para Ω, ambos finitos e positivos para Θ.",
                                    "Desenhe diagramas de Venn mostrando Θ dentro de O e Ω."
                                  ],
                                  "verification": "Explique as provas e desenhe o diagrama de Venn corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora para limites",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Lembre: Θ é interseção de O e Ω para a mesma f(n).",
                                  "learningObjective": "Compreender matematicamente por que Θ é mais preciso e subset.",
                                  "commonMistakes": [
                                    "Achar que O ⊆ Θ (não, O é maior)",
                                    "Confundir ⊆ com = ",
                                    "Ignorar casos assintóticos vs finitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Concretos de Diferenças",
                                  "subSteps": [
                                    "Exemplo 1: Função n: Θ(n), O(n), Ω(n).",
                                    "Exemplo 2: Função n^2 em worst case para bubble sort: Θ(n^2), mas O(n^2) loose em average.",
                                    "Exemplo 3: QuickSort average Θ(n log n), worst O(n^2) mas não Θ(n^2).",
                                    "Plote tabelas numéricas para n=10,100,1000 mostrando bounds.",
                                    "Identifique cenários onde Θ é preferível para precisão."
                                  ],
                                  "verification": "Crie e explique 3 exemplos mostrando diferenças nos bounds.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para tabelas",
                                    "Gráficos de complexidade online"
                                  ],
                                  "tips": "Use grandes n para ver comportamento assintótico ignorar constantes.",
                                  "learningObjective": "Aplicar conceitos em funções reais para ver quando Θ é tight.",
                                  "commonMistakes": [
                                    "Usar small n onde constantes dominam",
                                    "Confundir average com worst case",
                                    "Achar todos algoritmos Θ iguais em todos cases"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Comparações em Contextos de Algoritmos",
                                  "subSteps": [
                                    "Compare MergeSort: Θ(n log n) sempre vs HeapSort O(n log n) worst.",
                                    "Analise busca binária: Θ(log n) vs linear O(n).",
                                    "Crie um algoritmo simples e classifique suas notações.",
                                    "Debata: Quando usar Θ vs O em relatórios? (Θ para tight analysis).",
                                    "Resolva 2 exercícios: Classifique g(n)=2n+3 como Θ(n)."
                                  ],
                                  "verification": "Classifique corretamente 5 funções/algoritmos com justificativa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios de CLRS ou LeetCode",
                                    "Notebook Jupyter para simulações"
                                  ],
                                  "tips": "Sempre pergunte: Há lower bound matching upper?",
                                  "learningObjective": "Habilitar comparações fluídas em análises reais.",
                                  "commonMistakes": [
                                    "Overuse O sem checar Θ",
                                    "Ignorar amortized analysis",
                                    "Confundir notação com tempo real"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao analisar QuickSort: Worst case é O(n^2) (pivô ruim), mas Θ(n log n) no average. Θ destaca precisão average, enquanto O é conservador para worst, ajudando escolher algoritmos confiáveis.",
                              "finalVerifications": [
                                "Explique verbalmente Θ ⊆ O e Θ ⊆ Ω com prova simples.",
                                "Dê 2 exemplos onde função é O mas não Θ.",
                                "Classifique complexidade de 3 algoritmos comuns (ex: Bubble, Merge, Binary Search).",
                                "Desenhe diagrama Venn correto.",
                                "Discuta quando preferir Θ sobre O em papers.",
                                "Resolva: Provar n log n = Θ(n log n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% correta).",
                                "Correção nas inclusões e provas (sem erros lógicos).",
                                "Qualidade de exemplos (concretos, variados, com números).",
                                "Profundidade em comparações (tight vs loose bounds).",
                                "Aplicação prática (ligação a algoritmos reais).",
                                "Clareza em explicações e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e assintóticos (Cálculo II).",
                                "Estatística: Análise probabilística em average case.",
                                "Engenharia de Software: Otimização e profiling de performance.",
                                "Física: Modelagem de crescimento exponencial em simulações."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usa-se Θ para benchmarks precisos (ex: Google usa em BigQuery para prever custos), O para garantias conservadoras em SLAs, otimizando apps escaláveis como redes sociais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Identificar equivalências assintóticas",
                            "description": "Reconhecer que se g(n) = O(f(n)) e g(n) = Ω(f(n)), então g(n) = Θ(f(n)), usando exemplos como n² e 2n².",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Big-O, Big-Omega e Big-Theta",
                                  "subSteps": [
                                    "Leia a definição formal de Big-O: g(n) = O(f(n)) se existem constantes c > 0 e n0 tal que g(n) ≤ c * f(n) para todo n ≥ n0.",
                                    "Estude Big-Omega: g(n) = Ω(f(n)) se existem c > 0 e n0 tal que g(n) ≥ c * f(n) para n ≥ n0.",
                                    "Analise Big-Theta: g(n) = Θ(f(n)) se g(n) = O(f(n)) e g(n) = Ω(f(n)).",
                                    "Compare as três noções com diagramas de limites superior, inferior e apertado.",
                                    "Resuma as diferenças em suas próprias palavras."
                                  ],
                                  "verification": "Crie um fluxograma mostrando as relações entre O, Ω e Θ, e explique-o em voz alta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel ou ferramenta digital como Draw.io",
                                    "Referência: Livro 'Introduction to Algorithms' CLRS, capítulo 3"
                                  ],
                                  "tips": "Use exemplos simples como constantes e lineares para visualizar os limites.",
                                  "learningObjective": "Compreender precisamente as definições formais das notações assintóticas.",
                                  "commonMistakes": [
                                    "Confundir O com ≤ exata em vez de assintótica",
                                    "Ignorar as constantes c e n0",
                                    "Pensar que O implica Ω"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Interseção entre Big-O e Big-Omega",
                                  "subSteps": [
                                    "Demonstre graficamente como O fornece limite superior e Ω limite inferior.",
                                    "Prove que se g(n) = O(f(n)) e g(n) = Ω(f(n)), então os limites se encontram, formando Θ(f(n)).",
                                    "Calcule limites: lim (n→∞) g(n)/f(n) deve existir e ser finito e positivo para Θ.",
                                    "Teste com funções polinomiais: compare n² e 3n².",
                                    "Registre observações sobre quando a equivalência falha (ex: n² e n³)."
                                  ],
                                  "verification": "Escreva uma prova curta mostrando que O + Ω implica Θ para funções genéricas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou Wolfram Alpha para limites",
                                    "Papel quadriculado para gráficos"
                                  ],
                                  "tips": "Sempre verifique o limite L = lim g(n)/f(n); se 0 < L < ∞, é Θ.",
                                  "learningObjective": "Reconhecer que Θ é a combinação de O e Ω para crescimento idêntico.",
                                  "commonMistakes": [
                                    "Assumir simetria sem prova",
                                    "Usar exemplos onde limite é 0 ou ∞",
                                    "Esquecer n0 na definição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Equivalências com Exemplos Simples",
                                  "subSteps": [
                                    "Pegue g(n) = 2n² e f(n) = n²: encontre c=3 para O e c=1 para Ω.",
                                    "Verifique: para n≥1, 2n² ≤ 3n² e 2n² ≥ 1*n².",
                                    "Repita com g(n) = n² + n e f(n) = n², calculando limites.",
                                    "Contraexemplo: mostre que n² ≠ Θ(n log n).",
                                    "Crie dois exemplos próprios e valide."
                                  ],
                                  "verification": "Liste 3 pares de funções onde equivalência holds e prove brevemente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para plotar funções",
                                    "Exemplos do contexto curricular"
                                  ],
                                  "tips": "Fatore constantes fora: 2n² ~ n² assintoticamente.",
                                  "learningObjective": "Aplicar definições para detectar Θ em pares comuns de funções.",
                                  "commonMistakes": [
                                    "Ignorar termos dominantes",
                                    "Escolher c inadequado",
                                    "Confundir com igualdade algébrica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Sintetizar Conhecimento",
                                  "subSteps": [
                                    "Resolva 5 exercícios: identifique se g=Θ(f) para pares dados (ex: 5n² vs n², n³ vs n² log n).",
                                    "Escreva um algoritmo simples para checar Θ via limites numéricos.",
                                    "Discuta em fórum ou com par: explique por que 2n² = Θ(n²).",
                                    "Revise erros comuns e corrija.",
                                    "Crie um cheat sheet com regras chave."
                                  ],
                                  "verification": "Submeta soluções de exercícios com provas para autoavaliação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Lista de exercícios online (LeetCode, Khan Academy)",
                                    "Notebook Jupyter para simulações"
                                  ],
                                  "tips": "Use logaritmos para comparar: log g - log f → constante para Θ.",
                                  "learningObjective": "Dominar identificação de equivalências assintóticas via prática.",
                                  "commonMistakes": [
                                    "Sobre-simplificar funções exponenciais",
                                    "Não testar n grandes",
                                    "Confundir Θ com = exata"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere g(n) = 2n² + n e f(n) = n². Prove g(n) = O(f(n)) com c=3, n0=1 (pois 2n² + n ≤ 3n² para n≥1). Prove g(n) = Ω(f(n)) com c=1, n0=1 (2n² + n ≥ n²). Logo, g(n) = Θ(n²), útil para analisar quicksort médio.",
                              "finalVerifications": [
                                "Explicar verbalmente por que Θ requer ambos O e Ω.",
                                "Provar corretamente 3 pares de funções como Θ.",
                                "Identificar erro em prova falsa: 'n² = Θ(2^n)' e corrigir.",
                                "Calcular limite correto para par dado.",
                                "Aplicar em algoritmo real: tempo de merge sort é Θ(n log n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas provas formais (constantes c, n0 corretos).",
                                "Uso correto de limites para confirmação assintótica.",
                                "Identificação precisa de contraexemplos.",
                                "Clareza em explicações e exemplos.",
                                "Proficiência em 80% dos exercícios práticos.",
                                "Integração com contexto de análise de algoritmos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e funções assintóticas em cálculo.",
                                "Física: Ordens de magnitude em escalas (ex: crescimento populacional).",
                                "Engenharia de Software: Avaliação de escalabilidade em big data.",
                                "Economia: Modelagem de custos crescentes em funções de produção."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, permite classificar algoritmos como Θ(n²) independentemente de constantes, guiando escolhas em cenários de alto volume como machine learning ou bancos de dados, otimizando performance sem detalhes irrelevantes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Escolher notação apropriada para análise",
                            "description": "Decidir usar Θ quando se conhece o crescimento exato, versus O para upper bounds soltos em algoritmos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de Big-O e Big-Θ",
                                  "subSteps": [
                                    "Leia a definição formal de Big-O: f(n) = O(g(n)) se existem constantes c > 0 e n0 tal que f(n) ≤ c * g(n) para todo n ≥ n0.",
                                    "Leia a definição formal de Big-Θ: f(n) = Θ(g(n)) se f(n) = O(g(n)) e f(n) = Ω(g(n)), significando crescimento exato.",
                                    "Compare as diferenças: Big-O é upper bound (limite superior solto), Big-Θ é tight bound (exato assintótico).",
                                    "Anote exemplos clássicos: n² = O(n³) mas n² = Θ(n²).",
                                    "Resuma em suas palavras as implicações para análise de algoritmos."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras comparando O e Θ, e verifique se cita as definições corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Algoritmos (ex: CLRS Capítulo 3)",
                                    "Notas de aula sobre notação assintótica",
                                    "Folha de papel ou editor de texto"
                                  ],
                                  "tips": "Use diagramas de crescimento de funções para visualizar bounds soltos vs exatos.",
                                  "learningObjective": "Dominar as definições matemáticas exatas de Big-O e Big-Θ para discernir suas diferenças.",
                                  "commonMistakes": [
                                    "Confundir Big-O com tempo exato (é apenas upper bound)",
                                    "Ignorar a constante c e n0 nas definições formais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Critérios para Escolha da Notação",
                                  "subSteps": [
                                    "Liste cenários para Θ: quando lower e upper bounds coincidem (ex: algoritmos com crescimento exato conhecido).",
                                    "Liste cenários para O: quando só upper bound é conhecido ou relevante (ex: pior caso sem tight bound).",
                                    "Analise trade-offs: Θ é mais preciso mas requer prova completa; O é mais simples para bounds rápidos.",
                                    "Crie uma tabela de decisão: 'Conheço Ω também?' -> Θ; 'Só upper?' -> O.",
                                    "Aplique a tabela em 2 funções simples: log n vs n."
                                  ],
                                  "verification": "Crie e preencha uma tabela de decisão com 3 exemplos, confirmando escolhas lógicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Referência online: Wikipedia Big O notation",
                                    "Calculadora para plots simples"
                                  ],
                                  "tips": "Pergunte sempre: 'É tight ou loose?' para guiar a escolha.",
                                  "learningObjective": "Desenvolver critérios claros para decidir entre Θ (exato) e O (upper bound) baseado no conhecimento disponível.",
                                  "commonMistakes": [
                                    "Usar Θ sem provar Ω (overclaiming precisão)",
                                    "Preferir sempre O por simplicidade, perdendo precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Análise em Exemplos de Algoritmos Simples",
                                  "subSteps": [
                                    "Analise Bubble Sort: prove T(n) = O(n²) e verifique se Θ(n²) aplica (sim, tight).",
                                    "Analise Binary Search: T(n) = O(log n), mas Θ(log n) pois exato.",
                                    "Para QuickSort médio: O(n log n), mas Θ só para pior? Discuta.",
                                    "Compare: quando usar O vs Θ em relatórios de análise.",
                                    "Registre decisões com justificativas curtas."
                                  ],
                                  "verification": "Resolva 3 análises escritas, justificando notação escolhida em cada uma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de algoritmos comuns",
                                    "Ferramenta de plotagem como Desmos ou Python Matplotlib",
                                    "Exercícios de livro de algoritmos"
                                  ],
                                  "tips": "Comece com casos conhecidos para construir confiança antes de casos ambíguos.",
                                  "learningObjective": "Aplicar critérios em algoritmos reais para escolher notação apropriada.",
                                  "commonMistakes": [
                                    "Assumir Θ sem análise de lower bound",
                                    "Ignorar constantes em comparações práticas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Refinar Decisões em Cenários Complexos",
                                  "subSteps": [
                                    "Escolha um algoritmo novo (ex: Dijkstra): decida O ou Θ baseado em literatura.",
                                    "Simule análise: prove bounds e justifique escolha.",
                                    "Crie um caso onde O é preferido (ex: algoritmo com bounds variáveis).",
                                    "Revise análises anteriores e refine se necessário.",
                                    "Discuta com par: 'Por que não Θ aqui?'"
                                  ],
                                  "verification": "Produza relatório de 1 página com 2 análises complexas e escolhas justificadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Artigos ou pseudocódigo de algoritmos avançados",
                                    "Ferramenta de análise assintótica online",
                                    "Fórum ou parceiro de estudo"
                                  ],
                                  "tips": "Priorize precisão: use Θ só quando confiante em ambos bounds.",
                                  "learningObjective": "Refinar habilidade de escolha contextual em análises reais e ambíguas.",
                                  "commonMistakes": [
                                    "Forçar Θ para parecer mais preciso",
                                    "Não considerar contexto prático da análise"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao analisar Merge Sort, prove T(n) = O(n log n) facilmente, mas como lower bound é Ω(n log n) por entropia de informação, use Θ(n log n) para tight bound exato em relatórios de performance.",
                              "finalVerifications": [
                                "Explica corretamente diferença entre upper bound (O) e tight bound (Θ).",
                                "Aplica tabela de decisão em 3 algoritmos novos sem erros.",
                                "Justifica escolhas com provas parciais de Ω quando usa Θ.",
                                "Identifica cenários onde O é suficiente (ex: prototipagem rápida).",
                                "Critica análises incorretas de pares, corrigindo uso indevido de Θ.",
                                "Produz análise completa de algoritmo mediano com notação apropriada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (100% correto).",
                                "Justificativas lógicas para escolha de notação (tight vs loose).",
                                "Número de substeps completos em análises práticas.",
                                "Ausência de erros comuns como overclaiming Θ.",
                                "Criatividade em exemplos reais e conexões contextuais.",
                                "Clareza e estrutura em relatórios de decisão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e funções assintóticas.",
                                "Física: Modelagem de crescimento em sistemas dinâmicos (ex: decaimento exponencial).",
                                "Engenharia de Software: Otimização de performance e benchmarking.",
                                "Economia: Análise de complexidade em modelos de otimização linear."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, engenheiros usam Θ para algoritmos estáveis como Merge Sort em sistemas de grande escala (ex: bancos de dados Google), enquanto O é usado para estimativas rápidas em machine learning onde bounds exatos são caros de provar, otimizando tempo de design e escalabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Provas e Exemplos de Uso da Notação Θ",
                        "description": "Técnicas para provar e exemplificar o uso de Θ(f(n)) na análise de complexidade de algoritmos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Provar que uma função é Θ(f(n)) usando limites",
                            "description": "Usar regra de L'Hôpital ou expansão em série para mostrar que lim (n→∞) g(n)/f(n) = c (constante finita >0), provando Θ(f(n)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de notação Big-Θ",
                                  "subSteps": [
                                    "Relembre que g(n) = Θ(f(n)) se existirem constantes c1, c2 > 0 e n0 tal que c1 f(n) ≤ g(n) ≤ c2 f(n) para todo n ≥ n0.",
                                    "Entenda que isso é equivalente a lim_{n→∞} g(n)/f(n) = c, onde 0 < c < ∞.",
                                    "Identifique funções g(n) e f(n) candidatas para a prova.",
                                    "Escreva a definição em suas próprias palavras.",
                                    "Diferencie Θ de Big-O e Big-Ω."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição de Θ(f(n)) e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Livro ou notas de análise de algoritmos",
                                    "Acesso a Khan Academy ou Wikipedia para revisão rápida"
                                  ],
                                  "tips": "Use analogias como 'sanduíche' para c1 f(n) e c2 f(n) envolvendo g(n).",
                                  "learningObjective": "Dominar a definição precisa de Θ(f(n)) e sua equivalência via limites.",
                                  "commonMistakes": [
                                    "Confundir limites finitos >0 com =0 ou ∞.",
                                    "Esquecer que c deve ser positivo e finito.",
                                    "Ignorar o 'para n suficientemente grande'."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o limite lim_{n→∞} g(n)/f(n)",
                                  "subSteps": [
                                    "Escolha funções g(n) e f(n) onde g(n) é ligeiramente mais complexa que f(n), ex: g(n) = n² + n, f(n) = n².",
                                    "Simplifique g(n)/f(n) algebraicamente para a forma mais simples possível.",
                                    "Verifique se o limite é indeterminado (∞/∞ ou 0/0).",
                                    "Prepare a expressão para aplicação de técnicas avançadas.",
                                    "Anote as hipóteses assumidas (ex: n→∞)."
                                  ],
                                  "verification": "Mostre a expressão simplificada de g(n)/f(n) e identifique o tipo de indeterminação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou software como Wolfram Alpha",
                                    "Papel milimetrado para gráficos iniciais",
                                    "Exemplos de currículo"
                                  ],
                                  "tips": "Divida numerador e denominador pela maior potência de n para simplificar.",
                                  "learningObjective": "Configurar corretamente a fração g(n)/f(n) pronta para cálculo de limite.",
                                  "commonMistakes": [
                                    "Não dividir pelos termos dominantes.",
                                    "Usar n→0 em vez de n→∞.",
                                    "Esquecer simplificações algébricas básicas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o limite usando L'Hôpital ou expansão em série",
                                  "subSteps": [
                                    "Se ∞/∞, aplique regra de L'Hôpital: derive numerador e denominador.",
                                    "Repita L'Hôpital até obter forma determinada, se necessário.",
                                    "Alternativa: use expansão em série de Taylor para funções complicadas.",
                                    "Calcule numericamente para valores grandes de n para validar.",
                                    "Confirme que o limite converge para c finito e positivo."
                                  ],
                                  "verification": "Apresente o cálculo passo a passo resultando em lim = c > 0.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de cálculo simbólico (Mathematica ou SymPy)",
                                    "Tabela de derivadas comuns",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Verifique derivadas antes de aplicar L'Hôpital; pratique com funções polinomiais primeiro.",
                                  "learningObjective": "Aplicar com maestria L'Hôpital ou séries para limites assintóticos.",
                                  "commonMistakes": [
                                    "Derivar incorretamente.",
                                    "Aplicar L'Hôpital em formas não ∞/∞.",
                                    "Parar prematuramente sem forma determinada."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a prova e verificar condições",
                                  "subSteps": [
                                    "Afirme que como lim = c (0 < c < ∞), então g(n) = Θ(f(n)).",
                                    "Encontre explicitamente c1 ≈ c/2, c2 ≈ 2c e estime n0 via teste numérico.",
                                    "Discuta implicações para análise de algoritmos.",
                                    "Teste com variação pequena em g(n) para robustez.",
                                    "Escreva a prova completa formalmente."
                                  ],
                                  "verification": "Escreva uma prova completa e concisa para um exemplo dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Modelo de prova formal",
                                    "Ferramentas de plotagem (Desmos ou GeoGebra)"
                                  ],
                                  "tips": "Sempre inclua '∴ g(n) = Θ(f(n))' no final da prova.",
                                  "learningObjective": "Finalizar provas rigorosas de complexidade Θ com todas as condições.",
                                  "commonMistakes": [
                                    "Não especificar c1, c2, n0.",
                                    "Concluir Θ sem limite finito positivo.",
                                    "Ignorar casos onde limite oscila."
                                  ]
                                }
                              ],
                              "practicalExample": "Prove que g(n) = 3n² + 2n + 1 é Θ(n²). Calcule lim_{n→∞} (3n² + 2n + 1)/n² = lim (3 + 2/n + 1/n²) = 3 (c=3 finito >0). Logo, Θ(n²). Para rigor, c1=2.5, c2=3.5, n0=10 satisfaz.",
                              "finalVerifications": [
                                "Pode provar independentemente que n log n = Θ(n log n) usando L'Hôpital?",
                                "Identifica corretamente quando um limite é ∞ e nega Θ?",
                                "Escreve prova formal para g(n)=n³ + n² log n = Θ(n³)?",
                                "Explica por que lim=0 implica o(n), não Θ?",
                                "Aplica a um exemplo novo sem ajuda?",
                                "Verifica numericamente para n=1000 e confirma c?"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática no cálculo do limite (100%).",
                                "Uso apropriado e repetição correta de L'Hôpital ou séries.",
                                "Identificação precisa de c finito positivo.",
                                "Especificação de c1, c2, n0 com justificativa.",
                                "Clareza e rigor na redação da prova formal.",
                                "Tratamento de erros comuns e edge cases."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial e Integral (regra de L'Hôpital).",
                                "Análise Real (limites e assíntotas).",
                                "Matemática Discreta (funções geradoras e séries).",
                                "Estatística (limites em leis dos grandes números).",
                                "Física (assíntotas em modelos cinemáticos)."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, prova que o tempo de merge sort é Θ(n log n), permitindo prever escalabilidade para big data em empresas como Google, otimizando recursos computacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Aplicar Θ em exemplos clássicos",
                            "description": "Analisar algoritmos como insertion sort (Θ(n²) no pior caso) ou binary search (Θ(log n)), justificando com constantes c1 e c2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição e Requisitos da Notação Big-Θ",
                                  "subSteps": [
                                    "Leia a definição formal de f(n) = Θ(g(n)) como existirem constantes positivas c1, c2 e n0 tal que para todo n ≥ n0, c1 * g(n) ≤ f(n) ≤ c2 * g(n).",
                                    "Identifique os componentes chave: função f(n) (custo do algoritmo), g(n) (função de crescimento), limites inferior e superior.",
                                    "Estude exemplos simples de Θ, como Θ(n) para soma linear.",
                                    "Anote as condições necessárias para provar Θ: acoplamento assintótico apertado.",
                                    "Pratique identificando f(n) e g(n) em pseudocódigos básicos."
                                  ],
                                  "verification": "Escreva a definição de Θ de memória e identifique corretamente f(n) e g(n) em um exemplo dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, lápis, referência rápida de notação assintótica (PDF ou livro-texto).",
                                  "tips": "Use diagramas para visualizar os limites c1*g(n) e c2*g(n) ao redor de f(n).",
                                  "learningObjective": "Compreender os pré-requisitos matemáticos para aplicar Θ corretamente.",
                                  "commonMistakes": "Confundir Θ com O ou Ω; ignorar a necessidade de ambas as desigualdades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Insertion Sort no Pior Caso",
                                  "subSteps": [
                                    "Escreva o pseudocódigo do insertion sort e conte as operações no pior caso (array reversamente ordenado).",
                                    "Calcule f(n): número de comparações e trocas, resultando em aproximadamente n(n-1)/2 ~ n²/2.",
                                    "Encontre c1 e c2: prove que para n ≥ 1, (1/4)n² ≤ f(n) ≤ n² (ex: c1=1/4, c2=1).",
                                    "Verifique com n pequenos (n=3,4) plotando f(n), n² e os limites.",
                                    "Justifique n0=1 ou ajuste conforme necessário."
                                  ],
                                  "verification": "Mostre cálculos para n=5 provando c1*n² ≤ f(n) ≤ c2*n² com valores numéricos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Pseudocódigo de insertion sort impresso, calculadora, planilha Excel para plots.",
                                  "tips": "Comece com arrays pequenos para intuição antes de generalizar para n.",
                                  "learningObjective": "Aplicar Θ a um algoritmo quadrático clássico, identificando constantes explicitamente.",
                                  "commonMistakes": "Contar apenas comparações, ignorando trocas; escolher c1/c2 muito apertados sem prova."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Binary Search no Caso Médio/Pior",
                                  "subSteps": [
                                    "Escreva pseudocódigo de binary search em array ordenado e conte iterações: log2(n) +1.",
                                    "Defina f(n) ≈ log2(n), g(n)=log n; prove Θ(log n).",
                                    "Encontre c1 e c2: para n≥2, 1*log n ≤ f(n) ≤ 2*log n (base 2 para log2).",
                                    "Teste com n=8 (3 passos), n=16 (4 passos) para validar limites.",
                                    "Discuta mudança de base: log2(n) = ln(n)/ln(2), mas mantenha consistência."
                                  ],
                                  "verification": "Calcule f(n) para n=1024 e mostre que está dentro de c1*log n e c2*log n.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Pseudocódigo de binary search, calculadora científica para log.",
                                  "tips": "Use árvore binária para visualizar divisões sucessivas.",
                                  "learningObjective": "Dominar aplicação de Θ a algoritmos logarítmicos com justificativa formal.",
                                  "commonMistakes": "Confundir pior caso com médio; esquecer +1 nas contagens exatas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Exemplos e Generalizar Provas",
                                  "subSteps": [
                                    "Compare insertion sort (Θ(n²)) vs binary search (Θ(log n)): discuta implicações em eficiência.",
                                    "Escreva provas formais concisas para ambos, destacando padrões comuns.",
                                    "Identifique reutilização de técnicas (somas de séries, master theorem intro).",
                                    "Crie um template genérico para provar Θ em novos algoritmos.",
                                    "Resolva exercício extra: Θ para linear search."
                                  ],
                                  "verification": "Escreva prova completa para um terceiro algoritmo usando o template.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha para anotações comparativas, exemplos adicionais de algoritmos.",
                                  "tips": "Foque em assintótica: ignore constantes baixas para grandes n.",
                                  "learningObjective": "Generalizar o processo de prova de Θ para algoritmos variados.",
                                  "commonMistakes": "Não generalizar, ficando preso a um exemplo; provas sem n0 explícito."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Refinar Análises",
                                  "subSteps": [
                                    "Revise cálculos para erros em c1, c2, n0 nos dois exemplos.",
                                    "Teste com n grandes (n=1000) usando código simulado ou fórmulas.",
                                    "Peça feedback ou autoavalie usando critérios de avaliação.",
                                    "Ajuste constantes para torná-las mais apertadas se possível.",
                                    "Documente lições aprendidas em um resumo."
                                  ],
                                  "verification": "Produza relatório final com provas revisadas e testes numéricos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código Python simples para simular contagens (opcional).",
                                  "tips": "Use gráficos (Excel/Matplotlib) para visualização intuitiva.",
                                  "learningObjective": "Garantir rigor e precisão nas provas de complexidade.",
                                  "commonMistakes": "Ignorar verificação numérica; constantes inválidas para pequenos n."
                                }
                              ],
                              "practicalExample": "Para insertion sort em array de 5 elementos reversos: f(5)=10 comparações. Com g(n)=n², c1=0.4 (2≤10≤25 com c2=5), validando Θ(n²). Similar para binary search em n=16: 4 passos, dentro 1*log2(16)=4 ≤ f(n) ≤ 8.",
                              "finalVerifications": [
                                "Provas incluem c1, c2, n0 explícitos para ambos algoritmos.",
                                "Cálculos numéricos confirmam limites para pelo menos 3 valores de n.",
                                "Definição de Θ aplicada corretamente sem confusão com O/Ω.",
                                "Pseudocódigos analisados com contagem precisa de operações.",
                                "Generalização para outro algoritmo demonstrada.",
                                "Erros comuns evitados e documentados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas desigualdades (c1*g(n) ≤ f(n) ≤ c2*g(n)).",
                                "Escolha adequada de g(n) refletindo crescimento dominante.",
                                "Justificativa formal com n0 e testes empíricos.",
                                "Clareza na documentação: passos lógicos e diagramas.",
                                "Capacidade de generalizar para novos exemplos.",
                                "Identificação correta de casos (pior/médio) e operações chave."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e séries infinitas (soma harmônica em sorts).",
                                "Matemática Discreta: Contagem de recursões e árvores de decisão.",
                                "Engenharia de Software: Otimização de performance em projetos reais.",
                                "Física: Modelagem assintótica similar a aproximações em dinâmica.",
                                "Estatística: Análise de complexidade média vs pior caso."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usar Θ(n²) para evitar insertion sort em grandes datasets (ex: preferir quicksort Θ(n log n)); Θ(log n) guia escolhas como binary search em bancos de dados indexados, otimizando apps como Google Search ou e-commerces."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Resolver exercícios de classificação Θ",
                            "description": "Classificar funções como 3n² + 2n = Θ(n²), fornecendo n0 e constantes explícitas para validação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal de Notação Big-Θ",
                                  "subSteps": [
                                    "Leia a definição: f(n) = Θ(g(n)) se existem c1, c2 > 0 e n0 tal que para todo n ≥ n0, c1 · g(n) ≤ f(n) ≤ c2 · g(n).",
                                    "Identifique os componentes: função f(n), função g(n) (geralmente o termo dominante), constantes c1 e c2, e ponto n0.",
                                    "Revise exemplos simples como n² = Θ(n²) com c1=1, c2=1, n0=1.",
                                    "Anote a necessidade de provar tanto o limite inferior (Ω) quanto superior (O).",
                                    "Discuta por que isso captura o comportamento assintótico exato."
                                  ],
                                  "verification": "Escreva a definição de Big-Θ de memória e explique cada parâmetro em suas próprias palavras.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou editor de texto; referência de livro ou notas sobre análise assintótica.",
                                  "tips": "Visualize o 'sanduíche' gráfico: f(n) entre c1 g(n) e c2 g(n) para n grande.",
                                  "learningObjective": "Dominar a definição precisa de Big-Θ e seus requisitos.",
                                  "commonMistakes": "Confundir Θ com O (apenas superior) ou confundir c1/c2 com valores negativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Função f(n) e Identificar g(n)",
                                  "subSteps": [
                                    "Examine f(n) = 3n² + 2n e identifique o termo dominante (3n², grau 2).",
                                    "Defina g(n) = n² como a função de referência.",
                                    "Simplifique f(n)/g(n) = 3 + 2/n, que tende a 3 quando n → ∞.",
                                    "Confirme que f(n) ~ 3n², justificando Θ(n²).",
                                    "Teste com valores pequenos de n para intuitar o comportamento."
                                  ],
                                  "verification": "Justifique por que g(n) = n² é apropriado, calculando lim (n→∞) f(n)/g(n).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou software como Python/Mathematica para limites; gráfico de f(n) vs n².",
                                  "tips": "Sempre divida f(n) por potências de n para encontrar o grau dominante.",
                                  "learningObjective": "Aprender a extrair o comportamento assintótico dominante de polinômios.",
                                  "commonMistakes": "Escolher g(n) errado, como n³ ou n, ignorando o grau mais alto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer o Limite Inferior (Prova de Ω(n²))",
                                  "subSteps": [
                                    "Encontre c1 > 0 tal que f(n) ≥ c1 n² para n ≥ n0.",
                                    "Para f(n) = 3n² + 2n ≥ 3n², escolha c1 = 3 e teste n0 = 1.",
                                    "Verifique: para n ≥ 1, 2n ≥ 0, então 3n² + 2n ≥ 3n².",
                                    "Ajuste c1 se necessário (ex: c1=2.5 para margem).",
                                    "Calcule para n=1,2,3 para validar."
                                  ],
                                  "verification": "Mostre desigualdade f(n) ≥ c1 n² holding para 3 valores de n ≥ n0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha ou tabela para tabulação de valores n, f(n), c1 n².",
                                  "tips": "Comece com o termo dominante para c1 próximo do coeficiente líder.",
                                  "learningObjective": "Provar que f(n) cresce pelo menos tão rápido quanto g(n).",
                                  "commonMistakes": "Usar c1 maior que o possível ou ignorar termos positivos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer o Limite Superior (Prova de O(n²))",
                                  "subSteps": [
                                    "Encontre c2 > 0 tal que f(n) ≤ c2 n² para n ≥ n0.",
                                    "Para n ≥ 1, 2n ≤ 2n², então 3n² + 2n ≤ 3n² + 2n² = 5n², c2=5.",
                                    "Verifique para n=1: 3+2=5 ≤ 5*1=5; n=2: 12+4=16 ≤ 5*4=20.",
                                    "Ajuste n0/c2 se desigualdade falhar para n pequenos.",
                                    "Combine com step anterior usando mesmo n0."
                                  ],
                                  "verification": "Tabule f(n) ≤ c2 n² para 3-5 valores n ≥ n0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesma planilha do step anterior; gráfico comparativo.",
                                  "tips": "Majorar termos menores: kn^m ≤ k n^d para m < d e n ≥ 1.",
                                  "learningObjective": "Provar que f(n) não cresce mais rápido que g(n).",
                                  "commonMistakes": "Subestimar c2 ou escolher n0 muito pequeno onde falha."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Generalizar a Classificação Θ",
                                  "subSteps": [
                                    "Compile: f(n) = Θ(n²) com c1=3, c2=5, n0=1.",
                                    "Teste para n grandes (ex: n=10,100) para confirmar.",
                                    "Generalize para funções similares: an² + bn + c = Θ(n²).",
                                    "Resolva exercício extra: prove 4n² - n = Θ(n²).",
                                    "Documente a prova completa."
                                  ],
                                  "verification": "Escreva prova formal completa e teste com função similar.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Template de prova; exemplos adicionais de exercícios.",
                                  "tips": "Use o menor n0 possível para elegância, mas garanta validade.",
                                  "learningObjective": "Sintetizar prova completa e aplicá-la a variações.",
                                  "commonMistakes": "Esquecer de especificar valores explícitos de c1,c2,n0."
                                }
                              ],
                              "practicalExample": "Para f(n) = 3n² + 2n, g(n) = n²: Limite inferior: 3n² + 2n ≥ 3n² (c1=3, n≥1). Limite superior: 3n² + 2n ≤ 5n² (pois 2n ≤ 2n² para n≥1, c2=5). Verificação: n=1: 5≤5; n=2:16≤20; n=10:320≤500. Assim, 3n² + 2n = Θ(n²) com c1=3, c2=5, n0=1.",
                              "finalVerifications": [
                                "Prova inclui c1, c2 >0 explícitos e n0.",
                                "Desigualdades validadas para pelo menos 3 valores n ≥ n0.",
                                "g(n) é o termo dominante correto.",
                                "Limites inferior e superior ambos provados.",
                                "Generalização para funções similares demonstrada.",
                                "Nenhum erro aritmético em cálculos de verificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas desigualdades matemáticas (sem erros algébricos).",
                                "Constantes c1, c2 positivas e mínimas possíveis.",
                                "n0 escolhido adequadamente com validação numérica.",
                                "Explicação clara do raciocínio assintótico.",
                                "Aplicação consistente da definição de Θ.",
                                "Ausência de confusão com O ou Ω isolados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Limites e análise assintótica de funções.",
                                "Análise de Algoritmos: Comparação de complexidades em programação.",
                                "Engenharia de Software: Avaliação de performance de código.",
                                "Estatística: Análise de crescimento de dados em big data."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, classifica a complexidade de algoritmos de ordenação como Θ(n log n) para quicksort médio, permitindo escolher implementações com melhores constantes para datasets reais, otimizando tempo de execução em aplicações como bancos de dados ou machine learning."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.4",
                            "name": "Usar ferramentas para verificação assintótica",
                            "description": "Aplicar gráficos ou ferramentas computacionais para visualizar e confirmar relações Θ entre funções polinomiais e exponenciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar funções e ferramenta apropriada",
                                  "subSteps": [
                                    "Identifique uma função polinomial (ex: n³) e uma exponencial (ex: 2ⁿ) para comparação.",
                                    "Defina o domínio relevante (n ≥ 1, focando em valores grandes como n=10 a 1000).",
                                    "Escolha uma ferramenta: Desmos para gráficos rápidos ou Python (Matplotlib/Jupyter) para análise avançada.",
                                    "Instale ou acesse a ferramenta necessária.",
                                    "Anote a hipótese Θ: verifique se f(n) = Θ(g(n)) ou não."
                                  ],
                                  "verification": "Lista de funções, domínio e ferramenta selecionados documentados em um arquivo de notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Computador com internet",
                                    "Acesso a Desmos ou Python/Jupyter Notebook"
                                  ],
                                  "tips": "Comece com funções clássicas como n² vs. 2ⁿ para resultados claros.",
                                  "learningObjective": "Compreender seleção de pares de funções que ilustrem diferenças assintóticas.",
                                  "commonMistakes": [
                                    "Escolher funções de mesma ordem (ex: n² e 2n²), perdendo o contraste",
                                    "Ignorar domínio assintótico (n pequeno)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e gerar gráficos das funções",
                                  "subSteps": [
                                    "Entre as funções na ferramenta (ex: Desmos: y=n^3 e y=2^n).",
                                    "Ajuste escalas para log ou linear para visualizar crescimento.",
                                    "Plote razões como f(n)/g(n) ou log(f(n)/g(n)).",
                                    "Adicione múltiplos valores de n para curvas suaves.",
                                    "Salve ou exporte o gráfico inicial."
                                  ],
                                  "verification": "Gráficos gerados e salvos mostrando as curvas de f(n) e g(n).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta gráfica (Desmos/Python)",
                                    "Editor de código se usando Python"
                                  ],
                                  "tips": "Use escala logarítmica para exponenciais; zoom em n grande.",
                                  "learningObjective": "Dominar plotagem precisa para visualização assintótica.",
                                  "commonMistakes": [
                                    "Escalas inadequadas que mascaram dominância",
                                    "Plotar apenas n pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar visualmente as relações assintóticas",
                                  "subSteps": [
                                    "Observe interseções e dominância para n → ∞.",
                                    "Identifique se f(n)/g(n) → c (constante ≠0) para Θ, ou 0/∞ caso contrário.",
                                    "Anote comportamentos: polinomiais crescem mais devagar que exponenciais.",
                                    "Compare múltiplos pares (ex: n^4 vs 3^n).",
                                    "Registre observações qualitativas."
                                  ],
                                  "verification": "Relatório com anotações sobre dominância visual em cada gráfico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos salvos do passo anterior",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Procure curvas que se separam drasticamente após n=20.",
                                  "learningObjective": "Interpretar gráficos para inferir relações Θ.",
                                  "commonMistakes": [
                                    "Confundir crescimento inicial com assintótico",
                                    "Ignorar Θ bidirecional (Ω e O)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar com análises numéricas e computacionais",
                                  "subSteps": [
                                    "Calcule razões f(n)/g(n) para n=10,50,100,500 usando a ferramenta.",
                                    "Use limites computacionais (ex: sympy em Python para lim n→∞ f/g).",
                                    "Gere tabela de valores e plote razões.",
                                    "Conclua se Θ holds (razão bounded) ou não.",
                                    "Documente evidências numéricas."
                                  ],
                                  "verification": "Tabela de razões e limite computado confirmando ou refutando Θ.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com numpy/sympy ou Wolfram Alpha",
                                    "Planilha para tabelas"
                                  ],
                                  "tips": "Para confirmação rigorosa, use sympy.limit().",
                                  "learningObjective": "Integrar análise numérica para validar observações visuais.",
                                  "commonMistakes": [
                                    "Amostras insuficientes de n",
                                    "Erro em computação de limites"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Desmos, plote f(n)=n³ (azul) e g(n)=2ⁿ (vermelho) para 1≤n≤50. Observe que após n=20, 2ⁿ domina n³ drasticamente. Compute n³/2ⁿ →0, confirmando n³ ≠ Θ(2ⁿ).",
                              "finalVerifications": [
                                "Gráficos mostram separação clara de curvas para n grande.",
                                "Razões f(n)/g(n) computadas convergem para 0 ou ∞.",
                                "Limites assintóticos calculados corretamente.",
                                "Conclusão sobre Θ alinhada com visual e numérico.",
                                "Relatório documenta todas evidências.",
                                "Teste com 2 pares adicionais de funções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção e plotagem de funções (20%)",
                                "Qualidade da análise visual e interpretação Θ (25%)",
                                "Correção das verificações numéricas/limites (25%)",
                                "Clareza da documentação e conclusões (15%)",
                                "Uso eficiente da ferramenta sem erros (10%)",
                                "Criatividade em exemplos adicionais (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de limites e análise assintótica.",
                                "Programação: Scripting em Python para automação de plots.",
                                "Estatística: Visualização de dados e interpretação de tendências.",
                                "Física: Modelagem de crescimento exponencial (populações, decaimento)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, use ferramentas como Python/Matplotlib para comparar complexidades de algoritmos (ex: bubble sort O(n²) vs quicksort médio O(n log n)), escolhendo o escalável para big data."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Relações Assintóticas",
                    "description": "Relações como o, ω e ~ para comparações precisas entre funções assintóticas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Notação little-o (o)",
                        "description": "A notação little-o descreve uma relação assintótica estrita onde f(n) cresce mais devagar que g(n), ou seja, f(n)/g(n) → 0 quando n → ∞.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Definir formalmente a notação little-o",
                            "description": "Explicar a definição matemática: f(n) = o(g(n)) se para todo ε > 0 existe n0 tal que para n > n0, |f(n)| ≤ ε |g(n)|, e fornecer exemplos como n = o(n²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar pré-requisitos de notações assintóticas",
                                  "subSteps": [
                                    "Estude a definição de notação Big-O: f(n) = O(g(n)) se ∃ C > 0 e n0 tal que para n > n0, |f(n)| ≤ C |g(n)|.",
                                    "Revise conceitos de limites assintóticos e funções positivas para n grande.",
                                    "Identifique diferenças intuitivas entre crescimento 'limitado' (Big-O) e 'estritamente menor' (little-o).",
                                    "Liste 3 exemplos simples de Big-O, como n² = O(n³)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença intuitiva entre Big-O e little-o.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre análise assintótica",
                                    "Livro de Algoritmos (ex: Cormen)",
                                    "Vídeo introdutório no YouTube sobre notações Big-O/Theta"
                                  ],
                                  "tips": "Use gráficos para visualizar crescimentos de funções como n vs n².",
                                  "learningObjective": "Compreender a base conceitual necessária para a definição de little-o.",
                                  "commonMistakes": [
                                    "Confundir little-o com Big-O",
                                    "Ignorar o papel dos quantificadores universais e existenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dissecar a definição formal da notação little-o",
                                  "subSteps": [
                                    "Memorize a definição: f(n) = o(g(n)) iff ∀ ε > 0 ∃ n0 tal que ∀ n > n0, |f(n)| ≤ ε |g(n)|.",
                                    "Analise cada quantificador: 'para todo ε > 0' significa que ε pode ser arbitrariamente pequeno.",
                                    "Entenda 'existe n0' como ponto a partir do qual a desigualdade vale para todos n maiores.",
                                    "Reescreva a definição em palavras: f cresce mais devagar que qualquer múltiplo positivo pequeno de g.",
                                    "Pratique reescrevendo com símbolos matemáticos em LaTeX ou papel."
                                  ],
                                  "verification": "Escreva a definição formal completa sem consultar materiais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel ou editor LaTeX",
                                    "Referência: Wikipedia ou livro de Cormen capítulo sobre assintóticas"
                                  ],
                                  "tips": "Pense em ε como 'fator de escala' que pode ser reduzido infinitamente.",
                                  "learningObjective": "Dominar a formulação matemática exata da little-o.",
                                  "commonMistakes": [
                                    "Esquecer o quantificador universal em ε",
                                    "Usar ≤ em vez de < incorretamente (little-o é estrita)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a definição em exemplos concretos",
                                  "subSteps": [
                                    "Prove que n = o(n²): Escolha ε > 0, encontre n0 = 1/ε, verifique |n| ≤ ε n² para n > n0.",
                                    "Verifique log(n) = o(n): Use limite lim log(n)/n = 0 para justificar.",
                                    "Teste contra-exemplo: n² ≠ o(n), pois não vale para ε pequeno.",
                                    "Crie seu próprio exemplo: 2^n = o(n!)? Justifique.",
                                    "Desenhe gráficos comparando f(n) e ε g(n) para valores de ε decrescentes."
                                  ],
                                  "verification": "Forneça prova escrita para pelo menos 2 exemplos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora ou software como Desmos para gráficos",
                                    "Papel para provas"
                                  ],
                                  "tips": "Sempre comece escolhendo n0 em termos de ε.",
                                  "learningObjective": "Aplicar a definição para validar relações little-o.",
                                  "commonMistakes": [
                                    "Escolher n0 independente de ε",
                                    "Não verificar para todos n > n0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar little-o com outras notações e sintetizar",
                                  "subSteps": [
                                    "Compare com Big-O: little-o é Big-O com C=ε para todo ε>0 (estrita).",
                                    "Diferencie de Omega e Theta: little-o implica não-Theta.",
                                    "Resolva exercícios: Classifique n log n vs n² como little-o ou não.",
                                    "Crie tabela resumindo: Definição, Exemplos, Intuição para O, o, Ω, Θ.",
                                    "Explique por que little-o é útil em análise precisa de algoritmos."
                                  ],
                                  "verification": "Preencha tabela de comparação corretamente e explique 1 uso prático.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em Excel ou papel",
                                    "Exercícios de livro de algoritmos"
                                  ],
                                  "tips": "Lembre: f = o(g) implica f = O(g), mas não vice-versa.",
                                  "learningObjective": "Posicionar little-o no contexto de relações assintóticas.",
                                  "commonMistakes": [
                                    "Confundir little-o com little-omega",
                                    "Pensar que little-o permite constantes finitas fixas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para provar n = o(n²): Dado ε > 0, defina n0 = 1/ε. Para n > n0, n < ε n² pois n² - n/ε > 0 quando n > 1/ε. Verifique: |n| / |n²| = 1/n → 0 < ε.",
                              "finalVerifications": [
                                "Escreve a definição formal sem erros.",
                                "Prova corretamente pelo menos 3 exemplos como n = o(n²), log n = o(n), n² ≠ o(n³).",
                                "Explica a intuição: f cresce negligible comparado a g.",
                                "Diferencia little-o de Big-O em um parágrafo.",
                                "Identifica quando usar little-o em análise de algoritmos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (100% dos símbolos corretos).",
                                "Corretude em provas de exemplos (lógica válida e n0 dependente de ε).",
                                "Profundidade na comparação com outras notações.",
                                "Criatividade em exemplos próprios.",
                                "Clareza na explicação intuitiva e escrita.",
                                "Aplicação em contexto real de algoritmos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Real (limites, quantificadores).",
                                "Ciência da Computação: Análise de Algoritmos (complexidade).",
                                "Engenharia de Software: Otimização de performance.",
                                "Matemática Discreta: Relações de ordem em funções."
                              ],
                              "realWorldApplication": "Na análise de algoritmos, usa-se little-o para provar que o tempo de um algoritmo linear (O(n)) domina um logarítmico (o(n)), auxiliando na escolha de implementações eficientes em big data ou machine learning."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Provar relações little-o usando limites",
                            "description": "Demonstrar que lim (n→∞) f(n)/g(n) = 0 implica f(n) = o(g(n)), aplicando em pares como log n = o(n) ou n² = o(2^n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de Little-o e Limites",
                                  "subSteps": [
                                    "Recordar a definição formal: f(n) = o(g(n)) se para todo ε > 0 existe N tal que para n > N, 0 ≤ f(n)/g(n) < ε (assumindo g(n) > 0).",
                                    "Entender que isso implica lim_{n→∞} f(n)/g(n) = 0.",
                                    "Discutir pré-requisitos: funções positivas para n suficientemente grande e comportamento assintótico.",
                                    "Exemplificar intuitivamente: log n cresce mais devagar que qualquer potência positiva de n.",
                                    "Praticar reescrevendo a definição em suas próprias palavras."
                                  ],
                                  "verification": "Explique a definição de little-o e dê um exemplo verbal sem fórmulas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Algorithms' (CLRS, Capítulo 3)",
                                    "Caderno e calculadora",
                                    "Folha de definições assintóticas"
                                  ],
                                  "tips": "Sempre assuma g(n) > 0 para n grande para evitar divisões por zero.",
                                  "learningObjective": "Dominar as definições precisas de notação little-o e sua relação com limites.",
                                  "commonMistakes": [
                                    "Confundir little-o com big-O (little-o é estritamente mais fraco)",
                                    "Esquecer a quantificação 'para todo ε > 0'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Teorema de Equivalência entre Little-o e Limite Zero",
                                  "subSteps": [
                                    "Estudar o teorema: lim_{n→∞} f(n)/g(n) = 0 ⇔ f(n) = o(g(n)).",
                                    "Provar a direção '⇒': usar definição de limite para mostrar a definição ε-N de little-o.",
                                    "Provar a direção '⇐': usar ε-N para mostrar que o limite é zero.",
                                    "Discutir condições: funções definidas para n → ∞ e g(n) ≠ 0.",
                                    "Verificar com um exemplo simples como lim n / 2^n = 0 implica n = o(2^n)."
                                  ],
                                  "verification": "Escreva a prova das duas direções do teorema em um parágrafo conciso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para provas",
                                    "Software como Wolfram Alpha para checar limites",
                                    "Notas de aula sobre limites"
                                  ],
                                  "tips": "Use ε/2 na prova para margem de segurança na quantificação.",
                                  "learningObjective": "Provar formalmente a equivalência entre limite zero e notação little-o.",
                                  "commonMistakes": [
                                    "Ignorar a direção reversa da implicação",
                                    "Confundir com big-Theta onde limite é constante finito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Limites para Provas Little-o",
                                  "subSteps": [
                                    "Escolher pares de funções: log n e n, n² e 2^n.",
                                    "Aplicar técnicas de limites: L'Hôpital para indeterminados ∞/∞, ou expansões assintóticas.",
                                    "Calcular lim (log n)/n: usar mudança log n = ln n / ln base, mostrar tende a 0.",
                                    "Calcular lim n² / 2^n: aplicar L'Hôpital duas vezes ou série exponencial.",
                                    "Generalizar para famílias de funções polinomiais vs exponenciais."
                                  ],
                                  "verification": "Compute e justifique dois limites: (log n)/n e n²/2^n.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou SymPy/Python para limites",
                                    "Tabela de limites conhecidos",
                                    "Exercícios de CLRS 3.1"
                                  ],
                                  "tips": "Para log n / n^k (k>0), use L'Hôpital: derivada log é 1/n, n^k é k n^{k-1}, repita.",
                                  "learningObjective": "Executar cálculos de limites que comprovam relações little-o.",
                                  "commonMistakes": [
                                    "Aplicar L'Hôpital sem forma ∞/∞ ou 0/0",
                                    "Esquecer que n é discreto mas limite é contínuo aproximado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Provas Completas em Exemplos",
                                  "subSteps": [
                                    "Provar completamente log n = o(n): calcular limite e citar teorema.",
                                    "Provar n² = o(2^n): detalhar passos do limite.",
                                    "Testar contra-exemplo: mostrar que n ≠ o(n) pois limite=1 ≠0.",
                                    "Explorar variações: n log n = o(n^{1.5}), etc.",
                                    "Documentar a prova em formato estruturado: enunciado, limite, conclusão."
                                  ],
                                  "verification": "Escreva provas completas para dois pares de funções.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Template de prova em LaTeX ou Word",
                                    "Lista de pares de funções para prática"
                                  ],
                                  "tips": "Estruture prova como: 1. Enunciado, 2. Cálculo limite, 3. Aplicação teorema.",
                                  "learningObjective": "Realizar provas end-to-end de relações little-o usando limites.",
                                  "commonMistakes": [
                                    "Não justificar o limite adequadamente",
                                    "Usar big-O quando little-o é requerido"
                                  ]
                                }
                              ],
                              "practicalExample": "Para provar que log₂ n = o(n): Compute lim_{n→∞} (log₂ n)/n = lim (ln n / (n ln 2)) = 0 por L'Hôpital (derivada ln n é 1/n, derivada n é 1, repita infinitas vezes efetivamente). Pelo teorema, log₂ n = o(n). Isso mostra que tempo de busca binária é negligible comparado a linear scan.",
                              "finalVerifications": [
                                "Pode provar log n = o(n) do zero, incluindo limite?",
                                "Explique por que lim f/g = 0 implica f = o(g), sem olhar notas.",
                                "Identifique erro em uma prova falha: e.g., claiming n = o(n).",
                                "Aplique a uma nova par: n^3 = o(n^4)? Justifique com limite.",
                                "Diferencie little-o de big-O em um exemplo concreto.",
                                "Prove n! = o(n^n) via limite ou Stirling."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na definição e prova do teorema.",
                                "Correto cálculo e justificativa de limites (uso de L'Hôpital ou equivalentes).",
                                "Clareza na estrutura da prova: enunciado, cálculo, conclusão.",
                                "Manipulação correta de funções logarítmicas, polinomiais e exponenciais.",
                                "Identificação de erros comuns e contra-exemplos.",
                                "Generalização para novos pares de funções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática (Análise Real): Definições ε-N e teorema do limite.",
                                "Ciência da Computação (Análise de Algoritmos): Comparação de complexidades em sorting e graph algorithms.",
                                "Física/Matemática Aplicada: Análise assintótica de crescimento populacional exponencial vs polinomial.",
                                "Estatística: Taxas de convergência em aproximações probabilísticas."
                              ],
                              "realWorldApplication": "Na análise de algoritmos, prova que o tempo de um algoritmo log-linear (e.g., merge sort O(n log n)) é o(n^2) comparado a quadraticos como bubble sort, guiando escolhas de implementação eficientes em software de grande escala como bancos de dados ou machine learning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Identificar e classificar funções em little-o",
                            "description": "Dado um conjunto de funções, determinar quais satisfazem f(n) = o(g(n)) para pares específicos, justificando com cálculos assintóticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal de Notação Little-o",
                                  "subSteps": [
                                    "Leia e memorize a definição: f(n) = o(g(n)) se e somente se lim_{n→∞} f(n)/g(n) = 0.",
                                    "Entenda a intuição: f(n) cresce estritamente mais devagar que g(n), sem fator constante limitante.",
                                    "Compare com Big-O (lim ≤ c) e Theta (lim constante finita e positiva).",
                                    "Analise exemplos iniciais: 1 = o(n), n = o(n²), log n = o(n).",
                                    "Diferencie de little-omega (lim = ∞)."
                                  ],
                                  "verification": "Escreva a definição em suas palavras e forneça 3 exemplos corretos com justificativa qualitativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência de notações assintóticas (livro ou PDF)",
                                    "Calculadora gráfica opcional"
                                  ],
                                  "tips": "Desenhe gráficos de funções para visualizar o crescimento relativo.",
                                  "learningObjective": "Definir precisamente little-o e distingui-la de notações relacionadas.",
                                  "commonMistakes": [
                                    "Confundir little-o com Big-O (permitir limite finito não-zero)",
                                    "Ignorar o comportamento para n→∞"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Técnicas de Prova Usando Limites e Equivalências Assintóticas",
                                  "subSteps": [
                                    "Aprenda a computar lim f(n)/g(n) diretamente para funções polinomiais e logarítmicas.",
                                    "Use regra de L'Hôpital para formas ∞/∞ ou 0/0.",
                                    "Aplique equivalências: n^α = o(n^β) se α < β; log n = o(n^ε) para ε>0.",
                                    "Pratique expansões assintóticas: e^n domina qualquer polinômio.",
                                    "Registre identidades úteis como √n = o(n / log n)."
                                  ],
                                  "verification": "Prove corretamente se n log n = o(n^{1.5}) usando limite, mostrando passos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora ou software como Wolfram Alpha",
                                    "Tabela de limites assintóticos",
                                    "Papel para cálculos"
                                  ],
                                  "tips": "Sempre especifique n→∞ e normalize funções dominantes primeiro.",
                                  "learningObjective": "Aplicar métodos matemáticos rigorosos para verificar relações little-o.",
                                  "commonMistakes": [
                                    "Aplicar L'Hôpital sem forma indeterminada",
                                    "Esquecer de dividir por termo dominante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Identificação em Pares de Funções Comuns",
                                  "subSteps": [
                                    "Liste 10 pares comuns: (log n, n), (n, n²), (n!, 2^n), etc.",
                                    "Para cada par, compute lim f/g e classifique como little-o, Big-O ou nem.",
                                    "Justifique falhas: ex., n² ≠ o(n log n) pois lim = ∞.",
                                    "Agrupe funções por classes de crescimento: constantes, log, poly, exp.",
                                    "Teste casos limítrofes como n / log n = o(n)."
                                  ],
                                  "verification": "Classifique corretamente 8/10 pares dados, com justificativas curtas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de funções de exemplo",
                                    "Planilha ou app de cálculo",
                                    "Gráficos online como Desmos"
                                  ],
                                  "tips": "Use tabelas para organizar pares e resultados de limites.",
                                  "learningObjective": "Reconhecer padrões de crescimento e classificar rapidamente.",
                                  "commonMistakes": [
                                    "Subestimar crescimento exponencial",
                                    "Confundir log_b n com ln n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Problemas Completos: Classificar Conjuntos e Justificar",
                                  "subSteps": [
                                    "Receba um conjunto de 5-7 funções e múltiplos pares para testar f = o(g).",
                                    "Para cada par afirmado, prove ou refute com cálculo assintótico detalhado.",
                                    "Escreva justificativas formais: 'Pelo limite ... = 0, segue que ...'.",
                                    "Identifique contraexemplos para pares falsos.",
                                    "Sintetize: ordene todas funções por classes assintóticas."
                                  ],
                                  "verification": "Resolva um conjunto teste completo sem erros, com todas justificativas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Problemas de prática impressos ou digitais",
                                    "Software simbólico (SymPy ou Mathematica)",
                                    "Referências de complexidade"
                                  ],
                                  "tips": "Comece pelos pares mais óbvios para ganhar confiança.",
                                  "learningObjective": "Aplicar conhecimento integralmente em cenários realistas de classificação.",
                                  "commonMistakes": [
                                    "Justificativas vagas sem limite explícito",
                                    "Erros aritméticos em expoentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o conjunto {log n, n, n log n, n², 2^n}, classifique: (i) log n = o(n)? Sim, lim (log n)/n = 0. (ii) n log n = o(n²)? Sim, lim (n log n)/n² = lim (log n)/n = 0. (iii) n² = o(2^n)? Sim, por crescimento exponencial domina polinomial. Justificativas via limites confirmam.",
                              "finalVerifications": [
                                "Classifica corretamente 10 pares de funções mistas sem hesitação.",
                                "Fornece provas rigorosas com limites para todos os casos.",
                                "Identifica e corrige erros em provas de pares falsos.",
                                "Ordena um conjunto de 7 funções por ordem assintótica crescente.",
                                "Explica intuições gráficas para relações little-o.",
                                "Aplica em contexto de complexidade: QuickSort O(n log n) vs MergeSort."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e limites (100% correto).",
                                "Profundidade das justificativas (inclui passos matemáticos).",
                                "Eficiência na classificação (tempo < estimado).",
                                "Criatividade em contraexemplos e intuições.",
                                "Integração com outras notações assintóticas.",
                                "Clareza na comunicação escrita/oral de provas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de limites e análise assintótica.",
                                "Engenharia de Computação: Análise de tempo/espaço de algoritmos.",
                                "Física: Modelagem de crescimento em sistemas dinâmicos.",
                                "Economia: Análise assintótica de funções de custo em grande escala.",
                                "Estatística: Comportamento assintótico de estimadores."
                              ],
                              "realWorldApplication": "Na análise de algoritmos, permite determinar se uma aproximação heurística (ex.: O(n log n)) é assintoticamente negligenciável comparada a uma exata (O(n²)), guiando escolhas de implementação em software de grande escala como bancos de dados ou IA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Notação little-omega (ω)",
                        "description": "A notação little-omega descreve uma relação assintótica estrita onde f(n) cresce mais rápido que g(n), ou seja, f(n)/g(n) → ∞ quando n → ∞.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Definir formalmente a notação little-omega",
                            "description": "Explicar a definição: f(n) = ω(g(n)) se para todo C > 0 existe n0 tal que para n > n0, |f(n)| ≥ C |g(n)|, com exemplos como n² = ω(n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Pré-Assintóticos Básicos",
                                  "subSteps": [
                                    "Relembre as definições de Big-O (limite superior) e Big-Omega (limite inferior).",
                                    "Entenda que little-omega é uma versão estrita do Big-Omega, focando em crescimento estritamente maior.",
                                    "Escreva exemplos simples: f(n) = O(g(n)) para f(n) = 2n e g(n) = n.",
                                    "Compare com Theta, que é tanto superior quanto inferior.",
                                    "Identifique por que little-omega ignora constantes multiplicativas."
                                  ],
                                  "verification": "Escreva definições corretas de Big-O e Big-Omega em um papel e compare com uma referência confiável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro 'Introduction to Algorithms' (CLRS), capítulo de análise assintótica",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar as relações entre notações assintóticas.",
                                  "learningObjective": "Compreender o contexto das notações assintóticas para posicionar little-omega.",
                                  "commonMistakes": [
                                    "Confundir little-omega com Big-Omega (não estrita)",
                                    "Ignorar o papel das constantes C"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e Escrever a Definição Formal",
                                  "subSteps": [
                                    "Leia a definição: f(n) = ω(g(n)) iff para todo C > 0 existe n0 tal que para todo n > n0, |f(n)| > C |g(n)|.",
                                    "Note a diferença: usa > em vez de ≥ como em Big-Omega.",
                                    "Escreva a definição 5 vezes de memória, variando a notação (f(n), g(n)).",
                                    "Explique verbalmente cada quantificador: ∀ C > 0, ∃ n0, ∀ n > n0.",
                                    "Traduza para linguagem natural: 'f cresce mais rápido que qualquer múltiplo constante de g, eventualmente'."
                                  ],
                                  "verification": "Recite a definição sem olhar e verifique contra a original; acerte 100%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência online: Wikipedia 'Little-omega notation'",
                                    "Gravador de voz ou app de notas"
                                  ],
                                  "tips": "Use mnemônicos como 'Todo C positivo precisa de um n0 para dominar para sempre'.",
                                  "learningObjective": "Internalizar a definição exata de little-omega.",
                                  "commonMistakes": [
                                    "Usar ≥ em vez de >",
                                    "Confundir ordem dos quantificadores (∃ antes de ∀)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Definição com Exemplos Simples",
                                  "subSteps": [
                                    "Pegue f(n) = n² e g(n) = n; prove: para qualquer C>0, escolha n0 = C+1, então n² > C n para n > n0.",
                                    "Teste com valores numéricos: para C=10, n0=11, verifique n=12: 144 > 120.",
                                    "Faça o inverso: mostre que n ≠ ω(n²) (não vale).",
                                    "Generalize para polinômios: n^k = ω(n^m) se k > m.",
                                    "Registre 3 exemplos em uma tabela: função, C, n0, verificação."
                                  ],
                                  "verification": "Crie e valide uma prova para n² = ω(n) com pelo menos 3 valores de C.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python para plots",
                                    "Papel quadriculado",
                                    "Ferramenta online como Desmos para gráficos assintóticos"
                                  ],
                                  "tips": "Comece com C pequenos para visualizar o 'eventualmente'.",
                                  "learningObjective": "Aplicar a definição para validar relações little-omega.",
                                  "commonMistakes": [
                                    "Escolher n0 muito pequeno que falha para n logo após",
                                    "Esquecer o módulo | | para funções negativas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Outras Notações e Contra-Exemplos",
                                  "subSteps": [
                                    "Compare: f = ω(g) implica f = Ω(g), mas não O(g).",
                                    "Encontre contra-exemplo: n log n ≠ ω(n) mas n log n = Ω(n).",
                                    "Crie tabela comparativa: Big-O, Big-Omega, little-o, little-omega para pares comuns.",
                                    "Prove que se f = ω(g) e g = ω(h), então f = ω(h).",
                                    "Discuta implicações em análise de algoritmos: QuickSort vs BubbleSort."
                                  ],
                                  "verification": "Explique diferenças em uma tabela e prove uma propriedade transitiva corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabelas",
                                    "CLRS ou notas de aula",
                                    "Caneta marca-texto para destacar diferenças"
                                  ],
                                  "tips": "Use setas em diagramas para mostrar inclusões (ω ⊂ Ω).",
                                  "learningObjective": "Distinguir little-omega de notações relacionadas e entender propriedades.",
                                  "commonMistakes": [
                                    "Achar que ω é simétrica (não é)",
                                    "Confundir little-omega com little-o"
                                  ]
                                }
                              ],
                              "practicalExample": "Para provar que o tempo de um algoritmo de ordenação O(n²) é ω(n log n) do MergeSort: Para qualquer C>0, existe n0 tal que para n>n0, n² > C n log n (escolha n0 grande o suficiente, verificável numericamente para C=100, n0≈1000).",
                              "finalVerifications": [
                                "Escreva a definição formal de little-omega sem erros.",
                                "Prove corretamente que n² = ω(n) com escolha explícita de n0.",
                                "Identifique 2 funções que NÃO satisfazem ω para um par dado.",
                                "Explique a diferença entre ω(g(n)) e Ω(g(n)) com exemplo.",
                                "Crie um exemplo original e valide-o.",
                                "Desenhe gráfico assintótico mostrando dominância estrita."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% dos quantificadores corretos).",
                                "Capacidade de provar exemplos com n0 explícito e verificação numérica.",
                                "Distinção clara de notações relacionadas (sem confusões).",
                                "Uso correto de módulo e consideração de funções positivas/negativas.",
                                "Criatividade em exemplos originais e contra-exemplos.",
                                "Compreensão de implicações em análise algorítmica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Real (limites inferiores, quantificadores ∃∀).",
                                "Matemática: Teoria dos Limites e Assíntotas em funções contínuas.",
                                "Física: Análise assintótica de trajetórias ou crescimento exponencial em modelos dinâmicos.",
                                "Engenharia: Comparação de eficiência em sistemas embarcados (complexidade vs recursos)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usar little-omega para provar que um novo algoritmo de machine learning O(n²) é assintoticamente pior que O(n log n), guiando otimizações em big data no Google ou AWS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Provar relações little-omega usando limites",
                            "description": "Mostrar que lim (n→∞) f(n)/g(n) = ∞ implica f(n) = ω(g(n)), aplicando em exemplos como 2^n = ω(n³).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal de notação little-omega (ω)",
                                  "subSteps": [
                                    "Leia a definição: f(n) = ω(g(n)) se para todo C > 0 existe N tal que para todo n > N, f(n) > C * g(n).",
                                    "Compare com big-O e little-o para diferenciar: ω é o oposto estrito de big-O.",
                                    "Escreva a definição em suas próprias palavras.",
                                    "Identifique que isso significa f cresce estritamente mais rápido que g.",
                                    "Pratique com um exemplo simples: n^2 = ω(n)."
                                  ],
                                  "verification": "Escreva a definição ε-δ (ou equivalente para constantes C) de ω(g(n)) sem olhar para referências.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência de análise assintótica (ex: CLRS Capítulo 3)"
                                  ],
                                  "tips": "Lembre-se: ω é assimptótico estritamente dominante; foque no 'para todo C > 0'.",
                                  "learningObjective": "Compreender precisamente o que significa f(n) = ω(g(n)) em termos de crescimento assimptótico.",
                                  "commonMistakes": [
                                    "Confundir com big-Ω (que permite igualdade)",
                                    "Esquecer o 'estritamente maior' para todo C",
                                    "Misturar com little-o"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a condição limite para little-omega",
                                  "subSteps": [
                                    "Estude a equivalência: lim (n→∞) f(n)/g(n) = ∞ ⇔ f(n) = ω(g(n)).",
                                    "Explique intuitivamente: se f/g → ∞, f domina g por qualquer múltiplo.",
                                    "Prove a direção ⇒: se f = ω(g), então para qualquer C, f/g > C eventualmente, logo → ∞.",
                                    "Discuta por que o limite captura o crescimento ilimitado.",
                                    "Teste com contraexemplo: se lim = L finito >0, não é ω."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que lim f/g = ∞ implica domínio assimptótico estrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software como Wolfram Alpha para limites",
                                    "Notas de cálculo de limites"
                                  ],
                                  "tips": "Use L'Hôpital se necessário para limites ∞/∞, mas foque na definição.",
                                  "learningObjective": "Dominar a conexão entre limites e notação ω.",
                                  "commonMistakes": [
                                    "Assumir que lim = 0 implica ω (é little-o)",
                                    "Ignorar n→∞ discreto vs contínuo",
                                    "Confundir f/g → ∞ com g/f → 0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a prova formal da implicação",
                                  "subSteps": [
                                    "Assuma lim (n→∞) f(n)/g(n) = ∞.",
                                    "Pela definição de limite ∞, para todo K > 0 existe N tal que n > N implica f(n)/g(n) > K.",
                                    "Escolha K = C + 1 para qualquer C > 0, mostrando f(n) > C g(n) para n > N.",
                                    "Conclua que f(n) = ω(g(n)) pela definição.",
                                    "Verifique as hipóteses: g(n) > 0 para n grande, f,g → ∞."
                                  ],
                                  "verification": "Escreva a prova completa em formato ε-N (adaptado para ∞ e C).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para prova formal",
                                    "Template de prova de limites"
                                  ],
                                  "tips": "Estruture como: 'Seja C > 0 arbitrário. Pelo limite, tome K = C...'",
                                  "learningObjective": "Realizar prova rigorosa ligando limite a definição ω.",
                                  "commonMistakes": [
                                    "Pular a quantificação 'para todo C'",
                                    "Não especificar N dependendo de C",
                                    "Esquecer positividade de g(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a prova no exemplo 2^n = ω(n^3)",
                                  "subSteps": [
                                    "Compute lim (n→∞) 2^n / n^3.",
                                    "Use expansão binomial ou L'Hôpital repetido: derivadas mostram exponencial domina polinomial.",
                                    "Conclua = ∞, logo pelo teorema, 2^n = ω(n^3).",
                                    "Verifique numericamente para n=10,20,30.",
                                    "Generalize para 2^n = ω(n^k) qualquer k."
                                  ],
                                  "verification": "Calcule o limite e escreva a conclusão ω com valores numéricos de suporte.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Wolfram Alpha ou Python para plotar 2^n / n^3"
                                  ],
                                  "tips": "Para limite, note que Stirling ou indução também funcionam, mas limite é direto.",
                                  "learningObjective": "Aplicar o teorema em exemplo concreto de CS.",
                                  "commonMistakes": [
                                    "Calcular errado o limite (ex: pensar polinomial ganha)",
                                    "Esquecer n discreto, usar log incorreto",
                                    "Não checar numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para provar 2^n = ω(n^3): Compute lim (n→∞) 2^n / n^3. Aplicando L'Hôpital 3 vezes: derivadas de 2^n é (ln2)^k 2^n, de n^3 polinomial, limite ainda ∞. Numericamente: n=10: 1024/1000≈1, n=20:1M/8000≈130k, n=30:1B/27k≈40M → ∞. Logo 2^n = ω(n^3).",
                              "finalVerifications": [
                                "Pode definir ω(g(n)) corretamente com quantificadores?",
                                "Explica a implicação limite ∞ → ω?",
                                "Escreve prova formal sem erros?",
                                "Aplica corretamente ao exemplo 2^n vs n^3?",
                                "Identifica erros comuns em provas semelhantes?",
                                "Generaliza para outros pares f,g?"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na definição e prova (100%)",
                                "Clareza e estrutura lógica da prova",
                                "Uso apropriado de limites e verificações numéricas",
                                "Profundidade nos substeps e tips aplicados",
                                "Conexão explícita entre teoria e exemplo",
                                "Ausência de common mistakes identificados"
                              ],
                              "crossCurricularConnections": [
                                "Cálculo I/II: Limites em ∞ e L'Hôpital",
                                "Matemática Discreta: Crescimento de funções",
                                "Análise de Algoritmos: Classificação de complexidade",
                                "Teoria da Computação: Hierarquia de tempos"
                              ],
                              "realWorldApplication": "Em análise de algoritmos, prova que algoritmos exponenciais como força bruta em TSP (2^n) são ω de polinomiais como aproximações (n^3), guiando escolhas de heurísticas vs exaustivas em otimização prática."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Comparar funções usando little-omega",
                            "description": "Analisar hierarquias de crescimento, identificando quando uma função domina outra estritamente, como n! = ω(n^k) para qualquer k fixo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição Formal de Little-Omega (ω)",
                                  "subSteps": [
                                    "Leia a definição: f(n) = ω(g(n)) se para todo c > 0 existe n0 tal que para todo n ≥ n0, f(n) > c * g(n).",
                                    "Compare com big-O e Theta para destacar a dominância estrita (limite inferior).",
                                    "Estude a equivalência via limites: lim (n→∞) g(n)/f(n) = 0.",
                                    "Anote exemplos iniciais como n² = ω(n).",
                                    "Resuma em suas palavras a diferença entre ω e o(little-o)."
                                  ],
                                  "verification": "Escreva a definição formal e prove n² = ω(n) usando limite.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise de Algoritmos (ex: CLRS), caderno, calculadora simbólica online (Wolfram Alpha)"
                                  ],
                                  "tips": "Visualize graficamente o crescimento para intuitar dominância.",
                                  "learningObjective": "Dominar a definição precisa de little-omega e sua relação com limites.",
                                  "commonMistakes": [
                                    "Confundir com big-Omega (Ω), que permite constantes; inverter f e g."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Provar Dominância Usando Limites e Definição Direta",
                                  "subSteps": [
                                    "Escolha pares de funções: prove n! = ω(n^k) para k fixo usando Stirling (n! ~ sqrt(2πn)(n/e)^n).",
                                    "Calcule lim (n→∞) n^k / n! = 0 via expansão de Stirling ou indução.",
                                    "Use definição direta: para dado c, encontre n0 onde n! > c n^k.",
                                    "Pratique com exponenciais: 2^n = ω(n^k).",
                                    "Teste contra-polos: verifique por que n^k ≠ ω(n log n)."
                                  ],
                                  "verification": "Forneça prova completa para n! = ω(n^3) com n0 explícito.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "CLRS capítulo 3, Wolfram Alpha para limites, papel para cálculos manuais"
                                  ],
                                  "tips": "Use logaritmos para simplificar comparações de crescimento.",
                                  "learningObjective": "Aplicar limites e indução para provar relações ω.",
                                  "commonMistakes": [
                                    "Esquecer de quantificar 'para todo c > 0'; usar big-O em vez de ω."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Hierarquias de Funções Comuns em Complexidade",
                                  "subSteps": [
                                    "Liste hierarquia: log n < n^ε < n < n log n < n^k < c^n < n! para qualquer ε,k,c fixos.",
                                    "Prove pairwise: n log n = ω(n), 2^n = ω(n^k), n! = ω(2^n).",
                                    "Crie tabela de dominâncias com ω.",
                                    "Identifique funções incomparáveis (ex: n! e n^n).",
                                    "Grafique 3 pares para visualizar."
                                  ],
                                  "verification": "Complete tabela de 5 comparações corretas com justificativas breves.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de plotagem (Desmos ou Python Matplotlib), tabela em Excel"
                                  ],
                                  "tips": "Comece com funções polinomiais antes de fatoriais/exponenciais.",
                                  "learningObjective": "Construir e validar hierarquias de crescimento usando ω.",
                                  "commonMistakes": [
                                    "Ignorar constantes em exponenciais; achar n^n = ω(n!) (falso)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar em Contextos de Algoritmos",
                                  "subSteps": [
                                    "Analise tempos: mostre que algoritmo O(n!) domina qualquer O(n^k).",
                                    "Resolva problemas: 'Prove que tempo de brute-force TSP é ω(polynomial).'",
                                    "Crie contraexemplos onde ω não se aplica.",
                                    "Discuta implicações para classes P vs EXP.",
                                    "Revise todas provas anteriores."
                                  ],
                                  "verification": "Escreva análise de 2 algoritmos reais usando ω.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de algoritmos (TSP, permutações), timer para prática"
                                  ],
                                  "tips": "Relacione com master theorem para recorrências.",
                                  "learningObjective": "Integrar ω na análise prática de complexidade.",
                                  "commonMistakes": [
                                    "Aplicar ω a casos finitos; confundir com tempo médio vs pior."
                                  ]
                                }
                              ],
                              "practicalExample": "Prove que o tempo de geração de todas as permutações (O(n!)) domina qualquer algoritmo polinomial de aproximação para TSP: n! = ω(n^{100}), significando que para grandes n, brute-force é impraticável comparado a heurísticas polinomiais.",
                              "finalVerifications": [
                                "Defina corretamente ω e prove n² = ω(n).",
                                "Mostre n! = ω(n^k) para k=5 com limite explícito.",
                                "Classifique hierarquia: log n, n, n log n, 2^n, n! com ω.",
                                "Identifique erro em prova falsa: 'n log n = ω(n^2)'.",
                                "Aplique ω a um algoritmo real (ex: backtracking).",
                                "Explique por que ω é útil para hierarquias estritas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e uso de limites (30%).",
                                "Corretude das provas para pares específicos (25%).",
                                "Completude da hierarquia e tabela de dominâncias (20%).",
                                "Aplicação contextual em algoritmos (15%).",
                                "Clareza e avoidance de erros comuns (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e séries (cálculo avançado).",
                                "Física: Modelagem de crescimento exponencial em populações/decay.",
                                "Engenharia: Análise de escalabilidade em sistemas distribuídos.",
                                "Economia: Crescimento superpolinomial em modelos de complexidade."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, usar ω para provar que problemas NP-hard como TSP têm soluções exatas (brute-force n!) estritamente piores que aproximações polinomiais, guiando escolhas de heurísticas em software de otimização logística (ex: roteirização de entregas na Amazon)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Relação assintótica ~ (equivalência)",
                        "description": "A relação ~ indica que duas funções são assintoticamente equivalentes, f(n) ~ g(n) se f(n)/g(n) → 1 quando n → ∞.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Definir a relação de equivalência assintótica",
                            "description": "Definir f(n) ~ g(n) como lim (n→∞) f(n)/g(n) = 1, com exemplos como (n² + n) ~ n² ou 2n log n ~ n log n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Limites Assintóticos",
                                  "subSteps": [
                                    "Revise o conceito de limite quando n tende ao infinito.",
                                    "Entenda que funções assintóticas descrevem o comportamento dominante para grandes n.",
                                    "Estude exemplos básicos de limites, como lim (n→∞) (n+1)/n = 1.",
                                    "Pratique calcular limites simples envolvendo polinômios e logaritmos.",
                                    "Identifique por que limites são cruciais para análise assintótica em algoritmos."
                                  ],
                                  "verification": "Calcule corretamente 3 limites simples e explique seu significado assintótico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software como Wolfram Alpha",
                                    "Notas de cálculo básico",
                                    "Vídeo tutorial sobre limites (Khan Academy)"
                                  ],
                                  "tips": "Sempre simplifique a expressão antes de aplicar o limite.",
                                  "learningObjective": "Dominar o cálculo de limites para n→∞ como base para relações assintóticas.",
                                  "commonMistakes": "Confundir limite com valor exato; ignorar termos dominantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente a Relação de Equivalência Assintótica ~",
                                  "subSteps": [
                                    "Leia a definição: f(n) ~ g(n) iff lim (n→∞) f(n)/g(n) = 1.",
                                    "Escreva a definição em suas próprias palavras.",
                                    "Compare com outras relações como O, Θ e Ω.",
                                    "Anote símbolos matemáticos corretos: usar ∼ ou ~.",
                                    "Crie um fluxograma para decidir quando usar ~."
                                  ],
                                  "verification": "Escreva a definição formal e distinga de Big-O em um parágrafo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Referência de análise assintótica (CLRS capítulo 3)"
                                  ],
                                  "tips": "Lembre-se: ~ indica equivalência exata no crescimento, não upper bound.",
                                  "learningObjective": "Articular precisamente a definição matemática de f(n) ~ g(n).",
                                  "commonMistakes": "Confundir ~ com ≈ (aproximação numérica); omitir o limite."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Definição a Exemplos Simples",
                                  "subSteps": [
                                    "Verifique (n² + n) ~ n²: compute lim (n→∞) (n² + n)/n² = lim (1 + 1/n) = 1.",
                                    "Verifique 2n log n ~ n log n: lim (n→∞) (2n log n)/(n log n) = 2 * lim 1 = 2? Espere, corrija para constante 1 ajustando.",
                                    "Para 2n log n ~ n log n: sim, pois 2n log n / (n log n) = 2 → mas ~ requer =1, então ajuste para c*n log n com c=1 ou normalize.",
                                    "Exemplo correto: n² + 3n + 1 ~ n².",
                                    "Liste 3 exemplos próprios e verifique o limite."
                                  ],
                                  "verification": "Mostre cálculos para 3 exemplos onde o limite é 1 e 1 contraexemplo onde não é.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para plotar e limites",
                                    "Gráficos de funções assintóticas"
                                  ],
                                  "tips": "Divida numerador e denominador pelos termos de maior grau.",
                                  "learningObjective": "Calcular limites para confirmar equivalência assintótica em exemplos.",
                                  "commonMistakes": "Esquecer de dividir por n→∞ corretamente; ignorar logaritmos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Contraexemplos e Generalizações",
                                  "subSteps": [
                                    "Encontre contraexemplo: n² + n² ~ n²? Não, pois 2n²/n²=2≠1.",
                                    "Discuta quando ~ é útil vs. Θ (Θ permite constantes).",
                                    "Generalize para funções com log: n log n + n ~ n log n.",
                                    "Crie tabela comparando ~, O, Θ para exemplos.",
                                    "Resolva exercícios: prove ou refute 3 afirmações."
                                  ],
                                  "verification": "Identifique corretamente 2 casos onde ~ não se aplica e explique por quê.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de exercícios de algoritmos",
                                    "SymPy ou Mathematica para limites simbólicos"
                                  ],
                                  "tips": "Sempre compute o limite numericamente para grandes n para validar.",
                                  "learningObjective": "Discernir aplicação precisa de ~ e suas limitações.",
                                  "commonMistakes": "Assumir ~ para qualquer constante; confundir com crescimento idêntico."
                                }
                              ],
                              "practicalExample": "Em análise de algoritmos de ordenação, prove que o tempo de QuickSort médio ~ 2n log n é equivalente a n log n para fins assintóticos, pois lim (2n log n)/(n log n) = 2, mas normalize reconhecendo que ~ ignora constantes fixas? Não: estritamente ~ requer 1, então use Θ; mas para ~ exata, (n log n + n) ~ n log n.",
                              "finalVerifications": [
                                "Define corretamente f(n) ~ g(n) usando limite =1.",
                                "Calcula limites para 3 exemplos dados.",
                                "Distingue ~ de O, Ω e Θ.",
                                "Identifica erros comuns em provas.",
                                "Aplica a um problema de algoritmo real.",
                                "Explica intuitivamente o significado assintótico."
                              ],
                              "assessmentCriteria": [
                                "Precisão da definição formal (30%)",
                                "Correção nos cálculos de limites (30%)",
                                "Qualidade dos exemplos e contraexemplos (20%)",
                                "Clareza na distinção de outras notações (10%)",
                                "Criatividade em aplicações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de limites e análise real.",
                                "Física: Assintóticas em leis de escala (ex: lei de potência).",
                                "Engenharia de Software: Otimização de performance.",
                                "Estatística: Análise de crescimento de dados."
                              ],
                              "realWorldApplication": "Na otimização de algoritmos de machine learning, usa-se f(n) ~ g(n) para comparar complexidades de modelos, como tempo de treinamento de redes neurais onde termos inferiores são negligible, guiando escolhas de hardware e escalabilidade em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Verificar equivalência usando expansões assintóticas",
                            "description": "Usar expansões de Taylor ou propriedades logarítmicas para provar ~, como (1 + 1/n)^n ~ e.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Expansões de Taylor e Relações Assintóticas",
                                  "subSteps": [
                                    "Estude a definição de expansão de Taylor para funções suaves ao redor de um ponto.",
                                    "Revise a notação assintótica ~, confirmando que f(n) ~ g(n) significa f(n)/g(n) → 1 quando n → ∞.",
                                    "Identifique funções comuns como exp(x), log(1+x) e suas expansões de Taylor.",
                                    "Pratique expandindo funções simples como e^x = 1 + x + x^2/2! + ... até ordem 3.",
                                    "Discuta limitações: expansões são válidas localmente, mas úteis para assintóticas em ∞."
                                  ],
                                  "verification": "Resolva 3 expansões de Taylor básicas e confirme que f(n)/g(n) → 1 para um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Cálculo (ex: Stewart), calculadora, papel para anotações.",
                                  "tips": "Comece com x pequeno para visualizar convergência; use séries infinitas só para assintóticas.",
                                  "learningObjective": "Compreender como expansões de Taylor aproximam funções para análise assintótica.",
                                  "commonMistakes": "Confundir Taylor com Maclaurin; ignorar termos de ordem superior que afetam o limite."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Propriedades Logarítmicas e Exponenciais para Equivalências",
                                  "subSteps": [
                                    "Revise log(1+x) ~ x - x^2/2 + x^3/3 - ... para |x| < 1.",
                                    "Estude exp(x) ~ 1 + x + x^2/2 + ... e sua inversa.",
                                    "Aprenda a manipular expressões: tome log de ambos os lados para simplificar limites.",
                                    "Pratique derivando ln((1+1/n)^n) = n ln(1+1/n) ~ n*(1/n - 1/(2n^2)) = 1 - 1/(2n).",
                                    "Verifique que exp(ln((1+1/n)^n)) ~ exp(1 - 1/(2n)) ~ e * exp(-1/(2n)) ~ e."
                                  ],
                                  "verification": "Derive a expansão logarítmica para (1+1/n)^n e mostre o limite para 1 após normalizar por e.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software simbólico como Wolfram Alpha ou SymPy, quadro branco.",
                                  "tips": "Sempre normalize dividindo por g(n) antes de expandir; ignore o(1) termos.",
                                  "learningObjective": "Dominar uso de logs e exps em provas assintóticas via expansões.",
                                  "commonMistakes": "Esquecer de exponentiar de volta após log; tratar ln(1+x) ≈ x sem termos corretivos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Expansões a Provas de Equivalência Clássica",
                                  "subSteps": [
                                    "Escolha f(n) = (1+1/n)^n e g(n) = e; compute lim f(n)/g(n).",
                                    "Expanda ln(f(n)) = n ln(1+1/n) usando Taylor até O(1/n^2).",
                                    "Mostre ln(f(n)) → 1, logo f(n) → e^1 = e.",
                                    "Para precisão ~, expanda até mostrar f(n)/e = exp(ln(f(n)) - 1) → exp(0) = 1.",
                                    "Teste numericamente para n=10,100,1000 confirmando aproximação."
                                  ],
                                  "verification": "Escreva prova completa para (1+1/n)^n ~ e, com limite explícito de f/e → 1.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Python para plots numéricos, papel para prova.",
                                  "tips": "Use notação big-O para descartar termos menores; plote log(f(n)/e) para visualização.",
                                  "learningObjective": "Executar prova passo-a-passo de equivalência usando expansões.",
                                  "commonMistakes": "Parar na aproximação grosseira sem provar limite exato de 1; erros em coeficientes Taylor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar e Praticar com Outros Exemplos",
                                  "subSteps": [
                                    "Prove (1 + x_n)^(1/x_n) ~ e quando x_n → 0.",
                                    "Verifique Stirling: n! ~ sqrt(2 pi n) (n/e)^n usando log e Taylor.",
                                    "Aplique a harmônicos: H_n ~ ln n + γ via integral/Taylor.",
                                    "Crie contraexemplo onde Taylor falha (ex: oscilatória).",
                                    "Resolva 2 exercícios independentes envolvendo ~ com expansões."
                                  ],
                                  "verification": "Submeta provas para 2 exemplos adicionais, confirmando f/g → 1 com expansões.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Lista de exercícios (ex: CLRS ou online), timer para prática.",
                                  "tips": "Varie funções: trigonométricas como sin(x)/x ~ 1; sempre cheque ordem dos termos.",
                                  "learningObjective": "Adaptar técnica a novas funções e reconhecer quando usar.",
                                  "commonMistakes": "Aplicar Taylor fora do raio de convergência; confundir ~ com O."
                                }
                              ],
                              "practicalExample": "Para provar (1 + 1/n)^n ~ e: ln((1+1/n)^n) = n ln(1+1/n) = n [1/n - (1/n)^2/2 + (1/n)^3/3 - ...] = 1 - 1/(2n) + 1/(3n^2) - ... → 1. Assim, (1+1/n)^n = exp(1 - 1/(2n) + O(1/n^2)) = e * exp(-1/(2n) + O(1/n^2)) ~ e * (1 - 1/(2n) + ...) ~ e.",
                              "finalVerifications": [
                                "Limite de f(n)/g(n) = 1 computado corretamente com expansões.",
                                "Expansões de Taylor usadas com termos suficientes para o limite.",
                                "Manipulações log/exp justificadas e sem erros algébricos.",
                                "Verificação numérica para n grande (ex: n=10^6) confirma ~ dentro de 1%.",
                                "Prova escrita é clara, com passos numerados e big-O apropriado.",
                                "Identifica quando expansão é válida (n → ∞)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: coeficientes Taylor corretos e limite exato.",
                                "Estrutura da prova: lógico, com subpassos explícitos.",
                                "Generalização: aplica a pelo menos 2 exemplos além do clássico.",
                                "Análise de erros: discute pitfalls como truncagem prematura.",
                                "Criatividade: conecta a aplicações em algoritmos.",
                                "Clareza: explicação acessível para pares."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Algoritmos: aproxima limites em quicksort ou Stirling para contagens.",
                                "Cálculo: séries infinitas e convergência.",
                                "Probabilidade: limites em distribuições (ex: Lei dos Grandes Números).",
                                "Física: aproximações em mecânica quântica ou termodinâmica."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, prova que tempo de merge sort ~ 2 n log n usando harmônicos ~ ln n; otimiza código assintótico em Big Data, prevendo escalabilidade para n→∞ em clusters."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Diferenciar ~ de Θ e little-o",
                            "description": "Explicar as sutis diferenças: f ~ g implica f = Θ(g), mas não o inverso, e contrastar com relações estritas como little-o.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Θ e little-o",
                                  "subSteps": [
                                    "Lembre-se da definição formal de f(n) = Θ(g(n)): existem constantes c1 > 0, c2 > 0 e n0 tal que para todo n ≥ n0, c1 g(n) ≤ f(n) ≤ c2 g(n).",
                                    "Entenda f(n) = o(g(n)): para todo c > 0 existe n0 tal que para n ≥ n0, 0 ≤ f(n) < c g(n), significando f cresce estritamente mais devagar que g.",
                                    "Pratique com exemplos: n^2 = Θ(n^2), n = o(n^2), mas n^2 ≠ o(n).",
                                    "Desenhe gráficos assintóticos para visualizar os limites superior e inferior.",
                                    "Escreva as definições em suas próprias palavras."
                                  ],
                                  "verification": "Você pode explicar verbalmente ou por escrito as definições com exemplos corretos sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Gráficos de funções assintóticas online (ex: Desmos)"
                                  ],
                                  "tips": "Use limites para intuitivamente entender: Θ é sanduíche, little-o é esmagado para zero.",
                                  "learningObjective": "Dominar as noções básicas de limites superior e inferior em notação big-O.",
                                  "commonMistakes": [
                                    "Confundir Θ com = exata",
                                    "Pensar que little-o permite crescimento similar",
                                    "Ignorar a direção assintótica (n→∞)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Notação de Equivalência Assintótica ~",
                                  "subSteps": [
                                    "Defina f(n) ~ g(n) como lim (n→∞) f(n)/g(n) = 1.",
                                    "Note que isso implica f e g crescem na mesma taxa exata assintoticamente.",
                                    "Prove intuitivamente: se f/g → 1, então f está entre (1-ε)g e (1+ε)g para grandes n.",
                                    "Compare com Θ: ~ é mais restritiva que Θ.",
                                    "Exemplo: 2n ~ n, pois (2n)/n = 2 →? Não, limite é 2 ≠1. Corrija: n+1 ~ n, limite=1."
                                  ],
                                  "verification": "Calcule corretamente o limite de f/g para 3 exemplos dados e identifique se ~ holds.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como Wolfram Alpha",
                                    "Folha de exercícios com limites"
                                  ],
                                  "tips": "Sempre compute lim f/g explicitamente; use L'Hôpital se indeterminado.",
                                  "learningObjective": "Compreender a definição precisa de ~ via limites e sua força.",
                                  "commonMistakes": [
                                    "Confundir ~ com Θ (ex: n^2 + n ~ n^2? Não, limite=1 mas Θ sim)",
                                    "Esquecer que ~ requer limite exatamente 1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar e Entender ~ Implica Θ, mas Não o Inverso",
                                  "subSteps": [
                                    "Prove: Se f ~ g, então f = Θ(g). Dado lim f/g=1, para ε=0.5, existe n0 tal que |f/g -1| <0.5, logo 0.5g < f <1.5g.",
                                    "Encontre contraexemplo: f=n^2 + n, g=n^2. Θ sim (c1=1, c2=2), mas lim f/g=1? Não, =1 mas espere: lim (n^2+n)/n^2=1+1/n=1. Sim ~! Erro comum: n^2 + n^2/2 ~ n^2? Não, lim=1.5.",
                                    "Melhor contraexemplo: f= n^2 + n, g=n^2: lim=1, sim ~. Use f=2n^2, g=n^2: lim=2≠1, Θ sim.",
                                    "Liste propriedades: ~ é reflexiva, simétrica, transitiva (equivalência).",
                                    "Pratique provando 2 exemplos onde Θ holds mas ~ não."
                                  ],
                                  "verification": "Forneça prova curta de ~⇒Θ e 2 contraexemplos válidos para Θ mas não ~.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Algoritmos (CLRS capítulo assintóticas)",
                                    "Editor de LaTeX para provas"
                                  ],
                                  "tips": "Para contraexemplos, escolha coeficientes constantes ≠1 em Θ.",
                                  "learningObjective": "Distinguir a equivalência forte (~) da bounded (~Θ).",
                                  "commonMistakes": [
                                    "Achar que todo Θ é ~ (esquecer limite exato 1)",
                                    "Provas sem quantificar ε e n0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com little-o e Praticar Diferenciações",
                                  "subSteps": [
                                    "Compare: ~ é 'igualdade assintótica', little-o é 'estritamente menor', Θ é 'mesma ordem'.",
                                    "Exemplo: n = o(n log n), mas n ≠ Θ(n log n), e n ~ n (óbvio).",
                                    "Crie tabela comparativa: Colunas ~, Θ, o; linhas exemplos como n vs n^2.",
                                    "Resolva problemas: Classifique n^2 log n vs n^2: Θ sim, ~ não (lim=∞? Não log n→∞, lim=∞ então o(n^2)? Não.",
                                    "n^2 log n / n^2 = log n →∞, então n^2 log n = ω(n^2), não Θ."
                                  ],
                                  "verification": "Classifique corretamente 5 pares de funções em ~, Θ, o.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em Excel ou papel",
                                    "Lista de funções comuns: n, n log n, n^2, 2^n"
                                  ],
                                  "tips": "Use logaritmos para simplificar limites complexos.",
                                  "learningObjective": "Aplicar todas as noções em classificações precisas.",
                                  "commonMistakes": [
                                    "Confundir direção: f=o(g) não implica g=Ω(f)",
                                    "Ignorar constantes em little-o"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao analisar quicksort, o tempo médio é ~ 2n ln n, implicando Θ(n ln n), mas distinguindo de worst-case Θ(n^2). Use ~ para precisão em implementações otimizadas, evitando superestimar com Θ solto.",
                              "finalVerifications": [
                                "Explique por que f ~ g implica f=Θ(g) mas não vice-versa com prova esboçada.",
                                "Forneça contraexemplo onde f=Θ(g) mas f ≠ g~.",
                                "Classifique corretamente: n^2 + 3n ~ n^2? (Sim, lim=1).",
                                "Diferencie little-o: dê exemplo onde f ~ g mas nem f nem g é o do outro.",
                                "Crie seu próprio par de funções e classifique todas três relações.",
                                "Desenhe gráfico mostrando curvas ~, Θ mas não ~, e o."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (limites corretos).",
                                "Uso correto de contraexemplos (limites ≠1 para Θ sem ~).",
                                "Profundidade nas provas (ε-δ ou n0 explicitos).",
                                "Capacidade de classificar novos pares sem erros.",
                                "Integração com little-o em comparações.",
                                "Clareza em tabelas/gráficos explicativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e cálculo assintótico.",
                                "Análise Numérica: Erros de aproximação em simulações.",
                                "Física: Assintóticas em modelos de crescimento exponencial.",
                                "Economia: Modelos de crescimento assintótico em funções de custo."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, usar ~ para otimizar código onde coeficientes exatos importam (ex: cache em mergesort vs Θ genérico), prevendo performance precisa em big data sem superestimar recursos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Hierarquia de Crescimento de Funções",
                    "description": "Comparação do crescimento de funções comuns: logarítmica, linear, polinomial, exponencial.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Funções Logarítmicas",
                        "description": "Compreensão do crescimento lento das funções logarítmicas, como log₂ n ou ln n, que representam o número de iterações em algoritmos de divisão e conquista eficientes, posicionadas no topo da hierarquia de crescimento assintótico.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Identificar funções logarítmicas comuns",
                            "description": "Reconhecer e nomear funções como log₂ n, log₁₀ n e ln n, entendendo suas propriedades básicas, como log_b (a^c) = c * log_b a e mudança de base log_b a = log_k a / log_k b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender definições básicas das funções logarítmicas comuns",
                                  "subSteps": [
                                    "Defina log₂ n como o logaritmo na base 2, usado em computação para potências de 2.",
                                    "Defina log₁₀ n como logaritmo comum (base 10), comum em escalas decimais.",
                                    "Defina ln n como logaritmo natural (base e ≈ 2.718), fundamental em cálculo e crescimento contínuo.",
                                    "Compare as bases: base 2 para binário, base 10 para humanos, base e para matemática avançada.",
                                    "Escreva exemplos numéricos: log₂ 8 = 3, log₁₀ 100 = 2, ln e = 1."
                                  ],
                                  "verification": "Liste corretamente as definições e três exemplos numéricos para cada função sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Calculadora ou software como Desmos/GeoGebra"
                                  ],
                                  "tips": "Use tabelas para comparar bases e memorize exemplos chave como potências exatas.",
                                  "learningObjective": "Reconhecer as três funções logarítmicas comuns e suas bases associadas.",
                                  "commonMistakes": [
                                    "Confundir bases: log₂ com ln",
                                    "Esquecer que ln usa base e, não 10"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar identificação e nomeação em expressões matemáticas",
                                  "subSteps": [
                                    "Analise expressões como f(n) = log₂ (n²) e identifique a função base.",
                                    "Nomeie variações: log n geralmente significa log₂ n em CS, mas especifique sempre.",
                                    "Identifique em contextos: log₁₀ em medidas de pH, ln em funções exponenciais.",
                                    "Crie uma tabela de identificação: coluna para expressão, coluna para nome e base.",
                                    "Resolva 10 expressões mistas, como 3 log₂ n ou log₁₀ (10^n)."
                                  ],
                                  "verification": "Identifique corretamente 10 expressões dadas, nomeando base e tipo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Lista de 20 expressões de prática (criar ou buscar online)",
                                    "Planilha Excel ou Google Sheets para tabelas"
                                  ],
                                  "tips": "Sempre pergunte: 'Qual é a base explícita ou implícita?' em contextos de CS.",
                                  "learningObjective": "Nomear precisamente funções logarítmicas em expressões isoladas ou compostas.",
                                  "commonMistakes": [
                                    "Ignorar subscritos de base",
                                    "Assumir log sempre base 10"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a propriedade de potência: log_b (a^c) = c * log_b a",
                                  "subSteps": [
                                    "Prove intuitivamente: log_b (b^k) = k, então para a^c onde a = b^m.",
                                    "Aplique em exemplos: log₂ (8^3) = 3 * log₂ 8 = 3*3 = 9.",
                                    "Pratique com bases mistas: ln (e^5) = 5 * ln e = 5.",
                                    "Simplifique expressões complexas: log₁₀ (100^x * 10) usando a propriedade.",
                                    "Verifique com calculadora: compute ambos os lados para confirmação."
                                  ],
                                  "verification": "Simplifique 5 expressões usando a propriedade e verifique numericamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou Wolfram Alpha",
                                    "Exercícios impressos ou digitais"
                                  ],
                                  "tips": "Puxe o expoente para fora: multiplique pelo coeficiente c.",
                                  "learningObjective": "Aplicar corretamente a propriedade de potência em logaritmos.",
                                  "commonMistakes": [
                                    "Esquecer o multiplicador c",
                                    "Confundir com propriedades de exponenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender e aplicar a fórmula de mudança de base: log_b a = log_k a / log_k b",
                                  "subSteps": [
                                    "Memorize a fórmula e justifique: muda o expoente para base k.",
                                    "Exemplo prático: log₂ 10 = log₁₀ 10 / log₁₀ 2 ≈ 1 / 0.3010 ≈ 3.32.",
                                    "Use ln para mudança: comum em calculadoras sem todas as bases.",
                                    "Converta entre log₂, log₁₀ e ln em 5 exemplos.",
                                    "Aplique em análise: converter log₃ n para base 2 em complexidade."
                                  ],
                                  "verification": "Converta 5 logaritmos entre bases diferentes com precisão de 2 casas decimais.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Calculadora ou Python/Jupyter para log()",
                                    "Tabela de valores log conhecidos"
                                  ],
                                  "tips": "Prefira log₁₀ ou ln para cálculos práticos; memorize log₂ 10 ≈ 3.32.",
                                  "learningObjective": "Converter logaritmos entre bases usando a fórmula.",
                                  "commonMistakes": [
                                    "Inverter numerador/denominador",
                                    "Usar base errada no denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar identificação em contextos de análise de algoritmos",
                                  "subSteps": [
                                    "Identifique logs em notação Big O: O(log n) geralmente log₂ n.",
                                    "Compare crescimento: log₂ n vs n, plotando gráficos mentais.",
                                    "Analise exemplos: busca binária O(log₂ n), árvores balanceadas.",
                                    "Resolva problemas: 'Qual log em O(log₃ n²)?' → 2 log₃ n.",
                                    "Crie 3 exemplos próprios de algoritmos com logs comuns."
                                  ],
                                  "verification": "Analise 5 complexidades de algoritmos identificando e simplificando logs.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Gráficos de crescimento de funções (online ou papel)",
                                    "Exemplos de algoritmos de CS"
                                  ],
                                  "tips": "Em CS, assuma base 2 a menos que especificado; foque em hierarquia.",
                                  "learningObjective": "Identificar funções logarítmicas em cenários reais de complexidade computacional.",
                                  "commonMistakes": [
                                    "Ignorar propriedades ao simplificar Big O",
                                    "Confundir log com linear"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de busca binária, o tempo é O(log₂ n). Identifique: log₂ (n/2)^k = k log₂ (n/2) = k (log₂ n - 1), usando potência e propriedades básicas para provar eficiência.",
                              "finalVerifications": [
                                "Nomeie corretamente log₂ n, log₁₀ n e ln n em 10 expressões aleatórias.",
                                "Simplifique 5 expressões usando log_b (a^c) = c log_b a.",
                                "Converta log₃ 8 para base 2 com erro < 0.01.",
                                "Identifique logs em 3 complexidades Big O de algoritmos comuns.",
                                "Explique verbalmente a mudança de base para um par de bases.",
                                "Compare crescimento: prove log n cresce mais lento que n^ε para ε>0."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de bases (100% correto).",
                                "Aplicação correta de propriedades em simplificações (>90% acerto).",
                                "Uso fluido da mudança de base em cálculos numéricos.",
                                "Conexão com contextos de CS (exemplos relevantes).",
                                "Explicações claras e sem erros conceituais.",
                                "Criatividade em exemplos próprios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra e funções exponenciais/logarítmicas.",
                                "Física: Escalas logarítmicas em decibéis (log₁₀) e decaimento radioativo (ln).",
                                "Química: pH como -log₁₀ [H+].",
                                "Estatística: Escalas log em distribuições probabilísticas.",
                                "Engenharia: Compressão de dados e sinal (logs base 2)."
                              ],
                              "realWorldApplication": "Em ciência da computação, identificar log₂ n é crucial para analisar eficiência de algoritmos como busca binária (O(log n) tempo), árvores AVL/BST, e segment trees, permitindo prever escalabilidade para grandes n, como em bancos de dados com milhões de registros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Calcular crescimento logarítmico",
                            "description": "Calcular valores aproximados de log n para n grandes (ex: log₂ 1024 = 10) e interpretar graficamente seu crescimento lento comparado a funções lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Logaritmos Base 2",
                                  "subSteps": [
                                    "Defina log₂(n) como o expoente x tal que 2^x = n.",
                                    "Memorize valores conhecidos: log₂(1)=0, log₂(2)=1, log₂(4)=2, log₂(8)=3, log₂(16)=4, log₂(32)=5, log₂(64)=6.",
                                    "Aprenda propriedades: log₂(2^k)=k, log₂(a*b)=log₂(a)+log₂(b), log₂(a^b)=b*log₂(a).",
                                    "Pratique convertendo potências de 2 em logs: 2^10=1024 → log₂(1024)=10.",
                                    "Explique intuitivamente: log₂(n) conta quantas vezes divide n por 2 até chegar a 1."
                                  ],
                                  "verification": "Escreva e explique corretamente log₂(512) e log₂(1) com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de potências de 2 até 2^20"
                                  ],
                                  "tips": "Visualize como 'quantas divisões por 2 para chegar a 1' – isso ajuda na intuição.",
                                  "learningObjective": "Dominar definição, valores básicos e propriedades de log₂ para cálculos iniciais.",
                                  "commonMistakes": [
                                    "Confundir log₂ com log₁₀ (use potências de 2 sempre)",
                                    "Esquecer log₂(1)=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Técnica de Aproximação para n Grandes",
                                  "subSteps": [
                                    "Encontre a maior potência de 2 menor ou igual a n (ex: para 1000, 2^9=512, 2^10=1024).",
                                    "Calcule log₂(n) ≈ k + fração, onde k é o expoente da potência menor e fração = log₂(n / 2^k).",
                                    "Aproxime frações: 2^0.3≈1.23, 2^0.5≈1.41, 2^0.7≈1.62; pratique para 0.1-0.9.",
                                    "Exemplo: log₂(1000) ≈ 9 + log₂(1000/512)=9 + log₂(1.95)≈9+0.96=9.96≈10.",
                                    "Pratique com n=1e6 (1.000.000): 2^19=524288, 2^20=1.048.576 → ≈19.93."
                                  ],
                                  "verification": "Aproxime log₂(50000) com erro <5% e justifique os passos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora para verificação opcional",
                                    "Lista de potências de 2 até 2^30"
                                  ],
                                  "tips": "Sempre anote 2^k mais próximo; frações abaixo de 0.5 são conservadoras.",
                                  "learningObjective": "Aplicar método de aproximação por potências para logs de números grandes sem calculadora.",
                                  "commonMistakes": [
                                    "Escolher potência errada (sempre teste 2^k <=n <2^{k+1})",
                                    "Ignorar fração, superestimando"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Crescimento Logarítmico Numericamente",
                                  "subSteps": [
                                    "Calcule logs para sequência: n=10,100,1000,10k,100k,1M,10M → logs≈3.3,6.6,10,13.3,16.6,20,23.3.",
                                    "Observe padrão: cada 10x em n adiciona ~3.3 ao log₂ (devido log₂(10)≈3.32).",
                                    "Compare com linear: para n=1M, linear=1M, log₂≈20 (muito menor).",
                                    "Tabela: n | log₂(n) | n (linear)",
                                    "Regra prática: log₂(10^k)≈3.32k para estimativas rápidas."
                                  ],
                                  "verification": "Crie tabela comparando log₂(n) e n para 5 valores grandes e note o crescimento lento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou papel quadriculado",
                                    "Valores pré-calculados de potências"
                                  ],
                                  "tips": "Use 'log₂(n) cresce como número de dígitos' para memória.",
                                  "learningObjective": "Reconhecer numericamente o crescimento lento de log₂(n) vs funções lineares.",
                                  "commonMistakes": [
                                    "Pensar log cresce rápido (não, é o inverso do exponencial)",
                                    "Erros aritméticos em sequências"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Comparar Graficamente",
                                  "subSteps": [
                                    "Plote eixos: x=1 a 1024 (ou mais), y=log₂(x) e y=x (linear).",
                                    "Use pontos chave: (1,0), (2,1), (4,2),...,(1024,10) para log; linha reta para linear.",
                                    "Observe: log₂ curva suave subindo devagar; linear explode.",
                                    "Adicione n=10k (≈13.3), 100k(≈16.6) para enfatizar lentidão.",
                                    "Interprete: 'Log₂ atinge 20 em 1M, linear já em 1M'."
                                  ],
                                  "verification": "Desenhe gráfico mostrando log₂(x) abaixo de x para x>1, com 5 pontos marcados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel milimetrado ou ferramenta como Desmos/GeoGebra",
                                    "Dados de steps anteriores"
                                  ],
                                  "tips": "Escala log no y opcional para melhor visual, mas foque em linear primeiro.",
                                  "learningObjective": "Interpretar graficamente por que log₂(n) cresce mais lento que linear em contextos de algoritmos.",
                                  "commonMistakes": [
                                    "Escala errada no gráfico (use log para x se necessário)",
                                    "Pontos imprecisos"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule approx log₂(1.000.000): 2^20=1.048.576 → ≈19.93. Plote y=log₂(x) e y=x de x=1 a 1M; observe que em 1M, log=20 vs linear=1M, ilustrando eficiência em buscas binárias (20 passos vs 1M).",
                              "finalVerifications": [
                                "Calcule exatamente log₂(4096) e approx log₂(5000) com erro <1.",
                                "Liste 5 potências de 2 e seus logs.",
                                "Crie tabela: n=10^k para k=1-6 com log₂ approx.",
                                "Descreva em 2 frases por que log₂ cresce lento.",
                                "Desenhe gráfico simples log₂ vs linear até 1024."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Aproximações de log₂(n) dentro de 5% para n>1000.",
                                "Compreensão: Correta explicação de propriedades e intuição (divisões por 2).",
                                "Visualização: Gráficos mostram claramente crescimento lento vs linear.",
                                "Aplicação: Relaciona a análise de algoritmos (ex: O(log n) eficiente).",
                                "Completude: Todos cálculos e tabelas com justificativas.",
                                "Criatividade: Exemplos próprios além dos dados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra exponencial e funções inversas.",
                                "Física: Escalas logarítmicas em magnitudes (terremotos Richter, decibéis).",
                                "Biologia: Modelos de crescimento populacional (log para fases iniciais).",
                                "Economia: Crescimento composto e juros (log para taxas).",
                                "Engenharia: Profundidade de árvores binárias em estruturas de dados."
                              ],
                              "realWorldApplication": "Na análise de algoritmos, calcular log₂(n) estima passos em buscas binárias ou altura de árvores balanceadas; crescimento lento garante eficiência para big data (ex: log₂(1 bilhão)≈30 passos vs linear 1 bi)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Associar a algoritmos",
                            "description": "Exemplificar algoritmos com complexidade logarítmica, como busca binária e árvores balanceadas, justificando por que log n iterações resolvem problemas de tamanho n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Complexidade Logarítmica",
                                  "subSteps": [
                                    "Revise a definição de função logarítmica: log₂(n) representa o número de vezes que n deve ser dividido por 2 para chegar a 1.",
                                    "Entenda por que log n é eficiente: cada iteração halves o problema, resolvendo problemas grandes com poucas divisões.",
                                    "Compare com linear (n) e quadrático (n²) usando gráficos de crescimento.",
                                    "Calcule exemplos manuais: log₂(1024) = 10, significando 10 divisões para 1024 elementos.",
                                    "Discuta notação Big O: O(log n) para algoritmos que dividem o espaço de busca."
                                  ],
                                  "verification": "Resolva 5 exercícios de cálculo logarítmico e explique em voz alta por que log n resolve n elementos em poucas iterações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora, planilha Excel para gráficos, Khan Academy vídeo sobre logaritmos.",
                                  "tips": "Visualize como cortar uma pizza: cada corte logarítmico divide em metades perfeitas.",
                                  "learningObjective": "Explicar matematicamente por que log n iterações bastam para problemas de tamanho n.",
                                  "commonMistakes": "Confundir log n com n log n; sempre baseie em divisões por 2 para clareza."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Busca Binária como Exemplo Clássico",
                                  "subSteps": [
                                    "Implemente busca binária em Python para uma lista ordenada de 1 a 1.000.000.",
                                    "Trace o algoritmo passo a passo: inicie com low=0, high=n-1, calcule mid e compare.",
                                    "Meça iterações: para n=1.000.000, máximo ~20 passos (log₂(1e6)≈20).",
                                    "Compare com busca linear: execute ambos e cronometre tempos reais.",
                                    "Justifique: cada comparação elimina metade da busca, levando a log n comparações."
                                  ],
                                  "verification": "Implemente e teste busca binária encontrando um elemento em <25 iterações para n=1e6; grave vídeo da execução.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor Python (VS Code), lista ordenada gerada por código, stopwatch para timing.",
                                  "tips": "Sempre ordene a lista primeiro; use print statements para visualizar divisões.",
                                  "learningObjective": "Demonstrar como busca binária exemplifica O(log n) na prática.",
                                  "commonMistakes": "Esquecer de ordenar a lista; confundir índices low/high em recursão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Árvores Balanceadas e sua Complexidade Logarítmica",
                                  "subSteps": [
                                    "Estude Binary Search Tree (BST): inserção/busca em altura h = log n se balanceada.",
                                    "Implemente inserção em AVL Tree (auto-balanceada) usando rotação.",
                                    "Simule inserções: adicione 15 elementos e verifique altura máxima ~4 (log₂(15)≈4).",
                                    "Compare com BST desbalanceado (vira linear) vs. balanceado (permanece log n).",
                                    "Justifique: balanceamento garante altura log n, tornando operações O(log n)."
                                  ],
                                  "verification": "Construa AVL com 31 nós, confirme altura=5 e busque raiz em 5 passos; exporte diagrama.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Biblioteca Python treap ou código AVL pronto, visualizador de árvores online (VisuAlgo).",
                                  "tips": "Desenhe árvores no papel primeiro para entender rotações antes de codificar.",
                                  "learningObjective": "Associar árvores balanceadas a log n via manutenção de altura balanceada.",
                                  "commonMistakes": "Ignorar balanceamento, levando a O(n); não verificar fator de balanceamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Justificar Associações Logarítmicas",
                                  "subSteps": [
                                    "Compile exemplos: liste 5 algoritmos O(log n) e justifique divisões sucessivas.",
                                    "Crie tabela comparativa: busca binária vs. árvores vs. outros (merge sort divide).",
                                    "Explique generalização: problemas 'dividir para conquistar' naturalmente log n.",
                                    "Teste cenários: reduza n de 1e6 para 1e3 e observe iterações cair de 20 para 10.",
                                    "Discuta limitações: requer ordenação ou balanceamento prévio."
                                  ],
                                  "verification": "Escreva relatório de 1 página justificando log n para 3 algoritmos com traçamentos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel/caneta para tabelas, Google Docs para relatório.",
                                  "tips": "Use analogia de dicionário: folhear metades até achar palavra (log n páginas).",
                                  "learningObjective": "Justificar unificada por que log n resolve escala n eficientemente.",
                                  "commonMistakes": "Generalizar demais sem pré-condições como ordenação."
                                }
                              ],
                              "practicalExample": "Implemente busca binária em uma lista de 1 milhão de números ordenados para encontrar 500.000: o algoritmo fará no máximo 20 comparações, demonstrando log₂(1e6)≈20, enquanto busca linear faria em média 500.000 comparações. Visualize com prints e gráfico de iterações vs. n.",
                              "finalVerifications": [
                                "Calcule corretamente log₂(1.024)=10 e explique iterações em busca binária.",
                                "Implemente e execute busca binária/AVL com medição de passos < log n +1.",
                                "Trace manualmente árvore balanceada de 16 folhas em altura 4.",
                                "Compare tempos reais: O(log n) vs. O(n) em dataset grande.",
                                "Justifique em 3 frases por quê log n escala para big data.",
                                "Identifique 2 pré-condições para O(log n) (ex: ordenado)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na justificativa matemática de log n (80% correto).",
                                "Implementações funcionais sem bugs em busca binária e AVL.",
                                "Análises traçadas com contagem exata de iterações.",
                                "Uso correto de notação Big O em exemplos.",
                                "Criatividade em analogias reais para explicação.",
                                "Relatório claro e conciso com tabelas/gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de logaritmos e hierarquia assintótica.",
                                "Física: Princípio de divide-and-conquer similar a bifurcações em sistemas dinâmicos.",
                                "Estatística: Busca em dados ordenados para queries eficientes.",
                                "Engenharia: Otimização de estruturas de dados em software embarcado."
                              ],
                              "realWorldApplication": "Em bancos de dados como PostgreSQL, índices B-trees usam O(log n) para queries em bilhões de registros, permitindo apps como Google Search responderem em milissegundos; em jogos, árvores quad para colisões rápidas em mundos abertos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Funções Polinomiais",
                        "description": "Análise do crescimento de funções polinomiais n^k para k ≥ 1 (lineares quando k=1, quadráticas k=2 etc.), que dominam logarítmicas mas são gerenciáveis para n razoáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Classificar graus polinomiais",
                            "description": "Diferenciar funções lineares (O(n)), quadráticas (O(n²)) e de graus superiores, calculando coeficientes dominantes em expressões como 3n² + 2n + 1 ~ 3n².",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de polinômios e graus",
                                  "subSteps": [
                                    "Defina um polinômio como uma soma de termos na forma a_k * n^k, onde k é o expoente.",
                                    "Explique que o grau de um polinômio é o maior expoente k com coeficiente não zero.",
                                    "Diferencie termos constantes (grau 0), lineares (grau 1), quadráticos (grau 2) e superiores.",
                                    "Identifique exemplos simples: 5 (grau 0), 3n (grau 1), 2n² + n (grau 2).",
                                    "Pratique reescrevendo expressões para destacar expoentes."
                                  ],
                                  "verification": "Liste corretamente o grau de 3 polinômios dados sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Sempre ordene os termos por grau decrescente para visualizar melhor.",
                                  "learningObjective": "Entender os fundamentos de polinômios e seu grau.",
                                  "commonMistakes": [
                                    "Confundir grau com número de termos",
                                    "Ignorar coeficientes zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o termo dominante em uma expressão polinomial",
                                  "subSteps": [
                                    "Ordene os termos do polinômio em ordem decrescente de expoentes.",
                                    "Localize o termo com o maior expoente (termo dominante).",
                                    "Confirme que seu coeficiente é não zero.",
                                    "Aproxime o polinômio pelo termo dominante: ex. 3n² + 2n + 1 ≈ 3n².",
                                    "Teste com variações: remova termos menores e compare comportamentos assintóticos."
                                  ],
                                  "verification": "Aproxime corretamente 4 expressões pelo termo dominante.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios com polinômios",
                                    "Gráficos online de funções (opcional)"
                                  ],
                                  "tips": "Pense em n grande: termos de grau menor tornam-se insignificantes.",
                                  "learningObjective": "Localizar e isolar o termo que dita o crescimento.",
                                  "commonMistakes": [
                                    "Escolher termo com maior coeficiente em vez de maior grau",
                                    "Esquecer de verificar coeficiente zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar funções polinomiais por grau e notação Big O",
                                  "subSteps": [
                                    "Mapeie graus para classes: grau 0 = constante O(1), grau 1 = linear O(n), grau 2 = quadrático O(n²).",
                                    "Classifique exemplos: 4n³ + n² = cúbico O(n³).",
                                    "Compare hierarquia de crescimento: O(1) < O(n) < O(n²) < O(n³).",
                                    "Aplique a funções de algoritmos: bubble sort ~ O(n²).",
                                    "Crie uma tabela de classificação para 5 funções."
                                  ],
                                  "verification": "Classifique 5 funções com grau e Big O corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de hierarquia de Big O",
                                    "Exemplos de algoritmos"
                                  ],
                                  "tips": "Lembre-se: Big O ignora constantes e termos inferiores.",
                                  "learningObjective": "Associar graus polinomiais à complexidade computacional.",
                                  "commonMistakes": [
                                    "Confundir O(n²) com linear",
                                    "Incluir todos os termos no Big O"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação em contextos de algoritmos",
                                  "subSteps": [
                                    "Analise complexidades reais: selection sort (O(n²)), linear search (O(n)).",
                                    "Classifique polinômios de tempo/espaço de algoritmos dados.",
                                    "Compare crescimento plotando ou calculando para n=10,100,1000.",
                                    "Resolva problemas: 'Qual algoritmo é mais eficiente para n grande?'",
                                    "Autoavalie com quiz de 10 itens."
                                  ],
                                  "verification": "Resolva um conjunto de 5 problemas de classificação sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de complexidades de algoritmos comuns",
                                    "Ferramenta de plotagem como Desmos"
                                  ],
                                  "tips": "Visualize graficamente para internalizar o crescimento.",
                                  "learningObjective": "Aplicar classificação em cenários reais de análise de algoritmos.",
                                  "commonMistakes": [
                                    "Ignorar assintótica e focar em casos pequenos",
                                    "Confundir tempo com espaço"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o algoritmo de Bubble Sort com tempo T(n) = n(n-1)/2 ≈ (1/2)n², classifique como quadrático O(n²): identifique termo dominante n², grau 2, e compare com linear O(n) mostrando que para n=1000, O(n²) é 500x maior.",
                              "finalVerifications": [
                                "Classifica corretamente o grau de 10 polinômios variados.",
                                "Aproxima expressões pelo termo dominante em 8/10 casos.",
                                "Mapeia graus para Big O sem erros em hierarquia.",
                                "Explica diferenças de crescimento com exemplos numéricos.",
                                "Aplica a 5 complexidades de algoritmos reais.",
                                "Identifica erros comuns em classificações dadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do termo dominante (40%)",
                                "Correta classificação de grau e Big O (30%)",
                                "Explicação clara do raciocínio assintótico (15%)",
                                "Uso de exemplos práticos e comparações (10%)",
                                "Ausência de erros comuns como confundir coeficientes (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra polinomial e limites assintóticos.",
                                "Física: Modelagem de movimento com funções polinomiais (ex. posição quadrática).",
                                "Engenharia de Software: Otimização de performance de código.",
                                "Economia: Análise de custos escaláveis em funções de produção."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, classificar o grau polinomial da complexidade de um algoritmo como O(n²) para Bubble Sort permite escolher alternativas O(n log n) como Merge Sort para grandes datasets, otimizando tempo de execução em aplicações como busca em bancos de dados ou processamento de big data."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Comparar polinomiais de diferentes graus",
                            "description": "Determinar limites assintóticos, provando que para k > m, n^k domina n^m quando n → ∞, usando divisão de polinomiais ou L'Hôpital.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Dominância Assintótica",
                                  "subSteps": [
                                    "Defina limite assintótico quando n → ∞.",
                                    "Explique o que significa f(n) domina g(n) se lim (g(n)/f(n)) = 0.",
                                    "Diferencie graus de polinomiais: identifique o grau como o expoente mais alto.",
                                    "Classifique exemplos: n^3 vs n^2, onde 3 > 2 implica dominância.",
                                    "Discuta notação Big-O informalmente para motivação."
                                  ],
                                  "verification": "Escreva definições corretas e classifique 3 pares de polinomiais corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno, calculadora, vídeo introdutório sobre limites assintóticos.",
                                  "tips": "Visualize graficamente funções para intuição inicial.",
                                  "learningObjective": "Compreender a definição formal de dominância assintótica para polinomiais.",
                                  "commonMistakes": "Confundir dominância com igualdade de graus; ignorar coeficientes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Divisão de Polinomiais",
                                  "subSteps": [
                                    "Revise algoritmo de divisão longa para polinomiais.",
                                    "Pratique dividindo polinômio de grau k por grau m (k > m).",
                                    "Identifique quociente (n^{k-m}) e resto (grau < m).",
                                    "Escreva forma geral: n^k / n^m = n^{k-m} + resto/n^m.",
                                    "Verifique com exemplos numéricos para n grande."
                                  ],
                                  "verification": "Realize 3 divisões corretas, mostrando quociente e resto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel milimetrado, software como GeoGebra ou Wolfram Alpha para verificação.",
                                  "tips": "Sempre ordene termos por grau decrescente antes de dividir.",
                                  "learningObjective": "Executar divisão polinomial para expressar razões de polinomiais.",
                                  "commonMistakes": "Erros em sinais durante divisão; esquecer de dividir o resto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar Dominância Usando Limites e Divisão",
                                  "subSteps": [
                                    "Escreva lim (n→∞) n^m / n^k para k > m.",
                                    "Use divisão: = lim [1/n^{k-m} + resto/n^k].",
                                    "Mostre que 1/n^{k-m} → 0 e resto/n^k → 0.",
                                    "Generalize para polinomiais com coeficientes: a n^k + ... domina b n^m.",
                                    "Teste com valores grandes de n para confirmação numérica."
                                  ],
                                  "verification": "Escreva prova completa para um exemplo específico como n^3 / n^2.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Caderno, tabela de valores para n=10,100,1000.",
                                  "tips": "Foque no termo líder; ignore inferiores para assíntotica.",
                                  "learningObjective": "Provar formalmente dominância via limites e divisão polinomial.",
                                  "commonMistakes": "Não levar limite corretamente; confundir numerador e denominador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Regra de L'Hôpital para Casos Indeterminados",
                                  "subSteps": [
                                    "Identifique quando lim n^m / n^k é ∞/∞.",
                                    "Aplique L'Hôpital: derive numerador e denominador.",
                                    "Repita até forma resolvida, mostrando → 0.",
                                    "Compare com divisão: valide equivalência.",
                                    "Pratique com polinomiais não-monômios, ex: (n^2 + n)/n^3."
                                  ],
                                  "verification": "Resolva 2 limites usando L'Hôpital, confirmando resultado 0.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Calculadora simbólica ou SymPy online, regras de derivação.",
                                  "tips": "L'Hôpital é útil para funções racionais; confirme derivadas.",
                                  "learningObjective": "Usar L'Hôpital como alternativa para provar dominância.",
                                  "commonMistakes": "Aplicar L'Hôpital sem forma ∞/∞; erros em derivadas múltiplas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Sintetizar Comparações",
                                  "subSteps": [
                                    "Compare 5 pares de polinomiais variados.",
                                    "Crie tabela hierárquica de crescimento.",
                                    "Discuta exceções: quando k = m.",
                                    "Aplique em contexto de algoritmos: O(n^2) vs O(n log n).",
                                    "Resolva exercícios mistos com divisão e L'Hôpital."
                                  ],
                                  "verification": "Complete tabela e 3 provas independentes sem erros.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folha de exercícios personalizada, timer.",
                                  "tips": "Sempre pergunte: qual grau maior? Domina.",
                                  "learningObjective": "Aplicar métodos fluidamente em comparações reais.",
                                  "commonMistakes": "Ignorar termos de grau igual; não generalizar."
                                }
                              ],
                              "practicalExample": "Para provar que n^3 domina n^2 + 5n quando n → ∞: Divida (n^2 + 5n)/n^3 = 1/n + 5/n^2 → 0. Ou L'Hôpital duas vezes: der1: (2n+5)/3n^2 → ∞/∞, der2: 2/6n → 0.",
                              "finalVerifications": [
                                "Prova correta de dominância para 3 pares dados.",
                                "Tabela hierárquica de 5 polinomiais ordenados.",
                                "Cálculo numérico de limites para n=10^6 confirmando <0.01.",
                                "Explicação verbal de por que divisão funciona.",
                                "Aplicação correta de L'Hôpital em 2 exemplos.",
                                "Identificação de casos onde não domina (graus iguais)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de dominância (20%)",
                                "Correção na divisão polinomial (25%)",
                                "Validade das provas de limite (25%)",
                                "Uso apropriado de L'Hôpital (15%)",
                                "Exemplos práticos e generalizações (10%)",
                                "Clareza na comunicação matemática (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Análise de Algoritmos: Classificar complexidades O(n^k).",
                                "Cálculo: Limites e derivadas em funções contínuas.",
                                "Física: Comparar crescimentos em modelos cinemáticos (posição vs velocidade).",
                                "Estatística: Análise assintótica de variâncias polinomiais."
                              ],
                              "realWorldApplication": "Em Ciência da Computação, determina qual termo domina na análise de tempo de execução de algoritmos, como sorting O(n^2) vs linear O(n), otimizando escolhas para grandes datasets em machine learning ou big data."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Exemplificar em algoritmos",
                            "description": "Relacionar com algoritmos como ordenação por inserção (O(n²)) e merge sort (O(n log n)), destacando impacto prático para n=10^6.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o algoritmo de Ordenação por Inserção e sua Complexidade",
                                  "subSteps": [
                                    "Estude o pseudocódigo do Insertion Sort: para i de 1 a n-1, inserir a[i] na posição correta no subarray ordenado.",
                                    "Implemente uma versão simples em Python para n pequeno (ex: n=10).",
                                    "Analise o pior caso: compare todos os elementos anteriores, levando a ~n²/2 comparações.",
                                    "Confirme que a notação Big-O é O(n²) para tempo.",
                                    "Registre o número de operações em uma tabela para n=10, 100."
                                  ],
                                  "verification": "Execute o código e liste o número exato de comparações no pior caso para n=5.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python), papel para pseudocódigo",
                                  "tips": "Use print statements para contar swaps e comparações durante a execução.",
                                  "learningObjective": "Compreender a estrutura e o motivo da complexidade quadrática do Insertion Sort.",
                                  "commonMistakes": "Confundir com Bubble Sort; ignorar que melhor caso é O(n)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Merge Sort e sua Complexidade O(n log n)",
                                  "subSteps": [
                                    "Revise o pseudocódigo recursivo: dividir array em metades, ordenar recursivamente, mesclar.",
                                    "Implemente Merge Sort em Python com função de merge.",
                                    "Calcule recursivamente: T(n) = 2T(n/2) + O(n), resolvendo para O(n log n) via árvore de recursão.",
                                    "Desenhe a árvore de recursão para n=8, contando níveis (log n) e trabalho por nível (n).",
                                    "Compare com Insertion Sort em termos de divisões e merges."
                                  ],
                                  "verification": "Desenhe a árvore de recursão para n=16 e some o trabalho total.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python IDE, papel para desenhar árvores",
                                  "tips": "Use memoização ou contadores para visualizar profundidade da recursão.",
                                  "learningObjective": "Dominar a análise de divide-and-conquer e por que resulta em O(n log n).",
                                  "commonMistakes": "Esquecer o custo de merge (O(n)); confundir log n com ln n."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Complexidades Usando Hierarquia de Crescimento",
                                  "subSteps": [
                                    "Liste funções polinomiais: constante < log n < n < n log n < n² < n³ < 2^n.",
                                    "Posicione O(n log n) vs O(n²) na hierarquia: n log n cresce mais devagar que n².",
                                    "Calcule razões: para n=10^6, n log n / n² = log n / n ≈ 20 / 1e6 = muito pequeno.",
                                    "Plote gráficos simples de f(n) = n² e g(n)=n log2 n para n=10^3 a 10^6.",
                                    "Discuta dominância assintótica: lim n→∞ n log n / n² = 0."
                                  ],
                                  "verification": "Crie uma tabela comparando valores para n=10^3, 10^4, 10^6.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha (Excel/Google Sheets) ou Python com matplotlib",
                                  "tips": "Use log2(n) para bits; assuma 1 operação = 1 microssegundo para intuição.",
                                  "learningObjective": "Aplicar hierarquia para prever qual algoritmo escala melhor.",
                                  "commonMistakes": "Ignorar constantes; focar só em pequenos n onde O(n²) parece ok."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto Prático para n=10^6 e Exemplificar",
                                  "subSteps": [
                                    "Assuma 10^8 operações/segundo: Insertion Sort ~ (10^6)^2 / 2 = 5*10^11 ops → ~5000 segundos (~1.4 horas).",
                                    "Merge Sort: 10^6 * 20 ≈ 2*10^7 ops → ~0.2 segundos.",
                                    "Implemente ambos em Python, gere array aleatório de 10^6 ints, meça tempo real com timeit.",
                                    "Otimize Insertion Sort para n pequeno, mas destaque falha em grande n.",
                                    "Crie relatório: 'Para processar 1 milhão de registros, Merge Sort é 25.000x mais rápido.'"
                                  ],
                                  "verification": "Execute benchmarks e capture tempos; diferença deve ser >1000x.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Computador com Python (numpy.random para array grande)",
                                  "tips": "Use %timeit no Jupyter; reduza n para 10^5 se memória baixa.",
                                  "learningObjective": "Quantificar impacto prático da complexidade no mundo real.",
                                  "commonMistakes": "Testar só n pequeno; ignorar overhead de recursão no Merge Sort."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Comunicar a Relação",
                                  "subSteps": [
                                    "Escreva um parágrafo relacionando: 'Insertion Sort O(n²) impraticável para big data; Merge Sort O(n log n) essencial.'",
                                    "Crie infográfico simples: gráfico de tempo vs n.",
                                    "Discuta trade-offs: Insertion Sort bom para n<1000 (cache-friendly).",
                                    "Responda perguntas hipotéticas: 'Por que não usar sempre O(n log n)?'",
                                    "Autoavalie compreensão com quiz interno."
                                  ],
                                  "verification": "Escreva explicação em 200 palavras e verifique contra fontes como CLRS.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto, ferramenta de gráfico (Canva ou matplotlib)",
                                  "tips": "Use analogias: n² como contar grãos de areia; n log n como biblioteca organizada.",
                                  "learningObjective": "Comunicar efetivamente o impacto da análise de algoritmos.",
                                  "commonMistakes": "Superestimar prático sem benchmarks; ignorar cenários híbridos."
                                }
                              ],
                              "practicalExample": "Implemente Insertion Sort e Merge Sort em Python para ordenar 1 milhão de números aleatórios. Meça tempos: Insertion Sort falha ou demora horas; Merge Sort termina em segundos, provando superioridade prática de O(n log n) sobre O(n²) para big data.",
                              "finalVerifications": [
                                "Explicar verbalmente por que Merge Sort é preferível para n=10^6.",
                                "Apresentar benchmark com tempos reais medidos.",
                                "Desenhar hierarquia mostrando n log n < n².",
                                "Calcular corretamente ops para ambos algoritmos em n=10^6.",
                                "Identificar cenários onde Insertion Sort ainda é útil (n pequeno).",
                                "Relacionar a um problema real como ordenar logs de servidor."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise de complexidade (100% correto).",
                                "Qualidade dos benchmarks e visualizações (gráficos claros).",
                                "Profundidade dos substeps executados (todos completos).",
                                "Comunicação clara do impacto prático.",
                                "Identificação correta de erros comuns e trade-offs.",
                                "Criatividade na conexão com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de recorrências e análise assintótica (cálculo de limites).",
                                "Física: Analogia com crescimento exponencial em sistemas caóticos.",
                                "Estatística: Importância em ordenação de dados para análise de grandes datasets.",
                                "Economia: Otimização de recursos computacionais em escala empresarial."
                              ],
                              "realWorldApplication": "Em empresas como Google ou Netflix, escolher Merge Sort (ou similares) sobre Insertion Sort permite processar bilhões de dados em tempo real, evitando crashes ou atrasos em buscas, recomendações e análises de logs, economizando milhões em hardware e tempo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.4",
                            "name": "Avaliar limites computacionais",
                            "description": "Estimar tempo de execução para polinomiais altos (ex: n^5 para n=100), mostrando viabilidade em hardware moderno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender funções polinomiais e notação Big O",
                                  "subSteps": [
                                    "Revise a definição de funções polinomiais: f(n) = a_k * n^k + ... + a_0",
                                    "Estude a notação Big O para polinomiais: O(n^d) onde d é o grau dominante",
                                    "Identifique exemplos: n^2 é quadrático, n^5 é quíntico",
                                    "Compare hierarquia de crescimento: n^5 cresce mais rápido que n^3",
                                    "Pratique identificando o termo dominante em expressões polinomiais"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que significa O(n^5) para um algoritmo",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Algoritmos (ex: CLRS), calculadora, papel e caneta",
                                  "tips": "Foquem no termo de maior grau; ignore constantes para estimativas assintóticas",
                                  "learningObjective": "Dominar conceitos fundamentais de complexidade polinomial",
                                  "commonMistakes": "Confundir grau com número de operações; ignorar que Big O é assintótico"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular número de operações básicas para polinômiais altos",
                                  "subSteps": [
                                    "Escolha um exemplo: n=100, grau=5 para O(n^5)",
                                    "Calcule operações: aproximadamente 100^5 = 10^10 operações",
                                    "Estime operações por segundo em hardware moderno: ~10^9 ops/s (GHz clock)",
                                    "Divida: 10^10 / 10^9 = 10 segundos aproximados",
                                    "Varie n e grau: teste n=1000, grau=3 vs grau=5"
                                  ],
                                  "verification": "Mostre cálculo escrito: confirme 100^5 = 10 bilhões de operações",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, planilha Excel/Google Sheets para potências",
                                  "tips": "Use notação científica para grandes números; log10(n^k) = k*log10(n)",
                                  "learningObjective": "Calcular precisamente o volume de trabalho computacional",
                                  "commonMistakes": "Esquecer de elevar à potência correta; subestimar potências de 10"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar tempo real considerando hardware moderno",
                                  "subSteps": [
                                    "Pesquise specs: CPU moderna (ex: Intel i9, 3-5 GHz, multi-core)",
                                    "Ajuste para overhead: divida por fator de eficiência (ex: 0.1-0.5 para loops reais)",
                                    "Inclua memória: verifique se n^5 cabe em RAM (100^5 * sizeof(data))",
                                    "Simule com código simples: implemente loop n^5 e meça tempo",
                                    "Compare single-core vs multi-core aceleração"
                                  ],
                                  "verification": "Execute código de benchmark e registre tempo real vs estimado",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Computador com Python/Jupyter, timer de código (timeit), sites como cpu.userbenchmark.com",
                                  "tips": "Comece com n pequeno e escale; use profiling tools como cProfile",
                                  "learningObjective": "Traduzir teoria Big O em tempos reais mensuráveis",
                                  "commonMistakes": "Ignorar constantes ocultas ou cache misses; assumir 100% eficiência"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar viabilidade e limites computacionais",
                                  "subSteps": [
                                    "Classifique tempos: <1s viável instantâneo, 1min aceitável, >1h impraticável",
                                    "Compare com exponenciais: n=100, 2^n vs n^5",
                                    "Discuta otimizações: reduzir grau com algoritmos melhores",
                                    "Avalie cenários: big data (n=10^6), cloud computing",
                                    "Conclua: n^5 para n=100 é viável (~segundos a minutos)"
                                  ],
                                  "verification": "Resuma em tabela: n, grau, ops, tempo estimado, viável?",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha para tabela comparativa, artigos sobre limites computacionais",
                                  "tips": "Use thresholds claros: 10^12 ops ~ dia de computação",
                                  "learningObjective": "Avaliar se um algoritmo é prático no mundo real",
                                  "commonMistakes": "Superestimar hardware futuro; ignorar escalabilidade paralela"
                                }
                              ],
                              "practicalExample": "Para um algoritmo de processamento de imagem O(n^5) com n=100 pixels por dimensão: calcule 100^5 = 10^10 operações. Em CPU 4GHz (4x10^9 ops/s), ~2.5s single-core; viável para protótipos, mas otimize para produção.",
                              "finalVerifications": [
                                "Estime corretamente tempo para n=100, O(n^5): ~10s",
                                "Compare viabilidade n=1000 O(n^3) vs O(n^5)",
                                "Benchmark código real bate com estimativa (±50%)",
                                "Identifique quando polinomial alto torna-se impraticável",
                                "Explique impacto de multi-core em estimativas",
                                "Crie tabela de viabilidade para graus 1-7, n=10-1000"
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de operações (erro <10%)",
                                "Correta tradução para tempo real com specs hardware",
                                "Interpretação qualitativa de viabilidade",
                                "Uso de exemplos numéricos concretos",
                                "Consideração de fatores reais (overhead, memória)",
                                "Clareza na tabela/comparação final"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de potências e logaritmos",
                                "Física: Frequência de clock e limites de silício",
                                "Engenharia de Software: Benchmarking e profiling",
                                "Estatística: Análise de variância em tempos reais"
                              ],
                              "realWorldApplication": "Em desenvolvimento de ML, avaliar se modelo O(n^4) treina viavelmente para datasets n=500; em simulações científicas, decidir se grid n=100 é factível antes de alocar supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Funções Exponenciais",
                        "description": "Estudo do crescimento explosivo de funções como 2^n ou a^n (a>1), que superam qualquer polinomial e tornam problemas intratáveis para n grande.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Entender base e crescimento exponencial",
                            "description": "Definir f(n) = a^n com a>1, calcular valores (2^10=1024, 2^20≈1M) e notar aceleração rápida comparada a n^k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função exponencial básica",
                                  "subSteps": [
                                    "Explique o conceito de base 'a' onde a > 1 (ex: 2, 10, e).",
                                    "Escreva a fórmula f(n) = a^n, onde n é um inteiro não-negativo.",
                                    "Diferencie de funções lineares ou polinomiais, destacando o crescimento multiplicativo.",
                                    "Forneça exemplos iniciais: 2^0 = 1, 2^1 = 2, 2^2 = 4.",
                                    "Discuta o papel da base na velocidade de crescimento (maior a >1, mais rápido)."
                                  ],
                                  "verification": "Escreva a definição correta e 3 exemplos válidos em uma tabela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora simples"
                                  ],
                                  "tips": "Sempre comece com n=0 para reforçar que qualquer base^0 = 1.",
                                  "learningObjective": "Compreender a notação e propriedades fundamentais de funções exponenciais.",
                                  "commonMistakes": "Confundir a^n com n^a ou assumir a=1 (crescimento constante)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular valores de potências exponenciais",
                                  "subSteps": [
                                    "Calcule manualmente 2^1 até 2^10, memorizando 2^10 = 1024.",
                                    "Estenda para 2^20 ≈ 1.048.576 (use multiplicação: 2^20 = (2^10)^2).",
                                    "Pratique com outras bases: 10^3 = 1.000, 3^5 = 243.",
                                    "Crie uma tabela comparando valores para n de 0 a 20.",
                                    "Use propriedades como a^(m+n) = a^m * a^n para agilizar cálculos."
                                  ],
                                  "verification": "Produza uma tabela com cálculos corretos para 2^10 e 2^20.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou papel quadriculado"
                                  ],
                                  "tips": "Multiplique por 2 repetidamente para visualizar o padrão de duplicação.",
                                  "learningObjective": "Dominar cálculos precisos de funções exponenciais comuns.",
                                  "commonMistakes": "Erros aritméticos em potências altas; arredondar prematuramente (ex: 2^20 como 1M exato)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar crescimento exponencial com polinomial",
                                  "subSteps": [
                                    "Defina função polinomial g(n) = n^k para k fixo (ex: n^2, n^3).",
                                    "Calcule valores paralelos: para n=10, 10^2=100 vs 2^10=1024; n=20, 20^3=8.000 vs 2^20≈1M.",
                                    "Observe o cruzamento: exponencial ultrapassa polinomial rapidamente após certo n.",
                                    "Crie gráfico simples ou tabela mostrando n^k sempre < a^n para n grande.",
                                    "Explique intuitivamente: polinomial 'soma', exponencial 'multiplica'."
                                  ],
                                  "verification": "Gere tabela/gráfico comprovando 2^n > n^3 para n>10.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfica de papel",
                                    "Ferramenta online como Desmos ou GeoGebra"
                                  ],
                                  "tips": "Teste n=1,5,10,20 para ver inversão clara no crescimento.",
                                  "learningObjective": "Identificar hierarquia de crescimento: exponencial domina polinomial.",
                                  "commonMistakes": "Achar que polinomiais crescem mais rápido em curtos prazos; ignorar assíntotica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e internalizar a aceleração rápida",
                                  "subSteps": [
                                    "Plote curvas de f(n)=2^n e g(n)=n^3 em escala logarítmica se possível.",
                                    "Simule com dobras de papel: cada dobra ≈ dobra área (exponencial).",
                                    "Discuta limites práticos: 2^64 ≈ 10^18 (limite de dados em computadores).",
                                    "Compare tempos: algoritmo O(2^n) vs O(n^2) em cenários reais.",
                                    "Resuma: 'exponencial explode' após threshold."
                                  ],
                                  "verification": "Descreva verbalmente ou desenhe por que exponencial acelera mais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para dobras",
                                    "Software de plotagem (opcional)"
                                  ],
                                  "tips": "Use analogia de coelhos se reproduzindo: população dobra a cada geração.",
                                  "learningObjective": "Graspar intuitivamente a dominância exponencial em análise de algoritmos.",
                                  "commonMistakes": "Subestimar impacto em n médio (ex: n=30 já inviável computacionalmente)."
                                }
                              ],
                              "practicalExample": "Em análise de algoritmos, um backtracking ingênuo em um problema com 30 variáveis binárias gera 2^30 ≈ 1 bilhão de estados, inviável, enquanto O(n^2) para n=30 é só 900.",
                              "finalVerifications": [
                                "Define corretamente f(n)=a^n com a>1.",
                                "Calcula precisamente 2^10=1024 e 2^20=1.048.576.",
                                "Compara e prova 2^n > n^k para n grande via tabela.",
                                "Explica aceleração rápida com exemplo numérico.",
                                "Identifica aplicação em complexidade computacional.",
                                "Visualiza crescimento via gráfico ou simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e notação matemática (30%).",
                                "Correção em cálculos de potências (25%).",
                                "Clareza na comparação com polinomiais (20%).",
                                "Profundidade na visualização/aceleração (15%).",
                                "Uso de exemplos práticos e verificações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Potenciação e limites assintóticos (Big O).",
                                "Biologia: Modelos de crescimento populacional bacteriano.",
                                "Economia: Juros compostos e inflação exponencial.",
                                "Física: Decaimento radioativo (base <1, mas simétrico)."
                              ],
                              "realWorldApplication": "Em criptografia, chaves RSA com módulo 2^2048 bits tornam ataques de força bruta (2^2048 tentativas) impossíveis, mesmo com supercomputadores, destacando por que exponenciais definem limites computacionais práticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Provar dominância sobre polinomiais",
                            "description": "Demonstrar lim (n→∞) n^k / a^n = 0 para a>1, k fixo, usando indução ou série de Taylor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Enunciado e Construir Intuição",
                                  "subSteps": [
                                    "Analise o limite lim (n→∞) n^k / a^n = 0, onde a > 1 e k é fixo.",
                                    "Explique intuitivamente por que funções exponenciais crescem mais rápido que polinomiais.",
                                    "Teste numericamente com valores específicos, como k=2, a=2, para n=1,10,20,50.",
                                    "Grave os resultados em uma tabela para visualizar a tendência.",
                                    "Discuta o impacto na hierarquia de crescimento de funções em análise de algoritmos."
                                  ],
                                  "verification": "Crie uma tabela numérica mostrando n^k / a^n diminuindo para valores próximos de 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora ou planilha (Excel/Google Sheets), gráfico de funções online (Desmos).",
                                  "tips": "Comece com k pequeno (ex: k=1) para intuição antes de generalizar.",
                                  "learningObjective": "Entender o significado matemático e computacional do limite.",
                                  "commonMistakes": "Confundir a>1 com |a|>1; ignorar que k é fixo enquanto n→∞."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar o Limite Usando Indução Matemática",
                                  "subSteps": [
                                    "Fixe k e prove por indução que existe N tal que para n ≥ N, n^k < (a^n)/2.",
                                    "Base da indução: Verifique para n=1 ou n pequeno.",
                                    "Hipótese indutiva: Assuma para n=m, m^k < (a^m)/2.",
                                    "Passo indutivo: Mostre para n=m+1 usando desigualdade (m+1)^k ≤ 2 m^k para m grande.",
                                    "Conclua que n^k / a^n < 1/2 para n ≥ N, implicando limite 0."
                                  ],
                                  "verification": "Escreva a prova completa em papel, verificando base e passos indutivos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e caneta, quadro branco, referência de livro de indução (ex: Concrete Mathematics).",
                                  "tips": "Escolha N grande o suficiente para que (1 + 1/m)^k < a/2 na indução.",
                                  "learningObjective": "Dominar prova por indução para dominância exponencial-polinomial.",
                                  "commonMistakes": "Falhar no passo indutivo ao não bounding (m+1)^k corretamente; esquecer normalização para 1/2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar o Limite Usando Série de Taylor",
                                  "subSteps": [
                                    "Reescreva n^k / a^n = n^k e^{-n ⁡ln a}, com b = ln a > 0.",
                                    "Use expansão de Taylor para e^{-x} = ∑ (-1)^m x^m / m! para x = n b.",
                                    "Mostre que |n^k e^{-n b}| ≤ n^k / (n b)^{k+1} * (k+1)! para termos dominantes.",
                                    "Aplique limite de Stirling ou bounding para provar que o termo principal → 0.",
                                    "Generalize para qualquer k fixo."
                                  ],
                                  "verification": "Derive a expansão e compute limite para k=1,2 manualmente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papel e caneta, tabela de séries de Taylor, software simbólico (Wolfram Alpha para verificação).",
                                  "tips": "Foquem no termo de ordem k+1 na série para bounding superior.",
                                  "learningObjective": "Aplicar séries de Taylor para limites assintóticos.",
                                  "commonMistakes": "Esquecer sinal alternado na série; não justificar resto da série."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, Comparar e Aplicar as Provas",
                                  "subSteps": [
                                    "Compare as duas provas: indução (elementar) vs. Taylor (analítica).",
                                    "Teste com k=3, a=1.5 numericamente e analiticamente.",
                                    "Discuta generalizações para k não-inteiro ou a variável.",
                                    "Aplique a funções de complexidade: mostre 2^n >> n^{100}.",
                                    "Resuma forças e fraquezas de cada método."
                                  ],
                                  "verification": "Escreva um relatório curto comparando as provas e um exemplo de algoritmo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, exemplos de livros de algoritmos (CLRS), Python/Mathematica para plots.",
                                  "tips": "Use logaritmos para visualizar: log(n^k / a^n) = k log n - n log a → -∞.",
                                  "learningObjective": "Integrar provas em contexto de análise de algoritmos.",
                                  "commonMistakes": "Não conectar de volta à hierarquia de crescimento; superestimar simplicidade de Taylor."
                                }
                              ],
                              "practicalExample": "Em análise de algoritmos, prove que o tempo de um algoritmo exponencial O(2^n) domina qualquer polinomial O(n^{100}), explicando por que brute-force é inviável para n=100 em criptografia AES.",
                              "finalVerifications": [
                                "Escreva a prova por indução completa sem erros para k=3, a=2.",
                                "Derive corretamente o bounding via Taylor para o limite.",
                                "Compute numericamente lim n=1000 de 1000^5 / 1.1^n < 10^{-10}.",
                                "Explique verbalmente a intuição em 1 minuto.",
                                "Aplique a um exemplo de complexidade: compare n! vs. 2^n.",
                                "Identifique erros em uma prova fornecida com falhas intencionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na indução (base, passo corretos): 25%.",
                                "Correta aplicação de série de Taylor e bounding: 25%.",
                                "Intuição e exemplos numéricos convincentes: 20%.",
                                "Conexão clara com análise de algoritmos: 15%.",
                                "Clareza na escrita e comparação de métodos: 10%.",
                                "Generalização e verificações finais: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Real (limites, séries infinitas).",
                                "Física: Modelos de crescimento populacional exponencial vs. polinomial.",
                                "Economia: Análise de crescimento composto vs. power-law.",
                                "Estatística: Comportamento assintótico de distribuições."
                              ],
                              "realWorldApplication": "Em ciência da computação, essa prova fundamenta a classificação de problemas NP-completos como intratáveis, justificando heurísticas em otimização e machine learning, onde soluções exatas exponenciais são substituídas por aproximações polinomiais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Relacionar com problemas NP",
                            "description": "Exemplificar em subconjunto soma ou caixeiro viajante com recorrência 2^n, ligando à teoria de complexidade (referência Cormen).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Problemas NP e Complexidade Exponencial",
                                  "subSteps": [
                                    "Defina classe P e NP, destacando que NP inclui problemas verificáveis em tempo polinomial mas possivelmente não solucionáveis em tempo polinomial.",
                                    "Explique o conceito de tempo de execução exponencial (O(2^n)) e por que ele é intratável para n grande.",
                                    "Revise a hierarquia de crescimento de funções, posicionando 2^n acima de polinomiais.",
                                    "Leia seções relevantes do Cormen (Capítulo 34: NP-Completeness) sobre redução e implicações.",
                                    "Anote diferenças entre solucionabilidade e verificabilidade em NP."
                                  ],
                                  "verification": "Resuma em 3-5 frases os conceitos chave e identifique 2 exemplos de problemas em P vs NP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to Algorithms' de Cormen (ou PDF), anotações, quadro branco.",
                                  "tips": "Use analogias como 'verificar uma senha (rápido) vs quebrá-la por força bruta (lento)'.",
                                  "learningObjective": "Dominar definições básicas de P, NP e tempo exponencial.",
                                  "commonMistakes": "Confundir NP-completo com NP-difícil; ignorar verificabilidade polinomial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Problema Subset Sum e sua Recorrência 2^n",
                                  "subSteps": [
                                    "Descreva Subset Sum: dado um conjunto de inteiros e alvo S, existe subconjunto que soma S?",
                                    "Implemente solução força bruta: gere todos 2^n subconjuntos e verifique soma.",
                                    "Calcule complexidade: cada subconjunto leva O(n) para somar, total O(n * 2^n).",
                                    "Discuta por que é NP-completo (redução de Partition).",
                                    "Compare com DP pseudo-polinomial O(n*W), mas exponencial em n para W grande."
                                  ],
                                  "verification": "Escreva pseudocódigo da solução força bruta e prove T(n) = Θ(n * 2^n).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (Python/Jupyter), exemplos de instâncias pequenas (n=5-10).",
                                  "tips": "Teste com {3,1,5,2} e S=6; visualize árvore de recursão.",
                                  "learningObjective": "Exemplificar recorrência 2^n em problema NP-clássico.",
                                  "commonMistakes": "Esquecer fator n na complexidade; confundir com Knapsack ilimitado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Caixeiro Viajante (TSP) e Recorrência 2^n",
                                  "subSteps": [
                                    "Defina TSP: encontrar ciclo Hamiltoniano de custo mínimo em grafo completo.",
                                    "Descreva brute-force: gere todas (n-1)!/2 permutações, calcule custo O(n^2) por uma.",
                                    "Mostre relação com 2^n via held-karp DP: O(n^2 * 2^n).",
                                    "Explique NP-hardness via redução de Hamilton Cycle.",
                                    "Compare crescimento: 2^n vs n!, notando Stirling approx n! ~ sqrt(2πn)(n/e)^n."
                                  ],
                                  "verification": "Para grafo pequeno (4 cidades), liste tours e identifique ótimo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de grafos (NetworkX Python), mapa simples de cidades.",
                                  "tips": "Use distâncias euclidianas para intuição visual.",
                                  "learningObjective": "Ligar TSP a funções exponenciais na hierarquia.",
                                  "commonMistakes": "Ignorar subtorneios em DP; superestimar brute-force como O(n!)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ligar Exemplos à Teoria de Complexidade (Cormen) e Hierarquia",
                                  "subSteps": [
                                    "Revise Cormen Ch. 3 (Growth Rates) e Ch. 34 (NP): exponenciais dominam polinomiais.",
                                    "Crie tabela comparando T(n): log n, n, n^2, 2^n para n=10,20,40.",
                                    "Discuta implicações: por que NP-completos sugerem P≠NP.",
                                    "Relacione à hierarquia: 2^n caracteriza problemas 'inviáveis' práticos.",
                                    "Escreva ensaio curto conectando Subset Sum/TSP a funções exponenciais."
                                  ],
                                  "verification": "Preencha tabela de crescimento e resuma ligação em parágrafo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Cormen PDF, planilha Excel/Google Sheets para tabelas.",
                                  "tips": "Grafique log(T(n)) para visualizar dominância.",
                                  "learningObjective": "Integrar exemplos à teoria formal de complexidade.",
                                  "commonMistakes": "Não referenciar Cormen precisamente; ignorar assintóticas."
                                }
                              ],
                              "practicalExample": "Para Subset Sum com conjunto {1,3,4,5} e S=9: brute-force testa 16 subconjuntos (2^4), encontra {4,5}. Tempo ~4*16=64 ops. Para n=40, 40*2^40 ~ 4e13 ops (inviável). TSP em 10 cidades: ~3.6e6 tours, viável; n=20: ~2e18, não.",
                              "finalVerifications": [
                                "Explicar corretamente P vs NP com exemplos.",
                                "Derivar recorrência 2^n para Subset Sum e TSP.",
                                "Citar seções de Cormen sobre NP e growth rates.",
                                "Comparar tabelas de crescimento mostrando dominância exponencial.",
                                "Identificar 2 reduções para NP-completude.",
                                "Discutir implicações práticas de P≠NP."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de NP (90%+).",
                                "Análise assintótica: derivações exatas de T(n).",
                                "Exemplos concretos: instâncias resolvidas manualmente.",
                                "Referências: citação precisa de Cormen.",
                                "Integração: ligação clara à hierarquia de funções.",
                                "Clareza: explicações concisas e sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória (subconjuntos, permutações) e Análise Assintótica.",
                                "Física: Modelagem de otimização em simulações quânticas (QAOA para NP).",
                                "Economia: Otimização de rotas em logística e supply chain.",
                                "Filosofia: Limites do computacional (Church-Turing, decidibilidade)."
                              ],
                              "realWorldApplication": "Em logística, TSP otimiza rotas de entrega (Google Maps aproximações); Subset Sum em criptomoedas (endereços válidos); pharma testa combinações de drogas (2^n inviável, usa heurísticas); prova P≠NP impulsiona pesquisa em computação quântica para quebrar barreiras exponenciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.4",
                        "name": "Comparação da Hierarquia",
                        "description": "Síntese da hierarquia completa: constantes < log n < n^k (qualquer k) < a^n < n!, com ferramentas para ordenação e notação Big-O/Θ/Ω.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.4.1",
                            "name": "Ordenar funções por crescimento",
                            "description": "Listar em ordem crescente: 1, log log n, log n, n, n log n, n², n³, 2^n, n!, justificando com limites assintóticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Notação Assintótica e Limites",
                                  "subSteps": [
                                    "Defina notação Big O, Θ e Ω com exemplos simples.",
                                    "Explique o conceito de limite assintótico: lim (n→∞) f(n)/g(n).",
                                    "Pratique limites básicos: lim n→∞ n / n² = 0.",
                                    "Identifique funções constantes, logarítmicas, lineares, polinomiais, exponenciais e fatorial.",
                                    "Liste propriedades: log log n < log n, n^k cresce mais devagar que c^n para c>1."
                                  ],
                                  "verification": "Resuma em um parágrafo as definições e resolva 3 limites dados (ex: log n / n = 0).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora gráfica ou Wolfram Alpha para limites.",
                                  "tips": "Use L'Hôpital para limites indeterminados como ∞/∞.",
                                  "learningObjective": "Compreender como limites assintóticos determinam ordem de crescimento.",
                                  "commonMistakes": "Confundir Big O com tempo exato; ignorar constantes em limites."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Cada Função Individualmente",
                                  "subSteps": [
                                    "Calcule valores para n=10, 100, 1000 para cada: 1, log log n (log2), log n (log2), n, n log n, n², n³, 2^n, n!.",
                                    "Desenhe gráfico manual ou use ferramenta para visualizar crescimento.",
                                    "Classifique cada uma: constante, log-log, log, linear, linearítmica, quadrática, cúbica, exponencial, fatorial.",
                                    "Anote comportamentos: fatorial cresce mais rápido que exponencial.",
                                    "Compare pares iniciais: 1 vs log log n (log log n cresce)."
                                  ],
                                  "verification": "Tabela com valores numéricos e classificações para todas as funções.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel/Google Sheets ou Python (matplotlib para plots), tabela de log2.",
                                  "tips": "Use n=2^20 (~1M) para exponenciais; Stirling approx para n!.",
                                  "learningObjective": "Familiarizar com o perfil de crescimento de cada função.",
                                  "commonMistakes": "Erro em log log n (use log2(log2 n)); subestimar 2^n vs n³."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Funções em Pares Usando Limites",
                                  "subSteps": [
                                    "Compute lim f(n)/g(n) para pares adjacentes: ex log log n / 1 = ∞.",
                                    "Prove: log n / log log n = ∞, n / log n = ∞, etc.",
                                    "Use regras: polinomial > log qualquer, exponencial > polinomial, n! > 2^n.",
                                    "Registre todos os 8 limites necessários para ordenação.",
                                    "Identifique a ordem preliminar: 1 < log log n < log n < n < n log n < n² < n³ < 2^n < n!."
                                  ],
                                  "verification": "Lista de 8 limites resolvidos com valores (0,1,∞).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Calculadora simbólica (Symbolab ou papel), notas do Step 1.",
                                  "tips": "Se lim=1, compare log f / log g; pratique com log_b n = ln n / ln b.",
                                  "learningObjective": "Dominar comparação rigorosa via limites assintóticos.",
                                  "commonMistakes": "Confundir n log n com n² (n log n < n² pois log n / n →0); inverter 2^n e n!."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ordenar e Justificar a Hierarquia Completa",
                                  "subSteps": [
                                    "Compile a lista ordenada: 1, log log n, log n, n, n log n, n², n³, 2^n, n!.",
                                    "Escreva justificativas encadeadas: cada uma o(da próxima).",
                                    "Teste com n grande (10^6): confirme numericamente.",
                                    "Crie mnemônico ou tabela de referência.",
                                    "Resolva exercício inverso: desordene e reordene."
                                  ],
                                  "verification": "Lista ordenada com 8 justificativas de limites.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela do Step 2, software de plotagem (Desmos).",
                                  "tips": "Visualize em log-log plot para clareza em crescimento lento.",
                                  "learningObjective": "Aplicar comparações para ordenação global.",
                                  "commonMistakes": "Colocar n log n > n²; esquecer log log n é mais lento que log n."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Verificar Compreensão",
                                  "subSteps": [
                                    "Ordene novas listas: ex adicione √n, 3^n.",
                                    "Explique por que n! ~ √(2πn) (n/e)^n > 2^n.",
                                    "Compare com algoritmos: Bubble Sort O(n²) vs Merge O(n log n).",
                                    "Crie quiz autoavaliativo com 5 perguntas.",
                                    "Discuta exceções para n pequeno."
                                  ],
                                  "verification": "Resolva 3 exercícios independentes corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Quiz impresso ou online (Kahoot).",
                                  "tips": "Sempre volte aos limites para dúvidas.",
                                  "learningObjective": "Reforçar e generalizar a habilidade.",
                                  "commonMistakes": "Ignorar base do log (não afeta ordem assintótica)."
                                }
                              ],
                              "practicalExample": "Para n=1000: calcule valores - 1=1, log2(log2(1000))≈3.2, log2(1000)≈10, n=1000, n log n≈10000, n²=1e6, n³=1e9, 2^1000≈1e301, 1000!≈4e2567. Note 2^n >> n³ mas n! ainda maior em escalas reais grandes.",
                              "finalVerifications": [
                                "Lista ordenada correta sem erros.",
                                "Todos os limites assintóticos resolvidos com justificativa.",
                                "Tabela numérica confirma ordem para n=10^6.",
                                "Explicação verbal da hierarquia em 1 minuto.",
                                "Sucesso em ordenar lista variante com 2 funções extras.",
                                "Identificação correta de 3 pares comuns confundidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na ordenação (100% correto).",
                                "Uso correto de limites (pelo menos 0,1,∞ identificados).",
                                "Justificativas rigorosas, não só intuitivas.",
                                "Valores numéricos/plots suportam claims.",
                                "Generalização para funções similares.",
                                "Ausência de erros comuns listados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo (limites, L'Hôpital), Logaritmos e funções exponenciais.",
                                "Física: Modelos de crescimento populacional (exponencial vs fatorial em reações).",
                                "Economia: Análise de complexidade em otimização de recursos.",
                                "Estatística: Ordem em tempos de computação para simulações grandes."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, ordenar complexidades ajuda a escolher o melhor algoritmo para dados grandes, ex: QuickSort O(n log n) preferível a O(n²) para Big Data em empresas como Google."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.3"
                            ]
                          },
                          {
                            "id": "10.1.1.5.4.2",
                            "name": "Usar notação assintótica",
                            "description": "Aplicar f(n) = O(g(n)) se lim sup |f/g| < ∞, classificando misturas como n² + 2^n = Θ(2^n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Formais de Notação Assintótica",
                                  "subSteps": [
                                    "Estude a definição de f(n) = O(g(n)): existe c > 0 e n0 tal que para todo n ≥ n0, |f(n)| ≤ c |g(n)|.",
                                    "Aprenda f(n) = Ω(g(n)) e f(n) = Θ(g(n)) como combinações de O e Ω.",
                                    "Entenda lim sup |f(n)/g(n)| < ∞ como critério equivalente para Big O.",
                                    "Anote exemplos simples: n² = O(n³), mas não o inverso.",
                                    "Compare com notação informal de dominância assintótica."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as três noções (O, Ω, Θ) com um exemplo cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, quadro branco, recurso online como Khan Academy ou CLRS capítulo 3.",
                                  "tips": "Use gráficos de crescimento para visualizar dominância antes de formalizar.",
                                  "learningObjective": "Dominar as definições precisas e equivalências para notação Big O/Ω/Θ.",
                                  "commonMistakes": "Confundir O com ≤ exato (é assintótico); ignorar constantes c e n0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o Critério de Limite Superior para Big O",
                                  "subSteps": [
                                    "Revise limites: compute lim sup |f(n)/g(n)| para funções polinomiais e exponenciais.",
                                    "Prove que se lim sup |f/g| = L < ∞, então f = O(g).",
                                    "Pratique com exemplos: prove n² + n = O(n²) via lim sup = 1.",
                                    "Explore casos onde limite não existe, mas ainda O (ex: oscilações).",
                                    "Use L'Hôpital para limites indeterminados em racionais."
                                  ],
                                  "verification": "Calcule lim sup para 3 pares f/g dados e classifique corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora gráfica ou Wolfram Alpha, tabela de limites comuns.",
                                  "tips": "Sempre divida pelo termo suspeito de dominante; foque em n → ∞.",
                                  "learningObjective": "Aplicar lim sup |f/g| < ∞ para determinar Big O rigorosamente.",
                                  "commonMistakes": "Usar lim inf em vez de lim sup; esquecer normalização por g(n) > 0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Termos Dominantes em Funções Mistas",
                                  "subSteps": [
                                    "Liste hierarquia: log n << n^ε << n^k << c^n << n! para qualquer k, ε, c>1.",
                                    "Para misturas como n² + 2^n, isole o dominante (2^n).",
                                    "Prove n² + 2^n = O(2^n) via divisão: (n²/2^n) → 0.",
                                    "Classifique como Θ(2^n) mostrando ambos O e Ω.",
                                    "Pratique rearranjo: fatorar o dominante quando possível."
                                  ],
                                  "verification": "Classifique 4 funções mistas (ex: n log n + n², 3^n + n^{100}) com provas curtas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folha de exercícios com funções hierárquicas, software como Desmos para plots.",
                                  "tips": "Pergunte: 'Qual termo cresce mais rápido para n grande?' Ignore inferiores.",
                                  "learningObjective": "Detectar e justificar dominância em polinômios + exponenciais + fatoriais.",
                                  "commonMistakes": "Subestimar exponenciais vs polinomiais; tratar todos termos igualmente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Classificações Completas e Verificações",
                                  "subSteps": [
                                    "Resolva problemas: classifique f vs g para 5 pares mistos usando lim sup.",
                                    "Crie contraexemplos onde intuição falha (ex: n! vs 2^{2n}).",
                                    "Aplique em algoritmos: tempo de merge sort n log n vs quicksort médio O(n log n).",
                                    "Verifique Θ bidirecional: prove ambos sentidos para tight bounds.",
                                    "Autoavalie com quiz: 10 questões de múltipla escolha e provas."
                                  ],
                                  "verification": "Resolva um conjunto de 5 exercícios independentes com 100% acerto.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Exercícios impressos ou LeetCode-style problems, timer para simular exame.",
                                  "tips": "Comece com plots intuitivos, depois formalize; memorize hierarquia top 5.",
                                  "learningObjective": "Aplicar notação assintótica de forma fluida em cenários complexos.",
                                  "commonMistakes": "Esquecer Θ requer ambos O e Ω; confundir com complexidade exata."
                                }
                              ],
                              "practicalExample": "Classifique a complexidade de tempo de um algoritmo com T(n) = 3n² + 5n log n + 100n. Passos: Identifique dominante n²; prove T(n)/n² → 3 < ∞ (O(n²)); e n² = O(T(n)) via divisão inversa → Θ(n²). Verifique plotando para n=1000.",
                              "finalVerifications": [
                                "Corretamente prova f(n) = O(g(n)) para 3 funções mistas usando lim sup.",
                                "Identifica termos dominantes em 5 expressões com hierarquia mista.",
                                "Classifica Θ corretamente, mostrando ambos sentidos.",
                                "Explica erro comum: por que n^{100} ≠ O(2^n)?",
                                "Resolve quiz de 10 itens com ≥90% acerto.",
                                "Aplica a um algoritmo real, como Fibonacci ingênuo Θ(φ^n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas provas de limite (lim sup correto e finito).",
                                "Correta identificação de dominância e hierarquia.",
                                "Uso consistente de Θ para bounds tight.",
                                "Clareza na explicação de subpassos e verificações.",
                                "Tratamento de edge cases (oscilações, limites ∞).",
                                "Aplicação prática sem erros de notação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de limites e séries (cálculo avançado).",
                                "Física: Modelos de crescimento populacional exponencial vs polinomial.",
                                "Economia: Análise assintótica de custos em escalas grandes.",
                                "Estatística: Complexidade de algoritmos de ML como gradient descent O(n iter).",
                                "Engenharia: Otimização de sistemas em tempo real."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usa-se para escolher algoritmos escaláveis: prefira O(n log n) sobre O(n²) para big data, prevendo performance em servidores com milhões de usuários, como no Google Search ou Netflix recommendations."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.3"
                            ]
                          },
                          {
                            "id": "10.1.1.5.4.3",
                            "name": "Interpretar gráficos e tabelas",
                            "description": "Analisar gráficos semi-log ou log-log de crescimento, prevendo qual função domina para n=10, 100, 1000.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos de gráficos semi-log e log-log",
                                  "subSteps": [
                                    "Defina gráfico semi-log: eixo y em escala logarítmica, x linear.",
                                    "Defina gráfico log-log: ambos eixos em escala logarítmica.",
                                    "Explique como escalas log alteram a aparência de funções polinomiais, exponenciais e logarítmicas.",
                                    "Identifique funções comuns: log n (reta em semi-log y), n^k (reta em log-log), exponenciais (curva em ambos)."
                                  ],
                                  "verification": "Resuma em 3 frases as diferenças entre semi-log e log-log, com exemplos de funções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Calculadora para logaritmos",
                                    "Referência online sobre escalas logarítmicas"
                                  ],
                                  "tips": "Lembre-se: log transforma multiplicação em adição, linearizando curvas.",
                                  "learningObjective": "Compreender como escalas logarítmicas revelam hierarquias de crescimento.",
                                  "commonMistakes": "Confundir semi-log (apenas y log) com log-log (ambos log); ignorar base do logaritmo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar e interpretar um gráfico de crescimento fornecido",
                                  "subSteps": [
                                    "Identifique o tipo de gráfico (semi-log ou log-log) pelos rótulos dos eixos.",
                                    "Observe as curvas de funções como log n, n, n log n, n^2, 2^n.",
                                    "Note inclinações: retas indicam crescimento polinomial/exponencial linearizado.",
                                    "Marque pontos para n=10, 100, 1000 nos eixos x.",
                                    "Registre qual curva está acima das outras em cada ponto."
                                  ],
                                  "verification": "Descreva o gráfico em um parágrafo, listando posições relativas das curvas em n=10,100,1000.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico semi-log ou log-log impresso ou digital",
                                    "Lupa ou zoom no software de gráficos"
                                  ],
                                  "tips": "Use uma régua para alinhar valores exatos nos eixos log.",
                                  "learningObjective": "Desenvolver habilidade em ler e extrair dados de gráficos logarítmicos.",
                                  "commonMistakes": "Ler valores errados devido a ticks logarítmicos não lineares; confundir curvas semelhantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar funções e prever dominância em valores específicos",
                                  "subSteps": [
                                    "Para n=10: compare alturas das curvas e note a maior.",
                                    "Para n=100: observe cruzamentos ou separações crescentes.",
                                    "Para n=1000: identifique a curva que continua subindo mais rápido.",
                                    "Justifique usando propriedades assintóticas (ex: exponencial domina polinomial).",
                                    "Teste com cálculo manual: compute log(f(n)) para confirmação."
                                  ],
                                  "verification": "Crie uma tabela com n, função dominante e razão qualitativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Pense em limites: para n grande, f domina g se f(n)/g(n) -> infinito.",
                                  "learningObjective": "Aplicar análise visual para prever comportamento assintótico.",
                                  "commonMistakes": "Ignorar efeito do log na percepção de dominância; focar só em n pequeno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar previsões e sintetizar a hierarquia de crescimento",
                                  "subSteps": [
                                    "Calcule valores reais de funções para n=10,100,1000 para verificar gráfico.",
                                    "Ordene funções por dominância crescente: log n < n < n log n < n^2 < 2^n.",
                                    "Discuta quando cruzamentos ocorrem (ex: log n > n para n muito pequeno).",
                                    "Crie uma regra geral para interpretação futura."
                                  ],
                                  "verification": "Escreva um relatório de 1 página com previsões, cálculos e hierarquia confirmada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como Desmos ou Excel para plots",
                                    "Folha de cálculos"
                                  ],
                                  "tips": "Sempre confirme visual com numérico para robustez.",
                                  "learningObjective": "Integrar análise gráfica e analítica para conclusões confiáveis.",
                                  "commonMistakes": "Generalizar de n pequeno para grande; esquecer normalizações nos gráficos."
                                }
                              ],
                              "practicalExample": "Dado um gráfico log-log com curvas log2(n), n, n^1.5, 2^n: Para n=10, n domina; n=100, n^1.5 começa a separar; n=1000, 2^n domina claramente, prevendo escalabilidade pobre de algoritmos exponenciais em inputs grandes.",
                              "finalVerifications": [
                                "Identifica corretamente tipo de gráfico em 90% dos casos.",
                                "Prevê dominância precisa para n=10,100,1000 em pelo menos 3 gráficos teste.",
                                "Justifica previsões com propriedades assintóticas.",
                                "Cria tabela de comparação válida.",
                                "Sintetiza hierarquia geral sem erros.",
                                "Valida com cálculos numéricos concordantes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de escalas e tipos de gráfico (30%).",
                                "Correção nas previsões de dominância para valores específicos (25%).",
                                "Qualidade da justificativa assintótica e numérica (20%).",
                                "Clareza na tabela e síntese da hierarquia (15%).",
                                "Detecção e correção de erros comuns (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos e funções assintóticas.",
                                "Estatística: Interpretação de gráficos logarítmicos em dados.",
                                "Física: Análise de escalas em crescimento exponencial (ex: decaimento radioativo).",
                                "Economia: Previsão de crescimento em modelos log-log."
                              ],
                              "realWorldApplication": "Em análise de algoritmos, usar gráficos log-log para escolher quicksort (n log n) sobre bubble sort (n^2) para n=1000, otimizando performance em big data e software escalável."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Recursividade e Recorrência",
                "description": "Análise de algoritmos recursivos por meio de equações de recorrência e métodos de solução.",
                "totalSkills": 55,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Definição de Recursividade",
                    "description": "Conceitos fundamentais de funções e algoritmos recursivos, incluindo caso base e chamada recursiva.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Conceito de Função Recursiva",
                        "description": "Uma função recursiva é definida em termos de si mesma, resolvendo um problema original por meio de chamadas para resolver subproblemas menores e idênticos, até alcançar uma solução trivial.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Identificar função recursiva",
                            "description": "Reconhecer em um pseudocódigo ou código fonte se uma função é recursiva, verificando se há uma chamada para si mesma dentro de sua definição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição fundamental de uma função recursiva",
                                  "subSteps": [
                                    "Leia a definição: uma função recursiva chama a si mesma dentro de seu próprio corpo.",
                                    "Estude componentes essenciais: caso base (condição de parada) e chamada recursiva.",
                                    "Compare com funções iterativas que usam loops em vez de auto-chamadas.",
                                    "Anote exemplos verbais: 'fatorial(n) = n * fatorial(n-1)' demonstra recursão.",
                                    "Visualize com diagrama: desenhe uma árvore de chamadas recursivas simples."
                                  ],
                                  "verification": "Escreva em suas palavras a definição e identifique os dois componentes chave sem consultar materiais.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Definição impressa ou digital de recursividade",
                                    "Papel e caneta para anotações",
                                    "Vídeo curto sobre recursão (ex: Khan Academy)"
                                  ],
                                  "tips": "Foquem em 'auto-referência' como palavra-chave; ignore complexidade por enquanto.",
                                  "learningObjective": "Definir precisamente o que torna uma função recursiva e distinguir de iteração.",
                                  "commonMistakes": [
                                    "Confundir loops com recursão",
                                    "Ignorar a necessidade de caso base",
                                    "Achar que qualquer chamada de função é recursiva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a estrutura externa da função (assinatura e parâmetros)",
                                  "subSteps": [
                                    "Identifique a assinatura: nome da função, parâmetros e tipo de retorno.",
                                    "Verifique se o nome da função é único e não sobrecarregado.",
                                    "Liste todos os parâmetros de entrada e observe dependências.",
                                    "Compare assinaturas de funções candidatas em um código fonte.",
                                    "Anote se há múltiplas funções com nomes semelhantes."
                                  ],
                                  "verification": "Dada uma função aleatória, descreva sua assinatura corretamente e liste parâmetros.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Exemplos de pseudocódigo com assinaturas variadas",
                                    "Editor de texto ou IDE para destacar código"
                                  ],
                                  "tips": "Sempre leia a linha de declaração primeiro; parâmetros ajudam a rastrear chamadas.",
                                  "learningObjective": "Extrair e interpretar corretamente a assinatura de uma função para preparação de análise interna.",
                                  "commonMistakes": [
                                    "Pular a assinatura e ir direto ao corpo",
                                    "Confundir parâmetros com variáveis locais",
                                    "Ignorar funções aninhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar o corpo da função em busca de chamadas internas",
                                  "subSteps": [
                                    "Localize todas as chamadas de função dentro do corpo.",
                                    "Compare o nome da chamada com o nome da função atual.",
                                    "Verifique argumentos da chamada: eles devem corresponder à assinatura.",
                                    "Identifique o caso base: condições if/else que param a recursão.",
                                    "Marque chamadas recursivas com destaque ou seta."
                                  ],
                                  "verification": "Em um pseudocódigo fornecido, circule todas as chamadas de função e classifique como recursiva ou não.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Pseudocódigos mistos recursivos e não-recursivos",
                                    "Marcadores ou ferramenta de anotação digital"
                                  ],
                                  "tips": "Procure linha por linha; use Ctrl+F para o nome da função no editor.",
                                  "learningObjective": "Detectar com precisão chamadas auto-referenciais no corpo da função.",
                                  "commonMistakes": [
                                    "Confundir chamadas a outras funções",
                                    "Não notar chamadas condicionais",
                                    "Parar na primeira chamada encontrada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a identificação e praticar com exemplos variados",
                                  "subSteps": [
                                    "Classifique 5 funções: recursiva, não-recursiva ou potencialmente recursiva.",
                                    "Explique por quê para cada uma, citando evidências do código.",
                                    "Teste mentalmente a execução: simule chamadas para 2-3 níveis.",
                                    "Discuta com parceiro ou auto-registre dúvidas.",
                                    "Revise erros e reforce regras."
                                  ],
                                  "verification": "Corretamente classificar 90% de 10 exemplos independentes sem erros.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Banco de 10 pseudocódigos teste",
                                    "Planilha de classificação",
                                    "Simulador de execução online (opcional)"
                                  ],
                                  "tips": "Sempre pergunte: 'Essa chamada é para MIM mesmo?'",
                                  "learningObjective": "Aplicar critérios de identificação de forma consistente e precisa em diversos contextos.",
                                  "commonMistakes": [
                                    "Classificar funções com chamadas indiretas como recursivas",
                                    "Esquecer casos base ausentes",
                                    "Influência de viés de exemplos anteriores"
                                  ]
                                }
                              ],
                              "practicalExample": "Pseudocódigo recursivo: função fatorial(n): se n <= 1 retornar 1 senão retornar n * fatorial(n-1). Não-recursivo: função soma(n): total = 0, enquanto n > 0 total += n, n -= 1, retornar total. Identifique: fatorial chama 'fatorial' (sim); soma não chama 'soma' (não).",
                              "finalVerifications": [
                                "Classificar corretamente 5 funções recursivas e 5 não-recursivas em <5 minutos.",
                                "Explicar verbalmente os critérios para um exemplo complexo.",
                                "Identificar ausência de recursão em funções com loops ou chamadas externas.",
                                "Detectar recursão indireta básica (duas funções se chamando mutuamente).",
                                "Simular pilha de chamadas para uma função recursiva simples.",
                                "Diferenciar recursão de delegação para helpers."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de auto-chamadas (100% em testes).",
                                "Explicação clara de evidências do código (com citações de linhas).",
                                "Tempo de análise <2 minutos por função média.",
                                "Reconhecimento de casos base e sua relação com recursão.",
                                "Ausência de falsos positivos/negativos em cenários variados.",
                                "Capacidade de ensinar o conceito a outro aprendiz."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática (caso base + passo recursivo).",
                                "Linguística: Estruturas recursivas em gramáticas (frases embutidas).",
                                "Biologia: Fractais em padrões naturais (folhas, vasos sanguíneos).",
                                "Física: Modelos recursivos em simulações de caos (atratores).",
                                "Artes: Geração de fractais em design gráfico (ex: árvore de Sierpinski)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, identificar recursão em código legado ajuda a prever estouro de pilha; essencial para algoritmos em árvores (busca em grafos), parsing de expressões matemáticas e jogos (movimentos de IA recursivos)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Explicar recursão como decomposição",
                            "description": "Descrever como a recursão decompõe um problema grande em subproblemas menores da mesma forma, ilustrando com exemplos simples como fatorial ou soma de números.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Decomposição de Problemas em Subproblemas",
                                  "subSteps": [
                                    "Defina decomposição como dividir um problema grande em partes menores semelhantes ao original.",
                                    "Discuta por que problemas repetitivos se beneficiam dessa abordagem, evitando loops explícitos.",
                                    "Identifique problemas cotidianos que envolvem repetição, como contar degraus em uma escada.",
                                    "Compare decomposição iterativa (loops) vs. recursiva (chamadas a si mesma).",
                                    "Esboce um fluxograma simples de um problema se dividindo em subproblemas."
                                  ],
                                  "verification": "Crie um diagrama manual mostrando um problema grande se dividindo em 3 níveis de subproblemas menores idênticos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a um editor de diagramas online como draw.io"
                                  ],
                                  "tips": "Use analogias visuais como dividir uma pizza em fatias menores iguais para fixar o conceito.",
                                  "learningObjective": "Entender que decomposição recursiva transforma problemas complexos em padrões auto-similares.",
                                  "commonMistakes": [
                                    "Confundir decomposição com divisão simples sem repetição",
                                    "Ignorar que subproblemas devem ser da mesma forma que o original"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os Componentes Essenciais de uma Função Recursiva",
                                  "subSteps": [
                                    "Explique o 'caso base' como a condição de parada onde o problema é pequeno o suficiente para resolver diretamente.",
                                    "Descreva o 'caso recursivo' como a divisão do problema em subproblemas menores via chamada à própria função.",
                                    "Escreva pseudocódigo genérico: se (condição base) return valor; else return f(subproblema).",
                                    "Discuta a pilha de chamadas recursivas e como ela se desenrola até o caso base.",
                                    "Simule manualmente 2-3 níveis de chamadas para um problema hipotético."
                                  ],
                                  "verification": "Escreva pseudocódigo para um problema simples (ex: contar até 3) destacando caso base e recursivo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE como VS Code",
                                    "Vídeo curto sobre pilha de chamadas (opcional)"
                                  ],
                                  "tips": "Pense na recursão como 'delegar para uma versão menor de si mesmo' até chegar ao trivial.",
                                  "learningObjective": "Reconhecer e nomear os dois pilares da recursão: base e recursão.",
                                  "commonMistakes": [
                                    "Esquecer o caso base, causando loop infinito",
                                    "Fazer chamadas recursivas sem reduzir o problema"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Recursão à Decomposição do Fatorial",
                                  "subSteps": [
                                    "Defina fatorial: n! = n * (n-1)! com base 0! = 1.",
                                    "Trace chamadas recursivas para 5!: 5! -> 4! -> 3! -> 2! -> 1! -> base.",
                                    "Implemente em pseudocódigo ou código simples (Python/JS).",
                                    "Desenhe a árvore de chamadas mostrando decomposição e recomposição.",
                                    "Calcule manualmente o valor final verificando a multiplicação na volta."
                                  ],
                                  "verification": "Execute o código para n=4 e liste todas as chamadas na pilha, confirmando resultado 24.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com Python ou JavaScript",
                                    "Papel para desenhar árvore de chamadas"
                                  ],
                                  "tips": "Anote valores na pilha como '5 * [f(4)]' para visualizar a decomposição.",
                                  "learningObjective": "Ilustrar decomposição prática onde cada subproblema é n-1 vezes menor.",
                                  "commonMistakes": [
                                    "Confundir ordem de multiplicação",
                                    "Usar loop em vez de recursão pura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar com Exemplo de Soma de Números e Síntese",
                                  "subSteps": [
                                    "Defina soma(1 a n) = n + soma(1 a n-1) com base soma(1 a 0)=0.",
                                    "Trace para soma até 4: 4 + soma(3) -> ... -> base.",
                                    "Compare com fatorial: ambos decompõem reduzindo por 1.",
                                    "Discuta quando usar recursão vs. iteração (profundidade de pilha).",
                                    "Crie um resumo: 'Recursão = decompor + base + combinar resultados'."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como soma decompõe um problema grande em menores idênticos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE para testar soma recursiva",
                                    "Folha de resumo"
                                  ],
                                  "tips": "Varie exemplos para fixar: use soma de array ao invés de sequência natural.",
                                  "learningObjective": "Sintetizar recursão como estratégia universal de decomposição.",
                                  "commonMistakes": [
                                    "Não reduzir corretamente o tamanho do problema",
                                    "Ignorar overflow de pilha em exemplos grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule o fatorial de 4 (24) traçando recursivamente: f(4)=4*f(3), f(3)=3*f(2), f(2)=2*f(1), f(1)=1; desenvolva a pilha e multiplique na volta: 1*2=2, 2*3=6, 6*4=24.",
                              "finalVerifications": [
                                "Pode desenhar árvore de chamadas para fatorial de 5 sem erros.",
                                "Explica diferença entre caso base e recursivo em 30 segundos.",
                                "Implementa soma recursiva correta para n=10.",
                                "Identifica quando recursão decompõe um problema dado.",
                                "Discute risco de stack overflow em recursão profunda.",
                                "Compara recursão com loop equivalente em um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação de decomposição como auto-similaridade (nota 1-5).",
                                "Precisão nos componentes (base/recursivo) em exemplos (correto/incorreto).",
                                "Profundidade no traçado de chamadas (níveis completos).",
                                "Uso de múltiplos exemplos para generalização.",
                                "Identificação de limitações práticas da recursão.",
                                "Capacidade de sintetizar conceito em poucas frases."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática (base + passo recursivo).",
                                "Biologia: Estruturas fractais em folhas ou vasos sanguíneos (auto-similaridade).",
                                "Linguística: Análise sintática de frases (árvores recursivas).",
                                "Física: Modelagem de ondas ou partículas dividindo em subpartículas."
                              ],
                              "realWorldApplication": "Em sistemas de arquivos, recursão percorre diretórios aninhados (ex: deletar pasta com subpastas); em parsing de HTML/XML, constrói árvores DOM decompostas recursivamente; em algoritmos de busca em árvores genealógicas ou redes sociais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Diferenciar recursão de iteração",
                            "description": "Comparar uma solução recursiva com sua equivalente iterativa, destacando vantagens e desvantagens em termos de legibilidade e uso de pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Iteração e Recursão",
                                  "subSteps": [
                                    "Defina iteração como o uso de loops (for, while) para repetir uma tarefa até uma condição ser atendida.",
                                    "Defina recursão como uma função que chama a si mesma com um problema menor até atingir um caso base.",
                                    "Identifique o caso base na recursão como o ponto de parada para evitar loops infinitos.",
                                    "Compare: iteração usa estrutura de controle explícita; recursão usa chamadas de função implícitas."
                                  ],
                                  "verification": "Escreva definições curtas e um diagrama simples comparando os fluxos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Documentação de linguagens como Python ou Java"
                                  ],
                                  "tips": "Use analogias: iteração é como contar degraus subindo uma escada; recursão é como uma boneca russa.",
                                  "learningObjective": "Distinguir conceitualmente iteração de recursão.",
                                  "commonMistakes": [
                                    "Confundir recursão com loops aninhados",
                                    "Esquecer o papel do caso base"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Exemplos Equivalentes: Fatorial Iterativo e Recursivo",
                                  "subSteps": [
                                    "Implemente fatorial iterativo usando um loop for ou while.",
                                    "Implemente fatorial recursivo com caso base (n=0 ou n=1 retorna 1) e chamada recursiva (n * fatorial(n-1)).",
                                    "Teste ambos com n=5, verificando que retornam 120.",
                                    "Compare o código lado a lado em um editor."
                                  ],
                                  "verification": "Execute os códigos e confirme saídas idênticas sem erros de stack overflow.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Interpretador Python ou compilador Java"
                                  ],
                                  "tips": "Comece com valores pequenos para evitar overflow em recursão.",
                                  "learningObjective": "Criar implementações funcionais equivalentes para um problema comum.",
                                  "commonMistakes": [
                                    "Erro no caso base recursivo levando a stack overflow",
                                    "Índice incorreto no loop iterativo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Legibilidade e Estrutura do Código",
                                  "subSteps": [
                                    "Avalie legibilidade iterativa: fluxo linear, variáveis acumuladoras claras.",
                                    "Avalie legibilidade recursiva: elegante para problemas hierárquicos, mas pode obscurecer o fluxo.",
                                    "Discuta quando cada uma é mais legível (iterativa para contagens simples; recursiva para árvores).",
                                    "Reescreva um código para melhorar legibilidade em ambas."
                                  ],
                                  "verification": "Explique em 3 frases por que um é mais legível que o outro para fatorial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Códigos do passo anterior",
                                    "Ferramenta de análise estática como pylint"
                                  ],
                                  "tips": "Leia o código em voz alta para simular compreensão.",
                                  "learningObjective": "Comparar legibilidade como fator de escolha arquitetural.",
                                  "commonMistakes": [
                                    "Ignorar legibilidade em favor de performance prematura",
                                    "Superestimar simplicidade recursiva em problemas lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Vantagens, Desvantagens e Uso de Pilha",
                                  "subSteps": [
                                    "Explique uso de pilha na recursão: cada chamada adiciona frame à pilha de chamadas.",
                                    "Simule pilha para fatorial(3): mostra 3 frames até caso base.",
                                    "Compare: iteração usa pilha implícita mínima; recursão pode causar StackOverflowError.",
                                    "Liste prós/contra: recursão (legível para divide-conquer, memoizável); iteração (eficiente em memória, sem overflow)."
                                  ],
                                  "verification": "Desenhe diagrama da pilha para recursão e confirme limites (ex: sys.getrecursionlimit() em Python).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de depuração (debugger do IDE)",
                                    "Documentação sobre call stack"
                                  ],
                                  "tips": "Use debugger para visualizar pilha em tempo real.",
                                  "learningObjective": "Entender impactos em memória e quando evitar recursão profunda.",
                                  "commonMistakes": [
                                    "Confundir pilha de execução com pilha de dados",
                                    "Ignorar otimizações como tail recursion"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar a um Segundo Exemplo e Sintetizar",
                                  "subSteps": [
                                    "Escolha soma de array: implemente iterativa (loop) e recursiva (soma(rest) + primeiro).",
                                    "Compare legibilidade e pilha novamente.",
                                    "Sintetize regras gerais: use recursão para estruturas recursivas; iteração para lineares.",
                                    "Documente trade-offs em uma tabela."
                                  ],
                                  "verification": "Implementações corretas e tabela de comparação completa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Códigos anteriores como referência"
                                  ],
                                  "tips": "Escolha exemplos familiares para reforçar padrões.",
                                  "learningObjective": "Generalizar diferenciação para múltiplos problemas.",
                                  "commonMistakes": [
                                    "Forçar recursão em problemas não-naturais",
                                    "Subestimar overhead de função calls"
                                  ]
                                }
                              ],
                              "practicalExample": "Para calcular o fatorial de 5 (120):\n- Iterativo: resultado = 1; for i in 1 to 5: resultado *= i\n- Recursivo: def fat(n): if n <= 1: return 1; return n * fat(n-1)\nSimule execução passo a passo.",
                              "finalVerifications": [
                                "Implementar fatorial recursivo e iterativo sem erros.",
                                "Explicar com diagrama o uso de pilha na recursão.",
                                "Listar 3 vantagens e 3 desvantagens de cada abordagem.",
                                "Converter um código recursivo simples para iterativo e vice-versa.",
                                "Identificar quando recursão causa StackOverflow em código dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de recursão vs iteração (30%)",
                                "Correção de implementações: códigos funcionais e equivalentes (25%)",
                                "Análise qualitativa: comparação clara de legibilidade (20%)",
                                "Análise quantitativa: entendimento de uso de pilha e limites (15%)",
                                "Generalização: aplicação a novos exemplos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática (recursão como indução).",
                                "Lógica: Provas por indução e recorrências.",
                                "Biologia: Modelagem de fractais e estruturas auto-similares (ex: folhas de samambaia).",
                                "Física: Simulações de sistemas caóticos com recursão.",
                                "Engenharia: Análise de estruturas hierárquicas como redes neurais."
                              ],
                              "realWorldApplication": "Em algoritmos de busca em árvores (ex: parsing HTML), quicksort/merge sort (divide-and-conquer recursivo), ou processamento de grafos genealógicos, onde recursão melhora legibilidade, mas iteração é preferida para performance em grandes datasets para evitar stack overflow."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Caso Base da Recursão",
                        "description": "O caso base é a condição de parada da recursão, representando instâncias simples do problema que podem ser resolvidas diretamente sem chamadas adicionais, evitando loops infinitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Reconhecer o caso base",
                            "description": "Identificar em um algoritmo recursivo a condição if que define o caso base, como n=0 ou n=1 em funções como fatorial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Caso Base na Recursão",
                                  "subSteps": [
                                    "Leia a definição: O caso base é a condição que para a recursão, evitando chamadas infinitas.",
                                    "Compare com iteração: Pense no caso base como o 'for i=0' em um loop.",
                                    "Anote exemplos simples: n=0 retorna 1 no fatorial.",
                                    "Discuta por que é essencial: Sem ele, ocorre stack overflow.",
                                    "Resuma em suas palavras o papel do caso base."
                                  ],
                                  "verification": "Escreva uma definição de 1 parágrafo e um exemplo simples; verifique se menciona parada da recursão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto",
                                  "tips": "Use analogia de dominós: o caso base é o primeiro dominó que não cai mais.",
                                  "learningObjective": "Definir precisamente o que é um caso base e sua função em algoritmos recursivos.",
                                  "commonMistakes": "Confundir com caso recursivo; lembrar que caso base NÃO chama a si mesmo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Caso Base em Código de Fatorial",
                                  "subSteps": [
                                    "Copie o código de fatorial recursivo: def factorial(n): if n <= 1: return 1 else: return n * factorial(n-1)",
                                    "Localize a condição 'if': Destaque 'n <= 1'.",
                                    "Explique o que acontece: Retorna 1 sem recursão.",
                                    "Teste manualmente: Trace para n=0 e n=1.",
                                    "Modifique levemente: Troque por n==0 e verifique se ainda funciona."
                                  ],
                                  "verification": "Anote a linha exata do caso base e execute o código para n=0, confirmando parada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código Python (ex: VS Code, Replit)",
                                  "tips": "Procure por 'if' que retorna valor constante ou simples sem chamada recursiva.",
                                  "learningObjective": "Reconhecer a estrutura if-then que define o caso base no exemplo clássico de fatorial.",
                                  "commonMistakes": "Ignorar 'n <=1' como múltiplos valores; caso base pode cobrir n=0 e n=1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Caso Base em Outros Algoritmos Recursivos",
                                  "subSteps": [
                                    "Examine Fibonacci: if n <= 1: return n",
                                    "Verifique soma de lista: if not lista: return 0",
                                    "Identifique em torre de Hanói: if n == 1: mover disco",
                                    "Compare padrões: Condições como n==0, n==1, lista vazia.",
                                    "Crie um fluxograma: Desenhe recursão vs. caso base."
                                  ],
                                  "verification": "Liste 3 exemplos com linha do caso base; confirme que param recursão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Códigos de exemplo impressos ou online (GeeksforGeeks Recursion)",
                                  "tips": "Pergunte: 'Essa condição chama a função recursivamente? Não? É caso base!'",
                                  "learningObjective": "Identificar casos base em diversos algoritmos recursivos além do fatorial.",
                                  "commonMistakes": "Confundir condição de parada com redução do problema; foco na ausência de chamada recursiva."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Detecção e Verificação de Casos Base",
                                  "subSteps": [
                                    "Pegue 5 códigos recursivos aleatórios online.",
                                    "Marque o caso base em cada um.",
                                    "Simule execução para n pequeno sem caso base (erro esperado).",
                                    "Adicione caso base faltante em um código quebrado.",
                                    "Autoavalie: Explique oralmente para si mesmo."
                                  ],
                                  "verification": "Resolva um quiz com 5 códigos: 100% acerto em identificar caso base.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Site como LeetCode ou HackerRank (seção recursão fácil)",
                                  "tips": "Sempre trace 2-3 chamadas para validar se para corretamente.",
                                  "learningObjective": "Aplicar reconhecimento de caso base em códigos variados e corrigir ausências.",
                                  "commonMistakes": "Assumir que todo 'if n==0' é caso base; verifique se realmente para recursão."
                                }
                              ],
                              "practicalExample": "No fatorial: def fat(n): if n <= 1: return 1  # CASO BASE else: return n * fat(n-1). Para n=3: fat(3) -> 3*fat(2) -> 2*fat(1) -> 1 (para aqui). Sem 'if n<=1', loop infinito.",
                              "finalVerifications": [
                                "Identifica corretamente o caso base em fatorial, Fibonacci e soma de lista.",
                                "Explica por que uma condição sem chamada recursiva é caso base.",
                                "Detecta ausência de caso base em código e prevê stack overflow.",
                                "Trace recursão manualmente até o caso base.",
                                "Modifica código para adicionar caso base faltante.",
                                "Lista 3 padrões comuns de casos base (n=0/1, lista vazia, etc.)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% correto em identificar casos base em 5 exemplos.",
                                "Explicação: Descreve função do caso base sem erros conceituais.",
                                "Aplicação: Corrige código recursivo sem caso base.",
                                "Análise: Identifica múltiplos valores no caso base (ex: n<=1).",
                                "Profundidade: Relaciona com stack overflow e eficiência.",
                                "Criatividade: Propõe caso base para novo algoritmo simples."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução matemática (hipótese base como caso base).",
                                "Lógica: Condições booleanas e parada em provas por indução.",
                                "Física: Modelos recursivos em fractais ou movimento browniano.",
                                "Linguagem Portuguesa: Estruturas condicionais em narrativas ramificadas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, reconhecer casos base previne crashes por recursão infinita em funções como busca em árvores (ex: navegadores web processando DOM recursivamente) ou cálculos financeiros (juros compostos recursivos em apps bancários)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Construir caso base correto",
                            "description": "Criar um caso base apropriado para um problema recursivo dado, garantindo que ele cubra todas as condições de parada e retorne o valor correto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema para identificar condições de parada",
                                  "subSteps": [
                                    "Leia a descrição do problema recursivo e identifique entradas que não requerem chamadas recursivas.",
                                    "Liste todas as condições onde a recursão deve parar (ex: valores mínimos como 0, 1 ou listas vazias).",
                                    "Anote o valor esperado de retorno para cada condição de parada.",
                                    "Verifique se há múltiplas condições de parada e documente-as.",
                                    "Desenhe um fluxograma simples mostrando quando o caso base é ativado."
                                  ],
                                  "verification": "Crie uma lista documentada de condições de parada com valores esperados; revise se cobre todos os cenários de parada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do problema recursivo",
                                    "Papel e caneta ou editor de texto para anotações",
                                    "Exemplos de problemas recursivos semelhantes"
                                  ],
                                  "tips": "Sempre pergunte: 'Qual é o menor input possível que resolve o problema sem recursão?'",
                                  "learningObjective": "Identificar precisamente todas as condições de parada em um problema recursivo.",
                                  "commonMistakes": [
                                    "Ignorar condições de parada múltiplas",
                                    "Confundir condições de parada com casos recursivos iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e escrever os casos base no código",
                                  "subSteps": [
                                    "Escreva condicionais if/else para cada condição de parada identificada.",
                                    "Garanta que cada caso base retorne exatamente o valor correto sem chamadas recursivas.",
                                    "Use asserts ou prints iniciais para confirmar retornos.",
                                    "Nomeie variáveis e condicionais de forma clara (ex: if n == 0).",
                                    "Remova temporariamente o caso recursivo para isolar os casos base."
                                  ],
                                  "verification": "Execute o código apenas com os casos base ativados e confirme que retorna valores corretos para inputs de parada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Linguagem de programação com suporte a recursão (Python, JavaScript)"
                                  ],
                                  "tips": "Comece com o caso base mais simples e adicione os outros gradualmente.",
                                  "learningObjective": "Implementar casos base que cubram todas as condições de parada com retornos precisos.",
                                  "commonMistakes": [
                                    "Retornar valor incorreto no caso base",
                                    "Incluir lógica recursiva acidentalmente no caso base"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar os casos base isoladamente",
                                  "subSteps": [
                                    "Crie testes unitários específicos para cada condição de parada.",
                                    "Execute testes com inputs que ativem apenas casos base (ex: n=0, lista vazia).",
                                    "Registre saídas e compare com valores esperados.",
                                    "Use depurador para inspecionar o fluxo e garantir parada imediata.",
                                    "Ajuste se houver falhas nos retornos."
                                  ],
                                  "verification": "Todos os testes de casos base passam com 100% de acerto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Framework de testes (unittest em Python, Jest em JS)",
                                    "Depurador do IDE"
                                  ],
                                  "tips": "Escreva testes antes do código para guiar a implementação (TDD).",
                                  "learningObjective": "Validar que os casos base funcionam corretamente sem depender de recursão.",
                                  "commonMistakes": [
                                    "Não testar todas as condições de parada",
                                    "Testar apenas com inputs recursivos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e verificar contra loops infinitos",
                                  "subSteps": [
                                    "Reinsira o caso recursivo após os casos base.",
                                    "Teste com inputs que transitam de recursivo para base.",
                                    "Monitore profundidade de recursão e detecte loops infinitos.",
                                    "Aumente limites de recursão se necessário e otimize.",
                                    "Documente o caso base no comentário do código."
                                  ],
                                  "verification": "Função recursiva completa executa sem erros para inputs pequenos e grandes, ativando casos base corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código completo da função recursiva",
                                    "Ferramentas de profiling para recursão"
                                  ],
                                  "tips": "Use memoização temporária para depurar recursões profundas.",
                                  "learningObjective": "Garantir que casos base previnam loops infinitos na recursão completa.",
                                  "commonMistakes": [
                                    "Casos base incompletos levando a recursão infinita",
                                    "Não testar transição recursivo-base"
                                  ]
                                }
                              ],
                              "practicalExample": "Para fatorial recursivo: def factorial(n): if n == 0 or n == 1: return 1  # Caso base else: return n * factorial(n-1). Teste: factorial(0) == 1, factorial(1) == 1.",
                              "finalVerifications": [
                                "Todos os casos base retornam valores corretos para inputs de parada.",
                                "Nenhum loop infinito ocorre em testes com inputs que atingem base.",
                                "Cobertura de testes para casos base é 100%.",
                                "Fluxo de execução para corretamente para condições de parada.",
                                "Documentação clara dos casos base no código.",
                                "Transição suave para caso recursivo sem sobreposição."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todas condições de parada (100% cobertura).",
                                "Retornos corretos e sem side-effects nos casos base.",
                                "Código limpo com condicionais claras e sem redundâncias.",
                                "Testes unitários abrangentes para validação.",
                                "Prevenção efetiva de recursão infinita.",
                                "Documentação explicativa dos casos base."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática (caso base como P(0)).",
                                "Lógica: Condicionais e proposições verdadeiras em casos triviais.",
                                "Engenharia de Software: Testes unitários e TDD.",
                                "Análise de Algoritmos: Complexidade em casos base O(1)."
                              ],
                              "realWorldApplication": "Em árvores de busca binária (BST), o caso base para nós nulos previne travessias infinitas; em parsing de expressões, casos vazios garantem parsing correto sem stack overflow."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Analisar falhas sem caso base",
                            "description": "Prever o comportamento de uma função recursiva sem caso base adequado, explicando o estouro de pilha ou loop infinito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Examinar a estrutura da função recursiva",
                                  "subSteps": [
                                    "Leia a definição completa da função, identificando parâmetros e corpo.",
                                    "Localize a chamada recursiva para si mesma.",
                                    "Verifique a presença de um caso base (condição if que retorna sem recursão).",
                                    "Anote o que acontece na ausência do caso base.",
                                    "Compare com uma função recursiva padrão que possui caso base."
                                  ],
                                  "verification": "Liste os componentes: parâmetros, chamada recursiva e ausência de caso base em um diagrama ou notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código fonte da função recursiva",
                                    "Papel e caneta ou editor de texto para anotações"
                                  ],
                                  "tips": "Pense na recursão como uma função que se chama até atingir uma condição de parada.",
                                  "learningObjective": "Identificar elementos essenciais de uma recursão e detectar falta de término.",
                                  "commonMistakes": [
                                    "Assumir que todo retorno é um caso base",
                                    "Ignorar mudanças nos parâmetros na recursão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular a execução inicial com um input simples",
                                  "subSteps": [
                                    "Escolha um input pequeno, como n=3.",
                                    "Execute a primeira chamada: anote o valor de retorno e parâmetros.",
                                    "Registre a próxima chamada recursiva gerada.",
                                    "Desenhe uma árvore de chamadas ou pilha para visualizar.",
                                    "Continue por 3-4 níveis para observar o padrão."
                                  ],
                                  "verification": "Crie um traçado de chamadas mostrando pelo menos 4 níveis de recursão sem parada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para desenhar pilha de chamadas",
                                    "Calculadora para valores numéricos se aplicável"
                                  ],
                                  "tips": "Use setas para mostrar fluxo: chamada -> recursão -> próxima chamada.",
                                  "learningObjective": "Simular manualmente o fluxo de execução recursiva.",
                                  "commonMistakes": [
                                    "Parar simulação prematuramente",
                                    "Confundir ordem de avaliação de argumentos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar o padrão de recursão infinita",
                                  "subSteps": [
                                    "Analise o padrão nos parâmetros: eles diminuem, aumentam ou oscilam?",
                                    "Identifique por que não há parada (ex: n nunca atinge valor terminal).",
                                    "Preveja o número ilimitado de chamadas.",
                                    "Explique o consumo crescente de memória da pilha.",
                                    "Teste mentalmente com input zero ou negativo se relevante."
                                  ],
                                  "verification": "Descreva em palavras o loop infinito ou progressão sem fim nos parâmetros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama da pilha do step 2",
                                    "Exemplos de funções semelhantes"
                                  ],
                                  "tips": "Pergunte: 'O parâmetro se aproxima de um valor base?'",
                                  "learningObjective": "Reconhecer padrões que levam a não-terminação em recursão.",
                                  "commonMistakes": [
                                    "Achar que recursão profunda é finita",
                                    "Ignorar overhead de pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar as consequências e correções",
                                  "subSteps": [
                                    "Descreva o estouro de pilha (stack overflow) ou loop infinito.",
                                    "Explique limites da pilha em linguagens como Python ou C++.",
                                    "Sugira adição de caso base (ex: if n <= 1: return 1).",
                                    "Compare execução antes/depois da correção.",
                                    "Discuta detecção em IDEs ou debuggers."
                                  ],
                                  "verification": "Escreva uma explicação de 100 palavras sobre o erro e solução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de stack overflow da linguagem",
                                    "Editor de código para testar"
                                  ],
                                  "tips": "Execute em ambiente real para ver o erro (mas limite profundidade).",
                                  "learningObjective": "Prever e mitigar falhas recursivas no mundo real.",
                                  "commonMistakes": [
                                    "Confundir stack overflow com out-of-memory",
                                    "Não testar a correção"
                                  ]
                                }
                              ],
                              "practicalExample": "Função Python: def factorial(n): return n * factorial(n-1). Chamada: factorial(5). Simulação: factorial(5) chama factorial(4), que chama factorial(3), ... continua indefinidamente até stack overflow, pois n nunca atinge 0 ou 1.",
                              "finalVerifications": [
                                "Pode traçar 5 níveis de chamadas recursivas sem erro.",
                                "Explica corretamente por que ocorre stack overflow.",
                                "Identifica ausência de caso base em código novo.",
                                "Propõe caso base correto para função dada.",
                                "Diferencia recursão infinita de recursão profunda finita.",
                                "Simula com input negativo ou zero."
                              ],
                              "assessmentCriteria": [
                                "Precisão na simulação de chamadas (100% correta).",
                                "Explicação clara de não-terminação e stack overflow.",
                                "Uso correto de termos: pilha, recursão, caso base.",
                                "Criatividade em diagramas ou visualizações.",
                                "Proposta de correção funcional e testável.",
                                "Profundidade na análise de padrões de parâmetros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de sequências infinitas e convergência.",
                                "Lógica: Paradoxos auto-referenciais como o mentiroso.",
                                "Engenharia de Software: Técnicas de debugging e análise estática.",
                                "Física: Modelos de sistemas em loop sem atratores.",
                                "Psicologia: Viés de confirmação em detecção de padrões infinitos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como em algoritmos de parsing de árvores genealógicas ou navegação em grafos, analisar recursões sem caso base previne crashes em produção, economizando tempo de debug e melhorando confiabilidade de apps como navegadores web ou jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Chamada Recursiva",
                        "description": "A chamada recursiva é a invocação da própria função com argumentos modificados (geralmente menores), que permite progredir em direção ao caso base.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Identificar chamada recursiva",
                            "description": "Localizar no código a linha onde a função chama a si mesma, analisando os parâmetros passados na chamada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica de uma função recursiva",
                                  "subSteps": [
                                    "Leia a declaração da função e identifique seu nome e parâmetros de entrada.",
                                    "Localize o caso base (condição de parada) que evita recursão infinita.",
                                    "Observe o corpo da função em busca de qualquer chamada de função.",
                                    "Anote o escopo da função para confirmar que estamos analisando o código correto.",
                                    "Compare com um exemplo simples de recursão não-recursiva para contrastar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os componentes principais da função identificados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código fonte da função recursiva",
                                    "Editor de texto ou IDE como VS Code"
                                  ],
                                  "tips": "Sempre comece pelo topo da função; o caso base geralmente vem primeiro.",
                                  "learningObjective": "Reconhecer os elementos fundamentais que distinguem uma função recursiva.",
                                  "commonMistakes": [
                                    "Confundir chamadas de outras funções com recursão",
                                    "Ignorar o caso base ao ler o código"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escanear o corpo da função por invocações internas",
                                  "subSteps": [
                                    "Percorra linha por linha o corpo da função, procurando por expressões que chamem uma função.",
                                    "Destaque todas as chamadas de função encontradas, independentemente do nome.",
                                    "Verifique se alguma chamada usa o nome exato da função atual.",
                                    "Ignore chamadas a funções auxiliares ou bibliotecas externas.",
                                    "Use busca por texto (Ctrl+F) para o nome da função no editor."
                                  ],
                                  "verification": "Liste todas as linhas com chamadas de função e circule a potencial recursiva.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código fonte",
                                    "Marcadores ou highlighter no editor"
                                  ],
                                  "tips": "Foque apenas em chamadas dentro do corpo da função, não na declaração.",
                                  "learningObjective": "Desenvolver habilidade para escanear código eficientemente em busca de padrões específicos.",
                                  "commonMistakes": [
                                    "Marcar chamadas condicionais como não-recursivas prematuramente",
                                    "Confundir variáveis com nomes de funções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Confirmar a chamada recursiva analisando argumentos",
                                  "subSteps": [
                                    "Examine os argumentos passados na chamada suspeita e compare com os parâmetros da função.",
                                    "Verifique se os argumentos são derivados dos parâmetros de entrada, indicando progressão.",
                                    "Confirme que a chamada ocorre após o caso base, para redução do problema.",
                                    "Teste mentalmente: se o argumento diminui (ex: n-1), é recursiva.",
                                    "Documente como os parâmetros mudam na recursão."
                                  ],
                                  "verification": "Descreva os parâmetros na chamada e prove que levam à terminação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código fonte com anotações",
                                    "Papel e caneta para traçar chamadas"
                                  ],
                                  "tips": "Pense em 'dividir para conquistar': parâmetros devem reduzir o problema.",
                                  "learningObjective": "Analisar se uma chamada interna forma recursão válida.",
                                  "commonMistakes": [
                                    "Assumir recursão sem verificar redução de parâmetros",
                                    "Ignorar chamadas com parâmetros idênticos (recursão infinita)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar a identificação",
                                  "subSteps": [
                                    "Trace uma execução manual com entrada pequena (ex: n=3) para ver a recursão.",
                                    "Confirme ausência de outras chamadas recursivas na função.",
                                    "Escreva um comentário no código apontando a linha exata da chamada.",
                                    "Compare com documentação ou pseudocódigo da recursão.",
                                    "Teste alterando a chamada para ver se quebra a recursão."
                                  ],
                                  "verification": "Execute o código com depurador e pause na linha identificada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código fonte",
                                    "Depurador (ex: Python debugger ou browser console)"
                                  ],
                                  "tips": "Use print statements temporários para visualizar chamadas recursivas.",
                                  "learningObjective": "Consolidar a identificação através de validação prática.",
                                  "commonMistakes": [
                                    "Não testar com casos pequenos",
                                    "Confundir recursão mútua com auto-recursão"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a função fatorial em Python:\ndef fatorial(n):\n    if n <= 1:\n        return 1\n    return n * fatorial(n-1)\nA chamada recursiva está na linha 'return n * fatorial(n-1)', onde 'fatorial' chama a si mesma com parâmetro 'n-1'.",
                              "finalVerifications": [
                                "Aponta corretamente a linha exata da chamada recursiva.",
                                "Explica como os parâmetros mudam na recursão.",
                                "Identifica o caso base e sua relação com a chamada.",
                                "Traça uma execução com 2-3 níveis de recursão.",
                                "Distingue de chamadas não-recursivas no mesmo código."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização da linha (100% correto).",
                                "Análise correta dos parâmetros e redução do problema.",
                                "Explicação clara da verificação de recursão.",
                                "Uso de exemplos ou traçado para suporte.",
                                "Ausência de confusão com outros tipos de chamadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relação com sequências recursivas e indução matemática.",
                                "Lógica: Análise de estruturas condicionais e fluxos de controle.",
                                "Física: Modelagem de fenômenos fractais ou divisíveis (ex: movimento pendular).",
                                "Linguagem: Parsing de estruturas aninhadas em gramáticas."
                              ],
                              "realWorldApplication": "Em sistemas de arquivos, identificar chamadas recursivas em funções que percorrem árvores de diretórios (ex: ls -R no Unix ou os.walk() em Python), permitindo otimizar buscas em grandes hierarquias de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Verificar progresso na recursão",
                            "description": "Avaliar se os argumentos da chamada recursiva diminuem monotonicamente, garantindo convergência para o caso base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Caso Base e a Chamada Recursiva",
                                  "subSteps": [
                                    "Examine o código da função recursiva linha por linha.",
                                    "Localize todas as condições de parada (casos base), geralmente com 'if' e 'return' sem recursão.",
                                    "Identifique a chamada recursiva da própria função, anotando os argumentos passados.",
                                    "Registre os parâmetros de entrada originais e compare com os da chamada recursiva.",
                                    "Desenhe um diagrama simples mostrando o fluxo do caso base para a recursão."
                                  ],
                                  "verification": "Você pode apontar precisamente o caso base e a chamada recursiva, com argumentos anotados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código fonte da função recursiva",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Comece sempre pelo final do código para encontrar retornos sem recursão.",
                                  "learningObjective": "Reconhecer a estrutura fundamental de recursão para análise subsequente.",
                                  "commonMistakes": [
                                    "Confundir múltiplas chamadas recursivas",
                                    "Ignorar casos base múltiplos ou aninhados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os Argumentos na Chamada Recursiva",
                                  "subSteps": [
                                    "Liste todos os argumentos passados na chamada recursiva.",
                                    "Compare cada argumento recursivo com o correspondente no parâmetro de entrada original.",
                                    "Determine se o argumento é constante, crescente ou decrescente em relação ao original.",
                                    "Calcule a diferença ou razão entre o argumento original e o recursivo.",
                                    "Classifique os argumentos como 'diminuindo', 'estáveis' ou 'aumentando'."
                                  ],
                                  "verification": "Crie uma tabela comparando argumentos de entrada e recursivos, confirmando classificações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código fonte",
                                    "Planilha ou tabela em papel/digital"
                                  ],
                                  "tips": "Use variáveis simbólicas como 'n' para generalizar a análise.",
                                  "learningObjective": "Extrair e comparar parâmetros para detectar padrões de mudança.",
                                  "commonMistakes": [
                                    "Focar apenas no primeiro argumento, ignorando múltiplos",
                                    "Confundir valor absoluto com direção de mudança"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Diminuição Monotônica dos Argumentos",
                                  "subSteps": [
                                    "Defina 'monotônica' como estritamente decrescente ou não-crescente em cada iteração.",
                                    "Simule 3-5 chamadas recursivas sucessivas, rastreando valores dos argumentos.",
                                    "Confirme se, em todas as chamadas, os argumentos principais diminuem até o caso base.",
                                    "Verifique se a diminuição é consistente (ex: n -> n-1 sempre).",
                                    "Identifique exceções onde a diminuição falha ou oscila."
                                  ],
                                  "verification": "Desenhe uma sequência de chamadas mostrando diminuição contínua até o caso base.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código fonte",
                                    "Simulador de execução ou debugger simples"
                                  ],
                                  "tips": "Use traços em papel para visualizar a pilha de chamadas recursivas.",
                                  "learningObjective": "Avaliar propriedades matemáticas de monotonicidade em recursões.",
                                  "commonMistakes": [
                                    "Assumir diminuição sem simulação",
                                    "Permitir platôs como 'diminuição' quando não converge"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar Convergência para o Caso Base",
                                  "subSteps": [
                                    "Rastreie o caminho de argumentos do input inicial até o caso base.",
                                    "Calcule o número aproximado de iterações necessárias para atingir o base.",
                                    "Teste com valores numéricos pequenos para validar a simulação.",
                                    "Analise se há loops infinitos potenciais (argumentos não diminuem para base).",
                                    "Escreva uma declaração de convergência ou risco de não-terminação."
                                  ],
                                  "verification": "Execute a função com input pequeno e confirme terminação sem stack overflow.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente de programação para testes",
                                    "Valores de teste numéricos"
                                  ],
                                  "tips": "Teste com n=5 e n=0 para cobrir bordas.",
                                  "learningObjective": "Garantir terminação prática da recursão via análise de progresso.",
                                  "commonMistakes": [
                                    "Ignorar overflow em linguagens com limites de pilha",
                                    "Confundir convergência com eficiência"
                                  ]
                                }
                              ],
                              "practicalExample": "Na função fatorial def fact(n): if n <= 1: return 1 else: return n * fact(n-1), o argumento 'n' diminui monotonicamente (n → n-1) até <=1, garantindo convergência. Contraste com def bad_fact(n): return n * bad_fact(n+1), onde n aumenta, causando não-convergência.",
                              "finalVerifications": [
                                "Identifica corretamente todos os casos base e chamadas recursivas.",
                                "Lista e compara argumentos de entrada vs. recursivos com precisão.",
                                "Simula chamadas mostrando diminuição monotônica consistente.",
                                "Conclui validamente se converge para o caso base.",
                                "Explica riscos de não-terminação em exemplos contrários.",
                                "Testa numericamente com pelo menos dois inputs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes recursivos (90%+ correto).",
                                "Correta análise de monotonicidade com simulações visuais.",
                                "Profundidade da verificação de convergência (múltiplas iterações).",
                                "Clareza na explicação de progressos e falhas.",
                                "Uso efetivo de ferramentas e testes práticos.",
                                "Generalização para funções com múltiplos argumentos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de sequências decrescentes e indução matemática.",
                                "Lógica: Provas de terminação em lógica computacional.",
                                "Engenharia de Software: Verificação de corretude e análise estática.",
                                "Física: Modelos iterativos em simulações de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em algoritmos de divide-and-conquer como quicksort ou busca binária, verificar diminuição monotônica do tamanho do problema garante terminação eficiente, evitando loops infinitos em sistemas de software críticos como bancos de dados ou jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Traçar chamadas recursivas",
                            "description": "Executar manualmente o traçado de uma execução recursiva pequena, mostrando a pilha de chamadas e retornos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura da função recursiva",
                                  "subSteps": [
                                    "Leia a definição da função recursiva, identificando o caso base (base case) e o caso recursivo (recursive case).",
                                    "Anote os parâmetros de entrada e o que a função retorna em cada caso.",
                                    "Desenhe um diagrama simples da função mostrando onde a recursão ocorre.",
                                    "Liste as condições de parada (base case).",
                                    "Verifique se a função está bem definida evitando recursão infinita."
                                  ],
                                  "verification": "Confirme que você pode explicar verbalmente ou por escrito o base case e o recursive case.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Código fonte da função recursiva exemplo"
                                  ],
                                  "tips": "Sempre comece pelo base case; ele é o 'ponto de ancoragem' da recursão.",
                                  "learningObjective": "Identificar corretamente os componentes essenciais de uma função recursiva.",
                                  "commonMistakes": [
                                    "Confundir base case com recursive case",
                                    "Ignorar condições de parada levando a loops infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iniciar a chamada inicial e simular a pilha",
                                  "subSteps": [
                                    "Anote a chamada inicial com seus parâmetros (ex: fact(3)).",
                                    "Empilhe a chamada inicial na pilha de chamadas, registrando estado atual (parâmetros e valor parcial).",
                                    "Avalie se é base case; se não, execute o recursive case.",
                                    "Registre a próxima chamada recursiva na pilha.",
                                    "Continue empilhando até atingir o primeiro base case."
                                  ],
                                  "verification": "Desenhe a pilha de chamadas após as primeiras 2-3 empilhadas e confirme com um colega ou auto-revisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado para pilha",
                                    "Exemplo de código recursivo impresso"
                                  ],
                                  "tips": "Use uma tabela com colunas: Chamada, Parâmetros, Retorno Parcial para visualizar a pilha.",
                                  "learningObjective": "Simular corretamente o empilhamento de chamadas recursivas iniciais.",
                                  "commonMistakes": [
                                    "Esquecer de registrar o estado da chamada pai",
                                    "Não pausar na avaliação do base case"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Traçar até o base case e iniciar retornos",
                                  "subSteps": [
                                    "Continue empilhando chamadas até alcançar o base case mais profundo.",
                                    "No base case, compute o valor de retorno e anote-o.",
                                    "Desempilhe a chamada mais recente, aplicando o resultado ao pai (ex: multiplicação em fatorial).",
                                    "Repita o desempilhamento para todas as chamadas na pilha.",
                                    "Registre todos os retornos parciais até o resultado final."
                                  ],
                                  "verification": "A pilha deve estar vazia no final, com o resultado final correto calculado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho digital como Draw.io ou papel",
                                    "Calculadora para verificação numérica"
                                  ],
                                  "tips": "Pense na pilha como uma torre: construa até o topo (base case), depois desmonte calculando de cima para baixo.",
                                  "learningObjective": "Executar o ciclo completo de empilhamento e desempilhamento com precisão.",
                                  "commonMistakes": [
                                    "Desempilhar na ordem errada",
                                    "Erro aritmético nos retornos parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e validar o traçado completo",
                                  "subSteps": [
                                    "Desenhe o diagrama completo da árvore de chamadas ou pilha ao longo da execução.",
                                    "Compare o resultado final com uma execução direta da função.",
                                    "Identifique pontos onde stack overflow poderia ocorrer em entradas maiores.",
                                    "Escreva um resumo do fluxo: chamadas, pilha máxima, retornos.",
                                    "Teste com uma variação pequena do input para validar compreensão."
                                  ],
                                  "verification": "Explique o traçado para outra pessoa ou grave um vídeo curto demonstrando.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de diagramação (ex: Lucidchart gratuito)",
                                    "Código executável para verificação"
                                  ],
                                  "tips": "Use cores diferentes para empilhamento (azul) e desempilhamento (vermelho) no diagrama.",
                                  "learningObjective": "Consolidar o traçado em uma visualização clara e validada.",
                                  "commonMistakes": [
                                    "Ignorar o tamanho máximo da pilha",
                                    "Não validar contra execução real"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a função fatorial recursiva: def fact(n): if n <= 1: return 1 else: return n * fact(n-1). Trace fact(4): Pilha: fact(4) -> fact(3) -> fact(2) -> fact(1) [base:1] -> return 2 -> return 6 -> return 24.",
                              "finalVerifications": [
                                "Pode traçar corretamente fact(4) mostrando pilha máxima de 4 chamadas.",
                                "Identifica base case em funções como Fibonacci recursivo.",
                                "Calcula retornos parciais sem erros aritméticos.",
                                "Desenha diagrama de pilha com chamadas e retornos rotulados.",
                                "Explica o risco de stack overflow para n=1000."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de base e recursive cases (100%).",
                                "Correta simulação da pilha de chamadas e retornos.",
                                "Diagrama visual claro e completo.",
                                "Resultado final matches execução direta.",
                                "Explicação verbal fluida sem hesitações.",
                                "Detecção de erros comuns como recursão infinita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática (base case + passo recursivo).",
                                "Linguística: Estruturas recursivas em gramáticas (frases aninhadas).",
                                "Física: Modelos de movimento pendular ou fractais recursivos.",
                                "Artes: Geração de padrões fractais como árvore de Sierpinski."
                              ],
                              "realWorldApplication": "Debugging de algoritmos recursivos em software (ex: parsing de árvores em navegadores web), análise de performance para evitar stack overflow em aplicações como jogos ou processadores de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Equações de Recorrência",
                    "description": "Formulação matemática para modelar o tempo ou espaço de algoritmos recursivos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Formulação de Equações de Recorrência",
                        "description": "Processo de traduzir algoritmos recursivos em equações matemáticas que modelam o tempo de execução ou espaço auxiliar, identificando o número de subproblemas, seu tamanho e o custo de combinação.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar recursões em algoritmos",
                            "description": "Analisar o código de um algoritmo recursivo para determinar o número de chamadas recursivas (a), o tamanho dos subproblemas (n/b) e o custo não-recursivo f(n), como no Merge Sort.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica de um algoritmo recursivo",
                                  "subSteps": [
                                    "Leia a definição de recursão: uma função que chama a si mesma para resolver subproblemas menores.",
                                    "Identifique a condição base (caso que para a recursão).",
                                    "Localize as chamadas recursivas no código.",
                                    "Anote os parâmetros passados nas chamadas recursivas.",
                                    "Desenhe um diagrama de chamadas recursivas para um exemplo simples como fatorial."
                                  ],
                                  "verification": "Desenhe corretamente um diagrama de chamadas para fatorial(n=3) mostrando 3 chamadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código de exemplo de fatorial recursivo",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Sempre comece pela condição base para evitar confusão com loops infinitos.",
                                  "learningObjective": "Reconhecer componentes fundamentais de recursão: base e chamadas recursivas.",
                                  "commonMistakes": [
                                    "Confundir chamadas recursivas com loops iterativos",
                                    "Ignorar a condição base"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contar o número de chamadas recursivas (a)",
                                  "subSteps": [
                                    "Analise quantas vezes a função chama a si mesma por invocação.",
                                    "Para Merge Sort, note que há duas chamadas: mergeSort(left) e mergeSort(right).",
                                    "Confirme se 'a' é constante ou depende de n (geralmente constante como 2).",
                                    "Teste com n pequeno, trace as chamadas.",
                                    "Registre 'a=2' para Merge Sort."
                                  ],
                                  "verification": "Trace Merge Sort para n=4 e confirme exatamente 2 chamadas por nível.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código de Merge Sort",
                                    "Ferramenta de debug como Python Tutor"
                                  ],
                                  "tips": "Use contadores em código para validar o número de chamadas durante execução.",
                                  "learningObjective": "Determinar precisamente o fator de ramificação 'a' nas recursões.",
                                  "commonMistakes": [
                                    "Contar chamadas totais em vez de por invocação",
                                    "Incluir chamadas não-recursivas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar o tamanho dos subproblemas (n/b)",
                                  "subSteps": [
                                    "Examine os argumentos passados nas chamadas recursivas.",
                                    "Em Merge Sort, subproblemas são de tamanho n/2 cada.",
                                    "Identifique 'b' como o fator de redução (b=2 para halving).",
                                    "Verifique se subproblemas são iguais ou desiguais.",
                                    "Anote 'n/b = n/2'."
                                  ],
                                  "verification": "Para Merge Sort(n=8), confirme subproblemas de tamanho 4.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código de Merge Sort anotado",
                                    "Calculadora para tamanhos"
                                  ],
                                  "tips": "Pense em árvore de recursão: cada nó divide em b filhos de tamanho n/b.",
                                  "learningObjective": "Calcular o fator de redução 'b' e tamanho relativo dos subproblemas.",
                                  "commonMistakes": [
                                    "Assumir b=1 para recursões lineares",
                                    "Confundir com número de chamadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar o custo não-recursivo f(n)",
                                  "subSteps": [
                                    "Exclua todas as chamadas recursivas do código.",
                                    "Some o trabalho fora das recursões: em Merge Sort, é o merge de O(n).",
                                    "Classifique f(n) como constante, linear, etc.",
                                    "Ignore condições base se forem O(1).",
                                    "Formule a recorrência completa: T(n) = a T(n/b) + f(n)."
                                  ],
                                  "verification": "Escreva a recorrência exata para Merge Sort: T(n) = 2 T(n/2) + O(n).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código comentado linha por linha",
                                    "Tabela de análise de tempo"
                                  ],
                                  "tips": "Meça linhas executadas fora de recursão multiplicadas por n.",
                                  "learningObjective": "Isolar e quantificar o trabalho não-recursivo f(n).",
                                  "commonMistakes": [
                                    "Incluir tempo de recursão em f(n)",
                                    "Subestimar merge como O(1)"
                                  ]
                                }
                              ],
                              "practicalExample": "No Merge Sort, código mostra 2 chamadas recursivas (a=2), subproblemas de n/2 (b=2), e merge custa Θ(n) (f(n)=Θ(n)). Trace para array [1,3,2,4]: divide em [1,3] e [2,4], etc.",
                              "finalVerifications": [
                                "Formula corretamente a recorrência T(n) = 2T(n/2) + Θ(n) para Merge Sort.",
                                "Identifica a=1, b=1, f(n)=Θ(n) em busca binária recursiva.",
                                "Desenha árvore de recursão mostrando níveis log n.",
                                "Calcula chamadas totais como ~2n para Merge Sort.",
                                "Distingue recursão de divide-and-conquer balanceada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 'a' (100% correto em 3 exemplos).",
                                "Correta determinação de 'b' e tamanho subproblema.",
                                "Classificação precisa de f(n) em notação Big-O.",
                                "Explicação clara da recorrência completa.",
                                "Uso correto de diagramas para validação.",
                                "Identificação de erros comuns em análise."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações de recorrência via substituição ou Master Theorem.",
                                "Lógica e Programação: Depuração e tracing de stack frames.",
                                "Física: Modelos fractais e recursivos em simulações.",
                                "Economia: Análise de custo-benefício em otimização recursiva."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como no Google Maps (A* com heurísticas recursivas) ou compressão de dados (FFT recursiva), para prever tempo de execução e otimizar escalabilidade em big data."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Escrever equações de recorrência",
                            "description": "Formular a equação T(n) = a T(n/b) + f(n) a partir de um algoritmo recursivo, incluindo condições base como T(1) = c.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o algoritmo recursivo e identificar componentes principais",
                                  "subSteps": [
                                    "Leia o pseudocódigo ou código do algoritmo recursivo com atenção.",
                                    "Identifique as chamadas recursivas e quantas subchamadas são feitas (parâmetro 'a').",
                                    "Observe o tamanho do subproblema em relação ao problema original (parâmetro 'n/b').",
                                    "Liste o trabalho realizado fora das chamadas recursivas (função 'f(n)').",
                                    "Anote entradas e saídas para entender o fluxo."
                                  ],
                                  "verification": "Crie um diagrama de árvore de recursão simples com 2-3 níveis e rotule os componentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo do algoritmo",
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Comece pelo topo da recursão e desça; ignore otimizações inicialmente.",
                                  "learningObjective": "Compreender a estrutura recursiva para mapear parâmetros da equação de recorrência.",
                                  "commonMistakes": [
                                    "Confundir chamadas recursivas com loops",
                                    "Ignorar custos constantes no f(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar as condições base da recursão",
                                  "subSteps": [
                                    "Localize no código onde a recursão para (ex: if n == 1 ou n <= 1).",
                                    "Calcule o tempo ou custo exato para o caso base (geralmente uma constante 'c').",
                                    "Verifique se há múltiplos casos base e anote todos.",
                                    "Expresse como T(1) = c ou equivalente.",
                                    "Teste com entrada pequena para validar."
                                  ],
                                  "verification": "Escreva explicitamente as condições base e execute o algoritmo com n=1 para confirmar.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo",
                                    "Calculadora ou interpretador de código"
                                  ],
                                  "tips": "Casos base são cruciais para evitar recursão infinita; sempre especifique-os.",
                                  "learningObjective": "Identificar e formalizar pontos de parada da recursão.",
                                  "commonMistakes": [
                                    "Esquecer condições base",
                                    "Definir T(0) incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a relação recursiva principal",
                                  "subSteps": [
                                    "Conte o número de chamadas recursivas idênticas (a).",
                                    "Determine o fator de divisão do tamanho (b, ex: n/2 para divide-and-conquer).",
                                    "Some os custos não-recursivos: operações fora das chamadas (f(n)).",
                                    "Escreva a equação: T(n) = a * T(n/b) + f(n).",
                                    "Simplifique f(n) se possível (ex: O(n log n) para merge)."
                                  ],
                                  "verification": "Substitua valores pequenos (n=2, n=4) na equação e compare com execução real.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo analisado",
                                    "Folha de cálculos"
                                  ],
                                  "tips": "Assuma tamanhos iguais para subproblemas; ajuste se assimétricos.",
                                  "learningObjective": "Construir a forma padrão da equação de recorrência Master Theorem.",
                                  "commonMistakes": [
                                    "Errar o valor de 'a' ou 'b'",
                                    "Incluir recursão em f(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever a equação completa e validar",
                                  "subSteps": [
                                    "Combine condições base e recursão em uma equação única.",
                                    "Expanda a árvore de recursão para 3 níveis e some custos para verificar.",
                                    "Compare com teorema do Mestre ou solução exata conhecida.",
                                    "Ajuste se houver overheads ocultos.",
                                    "Documente suposições (ex: n potência de b)."
                                  ],
                                  "verification": "Resolva a equação para n pequeno e bata com medições empíricas de tempo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Equação parcial",
                                    "Ferramenta de plotagem como Python/Matplotlib para T(n)"
                                  ],
                                  "tips": "Use notação big-O para f(n) se exato for complexo.",
                                  "learningObjective": "Produzir equações precisas e verificáveis para análise assintótica.",
                                  "commonMistakes": [
                                    "Omitir suposições",
                                    "Não validar com casos concretos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Merge Sort: T(n) = 2 T(n/2) + O(n), com T(1) = O(1). Análise: 2 chamadas para metades, merge custa O(n).",
                              "finalVerifications": [
                                "Escreva corretamente a equação para 3 algoritmos diferentes (ex: Binary Search, Fibonacci, QuickSort).",
                                "Desenhe árvore de recursão e calcule T(n) manualmente para n=8.",
                                "Identifique a, b, f(n) em pseudocódigo não visto antes.",
                                "Aplique Master Theorem à sua equação e justifique.",
                                "Compare equação com medição real de tempo em código.",
                                "Explique diferenças se houver múltiplas recursões."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de a, b e f(n) (80% correto).",
                                "Inclusão correta de condições base.",
                                "Validação com expansão da árvore ou casos pequenos.",
                                "Clareza na documentação de suposições.",
                                "Capacidade de generalizar para algoritmos similares.",
                                "Ausência de erros comuns como confundir f(n) com recursão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências recursivas e relações lineares.",
                                "Física: Modelos dinâmicos recursivos em simulações (ex: fractais).",
                                "Engenharia de Software: Otimização de performance em sistemas distribuídos.",
                                "Economia: Modelos de crescimento recursivo em finanças.",
                                "Biologia: Algoritmos recursivos em filogenia e árvores evolutivas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, equações de recorrência são usadas para prever escalabilidade de algoritmos em big data (ex: Google usa para MapReduce), otimizando tempo de processamento em petabytes de dados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Definir condições base",
                            "description": "Estabelecer os casos base corretos para equações de recorrência, garantindo que a recursão termine, como T(0) = 0 ou T(1) = 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Condições Base",
                                  "subSteps": [
                                    "Estude a definição: condições base são valores fixos para entradas mínimas que interrompem a recursão.",
                                    "Analise por que são essenciais: previnem recursão infinita ao fornecer um ponto de parada.",
                                    "Identifique tipos comuns: T(0) = 0 para contagens ou somas, T(1) = 1 para sequências unitárias.",
                                    "Compare com iteração: base cases são como o 'início' de um loop.",
                                    "Anote exemplos simples de recursões sem base case que falham."
                                  ],
                                  "verification": "Explique em 2-3 frases o papel das condições base e dê um exemplo verbal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre recursão",
                                    "Vídeo introdutório sobre equações de recorrência (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Visualize como uma escada: sem o primeiro degrau (base case), você não sobe.",
                                  "learningObjective": "Dominar a definição e importância das condições base em recursões.",
                                  "commonMistakes": [
                                    "Confundir condições base com o caso recursivo principal",
                                    "Achar que base cases são opcionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos de Recorrências com e sem Base Cases",
                                  "subSteps": [
                                    "Examine a recorrência T(n) = T(n-1) + T(n-2) sem base: simule para n=3 e observe explosão.",
                                    "Adicione base cases T(0)=0, T(1)=1 e recalcule para n=3,4.",
                                    "Estude fatorial: T(n) = n * T(n-1), com T(0)=1 ou T(1)=1.",
                                    "Identifique padrões: base cases geralmente para n=0 ou n=1.",
                                    "Registre em tabela: recorrência, base cases e valores computados."
                                  ],
                                  "verification": "Simule manualmente T(5) para Fibonacci com base cases corretos e sem eles.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para simulações",
                                    "Calculadora ou planilha Excel para tabelas"
                                  ],
                                  "tips": "Desenhe uma árvore de recursão para visualizar chamadas infinitas sem base.",
                                  "learningObjective": "Reconhecer impactos de base cases ausentes ou incorretas.",
                                  "commonMistakes": [
                                    "Escolher base cases inconsistentes com a recursão",
                                    "Usar valores arbitrários sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Definição de Condições Base para Recorrências Simples",
                                  "subSteps": [
                                    "Para T(n) = 2*T(n-1) + 1, defina T(0)=0 e justifique.",
                                    "Para soma de primeiros n números: T(n)=T(n-1)+n, defina T(0)=0 ou T(1)=1.",
                                    "Crie 3 recorrências próprias e defina base cases viáveis.",
                                    "Teste consistência: compute T(2), T(3) manualmente.",
                                    "Documente escolhas: explique por que o valor escolhido termina a recursão."
                                  ],
                                  "verification": "Apresente 3 exemplos com base cases definidos e valores para n=0 a 3.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios impressos ou Google Docs",
                                    "Referência de algoritmos recursivos"
                                  ],
                                  "tips": "Pergunte: 'Qual o menor n possível? Qual valor lógico para ele?'",
                                  "learningObjective": "Aplicar seleção de base cases em contextos variados.",
                                  "commonMistakes": [
                                    "Definir múltiplos base cases desnecessários",
                                    "Ignorar o domínio da função (n inteiro positivo)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Refinar Condições Base",
                                  "subSteps": [
                                    "Valide terminação: prove que recursão atinge base case em passos finitos.",
                                    "Cheque unicidade: garanta que base cases cubram todos os casos mínimos.",
                                    "Teste com software: implemente recursão simples em Python e rode com/ sem base.",
                                    "Refine erros: ajuste base cases baseados em resultados inesperados.",
                                    "Resuma regras gerais: base para n=0/1, valor neutro ou inicial lógico."
                                  ],
                                  "verification": "Implemente e execute código recursivo com base cases, confirmando saída correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python IDLE ou online como Replit)",
                                    "Templates de funções recursivas"
                                  ],
                                  "tips": "Use print statements para rastrear chamadas recursivas.",
                                  "learningObjective": "Garantir validade e robustez das condições base definidas.",
                                  "commonMistakes": [
                                    "Não testar computacionalmente",
                                    "Assumir terminação sem prova"
                                  ]
                                }
                              ],
                              "practicalExample": "Na equação de recorrência para o número de Fibonacci modificado: T(n) = T(n-1) + T(n-2) para n > 1, defina condições base T(0) = 0 e T(1) = 1. Isso garante que T(2) = 1, T(3) = 2, etc., terminando a recursão corretamente ao atingir n=0 ou n=1.",
                              "finalVerifications": [
                                "Define base cases corretos para 3 recorrências padrão (Fibonacci, fatorial, soma).",
                                "Explica verbalmente por que base cases previnem recursão infinita.",
                                "Simula manualmente T(n) para n=4 com base cases e obtém valores exatos.",
                                "Identifica erros em base cases fornecidos incorretos.",
                                "Implementa função recursiva em código que roda sem stack overflow.",
                                "Justifica escolhas de valores base com lógica matemática."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de base cases (100% corretos em exemplos).",
                                "Justificativa clara e lógica para cada escolha de base case.",
                                "Capacidade de simular recursão manualmente sem erros.",
                                "Detecção de recursões inválidas por falta/incorreção de base cases.",
                                "Implementação prática em código funcional e testada.",
                                "Uso de terminologia precisa (ex: 'ponto de parada', 'terminação')."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e séries recursivas.",
                                "Programação: Funções recursivas em linguagens como Python ou Java.",
                                "Lógica: Provas de terminação em algoritmos.",
                                "Física: Modelos recursivos em simulações dinâmicas (ex: crescimento populacional)."
                              ],
                              "realWorldApplication": "Em análise de algoritmos como merge sort (T(n)=2T(n/2)+n, T(1)=1), base cases definem tempo para subproblemas unitários, essencial para calcular complexidade O(n log n) em sistemas reais como bancos de dados e buscas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Resolução por Expansão e Substituição",
                        "description": "Técnicas manuais para desenrolar equações de recorrência até obter uma forma fechada, usando iteração ou suposição indutiva.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Aplicar método da expansão",
                            "description": "Desenrolar iterativamente uma recorrência como T(n) = 2T(n/2) + n até identificar o padrão e somar a série resultante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e anotar a equação de recorrência inicial",
                                  "subSteps": [
                                    "Leia a equação de recorrência fornecida, como T(n) = 2T(n/2) + n.",
                                    "Identifique os componentes: função recursiva (2T(n/2)) e termo não-recursivo (+n).",
                                    "Anote o caso base, como T(1) = 1 ou similar.",
                                    "Verifique se n é uma potência de 2 para simplificar a expansão (assuma log n iterações).",
                                    "Escreva a recorrência em uma linha separada para referência."
                                  ],
                                  "verification": "A equação inicial e o caso base estão corretamente anotados sem erros de transcrição.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou editor de texto como Jupyter Notebook ou LaTeX.",
                                  "tips": "Sempre assuma que n = 2^k para facilitar o rastreamento de divisões exatas.",
                                  "learningObjective": "Compreender a estrutura básica de uma equação de recorrência e seu caso base.",
                                  "commonMistakes": "Esquecer de especificar o caso base ou confundir o termo recursivo com o não-recursivo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar expansões iterativas da recorrência",
                                  "subSteps": [
                                    "Substitua T(n) pela expressão recursiva: T(n) = 2[2T(n/4) + n/2] + n.",
                                    "Continue expandindo: T(n) = 4T(n/4) + 2*(n/2) + n.",
                                    "Faça pelo menos 3-4 expansões até ver um padrão emergente.",
                                    "Mantenha o rastreamento dos coeficientes e dos termos n/2^i.",
                                    "Pare quando o argumento recursivo se aproximar do caso base (ex: T(n/2^k) onde 2^k ≈ n)."
                                  ],
                                  "verification": "Expansões mostram substituições corretas sem erros aritméticos nos coeficientes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de cálculo ou quadro branco para expansões visuais.",
                                  "tips": "Use substituição direta sem pular passos para evitar erros de multiplicação de termos.",
                                  "learningObjective": "Executar substituições recursivas precisas para desenrolar a recorrência.",
                                  "commonMistakes": "Erro nos coeficientes (ex: multiplicar errado 2 * (n/2)) ou perder termos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o padrão e generalizar a expansão",
                                  "subSteps": [
                                    "Observe os termos resultantes: T(n) = 2^k T(n/2^k) + n * Σ (1 + 1/2 + ... + 1/2^{k-1}).",
                                    "Reconheça que os coeficientes recursivos formam 2^i e os não-recursivos n/2^{i-1}.",
                                    "Generalize para k iterações: T(n) = 2^k T(n/2^k) + n Σ_{i=0}^{k-1} 2^i / 2^i.",
                                    "Simplifique o padrão para Σ n (1 - 1/2^k)/(1 - 1/2).",
                                    "Escreva a forma geral compacta."
                                  ],
                                  "verification": "O padrão generalizado corresponde corretamente às expansões manuais realizadas.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Calculadora para verificar somas parciais.",
                                  "tips": "Alinhe os termos verticalmente para visualizar o padrão de soma geométrica.",
                                  "learningObjective": "Detectar e formalizar padrões em expansões recursivas como séries geométricas.",
                                  "commonMistakes": "Confundir índices nos somatórios ou ignorar o fator 2^i nos coeficientes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar a série e aplicar o caso base para obter a solução fechada",
                                  "subSteps": [
                                    "Defina k = log2(n), então n/2^k = 1 e 2^k = n.",
                                    "Substitua: T(n) = n T(1) + n Σ_{i=0}^{log n -1} 1 = n*1 + n * log n.",
                                    "Some a série geométrica: Σ = k = log2(n).",
                                    "Simplifique para T(n) = n log n + n (ou O(n log n)).",
                                    "Verifique numericamente com valores pequenos de n."
                                  ],
                                  "verification": "A solução final resolve corretamente para valores de teste (ex: n=4,8).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Exemplos numéricos prévios calculados manualmente.",
                                  "tips": "Sempre teste com n=2,4,8 para validar antes de generalizar.",
                                  "learningObjective": "Resolver somas de séries emergentes e aplicar limites para casos base.",
                                  "commonMistakes": "Esquecer de substituir 2^k por n ou errar a soma da série geométrica."
                                }
                              ],
                              "practicalExample": "Para T(n) = 2T(n/2) + n com T(1)=1: Expanda para T(4)=2T(2)+4=4T(1)+4+2=4+4+2=10; generalize para T(n)=n log2(n) + n, teste n=4: 4*2 +4=12 (ajuste exato).",
                              "finalVerifications": [
                                "Expansões iterativas coincidem com a forma geral derivada.",
                                "Soma da série geométrica está correta (ex: soma finita = n(1 - (1/2)^k)/(1/2)).",
                                "Aplicação do caso base produz solução fechada consistente.",
                                "Validação numérica para n=2^k pequenos bate com recursão direta.",
                                "Complexidade assintótica O(n log n) é identificada corretamente.",
                                "Padrão é expresso em notação de somatório Σ."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas substituições recursivas (sem erros aritméticos).",
                                "Identificação correta do padrão de série geométrica.",
                                "Resolução exata da soma e aplicação do caso base.",
                                "Generalização para big-O se aplicável.",
                                "Validação com exemplos numéricos.",
                                "Clareza na apresentação das expansões e somatório."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries geométricas infinitas e finitas.",
                                "Matemática: Logaritmos e propriedades de potências de 2.",
                                "Física: Modelagem de divisões recursivas em simulações de partículas.",
                                "Engenharia de Software: Análise de divide-and-conquer como em Merge Sort."
                              ],
                              "realWorldApplication": "Analisar a complexidade temporal do algoritmo Merge Sort, que segue T(n)=2T(n/2)+O(n), permitindo otimizar implementações em bancos de dados e processamento de big data."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Usar método da substituição",
                            "description": "Provar limites superior e inferior por indução, assumindo T(n) ≤ c n log n e verificando a hipótese indutiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Recorrência e Adivinhar o Bound Assintótico",
                                  "subSteps": [
                                    "Identifique a equação de recorrência T(n) = a T(n/b) + f(n).",
                                    "Expanda iterativamente a recorrência algumas vezes para adivinhar a forma da solução, como T(n) ≈ c n log n.",
                                    "Defina o bound superior conjecturado: T(n) ≤ c n log n para algum c > 0 e n ≥ n0.",
                                    "Prepare o bound inferior similarmente: T(n) ≥ d n log n para d > 0.",
                                    "Escolha log na base apropriada (geralmente base 2 para divisões por 2)."
                                  ],
                                  "verification": "Escreva a conjectura formal para T(n) ≤ c n log n e liste as expansões iniciais que justificam o palpite.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou editor LaTeX",
                                    "Exemplos de recorrências como T(n) = 2T(n/2) + n",
                                    "Referência: CLRS capítulo 4"
                                  ],
                                  "tips": [
                                    "Comece com expansões manuais para visualizar o padrão antes de formalizar.",
                                    "Use log₂ n para consistência com divisões por 2."
                                  ],
                                  "learningObjective": "Capacidade de adivinhar bounds precisos baseados em expansão iterativa.",
                                  "commonMistakes": [
                                    "Adivinhar bound muito frouxo (ex: n² em vez de n log n)",
                                    "Ignorar constantes ou floor/ceiling nas divisões",
                                    "Confundir O com Θ prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer o Caso Base da Indução",
                                  "subSteps": [
                                    "Escolha n0 pequeno (ex: n=1 ou n=2) onde T(n0) é conhecido.",
                                    "Verifique T(n0) ≤ c n0 log n0 ajustando c grande o suficiente para cobrir.",
                                    "Para bound inferior, verifique T(n0) ≥ d n0 log n0.",
                                    "Anote o valor mínimo de c e d necessários para o caso base.",
                                    "Confirme que a desigualdade holds com folga (c grande)."
                                  ],
                                  "verification": "Mostre cálculos numéricos para n=1,2,4 provando T(n) ≤ c n log n com c específico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou Python para T(n) em casos pequenos",
                                    "Tabela de valores base da recorrência"
                                  ],
                                  "tips": [
                                    "Escolha c ≥ max{T(n)/(n log n)} para n pequenos para garantir folga.",
                                    "Lide com log 0 definindo log 1 = 0."
                                  ],
                                  "learningObjective": "Dominar verificação do caso base com ajuste de constantes.",
                                  "commonMistakes": [
                                    "Esquecer de ajustar c para cobrir o máximo no caso base",
                                    "Usar n=0 onde log indefinido",
                                    "Não considerar T(1) constante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Assumir e Aplicar a Hipótese Indutiva",
                                  "subSteps": [
                                    "Assuma que para todo k < n, T(k) ≤ c k log k (hipótese indutiva - IH).",
                                    "Substitua na recorrência: T(n) ≤ a T(n/b) + f(n).",
                                    "Aplique IH em T(n/b): T(n/b) ≤ c (n/b) log (n/b).",
                                    "Simplifique: T(n) ≤ a c (n/b) log (n/b) + f(n).",
                                    "Expresse log(n/b) = log n - log b para alinhar com n log n."
                                  ]
                                },
                                "verification`: "
                              ],
                              "estimatedTime": "1 hora",
                              "materials": [
                                "Folha de anotações para IH",
                                "Livro CLRS ou notas de aula sobre indução"
                              ],
                              "tips": [
                                "Mantenha desigualdades ≤ em todos os passos.",
                                "Fatore n log n para comparar."
                              ],
                              "learningObjective": "Aplicar IH corretamente na recursão.",
                              "commonMistakes": [
                                "Aplicar IH só para n/2 sem generalizar para n/b",
                                "Esquecer o -log b no log",
                                "Trocar ≤ por ="
                              ]
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Reconhecer padrões geométricos",
                            "description": "Identificar somas de séries geométricas ou harmônicas na expansão, como Θ(n log n) para divide-and-conquer balanceado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Séries Geométricas e Harmônicas",
                                  "subSteps": [
                                    "Defina uma série geométrica: soma de termos a * r^k para k=0 a n-1.",
                                    "Calcule a soma fechada de uma série geométrica finita: S = a*(1-r^n)/(1-r).",
                                    "Identifique séries harmônicas: soma de 1/k, que cresce como ln(n).",
                                    "Diferencie convergência: geométrica converge rapidamente se |r|<1, harmônica diverge lentamente.",
                                    "Pratique com exemplos simples: soma 1 + 1/2 + 1/4 + 1/8."
                                  ],
                                  "verification": "Resolva 3 somas geométricas dadas e explique por que uma harmônica não tem soma fechada simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Calculadora ou software como Python para somas numéricas"
                                  ],
                                  "tips": "Lembre-se: razão r <1 para convergência em expansões de recorrências.",
                                  "learningObjective": "Compreender as propriedades matemáticas de séries relevantes para expansões de recorrências.",
                                  "commonMistakes": [
                                    "Confundir série geométrica com aritmética",
                                    "Esquecer o limite superior na soma finita",
                                    "Ignorar o caso r=1 (soma linear)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir Equações de Recorrência Simples",
                                  "subSteps": [
                                    "Escreva uma recorrência básica: T(n) = T(n/2) + f(n), com T(1)=1.",
                                    "Substitua iterativamente: T(n) = f(n) + T(n/2) = f(n) + f(n/2) + T(n/4).",
                                    "Continue até a base: expanda k vezes até n/2^k =1.",
                                    "Observe o padrão emergente na soma: Σ f(n/2^i) para i=0 a log n.",
                                    "Registre o número de iterações: aproximadamente log2(n)."
                                  ],
                                  "verification": "Expanda T(n)=2T(n/2)+n até 3 níveis e escreva a forma somada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou papel quadriculado",
                                    "Exemplos de recorrências impressos"
                                  ],
                                  "tips": "Use notação exata com limites: i=0 até floor(log2 n).",
                                  "learningObjective": "Dominar o processo de expansão iterativa de recorrências lineares.",
                                  "commonMistakes": [
                                    "Parar expansão prematuramente",
                                    "Erros em substituição de argumentos (n/2 vs n/4)",
                                    "Ignorar condição base"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Padrões Geométricos na Expansão",
                                  "subSteps": [
                                    "Na expansão, procure termos como c * n * (1/2)^i para i=0 a log n.",
                                    "Reconheça razão constante r=1/2 em divide-and-conquer balanceado.",
                                    "Compare com harmônica: se f(n)=1, surge Σ 1/2^i (geométrica) vs Σ 1/i (harmônica).",
                                    "Agrupar termos: fatorar n * Σ (1/2)^i.",
                                    "Preveja complexidade: para r<1, Θ(n); para harmônica, Θ(n log n)."
                                  ],
                                  "verification": "Dada uma expansão com 5 termos, classifique como geométrica ou harmônica e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de expansões anotadas",
                                    "Gráfico para plotar somas parciais"
                                  ],
                                  "tips": "Conte a razão entre termos consecutivos para confirmar geometricidade.",
                                  "learningObjective": "Desenvolver intuição para detectar padrões de séries em expansões recursivas.",
                                  "commonMistakes": [
                                    "Confundir crescimento linear com logarítmico",
                                    "Não normalizar termos para ver a razão",
                                    "Aplicar soma infinita prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Divide-and-Conquer Balanceado e Simplificar",
                                  "subSteps": [
                                    "Considere T(n)=2T(n/2)+n: expanda para n + 2*(n/2) + 4*(n/4) + ... = n * Σ 2^i / 2^i = n * log n termos.",
                                    "Corrija: na verdade, Σ 1 para log n níveis, mas ajustado é Θ(n log n) por harmônica em níveis.",
                                    "Para T(n)=T(n/2)+n: Σ n/2^i = n * Σ (1/2)^i = n*(2-1/2^{log n}) ≈ 2n (geométrica).",
                                    "Some usando fórmula fechada e limite inferior/superior para Θ.",
                                    "Verifique com n=8,16 para confirmação numérica."
                                  ],
                                  "verification": "Resolva T(n)=T(n/2)+n e prove Θ(n), contrastando com MergeSort Θ(n log n).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para simular recorrências",
                                    "Livro de Algoritmos (CLRS cap. 4)"
                                  ],
                                  "tips": "Sempre assuma n=2^k para simplificar logs.",
                                  "learningObjective": "Resolver recorrências comuns reconhecendo padrões e obter assintóticas precisas.",
                                  "commonMistakes": [
                                    "Confundir fator de ramificação (2T(n/2)) com razão na soma",
                                    "Esquecer multiplicador nos subproblemas",
                                    "Usar soma harmônica onde é geométrica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para MergeSort: T(n) = 2T(n/2) + n. Expansão: T(n) = n + 2*(n/2) + 4*(n/4) + ... + n*1 = n log n (harmônica por nível). Reconheça que cada nível soma n, com log n níveis.",
                              "finalVerifications": [
                                "Expanda corretamente uma recorrência dada até identificar o padrão.",
                                "Classifique corretamente uma série como geométrica ou harmônica.",
                                "Calcule soma fechada para série geométrica finita.",
                                "Preveja complexidade Θ correta para divide-and-conquer balanceado.",
                                "Diferencie expansões que levam a Θ(n) vs Θ(n log n).",
                                "Valide numericamente para n=16 e n=32."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão iterativa (sem erros de substituição).",
                                "Correta identificação do tipo de série (geométrica/harmônica).",
                                "Uso apropriado de fórmulas de soma fechada.",
                                "Derivação rigorosa de limites assintóticos Θ.",
                                "Explicação clara de padrões observados.",
                                "Aplicação consistente a exemplos variados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries infinitas e somas telescópicas.",
                                "Física: Decaimento exponencial em processos radioativos (análoga a r^k).",
                                "Economia: Modelos de crescimento composto descontado (séries geométricas).",
                                "Estatística: Somatórios em análise de variância cumulativa."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos como QuickSort ou FFT, reconhecer padrões geométricos permite prever tempo de execução Θ(n log n), essencial para escalabilidade em big data e machine learning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Teorema Mestre",
                        "description": "Teorema padrão para resolver recorrências da forma T(n) = a T(n/b) + f(n), com três casos baseados na comparação entre f(n) e n^{log_b a}.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Identificar parâmetros do Teorema Mestre",
                            "description": "Extrair a, b e f(n) de uma recorrência e calcular log_b a para classificar o caso 1, 2 ou 3.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a forma padrão do Teorema Mestre",
                                  "subSteps": [
                                    "Leia a declaração do Teorema Mestre: T(n) = a T(n/b) + f(n), onde a ≥ 1, b > 1.",
                                    "Identifique os componentes: a (número de subproblemas), b (fator de divisão do tamanho), f(n) (custo não-recursivo).",
                                    "Confirme que a recorrência está na forma exata ou assintótica Θ.",
                                    "Anote exemplos canônicos como T(n) = 2T(n/2) + n.",
                                    "Discuta regularidade de f(n) para casos aplicáveis."
                                  ],
                                  "verification": "Escreva a forma padrão e liste os três parâmetros com suas interpretações sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, referência do Teorema Mestre (livro ou PDF).",
                                  "tips": "Sempre comece pela forma padrão para evitar confusão com variações.",
                                  "learningObjective": "Compreender os componentes fundamentais da equação de recorrência do Teorema Mestre.",
                                  "commonMistakes": "Confundir a com o número de chamadas ou ignorar que b deve ser >1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair os parâmetros a e b da recorrência",
                                  "subSteps": [
                                    "Localize o termo recursivo: conte o número de T(·) para obter a.",
                                    "Identifique o argumento de T: extraia o fator de divisão n/b.",
                                    "Verifique se b é constante e >1; resolva para b se necessário (ex: n/2 implica b=2).",
                                    "Registre a e b explicitamente.",
                                    "Confirme que a é inteiro ≥1."
                                  ],
                                  "verification": "Apresente a recorrência e circule a e b corretamente identificados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplos de recurrences impressos ou em editor de texto, calculadora.",
                                  "tips": "Olhe primeiro para o número de termos T para achar a rapidamente.",
                                  "learningObjective": "Habilidade em isolar a e b da estrutura recursiva.",
                                  "commonMistakes": "Contar mal o número de subproblemas ou confundir n/2 com b=1/2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar f(n), o custo não-recursivo",
                                  "subSteps": [
                                    "Subtraia o termo recursivo da equação para isolar f(n).",
                                    "Reconheça f(n) como o termo restante após a T(n/b).",
                                    "Ignore constantes multiplicativas iniciais se Θ for usado.",
                                    "Classifique f(n) como polinomial (n^k) ou exponencial para preview.",
                                    "Escreva f(n) em notação big-O se não exata."
                                  ],
                                  "verification": "Reescreva a recorrência separando f(n) e verifique se soma ao original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado para equações, exemplos variados.",
                                  "tips": "f(n) é sempre o 'trabalho extra' fora da recursão.",
                                  "learningObjective": "Diferenciar precisamente o custo recursivo do não-recursivo.",
                                  "commonMistakes": "Incluir parte do recursivo em f(n) ou ignorar termos aditivos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular log_b a e classificar o caso",
                                  "subSteps": [
                                    "Calcule log_b a usando mudança de base: log_b a = ln(a)/ln(b) ou log2(a)/log2(b).",
                                    "Compare o crescimento de f(n) com n^{log_b a}.",
                                    "Classifique: Caso 1 se f(n) = O(n^{log_b a - ε}), Caso 2 se Θ(n^{log_b a} log^k n), Caso 3 se Ω(n^{log_b a + ε}).",
                                    "Verifique condições de regularidade para Caso 2/3.",
                                    "Anote a classificação final."
                                  ],
                                  "verification": "Mostre cálculo numérico de log_b a e justificativa da classificação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica, tabela de logs ou software como Python para verificação.",
                                  "tips": "Use calculadora para precisão; arredonde para comparação assintótica.",
                                  "learningObjective": "Aplicar log_b a para determinar o caso dominante do Teorema Mestre.",
                                  "commonMistakes": "Erro no cálculo de log (ex: log_b a como a/b), ignorar ε na comparação."
                                }
                              ],
                              "practicalExample": "Para T(n) = 4 T(n/2) + n^2: a=4, b=2, f(n)=n^2. log_2 4 = 2. Como f(n) = Θ(n^2), e 2 = log_b a, é Caso 2: T(n) = Θ(n^2 log n).",
                              "finalVerifications": [
                                "a, b e f(n) extraídos corretamente da recorrência.",
                                "Cálculo preciso de log_b a com pelo menos 2 casas decimais.",
                                "Classificação do caso (1, 2 ou 3) justificada com comparação assintótica.",
                                "Condições de regularidade verificadas se aplicável.",
                                "Reescrita da recorrência confirmando extração.",
                                "Solução do Teorema Mestre batendo com análise manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de a, b e f(n) (100% correto).",
                                "Cálculo exato de log_b a sem erros aritméticos.",
                                "Classificação correta do caso com justificativa assintótica.",
                                "Uso apropriado de notação big-O/Θ/Ω.",
                                "Tratamento de edge cases como a=1 ou b não inteiro.",
                                "Explicação clara das condições do teorema."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos e análise assintótica (cálculo de limites).",
                                "Matemática Discreta: Recorrências lineares e resolução exata.",
                                "Engenharia de Software: Análise de performance em algoritmos divide-and-conquer.",
                                "Física Computacional: Modelagem de simulações recursivas em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em análise de algoritmos como Merge Sort (T(n)=2T(n/2)+n, Caso 2) ou Strassen's Matrix Multiplication (Caso 3), permitindo prever tempo de execução em big data e otimizar código em aplicações como machine learning e processamento de grafos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Aplicar os casos do Teorema Mestre",
                            "description": "Resolver recorrências usando Caso 1 (f(n) = O(n^{log_b a - ε})), Caso 2 (f(n) = Θ(n^{log_b a} log^k n)) e Caso 3 (f(n) = Ω(n^{log_b a + ε}) com regularidade).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Forma Geral do Teorema Mestre e Condições Básicas",
                                  "subSteps": [
                                    "Estude a forma padrão T(n) = a T(n/b) + f(n), onde a ≥ 1, b > 1.",
                                    "Identifique as condições de regularidade: f(n) = O(n^{log_b a + ε}) para algum ε > 0.",
                                    "Memorize os três casos principais do teorema.",
                                    "Resolva log_b a manualmente para exemplos simples como a=2, b=2."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a forma geral e condições para um colega ou em um diário de aprendizado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre Teorema Mestre, calculadora para logaritmos, vídeo introdutório (ex: MIT OCW Algoritmos).",
                                  "tips": "Desenhe uma árvore de recursão para visualizar divide-and-conquer.",
                                  "learningObjective": "Compreender a estrutura fundamental do Teorema Mestre e suas premissas.",
                                  "commonMistakes": "Confundir a com b ou ignorar a condição de regularidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o Caso 1: Quando f(n) é Polinomialmente Menor",
                                  "subSteps": [
                                    "Verifique se f(n) = O(n^{log_b a - ε}) para ε > 0.",
                                    "Compare o crescimento de f(n) com n^{log_b a} usando limites ou testes assintóticos.",
                                    "Aplique a solução T(n) = Θ(n^{log_b a}).",
                                    "Resolva 3 exemplos: T(n)=2T(n/2)+n, T(n)=4T(n/2)+n, T(n)=2T(n/2)+√n.",
                                    "Justifique por que o caso se aplica com ε específico."
                                  ],
                                  "verification": "Resolva 2 recorrências do Caso 1 corretamente sem consultar notas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de exercícios de recorrências, Wolfram Alpha para verificar limites.",
                                  "tips": "Use a regra de L'Hôpital para limites lim f(n)/n^{log_b a} = 0.",
                                  "learningObjective": "Aplicar com precisão o Caso 1 identificando ε > 0.",
                                  "commonMistakes": "Escolher ε incorreto ou não verificar o limite indo a 0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar o Caso 2: Contribuição Logarítmica",
                                  "subSteps": [
                                    "Confirme regularidade e lim f(n)/n^{log_b a} = c > 0 (k=0) ou ~ log^k n.",
                                    "Entenda variações para k ≥ 0: T(n) = Θ(n^{log_b a} log^k n).",
                                    "Resolva exemplos: T(n)=2T(n/2)+n log n, T(n)=T(n/2)+n.",
                                    "Pratique generalização para k>1.",
                                    "Compare com Caso 1 para borderline cases."
                                  ],
                                  "verification": "Classifique e resolva 3 recorrências do Caso 2, explicando o valor de k.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro 'Introduction to Algorithms' (CLRS) capítulo 4, exercícios online (LeetCode discussões).",
                                  "tips": "Expanda log^k n como (log n)^k para clareza.",
                                  "learningObjective": "Identificar e resolver recorrências onde f(n) cresce como n^{log_b a} vezes log.",
                                  "commonMistakes": "Ignorar o expoente k ou confundir com Θ(n log n) sem justificativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar o Caso 3 e Aplicação Integrada",
                                  "subSteps": [
                                    "Verifique lim f(n)/n^{log_b a} = ∞ com ε > 0 e regularidade af(n) ≤ f(n).",
                                    "Aplique T(n) = Θ(f(n)).",
                                    "Resolva exemplos: T(n)=2T(n/2)+n^2, T(n)=T(n/2)+n^2.",
                                    "Misture casos: classifique 5 recorrências variadas.",
                                    "Crie sua própria recorrência e resolva."
                                  ],
                                  "verification": "Resolva um conjunto misto de 5 recorrências com 100% acerto e justificativas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Gerador de exercícios online, quadro branco para diagramas.",
                                  "tips": "Sempre verifique regularidade primeiro em todos os casos.",
                                  "learningObjective": "Aplicar todos os casos do Teorema Mestre de forma integrada.",
                                  "commonMistakes": "Aplicar Caso 3 sem provar o limite ∞ ou falhar na regularidade."
                                }
                              ],
                              "practicalExample": "Para T(n) = 3 T(n/2) + n^2: log_2 3 ≈ 1.58, f(n)=n^2 = Ω(n^{1.58 + ε}) com ε=0.42, regularidade ok (a f(n/b)=3(n/2)^2=0.75 n^2 < n^2), lim n^2 / n^{1.58} → ∞, então Caso 3: T(n)=Θ(n^2).",
                              "finalVerifications": [
                                "Classifique corretamente 5 recorrências mistas sem erros.",
                                "Justifique cada caso com cálculo de log_b a, ε e limite.",
                                "Explique diferenças entre casos para um 'aluno' imaginário.",
                                "Resolva uma recorrência não-padrão adaptando o teorema.",
                                "Identifique quando o teorema não se aplica (ex: f(n) oscilante)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do caso (100% correto).",
                                "Justificativa matemática completa (limites, ε, regularidade).",
                                "Eficiência na resolução (tempo < 5 min por recorrência).",
                                "Uso correto de notação assintótica (O, Θ, Ω).",
                                "Capacidade de generalizar para k>0 no Caso 2.",
                                "Detecção de violações das premissas do teorema."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e limites (Cálculo I/II).",
                                "Matemática: Logaritmos e propriedades de expoentes.",
                                "Engenharia de Software: Otimização de algoritmos recursivos.",
                                "Física/Matemática: Modelagem de crescimento em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em análise de algoritmos divide-and-conquer como Merge Sort (Caso 2: Θ(n log n)) ou Strassen's Matrix Multiplication (Caso 3), otimizando tempo de execução em big data e machine learning."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Verificar condições de aplicabilidade",
                            "description": "Validar se a recorrência atende aos requisitos do Teorema Mestre, como a ≥ 1, b > 1 e tamanhos de subproblemas decrescentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a forma padrão da equação de recorrência",
                                  "subSteps": [
                                    "Examine a equação dada e confirme se segue T(n) = a T(n/b) + f(n).",
                                    "Identifique explicitamente os valores de a, b e f(n).",
                                    "Verifique se a é um inteiro positivo e b é uma constante maior que 1.",
                                    "Anote a equação em sua forma canônica.",
                                    "Confirme se n/b é definido de forma que subproblemas sejam divisões uniformes."
                                  ],
                                  "verification": "A equação é reescrita corretamente na forma T(n) = a T(n/b) + f(n) com valores identificados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de equações de recorrência"
                                  ],
                                  "tips": "Sempre reescreva a equação para clareza antes de prosseguir.",
                                  "learningObjective": "Reconhecer e extrair os componentes fundamentais da forma do Teorema Mestre.",
                                  "commonMistakes": [
                                    "Confundir f(n) com o termo recursivo.",
                                    "Assumir valores de a ou b sem verificar a equação original."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar as condições sobre a e b",
                                  "subSteps": [
                                    "Confirme que a ≥ 1 (a é inteiro positivo ou zero, mas tipicamente ≥1).",
                                    "Verifique que b > 1 (b deve ser maior que 1 para garantir redução).",
                                    "Certifique-se de que a e b são constantes independentes de n.",
                                    "Calcule exemplos numéricos se necessário para validar.",
                                    "Documente se as condições são satisfeitas ou não."
                                  ],
                                  "verification": "Lista de verificações com justificativas escritas para a e b.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Referência ao enunciado do Teorema Mestre"
                                  ],
                                  "tips": "Lembre-se: a=0 invalida recursão; b≤1 não reduz o problema.",
                                  "learningObjective": "Aplicar precisamente as restrições numéricas em a e b.",
                                  "commonMistakes": [
                                    "Permitir a fracionária quando deve ser inteiro.",
                                    "Confundir b>1 com b≥1."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar decrescimento dos tamanhos de subproblemas",
                                  "subSteps": [
                                    "Analise se o tamanho do subproblema n/b < n para n suficientemente grande.",
                                    "Verifique se n/b é estritamente menor, considerando floor ou ceil se aplicável.",
                                    "Teste com valores grandes de n para confirmar redução assintótica.",
                                    "Confirme que a divisão é uniforme (mesmo tamanho para todos subproblemas).",
                                    "Identifique se há condições adicionais como divisibilidade exata."
                                  ],
                                  "verification": "Demonstração matemática ou numérica mostrando n/b < n.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico ou tabela de valores de n",
                                    "Software de plotagem opcional"
                                  ],
                                  "tips": "Use desigualdades: n/b < n iff b > 1, mas prove explicitamente.",
                                  "learningObjective": "Entender o requisito de terminação da recursão.",
                                  "commonMistakes": [
                                    "Ignorar floor/ceil em implementações reais.",
                                    "Assumir decrescimento sem prova para n grande."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar condições adicionais e concluir aplicabilidade",
                                  "subSteps": [
                                    "Verifique se f(n) é assintoticamente positiva (f(n) > 0 para n grande).",
                                    "Confirme que as condições de base estão implícitas ou definidas.",
                                    "Avalie se todas as condições do Teorema Mestre estão atendidas.",
                                    "Escreva uma conclusão clara: aplicável ou não, com razões.",
                                    "Registre contraexemplos se inválido."
                                  ],
                                  "verification": "Conclusão escrita com checklist completo de condições.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de checklist do Teorema Mestre"
                                  ],
                                  "tips": "Consulte o teorema completo para f(n) em O(n^k).",
                                  "learningObjective": "Sintetizar todas as verificações em uma decisão final.",
                                  "commonMistakes": [
                                    "Esquecer f(n) positiva.",
                                    "Aplicar teorema sem base case definida."
                                  ]
                                }
                              ],
                              "practicalExample": "Para T(n) = 2 T(n/2) + n: a=2 ≥1, b=2>1, n/2 < n (ex: n=8, sub=4<8), f(n)=n>0. Condições atendidas – Merge Sort.",
                              "finalVerifications": [
                                "Identifica corretamente a, b e f(n).",
                                "Confirma a ≥1 com justificativa.",
                                "Valida b>1 e decrescimento.",
                                "Conclui aplicabilidade corretamente.",
                                "Explica por que condições falham em contraexemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de parâmetros (100%).",
                                "Justificativas matemáticas claras.",
                                "Tratamento de casos edge (ex: a=1, b=1.5).",
                                "Conclusão consistente com teorema.",
                                "Uso de notação assintótica correta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Desigualdades e análise assintótica.",
                                "Lógica: Verificação de pré-condições em provas.",
                                "Física: Modelos recursivos em fractais e dinâmica.",
                                "Engenharia: Validação de specs em design de sistemas."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos como QuickSort ou FFT, verificar se o Teorema Mestre aplica para prever tempo de execução O(n log n), guiando escolhas de implementação em software de produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Método da Substituição",
                    "description": "Resolução de recorrências por conjectura de solução e prova por indução matemática.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Conjectura da Solução",
                        "description": "Processo de propor uma forma fechada para a solução de uma relação de recorrência, baseada na expansão manual da recorrência e identificação de padrões ou limites assintóticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Expandir recorrência manualmente",
                            "description": "Realizar a expansão iterativa de uma recorrência T(n) = a T(n/b) + f(n) por alguns passos para identificar o padrão emergente e conjecturar a forma da solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e anotar os componentes da recorrência",
                                  "subSteps": [
                                    "Leia a recorrência dada: T(n) = a T(n/b) + f(n)",
                                    "Identifique os parâmetros: a (coeficiente recursivo), b (fator de divisão), f(n) (trabalho não-recursivo)",
                                    "Anote as condições base, como T(1) = c ou similar",
                                    "Escreva a recorrência em uma folha de papel de forma clara",
                                    "Verifique se n é potência de b para simplificar (assuma n = b^k)"
                                  ],
                                  "verification": "Confira se todos os parâmetros (a, b, f(n)) estão corretamente anotados e condições base listadas",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de recorrência impresso ou anotado"
                                  ],
                                  "tips": "Sempre assuma que n é uma potência exata de b para evitar frações complicadas inicialmente",
                                  "learningObjective": "Compreender a estrutura padrão de uma recorrência Master Theorem",
                                  "commonMistakes": [
                                    "Confundir a com b",
                                    "Ignorar condições base",
                                    "Escrever f(n) incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar a primeira expansão iterativa",
                                  "subSteps": [
                                    "Substitua T(n) = a [a T(n/b^2) + f(n/b)] + f(n)",
                                    "Simplifique a expressão: T(n) = a^2 T(n/b^2) + a f(n/b) + f(n)",
                                    "Anote o termo recursivo restante e os dois termos f(n)",
                                    "Verifique algebricamente se a substituição está correta",
                                    "Destaque os termos acumulados de f"
                                  ],
                                  "verification": "A expansão resulta em exatamente dois termos f(n) e o termo recursivo com n/b^2",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para simplificações"
                                  ],
                                  "tips": "Use parênteses para agrupar corretamente as substituições recursivas",
                                  "learningObjective": "Executar uma iteração manual da expansão para visualizar o desdobramento",
                                  "commonMistakes": [
                                    "Erro na multiplicação de a pelo f(n/b)",
                                    "Esquecer de distribuir 'a' no termo interno",
                                    "Não simplificar os expoentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir para uma terceira iteração e generalizar",
                                  "subSteps": [
                                    "Substitua novamente o termo recursivo: adicione f(n/b^2) multiplicado por a^2",
                                    "Escreva: T(n) = a^3 T(n/b^3) + a^2 f(n/b^2) + a f(n/b) + f(n)",
                                    "Observe o padrão: termo recursivo a^k T(n/b^k) + soma de i=0 a k-1 de a^i f(n/b^i)",
                                    "Expanda até k=3 ou 4 para confirmar",
                                    "Registre a forma geral após observação"
                                  ],
                                  "verification": "Expansão mostra três ou mais termos f corretamente ponderados por potências de a",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Folha adicional para expansões múltiplas"
                                  ],
                                  "tips": "Alinhe os termos verticalmente para visualizar o padrão emergente claramente",
                                  "learningObjective": "Reconhecer a estrutura somatória após múltiplas expansões",
                                  "commonMistakes": [
                                    "Perder o rastreamento dos expoentes de a",
                                    "Erro nos argumentos de f(n/b^i)",
                                    "Parar cedo sem generalizar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar o padrão e conjecturar a solução",
                                  "subSteps": [
                                    "Analise os termos: T(n) ≈ soma_{i=0}^{k-1} a^i f(n / b^i) + a^k T(n/b^k)",
                                    "Assuma k grande (n/b^k ≈ 1), então T(1) conhecido",
                                    "Escreva a conjectura: T(n) = Θ( soma_{i=0}^{log_b n -1} a^i f(n / b^i) )",
                                    "Teste com um exemplo numérico pequeno para validar",
                                    "Documente a forma conjecturada claramente"
                                  ],
                                  "verification": "Conjectura inclui a soma correta e considera o limite da recursão",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo numérico calculado"
                                  ],
                                  "tips": "Pense em k = log_b n para parar a recursão",
                                  "learningObjective": "Conjecturar a forma fechada baseada no padrão observado",
                                  "commonMistakes": [
                                    "Ignorar o termo base a^k T(1)",
                                    "Não usar notação somatória",
                                    "Conjectura sem justificativa do padrão"
                                  ]
                                }
                              ],
                              "practicalExample": "Para T(n) = 2 T(n/2) + n (Merge Sort): Expansão dá T(n) = 2^k T(1) + soma_{i=0}^{k-1} 2^i (n / 2^i) = 2^k + n k, com k=log2 n, conjecturando T(n) = O(n log n).",
                              "finalVerifications": [
                                "Expansão iterativa correta para pelo menos 3 níveis",
                                "Padrão somatório identificado com índices i de 0 a k-1",
                                "Conjectura inclui termo recursivo base e soma de f",
                                "Validação com exemplo numérico pequeno (ex: n=8)",
                                "Assunção n=b^k explicitada",
                                "Forma geral escrita usando notação Θ ou O"
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica nas expansões (sem erros de cálculo)",
                                "Identificação correta do padrão somatório",
                                "Conjectura lógica e completa",
                                "Clareza na documentação e alinhamento de termos",
                                "Tratamento adequado das condições base",
                                "Validação com exemplo prático"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries geométricas e somatórios infinitos",
                                "Matemática: Logaritmos e mudança de base",
                                "Física: Modelagem recursiva de processos iterativos (ex: fratura de materiais)",
                                "Engenharia: Análise de divide-and-conquer em sistemas reais"
                              ],
                              "realWorldApplication": "Em análise de algoritmos para prever tempo de execução de divide-and-conquer como Merge Sort ou FFT, otimizando software em big data e machine learning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Identificar forma suspeita da solução",
                            "description": "A partir da expansão, reconhecer padrões como somas geométricas ou polinomiais e formular conjecturas como T(n) ≤ c n^k para k conhecido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Recorrência Original",
                                  "subSteps": [
                                    "Leia a equação de recorrência T(n) fornecida, identificando os termos base T(1) ou condições iniciais.",
                                    "Identifique o formato geral: T(n) = a T(n-b) + f(n), onde a é o número de subproblemas, b é o tamanho reduzido, e f(n) é o custo não-recursivo.",
                                    "Anote os valores de a, b e o tipo de f(n) (constante, linear, polinomial, etc.).",
                                    "Registre qualquer padrão óbvio inicial, como se f(n) sugere crescimento linear ou exponencial.",
                                    "Desenhe um diagrão de árvore de recursão simples para visualizar a estrutura."
                                  ],
                                  "verification": "Confirme que você pode reescrever a recorrência no formato padrão e listar corretamente a, b e f(n).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplo de recorrência impresso ou digital"
                                  ],
                                  "tips": "Sempre comece pelas condições base; elas ancoram a análise.",
                                  "learningObjective": "Compreender a estrutura fundamental de uma recorrência para preparar expansões.",
                                  "commonMistakes": [
                                    "Ignorar condições base",
                                    "Confundir f(n) com termos recursivos",
                                    "Assumir formato sem verificar a e b"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Expansões Iniciais da Recorrência",
                                  "subSteps": [
                                    "Substitua T(n) por sua definição recursiva uma vez: T(n) = a T(n-b) + f(n).",
                                    "Expanda o termo recursivo novamente: substitua T(n-b) por a T(n-2b) + f(n-b), resultando em T(n) = a² T(n-2b) + a f(n-b) + f(n).",
                                    "Continue expandindo 2-3 vezes mais, até ver um padrão emergente ou atingir a base.",
                                    "Escreva a expansão completa, agrupando termos semelhantes.",
                                    "Conte o número de folhas na árvore de recursão para estimar o padrão."
                                  ],
                                  "verification": "A expansão deve mostrar termos recursivos decrescentes e soma de f(n) em potências de a.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para potências",
                                    "Planilha ou software como Python para simular expansões"
                                  ],
                                  "tips": "Use notação abreviada como Σ para somas iniciais para evitar escrita longa.",
                                  "learningObjective": "Executar expansões manuais para revelar a forma acumulada da solução.",
                                  "commonMistakes": [
                                    "Erros aritméticos em potências de a",
                                    "Parar expansão cedo demais",
                                    "Não alinhar termos de f(n) corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Padrões na Expansão",
                                  "subSteps": [
                                    "Examine os coeficientes dos termos f(n), f(n-b), etc., procurando sequências como a^k.",
                                    "Identifique se a soma de f(n-ib) forma uma série geométrica (razão constante), aritmética (linear) ou polinomial.",
                                    "Compare com padrões conhecidos: soma geométrica Σ r^i, polinomial Σ i^k.",
                                    "Verifique se o termo recursivo dominante sugere O(n^k) ou exponencial.",
                                    "Anotar o padrão suspeito, como 'parece uma soma geométrica com razão 2'."
                                  ],
                                  "verification": "Descreva verbalmente o padrão identificado e dê um exemplo de fórmula fechada aproximada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de séries conhecidas (geométrica, harmônica)",
                                    "Gráfico da expansão vs. n"
                                  ],
                                  "tips": "Plote os termos parciais em um gráfico para visualização intuitiva.",
                                  "learningObjective": "Detectar padrões matemáticos familiares em expansões recursivas.",
                                  "commonMistakes": [
                                    "Confundir série geométrica com polinomial",
                                    "Ignorar o fator a na soma",
                                    "Sobre-generalizar de poucas expansões"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular a Conjectura da Solução",
                                  "subSteps": [
                                    "Baseado no padrão, proponha T(n) ≤ c n^k, onde k é derivado do grau polinomial ou log do crescimento.",
                                    "Escolha c inicial baseado na soma dominante ou condições base.",
                                    "Escreva a conjectura exata, como T(n) = Θ(n^k) ou com limites.",
                                    "Teste a conjectura com valores pequenos de n para validação inicial.",
                                    "Refine se necessário, adicionando termos logarítmicos se o padrão sugerir."
                                  ],
                                  "verification": "A conjectura deve coincidir com expansões para n=1 a 5 e ser no formato T(n) ≤ c n^k.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos resolvidos de livros como CLRS",
                                    "Calculadora para checagem numérica"
                                  ],
                                  "tips": "Comece com desigualdade frouxa (≤) para método da substituição.",
                                  "learningObjective": "Traduzir padrões observados em conjecturas formais testáveis.",
                                  "commonMistakes": [
                                    "Escolher k errado baseado em uma expansão só",
                                    "Esquecer fator c",
                                    "Não considerar Θ para tight bound"
                                  ]
                                }
                              ],
                              "practicalExample": "Para T(n) = 2 T(n/2) + n, expanda: T(n) = 2(2 T(n/4) + n/2) + n = 4 T(n/4) + 2(n/2) + n = 4 T(n/4) + 1.5 n. Continuando, revela soma n (1 + 1/2 + 1/4 + ...) ≈ 2n, conjectura T(n) ≤ c n log n, mas padrão polinomial sugere k=1 com log.",
                              "finalVerifications": [
                                "Expansão manual de uma recorrência dada mostra padrão claro.",
                                "Padrão identificado corresponde a uma série conhecida (geométrica/polinomial).",
                                "Conjectura formulada no formato T(n) ≤ c n^k com justificativa.",
                                "Teste numérico para n=4,8,16 valida a conjectura.",
                                "Explicação oral do processo cobre todos os passos.",
                                "Identifica corretamente quando o padrão não é óbvio (ex: harmônico)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão (sem erros aritméticos): 25%",
                                "Correta identificação de padrões: 25%",
                                "Qualidade da conjectura (tight bound e justificativa): 20%",
                                "Uso de verificações numéricas: 15%",
                                "Clareza na documentação e diagrama: 10%",
                                "Tratamento de edge cases: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries infinitas e somas fechadas.",
                                "Matemática Discreta: Indução e provas por conjectura.",
                                "Estatística: Modelagem de crescimento assintótico em dados.",
                                "Física: Recorrências em simulações dinâmicas (ex: fractais)."
                              ],
                              "realWorldApplication": "Em otimização de software, identificar formas de soluções em algoritmos recursivos como merge sort permite prever tempo de execução e decidir otimizações, essencial em big data e IA para escalabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Usar limites superior e inferior",
                            "description": "Estabelecer conjecturas com desigualdades O(g(n)) ou Θ(g(n)) considerando funções de crescimento como n log n ou n^2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Limites Assintóticos e Método da Substituição",
                                  "subSteps": [
                                    "Estude as definições de O(g(n)), Ω(g(n)) e Θ(g(n)) com exemplos de funções como n log n e n².",
                                    "Revise o método da substituição: assumir uma conjectura T(n) ≤ c·g(n) e provar por indução.",
                                    "Identifique recorrências onde limites superior e inferior são necessários, como T(n) = T(n/2) + T(n/4) + n.",
                                    "Pratique desenhando árvores de recorrência para visualizar o crescimento.",
                                    "Compare taxas de crescimento: liste funções comuns e ordene-as por assintótica."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre O(g(n)) e Ω(g(n)) e dê um exemplo de recorrência que requer ambos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre análise assintótica",
                                    "Livro 'Introduction to Algorithms' (CLRS), Capítulo 4",
                                    "Calculadora ou software como Desmos para plotar funções"
                                  ],
                                  "tips": "Use tabelas para comparar big-O, Omega e Theta em exemplos simples para fixar as diferenças.",
                                  "learningObjective": "Compreender os limites assintóticos e seu papel no método da substituição para conjecturas precisas.",
                                  "commonMistakes": [
                                    "Confundir O(g(n)) com ≤ g(n) exata",
                                    "Ignorar constantes c na conjectura",
                                    "Esquecer base casos na indução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular Conjectura Inicial com Limite Superior O(g(n))",
                                  "subSteps": [
                                    "Analise a recorrência e adivinhe g(n) baseado na árvore de recorrência ou master theorem.",
                                    "Escreva a conjectura: T(n) ≤ c·g(n) para algum c > 0 e n ≥ n₀.",
                                    "Escolha g(n) considerando funções como n log n ou n², justificando pelo crescimento dominante.",
                                    "Defina a hipótese indutiva clara: assume verdadeira para tamanhos menores.",
                                    "Teste a conjectura em casos pequenos (n=1,2,4) para ajustar c."
                                  ],
                                  "verification": "Escreva uma conjectura O(g(n)) para T(n) = 2T(n/2) + n e justifique g(n) = n log n.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e caneta para árvores de recorrência",
                                    "Exemplos de recorrências do CLRS",
                                    "Python ou Mathematica para computar valores exatos"
                                  ],
                                  "tips": "Sempre inclua o fator c e escolha n₀ grande o suficiente para cobrir bases.",
                                  "learningObjective": "Selecionar e formular corretamente uma conjectura de limite superior baseada em análise qualitativa.",
                                  "commonMistakes": [
                                    "Escolher g(n) muito apertado sem folga",
                                    "Não considerar o termo não-recursivo dominante",
                                    "Omitir condições n ≥ n₀"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar Limite Superior por Indução e Formular Limite Inferior",
                                  "subSteps": [
                                    "Verifique caso base: prove T(n₀) ≤ c·g(n₀).",
                                    "Passe indutivo: substitua T(n) ≤ c·T(n/b) + f(n) e mostre ≤ c·g(n), ajustando desigualdades.",
                                    "Resolva para c: isole termos e encontre c que funcione para todos n.",
                                    "Formule conjectura inferior: T(n) ≥ d·g(n) para d > 0.",
                                    "Repita indução para Ω(g(n)), focando em lower bound."
                                  ],
                                  "verification": "Complete a prova de indução para O(n log n) na recorrência merge sort e esboce para Ω.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Folha de exercícios de indução em recorrências",
                                    "CLRS exercícios 4.1-4.6",
                                    "LaTeX ou editor de equações online"
                                  ],
                                  "tips": "Massageie desigualdades: adicione/subtraia termos para encaixar na forma g(n).",
                                  "learningObjective": "Executar prova por indução completa para limite superior e esboçar inferior.",
                                  "commonMistakes": [
                                    "Erro no passo indutivo ao expandir recursões",
                                    "Escolher c muito pequeno que falha em n grandes",
                                    "Confundir upper com lower bound na mesma prova"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Limite Inferior e Concluir Θ(g(n))",
                                  "subSteps": [
                                    "Caso base para inferior: T(n₀) ≥ d·g(n₀).",
                                    "Passo indutivo para Ω: mostre T(n) ≥ d·g(n) usando hipóteses em subproblemas.",
                                    "Combine provas: como O e Ω implicam Θ(g(n)).",
                                    "Teste com contraexemplos: verifique se conjectura falha e ajuste.",
                                    "Documente a solução completa com valores de c, d, n₀."
                                  ],
                                  "verification": "Forneça prova completa Θ(n log n) para T(n) = 2T(n/2) + n, citando c e d.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exercícios avançados de recorrências",
                                    "Solução de problemas do LeetCode/HackerRank sobre análise",
                                    "Ferramenta de plotagem para comparar T(n) e g(n)"
                                  ],
                                  "tips": "Para lower bound, foque nos caminhos mais profundos da árvore de recorrência.",
                                  "learningObjective": "Finalizar prova de tight bound Θ(g(n)) combinando superior e inferior.",
                                  "commonMistakes": [
                                    "Prova de lower bound fraca sem d explícito",
                                    "Concluir Θ sem ambas as direções",
                                    "Ignorar condições de regularidade f(n) = O(g(n)/n)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a recorrência do Merge Sort T(n) = 2T(n/2) + n: Conjectura superior T(n) ≤ c n log n (c=2, n≥2). Prova: Base T(2)=2≤2*2*1. Indutivo: 2 c (n/2) log(n/2) + n ≤ c n log n ajustando. Inferior similar com d=1 para Θ(n log n).",
                              "finalVerifications": [
                                "Resolva T(n)=T(n/2)+T(n/4)+n com limites superior/inferior.",
                                "Prove Θ(n²) para T(n)=4T(n/2)+n².",
                                "Identifique quando substituição falha e use master theorem.",
                                "Compare crescimento: n log n vs n² em tabela.",
                                "Debug uma prova com erro comum fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de conjecturas O/Ω/Θ com justificativa de g(n).",
                                "Corretude da prova por indução (base, passo, constantes c/d).",
                                "Uso apropriado de desigualdades e manipulação algébrica.",
                                "Identificação de erros comuns e ajustes necessários.",
                                "Aplicação a novas recorrências não vistas.",
                                "Clareza na documentação da solução completa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Prova por indução matemática e análise assintótica.",
                                "Física: Modelagem de complexidade em simulações dinâmicas.",
                                "Engenharia de Software: Otimização de performance em sistemas reais.",
                                "Estatística: Análise de tempo de execução empírico vs teórico."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usar limites superior/inferior para provar que um algoritmo de ordenação como Merge Sort roda em Θ(n log n), guiando escolhas em big data processing no Google ou AWS para eficiência escalável."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Prova por Indução - Caso Base",
                        "description": "Verificação inicial da conjectura para valores pequenos de n, garantindo que a desigualdade ou igualdade se sustente na base da recursão.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Verificar caso base",
                            "description": "Escolher n0 adequado (ex: n=1 ou n=b) e comprovar diretamente que T(n0) ≤ c g(n0), ajustando constantes c se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e justificar o valor base n0",
                                  "subSteps": [
                                    "Analise a recorrência T(n) para determinar o menor n onde a recursão para (ex: n=1 ou n=b na forma T(n)=aT(n/b)+g(n)).",
                                    "Verifique restrições da recorrência, como n deve ser potência de b ou inteiro.",
                                    "Escolha n0 como o menor valor possível (ex: n0=1 se T(1) definido, ou n0=b).",
                                    "Justifique por que n0 é adequado: deve satisfazer condições da hipótese indutiva e ser computável diretamente.",
                                    "Anote n0 e sua justificativa em um rascunho."
                                  ],
                                  "verification": "Confirme que T(n0) está explicitamente definido na recorrência sem recursão infinita.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Definição da recorrência T(n), papel e caneta para anotações.",
                                  "tips": "Comece sempre com o menor n possível para simplificar cálculos.",
                                  "learningObjective": "Compreender o papel do caso base na indução para recorrências.",
                                  "commonMistakes": "Escolher n0 onde T(n0) ainda é recursivo ou fora do domínio."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o valor exato de T(n0)",
                                  "subSteps": [
                                    "Substitua n=n0 na recorrência base (ex: T(1)=1 ou T(b)=θ(1)).",
                                    "Expanda manualmente se necessário para valores pequenos (ex: T(2)=aT(1)+g(2)).",
                                    "Use a forma assintótica se aplicável, mas priorize valor exato ou limite superior.",
                                    "Registre o cálculo passo a passo, incluindo expansões.",
                                    "Verifique aritmética com uma segunda leitura."
                                  ],
                                  "verification": "O valor T(n0) é um número concreto ou expressão simples sem variáveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, tabela de valores base da recorrência.",
                                  "tips": "Desenhe uma árvore de recursão pequena para visualizar T(n0).",
                                  "learningObjective": "Dominar cálculo direto de casos base em recorrências.",
                                  "commonMistakes": "Ignorar condições base ou errar na expansão aritmética."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e ajustar a constante c",
                                  "subSteps": [
                                    "Calcule g(n0) usando a função de custo não-recursivo.",
                                    "Escolha c inicial como c ≥ T(n0)/g(n0), assumindo g(n0)>0.",
                                    "Se T(n0)/g(n0) não inteiro, arredonde c para cima (ex: c=2 se T(n0)=3, g(n0)=1).",
                                    "Teste c com desigualdade T(n0) ≤ c g(n0).",
                                    "Aumente c iterativamente se desigualdade falhar."
                                  ],
                                  "verification": "c é uma constante positiva finita onde T(n0) ≤ c g(n0) segura.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Valores de T(n0) e g(n0) do passo anterior, calculadora.",
                                  "tips": "Escolha c conservador (maior) para facilitar passos indutivos futuros.",
                                  "learningObjective": "Aprender a calibrar constantes para limites assintóticos.",
                                  "commonMistakes": "Escolher c muito pequeno ou esquecer que c pode ser ajustado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comprovar e documentar a desigualdade do caso base",
                                  "subSteps": [
                                    "Escreva formalmente: 'Para n=n0, T(n0) = [valor] ≤ c g(n0) = [valor], pois [cálculo].'",
                                    "Inclua todos os passos de cálculo inline.",
                                    "Verifique numericamente: compute ambos os lados e compare.",
                                    "Discuta se c funciona para n0 e por que é válido.",
                                    "Salve como parte da prova completa."
                                  ],
                                  "verification": "Desigualdade segura com evidência numérica ou algébrica explícita.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Rascunho dos passos anteriores, editor de texto ou caderno.",
                                  "tips": "Use LaTeX ou Markdown para formatação clara na documentação.",
                                  "learningObjective": "Formalizar comprovações em provas matemáticas.",
                                  "commonMistakes": "Pular verificação numérica ou não justificar ajuste de c."
                                }
                              ],
                              "practicalExample": "Para T(n) = 2T(n/2) + n (merge sort), com g(n) = n lg n. Escolha n0=1, T(1)=1. g(1)=0 (ajuste lg1=0, mas use n0=2: T(2)=2T(1)+2=4, g(2)=2 lg2=2. c=2: 4 ≤ 2*2=4, ok.",
                              "finalVerifications": [
                                "n0 escolhido é o menor válido e justificado.",
                                "T(n0) calculado corretamente sem recursão.",
                                "c ≥ T(n0)/g(n0) e desigualdade comprovada.",
                                "Todos cálculos documentados com passos.",
                                "Desigualdade segura para indução subsequente.",
                                "Sem erros aritméticos detectados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escolha e justificativa de n0 (30%).",
                                "Correção no cálculo de T(n0) e g(n0) (25%).",
                                "Adequação e ajuste lógico de c (20%).",
                                "Clareza e formalidade da comprovação (15%).",
                                "Ausência de erros comuns e verificações extras (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípios de indução matemática.",
                                "Lógica: Verificação de premissas em provas formais.",
                                "Engenharia de Software: Validação de complexidades em códigos reais."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos como quicksort ou FFT, verificar caso base garante que análises de tempo O(n log n) sejam confiáveis para implementações práticas em software de produção."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Ajustar constantes no caso base",
                            "description": "Determinar o menor c > 0 que satisfaz o caso base, considerando condições de contorno da recorrência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a recorrência, casos base e hipótese indutiva",
                                  "subSteps": [
                                    "Leia a definição da recorrência T(n), incluindo condições iniciais T(k) para k pequenos.",
                                    "Identifique os casos base relevantes, especialmente o menor n onde a recursão não se aplica diretamente.",
                                    "Escreva a hipótese indutiva assumida, como T(n) ≤ c * f(n) para algum c > 0 e n ≥ n0.",
                                    "Note as condições de contorno onde f(n) pode ser zero ou pequeno.",
                                    "Anote o menor c > 0 necessário para cobrir os casos base."
                                  ],
                                  "verification": "Lista completa da recorrência, casos base e hipótese indutiva escrita corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, definição da recorrência (livro ou notas).",
                                  "tips": "Sempre comece pelo menor n possível para evitar surpresas em contornos.",
                                  "learningObjective": "Compreender os componentes da prova por substituição no caso base.",
                                  "commonMistakes": "Ignorar condições de contorno como T(1) ou n=2; assumir c=1 sem cálculo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar desigualdade no caso base inicial",
                                  "subSteps": [
                                    "Substitua o menor caso base na hipótese: T(n0) ≤ c * f(n0).",
                                    "Calcule o valor exato de T(n0) usando a recorrência ou dado.",
                                    "Resolva para c: c ≥ T(n0) / f(n0), considerando se f(n0)=0 (ajustar n0).",
                                    "Registre o valor mínimo de c obtido.",
                                    "Verifique se f(n0) é definido e positivo."
                                  ],
                                  "verification": "Desigualdade escrita com cálculo explícito de c mínimo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, papel para equações.",
                                  "tips": "Se f(n0)=0, avance para o próximo n0 onde f(n0)>0.",
                                  "learningObjective": "Calcular precisamente o limite inferior para c no primeiro caso base.",
                                  "commonMistakes": "Dividir por zero em log(1)=0; não usar o valor exato de T(n0)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar e ajustar c para casos base subsequentes",
                                  "subSteps": [
                                    "Calcule T(n) para os próximos 2-3 casos base usando a recorrência.",
                                    "Teste cada um: T(ni) ≤ c * f(ni) com o c do passo anterior.",
                                    "Se falhar, atualize c = max(c anterior, T(ni)/f(ni)).",
                                    "Repita até cobrir todos os casos base até o ponto de indução.",
                                    "Escolha um c ligeiramente maior para margem de segurança."
                                  ],
                                  "verification": "Tabela com todos casos base, valores T(ni), f(ni) e verificação ≤ c*f(ni).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha ou tabela no papel, calculadora.",
                                  "tips": "Use potências de 2 para recorrências binárias para facilitar cálculos.",
                                  "learningObjective": "Garantir que c funcione globalmente nos casos base.",
                                  "commonMistakes": "Parar após um caso base; escolher c muito apertado sem margem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar e confirmar o valor final de c",
                                  "subSteps": [
                                    "Resuma o c escolhido e justifique por que é o menor >0.",
                                    "Escreva a hipótese fortalecida: T(n) ≤ c f(n) para n ≥ n0.",
                                    "Verifique numericamente em um caso base extra.",
                                    "Discuta implicações para o passo indutivo.",
                                    "Salve a prova do caso base completa."
                                  ],
                                  "verification": "Declaração final clara do c e prova escrita.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto ou caderno.",
                                  "tips": "Sempre adicione 10-20% ao c mínimo para robustez.",
                                  "learningObjective": "Finalizar a configuração do caso base para prosseguir à indução.",
                                  "commonMistakes": "Não mencionar n0 explicitamente; esquecer margem de erro."
                                }
                              ],
                              "practicalExample": "Para T(n) = T(n/2) + n com T(1) = 1 (n potência de 2). Hipótese: T(n) ≤ c n lg n para n ≥ 2. Caso n=2: T(2)=1+2=3 ≤ c*2*1=2c ⇒ c ≥ 1.5. n=4: T(4)=3+4=7 ≤ c*4*2=8c (com c=1.5, 7≤12 ok). Escolhemos c=2.",
                              "finalVerifications": [
                                "Todos os casos base até n0+2 satisfazem T(n) ≤ c f(n).",
                                "c > 0 e é o menor possível ou ligeiramente maior.",
                                "Condições de contorno (ex: lg1=0) foram contornadas escolhendo n0≥2.",
                                "Valores de T(n) calculados corretamente via recorrência.",
                                "Hipótese indutiva explicitamente fortalecida com c e n0.",
                                "Sem divisões por zero ou indefinidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de T(n) e c.",
                                "Cobertura completa de todos casos base relevantes.",
                                "Justificativa clara para escolha de n0 e c.",
                                "Uso correto de desigualdades ≤.",
                                "Margem de segurança no c escolhido.",
                                "Clareza na documentação da prova."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Prova por indução matemática.",
                                "Lógica: Raciocínio dedutivo e verificação de hipóteses.",
                                "Física: Modelagem de sistemas recursivos em simulações.",
                                "Engenharia de Software: Análise de complexidade em design de algoritmos."
                              ],
                              "realWorldApplication": "Em análise de algoritmos como Merge Sort ou Quick Sort, ajustar c garante limites superiores tight na complexidade, essencial para prever performance em aplicações de big data e machine learning."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Prova por Indução - Passo Indutivo",
                        "description": "Assumir a hipótese indutiva para valores menores e provar para n, manipulando desigualdades e tratando funções de piso/teto.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Aplicar hipótese indutiva",
                            "description": "Assumir T(m) ≤ c g(m) para m < n e substituir na recorrência T(n) = a T(floor(n/b)) + f(n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer e declarar a hipótese indutiva claramente",
                                  "subSteps": [
                                    "Relembre a hipótese base: T(m) ≤ c g(m) para todo m < n, onde c > 0 é uma constante.",
                                    "Escreva a recorrência original: T(n) = a T(floor(n/b)) + f(n).",
                                    "Identifique os parâmetros: a, b, f(n), g(n).",
                                    "Declare explicitamente a suposição: Assuma T(floor(n/b)) ≤ c g(floor(n/b)) pela hipótese indutiva.",
                                    "Verifique se floor(n/b) < n, garantindo que a hipótese se aplica."
                                  ],
                                  "verification": "Confirme que a declaração da hipótese menciona todos os elementos chave e que floor(n/b) < n é válido.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas da recorrência",
                                    "Exemplo de prova por indução"
                                  ],
                                  "tips": "Sempre escreva a hipótese verbatim para evitar ambiguidades.",
                                  "learningObjective": "Compreender e articular precisamente a hipótese indutiva no contexto da recursão.",
                                  "commonMistakes": [
                                    "Esquecer de especificar 'para todo m < n'",
                                    "Não verificar floor(n/b) < n",
                                    "Confundir g(m) com f(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Substituir a hipótese indutiva na recorrência",
                                  "subSteps": [
                                    "Substitua T(floor(n/b)) pela desigualdade: T(n) ≤ a c g(floor(n/b)) + f(n).",
                                    "Mantenha a desigualdade ≤ do lado esquerdo.",
                                    "Expresse g(floor(n/b)) em termos de n, usando propriedades como g(n/b) ≈ g(n)/b^k se aplicável.",
                                    "Registre a nova expressão: T(n) ≤ a c g(floor(n/b)) + f(n).",
                                    "Confirme que a substituição preserva a direção da desigualdade."
                                  ],
                                  "verification": "A expressão resultante deve ter exatamente a forma T(n) ≤ a c g(floor(n/b)) + f(n).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora para simplificações",
                                    "Quadro branco ou editor de equações"
                                  ],
                                  "tips": "Use ≈ para aproximações iniciais, mas seja preciso com floor.",
                                  "learningObjective": "Aplicar corretamente a hipótese para transformar a recorrência em desigualdade.",
                                  "commonMistakes": [
                                    "Usar = em vez de ≤",
                                    "Substituir incorretamente o argumento floor(n/b)",
                                    "Inverter o sinal da desigualdade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simplificar a desigualdade para mostrar T(n) ≤ c g(n)",
                                  "subSteps": [
                                    "Compare a c g(floor(n/b)) + f(n) com c g(n).",
                                    "Use bounds para floor(n/b), como n/b - 1 < floor(n/b) ≤ n/b.",
                                    "Aplique condições do método da substituição (ex: f(n) = O(g(n)/n^ε) ou similares).",
                                    "Escolha c grande o suficiente para absorver termos extras: c ≥ a c / b^k + k, resolva para c.",
                                    "Simplifique algebricamente até obter T(n) ≤ c g(n)."
                                  ],
                                  "verification": "A desigualdade final deve ser T(n) ≤ c g(n), com c explícito ou bounds mostrados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de cálculos",
                                    "Tabela de casos do Master Theorem para referência"
                                  ],
                                  "tips": "Teste com n grande para intuição; isole termos para encontrar c mínimo.",
                                  "learningObjective": "Manipular desigualdades recursivas para provar o bound desejado.",
                                  "commonMistakes": [
                                    "Não lidar com floor corretamente",
                                    "Escolher c muito pequeno",
                                    "Ignorar termos aditivos f(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir o passo indutivo e verificar consistência",
                                  "subSteps": [
                                    "Afirme: 'Portanto, pela hipótese indutiva, T(n) ≤ c g(n)'.",
                                    "Verifique se as condições para n suficientemente grande foram satisfeitas.",
                                    "Discuta singularidades ou casos onde n/b não é inteiro.",
                                    "Ligue de volta à hipótese base para completude.",
                                    "Anote qualquer constante c específica encontrada."
                                  ],
                                  "verification": "Conclusão liga explicitamente à forma desejada T(n) ≤ c g(n) para todo n.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Resumo da prova",
                                    "Exemplo resolvido para comparação"
                                  ],
                                  "tips": "Sempre reescreva a conclusão em negrito ou destacado.",
                                  "learningObjective": "Finalizar o raciocínio indutivo de forma rigorosa e convincente.",
                                  "commonMistakes": [
                                    "Pular verificação de c > 0",
                                    "Não mencionar 'para n ≥ n0'",
                                    "Concluir sem simplificação completa"
                                  ]
                                }
                              ],
                              "practicalExample": "Para T(n) = 3 T(floor(n/2)) + n, assuma IH: T(m) ≤ c m log m para m < n. Substitua: T(n) ≤ 3 c (n/2) log(n/2) + n = (3c/2) n (log n -1) + n. Simplifique para ≤ c n log n escolhendo c ≥ 4.",
                              "finalVerifications": [
                                "Hipótese indutiva declarada corretamente com todos os parâmetros.",
                                "Substituição preserva desigualdade ≤.",
                                "Simplificação leva exatamente a T(n) ≤ c g(n).",
                                "Valor de c é positivo e justificado.",
                                "Floor(n/b) < n é implicitamente ou explicitamente verificado.",
                                "Conclusão liga ao passo indutivo completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na declaração da hipótese (20%)",
                                "Correção da substituição recursiva (25%)",
                                "Rigor na simplificação algébrica (25%)",
                                "Escolha e justificativa de constantes (15%)",
                                "Clareza e completude da conclusão (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Prova por indução matemática.",
                                "Lógica: Raciocínio dedutivo e manipulação de desigualdades.",
                                "Física: Modelagem de sistemas recursivos em simulações.",
                                "Engenharia de Software: Análise de complexidade em design de algoritmos."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos como divide-and-conquer (ex: merge sort, FFT), provar bounds de tempo para garantir escalabilidade em big data e machine learning."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Manipular desigualdades no passo indutivo",
                            "description": "Resolver T(n) ≤ a c g(floor(n/b)) + f(n) ≤ c g(n), escolhendo c grande o suficiente para absorver termos extras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar a recorrência, o guess e a hipótese indutiva",
                                  "subSteps": [
                                    "Escreva a recorrência geral: T(n) ≤ a T(floor(n/b)) + f(n).",
                                    "Defina o guess: assuma T(n) = O(g(n)), ou seja, T(k) ≤ c g(k) para k < n, onde c > 0 é constante a escolher.",
                                    "Declare explicitamente a Hipótese Indutiva (IH): Para todo k < n, T(k) ≤ c g(k).",
                                    "Identifique os parâmetros a, b, f(n) e g(n) no contexto específico.",
                                    "Verifique se g é crescente e g(floor(n/b)) pode ser relacionado a g(n)."
                                  ],
                                  "verification": "Confirme que a IH está escrita corretamente e inclui 'para todo k < n'.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplo de recorrência anotado",
                                    "Referência ao teorema master para inspiração de g(n)"
                                  ],
                                  "tips": [
                                    "Escolha g(n) baseado no teorema master ou inspeção.",
                                    "Lembre que c será escolhido grande para absorver extras.",
                                    "Assuma n ≥ n0 onde n0 cobre base cases."
                                  ],
                                  "learningObjective": "Entender o setup da prova por substituição e o papel da constante c.",
                                  "commonMistakes": [
                                    "Esquecer 'floor(n/b)' na recorrência.",
                                    "Não especificar o domínio da IH (k < n).",
                                    "Escolher g(n) muito apertado sem slack."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a IH no passo indutivo e formar a desigualdade inicial",
                                  "subSteps": [
                                    "Substitua o termo recursivo: T(floor(n/b)) ≤ c g(floor(n/b)) pela IH.",
                                    "Escreva: T(n) ≤ a · c · g(floor(n/b)) + f(n).",
                                    "Bound floor(n/b) ≤ n/b para simplificar: g(floor(n/b)) ≤ g(n/b), assumindo g monótona.",
                                    "Anotar a desigualdade: T(n) ≤ a c g(n/b) + f(n).",
                                    "Discuta aproximações para log ou potências se aplicável."
                                  ],
                                  "verification": "A desigualdade T(n) ≤ a c g(floor(n/b)) + f(n) está correta e bounded.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora para bounds",
                                    "Folha com propriedades de g(n)",
                                    "Exemplos de recorrências padrão"
                                  ],
                                  "tips": [
                                    "Use g(n/b) ≤ (1/α) g(n) se g for homogênea, com α >1.",
                                    "Mantenha floor inicialmente para precisão.",
                                    "Copie a IH exatamente."
                                  ],
                                  "learningObjective": "Aplicar corretamente a IH para obter a desigualdade indutiva.",
                                  "commonMistakes": [
                                    "Aplicar IH a T(n) em vez de T(n/b).",
                                    "Esquecer o fator 'a'.",
                                    "Não boundar floor(n/b)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Manipular a desigualdade para isolar termos extras",
                                  "subSteps": [
                                    "Expanda ou bound a c g(n/b) em termos de c g(n), e.g., g(n/b) ≤ k g(n) com k <1.",
                                    "Reescreva: T(n) ≤ c · (a k) g(n) + f(n).",
                                    "Assuma ou prove f(n) ≤ d g(n) para alguma d >0 (condição chave).",
                                    "Forme: T(n) ≤ c (a k) g(n) + d g(n) = [a k c + d] g(n).",
                                    "Compare com c g(n): precisa a k c + d ≤ c, i.e., d ≤ c (1 - a k)."
                                  ],
                                  "verification": "A manipulação algébrica resulta em T(n) ≤ [a k c + d] g(n).",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Papel para álgebra",
                                    "Tabela de bounds para funções comuns (n log n, n^2)",
                                    "Software como Mathematica para verificação simbólica opcional"
                                  ],
                                  "tips": [
                                    "Para g(n)=n^log_b a * polilog, use expansões exatas.",
                                    "Assuma 1 - a k >0 (caso master 1 ou 2).",
                                    "Fatore g(n) sempre."
                                  ],
                                  "learningObjective": "Dominar a manipulação algébrica para absorver f(n) em c g(n).",
                                  "commonMistakes": [
                                    "Erro em bound de g(n/b), e.g., confundir log(n/b).",
                                    "Não fatorar g(n).",
                                    "Ignorar que d depende de n (deve ser constante)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escolher c grande o suficiente e verificar a desigualdade final",
                                  "subSteps": [
                                    "Do rearranjo: c ≥ d / (1 - a k), escolha c máximo sobre base cases.",
                                    "Verifique: a c g(n/b) + f(n) ≤ c g(n) para n ≥ n0.",
                                    "Ajuste c para cobrir casos base (n pequeno, compute diretamente).",
                                    "Confirme que para n ≥ n0, a desigualdade segura estritamente.",
                                    "Conclua a indução: IH + passo indutivo ⇒ T(n) ≤ c g(n)."
                                  ],
                                  "verification": "Calcule c explícito e teste em 2-3 valores de n.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Valores numéricos para teste",
                                    "Planilha para base cases",
                                    "Referência de prova completa"
                                  ],
                                  "tips": [
                                    "Escolha c = 2 * max necessário para segurança.",
                                    "Teste numericamente para n= b^2, b^3.",
                                    "Mencione 'para n suficientemente grande'."
                                  ],
                                  "learningObjective": "Selecionar e justificar o valor de c para completar a prova.",
                                  "commonMistakes": [
                                    "Escolher c muito pequeno (não absorve).",
                                    "Esquecer base cases.",
                                    "Não verificar 1 - a k >0."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere T(n) ≤ 2 T(n/2) + n, provando T(n) ≤ c n lg n (lg=log2). Passo indutivo: T(n) ≤ 2 c (n/2) lg(n/2) + n = c n (lg n - 1) + n = c n lg n - c n + n. Para ≤ c n lg n, precisa n(1 - c) ≤ 0, i.e., c ≥ 1. Escolha c=2 (para base cases como T(1)=1, T(2)=2 lg2 +2≈4 <4 lg4=8). Funciona para n≥2.",
                              "finalVerifications": [
                                "Escreve corretamente T(n) ≤ a c g(floor(n/b)) + f(n).",
                                "Bounds g(floor(n/b)) ≤ k g(n) com k explícito.",
                                "Identifica e absorve f(n) ≤ d g(n).",
                                "Calcula c ≥ d / (1 - a k) corretamente.",
                                "Verifica numericamente para 3 valores de n.",
                                "Explica ajuste para base cases."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação da IH (20%)",
                                "Correção na manipulação algébrica e bounds (30%)",
                                "Escolha e justificativa de c (20%)",
                                "Tratamento de floor e assintóticas (15%)",
                                "Verificação completa incluindo base (10%)",
                                "Clareza e estrutura da prova (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução matemática.",
                                "Matemática: Análise assintótica e limites.",
                                "Engenharia de Computação: Análise de algoritmos divide-and-conquer.",
                                "Física Computacional: Modelagem recursiva de sistemas dinâmicos.",
                                "Economia: Otimização recursiva em modelos de decisão."
                              ],
                              "realWorldApplication": "Usado para provar complexidade O(n log n) do Merge Sort, essencial em bancos de dados (ex: ordenação em SQL), machine learning (árvores de decisão), e processamento de grafos em redes sociais, garantindo eficiência escalável em aplicações de big data."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Tratar funções de piso e teto",
                            "description": "Usar propriedades como floor(n/b) ≤ n/b para preservar desigualdades em provas rigorosas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Definições e Propriedades Básicas de Floor e Ceiling",
                                  "subSteps": [
                                    "Defina floor(x) como o maior inteiro ≤ x e ceiling(x) como o menor inteiro ≥ x.",
                                    "Estude exemplos: floor(3.7) = 3, ceiling(3.7) = 4; floor(-1.2) = -2, ceiling(-1.2) = -1.",
                                    "Memorize desigualdades fundamentais: floor(x) ≤ x ≤ ceiling(x) e floor(x) = n onde n ≤ x < n+1.",
                                    "Pratique com frações: floor(n/b) para n inteiro, b > 1 inteiro.",
                                    "Explore floor(n/b) + floor((n mod b)/b) = floor(n/b)."
                                  ],
                                  "verification": "Resolva 5 exercícios de cálculo de floor/ceiling e liste 3 propriedades com exemplos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora, papel e lápis, tabela de exemplos de floor/ceiling.",
                                  "tips": "Sempre visualize no eixo numérico para intuição.",
                                  "learningObjective": "Dominar definições e desigualdades básicas para manipulação em provas.",
                                  "commonMistakes": "Confundir floor com ceiling em números negativos; ignorar que floor(x) é inteiro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Propriedades para Preservar Desigualdades em Recorrências",
                                  "subSteps": [
                                    "Aprenda floor(n/b) ≤ n/b ≤ floor(n/b) + 1 - 1/b.",
                                    "Estude n/b - 1 < floor(n/b) ≤ n/b.",
                                    "Aplique em recorrências: para T(n) ≤ a T(floor(n/b)) + f(n), assuma IH T(m) ≤ c m log m para m < n.",
                                    "Pratique bounding: floor(n/b) ≤ n/b implica T(n) ≤ a c (n/b) log(n/b) + f(n).",
                                    "Verifique monotonicidade: floor é não-decrescente."
                                  ],
                                  "verification": "Derive 3 desigualdades como floor(n/b) ≤ n/b a partir de definições.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise de algoritmos (CLRS cap. 4), editor de texto para anotações.",
                                  "tips": "Use substituição direta: multiplique desigualdades por constantes positivas.",
                                  "learningObjective": "Usar propriedades para manter desigualdades na hipótese indutiva.",
                                  "commonMistakes": "Esquecer de ajustar logs: log(floor(n/b)) ≈ log(n/b); inverter limites inferiores/superiores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar em Provas por Indução no Método da Substituição",
                                  "subSteps": [
                                    "Estruture prova: base, IH: T(k) ≤ c k log k para k < n, passo: T(n) ≤ a T(floor(n/b)) + f(n).",
                                    "Substitua IH: ≤ a c floor(n/b) log(floor(n/b)) + f(n) ≤ a c (n/b) log(n/b) + f(n).",
                                    "Simplifique para ≤ c n log n, resolvendo para c grande o suficiente.",
                                    "Trate resíduos: use floor(n/b) + floor((n%b)/b) bounds.",
                                    "Teste com b=2, a=2 para merge sort."
                                  ],
                                  "verification": "Escreva prova completa para T(n) = 2 T(floor(n/2)) + n ≤ c n log n.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "CLRS ou notas de aula, software como LaTeX para formalizar prova.",
                                  "tips": "Assuma n ≥ b^k para base; ignore floor inicialmente e adicione depois.",
                                  "learningObjective": "Aplicar floor/ceiling no passo indutivo sem quebrar desigualdades.",
                                  "commonMistakes": "Não bounding log(floor(n/b)) ≤ log(n/b); c não cobrindo casos base."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Refinar com Exemplos Complexos",
                                  "subSteps": [
                                    "Resolva recorrência T(n) = 3 T(ceiling(n/2)) + n.",
                                    "Compare proofs com/sem floor: mostre impacto em tight bounds.",
                                    "Gere contraexemplos onde ignorar floor falha.",
                                    "Otimize c minimizando slack nas desigualdades.",
                                    "Discuta generalizações para b não-potência de 2."
                                  ],
                                  "verification": "Complete 2 provas independentes e peer-review com soluções modelo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exercícios de Cormen, Python para simular recorrências.",
                                  "tips": "Use inequality chaining: floor ≤ ... ≤ target.",
                                  "learningObjective": "Refinar provas para rigor e eficiência computacional.",
                                  "commonMistakes": "Overbounding desnecessariamente, perdendo tight ness; erros aritméticos em logs."
                                }
                              ],
                              "practicalExample": "Na prova de merge sort: T(n) = 2 T(floor(n/2)) + Θ(n). Pelo IH, T(floor(n/2)) ≤ c floor(n/2) lg floor(n/2) ≤ c (n/2) lg(n/2). Então T(n) ≤ 2 c (n/2) lg(n/2) + d n = c n lg(n/2) + d n = c n (lg n -1) + d n ≤ c n lg n se c ≥ d / (lg n - lg(n/2) +1), ajustado para base.",
                              "finalVerifications": [
                                "Desigualdades preservadas em todos passos indutivos.",
                                "Casos base verificados para n pequeno.",
                                "Constantes c positivas finitas cobrem recorrência.",
                                "Floor/ceiling não violam monotonicidade.",
                                "Limite assintótico matches simulações numéricas.",
                                "Prova funciona para n não-potência de b."
                              ],
                              "assessmentCriteria": [
                                "Precisão na manipulação de floor(n/b) ≤ n/b (100%).",
                                "Rigor indutivo completo com IH aplicação (90%).",
                                "Eficiência na escolha de bounds (80%).",
                                "Clareza na derivação de logs e resíduos (85%).",
                                "Tratamento de edge cases como n < b (95%).",
                                "Generalização para ceiling se aplicável (bonus)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Indução e funções piso/teto em teoria dos números.",
                                "Análise Numérica: Erros de arredondamento em computação flutuante.",
                                "Matemática Pura: Desigualdades em análise real.",
                                "Engenharia de Software: Análise de performance em implementações reais."
                              ],
                              "realWorldApplication": "Em otimizadores de compiladores e análise de quicksort/mediasort, onde divisões não-exatas (floor(n/2)) afetam contagens de operações, garantindo bounds O(n log n) precisos para previsão de runtime em hardware real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Método da Árvore de Recorrência",
                    "description": "Análise visual da expansão recursiva para calcular custos totais por níveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Construção da Árvore de Recorrência",
                        "description": "Processo de representação visual das chamadas recursivas de um algoritmo de divide-and-conquer, iniciando pela raiz e expandindo subchamadas até as folhas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar o formato padrão de recorrência",
                            "description": "Reconhecer equações de recorrência do tipo T(n) = a T(n/b) + f(n), onde a é o número de subproblemas, b é o fator de divisão e f(n) é o custo do trabalho fora das recursões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes fundamentais da equação de recorrência padrão",
                                  "subSteps": [
                                    "Revise a estrutura geral: T(n) = a T(n/b) + f(n)",
                                    "Identifique T(n) como o tempo total para tamanho n",
                                    "Entenda a como o número de subproblemas recursivos",
                                    "Defina b como o fator pelo qual o problema é dividido",
                                    "Explique f(n) como o custo adicional fora das chamadas recursivas"
                                  ],
                                  "verification": "Escreva uma definição resumida de cada componente em suas próprias palavras",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto; quadro branco opcional",
                                  "tips": "Use analogias como dividir uma pizza: a fatias, b tamanho de cada fatia, f(n) tempo de corte",
                                  "learningObjective": "Memorizar e diferenciar os três componentes principais da forma padrão",
                                  "commonMistakes": "Confundir a com b ou ignorar que f(n) pode ser O(1), O(n), etc."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o número de subproblemas 'a'",
                                  "subSteps": [
                                    "Localize o termo recursivo: quantas vezes T(·) aparece à direita",
                                    "Conte o coeficiente multiplicativo antes de T(n/b)",
                                    "Verifique se 'a' é uma constante inteira positiva (ex: 1, 2, 4)",
                                    "Compare com exemplos: Merge Sort tem a=2",
                                    "Anote o valor de 'a' e justifique com base na recursão"
                                  ],
                                  "verification": "Marque o termo de 'a T(n/b)' na equação e explique por quê",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Exemplos de equações impressas ou digitais",
                                  "tips": "Pense em 'a' como 'quantos ramos saem do nó raiz na árvore de recorrência'",
                                  "learningObjective": "Reconhecer precisamente o coeficiente 'a' em qualquer equação dada",
                                  "commonMistakes": "Contar T(n) como subproblema ou confundir com expoentes"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar o fator de divisão 'b'",
                                  "subSteps": [
                                    "Examine o argumento de T: n/b indica divisão por b",
                                    "Identifique b como constante >1 (ex: 2 para metade, 10 para dízima)",
                                    "Confirme que n/b reduz o tamanho do problema",
                                    "Exemplos: Binary search b=2, Radix sort b=10",
                                    "Registre b e verifique se é inteiro ou potência"
                                  ],
                                  "verification": "Substitua valores numéricos em n/b e veja se faz sentido",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Lista de algoritmos comuns com suas recorrências",
                                  "tips": "'b' é o 'divisor' que equilibra a árvore; maior b significa menos níveis",
                                  "learningObjective": "Isolar e validar o fator de redução de tamanho 'b'",
                                  "commonMistakes": "Confundir b com log_b ou usar frações não-constantes"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Isolar e classificar f(n), o custo não-recursivo",
                                  "subSteps": [
                                    "Subtraia os termos recursivos: o restante é f(n)",
                                    "Classifique f(n): O(1), O(n), O(n log n), etc.",
                                    "Ignore constantes ou polinômios menores para notação assintótica",
                                    "Exemplos: Merge Sort f(n)=O(n), Fibonacci f(n)=O(1)",
                                    "Escreva f(n) em notação big-O"
                                  ],
                                  "verification": "Reescreva a equação destacando apenas f(n) e confirme independência de T",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de complexidades assintóticas",
                                  "tips": "f(n) é o 'trabalho na borda' da recursão, não dentro dela",
                                  "learningObjective": "Diferenciar precisamente o trabalho base de f(n)",
                                  "commonMistakes": "Incluir recursões em f(n) ou ignorar termos dominantes"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar se a equação segue o formato padrão",
                                  "subSteps": [
                                    "Confirme: exatamente uma instância de a T(n/b), mais f(n)",
                                    "Verifique se a ≥1, b >1 constantes, f(n) função de n",
                                    "Teste com n=1: T(1) deve ser constante (caso base implícito)",
                                    "Compare com contraexemplos: T(n)=T(n-1)+1 não é padrão",
                                    "Documente todos os componentes extraídos"
                                  ],
                                  "verification": "Crie uma tabela resumindo a, b, f(n) e declare 'padrão' ou 'não'",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Equações de teste variadas",
                                  "tips": "Formato padrão é para Master Theorem; desvios precisam de análise customizada",
                                  "learningObjective": "Aplicar critérios completos para confirmação do formato",
                                  "commonMistakes": "Aceitar variações como T(n)=a T(n/b)+f(n)+g(n) como padrão"
                                }
                              ],
                              "practicalExample": "Para Merge Sort: T(n) = 2 T(n/2) + cn. Aqui, a=2 (dois subarrays), b=2 (divide ao meio), f(n)=cn (merge linear). Construa a árvore: raiz custa cn, dois filhos n/2 cada, etc.",
                              "finalVerifications": [
                                "Extrair corretamente a, b e f(n) de 5 equações dadas",
                                "Explicar o papel de cada componente na árvore de recorrência",
                                "Identificar se uma equação NÃO segue o formato e por quê",
                                "Classificar f(n) em O-notation corretamente",
                                "Aplicar a 2 algoritmos reais como QuickSort ou Strassen",
                                "Desenhar esboço rápido da árvore para validação"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de a (100% correto em testes)",
                                "Correta extração de b e verificação de >1",
                                "Classificação assintótica precisa de f(n)",
                                "Justificativa clara para cada componente",
                                "Detecção consistente de não-padrão",
                                "Uso correto de terminologia técnica"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações lineares e recorrentes; logaritmos para níveis da árvore",
                                "Álgebra: Manipulação de expressões com variáveis n",
                                "Lógica e Programação: Reconhecimento de padrões em código recursivo",
                                "Física: Modelos de decaimento exponencial similares a divisões recursivas"
                              ],
                              "realWorldApplication": "Em otimização de algoritmos como busca binária (T(n)=T(n/2)+O(1), a=1,b=2,f(n)=O(1)) ou processamento de imagens com divide-and-conquer, permitindo uso do Master Theorem para prever tempo de execução em grandes datasets, essencial para Big Data e IA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Desenhar o nó raiz da árvore",
                            "description": "Representar o nível raiz com um único nó contendo o custo f(n) e a T(n), expandindo para a subchamadas de T(n/b).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes da relação de recorrência",
                                  "subSteps": [
                                    "Leia a relação de recorrência dada, como T(n) = a T(n/b) + f(n).",
                                    "Identifique f(n) como o custo não-recursivo no nível raiz.",
                                    "Note 'a' como o número de subchamadas e 'n/b' como o tamanho do subproblema.",
                                    "Registre T(n/b) como as chamadas recursivas.",
                                    "Anote os valores específicos de a, b e f(n) para o exemplo."
                                  ],
                                  "verification": "Lista escrita com f(n), a, b e T(n/b) corretamente identificados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, lápis, relação de recorrência impressa ou anotada.",
                                  "tips": "Sempre destaque f(n) como o trabalho fora das chamadas recursivas.",
                                  "learningObjective": "Compreender a estrutura básica da relação de recorrência T(n) = a T(n/b) + f(n).",
                                  "commonMistakes": "Confundir f(n) com o custo total T(n); ignorar o fator 'a'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar o nó raiz e adicionar o custo f(n)",
                                  "subSteps": [
                                    "Desenhe um círculo ou caixa central no topo da página para representar o nó raiz.",
                                    "Rotule o nó com 'T(n)' para indicar o problema original.",
                                    "Escreva 'f(n)' dentro ou ao lado do nó, indicando o custo não-recursivo.",
                                    "Use notação assintótica como Θ(n) ou O(n) se aplicável.",
                                    "Adicione uma borda destacada para enfatizar que é o nível raiz."
                                  ],
                                  "verification": "Nó raiz desenhado com T(n) e f(n) claramente rotulados.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Papel quadriculado, canetas coloridas para destaque.",
                                  "tips": "Use cores diferentes: azul para nós, vermelho para custos.",
                                  "learningObjective": "Representar visualmente o custo inicial do algoritmo recursivo.",
                                  "commonMistakes": "Esquecer de rotular T(n); colocar f(n) fora do nó."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar as subchamadas recursivas T(n/b)",
                                  "subSteps": [
                                    "Desenhe 'a' setas saindo do nó raiz para baixo.",
                                    "Em cada ponta de seta, desenhe um novo nó rotulado 'T(n/b)'.",
                                    "Se a=2, desenhe duas setas; generalize para outros valores.",
                                    "Conecte as setas diretamente do centro do nó raiz.",
                                    "Adicione labels nas setas como 'a chamadas' para clareza."
                                  ],
                                  "verification": "'a' nós T(n/b) conectados corretamente por setas do nó raiz.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Régua para setas retas, papel quadriculado.",
                                  "tips": "Mantenha setas simétricas para equilíbrio visual.",
                                  "learningObjective": "Visualizar a ramificação recursiva a partir do nível raiz.",
                                  "commonMistakes": "Número errado de setas; rotular incorretamente como T(n) em vez de T(n/b)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar e verificar a estrutura do nó raiz",
                                  "subSteps": [
                                    "Adicione uma legenda explicando símbolos: f(n), T(n/b), etc.",
                                    "Verifique se o nó raiz está centralizado e proeminente.",
                                    "Trace o caminho da recursão: raiz → subchamadas.",
                                    "Teste com um exemplo numérico pequeno, como n=8.",
                                    "Ajuste espaçamento para expansão futura da árvore."
                                  ],
                                  "verification": "Diagrama completo com legenda e sem erros de rotulagem.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Borracha para correções, legenda em post-it.",
                                  "tips": "Deixe espaço abaixo para níveis subsequentes da árvore.",
                                  "learningObjective": "Garantir precisão e clareza na representação do nó raiz.",
                                  "commonMistakes": "Falta de legenda; desalinhamento visual."
                                }
                              ],
                              "practicalExample": "Para Merge Sort: T(n) = 2 T(n/2) + Θ(n). Nó raiz: círculo com 'T(n)' e 'Θ(n)' dentro, duas setas para nós 'T(n/2)'.",
                              "finalVerifications": [
                                "Nó raiz contém T(n) e f(n) corretamente rotulados.",
                                "Exatamente 'a' subchamadas T(n/b) conectadas por setas.",
                                "Notação assintótica usada consistentemente.",
                                "Diagrama é legível e bem espaçado.",
                                "Legenda explica todos os elementos.",
                                "Estrutura permite expansão para níveis inferiores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de f(n) e T(n/b) (30%).",
                                "Correta representação visual com nós e conexões (30%).",
                                "Clareza e legibilidade do diagrama (20%).",
                                "Uso apropriado de labels e legendas (10%).",
                                "Ausência de erros comuns como contagem errada de subchamadas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de árvores genealógicas ou divisões fracionárias (n/b).",
                                "Visualização de Dados: Criação de diagramas hierárquicos como em D3.js.",
                                "Física: Modelagem de decaimento exponencial em ramificações.",
                                "Engenharia de Software: Diagramação de chamadas de funções recursivas."
                              ],
                              "realWorldApplication": "Em análise de algoritmos como QuickSort ou FFT, o nó raiz da árvore de recorrência ajuda engenheiros de software a estimar tempo de execução e otimizar código recursivo em aplicações de big data."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Expandir níveis recursivos da árvore",
                            "description": "Continuar a expansão da árvore desenhando subchamadas sucessivas até atingir o caso base T(1) = Θ(1), ilustrando a estrutura completa da recursão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Desenhar o Nó Raiz da Árvore de Recorrência",
                                  "subSteps": [
                                    "Revise a equação de recorrência, identificando o número de subchamadas recursivas (a), o tamanho de cada subproblema (b) e o custo não-recursivo f(n).",
                                    "Desenhe o nó raiz representando T(n), anotando f(n) como custo nesse nó.",
                                    "Indique as setas para as subchamadas recursivas saindo do nó raiz (ex: a setas para T(n/b)).",
                                    "Confirme que o nó raiz reflete corretamente a chamada inicial T(n)."
                                  ],
                                  "verification": "O nó raiz possui o custo f(n) anotado corretamente e aponta exatamente para o número correto de subchamadas T(n/b).",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de desenho (ex: Draw.io, Lucidchart)",
                                    "Equação de recorrência anotada",
                                    "Lápis e borracha"
                                  ],
                                  "tips": [
                                    "Use símbolos claros para T(n) e f(n) para evitar confusão visual.",
                                    "Mantenha a árvore horizontal para facilitar expansões laterais."
                                  ],
                                  "learningObjective": "Compreender a representação gráfica da chamada recursiva inicial e seus componentes.",
                                  "commonMistakes": [
                                    "Confundir f(n) com o custo total T(n).",
                                    "Desenhar subchamadas com tamanho incorreto (ex: T(n/2) em vez de T(n/b))."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir o Primeiro Nível Recursivo",
                                  "subSteps": [
                                    "Para cada subchamada T(n/b) do nível raiz, desenhe nós filhos com custo f(n/b).",
                                    "Adicione setas das subchamadas pai para esses novos nós.",
                                    "Anote o tamanho do problema reduzido em cada novo nó (T(n/b)).",
                                    "Verifique se o número de nós neste nível é a * número de nós pai (ex: 2 para a=2)."
                                  ],
                                  "verification": "Todos os nós do primeiro nível têm custo f(n/b) correto e estrutura idêntica às subchamadas da raiz.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Exemplo resolvido de árvore para referência (ex: T(n)=2T(n/2)+n)"
                                  ],
                                  "tips": [
                                    "Expanda um ramo por vez para manter a organização.",
                                    "Use cores alternadas para níveis para visualizar profundidade."
                                  ],
                                  "learningObjective": "Visualizar a ramificação inicial da recursão e o custo em subproblemas.",
                                  "commonMistakes": [
                                    "Esquecer de reduzir f(n) para f(n/b) nos nós filhos.",
                                    "Criar número incorreto de nós filhos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir Níveis Recursivos Sucessivos até Aproximar o Caso Base",
                                  "subSteps": [
                                    "Repita o processo de expansão para cada nó do nível anterior, desenhando T(n/b^k) para k=2,3,...",
                                    "Continue até que n/b^k ≈ 1 ou atinja um tamanho pequeno (ex: n=4 para b=2).",
                                    "Monitore a profundidade: log_b(n) níveis aproximadamente.",
                                    "Anote custos f(n/b^k) em cada nó sucessivo."
                                  ],
                                  "verification": "A árvore mostra ramificações consistentes em todos os níveis, com tamanhos de problema diminuindo corretamente até próximo de 1.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Mesmos anteriores",
                                    "Calculadora para log_b(n)"
                                  ],
                                  "tips": [
                                    "Desenhe em camadas para evitar sobreposição; use zoom out se digital.",
                                    "Pare quando todos os caminhos tiverem ~log_b(n) níveis."
                                  ],
                                  "learningObjective": "Dominar a expansão iterativa, ilustrando a estrutura exponencial da recursão.",
                                  "commonMistakes": [
                                    "Parar prematuramente antes de uniformidade nos tamanhos.",
                                    "Erros aritméticos em n/b^k."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar com Casos Base e Anotar Custos Totais",
                                  "subSteps": [
                                    "Substitua todos os nós T(1) ou T(base) pelo custo Θ(1).",
                                    "Some os custos f(.) em cada nível horizontal da árvore.",
                                    "Some os totais por nível e verifique convergência para o caso base.",
                                    "Rotule a altura da árvore como log_b(n)."
                                  ],
                                  "verification": "Todos os folhas são T(1)=Θ(1), e custos por nível estão somados corretamente sem erros de contagem.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Mesmos anteriores",
                                    "Folha de cálculo para somas (opcional, ex: Excel)"
                                  ],
                                  "tips": [
                                    "Conte nós por nível para validar: nível k tem a^k nós.",
                                    "Destaque folhas em verde para clareza."
                                  ],
                                  "learningObjective": "Finalizar a árvore completa, conectando à solução da recorrência.",
                                  "commonMistakes": [
                                    "Não substituir recursões residuais por Θ(1).",
                                    "Somar custos verticais em vez de por nível."
                                  ]
                                }
                              ],
                              "practicalExample": "Para T(n) = 2T(n/2) + n (Merge Sort): Raiz T(n) custo n → 2 nós T(n/2) custo n/2 cada → 4 nós T(n/4) custo n/4 → ... até  n nós T(1)=1. Nível 0: n; Nível 1: 2*(n/2)=n; ... Total ~ n log n.",
                              "finalVerifications": [
                                "A árvore atinge T(1)=Θ(1) em todas as folhas.",
                                "Número de nós por nível segue a^k corretamente.",
                                "Custos f(n/b^k) diminuem apropriadamente em cada nível.",
                                "Altura da árvore é log_b(n).",
                                "Somas por nível são consistentes e iguais onde f(n) domina.",
                                "Nenhuma subchamada excede o tamanho esperado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão recursiva (100% dos nós corretos).",
                                "Correção dos custos f(.) em todos os nós (sem erros aritméticos).",
                                "Completude até base case em todos os ramos.",
                                "Clareza visual da árvore (rótulos legíveis, estrutura organizada).",
                                "Validação das somas por nível.",
                                "Compreensão demonstrada via anotação da altura log_b(n)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expansões de séries geométricas e somas de níveis (a^k * f(n/b^k)).",
                                "Engenharia de Software: Decomposição hierárquica em design de algoritmos divide-and-conquer.",
                                "Física/Matemática: Modelagem de processos ramificados como fratais ou bifurcações.",
                                "Estatística: Análise de complexidade em árvores de decisão para ML."
                              ],
                              "realWorldApplication": "Analisar eficiência de algoritmos reais como Merge Sort ou FFT (Fast Fourier Transform), provando O(n log n) para otimização em big data processing, machine learning e processamento de sinais em indústrias como tech e telecom."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Cálculo de Custos por Nível",
                        "description": "Determinação do custo computacional total em cada nível da árvore, considerando o número de nós e o custo por nó.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Calcular o número de nós por nível",
                            "description": "Determinar que no nível k há a^k nós, cada um resolvendo um subproblema de tamanho n/b^k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a relação de recorrência e estrutura da árvore raiz",
                                  "subSteps": [
                                    "Identifique a forma padrão da recorrência: T(n) = a T(n/b) + f(n), onde a é o número de subproblemas e b é o fator de divisão.",
                                    "Desenhe o nó raiz representando o problema de tamanho n com custo f(n).",
                                    "Note que da raiz saem 'a' ramificações, cada uma para um subproblema de tamanho n/b.",
                                    "Confirme que a árvore é completa e balanceada, assumindo divisão uniforme.",
                                    "Registre os parâmetros a e b para o exemplo específico."
                                  ],
                                  "verification": "Verifique se o diagrama da raiz mostra corretamente 'a' filhos e custo f(n) no nó raiz.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e lápis ou software de desenho como Draw.io; referência à relação de recorrência.",
                                  "tips": "Sempre comece pela raiz para ancorar a visualização da árvore.",
                                  "learningObjective": "Compreender a base da árvore de recorrência e seus parâmetros fundamentais.",
                                  "commonMistakes": "Confundir a com b ou ignorar que f(n) é o custo não-recursivo por nó."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e contar nós nos primeiros níveis (0 e 1)",
                                  "subSteps": [
                                    "Nível 0 (raiz): 1 nó, problema de tamanho n.",
                                    "Nível 1: a nós, cada um com subproblema de tamanho n/b.",
                                    "Desenhe explicitamente o nível 1 ramificando da raiz.",
                                    "Calcule o número total de nós até nível 1: 1 + a.",
                                    "Anote o tamanho do problema em cada nó do nível 1."
                                  ],
                                  "verification": "Confirme que nível 1 tem exatamente 'a' nós e cada um resolve n/b.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado para desenhar a árvore; calculadora para valores numéricos.",
                                  "tips": "Use cores diferentes para níveis para facilitar a visualização.",
                                  "learningObjective": "Visualizar e quantificar a expansão inicial da árvore.",
                                  "commonMistakes": "Contar incorretamente os nós do nível 1 como a^1 em vez de a."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalizar o padrão para o nível k",
                                  "subSteps": [
                                    "Observe o padrão: cada nó gera 'a' filhos, então nível k tem a^k nós.",
                                    "Raciocine por indução: assuma verdadeiro para k-1, prove para k.",
                                    "Calcule o tamanho do subproblema no nível k: (n/b)^k = n / b^k.",
                                    "Desenhe ou liste até nível 2 ou 3 para validar o padrão.",
                                    "Escreva a fórmula geral: Número de nós no nível k = a^k."
                                  ],
                                  "verification": "Teste a fórmula para k=0 (1= a^0), k=1 (a), k=2 (a^2).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de exercícios com recorrências exemplo; tabela para anotar contagens por nível.",
                                  "tips": "Pense em termos de multiplicação geométrica: cada nível multiplica por a.",
                                  "learningObjective": "Derivar matematicamente o número de nós por nível usando padrões exponenciais.",
                                  "commonMistakes": "Escrever a_k em vez de a^k ou confundir com soma cumulativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar com exemplo prático e preparar para custos totais",
                                  "subSteps": [
                                    "Aplique a MergeSort: a=2, b=2, nível k: 2^k nós de tamanho n/2^k.",
                                    "Calcule para n=8, k=0 a 3: níveis 1,2,4,8 nós.",
                                    "Some nós totais até folha para validar.",
                                    "Discuta implicações para custo total por nível: a^k * f(n/b^k).",
                                    "Registre a fórmula completa para uso posterior."
                                  ],
                                  "verification": "A fórmula produz contagens corretas no exemplo e bate com desenho da árvore.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplo impresso de MergeSort; simulador online de árvores de recorrência se disponível.",
                                  "tips": "Use potências de 2 para n para simplificar cálculos manuais.",
                                  "learningObjective": "Aplicar e validar a fórmula em um caso real de algoritmo.",
                                  "commonMistakes": "Ignorar que folhas estão no nível log_b n, não infinito."
                                }
                              ],
                              "practicalExample": "Para MergeSort (T(n) = 2 T(n/2) + n): No nível k, há 2^k nós, cada resolvendo um subproblema de tamanho n/2^k. Para n=16, nível 2: 4 nós de tamanho 4 cada.",
                              "finalVerifications": [
                                "Fórmula a^k produz contagens corretas para k=0,1,2 em exemplo dado.",
                                "Tamanho do subproblema é precisamente n/b^k em todos os nós do nível k.",
                                "Diagrama da árvore até nível 3 está completo e balanceado.",
                                "Padrão é generalizável por indução para qualquer k.",
                                "Custo por nível pode ser calculado como a^k * f(n/b^k).",
                                "Nenhum erro em potências ou divisões fracionárias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula a^k (obrigatório).",
                                "Correta identificação do tamanho n/b^k por nó (essencial).",
                                "Uso de indução ou padrão claro na generalização.",
                                "Validação com pelo menos um exemplo numérico completo.",
                                "Diagrama visual claro e rotulado.",
                                "Explicação verbal fluida do raciocínio."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências geométricas e exponenciação (a^k).",
                                "Estruturas de Dados: Árvores binárias/ramificadas e contagem de nós.",
                                "Matemática Discreta: Indução matemática para prova de padrões.",
                                "Física: Modelos de ramificação em processos naturais (ex: crescimento populacional)."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos como QuickSort ou FFT, calcular nós por nível ajuda a prever tempo de execução e memória, essencial para escalabilidade em big data e machine learning."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Computar custo por nó em um nível",
                            "description": "Calcular o custo f(n/b^k) associado a cada nó no nível k da árvore de recorrência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o tamanho do subproblema em um nó do nível k",
                                  "subSteps": [
                                    "Revise a recorrência T(n) = a T(n/b) + f(n), onde o nível 0 é a raiz com tamanho n",
                                    "Note que cada transição para o próximo nível divide o tamanho por b",
                                    "Calcule o tamanho no nível k: size_k = n / b^k",
                                    "Confirme que isso se aplica a cada um dos nós no nível k",
                                    "Anote a fórmula size_k para referência"
                                  ],
                                  "verification": "Escreva e valide size_k = n / b^k para um exemplo dado, como n=16, b=2, k=2 → size=4",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de recorrência escrito"
                                  ],
                                  "tips": "Sempre comece do nível 0 para evitar confusão com indexação",
                                  "learningObjective": "Compreender como o tamanho do problema diminui exponencialmente nos níveis da árvore",
                                  "commonMistakes": [
                                    "Confundir divisão por b^k com multiplicação",
                                    "Usar k=1 como raiz",
                                    "Ignorar que é por nó, não total"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Substituir o tamanho do subproblema na função de custo f",
                                  "subSteps": [
                                    "Identifique a função de custo não-recursiva f do problema no nível raiz",
                                    "Substitua o argumento de f pelo size_k: custo_por_no = f(n / b^k)",
                                    "Escreva a expressão explicitamente, mantendo f intacta inicialmente",
                                    "Verifique se f é polinomial ou outra forma comum (ex: n^2, n log n)",
                                    "Registre a expressão custo_por_no para o próximo passo"
                                  ],
                                  "verification": "Confirme que a substituição resulta em f(n / b^k) sem alterar a forma de f",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Fórmula da recorrência"
                                  ],
                                  "tips": "Trate f como uma função black-box inicialmente para focar na substituição",
                                  "learningObjective": "Aplicar corretamente a função de custo ao tamanho reduzido do subproblema",
                                  "commonMistakes": [
                                    "Substituir errado o expoente (ex: b^k no denominador incorreto)",
                                    "Confundir f com o termo recursivo a T",
                                    "Aplicar f ao total do nível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simplificar a expressão do custo por nó",
                                  "subSteps": [
                                    "Expanda f(n / b^k) com base na forma de f (ex: se f(n)=n^2, então (n/b^k)^2 = n^2 / b^{2k})",
                                    "Aplique propriedades algébricas: potências, logaritmos se aplicável",
                                    "Generalize para formas comuns: f(n)=n^d → n^d / b^{d k}",
                                    "Teste com valores numéricos pequenos para validar a simplificação",
                                    "Escreva a forma final simplificada do custo por nó"
                                  ],
                                  "verification": "A expressão simplificada deve coincidir com cálculo numérico (ex: n=8, b=2, k=1, f(n)=n → 4)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para álgebra"
                                  ],
                                  "tips": "Fatore n^d / b^{d k} para padrões como Θ(n^d / b^{d k})",
                                  "learningObjective": "Dominar a simplificação algébrica de custos em termos de n, b e k",
                                  "commonMistakes": [
                                    "Erro em expoentes cruzados (d * k)",
                                    "Esquecer parênteses em (n/b^k)^d",
                                    "Simplificar prematuramente sem generalizar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar o custo por nó com um exemplo prático",
                                  "subSteps": [
                                    "Escolha uma recorrência exemplo: T(n)=2 T(n/2) + n",
                                    "Calcule para k específico (ex: k=2, n=16, b=2 → size=4, f(4)=4)",
                                    "Compare com desenho da árvore para confirmar por nó",
                                    "Repita para outro k ou f diferente para reforçar",
                                    "Documente o resultado e insights"
                                  ],
                                  "verification": "O custo calculado bate com o custo anotado manualmente na árvore desenhada",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para desenhar árvore",
                                    "Exemplo de recorrência"
                                  ],
                                  "tips": "Desenhe a árvore primeiro para visualização intuitiva",
                                  "learningObjective": "Validar teoricamente o cálculo através de exemplos concretos",
                                  "commonMistakes": [
                                    "Calcular custo total do nível em vez de por nó",
                                    "Usar a em vez de f",
                                    "Erro aritmético em números"
                                  ]
                                }
                              ],
                              "practicalExample": "Na recorrência T(n) = 3 T(n/2) + n^2 (ex: análise de um algoritmo divide-and-conquer como Strassen para multiplicação de matrizes), no nível k=1, cada um dos 3 nós tem tamanho n/2, custo por nó f(n/2) = (n/2)^2 = n^2 / 4. Isso é calculado substituindo diretamente e simplificando.",
                              "finalVerifications": [
                                "Pode derivar size_k = n / b^k corretamente para qualquer k",
                                "Substitui f(size_k) sem erros de notação",
                                "Simplifica f(n/b^k) para formas polinomiais comuns",
                                "Valida com exemplo numérico e árvore desenhada",
                                "Distingue custo por nó do custo total do nível",
                                "Generaliza para diferentes f(n)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula size_k (100% correto)",
                                "Correta substituição e simplificação algébrica (sem erros de expoentes)",
                                "Validação numérica consistente com teoria",
                                "Clareza na explicação escrita ou verbal",
                                "Identificação correta de erros comuns evitados",
                                "Generalização para recorrências variadas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de expoentes e funções polinomiais",
                                "Álgebra: Simplificação de expressões com variáveis n, b, k",
                                "Física: Modelagem de decaimento exponencial em processos recursivos",
                                "Economia: Cálculo de custos marginais em estruturas hierárquicas"
                              ],
                              "realWorldApplication": "Em análise de algoritmos divide-and-conquer como Merge Sort ou FFT, calcular custo por nó por nível permite somar custos totais para provar complexidade O(n log n), otimizando software em big data, IA e processamento de sinais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Somar custo total de um nível",
                            "description": "Multiplicar o número de nós a^k pelo custo por nó f(n/b^k) para obter o custo total do nível k: a^k * f(n/b^k).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o número de nós (subproblemas) no nível k da árvore de recorrência",
                                  "subSteps": [
                                    "Revise a relação de recorrência T(n) = a T(n/b) + f(n), onde a é o número de subproblemas por nó.",
                                    "No nível 0 (raiz), há 1 nó.",
                                    "No nível 1, há a nós; no nível 2, a^2 nós, e assim por diante.",
                                    "Generalize: no nível k, o número de nós é a^k.",
                                    "Anote a fórmula: número de nós = a^k."
                                  ],
                                  "verification": "Confirme escrevendo a fórmula a^k e calculando para k=0,1,2 com valores exemplo (ex: a=2, k=2 → 4 nós).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou editor de texto para anotações; diagrama da árvore de recorrência.",
                                  "tips": "Desenhe a árvore até o nível k para visualizar o crescimento exponencial.",
                                  "learningObjective": "Compreender como o número de subproblemas cresce exponencialmente com a^k.",
                                  "commonMistakes": "Confundir a^k com a*k (multiplicação linear em vez de exponencial)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o tamanho do subproblema e o custo por nó no nível k",
                                  "subSteps": [
                                    "No nível 0, tamanho do problema é n.",
                                    "No nível 1, cada subproblema tem tamanho n/b.",
                                    "No nível k, cada subproblema tem tamanho n / b^k.",
                                    "O custo não-recursivo por nó no nível k é f(n / b^k), onde f é a função de custo fora da recursão.",
                                    "Substitua na função f: calcule f(n / b^k)."
                                  ],
                                  "verification": "Calcule o tamanho para k=1,2 com exemplo (ex: n=8, b=2, k=2 → n/4=2) e aplique f(2).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora para potências; relação de recorrência anotada.",
                                  "tips": "Use notação fracionária para n/b^k para evitar erros de arredondamento precoce.",
                                  "learningObjective": "Calcular corretamente o tamanho reduzido dos subproblemas e o custo associado f(n/b^k).",
                                  "commonMistakes": "Esquecer a potência k em b^k, usando b em vez de b^k."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Multiplicar o número de nós pelo custo por nó para obter o custo total do nível k",
                                  "subSteps": [
                                    "Lembre: custo total = (número de nós) × (custo por nó).",
                                    "Substitua: custo total do nível k = a^k × f(n / b^k).",
                                    "Realize a multiplicação simbólica, mantendo variáveis n, a, b, k.",
                                    "Simplifique se possível (ex: se f(m) = m, então a^k * (n / b^k)).",
                                    "Anote a fórmula final: C_k = a^k * f(n / b^k)."
                                  ],
                                  "verification": "Escreva a fórmula C_k e compute numericamente para um exemplo específico.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel para derivação simbólica; calculadora para verificação numérica.",
                                  "tips": "Mantenha consistência na notação: use parênteses em f(n/b^k) para clareza.",
                                  "learningObjective": "Derivar e aplicar a fórmula de custo total por nível de forma precisa.",
                                  "commonMistakes": "Inverter a ordem: multiplicar f(n) por a^k em vez de f(n/b^k)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e praticar o cálculo com um exemplo completo",
                                  "subSteps": [
                                    "Escolha uma recorrência exemplo: T(n) = 2 T(n/2) + n (a=2, b=2, f(n)=n).",
                                    "Para k=1: nós=2^1=2, custo por nó=f(n/2)=n/2, total=2*(n/2)=n.",
                                    "Para k=2: nós=4, custo por nó=n/4, total=4*(n/4)=n.",
                                    "Compare com o custo da raiz (nível 0): f(n)=n.",
                                    "Registre observações sobre padrões emergentes."
                                  ],
                                  "verification": "Confirme que os cálculos batem e desenhe a árvore para validar visualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama da árvore de recorrência; calculadora.",
                                  "tips": "Use exemplos com potências de 2 para n (ex: n=8) para evitar frações.",
                                  "learningObjective": "Aplicar a fórmula em um contexto real e identificar padrões.",
                                  "commonMistakes": "Ignorar simplificações algébricas que revelam o custo constante por nível."
                                }
                              ],
                              "practicalExample": "Na análise do Merge Sort, T(n) = 2 T(n/2) + n. No nível k=2 para n=8: 4 nós, cada com f(8/4)=2, custo total=4*2=8, que contribui para a soma total O(n log n).",
                              "finalVerifications": [
                                "Deriva corretamente a fórmula C_k = a^k * f(n/b^k) a partir da estrutura da árvore.",
                                "Calcula o número de nós a^k para k=0 a 3 com a=3, b=2.",
                                "Aplica f(n/b^k) corretamente em um exemplo com f(n)=n^2.",
                                "Multiplica sem erros aritméticos em 3 exemplos numéricos.",
                                "Identifica quando o custo por nível é constante (ex: a/b^d =1 para f(n)=n^d)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação simbólica da fórmula (100% match).",
                                "Corretude em cálculos numéricos (erro <1%).",
                                "Explicação clara da progressão de tamanhos de subproblemas.",
                                "Uso correto de notação exponencial sem confusões lineares.",
                                "Identificação de simplificações algébricas relevantes.",
                                "Visualização via diagrama da árvore de recorrência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Exponenciação e funções (a^k, b^k).",
                                "Matemática: Simplificação algébrica de expressões como a^k * n / b^k.",
                                "Física: Modelagem de decaimento ou crescimento em sistemas recursivos (ex: divisões de átomos).",
                                "Economia: Cálculo de custos escaláveis em processos hierárquicos."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos como QuickSort ou FFT, calcular custos por nível ajuda a provar complexidade O(n log n), essencial para escalabilidade em big data e machine learning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Soma Total de Custos e Análise Assintótica",
                        "description": "Agregação dos custos de todos os níveis da árvore para obter o tempo total T(n) e análise de limites para complexidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Determinar a altura da árvore",
                            "description": "Calcular a profundidade máxima da árvore como log_b n níveis, até que o tamanho do subproblema atinja 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura básica da árvore de recorrência",
                                  "subSteps": [
                                    "Revise a recorrência dada, como T(n) = a T(n/b) + f(n), identificando os parâmetros a (número de subproblemas) e b (redução do tamanho).",
                                    "Desenhe a raiz da árvore representando o problema de tamanho n e custo f(n).",
                                    "Identifique os nós filhos como subproblemas de tamanho n/b.",
                                    "Continue ramificando até visualizar o padrão de profundidade.",
                                    "Anote o fator de ramificação b, que determina a largura da árvore."
                                  ],
                                  "verification": "Desenhe manualmente a árvore para n=16 com b=2 e confirme que os tamanhos dos subproblemas diminuem corretamente para 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou software de desenho como Draw.io; notas da recorrência.",
                                  "tips": "Comece com um n pequeno (potência de b) para visualizar facilmente.",
                                  "learningObjective": "Compreender como a árvore modela a recursão e identifica o parâmetro b.",
                                  "commonMistakes": "Confundir a com b; ignorar que f(n) é custo por nível, não altura."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o tamanho inicial do problema e o fator de divisão",
                                  "subSteps": [
                                    "Extraia n do problema inicial (tamanho da entrada).",
                                    "Localize b na recorrência, garantindo que n/b seja inteiro em cada nível.",
                                    "Calcule o tamanho do subproblema em cada nível: nível k tem tamanho n / b^k.",
                                    "Defina a condição de parada: quando n / b^k = 1.",
                                    "Resolva para k: k = log_b n."
                                  ],
                                  "verification": "Para n=64 e b=4, confirme que 64/4^0=64, 64/4^1=16, 64/4^2=4, 64/4^3=1, total 4 níveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou planilha para potências; exemplos de recorrências.",
                                  "tips": "Use n como potência de b para simplificar cálculos iniciais.",
                                  "learningObjective": "Identificar parâmetros chave e expressar tamanho por nível matematicamente.",
                                  "commonMistakes": "Usar log na base errada; esquecer que k inicia em 0 na raiz."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a altura exata usando logaritmo",
                                  "subSteps": [
                                    "Escreva a equação: altura h = log_b n, onde n / b^h = 1.",
                                    "Converta para exponencial: b^h = n, então h = log_b n.",
                                    "Use mudança de base se necessário: log_b n = ln(n) / ln(b) ou log2(n)/log2(b).",
                                    "Arredonde para cima se n não for potência exata de b.",
                                    "Some 1 se contar a raiz como nível 0 ou ajuste convenção."
                                  ],
                                  "verification": "Calcule h para T(n)=3T(n/2)+n com n=16: log2(16)=4, verifique árvore desenhada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora científica; tabela de logaritmos opcionais.",
                                  "tips": "Pratique com log2 para b=2, comum em divide-and-conquer.",
                                  "learningObjective": "Aplicar logaritmos para determinar profundidade máxima.",
                                  "commonMistakes": "Confundir altura com número de folhas; não arredondar corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a altura e interpretar no contexto da recorrência",
                                  "subSteps": [
                                    "Conte os níveis na árvore desenhada e compare com log_b n.",
                                    "Verifique se folhas estão em tamanho 1 (casos base).",
                                    "Discuta implicações: altura afeta tempo total O(n log n) em alguns casos.",
                                    "Teste com n não-potência, ex: n=10, b=2, h=4 pois 10/16<1 mas ajusta.",
                                    "Documente a fórmula final para a recorrência específica."
                                  ],
                                  "verification": "Resolva 2-3 exemplos variados e confirme consistência entre desenho e fórmula.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplos de problemas; software como Python para simular árvore.",
                                  "tips": "Sempre desenhe para validação visual antes de confiar só na fórmula.",
                                  "learningObjective": "Integrar cálculo com visualização e análise assintótica.",
                                  "commonMistakes": "Ignorar casos base não-unitários; superestimar altura por off-by-one."
                                }
                              ],
                              "practicalExample": "Para a recorrência do Merge Sort T(n) = 2 T(n/2) + n, com n=16: b=2, altura h = log2(16) = 4 níveis (raiz n=16, nível1: 2x8, nível2: 4x4, nível3: 8x2, nível4: 16x1).",
                              "finalVerifications": [
                                "Desenhar a árvore completa mostra exatamente h+1 níveis até tamanho 1.",
                                "Cálculo log_b n coincide com contagem manual de níveis.",
                                "Fórmula produz h inteiro ou ceiling correto para n arbitrário.",
                                "Teste com 3 recorrências diferentes (b=2,3,4) dá resultados consistentes.",
                                "Explicação oral cobre ramificação, redução e parada.",
                                "Identifica corretamente implicações para complexidade total."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de log_b n (erro <1 nível).",
                                "Desenho da árvore reflete corretamente tamanhos por nível.",
                                "Explicação clara da derivação matemática.",
                                "Manipulação correta de casos não-potência de b.",
                                "Integração com análise de custos totais.",
                                "Identificação de erros comuns em exemplos alheios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos e equações exponenciais.",
                                "Álgebra Linear: Estruturas hierárquicas semelhantes a decomposição de matrizes.",
                                "Física: Modelos de decaimento exponencial em simulações recursivas.",
                                "Economia: Análise de árvores de decisão em otimização."
                              ],
                              "realWorldApplication": "Em algoritmos divide-and-conquer como QuickSort ou FFT, determinar altura otimiza previsão de runtime em big data processing, ajudando engenheiros a escalar sistemas para milhões de elementos sem timeouts."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Somar custos de níveis internos",
                            "description": "Calcular a soma dos custos dos níveis da raiz até antes das folhas: Σ_{k=0}^{log_b n -1} a^k f(n/b^k).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura da árvore de recorrência e identificar níveis",
                                  "subSteps": [
                                    "Desenhe a árvore de recorrência para uma relação T(n) = a T(n/b) + f(n).",
                                    "Identifique a raiz (nível 0) e os níveis subsequentes até antes das folhas.",
                                    "Marque o custo f(n/b^k) em cada nó do nível k.",
                                    "Conte o número de nós no nível k: a^k nós.",
                                    "Note que folhas estão no nível log_b n."
                                  ],
                                  "verification": "A árvore desenhada mostra corretamente a^k nós no nível k com custos f(n/b^k) por nó.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de desenho como Draw.io",
                                    "Exemplo de relação recorrente como T(n) = 2T(n/2) + n"
                                  ],
                                  "tips": "Comece com n pequeno (ex: n=8) para visualizar facilmente.",
                                  "learningObjective": "Compreender a geometria da árvore de recorrência e distribuição de custos por nível.",
                                  "commonMistakes": [
                                    "Confundir níveis com profundidade total",
                                    "Esquecer que folhas não são incluídas nos custos internos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o custo total por nível",
                                  "subSteps": [
                                    "Para nível k, custo por nó é f(n/b^k).",
                                    "Número de nós: a^k.",
                                    "Custo total do nível k: a^k * f(n/b^k).",
                                    "Liste custos para k=0 até log_b n -1.",
                                    "Some manualmente para um exemplo pequeno."
                                  ],
                                  "verification": "Cálculo manual coincide com soma esperada para n=8 em T(n)=2T(n/2)+n (custos: nível0=8, nível1=4*2=8, total=16).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela para anotar custos por nível"
                                  ],
                                  "tips": "Use log_b n ≈ 3 para n=8, b=2.",
                                  "learningObjective": "Calcular precisamente o custo agregado de cada nível interno.",
                                  "commonMistakes": [
                                    "Incluir custos das folhas",
                                    "Erro em a^k ou n/b^k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a soma total dos custos internos",
                                  "subSteps": [
                                    "Escreva a soma: Σ_{k=0}^{log_b n -1} a^k f(n/b^k).",
                                    "Reconheça como série finita.",
                                    "Se f(n)=n^c, simplifique assumindo c=1 para linear.",
                                    "Calcule soma fechada quando possível (ex: série geométrica).",
                                    "Verifique limite para grandes n."
                                  ],
                                  "verification": "A fórmula derivada matches Σ_{k=0}^{h-1} a^k f(n/b^k) onde h=log_b n.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de fórmulas de séries (geométrica: S = (r^m -1)/(r-1))",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Pratique com a=1, b=2 para master theorem cases.",
                                  "learningObjective": "Formular e simplificar a soma dos custos internos usando notação sigma.",
                                  "commonMistakes": [
                                    "Índice superior errado (incluir log_b n)",
                                    "Confundir f(n/b^k) com f(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar com exemplos práticos",
                                  "subSteps": [
                                    "Escolha T(n)=3T(n/4)+n^2, compute log_4 n níveis.",
                                    "Calcule custos por nível e some.",
                                    "Compare com solução conhecida do Master Theorem.",
                                    "Teste com n=16, some manualmente.",
                                    "Generalize para análise assintótica."
                                  ],
                                  "verification": "Soma calculada equals T(n) menos custos das folhas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel para somas",
                                    "Referência Master Theorem"
                                  ],
                                  "tips": "Use potências de b para n exato.",
                                  "learningObjective": "Aplicar a soma em relações reais e validar resultados.",
                                  "commonMistakes": [
                                    "Arredondar log_b n incorretamente",
                                    "Ignorar exponentes em f(n)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para T(n) = 2T(n/2) + n com n=8: Nível 0: 1 nó * n=8. Nível 1: 2 nós * (n/2)=2*4=8. Nível 2 seria folhas. Soma interna: 8+8=16. Fórmula: Σ_{k=0}^{2} 2^k *(8/2^k)=8+8=16.",
                              "finalVerifications": [
                                "Pode desenhar árvore e marcar custos corretamente para n dado.",
                                "Calcula soma exata da fórmula para qualquer a,b,f(n) simples.",
                                "Identifica quando soma é O(n) ou similar.",
                                "Diferencia custos internos de totais incluindo folhas.",
                                "Aplica a casos Master Theorem Case 1/2.",
                                "Verifica com código simulando árvore."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de nós por nível (a^k).",
                                "Correto uso de f(n/b^k) em cada nível.",
                                "Soma sigma sem erros aritméticos.",
                                "Reconhecimento de padrões geométricos.",
                                "Validação cruzada com exemplos numéricos.",
                                "Explicação clara da exclusão de folhas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries geométricas e somas finitas.",
                                "Física: Modelos de fratura hierárquica ou difusão em árvores.",
                                "Economia: Cálculo de custos cumulativos em estruturas piramidais.",
                                "Biologia: Análise de ramificações em filogenia."
                              ],
                              "realWorldApplication": "Em análise de Merge Sort (T(n)=2T(n/2)+n), soma de custos internos revela O(n log n) devido a cópias lineares por nível, otimizando implementações paralelas em big data."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Incluir custos das folhas e obter T(n)",
                            "description": "Adicionar o custo das folhas (a^{log_b n} * Θ(1) = n^{log_b a}) e somar tudo para T(n) = Θ( soma total ).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e desenhar as folhas na árvore de recorrência",
                                  "subSteps": [
                                    "Revise a árvore de recorrência completa para o algoritmo dado, identificando o nível das folhas onde o tamanho do problema é base (n=1).",
                                    "Conte o número de folhas: para uma recorrência T(n) = a T(n/b) + f(n), há a^{log_b n} folhas.",
                                    "Marque cada folha com seu custo base, tipicamente Θ(1).",
                                    "Verifique a profundidade da árvore: log_b n níveis.",
                                    "Anote a altura h = log_b n."
                                  ],
                                  "verification": "Confirme que todas as folhas estão marcadas corretamente e o número total de folhas é a^h.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para desenhar a árvore",
                                    "Exemplo de recorrência resolvida anteriormente"
                                  ],
                                  "tips": "Comece com uma árvore pequena (n=8) para visualizar melhor.",
                                  "learningObjective": "Compreender a estrutura das folhas na árvore de recorrência.",
                                  "commonMistakes": "Confundir folhas com nós internos; folhas são sempre os casos base."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número exato de folhas",
                                  "subSteps": [
                                    "Calcule a altura da árvore: h = log_b n.",
                                    "Número de folhas = a^h = a^{log_b n} = n^{log_b a}.",
                                    "Use propriedades logarítmicas: log_b n = ln n / ln b.",
                                    "Para exemplos comuns: MergeSort (a=2,b=2) →  n folhas; n^{log_2 2} = n.",
                                    "Registre a fórmula: #folhas = n^{log_b a}."
                                  ],
                                  "verification": "Teste com n=16, b=2, a=2: deve dar 16 folhas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python para logs",
                                    "Tabela de recorrências padrão"
                                  ],
                                  "tips": "Memorize n^{log_b a} como padrão para #folhas.",
                                  "learningObjective": "Dominar o cálculo do número de folhas usando logaritmos.",
                                  "commonMistakes": "Esquecer de elevar a ao expoente log_b n; calcular errado a base do log."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar o custo total das folhas",
                                  "subSteps": [
                                    "Atribua custo Θ(1) por folha (caso base).",
                                    "Custo total folhas = #folhas * Θ(1) = Θ(n^{log_b a}).",
                                    "Compare com custos de níveis internos: folhas são o nível h.",
                                    "Exemplo: Para T(n)=2T(n/2)+n, folhas Θ(n), internos somam Θ(n log n).",
                                    "Anote: C_folhas = Θ(n^{log_b a})."
                                  ],
                                  "verification": "Some custos das folhas manualmente em uma árvore pequena e compare com fórmula.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Árvore desenhada do Step 1",
                                    "Notas de custos por nível"
                                  ],
                                  "tips": "Sempre use Θ para assintótica desde o início.",
                                  "learningObjective": "Calcular precisamente o custo das folhas.",
                                  "commonMistakes": "Ignorar que custo é Θ(1) por folha, assumindo custo variável."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar todos os custos e obter T(n)",
                                  "subSteps": [
                                    "Liste custos por nível: Nível 0: f(n), Nível 1: a*f(n/b), ..., Nível h-1, Folhas: a^h * Θ(1).",
                                    "Some geometricamente: T(n) = soma_{i=0}^{h} (a^i * custo_base(n/b^i)).",
                                    "Simplifique: T(n) = Θ(n^{log_b a}) se folhas dominam, ou inclua f(n) log n se linear.",
                                    "Para Master Theorem casos: compare n^{log_b a} vs f(n).",
                                    "Escreva T(n) = Θ( soma total ) = Θ(n^{log_b a} + soma interna)."
                                  ],
                                  "verification": "Calcule T(n) para n=8 e compare com execução real do algoritmo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de cálculo com somas por nível",
                                    "Master Theorem reference"
                                  ],
                                  "tips": "Use somas geométricas: soma a^i = (a^{h+1}-1)/(a-1).",
                                  "learningObjective": "Integrar custos de folhas à análise total T(n).",
                                  "commonMistakes": "Esquecer de incluir folhas na soma total."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar assintótica final de T(n)",
                                  "subSteps": [
                                    "Aplique Master Theorem: compare f(n) com n^{log_b a}.",
                                    "Se folhas dominam: T(n)=Θ(n^{log_b a}); senão, Θ(f(n) log n) ou similar.",
                                    "Teste com exemplos: MergeSort Θ(n log n), onde folhas Θ(n), internos Θ(n log n).",
                                    "Documente T(n) final.",
                                    "Compare com solução exata se possível."
                                  ],
                                  "verification": "Confirme que T(n) matches known bounds for standard recurrences.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela Master Theorem",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Sempre valide com caso conhecido como Fibonacci ou MergeSort.",
                                  "learningObjective": "Obter notação Θ final incluindo folhas.",
                                  "commonMistakes": "Subestimar contribuição das folhas em casos onde a=1."
                                }
                              ],
                              "practicalExample": "Para MergeSort: T(n)=2T(n/2)+n. Árvore tem log2 n níveis,  n folhas de custo 1 cada → C_folhas=Θ(n). Soma total: níveis internos ~ n log n, folhas n → T(n)=Θ(n log n). Desenhe árvore para n=8: 8 folhas, soma= 8 + 8 + 8*2 + 8*4? Wait, corretamente: nível 0: n=8, nível1:2*(4), etc., folhas nível3:8*1.",
                              "finalVerifications": [
                                "Número de folhas calculado corretamente como n^{log_b a}.",
                                "Custo das folhas é Θ(n^{log_b a}).",
                                "Soma total inclui todos níveis + folhas.",
                                "T(n) expresso em Θ corretamente.",
                                "Validação com Master Theorem ou exemplo numérico.",
                                "Nenhum erro em logaritmos ou potências."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de #folhas (100% match fórmula).",
                                "Correta inclusão de custo folhas na soma total.",
                                "Uso apropriado de notação assintótica Θ.",
                                "Explicação clara da soma por níveis.",
                                "Validação com pelo menos um exemplo numérico.",
                                "Identificação correta de caso dominante (folhas vs internos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos, somas geométricas e potências.",
                                "Álgebra: Resolução de recorrências lineares.",
                                "Física: Modelagem de crescimento exponencial em sistemas dinâmicos.",
                                "Economia: Análise de custos cumulativos em processos recursivos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, analisar MergeSort para prever tempo em datasets grandes (n=10^6), otimizando memória e tempo incluindo custos base (folhas) para evitar timeouts em big data processing."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.4",
                            "name": "Comparar com o Teorema Mestre",
                            "description": "Verificar se o resultado da árvore alinha com as condições do Master Theorem para confirmação assintótica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Relembrar as Condições do Teorema Mestre",
                                  "subSteps": [
                                    "Revise a forma padrão da relação de recorrência: T(n) = a T(n/b) + f(n), onde a ≥ 1, b > 1.",
                                    "Identifique os três casos principais: Caso 1 (f(n) = O(n^{log_b a - ε})), Caso 2 (f(n) = Θ(n^{log_b a} log^k n)), Caso 3 (f(n) = Ω(n^{log_b a + ε}) com condição de regularidade).",
                                    "Anote os valores de a, b e f(n) da relação de recorrência analisada na árvore.",
                                    "Calcule log_b a manualmente ou com calculadora para referência futura.",
                                    "Liste as soluções assintóticas para cada caso."
                                  ],
                                  "verification": "Você pode recitar corretamente os três casos e suas soluções assintóticas sem consultar notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de anotações ou quadro branco",
                                    "Calculadora para logaritmos",
                                    "Referência rápida do Master Theorem (opcional para verificação inicial)"
                                  ],
                                  "tips": "Use exemplos simples como T(n)=2T(n/2)+1 para fixar os casos.",
                                  "learningObjective": "Entender precisamente as premissas e soluções do Master Theorem.",
                                  "commonMistakes": "Confundir os expoentes nos casos 1 e 3; esquecer a condição de regularidade no caso 3."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair Parâmetros da Análise da Árvore de Recorrência",
                                  "subSteps": [
                                    "Identifique 'a' como o número de subproblemas por nível na árvore.",
                                    "Determine 'b' como o fator de divisão do tamanho do problema (n/b).",
                                    "Extraia f(n) como o custo não-recursivo no nível raiz da árvore.",
                                    "Calcule o custo total por nível da árvore e compare com n^{log_b a}.",
                                    "Registre o número de níveis da árvore (aproximadamente log_b n)."
                                  ],
                                  "verification": "Liste corretamente a, b, f(n) e log_b a da árvore analisada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama da árvore de recorrência impresso ou desenhado",
                                    "Papel e lápis para cálculos"
                                  ],
                                  "tips": "Desenhe a árvore ao lado para visualização direta dos parâmetros.",
                                  "learningObjective": "Mapear elementos da árvore de recorrência para os parâmetros do Master Theorem.",
                                  "commonMistakes": "Errar na identificação de f(n), incluindo custos recursivos erroneamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar f(n) com n^{log_b a} e Classificar o Caso",
                                  "subSteps": [
                                    "Calcule n^{log_b a} usando log_b a obtido anteriormente.",
                                    "Compare o crescimento de f(n) com n^{log_b a}: verifique se f(n) = O, Θ ou Ω.",
                                    "Para Θ, cheque potências de log; para caso 3, teste af(n/b) ≤ c f(n) para c<1.",
                                    "Classifique explicitamente em Caso 1, 2 ou 3 com justificativa assintótica.",
                                    "Anote desigualdades como f(n) = O(n^{log_b a - ε}) com ε > 0 específico."
                                  ],
                                  "verification": "Escreva a classificação do caso com a desigualdade correspondente e ε se aplicável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou software como Wolfram Alpha para comparações assintóticas",
                                    "Tabela de crescimento assintótico (O(1), log n, n, n log n, etc.)"
                                  ],
                                  "tips": "Use limites L'Hôpital ou propriedades de log para comparações rigorosas.",
                                  "learningObjective": "Aplicar comparações assintóticas para determinar o caso dominante.",
                                  "commonMistakes": "Ignorar fatores logarítmicos no caso 2; falhar na condição de regularidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Alinhamento entre Solução da Árvore e Master Theorem",
                                  "subSteps": [
                                    "Some os custos totais da árvore: custo em folhas + custos por níveis.",
                                    "Compare a soma assintótica da árvore (ex: Θ(n log n)) com a solução do caso identificado.",
                                    "Confirme se ambas convergem para a mesma classe (Θ, O, Ω).",
                                    "Se houver discrepância, identifique erros na árvore ou classificação.",
                                    "Documente a confirmação final: 'Alinha com Master Theorem - Caso X: T(n) = Θ(...)'."
                                  ],
                                  "verification": "A solução da árvore e do Master Theorem coincidem assintoticamente, com justificativa escrita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Cálculos prévios da soma da árvore",
                                    "Folha de verificação comparativa"
                                  ],
                                  "tips": "Sempre expresse ambas em notação Θ para comparação direta.",
                                  "learningObjective": "Validar a análise da árvore usando o Master Theorem como benchmark.",
                                  "commonMistakes": "Comparar expressões exatas em vez de assintóticas; ignorar constantes."
                                }
                              ],
                              "practicalExample": "Para T(n) = 2 T(n/2) + n: Árvore tem custo por nível Θ(n), log_2 n níveis → Θ(n log n). Master Theorem: a=2,b=2,f(n)=n=Θ(n^{log2 2}), Caso 2 → T(n)=Θ(n log n). Alinha perfeitamente.",
                              "finalVerifications": [
                                "Parâmetros a, b, f(n) extraídos corretamente da árvore.",
                                "Caso do Master Theorem classificado com desigualdade precisa.",
                                "Solução assintótica da árvore matches a do Theorem.",
                                "Condição de regularidade verificada se Caso 3.",
                                "Documentação completa com cálculos e justificativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de parâmetros (100% correto).",
                                "Correta classificação do caso com análise assintótica rigorosa.",
                                "Alinhamento confirmado com notação big-Theta.",
                                "Tratamento de edge cases como log factors ou regularidade.",
                                "Clareza e completude da justificativa escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e limites (cálculo).",
                                "Matemática Discreta: Logaritmos e equações de recorrência.",
                                "Estatística: Modelos probabilísticos em análise de algoritmos aleatórios.",
                                "Física: Modelos fractais e recursivos em simulações."
                              ],
                              "realWorldApplication": "Em otimização de software, como no design de divide-and-conquer em bibliotecas como FFT no NumPy ou merge sort em bancos de dados, confirmando eficiência Θ(n log n) para escalabilidade em big data."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Teorema Mestre",
                    "description": "Solução direta para recorrências padrão da forma T(n) = aT(n/b) + f(n).",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Forma Padrão e Premissas do Teorema Mestre",
                        "description": "Definição da recorrência padrão T(n) = a T(n/b) + f(n), com premissas como a ≥ 1 inteiro, b > 1 real, f(n) assintoticamente positiva, e cálculo de log_b a.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Identificar a forma padrão da recorrência",
                            "description": "Reconhecer e reescrever uma relação de recorrência dada no formato exato T(n) = a T(n/b) + f(n), identificando os parâmetros a, b e f(n), e verificando se satisfazem a ≥ 1 (inteiro), b > 1 (real positivo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma padrão da recorrência no Teorema Mestre",
                                  "subSteps": [
                                    "Leia a definição oficial: T(n) = a T(n/b) + f(n), onde a é o número de subproblemas, b é o fator de divisão do tamanho, e f(n) é o custo não-recursivo.",
                                    "Memorize as premissas: a ≥ 1 e inteiro, b > 1 e real positivo.",
                                    "Estude exemplos canônicos como T(n) = 2T(n/2) + n (merge sort).",
                                    "Anote o formato em um papel, destacando cada componente.",
                                    "Compare com formas não-padrão, como T(n) = T(n-1) + 1, para diferenciar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os componentes a, b e f(n) com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro ou slides sobre Teorema Mestre",
                                    "Vídeo tutorial curto (ex: YouTube sobre Master Theorem)"
                                  ],
                                  "tips": "Visualize o formato como uma árvore: raiz com custo f(n), subárvores recursivas.",
                                  "learningObjective": "Reconhecer visual e conceitualmente o formato exato T(n) = a T(n/b) + f(n).",
                                  "commonMistakes": [
                                    "Confundir f(n) com o termo recursivo",
                                    "Ignorar que b deve ser >1",
                                    "Assumir a sempre inteiro sem verificar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e reescrever uma recorrência dada no formato padrão",
                                  "subSteps": [
                                    "Identifique o termo recursivo principal (ex: 3 T(n/4)).",
                                    "Isole o termo não-recursivo como f(n) (ex: custo adicional fora da recursão).",
                                    "Reescreva explicitamente como T(n) = a T(n/b) + f(n), ajustando constantes se necessário.",
                                    "Garanta que n/b reflita exatamente a divisão (ex: n/2, não n-1).",
                                    "Teste com substituição simples: verifique se faz sentido para n grande."
                                  ],
                                  "verification": "Reescreva 2 recorrências dadas e confira com uma solução modelo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios impressos ou digitais de recorrências",
                                    "Calculadora para valores pequenos de n"
                                  ],
                                  "tips": "Procure padrões como 'k T(n/d)' para extrair a=k, b=d diretamente.",
                                  "learningObjective": "Transformar recorrências reais em forma padrão com precisão.",
                                  "commonMistakes": [
                                    "Tratar constantes multiplicativas erradas como parte de a",
                                    "Deixar f(n) incluir termos recursivos",
                                    "Usar divisões irregulares como n-1 em vez de n/b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar os parâmetros a, b e f(n)",
                                  "subSteps": [
                                    "Extraia a: coeficiente inteiro multiplicando T(n/b).",
                                    "Extraia b: denominador na divisão de n dentro de T().",
                                    "Defina f(n): resto da equação após remover o termo recursivo.",
                                    "Escreva explicitamente: 'a = X, b = Y, f(n) = Z(n)'.",
                                    "Valide com um valor pequeno de n (ex: n=4) para consistência."
                                  ],
                                  "verification": "Liste a, b, f(n) para 3 recorrências variadas e compare com chaves de resposta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de exercícios com recorrências",
                                    "Tabela de referência rápida para parâmetros"
                                  ],
                                  "tips": "a é sempre o número de chamadas recursivas idênticas; b é o fator exato de redução.",
                                  "learningObjective": "Extrair com exatidão os três parâmetros fundamentais.",
                                  "commonMistakes": [
                                    "Incluir constantes em f(n) incorretamente",
                                    "Confundir b com expoentes",
                                    "Esquecer que a pode ser 1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar as premissas do Teorema Mestre",
                                  "subSteps": [
                                    "Confira a ≥ 1 e inteiro (ex: 2.5 inválido).",
                                    "Confira b > 1 e real positivo (ex: b=1.5 ok, b=1 inválido).",
                                    "Avalie se f(n) é polinomial ou assintótica positiva.",
                                    "Declare se a recorrência satisfaz as premissas: 'Sim/Não' com justificativa.",
                                    "Se inválida, sugira ajustes ou nota 'não aplicável'."
                                  ],
                                  "verification": "Para 4 recorrências, verifique premissas e justifique cada uma.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de recorrências com premissas variadas",
                                    "Critérios de validação impressos"
                                  ],
                                  "tips": "Lembre: b>1 garante terminação; a≥1 cobre casos base como T(n)=T(n)+f(n).",
                                  "learningObjective": "Validar rigorosamente se uma recorrência está pronta para o Teorema Mestre.",
                                  "commonMistakes": [
                                    "Aceitar a fracionário",
                                    "Permitir b≤1",
                                    "Ignorar positividade de f(n)"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada T(n) = 4 T(n/2) + n², reescreva como T(n) = 4 T(n/2) + n² (já padrão), identifique a=4 (inteiro ≥1), b=2 (>1), f(n)=n², e verifique premissas: todas satisfeitas.",
                              "finalVerifications": [
                                "Reescreva corretamente 5 recorrências no formato padrão.",
                                "Identifique a, b, f(n) sem erros em exemplos mistos.",
                                "Valide premissas em 3 casos válidos e 2 inválidos.",
                                "Explique diferenças entre recorrências padrão e não-padrão.",
                                "Aplique a um algoritmo real como quicksort: T(n)=2T(n/2)+n.",
                                "Crie uma recorrência própria e auto-avalie."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reescrita do formato (100% match com T(n)=aT(n/b)+f(n)).",
                                "Correta extração de a (inteiro ≥1), b (>1 real), f(n).",
                                "Validação rigorosa das premissas com justificativa.",
                                "Uso consistente de notação assintótica (Θ, O).",
                                "Capacidade de lidar com variações (constantes, log n).",
                                "Clareza na explicação oral/escrita dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações diferenciais e recorrências lineares.",
                                "Álgebra: Manipulação simbólica e fatoração de expressões.",
                                "Lógica e Programação: Análise de funções recursivas em código.",
                                "Física: Modelagem de processos iterativos como decaimento.",
                                "Economia: Análise de crescimento exponencial em modelos recursivos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, identificar a forma padrão permite aplicar o Teorema Mestre para prever tempo de execução de algoritmos divide-and-conquer como merge sort ou FFT, otimizando escolhas em big data e machine learning."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Calcular o termo n^{log_b a}",
                            "description": "Computar o valor de log_b a para uma dada recorrência e expressar a função polilogarítmica n^{log_b a}, utilizando propriedades logarítmicas para simplificar expressões assintóticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de logaritmos",
                                  "subSteps": [
                                    "Defina log_b a como o expoente x tal que b^x = a.",
                                    "Estude a fórmula de mudança de base: log_b a = log_c a / log_c b para qualquer c > 0, c ≠ 1 (comumente c = 10 ou e).",
                                    "Memorize propriedades chave: log_b (a^c) = c log_b a, log_b (a * d) = log_b a + log_b d, log_b (a / d) = log_b a - log_b d.",
                                    "Pratique com exemplos simples: log_2 8 = 3, log_10 100 = 2.",
                                    "Entenda restrições: b > 0, b ≠ 1, a > 0."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o significado de log_2 16 e calcule seu valor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha de papel e caneta",
                                    "Tabela de logaritmos (opcional)"
                                  ],
                                  "tips": [
                                    "Use log natural (ln) ou log base 10 para cálculos rápidos em calculadoras.",
                                    "Visualize graficamente: log_b a é a interseção da curva y = b^x com x = a no eixo y."
                                  ],
                                  "learningObjective": "Compreender a definição e propriedades básicas de logaritmos para preparar cálculos de log_b a.",
                                  "commonMistakes": [
                                    "Confundir log_b a com a^{log_b} (inverso é b^{log_b a} = a).",
                                    "Esquecer restrições de domínio.",
                                    "Aplicar propriedades incorretamente em produtos ou potências."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular numericamente o valor de log_b a",
                                  "subSteps": [
                                    "Identifique valores de a, b e escolha base de calculadora (ex: ln ou log10).",
                                    "Aplique mudança de base: compute ln(a)/ln(b) ou log10(a)/log10(b).",
                                    "Verifique com potenciação: b^{resultado} deve aproximar a.",
                                    "Pratique com frações: log_3 (1/9) = log_3 1 - log_3 9 = 0 - 2 = -2.",
                                    "Aproxime valores irracionais, como log_2 3 ≈ 1.584."
                                  ],
                                  "verification": "Calcule log_4 64 e confirme que 4^{resultado} ≈ 64.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora com funções logarítmicas",
                                    "Planilha Excel ou Google Sheets para automação"
                                  ],
                                  "tips": [
                                    "Para logs exatos, prefira potências inteiras; use ≈ para irracionais.",
                                    "Teste com n=1: log_b 1 = 0 sempre."
                                  ],
                                  "learningObjective": "Dominar o cálculo preciso de log_b a usando ferramentas e verificação.",
                                  "commonMistakes": [
                                    "Erro de divisão na mudança de base (ln b no denominador).",
                                    "Usar log(a^b) como b*log(a) sem base consistente.",
                                    "Arredondar prematuramente levando a erros propagados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e simplificar a expressão n^{log_b a}",
                                  "subSteps": [
                                    "Expresse n^{log_b a} usando mudança de base: n^{log_b a} = n^{(ln a / ln b)} = (e^{ln n})^{ln a / ln b}.",
                                    "Simplifique assintoticamente: compare com n^k onde k = log_b a.",
                                    "Aplique propriedades: n^{log_b a} = (b^{log_b n})^{log_b a} = b^{log_b n * log_b a}.",
                                    "Pratique reescrita: para b=2, a=4, log_2 4=2, então n^2.",
                                    "Identifique quando é polinomial (log_b a >1), linear (=1) ou sublinear (<1)."
                                  ],
                                  "verification": "Simplifique n^{log_2 8} para n^3 e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para derivações algébricas",
                                    "Software simbólico como Wolfram Alpha (opcional)"
                                  ],
                                  "tips": [
                                    "Pense em n^{log_b a} como o 'tamanho do trabalho não-recursivo' no Teorema Mestre.",
                                    "Use log(n^{log_b a}) = log_b a * log n para análise assintótica."
                                  ],
                                  "learningObjective": "Manipular algebricamente n^{log_b a} para expressões simplificadas.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em potências compostas.",
                                    "Confundir expoente com base na simplificação.",
                                    "Ignorar o contexto assintótico (Theta vs exato)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar no contexto do Teorema Mestre para recorrências",
                                  "subSteps": [
                                    "Lembre o Teorema Mestre: T(n) = a T(n/b) + f(n), com termo dominante n^{log_b a} em caso 1.",
                                    "Para dada recorrência, compute log_b a e compare com f(n).",
                                    "Exemplo: T(n)=3 T(n/2)+n^2 → log_2 3 ≈1.58, n^{1.58} domina n^2? Não, caso 2/3.",
                                    "Resolva completamente: expresse T(n) = Theta(n^{log_b a}).",
                                    "Teste com variações: altere a ou b e recalcule."
                                  ],
                                  "verification": "Resolva T(n)=4 T(n/2)+n usando log_2 4=2, confirmando Theta(n^2).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de recorrências impressos",
                                    "Gráficos de crescimento (plot n^k vs log n)"
                                  ],
                                  "tips": [
                                    "Sempre verifique premissas: T(1)=constante, a≥1 inteiro, b>1.",
                                    "Use calculadora para logs não-inteiros."
                                  ],
                                  "learningObjective": "Integrar cálculo de n^{log_b a} à análise de complexidade via Teorema Mestre.",
                                  "commonMistakes": [
                                    "Escolher caso errado do Teorema (comparar exponents corretamente).",
                                    "Confundir a e b na recorrência.",
                                    "Omitir fator log n em casos mistos."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e otimizar expressões assintóticas",
                                  "subSteps": [
                                    "Compare n^{log_b a} com f(n) usando limites: lim f(n)/n^{log_b a} → 0, const, ∞.",
                                    "Simplifique expressões complexas: n^{log_b (a c)} = n^{log_b a + log_b c}.",
                                    "Gere tabela de valores para n=2^k e plote.",
                                    "Discuta aproximações: para big-O, foque no expoente dominante.",
                                    "Resuma em notação assintótica: Theta(n^{log_b a} lg n^k)."
                                  ],
                                  "verification": "Para T(n)=2 T(n/2)+n lg n, confirme log_2 2=1, caso 2 com log factor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python/Matlab para plotar curvas",
                                    "Tabela de valores n vs n^{log_b a}"
                                  ],
                                  "tips": [
                                    "Plots ajudam a visualizar dominância.",
                                    "Lembre: lg n = log_2 n."
                                  ],
                                  "learningObjective": "Validar e refinar cálculos no contexto prático de algoritmos.",
                                  "commonMistakes": [
                                    "Erro em limites assintóticos.",
                                    "Ignorar fatores logarítmicos.",
                                    "Sobre-simplificar irracionais."
                                  ]
                                }
                              ],
                              "practicalExample": "Na recorrência do Merge Sort: T(n) = 2 T(n/2) + O(n). Aqui, a=2, b=2, log_2 2 = 1, então o termo é n^1 = n. Como f(n)=O(n) = Theta(n^{log_2 2}), aplica-se caso 2 do Teorema Mestre, resultando T(n) = Theta(n log n). Calcule: para n=1024, log_2 1024=10, T(1024) ≈ 1024*10 = 10k operações.",
                              "finalVerifications": [
                                "Calcule log_3 81 = 4 e verifique 3^4=81.",
                                "Simplifique n^{log_2 4} para n^2.",
                                "Aplique Teorema Mestre em T(n)=9 T(n/3)+n^2, log_3 9=2, Theta(n^2).",
                                "Compare n^{1.5} vs n^2: n^2 domina para grandes n.",
                                "Resolva T(n)=a T(n/b)+n^k com k=log_b a, confirmando Theta(n^k log n).",
                                "Gere tabela: para a=4,b=2,n=16, 16^{log_2 4}=16^2=256."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de log_b a (erro <0.01 para numéricos).",
                                "Correto uso de propriedades logarítmicas em simplificações.",
                                "Identificação precisa do caso no Teorema Mestre.",
                                "Verificação consistente via potenciação ou limites.",
                                "Expressão clara de complexidade assintótica (Theta, big-O).",
                                "Explicação coerente do impacto em análise de algoritmos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra avançada e funções exponenciais/logarítmicas.",
                                "Física: Escalas logarítmicas em terremotos (Richter) ou decibéis.",
                                "Economia: Modelos de crescimento composto e juros (log para tempos de duplicação).",
                                "Engenharia: Análise de sinais e filtros (transformadas log).",
                                "Estatística: Escalas log em distribuições (log-normal)."
                              ],
                              "realWorldApplication": "Em análise de algoritmos divide-and-conquer como QuickSort ou FFT, calcular n^{log_b a} prevê tempo de execução, otimizando código para big data (ex: Google Maps usa para pathfinding em grafos grandes, onde log factors decidem escalabilidade)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Verificar premissas assintóticas de f(n)",
                            "description": "Confirmar que f(n) é positiva para n suficientemente grande e entender o papel das condições regulares para os casos do teorema, preparando para a aplicação dos casos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de f(n) e premissas básicas do Teorema Mestre",
                                  "subSteps": [
                                    "Identifique a recorrência T(n) = a T(n/b) + f(n) e isole f(n).",
                                    "Liste as premissas gerais do Teorema Mestre: a ≥ 1, b > 1 inteiros.",
                                    "Confirme que f(n) é dada explicitamente na recorrência.",
                                    "Analise o comportamento assintótico esperado de f(n), como Θ(g(n)).",
                                    "Documente o contexto da recorrência (ex: divide-and-conquer)."
                                  ],
                                  "verification": "Checklist completo das premissas básicas preenchido corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notas da aula sobre Teorema Mestre, papel e caneta ou editor de texto.",
                                  "tips": "Sempre anote a recorrência original para referência rápida.",
                                  "learningObjective": "Compreender o papel de f(n) nas premissas do teorema.",
                                  "commonMistakes": "Confundir f(n) com T(n) ou ignorar constantes a e b."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar se f(n) é positiva para n suficientemente grande",
                                  "subSteps": [
                                    "Determine um valor N0 tal que para todo n ≥ N0, f(n) > 0.",
                                    "Plote ou avalie f(n) para valores grandes de n (ex: n=10, 100, 1000).",
                                    "Use limites assintóticos: lim_{n→∞} f(n)/n^k > 0 para algum k.",
                                    "Considere funções polinomiais, logarítmicas ou exponenciais comuns.",
                                    "Justifique matematicamente por que f(n) > 0 eventualmente."
                                  ],
                                  "verification": "Exemplo numérico ou prova mostrando f(n) > 0 para n ≥ N0 específico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora gráfica ou software como Desmos/Mathematica, tabela de valores.",
                                  "tips": "Para polinômios de grau positivo, coeficiente líder positivo garante isso.",
                                  "learningObjective": "Aplicar análise assintótica para positividade.",
                                  "commonMistakes": "Avaliar apenas para n pequenos onde f(n) pode oscilar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar as condições de regularidade para os casos do teorema",
                                  "subSteps": [
                                    "Calcule c = log_b a e compare com o grau assintótico de f(n).",
                                    "Para Caso 1 (f(n) = O(n^{c-ε})): Verifique f(n)/n^c = O(n^{-ε}).",
                                    "Para Caso 2 (f(n) = Θ(n^c log^k n)): Confirme k e regularidade af(n) ≤ k f(n).",
                                    "Para Caso 3 (f(n) = Ω(n^{c+ε})): Verifique af(n/b) ≤ k f(n) para k<1.",
                                    "Teste a condição de regularidade: af(n/b) ≤ k f(n) para n grande."
                                  ],
                                  "verification": "Tabela comparando f(n), n^{log_b a} e condição af(n/b) ≤ k f(n).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de fórmulas assintóticas, calculadora para log_b a.",
                                  "tips": "Use aproximações Big-O para simplificar comparações.",
                                  "learningObjective": "Dominar condições específicas por caso no Teorema Mestre.",
                                  "commonMistakes": "Esquecer fator 'a' na regularidade ou usar base errada para log."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir verificação e preparar aplicação dos casos",
                                  "subSteps": [
                                    "Resuma quais premissas foram satisfeitas e qual caso se aplica.",
                                    "Identifique o caso dominante (1, 2 ou 3) baseado nas verificações.",
                                    "Escreva a solução assintótica T(n) = Θ(...).",
                                    "Teste com um exemplo numérico pequeno para validação.",
                                    "Anote exceções ou casos limítrofes não cobertos."
                                  ],
                                  "verification": "Resumo escrito confirmando premissas e caso aplicável.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Resumo anterior dos steps 1-3.",
                                  "tips": "Sempre volte à recorrência original para consistência.",
                                  "learningObjective": "Integrar verificações para aplicação prática do teorema.",
                                  "commonMistakes": "Aplicar caso errado apesar de premissas falhas."
                                }
                              ],
                              "practicalExample": "Para T(n) = 4T(n/2) + n^2, f(n)=n^2. c=log2(4)=2. f(n)>0 para n≥1. Para Caso 2? Não, pois Θ(n^2) mas precisa log^k. Verifique regularidade: 4*( (n/2)^2 ) = n^2 =1*f(n), mas para Caso 3: f(n)=Ω(n^{2+ε})? Não. Na verdade, é Caso 1? Espere, compare: n^2 vs n^2, mas com ε=0 não. Corrija: é Caso 2 com k=0, mas verifique af(n/b)=4*(n/2)^2=n^2=f(n), ok para Θ(n^2).",
                              "finalVerifications": [
                                "f(n) > 0 para todo n ≥ N0 especificado.",
                                "Condição de regularidade af(n/b) ≤ k f(n) para k<1 e n grande.",
                                "Comparação correta entre f(n) e n^{log_b a}.",
                                "Identificação precisa do caso aplicável (1,2 ou 3).",
                                "Solução assintótica T(n) derivada corretamente.",
                                "Exemplo numérico valida a conclusão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na verificação de positividade (100% correto).",
                                "Correta aplicação de limites assintóticos (80%+ acurácia).",
                                "Tratamento completo da regularidade por caso (todos subcasos cobertos).",
                                "Clareza na justificativa matemática (lógica sequencial).",
                                "Identificação de erros potenciais e exceções.",
                                "Integração com solução final do teorema."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e limites (Cálculo I/II).",
                                "Matemática Discreta: Recorrências lineares e logaritmos.",
                                "Engenharia de Software: Modelagem de performance de algoritmos.",
                                "Física: Análise assintótica em modelos de difusão ou crescimento."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos de machine learning como merge sort ou FFT, verificar premissas assegura previsões precisas de tempo de execução em big data, evitando surpresas em deploy de produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Caso 1 do Teorema Mestre",
                        "description": "Condições e solução quando f(n) = O(n^{log_b a - ε}) para algum ε > 0, resultando em T(n) = Θ(n^{log_b a}).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Aplicar as condições do Caso 1",
                            "description": "Verificar se existe ε > 0 tal que f(n) = O(n^{log_b a - ε}), usando notação Big-O e comparações assintóticas entre f(n) e n^{log_b a}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes da recorrência e o Caso 1 do Teorema Mestre",
                                  "subSteps": [
                                    "Leia o enunciado da recorrência T(n) = a T(n/b) + f(n).",
                                    "Identifique os valores de a (número de subproblemas), b (fator de divisão, b > 1) e f(n) (custo de combinação).",
                                    "Recorde o Caso 1: Se f(n) = O(n^{log_b a - ε}) para algum ε > 0, então T(n) = Θ(n^{log_b a}).",
                                    "Explique em suas palavras o que significa f(n) crescer mais devagar que n^{log_b a}.",
                                    "Anote exemplos onde o Caso 1 se aplica, como f(n) constante."
                                  ],
                                  "verification": "Liste corretamente a, b e f(n) da recorrência dada e resuma o Caso 1 sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência ao Teorema Mestre (livro ou notas)"
                                  ],
                                  "tips": [
                                    "Sempre verifique se b > 1 e a ≥ 1 para validade do teorema."
                                  ],
                                  "learningObjective": "Identificar precisamente os parâmetros da recorrência e as condições do Caso 1.",
                                  "commonMistakes": [
                                    "Confundir f(n) com o custo total T(n)",
                                    "Esquecer que ε deve ser positivo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o expoente crítico log_b a",
                                  "subSteps": [
                                    "Calcule log_b a usando logaritmo: log_b a = ln(a)/ln(b) ou mudança de base.",
                                    "Simplifique se possível (ex: log_2 4 = 2).",
                                    "Anote n^{log_b a} como o crescimento 'dominante' dos subproblemas.",
                                    "Compare intuitivamente com f(n): o expoente de f(n) deve ser menor que log_b a.",
                                    "Teste com valores numéricos pequenos para validar o cálculo."
                                  ],
                                  "verification": "Seu cálculo de log_b a coincide com ferramentas como Wolfram Alpha ou calculadora.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou app de logaritmos",
                                    "Papel para cálculos"
                                  ],
                                  "tips": [
                                    "Use propriedades de log: log_b (a^k) = k log_b a para simplificar."
                                  ],
                                  "learningObjective": "Dominar o cálculo preciso de log_b a e sua interpretação assintótica.",
                                  "commonMistakes": [
                                    "Usar log base 10 incorretamente sem mudança de base",
                                    "Confundir log_b a com a/b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a condição assintótica f(n) = O(n^{log_b a - ε})",
                                  "subSteps": [
                                    "Escolha ε > 0 pequeno (ex: 0.1) tal que log_b a - ε < grau polinomial de f(n).",
                                    "Use limite: lim_{n→∞} f(n) / n^{log_b a - ε} = 0 ou ≤ c para algum c > 0.",
                                    "Se f(n) é polinômio, compare expoentes diretamente.",
                                    "Para funções não polinomiais, use tabelas de crescimento assintótico (ex: log n << n^δ).",
                                    "Prove formalmente ou justifique informalmente com exemplos numéricos."
                                  ],
                                  "verification": "Mostre que o limite é finito ou zero, ou compare expoentes corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de ordens assintóticas",
                                    "Software como Python para plotar ou limites"
                                  ],
                                  "tips": [
                                    "Comece com ε pequeno; se falhar, tente menor até satisfazer."
                                  ],
                                  "learningObjective": "Aplicar notação Big-O e limites para verificar dominância assintótica.",
                                  "commonMistakes": [
                                    "Esquecer o limite n→∞",
                                    "Usar ε ≤ 0",
                                    "Comparar funções erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e interpretar a aplicação do Caso 1",
                                  "subSteps": [
                                    "Afirme se a condição é satisfeita e por quê.",
                                    "Escreva a solução T(n) = Θ(n^{log_b a}).",
                                    "Discuta implicações: tempo de execução dominado pelos subproblemas.",
                                    "Teste com n grande numericamente se possível.",
                                    "Registre exceções (ex: casos base)."
                                  ],
                                  "verification": "Conclusão correta com justificativa e solução Θ exata.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel para resumo final"
                                  ],
                                  "tips": [
                                    "Sempre inclua 'para algum ε > 0' na justificativa formal."
                                  ],
                                  "learningObjective": "Interpretar resultados do Teorema Mestre no contexto de análise de algoritmos.",
                                  "commonMistakes": [
                                    "Ignorar regularidade de f(n)",
                                    "Concluir Θ sem verificar condições"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere T(n) = 2 T(n/2) + 1. Aqui, a=2, b=2, log_2 2 = 1, f(n)=1 = O(1). Escolha ε=0.5, então n^{1-0.5} = n^{0.5}, e 1 / n^{0.5} → 0, logo f(n) = O(n^{0.5}). Assim, T(n) = Θ(n). Isso modela um algoritmo recursivo onde o custo de combinação é constante, como contagem simples em árvore binária balanceada.",
                              "finalVerifications": [
                                "Identifica corretamente a, b e f(n) em uma recorrência dada.",
                                "Calcula log_b a sem erros aritméticos.",
                                "Escolhe ε > 0 apropriado e verifica Big-O via limite ou comparação.",
                                "Conclui corretamente se Caso 1 aplica e escreve T(n) = Θ(...).",
                                "Explica intuitivamente por que f(n) é 'polinomialmente menor'.",
                                "Identifica quando a condição falha (ex: f(n) = n log n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de log_b a (100% correto).",
                                "Correta aplicação de Big-O com limite ou comparação (justificativa clara).",
                                "Escolha válida de ε > 0 com prova.",
                                "Conclusão lógica e solução Θ exata.",
                                "Profundidade dos substeps: pelo menos 4 por step com detalhes.",
                                "Ausência de erros comuns listados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos, limites e análise assintótica.",
                                "Cálculo: Uso de lim_{n→∞} para crescimento de funções.",
                                "Programação: Implementar recorrências em Python/JS para testes empíricos.",
                                "Estatística: Comparar tempos de execução reais vs. preditos."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos divide-and-conquer como busca binária ou árvores balanceadas, onde o custo extra f(n) é negligible (ex: O(1) ou O(log n)), permitindo prever Θ(n^{log_b a}) para escalabilidade em big data e machine learning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Determinar a solução assintótica do Caso 1",
                            "description": "Concluir que T(n) = Θ(n^{log_b a}) quando as condições do Caso 1 são satisfeitas, justificando intuitivamente pelo domínio do trabalho recursivo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as condições do Caso 1 do Teorema Mestre",
                                  "subSteps": [
                                    "Lembre-se da forma geral da recorrência: T(n) = a T(n/b) + f(n), onde a ≥ 1, b > 1.",
                                    "Identifique as condições específicas do Caso 1: f(n) = O(n^{log_b a - ε}) para algum ε > 0.",
                                    "Confirme que log_b a é o expoente crítico, denotado como c = log_b a.",
                                    "Verifique exemplos simples para internalizar: se f(n) cresce mais devagar que n^c.",
                                    "Anote as premissas: n/b é inteiro, T(1) constante."
                                  ],
                                  "verification": "Escreva as condições exatas do Caso 1 em um papel e compare com a definição padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência ao Teorema Mestre (livro ou notas)"
                                  ],
                                  "tips": "Use um exemplo numérico pequeno para testar as condições antes de prosseguir.",
                                  "learningObjective": "Compreender precisamente quando o Caso 1 se aplica.",
                                  "commonMistakes": [
                                    "Confundir com Caso 2 (f(n) = Θ(n^{log_b a} log^k n))",
                                    "Esquecer ε > 0",
                                    "Assumir a=1 sempre"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender intuitivamente o domínio do trabalho recursivo",
                                  "subSteps": [
                                    "Visualize a árvore de recursão: cada nível tem a subproblemas de tamanho n/b.",
                                    "Calcule o custo total do trabalho recursivo: soma geométrica a^k * (n/b^k)^c ao nível k.",
                                    "Mostre que isso soma para Θ(n^c), pois é uma série geométrica com razão a / b^c = 1.",
                                    "Compare com f(n): como f(n) = o(n^c), o total de f nos níveis é o(n^c).",
                                    "Conclua que o recursivo domina: T(n) ~ custo recursivo = Θ(n^c)."
                                  ],
                                  "verification": "Desenhe a árvore de recursão para um exemplo e some os custos até folhas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhar árvore",
                                    "Calculadora para log_b a"
                                  ],
                                  "tips": "Pense na razão r = a / b^{log_b a} = 1 para ver equilíbrio.",
                                  "learningObjective": "Graspar por que o trabalho recursivo domina quando f(n) é menor.",
                                  "commonMistakes": [
                                    "Ignorar a soma nos níveis não-folha",
                                    "Confundir custo por nível com total",
                                    "Esquecer normalização por tamanho"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Concluir e escrever a solução assintótica",
                                  "subSteps": [
                                    "Escreva explicitamente: se Caso 1, então T(n) = Θ(n^{log_b a}).",
                                    "Compute log_b a = ln(a)/ln(b) ou log_b a = log2 a / log2 b.",
                                    "Aplique a uma recorrência exemplo: T(n)=2T(n/2)+1 → log2 2=1, Θ(n).",
                                    "Justifique: recursivo domina, f(n) contribui negligiblemente.",
                                    "Generalize para qualquer a, b satisfazendo condições."
                                  ],
                                  "verification": "Para uma recorrência dada, escreva T(n)=Θ(...) corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de recorrências",
                                    "Calculadora ou software para logaritmos"
                                  ],
                                  "tips": "Sempre compute c = log_b a primeiro e verifique f(n) vs n^{c-ε}.",
                                  "learningObjective": "Aplicar a conclusão diretamente da condição.",
                                  "commonMistakes": [
                                    "Escrever Θ(f(n)) em vez de recursivo",
                                    "Confundir log_b a com log a",
                                    "Omitir Θ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar intuitivamente e praticar verificação",
                                  "subSteps": [
                                    "Explique em palavras: 'Recursões custam mais porque se ramificam mais rápido que f(n) desacelera'.",
                                    "Teste limite: lim f(n)/n^{log_b a} = 0 garante domínio.",
                                    "Resolva 2-3 exercícios variados: mude a,b,f(n).",
                                    "Compare com expansão total da árvore para confirmação.",
                                    "Resuma: Caso 1 = recursivo vence."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a justificativa para um par.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de 3 exercícios de recorrências Caso 1",
                                    "Notas anteriores"
                                  ],
                                  "tips": "Use analogia: recursivo como 'árvore crescendo exponencialmente', f(n) linear.",
                                  "learningObjective": "Desenvolver intuição duradoura para domínio.",
                                  "commonMistakes": [
                                    "Justificativa vaga sem árvore",
                                    "Não testar múltiplos exemplos",
                                    "Confundir com casos polinomiais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para T(n) = 4 T(n/2) + n (a=4, b=2, log2 4=2, f(n)=n = O(n^{2-1}), ε=1>0). Solução: T(n)=Θ(n^2). Intuição: recursivo em níveis soma 4^k (n/2^k)^2 = n^2, constante por nível; f total o(n log n) << n^2.",
                              "finalVerifications": [
                                "Pode identificar se uma recorrência satisfaz Caso 1.",
                                "Escreve corretamente T(n)=Θ(n^{log_b a}).",
                                "Desenha árvore de recursão mostrando domínio.",
                                "Computa log_b a para valores dados.",
                                "Justifica intuitivamente sem fórmulas.",
                                "Aplica a 3 exemplos diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de condições (ε>0).",
                                "Correção da notação Θ(n^{log_b a}).",
                                "Profundidade da justificativa intuitiva (árvore/custos).",
                                "Uso correto de logaritmos.",
                                "Capacidade de generalizar para novos casos.",
                                "Clareza na explicação verbal/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos e séries geométricas.",
                                "Matemática: Análise assintótica e limites.",
                                "Engenharia de Software: Análise de complexidade em design de algoritmos.",
                                "Física: Modelos recursivos em simulações (ex: fractais)."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos como divide-and-conquer (ex: análise de tempo em sorting networks ou FFT simplificada), ajudando engenheiros a prever escalabilidade e escolher implementações eficientes em big data."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Resolver exemplo do Caso 1",
                            "description": "Aplicar o Teorema Mestre ao Caso 1 em uma recorrência como T(n) = 3T(n/2) + n, calculando log_b a e verificando f(n) = O(n^{log_2 3 - ε}).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os parâmetros da recorrência T(n) = 3T(n/2) + n",
                                  "subSteps": [
                                    "Escreva a recorrência dada: T(n) = 3T(n/2) + n.",
                                    "Identifique 'a' como o coeficiente das chamadas recursivas (a = 3).",
                                    "Identifique 'b' como o divisor do tamanho do problema (b = 2, pois n/2).",
                                    "Identifique f(n) como o custo adicional não-recursivo (f(n) = n).",
                                    "Confirme que a recorrência está na forma padrão T(n) = a T(n/b) + f(n)."
                                  ],
                                  "verification": "Liste explicitamente a = 3, b = 2 e f(n) = n com justificativa.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo da recorrência impresso"
                                  ],
                                  "tips": "Sempre compare com a forma canônica do Teorema Mestre para evitar confusões.",
                                  "learningObjective": "Extrair com precisão os parâmetros a, b e f(n) de uma recorrência.",
                                  "commonMistakes": [
                                    "Confundir a com o número de divisões (b)",
                                    "Incluir o termo recursivo em f(n)",
                                    "Ignorar constantes implícitas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o expoente crítico log_b a",
                                  "subSteps": [
                                    "Calcule log_b a = log_2 3.",
                                    "Use uma calculadora ou tabela para aproximar: log_2 3 ≈ 1.58496.",
                                    "Mantenha o valor exato como log_2 3 para análises simbólicas.",
                                    "Anote o valor aproximado para comparações numéricas (cerca de 1.585).",
                                    "Verifique o cálculo: 2^{log_2 3} = 3."
                                  ],
                                  "verification": "Mostre o cálculo de log_2 3 ≈ 1.585 com pelo menos 3 casas decimais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de logaritmos (opcional)"
                                  ],
                                  "tips": "Lembre-se que log_b a = ln(a)/ln(b); pratique com potências para validar.",
                                  "learningObjective": "Computar e interpretar o expoente log_b a no contexto do Teorema Mestre.",
                                  "commonMistakes": [
                                    "Usar log base 10 em vez de base b=2",
                                    "Arredondar prematuramente perdendo precisão",
                                    "Confundir log_b a com a/b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a condição do Caso 1 do Teorema Mestre",
                                  "subSteps": [
                                    "Compare o grau de f(n) = n, que é n^1.",
                                    "Calcule log_b a - ε onde ε > 0: verifique se 1 < log_2 3 (≈1.585).",
                                    "Escolha ε = log_2 3 - 1 ≈ 0.585 > 0.",
                                    "Confirme f(n) = O(n^{log_2 3 - ε}) pois 1 < log_2 3 - ε + ε = log_2 3.",
                                    "Conclua que satisfaz Caso 1: f(n) = O(n^{log_b a - ε})."
                                  ],
                                  "verification": "Escreva explicitamente ε > 0 e prove que f(n) = O(n^{log_b a - ε}).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para anotações matemáticas",
                                    "Calculadora"
                                  ],
                                  "tips": "Pense em termos de crescimento assintótico: compare expoentes polinomiais.",
                                  "learningObjective": "Aplicar corretamente a condição de dominância recursiva no Caso 1.",
                                  "commonMistakes": [
                                    "Esquecer que ε deve ser positivo",
                                    "Comparar f(n) diretamente com n^{log_b a} sem ε",
                                    "Confundir com Caso 2 onde f(n) ≈ n^{log_b a} log n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e interpretar a solução do Teorema Mestre",
                                  "subSteps": [
                                    "Aplique Caso 1: T(n) = Θ(n^{log_b a}) = Θ(n^{log_2 3}).",
                                    "Escreva a notação assintótica: T(n) = Θ(n^{1.585}).",
                                    "Interprete: o tempo é dominado pelo trabalho recursivo.",
                                    "Verificação extra: plote ou pense em crescimento vs n log n.",
                                    "Documente o processo completo em um resumo."
                                  ],
                                  "verification": "Escreva T(n) = Θ(n^{log_2 3}) com justificativa do Caso 1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel para resumo final"
                                  ],
                                  "tips": "Sempre inclua Θ para tight bound no Caso 1.",
                                  "learningObjective": "Derivar e interpretar o bound assintótico final.",
                                  "commonMistakes": [
                                    "Usar O em vez de Θ",
                                    "Esquecer a base do log na notação final",
                                    "Não mencionar o caso aplicado"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um algoritmo de divisão-e-conquista para multiplicação de matrizes 3-vias, a recorrência T(n) = 3T(n/2) + n surge do custo de divisão. Aplicando Caso 1: log_2 3 ≈1.585 >1, ε≈0.585, logo T(n)=Θ(n^{1.585}), mais eficiente que O(n^2) clássico para grandes n.",
                              "finalVerifications": [
                                "Parâmetros a=3, b=2, f(n)=n identificados corretamente.",
                                "log_2 3 calculado com precisão (≈1.58496).",
                                "Condição Caso 1 verificada com ε>0 explícito.",
                                "Solução final T(n)=Θ(n^{log_2 3}) escrita.",
                                "Interpretação assintótica coerente fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de parâmetros (30%).",
                                "Correção no cálculo de log_b a (25%).",
                                "Validação rigorosa da condição Caso 1 com ε (25%).",
                                "Clareza na conclusão e notação Θ (10%).",
                                "Ausência de erros comuns e justificativas lógicas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de logaritmos e análise assintótica.",
                                "Física: Modelagem recursiva em sistemas dinâmicos e fractais.",
                                "Engenharia de Software: Otimização de algoritmos divide-and-conquer."
                              ],
                              "realWorldApplication": "Analisar o tempo de execução de algoritmos como variantes do Strassen para multiplicação de matrizes ou mergesort multi-via, prevendo escalabilidade em big data e ajudando a escolher implementações eficientes em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Casos 2 e 3 do Teorema Mestre",
                        "description": "Condições para Caso 2: f(n) = Θ(n^{log_b a} log^k n) com T(n) = Θ(n^{log_b a} log^{k+1} n); Caso 3: f(n) = Ω(n^{log_b a + ε}) com regularidade af(n)/n^{log_b a} ≤ c < 1, resultando em T(n) = Θ(f(n)).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Aplicar condições do Caso 2",
                            "description": "Identificar quando f(n) = Θ(n^{log_b a} (log n)^k) para k ≥ 0, e concluir T(n) = Θ(n^{log_b a} (log n)^{k+1}), com exemplos como Merge Sort T(n) = 2T(n/2) + n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teorema Mestre e Condições Específicas do Caso 2",
                                  "subSteps": [
                                    "Relembre a forma geral da recorrência: T(n) = a T(n/b) + f(n), com a ≥ 1, b > 1.",
                                    "Identifique os parâmetros a, b e f(n) em uma recorrência dada.",
                                    "Recite as condições do Caso 2: f(n) = Θ(n^{log_b a} (log_b n)^k) para algum k ≥ 0.",
                                    "Compare f(n) com n^{log_b a} (log_b n)^k, calculando log_b a = log a / log b.",
                                    "Anote exemplos onde k=0 (limite com Caso 1) e k>0."
                                  ],
                                  "verification": "Escreva as condições exatas do Caso 2 de memória e calcule log_b a para a=2, b=2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de anotações do Teorema Mestre",
                                    "Calculadora para logaritmos"
                                  ],
                                  "tips": "Use log_b n = ln n / ln b para precisão; pratique com base 2 comum em CS.",
                                  "learningObjective": "Dominar a identificação precisa das condições do Caso 2.",
                                  "commonMistakes": "Confundir com Caso 1 (onde f(n) = Θ(n^{log_b a}) sem fator log); ignorar k ≥ 0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar se uma Recorrência Satisfaz o Caso 2",
                                  "subSteps": [
                                    "Extraia a, b e f(n) de uma recorrência exemplo, como T(n) = 2T(n/2) + n log n.",
                                    "Calcule log_b a e expresse f(n) em termos de n^{log_b a} (log_b n)^k.",
                                    "Para o exemplo: log_2 2 = 1, f(n) = n (log_2 n)^1, então k=1.",
                                    "Verifique se f(n)/[n^{log_b a} (log_b n)^k] é Θ(1).",
                                    "Classifique recorrências: Caso 1, 2 ou 3."
                                  ],
                                  "verification": "Classifique 3 recorrências dadas (ex: Merge Sort como Caso 1 para contraste).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 5 recorrências de exemplo",
                                    "Gráfica de funções assintóticas (opcional)"
                                  ],
                                  "tips": "Plote log f(n) vs log n para visualizar o polinômio logarítmico.",
                                  "learningObjective": "Habilidade em extrair e comparar f(n) com a forma do Caso 2.",
                                  "commonMistakes": "Esquecer de usar log_b n (não log qualquer base); confundir log n com ln n."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Fórmula de Solução do Caso 2",
                                  "subSteps": [
                                    "Uma vez confirmado Caso 2, aplique T(n) = Θ(n^{log_b a} (log_b n)^{k+1}).",
                                    "Para exemplo T(n)=2T(n/2)+n log n: Θ(n (log n)^2).",
                                    "Simplifique expressões, trocando base de logaritmo se necessário (log_b n = log_2 n / log_2 b).",
                                    "Escreva a solução em notação Θ com base comum (geralmente log_2).",
                                    "Compare com soluções exatas ou simulações para validação."
                                  ],
                                  "verification": "Resolva 2 recorrências do Caso 2 e justifique o k usado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de identidades logarítmicas",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Lembre: o expoente de log aumenta em +1, preservando o n^{log_b a}.",
                                  "learningObjective": "Aplicar corretamente a conclusão assintótica do Caso 2.",
                                  "commonMistakes": "Erros em k+1 (esquecer +1); notação inconsistente de log."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Verificar com Exemplos e Contraexemplos",
                                  "subSteps": [
                                    "Resolva T(n)=3T(n/3)+n^{log_3 3} log_3 n = 3T(n/3)+n log_3 n (Caso 2, k=1).",
                                    "Teste limites: se k=-1, cai para Caso 1; se f(n) muito maior, Caso 3.",
                                    "Implemente uma recorrência simples em código e meça tempos para validar Θ.",
                                    "Crie um contraexemplo que parece Caso 2 mas não é.",
                                    "Discuta por que Merge Sort (T(n)=2T(n/2)+n) é Caso 1 (k=0)."
                                  ],
                                  "verification": "Resolva uma recorrência inédita e explique passos em voz alta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código (Python recursivo)",
                                    "Cronômetro para testes empíricos"
                                  ],
                                  "tips": "Use memoização em código para evitar explosão recursiva em testes.",
                                  "learningObjective": "Consolidar aplicação através de prática iterativa.",
                                  "commonMistakes": "Aplicar Caso 2 a Merge Sort (é Caso 1); ignorar constantes em Θ."
                                }
                              ],
                              "practicalExample": "Para T(n) = 2T(n/2) + n log_2 n: a=2, b=2, log_b a=1, f(n)=n (log_2 n)^1 = Θ(n^1 (log_2 n)^1), k=1. Logo, T(n) = Θ(n (log_2 n)^{2}). Isso modela algoritmos de ordenação avançados com custo extra logarítmico.",
                              "finalVerifications": [
                                "Corretamente identifica k em f(n) para 3 recorrências do Caso 2.",
                                "Deriva T(n) = Θ(n^{log_b a} (log_b n)^{k+1}) sem erros aritméticos.",
                                "Distingue Caso 2 de Caso 1 usando Merge Sort como exemplo.",
                                "Valida solução com gráfico assintótico ou teste empírico.",
                                "Explica impacto do +1 no expoente de log em complexidade.",
                                "Cria uma recorrência original que se encaixa no Caso 2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de a, b, f(n) e cálculo de log_b a (100% correto).",
                                "Identificação correta de k ≥ 0 e confirmação Θ(1) ratio.",
                                "Aplicação exata da fórmula de solução sem variações no expoente.",
                                "Uso consistente de notação assintótica e bases logarítmicas.",
                                "Profundidade em justificativas e distinção de casos vizinhos.",
                                "Criatividade em exemplos práticos e verificações empíricas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica, logaritmos e limites (cálculo).",
                                "Estatística: Modelagem de crescimento em dados grandes (Big O em ML).",
                                "Engenharia de Software: Otimização de recursão em árvores e grafos.",
                                "Física Computacional: Simulações recursivas em fractais e dinâmica."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, aplica-se para analisar Merge Sort modificado com custo n log n (ex: ordenação externa em bancos de dados), otimizando consultas em Big Data no Google ou AWS, onde (log n)^2 impacta escalabilidade em petabytes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Aplicar condições do Caso 3",
                            "description": "Verificar f(n) = Ω(n^{log_b a + ε}) para ε > 0 e a condição de regularidade af(n)/n^{log_b a} ≤ c f(n) para c < 1 e a ≥ 1, concluindo T(n) = Θ(f(n)), como em T(n) = T(n/2) + n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os parâmetros da recorrência",
                                  "subSteps": [
                                    "Escrever a equação de recorrência na forma padrão T(n) = a T(n/b) + f(n).",
                                    "Extrair o valor de a (número de subproblemas recursivos).",
                                    "Identificar b (fator de divisão do tamanho do problema).",
                                    "Isolar f(n) (custo do trabalho fora da recursão).",
                                    "Confirmar que a ≥ 1 e b > 1."
                                  ],
                                  "verification": "Verificar se a, b e f(n) foram corretamente extraídos comparando com a equação original.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de recorrência T(n) = T(n/2) + n",
                                    "Calculadora para logs se necessário"
                                  ],
                                  "tips": "Sempre assuma n grande e foque em comportamento assintótico.",
                                  "learningObjective": "Reconhecer e nomear corretamente os componentes do Teorema Mestre.",
                                  "commonMistakes": "Confundir f(n) com o termo recursivo ou errar o valor de a/b."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular log_b a e preparar comparação assintótica",
                                  "subSteps": [
                                    "Calcular log_b a usando logaritmo na base b de a (ou mudança de base: ln(a)/ln(b)).",
                                    "Computar n^{log_b a} como referência polinomial.",
                                    "Escolher um ε > 0 pequeno (ex: 0.1 ou baseado no crescimento de f(n)).",
                                    "Comparar o grau polinomial de f(n) com log_b a + ε.",
                                    "Verificar se f(n) cresce mais rápido que n^{log_b a}."
                                  ],
                                  "verification": "Confirmar cálculo de log_b a com uma calculadora ou tabela de logs e anotar o valor exato.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de logaritmos",
                                    "Gráfico assintótico opcional"
                                  ],
                                  "tips": "Use aproximações para logs se exatos forem difíceis; foque em desigualdades.",
                                  "learningObjective": "Dominar o cálculo de log_b a e entender seu papel como 'custo recursivo' assintótico.",
                                  "commonMistakes": "Erro no cálculo de log (ex: confundir base) ou escolher ε ≤ 0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a condição de dominância f(n) = Ω(n^{log_b a + ε})",
                                  "subSteps": [
                                    "Provar que f(n) / n^{log_b a + ε} → ∞ quando n → ∞.",
                                    "Para f(n) polinomial, comparar expoentes diretamente.",
                                    "Usar limites ou L'Hôpital se necessário para funções mais complexas.",
                                    "Documentar o valor de ε escolhido e justificar por quê > 0.",
                                    "Anotar a notação Ω explicitamente."
                                  ],
                                  "verification": "Resolver lim_{n→∞} f(n) / n^{log_b a + ε} = ∞ ou ≥ k > 0 para algum k.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel para limites",
                                    "Software como Wolfram Alpha para verificação"
                                  ],
                                  "tips": "Comece com ε pequeno; aumente se f(n) crescer muito mais rápido.",
                                  "learningObjective": "Aplicar notação Ω corretamente em contextos polinomiais.",
                                  "commonMistakes": "Usar O em vez de Ω ou ignorar o limite assintótico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a condição de regularidade",
                                  "subSteps": [
                                    "Calcular a f(n/b) explicitamente.",
                                    "Encontrar c < 1 tal que a f(n/b) ≤ c f(n) para n suficientemente grande.",
                                    "Testar com valores assintóticos ou simplificar f(n/b).",
                                    "Verificar para múltiplos n grandes e generalizar.",
                                    "Confirmar que a ≥ 1 (geralmente verdadeiro)."
                                  ],
                                  "verification": "Exibir desigualdade a f(n/b) ≤ c f(n) com c explícito (ex: c=0.6) e n0.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Exemplo numérico com n=1000",
                                    "Gráfico de f(n) vs f(n/b)"
                                  ],
                                  "tips": "Para f(n)=n^k, verifica facilmente: a (n/b)^k = a b^{-k} n^k ≤ c n^k com c = a/b^k <1.",
                                  "learningObjective": "Entender regularidade como 'f(n) não oscila demais na recursão'.",
                                  "commonMistakes": "Escolher c ≥1 ou falhar em n grande (testar n pequenos engana)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir a aplicação do Caso 3",
                                  "subSteps": [
                                    "Confirmar ambas condições: dominância e regularidade.",
                                    "Escrever T(n) = Θ(f(n)).",
                                    "Explicar intuitivamente por quê (trabalho recursivo negligenciável).",
                                    "Testar com o exemplo completo.",
                                    "Resumir em uma caixa de conclusão."
                                  ],
                                  "verification": "Ambas condições ✓ e conclusão Θ(f(n)) justificada.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Resumo da recorrência"
                                  ],
                                  "tips": "Só conclua Θ(f(n)) se AMBAS condições passarem.",
                                  "learningObjective": "Integrar todas as partes para solução completa do Teorema Mestre Caso 3.",
                                  "commonMistakes": "Concluir sem regularidade ou trocar com Caso 1."
                                }
                              ],
                              "practicalExample": "Para T(n) = T(n/2) + n: a=1, b=2, log_2 1=0. f(n)=n = Ω(n^{0+1}) com ε=1>0 (n/n^1 →1, mas ajusta para ∞ com ε<1). Regularidade: 1*f(n/2)=n/2 ≤ 0.6 n (c=0.6<1). Logo T(n)=Θ(n).",
                              "finalVerifications": [
                                "log_b a calculado corretamente.",
                                "ε > 0 explicitamente identificado e justificado.",
                                "f(n) = Ω(n^{log_b a + ε}) provada via limite.",
                                "Condição de regularidade com c < 1 e n0 especificados.",
                                "Conclusão T(n) = Θ(f(n)) sem ambiguidades.",
                                "Exemplo testado numericamente para n grande."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa de a, b, f(n): 20%.",
                                "Cálculo correto de log_b a e ε: 20%.",
                                "Prova rigorosa de dominância Ω: 25%.",
                                "Verificação completa de regularidade: 25%.",
                                "Conclusão e justificativa clara: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica, limites e logaritmos.",
                                "Matemática Discreta: Recorrências lineares e inequações.",
                                "Física: Modelos recursivos em fractais ou simulações.",
                                "Engenharia de Software: Otimização de algoritmos divide-and-conquer."
                              ],
                              "realWorldApplication": "Em análise de algoritmos como merge sort modificado ou buscas em árvores desbalanceadas, onde o custo de merge domina, permitindo prever tempo de execução Θ(n) para grandes datasets em big data ou machine learning."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Classificar recorrências em casos e resolver",
                            "description": "Dada uma recorrência, determinar qual caso se aplica (1, 2 ou 3), calcular a solução assintótica e validar com exemplos de algoritmos de divide-and-conquer.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teorema Mestre e identificar os três casos",
                                  "subSteps": [
                                    "Lembre a forma geral: T(n) = a T(n/b) + f(n), onde a ≥ 1, b > 1.",
                                    "Defina p = log_b a.",
                                    "Descreva Caso 1: se f(n) = O(n^{p - ε}) para ε > 0, então T(n) = Θ(n^p).",
                                    "Descreva Caso 2: se f(n) = Θ(n^p log^k n) para k ≥ 0, então T(n) = Θ(n^p log^{k+1} n).",
                                    "Descreva Caso 3: se f(n) = Ω(n^{p + ε}) para ε > 0 e af(n) ≤ c f(n) para c < 1 e n grande, então T(n) = Θ(f(n))."
                                  ],
                                  "verification": "Escreva um resumo dos três casos com as condições exatas em um papel ou documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de anotações, calculadora para logaritmos, referência do Teorema Mestre (livro ou PDF).",
                                  "tips": "Use tabelas para comparar os casos visualmente.",
                                  "learningObjective": "Compreender precisamente as condições de cada caso do Teorema Mestre.",
                                  "commonMistakes": "Confundir os expoentes ou ignorar a condição de regularidade no Caso 3."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a recorrência dada e extrair parâmetros",
                                  "subSteps": [
                                    "Identifique a, b e f(n) da recorrência T(n) = a T(n/b) + f(n).",
                                    "Calcule p = log_b a usando logaritmo (ex: log2 3 ≈ 1.585).",
                                    "Compare o crescimento de f(n) com n^p (use limites ou ordens assintóticas).",
                                    "Verifique se f(n) satisfaz as condições polinomiais ou logarítmicas.",
                                    "Anote se há termos log^k n em f(n)."
                                  ],
                                  "verification": "Liste a, b, f(n), p e uma comparação qualitativa f(n) vs n^p.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora científica, tabela de logaritmos, software como Wolfram Alpha para cálculos.",
                                  "tips": "Padronize n/b para frações exatas; assuma divisibilidade perfeita.",
                                  "learningObjective": "Extrair e computar corretamente os parâmetros chave da recorrência.",
                                  "commonMistakes": "Erro no cálculo de log_b a (use log a / log b), ou não simplificar f(n)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar o caso e resolver a recorrência",
                                  "subSteps": [
                                    "Compare f(n) com n^p para determinar Caso 1, 2 ou 3.",
                                    "Para Caso 1: escreva T(n) = Θ(n^p).",
                                    "Para Caso 2: identifique k e escreva T(n) = Θ(n^p log^{k+1} n).",
                                    "Para Caso 3: verifique regularidade af(n) ≤ c f(n) e escreva T(n) = Θ(f(n)).",
                                    "Simplifique a notação big-O/Θ final."
                                  ],
                                  "verification": "Escreva a classificação (ex: 'Caso 2 com k=0') e a solução assintótica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para desenhar árvore de recursão opcional, calculadora.",
                                  "tips": "Teste com ε pequeno (0.1) para borderline cases.",
                                  "learningObjective": "Aplicar corretamente a fórmula do caso identificado.",
                                  "commonMistakes": "Classificar errado Caso 2 vs 3 por não notar logs, ou esquecer k+1 no Caso 2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a solução com exemplos de divide-and-conquer",
                                  "subSteps": [
                                    "Escolha um algoritmo divide-and-conquer com recorrência similar (ex: Merge Sort para Caso 2).",
                                    "Expanda manualmente a recorrência para pequenos n e compare com a solução assintótica.",
                                    "Calcule T(n) para n=2^k e veja se matches Θ da solução.",
                                    "Discuta por que a classificação faz sentido no contexto do algoritmo.",
                                    "Teste com uma recorrência de Caso 3, como busca em matriz ordenada."
                                  ],
                                  "verification": "Mostre pelo menos dois exemplos onde a solução bate com o comportamento esperado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de algoritmos (Merge Sort, Strassen Matrix Mult), simulador de recursão online.",
                                  "tips": "Use n=8,16 para expansão manual sem fadiga.",
                                  "learningObjective": "Conectar teoria a prática via validação empírica.",
                                  "commonMistakes": "Usar algoritmo do caso errado ou não expandir o suficiente."
                                }
                              ],
                              "practicalExample": "Para T(n) = 2 T(n/2) + n (Merge Sort): a=2, b=2, p=1, f(n)=n = Θ(n^1 log^0 n), Caso 2 k=0, T(n)=Θ(n log n). Valide expandindo: T(1)=1, T(2)=3, T(4)=7, T(8)=15, que cresce como n log n.",
                              "finalVerifications": [
                                "Classificação correta do caso (1,2 ou 3) para recorrências dadas.",
                                "Solução assintótica exata em Θ notation.",
                                "Verificação da condição de regularidade se Caso 3.",
                                "Validação com pelo menos um algoritmo divide-and-conquer.",
                                "Expansão manual para n pequeno bate com assintótica.",
                                "Identificação correta de k no Caso 2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de a, b, f(n) e p (100% correto).",
                                "Classificação do caso justificada com comparações assintóticas.",
                                "Aplicação correta da fórmula sem erros aritméticos.",
                                "Validação robusta com exemplos numéricos e algorítmicos.",
                                "Explicação clara de porquês em linguagem técnica.",
                                "Tratamento de casos borderline com ε adequado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de logaritmos e análise assintótica (limites L'Hôpital).",
                                "Algoritmos: Implementação de divide-and-conquer em programação.",
                                "Matemática Discreta: Árvores de recursão e somas geométricas.",
                                "Engenharia de Software: Análise de performance e Big-O em projetos."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos como ordenação (Merge Sort, Caso 2) ou multiplicação de matrizes (Strassen, Caso 2), permitindo prever tempo de execução em big data, essencial para IA, bancos e computação científica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.3",
                              "10.1.2.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.6",
                    "name": "Técnica de Emparelhamento",
                    "description": "Identificação de padrões em recorrências para simplificar sua resolução.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.6.1",
                        "name": "Definição da Técnica de Emparelhamento",
                        "description": "Compreender os fundamentos da técnica de emparelhamento como método para identificar padrões em relações de recorrência, facilitando a simplificação e resolução.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.1.1",
                            "name": "Explicar o conceito de emparelhamento em recorrências",
                            "description": "Descrever a técnica de emparelhamento como a estratégia de agrupar termos semelhantes em expansões de recorrências recursivas para revelar padrões telescópicos ou cancelamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição Básica de Emparelhamento em Recorrências",
                                  "subSteps": [
                                    "Leia a definição: Emparelhamento é agrupar termos semelhantes na expansão de uma recorrência para identificar padrões telescópicos ou cancelamentos.",
                                    "Compare com expansões lineares sem emparelhamento, notando a complexidade.",
                                    "Identifique recorrências candidatas, como T(n) = T(n-1) + T(n-2).",
                                    "Anote exemplos onde cancelamentos ocorrem, como em somas alternadas.",
                                    "Discuta verbalmente com um parceiro o que 'telescópico' significa."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e dê um exemplo simples de cancelamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'cancelar frações em soma' para visualizar.",
                                  "learningObjective": "Compreender o conceito fundamental e sua motivação.",
                                  "commonMistakes": [
                                    "Confundir com substituição direta",
                                    "Ignorar o papel do agrupamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir uma Recorrência Simples Manualmente",
                                  "subSteps": [
                                    "Escolha uma recorrência linear: T(n) = 2T(n-1) + 1.",
                                    "Expanda iterativamente até T(1): escreva T(n), T(n-1), ..., T(1).",
                                    "Conte os termos resultantes e observe o padrão sem agrupar.",
                                    "Registre o número total de termos antes do emparelhamento.",
                                    "Desenhe a expansão em uma árvore ou lista numerada."
                                  ],
                                  "verification": "Mostre a expansão completa com pelo menos 5 iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para contagens"
                                  ],
                                  "tips": "Comece com n pequeno (ex: n=5) para praticar antes de generalizar.",
                                  "learningObjective": "Dominar a expansão iterativa de recorrências.",
                                  "commonMistakes": [
                                    "Erros aritméticos na expansão",
                                    "Parar expansão prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Emparelhamento e Identificar Padrões",
                                  "subSteps": [
                                    "Agrupe termos idênticos ou opostos na expansão do Step 2.",
                                    "Destaque pares que cancelam (ex: +1 e -1).",
                                    "Reescreva a soma agrupada, revelando o padrão telescópico.",
                                    "Calcule o valor fechado para n=10 e verifique numericamente.",
                                    "Generalize para n arbitrário, identificando termos residuais."
                                  ],
                                  "verification": "Apresente a forma agrupada e o resultado simplificado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel",
                                    "Exemplo impresso de recorrência Fibonacci"
                                  ],
                                  "tips": "Use cores diferentes para pares de termos para visualização.",
                                  "learningObjective": "Executar emparelhamento para simplificação.",
                                  "commonMistakes": [
                                    "Agrupar incorretamente termos não semelhantes",
                                    "Perder termos boundary"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Generalizar o Conceito",
                                  "subSteps": [
                                    "Teste com outra recorrência: T(n) = T(n-2) + n.",
                                    "Aplique emparelhamento e derive a solução fechada.",
                                    "Compare tempo de cálculo com e sem emparelhamento.",
                                    "Explique limitações (ex: não linearidades).",
                                    "Crie um fluxograma do processo completo."
                                  ],
                                  "verification": "Resolva uma nova recorrência e explique o processo em 1 parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook ou software como Python para verificação numérica"
                                  ],
                                  "tips": "Valide com computação para n grande onde manual falha.",
                                  "learningObjective": "Generalizar a técnica e reconhecer aplicações.",
                                  "commonMistakes": [
                                    "Aplicar em recorrências não adequadas",
                                    "Ignorar condições iniciais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para T(n) = T(n-1) + T(n-2) com T(1)=1, T(2)=1 (Fibonacci modificado), expanda: T(n) = [T(n-2)+T(n-3)] + [T(n-3)+T(n-4)] + ... Agrupe pares T(k) + T(k-1) para telescopar em T(n) + T(n-1) - T(1) - T(0), revelando O(φ^n).",
                              "finalVerifications": [
                                "Explicar verbalmente emparelhamento sem consultar notas.",
                                "Resolver uma recorrência desconhecida usando a técnica em <5 min.",
                                "Identificar padrões telescópicos em expansões dadas.",
                                "Diferenciar emparelhamento de outras métodos (substituição, generating functions).",
                                "Aplicar em recorrência não-linear e notar falha."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e motivação (20%)",
                                "Correção na expansão e agrupamento (30%)",
                                "Capacidade de generalização para novas recorrências (20%)",
                                "Identificação de erros comuns e limitações (15%)",
                                "Clareza na comunicação do processo (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries telescópicas e somas infinitas.",
                                "Física: Modelagem de oscilações com recorrências lineares.",
                                "Engenharia: Análise de sistemas de controle recursivos.",
                                "Economia: Modelos de crescimento exponencial com cancelamentos."
                              ],
                              "realWorldApplication": "Em análise de algoritmos divide-and-conquer como MergeSort, emparelhamento resolve T(n)=2T(n/2)+n para O(n log n), essencial para otimizar código em big data e machine learning."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.2",
                            "name": "Identificar quando usar emparelhamento",
                            "description": "Reconhecer cenários em que a técnica de emparelhamento é aplicável, como em recorrências lineares não homogêneas ou com coeficientes específicos que permitem pareamento de termos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de recorrências lineares homogêneas e não homogêneas",
                                  "subSteps": [
                                    "Estude a forma geral de uma recorrência linear: T(n) = a1 T(n-1) + ... + ak T(n-k) + f(n).",
                                    "Diferencie recorrências homogêneas (f(n)=0) das não homogêneas (f(n) ≠ 0).",
                                    "Analise exemplos simples como T(n) = 2T(n-1) + 1.",
                                    "Identifique a ordem da recorrência e os coeficientes constantes.",
                                    "Pratique expandindo 2-3 recorrências manualmente para n pequeno."
                                  ],
                                  "verification": "Capacidade de classificar corretamente 5 recorrências dadas como homogêneas ou não homogêneas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise de Algoritmos (ex: CLRS), vídeo introdutório sobre recorrências no YouTube.",
                                  "tips": "Anote a estrutura geral em um papel para visualização rápida.",
                                  "learningObjective": "Dominar a identificação básica de tipos de recorrências lineares.",
                                  "commonMistakes": "Confundir termos homogêneos com o termo forçante f(n); ignorar coeficientes variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar métodos padrão de solução de recorrências",
                                  "subSteps": [
                                    "Revise o método da equação característica para homogêneas.",
                                    "Aprenda variação de parâmetros e solução particular para não homogêneas.",
                                    "Identifique limitações: quando f(n) é polinomial, exponencial ou senoidal.",
                                    "Compare com métodos de substituição e árvore de recursão.",
                                    "Liste cenários onde métodos padrão falham ou são ineficientes."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que um método não se aplica a uma recorrência específica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "CLRS capítulo 4, Khan Academy ou MIT OCW vídeos sobre recorrências.",
                                  "tips": "Use tabelas para comparar métodos e suas aplicabilidades.",
                                  "learningObjective": "Reconhecer quando métodos padrão são insuficientes, abrindo espaço para emparelhamento.",
                                  "commonMistakes": "Assumir que todo método funciona para qualquer f(n); pular verificação da forma de f(n)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar padrões específicos para emparelhamento",
                                  "subSteps": [
                                    "Procure recorrências com coeficientes que permitam cancelamento de termos na expansão (ex: T(n) = T(n-1) + T(n-2) + c).",
                                    "Reconheça casos onde f(n) é constante ou linear e coeficientes são 1 ou -1 para pareamento.",
                                    "Analise recorrências não homogêneas lineares com termos pareáveis como em somas telescópicas.",
                                    "Examine exemplos: T(n) = 2T(n-1) - T(n-2) + 1, onde termos se emparelham.",
                                    "Crie uma checklist: coeficientes constantes? f(n) simples? Possível telescoping?"
                                  ],
                                  "verification": "Classifique 5 recorrências como 'aplicável a emparelhamento' ou não, justificando.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folhas de exercícios de recorrências, calculadora simbólica como Wolfram Alpha.",
                                  "tips": "Expanda a recorrência para n=5-10 termos e procure padrões de pareamento visualmente.",
                                  "learningObjective": "Detectar precisamente cenários onde emparelhamento simplifica a soma.",
                                  "commonMistakes": "Aplicar emparelhamento em recorrências de ordem alta sem coeficientes pareáveis; ignorar raízes múltiplas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar diferenciação com contra-exemplos e síntese",
                                  "subSteps": [
                                    "Resolva 3 recorrências usando emparelhamento onde aplicável.",
                                    "Tente (e falhe propositalmente) emparelhamento em casos inadequados, como f(n)=n^2 com coeficientes arbitrários.",
                                    "Crie uma tabela de decisão: se/else para escolher técnica.",
                                    "Aplique em contextos de algoritmos (ex: análise de mergesort variante).",
                                    "Revise e refine sua checklist pessoal."
                                  ],
                                  "verification": "Resolva um problema novo corretamente identificando uso de emparelhamento em <5 minutos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exercícios personalizados ou LeetCode/HackerRank problemas de análise.",
                                  "tips": "Registre tempo gasto em identificação vs. resolução para otimizar.",
                                  "learningObjective": "Sintetizar critérios decisórios para uso de emparelhamento vs. outras técnicas.",
                                  "commonMistakes": "Generalizar demais: nem todo pareamento funciona em ordem >2; confundir com método de geração."
                                }
                              ],
                              "practicalExample": "Na recorrência T(n) = T(n-1) + T(n-2) + 1 com T(1)=1, T(2)=1, expanda: os termos +1 se emparelham com subtrações nas expansões de T(n-1) e T(n-2), levando a uma soma telescópica simples T(n) ≈ 2F(n) - n, onde F é Fibonacci modificado. Identifique: coeficientes 1 e 1 permitem pareamento direto do termo constante.",
                              "finalVerifications": [
                                "Classifica corretamente 90% de 10 recorrências como aplicáveis ou não a emparelhamento.",
                                "Explica o motivo de pareamento em 3 exemplos com expansão manual.",
                                "Diferencia emparelhamento de telescoping puro e variação de parâmetros.",
                                "Aplica checklist em um problema real de algoritmo sem erros.",
                                "Resolve recorrência pareável em tempo < equação característica.",
                                "Identifica limitações em recorrências com coeficientes variáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões pareáveis (80% acerto).",
                                "Justificativa clara com referência a coeficientes e f(n).",
                                "Uso correto de expansão para visualização de pareamento.",
                                "Diferenciação de cenários inadequados sem hesitação.",
                                "Eficiência: tempo de decisão <2 minutos por recorrência.",
                                "Integração com contexto algorítmico (ex: complexidade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries telescópicas e somas fechadas.",
                                "Álgebra Linear: Sistemas de diferenças lineares.",
                                "Física: Modelos discretos de sistemas dinâmicos recursivos.",
                                "Engenharia de Software: Análise de performance em recursão memoizada."
                              ],
                              "realWorldApplication": "Em análise de algoritmos divide-and-conquer como quicksort com pivot médio, onde recorrências com overheads lineares permitem emparelhamento para provar O(n log n), otimizando decisões de implementação em sistemas de grande escala."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.3",
                            "name": "Diferenciar emparelhamento de outros métodos",
                            "description": "Comparar a técnica de emparelhamento com substituição, teorema mestre e árvore de recorrência, destacando suas vantagens em padrões específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os métodos alternativos de resolução de recorrências",
                                  "subSteps": [
                                    "Estude a técnica de substituição: identifique como adivinhar a forma fechada e provar por indução matemática.",
                                    "Revise o Teorema Mestre: memorize as três formas (a > b^d, a = b^d, a < b^d) e exemplos de aplicação em divide-and-conquer.",
                                    "Analise a árvore de recorrência: aprenda a desenhar a árvore de chamadas e calcular o custo total somando níveis.",
                                    "Liste recorrências resolvidas por cada método com exemplos simples (ex: T(n) = 2T(n/2) + n para Teorema Mestre).",
                                    "Identifique limitações iniciais: quando cada método falha (ex: substituição requer palpite correto)."
                                  ],
                                  "verification": "Crie uma tabela comparativa resumindo definição, exemplo e limitação de cada método.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to Algorithms' (CLRS), notas de aula sobre análise de algoritmos, papel e caneta para diagramas.",
                                  "tips": "Use cores diferentes para cada método na tabela para facilitar a visualização.",
                                  "learningObjective": "Dominar os conceitos fundamentais dos métodos de substituição, Teorema Mestre e árvore de recorrência.",
                                  "commonMistakes": "Confundir o caso a = b^d do Teorema Mestre com logarítmico sem considerar o polilog."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a definição e mecânica da técnica de emparelhamento",
                                  "subSteps": [
                                    "Defina emparelhamento: técnica para recorrências onde termos são agrupados em pares para telescopar a soma (ex: T(n) = T(n/2) + T(n/2 + 1) + c).",
                                    "Estude exemplos básicos: resolva T(n) = T(floor(n/2)) + T(ceil(n/2)) + 1 mostrando como pares cancelam.",
                                    "Desenhe a recursão gráfica: represente chamadas como uma árvore balanceada e agrupe folhas por pares.",
                                    "Pratique derivação: transforme a recorrência em soma e aplique emparelhamento para obter O(n).",
                                    "Compare intuitivamente com métodos lineares: note como evita expansão total da árvore."
                                  ],
                                  "verification": "Resolva manualmente uma recorrência simples por emparelhamento e verifique se obtém forma fechada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de papel quadriculado para desenhar árvores, calculadora para somas, vídeo tutorial sobre emparelhamento em YouTube.",
                                  "tips": "Sempre comece agrupando os termos mais profundos da recursão para visualizar o telescoping.",
                                  "learningObjective": "Entender como o emparelhamento explora simetria em recorrências não padrão.",
                                  "commonMistakes": "Ignorar o floor/ceil nas divisões, levando a contas inexatas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar diferenças chave entre emparelhamento e os outros métodos",
                                  "subSteps": [
                                    "Crie uma matriz de comparação: colunas para cada método, linhas para critérios (tipo de recorrência, complexidade de prova, automação).",
                                    "Analise aplicabilidade: substituição para formas exatas, Mestre para balanced divide-conquer, árvore para desbalanceadas, emparelhamento para quasi-balanceadas.",
                                    "Destaque mecânicas únicas: indução vs. casos assintóticos vs. soma de árvore vs. agrupamento de termos.",
                                    "Teste com recorrência híbrida: aplique todos os métodos em T(n) = T(n/2) + T(n/2 + 1) + n e note falhas.",
                                    "Registre similaridades: todos visam forma fechada, mas emparelhamento é mais 'geométrico'."
                                  ],
                                  "verification": "Preencha a matriz de comparação e explique verbalmente uma diferença para cada par de métodos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Google Sheets para matriz, exemplos de recorrências impressos.",
                                  "tips": "Use setas na matriz para mostrar 'melhor que' em cenários específicos.",
                                  "learningObjective": "Identificar distinções precisas entre os quatro métodos.",
                                  "commonMistakes": "Equiparar árvore de recorrência a emparelhamento, ambos visuais mas um expande tudo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar vantagens do emparelhamento em padrões específicos",
                                  "subSteps": [
                                    "Identifique padrões ideais: recorrências com chamadas simétricas como floor/ceil(n/2) ou Fibonacci-like.",
                                    "Compare eficiência: emparelhamento dá O(n) rápido vs. árvore que pode ser O(n log n) em desenho.",
                                    "Analise cenários: vantagem em quicksort médio, mergesort variants, onde outros métodos complicam.",
                                    "Pratique escolha: dado uma recorrência, justifique por que emparelhamento é superior.",
                                    "Sintetize regras: use emparelhamento quando há paridade ou simetria não capturada por Mestre."
                                  ],
                                  "verification": "Selecione 3 recorrências e classifique o melhor método com justificativa para cada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Lista de 10 recorrências de teste (criar ou buscar online), timer para prática.",
                                  "tips": "Memorize: 'Emparelhamento brilha em desbalanceamentos leves que telescopam'.",
                                  "learningObjective": "Saber quando e por quê escolher emparelhamento sobre alternativas.",
                                  "commonMistakes": "Superestimar Teorema Mestre para recorrências não-divide-conquer puras."
                                }
                              ],
                              "practicalExample": "Considere a recorrência do quicksort no pior caso médio: T(n) = T(floor(n/2)) + T(ceil(n/2)) + n. Substituição falha sem palpite, Mestre não aplica diretamente (não balanced), árvore expande para O(n^2). Emparelhamento agrupa pares de folhas, telescopando para T(n) = O(n log n), provando eficiência prática.",
                              "finalVerifications": [
                                "Explique verbalmente as diferenças sem consultar notas.",
                                "Resolva uma recorrência híbrida usando o método correto.",
                                "Classifique corretamente 5 recorrências dadas entre os 4 métodos.",
                                "Identifique vantagem do emparelhamento em um exemplo real.",
                                "Crie uma recorrência onde emparelhamento é essencial.",
                                "Debata com um par: convença sobre superioridade em um caso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de cada método (90% correto).",
                                "Capacidade de comparação lado a lado sem erros factuais.",
                                "Identificação correta de vantagens em pelo menos 80% dos padrões.",
                                "Uso adequado de terminologia técnica (floor/ceil, telescoping).",
                                "Profundidade na justificativa de escolhas de método.",
                                "Clareza na explicação de exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries infinitas e telescoping sums.",
                                "Matemática Discreta: Prova por indução e recorrências lineares.",
                                "Engenharia de Software: Análise assintótica de performance em código recursivo.",
                                "Física Computacional: Modelagem de sistemas dinâmicos recursivos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de algoritmos eficientes como quicksort otimizado ou análise de cache em processadores, onde emparelhamento revela complexidades reais O(n log n) em cenários desbalanceados, guiando otimizações em big data e machine learning."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.2",
                        "name": "Identificação de Padrões em Recorrências",
                        "description": "Aprender a expandir recorrências e detectar padrões emparelháveis para simplificar expressões complexas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.2.1",
                            "name": "Expandir uma recorrência recursivamente",
                            "description": "Realizar a expansão manual de uma relação de recorrência, como T(n) = a T(n/b) + f(n), até visualizar múltiplos níveis e identificar repetições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e preparar a recorrência inicial",
                                  "subSteps": [
                                    "Leia a recorrência fornecida, como T(n) = a T(n/b) + f(n)",
                                    "Identifique os parâmetros chave: coeficiente a, divisor b e função de custo f(n)",
                                    "Anote as condições base, se disponíveis (ex: T(1) = c)",
                                    "Escreva a expansão nível 0: T(n) = a T(n/b) + f(n)",
                                    "Confirme que n é potência de b para simplificação (assuma log_b n inteiro)"
                                  ],
                                  "verification": "Liste corretamente a, b, f(n) e escreva o nível 0 sem erros",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para logs",
                                    "Exemplo de recorrência impresso"
                                  ],
                                  "tips": [
                                    "Use notação clara com subscritos para níveis",
                                    "Assuma n = b^k para visualização fácil"
                                  ],
                                  "learningObjective": "Identificar componentes da recorrência e preparar expansão manual",
                                  "commonMistakes": [
                                    "Confundir a com b",
                                    "Ignorar condições base",
                                    "Escrever f(n) incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir o primeiro nível recursivo",
                                  "subSteps": [
                                    "Substitua o primeiro T(n/b) pela definição: T(n/b) = a T(n/b^2) + f(n/b)",
                                    "Multiplique pelo coeficiente a: a * [a T(n/b^2) + f(n/b)]",
                                    "Some o termo original f(n)",
                                    "Simplifique: T(n) = a^2 T(n/b^2) + a f(n/b) + f(n)",
                                    "Verifique algebricamente a distribuição"
                                  ],
                                  "verification": "Expansão nível 1 matches: a^2 T(n/b^2) + a f(n/b) + f(n)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Exemplo guia"
                                  ],
                                  "tips": [
                                    "Mantenha parênteses para evitar erros de distribuição",
                                    "Fatore termos comuns se possível"
                                  ],
                                  "learningObjective": "Executar substituição recursiva no primeiro nível com precisão",
                                  "commonMistakes": [
                                    "Esquecer multiplicar f(n/b) por a",
                                    "Erro em n/b^2",
                                    "Não simplificar termos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir o segundo nível e observar acumulação",
                                  "subSteps": [
                                    "Substitua T(n/b^2) = a T(n/b^3) + f(n/b^2)",
                                    "Aplique o coeficiente a^2: a^2 * [a T(n/b^3) + f(n/b^2)]",
                                    "Incorpore termos anteriores: + a f(n/b) + f(n)",
                                    "Simplifique: T(n) = a^3 T(n/b^3) + a^2 f(n/b^2) + a f(n/b) + f(n)",
                                    "Note o padrão emergente nos coeficientes e argumentos de f"
                                  ],
                                  "verification": "Expansão nível 2 correta com 4 termos de f(n) acumulados",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela para rastrear coeficientes"
                                  ],
                                  "tips": [
                                    "Use uma tabela para listar coeficientes a^k e f(n/b^k)",
                                    "Alinhe termos verticalmente"
                                  ],
                                  "learningObjective": "Visualizar acumulação de custos em níveis múltiplos",
                                  "commonMistakes": [
                                    "Erro no expoente de a",
                                    "Argumento errado em f(n/b^k)",
                                    "Perder termos anteriores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expandir níveis adicionais e identificar repetições",
                                  "subSteps": [
                                    "Continue para nível 3 ou 4: generalize T(n) = a^k T(n/b^k) + sum_{i=0}^{k-1} a^i f(n/b^i)",
                                    "Expanda até k=3 ou log_b n",
                                    "Observe repetição: termo recursivo diminui, soma de f(n) cresce",
                                    "Identifique padrão: soma geométrica se f(n) = n^c",
                                    "Pare quando T(n/b^k) atinge base (k = log_b n)"
                                  ],
                                  "verification": "Expansão mostra padrão geral com soma e identifica repetição",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou software como Mathematica para verificação opcional",
                                    "Papel"
                                  ],
                                  "tips": [
                                    "Conte níveis explicitamente",
                                    "Teste com números pequenos (n=8, b=2)"
                                  ],
                                  "learningObjective": "Detectar padrões recursivos e generalizar expansão",
                                  "commonMistakes": [
                                    "Parar cedo sem ver repetição",
                                    "Erro na soma de série",
                                    "Confundir k"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e generalizar a expansão completa",
                                  "subSteps": [
                                    "Escreva a forma fechada: T(n) = a^{log_b n} T(1) + sum_{i=0}^{log_b n -1} a^i f(n/b^i)",
                                    "Substitua condições base",
                                    "Valide com exemplo numérico (ex: n=8)",
                                    "Discuta convergência ou dominância de termos",
                                    "Documente padrões observados"
                                  ],
                                  "verification": "Forma geral correta e validação numérica passa",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Exemplo numérico"
                                  ],
                                  "tips": [
                                    "Use log_b n = ln n / ln b para estimar k",
                                    "Compare com Master Theorem"
                                  ],
                                  "learningObjective": "Consolidar expansão em forma utilizável para análise",
                                  "commonMistakes": [
                                    "Erro no limite da soma",
                                    "Ignorar base T(1)",
                                    "Cálculo numérico errado"
                                  ]
                                }
                              ],
                              "practicalExample": "Para T(n) = 2 T(n/2) + n (Merge Sort):\nNível 0: T(n) = 2 T(n/2) + n\nNível 1: 2[2 T(n/4) + n/2] + n = 4 T(n/4) + 2n\nNível 2: 4[2 T(n/8) + n/4] + 2n = 8 T(n/8) + 3n\nPadrão: T(n) = 2^k T(n/2^k) + k n, com k=log2 n → T(n) = 2n log n",
                              "finalVerifications": [
                                "Expansão manual mostra pelo menos 3 níveis corretos",
                                "Padrão de repetição (soma geométrica) identificado explicitamente",
                                "Termos f(n/b^i) distribuídos com coeficientes a^i precisos",
                                "Condições base incorporadas corretamente",
                                "Validação numérica para n pequeno (ex: n=8) coincide",
                                "Forma geral escrita sem erros algébricos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na substituição recursiva em todos os níveis (100% correto)",
                                "Identificação correta do padrão de repetição e generalização",
                                "Correta simplificação e distribuição de termos f(n)",
                                "Uso consistente de notação e alinhamento visual",
                                "Validação numérica e discussão de dominância de termos",
                                "Ausência de erros comuns como perda de termos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expansão de séries geométricas e somas infinitas",
                                "Programação: Simulação de chamadas recursivas em código (ex: trace de função)",
                                "Física: Modelos recursivos em sistemas fractais ou populações",
                                "Economia: Modelos de crescimento recursivo composto",
                                "Engenharia: Análise de divide-and-conquer em estruturas de dados"
                              ],
                              "realWorldApplication": "Essencial para analisar complexidade de algoritmos divide-and-conquer como Merge Sort (O(n log n)), Tree Traversals e Fast Fourier Transform, permitindo otimizar software em big data, machine learning e computação gráfica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.2",
                            "name": "Detectar padrões de emparelhamento",
                            "description": "Analisar expansões para agrupar termos idênticos ou complementares, como em recorrências do tipo T(n) = T(n-1) + T(n-2) + c, identificando pares que se cancelam.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar Expansão Inicial da Recorrência",
                                  "subSteps": [
                                    "Escreva a recorrência dada, ex: T(n) = T(n-1) + T(n-2) + c.",
                                    "Substitua T(n-1) por sua expressão recursiva.",
                                    "Substitua T(n-2) por sua expressão recursiva.",
                                    "Expanda para 3-4 níveis até visualizar termos repetidos.",
                                    "Inclua os termos +c em cada nível de expansão."
                                  ],
                                  "verification": "A expansão mostra múltiplos termos T(k) e +c com coeficientes iniciais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de recorrências impressos ou digitais"
                                  ],
                                  "tips": "Mantenha a expansão organizada usando indentação para cada nível.",
                                  "learningObjective": "Gerar a expansão bruta para revelar estrutura repetitiva.",
                                  "commonMistakes": [
                                    "Expandir apenas um ramo recursivo",
                                    "Esquecer de adicionar +c em cada substituição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar e Classificar Termos na Expansão",
                                  "subSteps": [
                                    "Identifique todos os termos T(base) com seus coeficientes acumulados.",
                                    "Conte e liste as ocorrências dos termos constantes +c.",
                                    "Classifique termos por tipo: recursivos idênticos, constantes, potenciais complementares.",
                                    "Use uma tabela para registrar frequência e coeficientes.",
                                    "Marque preliminarmente termos com sinais opostos se presentes."
                                  ],
                                  "verification": "Tabela completa com todos termos, coeficientes e frequências corretas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para somas iniciais"
                                  ],
                                  "tips": "Agrupe por índice k em T(k) para facilitar contagem.",
                                  "learningObjective": "Organizar a expansão para análise de padrões.",
                                  "commonMistakes": [
                                    "Perder termos durante a contagem",
                                    "Ignorar coeficientes crescentes como números de Fibonacci"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Padrões de Emparelhamento",
                                  "subSteps": [
                                    "Procure termos idênticos (ex: múltiplos +T(k) ou +c).",
                                    "Identifique complementares (ex: +1/k e -1/(k+1) em somas derivadas).",
                                    "Verifique pares que somam zero (cancelamento) ou constante.",
                                    "Observe padrões telescópicos ou simétricos como k e (n+1-k).",
                                    "Anote o número de pares possíveis e seu efeito."
                                  ],
                                  "verification": "Lista de 2-4 pares identificados com justificativa de emparelhamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência rápida de identidades matemáticas como 1/(k(k+1))"
                                  ],
                                  "tips": "Pense em reescrita algébrica: teste se termo = diferença de dois termos simples.",
                                  "learningObjective": "Reconhecer configurações onde pares simplificam a soma.",
                                  "commonMistakes": [
                                    "Confundir idênticos com complementares",
                                    "Não testar cancelamento em pares alternados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Emparelhamento e Simplificar",
                                  "subSteps": [
                                    "Agrupe os pares detectados e compute sua contribuição (zero ou constante).",
                                    "Elimine termos cancelados e some os restantes.",
                                    "Conte o número total de pares para generalizar.",
                                    "Escreva a forma fechada da recorrência.",
                                    "Valide com valores pequenos de n (ex: n=3,4)."
                                  ],
                                  "verification": "Forma simplificada coincide com avaliação direta da recorrência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para validação numérica"
                                  ],
                                  "tips": "Se n par, número de pares = n/2; ajuste para resto se ímpar.",
                                  "learningObjective": "Converter padrões detectados em solução fechada acionável.",
                                  "commonMistakes": [
                                    "Erro na contagem de pares",
                                    "Não validar com base cases"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere T(n) = T(n-1) + 1/(n(n+1)), T(1)=1. Expansão: T(n) = 1 + ∑_{k=2}^n [1/(k(k+1))]. Detecte padrão: 1/(k(k+1)) = 1/k - 1/(k+1). Emparelhe: soma = (1/2 - 1/3) + (1/3 - 1/4) + ... + (1/n - 1/(n+1)). Termos intermediários cancelam, restando 1 - 1/(n+1). Assim T(n) = 2 - 1/(n+1). Para T(n-2), adapte contando multiplicadores Fibonacci nos pares.",
                              "finalVerifications": [
                                "Expansão inicial correta para 3-4 níveis?",
                                "Todos termos listados com coeficientes precisos?",
                                "Pares de emparelhamento identificados e justificados?",
                                "Cancelamentos aplicados corretamente sem resíduos?",
                                "Forma simplificada validada numericamente para n=2,3,4?",
                                "Generalização para n arbitrário coerente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na expansão e listagem (sem erros de sinal ou coeficiente).",
                                "Identificação correta de pelo menos 2 padrões de emparelhamento.",
                                "Explicação clara do mecanismo de cancelamento ou soma constante por par.",
                                "Simplificação leva a expressão fechada exata ou assintótica.",
                                "Validação numérica demonstra acurácia.",
                                "Generalização mostra insight no padrão recorrente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries telescópicas e soma de progressões.",
                                "Álgebra: Decomposição em frações parciais para detecção de pares.",
                                "Estatística: Simplificação de somas esperadas em análises probabilísticas.",
                                "Física: Modelos recursivos em cadeias de Markov ou difusões."
                              ],
                              "realWorldApplication": "Na análise de algoritmos como union-find (somas harmônicas telescópicas para quase O(n)), quicksort (pairing probabilístico para custo médio), ou em finanças para calcular retornos compostos via somas canceláveis, permitindo previsão eficiente de complexidade ou crescimento sem simulações completas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.3",
                            "name": "Construir somas telescópicas via emparelhamento",
                            "description": "Aplicar emparelhamento para transformar somas longas em formas fechadas, eliminando termos intermediários por cancelamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de somas telescópicas e cancelamento de termos",
                                  "subSteps": [
                                    "Defina uma soma telescópica como uma soma onde a maioria dos termos cancela, deixando apenas os termos iniciais e finais.",
                                    "Estude o exemplo básico: ∑_{k=1}^n (1/k - 1/(k+1)) = 1 - 1/(n+1).",
                                    "Escreva a expansão para n=3, 4 e 5 manualmente para observar o padrão de cancelamento.",
                                    "Identifique os termos que sobrevivem: o primeiro positivo e o último negativo.",
                                    "Pratique reescrevendo uma soma simples em forma telescópica."
                                  ],
                                  "verification": "Expanda ∑_{k=1}^5 (1/k - 1/(k+1)) e confirme que resulta em 1 - 1/6.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para verificação numérica"
                                  ],
                                  "tips": [
                                    "Alinhe os termos em colunas para visualizar cancelamentos claramente.",
                                    "Comece sempre com expansões pequenas (n≤5)."
                                  ],
                                  "learningObjective": "Compreender o mecanismo de cancelamento em somas telescópicas.",
                                  "commonMistakes": [
                                    "Esquecer o termo final -1/(n+1).",
                                    "Confundir índices ao expandir."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a técnica de emparelhamento para criar diferenças telescópicas",
                                  "subSteps": [
                                    "Explique emparelhamento: agrupar termos consecutivos para formar uma diferença que cancela em somas pares ou ímpares.",
                                    "Aprenda decomposição em frações parciais: para 1/(k(k+m)) = (1/m)(1/k - 1/(k+m)).",
                                    "Aplique a um exemplo: 1/(k(k+1)) = 1/k - 1/(k+1), emparelhando k e k+1.",
                                    "Discuta emparelhamento em somas com termos alternados, como ∑ (1/(2k-1) - 1/(2k)).",
                                    "Identifique quando emparelhamento é aplicável: termos que formam diferenças racionais."
                                  ],
                                  "verification": "Decomponha 1/(k(k+2)) em frações parciais e verifique somando de volta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de decomposições parciais padrão"
                                  ],
                                  "tips": [
                                    "Use o método de coeficientes indeterminados para frações parciais.",
                                    "Teste a decomposição somando dois termos originais."
                                  ],
                                  "learningObjective": "Dominar emparelhamento via frações parciais para gerar telescópios.",
                                  "commonMistakes": [
                                    "Erro no coeficiente da decomposição (ex: 1/2 em vez de 1).",
                                    "Não simplificar a diferença obtida."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir uma soma telescópica completa via emparelhamento",
                                  "subSteps": [
                                    "Escolha uma soma alvo, ex: ∑_{k=1}^n 1/(k(k+3)).",
                                    "Decomponha: 1/(k(k+3)) = (1/3)(1/k - 1/(k+3)).",
                                    "Escreva a soma: (1/3) ∑_{k=1}^n (1/k - 1/(k+3)), expanda para ver cancelamentos.",
                                    "Agrupe termos: 1/1 + 1/2 + 1/3 - 1/(n+1) - 1/(n+2) - 1/(n+3).",
                                    "Simplifique para forma fechada."
                                  ],
                                  "verification": "Compute numericamente para n=10 e compare com forma fechada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Planilha ou Python para soma numérica"
                                  ],
                                  "tips": [
                                    "Expanda sempre os primeiros e últimos termos explicitamente.",
                                    "Conte quantos termos não cancelam (geralmente m para (k(k+m)))."
                                  ],
                                  "learningObjective": "Aplicar emparelhamento para transformar soma em telescópica.",
                                  "commonMistakes": [
                                    "Perder termos intermediários no cancelamento.",
                                    "Índices errados no agrupamento."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a técnica em recorrências e análise de algoritmos",
                                  "subSteps": [
                                    "Ligue a somas de recorrências: ex: T(n) = T(n-1) + 1/(n(n+1)) leva a telescópico.",
                                    "Desenrole uma recorrência simples: T(n) = ∑_{k=1}^n 1/(k(k+1)) ≈ 1.",
                                    "Emparelhe em divide-and-conquer: soma de custos que telescopam após manipulação.",
                                    "Generalize para recorrências lineares e verifique assintótica.",
                                    "Implemente em código para validar."
                                  ],
                                  "verification": "Resolva T(n) = T(n-1) + 1/(n(n+1)), T(1)=0, e prove T(n)=1-1/(n+1).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Editor de código Python/Jupyter"
                                  ],
                                  "tips": [
                                    "Pense em desenrolamento recursivo como soma.",
                                    "Use limites exatos para recorrências."
                                  ],
                                  "learningObjective": "Usar somas telescópicas em contextos de análise de algoritmos.",
                                  "commonMistakes": [
                                    "Confundir soma de recorrência com soma direta.",
                                    "Ignorar condições iniciais."
                                  ]
                                }
                              ],
                              "practicalExample": "Construa a forma fechada para ∑_{k=1}^n 1/(k(k+3)). Decomposição: 1/(k(k+3)) = (1/3)(1/k - 1/(k+3)). Soma: (1/3)[(1+1/2+1/3) - (1/(n+1)+1/(n+2)+1/(n+3))]. Os termos intermediários cancelam, deixando uma expressão fechada útil para análise assintótica.",
                              "finalVerifications": [
                                "Transforma corretamente ∑ 1/(k(k+1)) em 1 - 1/(n+1).",
                                "Identifica e cancela termos intermediários em expansões.",
                                "Aplica decomposição parcial sem erros aritméticos.",
                                "Liga a técnica a uma recorrência simples.",
                                "Verifica numericamente para n=10-20.",
                                "Generaliza para soma 1/(k(k+m))."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição em frações parciais.",
                                "Correta identificação e cancelamento de termos.",
                                "Forma fechada simplificada e exata.",
                                "Explicação clara do emparelhamento usado.",
                                "Aplicação bem-sucedida em pelo menos um exemplo de recorrência.",
                                "Verificação numérica consistente com analítica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries e frações parciais em cálculo.",
                                "Física: Aproximações de somas em mecânica quântica (somas de perturbação).",
                                "Programação: Implementação eficiente de somas em loops otimizados.",
                                "Engenharia: Análise de custos cumulativos em sistemas recursivos."
                              ],
                              "realWorldApplication": "Na análise de complexidade de algoritmos recursivos (ex: divide-and-conquer como merge sort), somas telescópicas via emparelhamento fornecem soluções fechadas exatas para recorrências, permitindo determinar big-O preciso sem simulações, essencial para otimização de software em larga escala."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.4",
                            "name": "Reconhecer padrões comuns emparelháveis",
                            "description": "Identificar padrões clássicos como em Fibonacci modificado ou mergesort irregular, onde emparelhamento revela complexidades O(n) ou O(n log n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Técnica de Emparelhamento em Recorrências",
                                  "subSteps": [
                                    "Revise o conceito de relações de recorrência em algoritmos recursivos.",
                                    "Estude como o emparelhamento agrupa termos para simplificar somas.",
                                    "Analise a diferença entre recorrências lineares e não-lineares.",
                                    "Pratique desenhando árvores de recursão para visualização.",
                                    "Identifique quando uma recorrência é candidata a emparelhamento."
                                  ],
                                  "verification": "Explique em suas palavras o que é emparelhamento e dê um exemplo simples de agrupamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis para desenhos de árvores",
                                    "Notebook com exemplos de recorrências básicas"
                                  ],
                                  "tips": "Desenhe árvores de recursão primeiro para visualizar o emparelhamento.",
                                  "learningObjective": "Entender os princípios básicos do emparelhamento para preparar identificação de padrões.",
                                  "commonMistakes": "Confundir emparelhamento com substituição direta sem agrupamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Padrões Clássicos Emparelháveis",
                                  "subSteps": [
                                    "Examine o padrão Fibonacci modificado: T(n) = T(n-1) + T(n-2) + 1.",
                                    "Analise mergesort irregular: T(n) = 2T(n/2) + n com variações.",
                                    "Compare somas expandidas e aplique emparelhamento para revelar O(n) ou O(n log n).",
                                    "Registre fórmulas simplificadas após emparelhamento para cada padrão.",
                                    "Crie uma tabela comparativa de padrões comuns."
                                  ],
                                  "verification": "Resolva a expansão de uma recorrência Fibonacci modificada e mostre o emparelhamento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Excel/Google Sheets",
                                    "Referências: 'Introduction to Algorithms' CLRS capítulo 4"
                                  ],
                                  "tips": "Use cores diferentes para destacar pares no emparelhamento.",
                                  "learningObjective": "Memorizar e replicar emparelhamentos em padrões clássicos.",
                                  "commonMistakes": "Ignorar termos constantes que afetam a complexidade final."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Identificação de Padrões em Exemplos Variados",
                                  "subSteps": [
                                    "Receba 5 recorrências aleatórias e classifique se são emparelháveis.",
                                    "Para emparelháveis, execute o emparelhamento e derive a complexidade.",
                                    "Para não-emparelháveis, justifique e sugira outra técnica.",
                                    "Cronometre sua identificação e refine velocidade.",
                                    "Discuta com um parceiro ou anote dúvidas."
                                  ],
                                  "verification": "Corretamente identifique e resolva 4/5 exemplos fornecidos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Lista de 10 exercícios de recorrências (online ou livro)",
                                    "Calculadora para somas grandes"
                                  ],
                                  "tips": "Procure simetria na árvore de recursão como pista inicial.",
                                  "learningObjective": "Desenvolver intuição para reconhecer padrões rapidamente.",
                                  "commonMistakes": "Forçar emparelhamento em recorrências assimétricas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Reconhecimento em Problemas Reais",
                                  "subSteps": [
                                    "Escolha um algoritmo real (ex: quicksort médio) e derive sua recorrência.",
                                    "Identifique padrão emparelhável e comprove complexidade.",
                                    "Compare com Mestre ou Akra-Bazzi se aplicável.",
                                    "Documente o processo em um relatório curto.",
                                    "Teste com variação para validar generalização."
                                  ],
                                  "verification": "Produza um relatório com análise correta de pelo menos 2 algoritmos reais.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Código fonte de algoritmos (Python/Java)",
                                    "Ferramenta de plotagem como Desmos para somas"
                                  ],
                                  "tips": "Valide com simulações numéricas para pequenas n.",
                                  "learningObjective": "Integrar reconhecimento de padrões em análises completas de complexidade.",
                                  "commonMistakes": "Subestimar casos base na recursão."
                                }
                              ],
                              "practicalExample": "Considere T(n) = T(n-1) + T(n-2) + n. Expanda: T(n) = n + (n-1) + ... + 1 + termos Fibonacci. Emparelhe os lineares para somar n(n+1)/2 (O(n)), revelando dominância O(φ^n).",
                              "finalVerifications": [
                                "Identifica corretamente Fibonacci modificado em 90% dos casos.",
                                "Executa emparelhamento sem erros aritméticos.",
                                "Deriva complexidade assintótica precisa.",
                                "Explica o processo verbalmente com clareza.",
                                "Distingue padrões emparelháveis de outros.",
                                "Aplica em recorrências não-triviais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões (40%)",
                                "Correção no emparelhamento e simplificação (30%)",
                                "Explicação clara do raciocínio (15%)",
                                "Velocidade e eficiência na prática (10%)",
                                "Generalização para novos exemplos (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries e somas infinitas.",
                                "Física: Modelos recursivos em oscilações.",
                                "Economia: Análise de crescimento exponencial em finanças.",
                                "Biologia: Padrões de crescimento populacional (Fibonacci)."
                              ],
                              "realWorldApplication": "Em otimização de software, reconhecer esses padrões acelera análise de algoritmos em big data, como em motores de busca (mergesort para ordenação) ou criptografia (recorrências em chaves geradas)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.3",
                        "name": "Aplicação e Resolução de Recorrências",
                        "description": "Praticar a resolução completa de recorrências utilizando a técnica de emparelhamento, com exemplos e verificação.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.3.1",
                            "name": "Resolver recorrência simples por emparelhamento",
                            "description": "Resolver T(n) = 2T(n-1) + 1 usando emparelhamento para obter T(n) = 2^n - 1, verificando por indução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a recorrência e calcular valores iniciais",
                                  "subSteps": [
                                    "Leia a recorrência T(n) = 2T(n-1) + 1 e identifique a condição base, assumindo T(1) = 1.",
                                    "Calcule T(2), T(3) e T(4) manualmente substituindo iterativamente.",
                                    "Registre os valores em uma tabela: n | T(n).",
                                    "Observe o padrão numérico inicial (ex: 1, 3, 7, 15).",
                                    "Anote hipóteses iniciais sobre o crescimento exponencial."
                                  ],
                                  "verification": "Tabela completa com cálculos corretos para n=1 a 4.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, caneta e calculadora opcional",
                                  "tips": "Comece sempre pela base para evitar erros de propagação.",
                                  "learningObjective": "Entender o comportamento inicial da recorrência através de cálculos manuais.",
                                  "commonMistakes": [
                                    "Esquecer a condição base T(1)=1",
                                    "Erro aritmético em substituições simples",
                                    "Não registrar valores para visualização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a técnica de emparelhamento (desenrolamento iterativo)",
                                  "subSteps": [
                                    "Escreva T(n) = 2T(n-1) + 1.",
                                    "Substitua T(n-1) = 2T(n-2) + 1, obtendo T(n) = 2[2T(n-2) + 1] + 1 = 4T(n-2) + 2 + 1.",
                                    "Continue até T(1): T(n) = 2^{n-1} T(1) + 2^{n-2} + ... + 2 + 1.",
                                    "Agrupe os termos constantes como uma série geométrica.",
                                    "Some a série: soma = 2^{n-1} + 2^{n-2} + ... + 1 = 2^n - 1."
                                  ],
                                  "verification": "Expressão desenrolada correta mostrando a soma geométrica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado para alinhar equações",
                                  "tips": "Use indentação ou setas para visualizar o 'emparelhamento' das substituições.",
                                  "learningObjective": "Dominar o desenrolamento iterativo para revelar o padrão.",
                                  "commonMistakes": [
                                    "Perder o fator 2^k nos coeficientes",
                                    "Erro na soma da série geométrica",
                                    "Parar o desenrolamento prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a fórmula fechada",
                                  "subSteps": [
                                    "Com base no desenrolamento, escreva T(n) = 2^{n-1} * T(1) + (2^{n-1} + ... + 1).",
                                    "Substitua T(1)=1 e reconheça a soma como S = 2^n - 1 - 1? Não, soma de 2^0 a 2^{n-1} = 2^n - 1.",
                                    "Conclua T(n) = 2^{n-1} * 1 + (2^n - 1 - 2^{n-1})? Simplifique: na verdade, direto T(n) = 2^n - 1.",
                                    "Verifique com valores anteriores: T(3)=7=8-1, T(4)=15=16-1.",
                                    "Escreva a fórmula final T(n) = 2^n - 1."
                                  ],
                                  "verification": "Fórmula fechada T(n) = 2^n - 1 validada com 3 valores iniciais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta",
                                  "tips": "Lembre-se da fórmula da soma geométrica S = (r^{k+1} - 1)/(r-1) com r=2.",
                                  "learningObjective": "Generalizar o padrão para obter solução fechada exata.",
                                  "commonMistakes": [
                                    "Confundir índices dos expoentes",
                                    "Erro na simplificação final",
                                    "Ignorar verificação numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a solução por indução matemática",
                                  "subSteps": [
                                    "Caso base: Para n=1, T(1)=1 = 2^1 - 1 =1, OK.",
                                    "Hipótese indutiva: Assuma T(k) = 2^k - 1 para k < n.",
                                    "Passo indutivo: T(n) = 2T(n-1) + 1 = 2(2^{n-1} - 1) + 1 = 2^n - 2 + 1 = 2^n - 1.",
                                    "Conclua que vale para todo n por princípio da indução.",
                                    "Teste com n=5: T(5)=2*15+1=31=32-1."
                                  ],
                                  "verification": "Prova completa por indução sem falhas lógicas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para estrutura da prova",
                                  "tips": "Escreva 'Assuma para k=n-1' explicitamente para clareza.",
                                  "learningObjective": "Validar rigorosamente a solução usando indução.",
                                  "commonMistakes": [
                                    "Falha no passo indutivo (esquecer +1 ou -2)",
                                    "Caso base incorreto",
                                    "Não generalizar para todo n"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva T(4): T(1)=1; T(2)=2*1+1=3; T(3)=2*3+1=7; T(4)=2*7+1=15. Desenrole: T(4)=2[2[2*1+1]+1]+1=8*1 +4+2+1=15=16-1. Indução confirma.",
                              "finalVerifications": [
                                "Cálculos manuais para n=1-5 coincidem com 2^n -1.",
                                "Desenrolamento mostra soma geométrica corretamente.",
                                "Fórmula fechada simplificada sem erros.",
                                "Prova por indução completa e válida.",
                                "Pode explicar o 'emparelhamento' verbalmente.",
                                "Identifica complexidade O(2^n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos iniciais (100% correto).",
                                "Desenrolamento iterativo completo e legível.",
                                "Derivação da soma geométrica exata.",
                                "Prova de indução lógica e sem lacunas.",
                                "Verificações numéricas em pelo menos 4 valores.",
                                "Explicação clara do método de emparelhamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries geométricas e indução matemática.",
                                "Análise de Algoritmos: Complexidade de recursões lineares.",
                                "Programação: Implementação e teste de funções recursivas.",
                                "Lógica: Provas formais e verificação."
                              ],
                              "realWorldApplication": "Analisar tempo de execução de algoritmos recursivos como 'exponencial' em divide-and-conquer simples, otimizando para problemas como Fibonacci ingênuo ou simulações de crescimento populacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.2",
                            "name": "Aplicar em recorrência de divide-and-conquer",
                            "description": "Usar emparelhamento em T(n) = T(n/2) + T(n/3) + n para simplificar e estimar a complexidade assintótica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Recorrência e Assumir a Forma Assintótica",
                                  "subSteps": [
                                    "Escreva a recorrência dada: T(n) = T(n/2) + T(n/3) + n.",
                                    "Identifique os termos recursivos T(n/2) e T(n/3) e o termo de custo não-recursivo n.",
                                    "Assuma que a solução assintótica é da forma T(n) = Θ(n^k) para algum k > 1, ignorando constantes e termos inferiores.",
                                    "Justifique por que k > 1: o termo +n sugere crescimento linear ou superior.",
                                    "Defina T(n) ≈ c n^k, onde c é uma constante."
                                  ],
                                  "verification": "Confirme que a recorrência está corretamente reescrita e a assunção Θ(n^k) é explicitada com justificativa.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, calculadora para experimentos iniciais",
                                  "tips": "Sempre comece visualizando o 'esqueleto' da recursão como uma árvore para intuir o crescimento.",
                                  "learningObjective": "Entender a estrutura da recorrência e motivar a assunção de forma polinomial para divide-and-conquer.",
                                  "commonMistakes": "Assumir k=1 sem verificar (pois termo +n sugere possível superlinear); confundir frações 1/2 e 1/3."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Equação de Emparelhamento",
                                  "subSteps": [
                                    "Substitua T(n) = c n^k na recorrência: c n^k = c (n/2)^k + c (n/3)^k + n.",
                                    "Divida todos os termos por n^k: c = c (1/2)^k + c (1/3)^k + n / n^k = c (2^{-k} + 3^{-k}) + n^{1-k}.",
                                    "Para n grande e k > 1, o termo n^{1-k} → 0, aproximando para c ≈ c (2^{-k} + 3^{-k}).",
                                    "Divida por c (assumindo c ≠ 0): 1 ≈ 2^{-k} + 3^{-k}.",
                                    "Escreva a equação final de emparelhamento: 1 = 2^{-k} + 3^{-k}."
                                  ],
                                  "verification": "Verifique se a equação 1 = 2^{-k} + 3^{-k} foi derivada corretamente, sem erros algébricos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta, software de álgebra simbólica opcional (ex: Wolfram Alpha para verificação)",
                                  "tips": "Normalize dividindo por n^k imediatamente para simplificar expoentes.",
                                  "learningObjective": "Dominar a derivação da equação de emparelhamento, destacando a aproximação assintótica.",
                                  "commonMistakes": "Esquecer de dividir o termo +n por n^k; manter c do lado esquerdo sem dividir."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver Numericamente a Equação para k",
                                  "subSteps": [
                                    "Defina a função f(k) = 2^{-k} + 3^{-k} - 1 e encontre a raiz onde f(k) = 0 para k > 1.",
                                    "Teste valores iniciais: f(1) = 0.5 + 0.333 - 1 ≈ -0.167 < 0; f(2) = 0.25 + 0.111 - 1 ≈ -0.639 < 0? Espere, f(1)>0? Não: 2^{-1}=0.5, 3^{-1}≈0.333, soma 0.833-1=-0.167<0.",
                                    "Como f(1) < 0 e f(k) diminui com k, teste k=1.5: 2^{-1.5}≈0.353, 3^{-1.5}≈0.192, soma≈0.545-1=-0.455<0.",
                                    "Use método de bisseção ou tentativa: k≈1.32: 2^{-1.32}≈0.401, 3^{-1.32}≈0.284, soma≈0.685-1<0; k=1.6: 2^{-1.6}≈0.330, 3^{-1.6}≈0.151, soma=0.481-1<0. Aumente para k menor.",
                                    "Itere até convergir: valor aproximado k ≈ 1.584 (use calculadora para precisão)."
                                  ],
                                  "verification": "Confirme que f(k) ≈ 0 com k ≈ 1.584 (erro < 0.01).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou planilha (Excel/Google Sheets) para f(k), Python opcional",
                                  "tips": "Use logaritmos para estimar: k ≈ log(1 / (1/2 + 1/3)) mas ajuste iterativamente.",
                                  "learningObjective": "Aprender a resolver equações transcendentais numericamente no contexto de complexidade.",
                                  "commonMistakes": "Confundir f(k)>0 ou <0; parar em k=1 sem notar que soma <1 requer k<1 mas contradiz assunção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a Solução e Concluir a Complexidade Assintótica",
                                  "subSteps": [
                                    "Verifique a aproximação: compute f(1.584) ≈ 2^{-1.584} + 3^{-1.584} -1 ≈ 0.33 + 0.67? Calcule precisamente ≈1.",
                                    "Confirme k >1 e que termo n^{1-k} é o(n), justificando Θ(n^k).",
                                    "Estime T(n) = Θ(n^{1.584}).",
                                    "Discuta limites: emparelhamento dá estimativa, Mestre pode refinar.",
                                    "Teste com valores pequenos de n para intuição (ex: desenhe árvore de recursão)."
                                  ],
                                  "verification": "Escreva T(n) = Θ(n^k) com k≈1.584 e justifique por que a aproximação é válida.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel para árvore de recursão, simulador de recorrência opcional",
                                  "tips": "Sempre verifique com gráfico de f(k) para visualização.",
                                  "learningObjective": "Validar o emparelhamento e interpretar o resultado assintótico.",
                                  "commonMistakes": "Ignorar verificação numérica; afirmar O(n) sem cálculo."
                                }
                              ],
                              "practicalExample": "Para T(n) = T(n/2) + T(n/3) + n, derive 1 = 2^{-k} + 3^{-k}. Resolvendo numericamente: teste k=1.5 → 0.353+0.192=0.545 <1; k=1.0 →0.833<1; itere para k≈1.584 onde ≈0.330+0.670? Precisamente 2^{-1.584}≈0.337, 3^{-1.584}≈0.663, soma=1. Conclua T(n)=Θ(n^{1.584}).",
                              "finalVerifications": [
                                "Equação de emparelhamento derivada corretamente como 1 = 2^{-k} + 3^{-k}.",
                                "Valor de k aproximado corretamente em 1.58-1.59.",
                                "Justificativa da aproximação n^{1-k}→0 para k>1.",
                                "Conclusão Θ(n^k) com k numérico.",
                                "Verificação numérica com f(k)≈0.",
                                "Discussão de quando usar Mestre vs. emparelhamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (sem erros em expoentes).",
                                "Correção numérica na solução para k (erro <5%).",
                                "Compreensão conceitual da aproximação assintótica.",
                                "Capacidade de justificar k>1 e validade do método.",
                                "Clareza na explicação e verificações finais.",
                                "Uso adequado de ferramentas numéricas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução numérica de equações transcendentais (método de Newton ou bisseção).",
                                "Física: Modelos de decaimento exponencial em sistemas divididos (ex: fracionamento radioativo).",
                                "Economia: Análise de crescimento em modelos de divisão de mercados desiguais.",
                                "Engenharia: Otimização de tempo em processos paralelos irregulares."
                              ],
                              "realWorldApplication": "Em algoritmos divide-and-conquer irregulares como processamento de consultas em bancos de dados distribuídos (ex: T(n/2) para um shard, T(n/3) para outro) ou heurísticas de IA em árvores de decisão desbalanceadas, onde estimar Θ(n^{1.58}) guia escolhas de eficiência e escalabilidade em sistemas reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.3",
                            "name": "Verificar solução por método de substituição",
                            "description": "Após emparelhamento, validar a solução proposta usando o método de substituição para confirmar a tight bound.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a recorrência e o bound proposto",
                                  "subSteps": [
                                    "Escreva a equação de recorrência exata (ex: T(n) = 2T(n/2) + n).",
                                    "Anote o bound proposto, especificando se é O, Ω ou Θ (ex: T(n) = Θ(n log n)).",
                                    "Defina constantes como c para upper bound (T(n) ≤ c f(n)) e d para lower bound (T(n) ≥ d f(n)).",
                                    "Confirme o domínio (n ≥ n0 para algum n0).",
                                    "Registre quaisquer premissas do emparelhamento anterior."
                                  ],
                                  "verification": "Verifique se a recorrência e o bound estão corretamente transcritos sem erros tipográficos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas da recorrência original",
                                    "Calculadora para logs"
                                  ],
                                  "tips": "Use notação assintótica clara (O, Θ) para evitar confusão com bounds exatos.",
                                  "learningObjective": "Compreender precisamente o problema e a hipótese a ser verificada.",
                                  "commonMistakes": "Confundir upper com lower bound; ignorar condições de base iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar o caso base",
                                  "subSteps": [
                                    "Escolha valores pequenos de n (ex: n=1, n=2) onde a recorrência é definida.",
                                    "Calcule T(n) diretamente para esses valores.",
                                    "Verifique se T(n) ≤ c f(n) para upper bound e T(n) ≥ d f(n) para lower bound.",
                                    "Ajuste c ou d se necessário para satisfazer o caso base.",
                                    "Documente os valores usados e resultados."
                                  ],
                                  "verification": "Confirme que desigualdades holds para todos casos base testados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de valores base da recorrência"
                                  ],
                                  "tips": "Comece com o menor n possível para simplicidade.",
                                  "learningObjective": "Garantir que a indução inicie corretamente.",
                                  "commonMistakes": "Escolher n0 muito grande, ignorando violações em casos pequenos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar upper bound por substituição (O)",
                                  "subSteps": [
                                    "Assuma a hipótese indutiva: T(k) ≤ c f(k) para k < n.",
                                    "Substitua na recorrência: T(n) = a T(n/b) + g(n) ≤ a c f(n/b) + g(n).",
                                    "Simplifique usando propriedades de f (ex: f(n/b) = f(n)/b log b para log).",
                                    "Mostre que a c f(n/b) + g(n) ≤ c f(n), escolhendo c grande o suficiente.",
                                    "Conclua que holds para n."
                                  ],
                                  "verification": "A desigualdade final T(n) ≤ c f(n) é estritamente verdadeira.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Regras algébricas (logaritmos, somas)"
                                  ],
                                  "tips": "Expanda logs se necessário: n log n = n log b + (n/b) log (n/b) * b.",
                                  "learningObjective": "Dominar substituição indutiva para upper bounds.",
                                  "commonMistakes": "Esquecer termo g(n) ou fator a; direção errada da desigualdade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar lower bound por substituição (Ω) para tight bound",
                                  "subSteps": [
                                    "Assuma hipótese: T(k) ≥ d f(k) para k < n.",
                                    "Substitua: T(n) ≥ a d f(n/b) + g(n).",
                                    "Simplifique para mostrar ≥ d f(n), frequentemente usando g(n) ≥ algo positivo.",
                                    "Verifique se d pode ser escolhido para satisfazer.",
                                    "Confirme que ambos bounds implicam Θ."
                                  ],
                                  "verification": "Desigualdade lower bound holds, confirmando tight bound Θ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas do upper bound para comparação"
                                  ],
                                  "tips": "Lower bounds podem precisar de g(n) estritamente positivo; use indução forte se aplicável.",
                                  "learningObjective": "Completar prova de tight bound via ambos os lados.",
                                  "commonMistakes": "Assumir simetria perfeita; ignorar que lower pode requerer prova separada."
                                }
                              ],
                              "practicalExample": "Para Merge Sort: T(n) = 2T(n/2) + n. Proposed: Θ(n lg n).\nUpper: Assuma T(m) ≤ c m lg m para m < n. Então T(n) ≤ 2c (n/2) lg(n/2) + n = c n (lg n -1) + n = c n lg n - c n + n. Escolha c ≥ 1 para ≤ c n lg n.\nBase: T(1)=0 ≤ c*0. Lower similar com d=1.",
                              "finalVerifications": [
                                "Caso base satisfaz ambos upper e lower bounds?",
                                "Hipótese indutiva substitui corretamente na recorrência?",
                                "Desigualdades simplificam para o bound desejado?",
                                "Constantes c e d existem finitas?",
                                "Holds para n suficientemente grande?",
                                "Tight bound Θ confirmado por ambos O e Ω?"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas substituições e simplificações.",
                                "Correta identificação e verificação de casos base.",
                                "Uso apropriado de hipóteses indutivas.",
                                "Escolha válida de constantes c/d.",
                                "Conclusão lógica para tight bound.",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Indução matemática em Matemática Discreta.",
                                "Técnicas de prova em Lógica e Fundamentos de CS.",
                                "Otimização em Engenharia de Software.",
                                "Modelagem assintótica em Matemática Aplicada."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, verificar complexidade por substituição garante que algoritmos como quicksort ou mergesort escalem para grandes datasets em aplicações como bancos de dados ou machine learning, evitando gargalos de performance."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Emparelhamento de Padrões",
                "description": "Técnicas para identificar e localizar padrões em sequências ou estruturas de dados.",
                "totalSkills": 59,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Problema do Emparelhamento de Padrões",
                    "description": "Definição formal do problema de encontrar ocorrências de um padrão em um texto.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Definição de Strings e Alfabeto",
                        "description": "Um alfabeto Σ é um conjunto finito de símbolos distintos. Uma string é uma sequência finita de símbolos pertencentes a Σ. O comprimento de uma string s, denotado por |s|, é o número de símbolos na sequência.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Identificar o alfabeto de uma string",
                            "description": "Dado uma string, determinar o conjunto mínimo de símbolos (alfabeto) necessário para representá-la, listando todos os caracteres únicos presentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Alfabeto em Strings",
                                  "subSteps": [
                                    "Defina uma string como uma sequência de caracteres.",
                                    "Explique que o alfabeto é o conjunto mínimo de símbolos únicos necessários para representar a string.",
                                    "Analise exemplos simples: para 'abc', alfabeto é {a,b,c}; para 'aab', é {a,b}.",
                                    "Discuta a diferença entre caracteres presentes e sua frequência.",
                                    "Identifique que o alfabeto ignora ordem e repetições."
                                  ],
                                  "verification": "Explique em suas próprias palavras o alfabeto de uma string exemplo como 'hello' e liste {h,e,l,o}.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Exemplos de strings impressos ou digitais"
                                  ],
                                  "tips": [
                                    "Pense no alfabeto como o 'vocabulário único' da string.",
                                    "Sempre liste sem duplicatas ou ordem específica."
                                  ],
                                  "learningObjective": "Dominar a definição conceitual de alfabeto como conjunto de caracteres únicos.",
                                  "commonMistakes": [
                                    "Incluir frequência de caracteres.",
                                    "Confundir alfabeto com o comprimento da string.",
                                    "Ignorar maiúsculas/minúsculas se não especificado."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Caracteres Únicos Manualmente",
                                  "subSteps": [
                                    "Escolha uma string curta, como 'banana'.",
                                    "Escreva todos os caracteres em uma lista: b,a,n,a,n,a.",
                                    "Marque ou risque duplicatas para isolar únicos.",
                                    "Forme o conjunto: {b,a,n}.",
                                    "Repita com outra string, como 'racecar', resultando em {r,a,c,e}."
                                  ],
                                  "verification": "Para 'Mississippi', liste corretamente {M,i,s,p} sem erros.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Strings de exemplo escritas",
                                    "Folha para riscar duplicatas"
                                  ],
                                  "tips": [
                                    "Use uma tabela: coluna para posição e coluna para único.",
                                    "Conte de esquerda para direita sistematicamente."
                                  ],
                                  "learningObjective": "Praticar identificação manual de caracteres únicos em strings variadas.",
                                  "commonMistakes": [
                                    "Esquecer caracteres no final ou início.",
                                    "Considerar espaços ou pontuação como irrelevantes sem instrução.",
                                    "Listar em ordem alfabética prematuramente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Método Automatizado com Estruturas de Dados",
                                  "subSteps": [
                                    "Aprenda sobre conjuntos (sets) que armazenam únicos automaticamente.",
                                    "Escreva pseudocódigo: inicialize set vazio; para cada char em string, adicione ao set.",
                                    "Implemente em Python: alfabeto = set('sua_string'); print(sorted(alfabeto)).",
                                    "Teste com 'hello world': espere {h,e,l,o,w,r,d,' '}.",
                                    "Compare resultado manual vs. automatizado."
                                  ],
                                  "verification": "Execute código para 'programming' e confirme {p,r,o,g,a,m,i,n}.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Editor de código como Python IDLE ou online repl.it",
                                    "Documentação básica de sets em Python"
                                  ],
                                  "tips": [
                                    "Use set() para eficiência O(n).",
                                    "sorted(set()) para visualização ordenada opcional."
                                  ],
                                  "learningObjective": "Aplicar estruturas de dados para extrair alfabeto de forma escalável.",
                                  "commonMistakes": [
                                    "Usar lista em vez de set, causando duplicatas.",
                                    "Esquecer de iterar sobre todos os caracteres.",
                                    "Ignorar tratamento de case sensitivity."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar em Casos Complexos",
                                  "subSteps": [
                                    "Pegue string longa ou com caracteres especiais, ex: 'A1b2C!@'.",
                                    "Combine método manual e automatizado para validar.",
                                    "Crie função que retorna tamanho do alfabeto e lista.",
                                    "Teste edge cases: string vazia (alfabeto vazio), string única ('a' -> {a}).",
                                    "Documente o processo para uma string real de texto."
                                  ],
                                  "verification": "Para string vazia e 'AaBb', confirme resultados corretos e explique diferenças de case.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Strings complexas preparadas",
                                    "Ambiente de programação"
                                  ],
                                  "tips": [
                                    "Sempre valide com len(set(string)) == número de únicos.",
                                    "Considere contexto: case-sensitive por padrão?"
                                  ],
                                  "learningObjective": "Garantir precisão em cenários reais e edge cases.",
                                  "commonMistakes": [
                                    "Tratar vazia como erro.",
                                    "Ignorar caracteres não-alfanuméricos.",
                                    "Assumir sempre minúsculas."
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a string 'Mississippi', o alfabeto é o conjunto mínimo {M, i, s, p}, pois contém apenas esses 4 caracteres únicos, ignorando repetições como os múltiplos 'i' e 's'. Em código Python: set('Mississippi') resulta em {'M', 'i', 's', 'p'}.",
                              "finalVerifications": [
                                "O conjunto lista exatamente os caracteres únicos presentes na string.",
                                "Não há duplicatas no alfabeto resultante.",
                                "Todos os caracteres da string original pertencem ao alfabeto.",
                                "Tamanho do alfabeto é correto (ex: 4 para 'Mississippi').",
                                "Método manual e automatizado produzem o mesmo resultado.",
                                "Edge cases como string vazia ou unichar são tratados corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos únicos identificados sem extras ou faltas.",
                                "Eficiência: Uso de set ou equivalente para automação.",
                                "Explicação: Conceito entendido e articulado claramente.",
                                "Testes: Múltiplos exemplos incluindo complexos validados.",
                                "Código: Funcional, legível e comentado se aplicável.",
                                "Tratamento de cases: Consistente com especificações (case-sensitive)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos e operações de união/interseção.",
                                "Linguística: Análise de alfabetos em idiomas naturais.",
                                "Estatística: Preparação para análise de frequência de caracteres.",
                                "Criptografia: Determinação de chave-alphabet para cifra.",
                                "Processamento de Linguagem Natural: Vocabulário único em corpus de texto."
                              ],
                              "realWorldApplication": "Em compressão de dados como Huffman coding, onde o alfabeto define símbolos a codificar; análise de logs de sistemas para detectar padrões de caracteres anômalos; ou em NLP para tokenização inicial, reduzindo vocabulário em modelos de machine learning para eficiência computacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Calcular o comprimento de strings",
                            "description": "Dado uma ou mais strings, computar corretamente o valor de |s| para cada uma, considerando que o comprimento é o número exato de caracteres.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição de String e Comprimento",
                                  "subSteps": [
                                    "Defina uma string como uma sequência finita de caracteres de um alfabeto finito.",
                                    "Explique que o comprimento |s| é o número exato de caracteres na sequência, sem contar espaços extras ou marcadores.",
                                    "Diferencie comprimento de tamanho em bytes (foco em caracteres lógicos).",
                                    "Identifique o alfabeto Σ como o conjunto de símbolos permitidos.",
                                    "Exemplo: Para s = 'abc', |s| = 3."
                                  ],
                                  "verification": "Escreva uma definição precisa de string e comprimento, e calcule |s| para s = 'hello' corretamente como 5.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Sempre conte cada caractere individualmente, ignorando interpretações semânticas.",
                                  "learningObjective": "Entender conceitualmente o que é o comprimento de uma string.",
                                  "commonMistakes": [
                                    "Confundir comprimento com número de palavras",
                                    "Contar espaços como separadores em vez de caracteres"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar Contagem Manual de Caracteres",
                                  "subSteps": [
                                    "Escreva strings simples como 'cat', 'dog' e conte caractere por caractere.",
                                    "Use uma régua ou dedo para marcar cada caractere enquanto conta.",
                                    "Repita com strings mais longas, como 'algorithm analysis'.",
                                    "Registre o comprimento para cada uma em uma tabela.",
                                    "Verifique contando de trás para frente."
                                  ],
                                  "verification": "Crie uma tabela com 5 strings e seus comprimentos corretos, sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis",
                                    "Lista de strings de exemplo"
                                  ],
                                  "tips": "Divida strings longas em sílabas para facilitar a contagem.",
                                  "learningObjective": "Desenvolver precisão na contagem manual de caracteres.",
                                  "commonMistakes": [
                                    "Pular caracteres invisíveis como espaços",
                                    "Contar letras maiúsculas/minúsculas de forma diferente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Lidar com Casos Especiais de Strings",
                                  "subSteps": [
                                    "Calcule para string vazia: ε ou '', onde |ε| = 0.",
                                    "Conte strings com espaços: 'a b c' tem |s| = 5.",
                                    "Inclua caracteres especiais: 'hello!' tem 6 caracteres.",
                                    "Teste strings com repetições: 'aaa' tem 3.",
                                    "Discuta unicidade: comprimento ignora significado, só conta símbolos."
                                  ],
                                  "verification": "Liste 4 casos especiais com cálculos corretos: vazia (0), com espaços (exato), com pontuação, repetições.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Lista de casos especiais impressa"
                                  ],
                                  "tips": "Sempre liste os caracteres um por um em uma linha para visualização.",
                                  "learningObjective": "Aplicar o conceito a strings não triviais.",
                                  "commonMistakes": [
                                    "Assumir string vazia tem comprimento 1",
                                    "Ignorar espaços ou tabs como caracteres"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Múltiplas Strings e Verificar Precisão",
                                  "subSteps": [
                                    "Dado um conjunto de strings, compute |s| para cada uma.",
                                    "Crie um programa mental ou tabela para entrada múltipla.",
                                    "Compare resultados com uma segunda contagem.",
                                    "Simule entrada de usuário: receba 3 strings e retorne comprimentos.",
                                    "Documente o processo para auditoria."
                                  ],
                                  "verification": "Processe 5 strings variadas e acerte 100% dos comprimentos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou tabela digital",
                                    "Strings de teste variadas"
                                  ],
                                  "tips": "Use um contador mecânico ou app para prática inicial.",
                                  "learningObjective": "Computar comprimentos de forma eficiente e precisa em batch.",
                                  "commonMistakes": [
                                    "Erros de transcrição ao copiar strings",
                                    "Confundir ordem das strings"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado as strings s1 = \"pattern\", s2 = \"\", s3 = \"a b c!\", compute: |s1| = 6, |s2| = 0, |s3| = 6. Liste caracteres: s1: p-a-t-t-e-r-n; s3: a- -b- -c-!. Útil em pré-processamento para emparelhamento de padrões.",
                              "finalVerifications": [
                                "Calcule corretamente |s| para 10 strings aleatórias sem erros.",
                                "Explique diferença entre string vazia e string com espaço.",
                                "Identifique e corrija erros em cálculos de pares.",
                                "Crie tabela de comprimentos para um texto curto.",
                                "Demonstre contagem manual para string de 20+ caracteres."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de comprimento.",
                                "Tratamento correto de casos especiais (vazia, espaços, especiais).",
                                "Eficiência no tempo de contagem para strings médias.",
                                "Capacidade de explicar o processo passo a passo.",
                                "Aplicação consistente em múltiplas instâncias.",
                                "Ausência de erros comuns como ignorar espaços."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceito de cardinalidade de conjuntos finitos.",
                                "Linguística: Análise morfológica e contagem de fonemas/letras.",
                                "Física: Medição de comprimentos em sequências discretas (ex: partículas).",
                                "Estatística: Pré-processamento de dados textuais para análise."
                              ],
                              "realWorldApplication": "Em busca de texto (Google), validação de campos de formulário (máx. 140 chars no Twitter), análise de DNA (comprimento de sequências genéticas), compressão de dados (calcular tamanhos antes/ depois)."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Representar strings formalmente",
                            "description": "Escrever a notação formal de uma string s ∈ Σ*, especificando o alfabeto Σ e utilizando notação como s = s[0] s[1] ... s[|s|-1], com índices iniciando em 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Definir o Alfabeto Σ",
                                  "subSteps": [
                                    "Revise a definição de alfabeto Σ como um conjunto finito de símbolos.",
                                    "Analise a string s e identifique todos os símbolos únicos presentes nela.",
                                    "Escreva Σ como um conjunto {símbolo1, símbolo2, ..., símboloK}, ordenando alfabeticamente para clareza.",
                                    "Confirme que todos os caracteres de s pertencem a Σ."
                                  ],
                                  "verification": "Liste Σ e verifique se todos os caracteres únicos de s estão incluídos sem duplicatas ou extras.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de strings simples como 'aba' ou 'mississippi'"
                                  ],
                                  "tips": [
                                    "Ordene os símbolos em Σ alfabeticamente para padronização.",
                                    "Lembre-se: Σ contém apenas símbolos únicos, não a contagem de ocorrências."
                                  ],
                                  "learningObjective": "Compreender o conceito de alfabeto finito e defini-lo corretamente para uma string dada.",
                                  "commonMistakes": [
                                    "Incluir símbolos não presentes em s",
                                    "Esquecer um símbolo que aparece em s",
                                    "Usar parênteses em vez de chaves para o conjunto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o Comprimento |s| e os Índices",
                                  "subSteps": [
                                    "Conte o número total de caracteres na string s para obter |s| = n.",
                                    "Liste os índices sequenciais de 0 até |s|-1.",
                                    "Associe cada posição i (0 ≤ i < |s|) ao símbolo s[i].",
                                    "Verifique que o último índice é |s|-1."
                                  ],
                                  "verification": "Escreva |s| e liste s[0] até s[|s|-1], confirmando que coincide com s.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "String de exemplo impressa ou digital",
                                    "Calculadora para strings longas (opcional)"
                                  ],
                                  "tips": [
                                    "Índices sempre começam em 0, independentemente da linguagem de programação.",
                                    "Use |s| em vez de um número fixo para generalidade."
                                  ],
                                  "learningObjective": "Calcular corretamente o comprimento de s e mapear símbolos aos índices baseados em 0.",
                                  "commonMistakes": [
                                    "Contar errado o comprimento (ex: esquecer espaços)",
                                    "Iniciar índices em 1 em vez de 0",
                                    "Confundir |s| com o número de símbolos únicos em Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever a Representação Indexada da String",
                                  "subSteps": [
                                    "Escreva a notação s = s[0] s[1] ... s[|s|-1].",
                                    "Substitua cada s[i] pelo símbolo real na string, se necessário para clareza.",
                                    "Garanta que a concatenação dos s[i] forme exatamente s.",
                                    "Inclua os valores explícitos de s[i] em uma lista adjacente para verificação."
                                  ],
                                  "verification": "Concatene os s[i] listados e confirme que resulta em s original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado para alinhar índices",
                                    "Editor de texto para prática"
                                  ],
                                  "tips": [
                                    "Use reticências (...) apenas se |s| for grande; liste todos para strings curtas.",
                                    "Mantenha notação simbólica s[i] para formalidade."
                                  ],
                                  "learningObjective": "Representar s formalmente como concatenação de símbolos indexados.",
                                  "commonMistakes": [
                                    "Usar índices errados ou fora de ordem",
                                    "Escrever s = s[1] s[2] ... s[n] iniciando em 1",
                                    "Omitir o último termo s[|s|-1]"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar em Notação Formal Completa",
                                  "subSteps": [
                                    "Una Σ, a representação indexada e s ∈ Σ*.",
                                    "Escreva a declaração completa: 'Seja Σ = {...}, então s ∈ Σ* com s = s[0] s[1] ... s[|s|-1]'.",
                                    "Valide que cada s[i] ∈ Σ.",
                                    "Teste com uma string de exemplo para confirmar."
                                  ],
                                  "verification": "Leia a notação completa em voz alta e verifique consistência lógica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelos de notações formais de referências teóricas"
                                  ],
                                  "tips": [
                                    "Sempre especifique Σ primeiro, seguido de s ∈ Σ*.",
                                    "Use 'seja' ou 'given' para introduzir formalmente."
                                  ],
                                  "learningObjective": "Construir a representação formal integral de uma string em teoria de linguagens.",
                                  "commonMistakes": [
                                    "Esquecer s ∈ Σ*",
                                    "Definir Σ inconsistente com os s[i] usados",
                                    "Notação incompleta sem índices explícitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para s = 'aba', defina Σ = {a, b}. Então s ∈ {a, b}*, com |s| = 3 e s = s[0] s[1] s[2], onde s[0] = 'a', s[1] = 'b', s[2] = 'a'.",
                              "finalVerifications": [
                                "Σ contém exatamente os símbolos únicos de s?",
                                "Notação s = s[0] s[1] ... s[|s|-1] está presente e correta?",
                                "Índices iniciam em 0 e terminam em |s|-1?",
                                "s ∈ Σ* é explicitamente declarado?",
                                "Todos s[i] pertencem a Σ?",
                                "|s| é calculado corretamente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de Σ (todos símbolos únicos incluídos, sem extras) - 25%",
                                "Correção do comprimento |s| e mapeamento de índices - 25%",
                                "Formato exato da notação indexada - 25%",
                                "Declaração completa s ∈ Σ* e clareza geral - 25%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Notação de conjuntos finitos e sequências indexadas.",
                                "Linguística: Conceitos de alfabeto e morfemas em linguagem formal.",
                                "Programação: Manipulação de strings em Python/Java com indexação [0:n].",
                                "Teoria da Informação: Entropia e comprimento de strings sobre alfabetos."
                              ],
                              "realWorldApplication": "Em algoritmos de emparelhamento de padrões como KMP ou Boyer-Moore, strings são representadas formalmente para analisar complexidade em buscas de texto, sequências de DNA ou compressão de dados, garantindo precisão em aplicações como editores de texto e genômica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Texto e Padrão no Problema",
                        "description": "O texto T é uma string de comprimento m (|T| = m), e o padrão P é uma string de comprimento n (|P| = n), com n ≤ m, ambas definidas sobre o mesmo alfabeto Σ.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Distinguir texto de padrão",
                            "description": "Explicar a diferença entre o texto T (string longa de entrada) e o padrão P (string curta a ser buscada), destacando suas funções no problema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Texto T como String de Entrada Principal",
                                  "subSteps": [
                                    "Leia a definição formal: T é uma string longa que representa o texto de entrada no problema de emparelhamento de padrões.",
                                    "Identifique T como o 'haystack' (palheiro) onde o padrão será buscado.",
                                    "Note que T geralmente tem comprimento n, onde n é grande (ex: milhares de caracteres).",
                                    "Examine exemplos simples: T = 'abracadabra'.",
                                    "Registre o papel de T: fornece o contexto completo para a busca."
                                  ],
                                  "verification": "Escreva uma definição de T em suas próprias palavras e identifique seu papel no problema.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou Jupyter Notebook"
                                  ],
                                  "tips": "Sempre associe T a algo familiar, como um livro ou documento inteiro.",
                                  "learningObjective": "Compreender T como a string fonte extensa no emparelhamento de padrões.",
                                  "commonMistakes": "Confundir T com o padrão P, assumindo que T é curta ou o alvo da busca."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Padrão P como String de Busca",
                                  "subSteps": [
                                    "Leia a definição: P é uma string curta que representa o padrão a ser encontrado em T.",
                                    "Identifique P como a 'needle' (agulha) no palheiro T.",
                                    "Note que P tem comprimento m, onde m << n (ex: poucos caracteres).",
                                    "Examine exemplos: P = 'abra' para T = 'abracadabra'.",
                                    "Registre funções: P define o que exatamente procurar em T."
                                  ],
                                  "verification": "Descreva P e dê um exemplo de seu uso em um T hipotético.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto"
                                  ],
                                  "tips": "Pense em P como uma palavra-chave em um mecanismo de busca.",
                                  "learningObjective": "Entender P como o elemento buscado de tamanho reduzido.",
                                  "commonMistakes": "Achar que P pode ser maior que T ou que T busca P."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças e Funções de T e P",
                                  "subSteps": [
                                    "Liste diferenças chave: T é longa (n chars), P é curta (m chars); T é passiva, P é ativa na busca.",
                                    "Descreva funções: T armazena dados; P especifica o match desejado.",
                                    "Crie uma tabela comparativa: colunas para tamanho, função, exemplo.",
                                    "Explique impacto no algoritmo: eficiência depende de n e m.",
                                    "Discuta saídas: posições onde P ocorre em T."
                                  ],
                                  "verification": "Crie uma tabela ou diagrama destacando 5 diferenças entre T e P.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel, caneta ou ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Use analogias visuais: T como oceano, P como barco específico.",
                                  "learningObjective": "Distinguir claramente funções e diferenças entre T e P no contexto do problema.",
                                  "commonMistakes": "Ignorar o tamanho relativo ou inverter papéis (P como contexto)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Distinção em um Exemplo Prático",
                                  "subSteps": [
                                    "Escolha T = 'mississippi' e P = 'iss'.",
                                    "Identifique manualmente ocorrências de P em T.",
                                    "Explique por que T é o texto e P o padrão nesta instância.",
                                    "Varie exemplos: teste com T sem P para reforçar distinção.",
                                    "Resuma lições aprendidas sobre funções."
                                  ],
                                  "verification": "Analise um exemplo dado e explique distinções corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Pseudocódigo simples"
                                  ],
                                  "tips": "Implemente uma busca manual para internalizar conceitos.",
                                  "learningObjective": "Aplicar distinção de T e P em cenários reais de emparelhamento.",
                                  "commonMistakes": "Contar comprimento errado ou falhar em localizar matches."
                                }
                              ],
                              "practicalExample": "Texto T: 'abracadabra' (comprimento 11). Padrão P: 'abra' (comprimento 4). Função: Buscar posições onde 'abra' aparece em 'abracadabra' (posições 0 e 4). T é o documento fonte; P define o termo exato a localizar.",
                              "finalVerifications": [
                                "Define T como string longa de entrada com precisão.",
                                "Define P como string curta de busca corretamente.",
                                "Lista pelo menos 3 diferenças chave entre T e P.",
                                "Explica funções de T e P no problema de emparelhamento.",
                                "Identifica corretamente em um exemplo prático.",
                                "Demonstra compreensão via diagrama ou tabela."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de T e P (30%).",
                                "Clareza na explicação de diferenças e funções (25%).",
                                "Uso correto de exemplos e analogias (20%).",
                                "Profundidade na aplicação prática (15%).",
                                "Ausência de confusões comuns como inversão de papéis (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise de padrões em textos e corpora linguísticos.",
                                "Biologia: Busca de sequências genéticas (T=DNA, P=genoma alvo).",
                                "Processamento de Linguagem Natural: Matching em documentos NLP.",
                                "Matemática: Teoria de strings e autômatos finitos."
                              ],
                              "realWorldApplication": "Em motores de busca como Google, T é o conteúdo de uma página web ou documento, e P é a consulta do usuário; usado também em bioinformática para encontrar genes em sequências de DNA longas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Denotar comprimentos m e n",
                            "description": "Utilizar corretamente a notação |T| = m e |P| = n em descrições formais, reconhecendo que tipicamente n << m em aplicações práticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Texto e Padrão",
                                  "subSteps": [
                                    "Ler a definição formal do Problema do Emparelhamento de Padrões (String Matching).",
                                    "Identificar o texto T como a string principal onde a busca ocorre.",
                                    "Identificar o padrão P como a substring a ser encontrada em T.",
                                    "Exemplificar com strings simples: T = 'hello', P = 'ell'.",
                                    "Diferenciar T (longo) de P (curto) em contextos reais."
                                  ],
                                  "verification": "Escrever uma frase explicando o que são T e P no problema.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Slides ou capítulo de livro sobre algoritmos de string matching",
                                    "Editor de texto para anotar exemplos"
                                  ],
                                  "tips": "Sempre visualize T como o 'haystack' (palheiro) e P como a 'needle' (agulha).",
                                  "learningObjective": "Reconhecer T e P como elementos fundamentais do problema de emparelhamento.",
                                  "commonMistakes": "Confundir T com P ou inverter seus papéis na descrição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Notação Formal de Comprimentos",
                                  "subSteps": [
                                    "Estudar a notação |T| para denotar o comprimento do texto.",
                                    "Associar |T| = m, onde m é um inteiro positivo representando o tamanho de T.",
                                    "Estudar a notação |P| para denotar o comprimento do padrão.",
                                    "Associar |P| = n, onde n é um inteiro positivo representando o tamanho de P.",
                                    "Praticar escrevendo |T| = m e |P| = n em uma descrição formal simples."
                                  ],
                                  "verification": "Escrever corretamente |T| = 10 e |P| = 3 para um exemplo dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Exemplos de strings de comprimentos variados"
                                  ],
                                  "tips": "Use barras verticais | | para cardinalidade, nunca parênteses ().",
                                  "learningObjective": "Dominar a notação exata |T| = m e |P| = n em contextos formais.",
                                  "commonMistakes": "Escrever len(T) = m em vez de |T| = m, ou omitir os sinais de igualdade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer a Relação Típica n << m",
                                  "subSteps": [
                                    "Analisar exemplos onde o padrão é muito menor que o texto (n pequeno, m grande).",
                                    "Entender que em aplicações práticas, n << m otimiza algoritmos como KMP.",
                                    "Calcular ratios: n/m < 0.1 em casos reais.",
                                    "Listar cenários: busca em documentos longos por palavras curtas.",
                                    "Explicar por que essa relação é assumida na análise de complexidade."
                                  ],
                                  "verification": "Identificar e justificar n << m em 3 exemplos diferentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Lista de strings reais (ex: texto de livro, padrões curtos)"
                                  ],
                                  "tips": "Pense em buscas no Google: query (n) vs. página web (m).",
                                  "learningObjective": "Compreender e aplicar a desigualdade típica n << m.",
                                  "commonMistakes": "Assumir n ≈ m ou ignorar a implicação para eficiência algorítmica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Descrições Formais Completas",
                                  "subSteps": [
                                    "Escrever uma descrição formal completa: 'Dado T com |T| = m e P com |P| = n onde n << m'.",
                                    "Aplicar em um problema: encontrar todas ocorrências de P em T.",
                                    "Revisar e corrigir descrições de pares T/P fornecidos.",
                                    "Criar seu próprio exemplo com notação correta.",
                                    "Discutir exceções raras onde n não é << m."
                                  ],
                                  "verification": "Produzir 2 descrições formais sem erros de notação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de problemas de string matching",
                                    "Ferramenta de linting para LaTeX ou Markdown"
                                  ],
                                  "tips": "Inclua sempre 'tipicamente n << m' para precisão.",
                                  "learningObjective": "Integrar notação e relação em descrições formais acionáveis.",
                                  "commonMistakes": "Esquecer a menção a n << m ou usar notação inconsistente."
                                }
                              ],
                              "practicalExample": "Considere T = 'ababcabcacbab' (|T| = 13 = m) e P = 'abcac' (|P| = 5 = n), onde n << m. O algoritmo deve encontrar posições i onde T[i..i+n-1] = P.",
                              "finalVerifications": [
                                "Escreve corretamente |T| = m e |P| = n em uma descrição formal.",
                                "Identifica T e P em um problema dado.",
                                "Justifica n << m com um exemplo numérico.",
                                "Aplica a notação em análise de complexidade simples.",
                                "Distingue cenários onde n não é << m."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação |T| = m e |P| = n (sem erros tipográficos).",
                                "Inclusão explícita de 'n << m' em contextos práticos.",
                                "Clareza na distinção entre T e P.",
                                "Uso correto em descrições formais completas.",
                                "Compreensão demonstrada via exemplos originais.",
                                "Evitação de notações alternativas como len() ou size()."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Notação de cardinalidade de conjuntos e desigualdades.",
                                "Linguística: Análise de estruturas textuais e padrões linguísticos.",
                                "Estatística: Análise de distribuições de comprimentos em dados textuais.",
                                "Engenharia de Software: Modelagem formal em documentação técnica."
                              ],
                              "realWorldApplication": "Em motores de busca como Google, onde padrões curtos (queries, n) são buscados em páginas web enormes (T, m), otimizando tempo de resposta; ou em editores de texto para 'find and replace' eficientes."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Verificar restrições de entrada",
                            "description": "Validar se n ≤ m para instâncias do problema e discutir o que ocorre se n > m (nenhuma ocorrência possível).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de n e m no problema",
                                  "subSteps": [
                                    "Leia a definição do problema de emparelhamento de padrões: texto T de comprimento m e padrão P de comprimento n.",
                                    "Identifique n como o tamanho do padrão P (número de caracteres em P).",
                                    "Identifique m como o tamanho do texto T (número de caracteres em T).",
                                    "Compare n e m conceitualmente: explique por que o tamanho importa para buscas.",
                                    "Crie um diagrama simples mostrando T e P com seus comprimentos anotados."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que são n e m, com um exemplo onde n < m.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Definição do problema de pattern matching",
                                    "Papel e caneta para diagramas",
                                    "Exemplos de strings simples"
                                  ],
                                  "tips": [
                                    "Lembre-se: n = len(P), m = len(T). Use funções de comprimento em pseudocódigo."
                                  ],
                                  "learningObjective": "Dominar a identificação precisa de n e m no contexto do problema.",
                                  "commonMistakes": [
                                    "Confundir n com m (padrão vs. texto)",
                                    "Esquecer caracteres especiais ou espaços no comprimento",
                                    "Assumir strings vazias têm comprimento indefinido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a verificação da restrição n ≤ m",
                                  "subSteps": [
                                    "Escreva pseudocódigo para calcular n = comprimento(P) e m = comprimento(T).",
                                    "Adicione uma condição if n > m then retornar 'impossível' ou 'nenhuma ocorrência'.",
                                    "Teste o código com entrada válida (n ≤ m) e observe o fluxo.",
                                    "Integre essa verificação como primeiro passo de um algoritmo de matching.",
                                    "Documente o código com comentários explicando a restrição."
                                  ],
                                  "verification": "Execute o pseudocódigo com n ≤ m e confirme que prossegue; com n > m, para corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE simples",
                                    "Pseudocódigo template para pattern matching",
                                    "Strings de teste: T='abc', P='ab'"
                                  ],
                                  "tips": [
                                    "Faça a verificação no início para otimizar tempo; evite processamento desnecessário."
                                  ],
                                  "learningObjective": "Criar uma validação programática eficiente da restrição de entrada.",
                                  "commonMistakes": [
                                    "Calcular comprimento incorretamente (ex: ignorar null terminators)",
                                    "Colocar verificação após loops desnecessários",
                                    "Não tratar n=0 ou m=0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o caso n > m e suas implicações",
                                  "subSteps": [
                                    "Discuta conceitualmente: por que n > m torna impossível qualquer ocorrência de P em T?",
                                    "Desenhe um exemplo visual: T com m=3 ('abc'), P com n=4 ('abcd') e mostre sobreposição impossível.",
                                    "Explique impactos no algoritmo: economia de tempo, complexidade O(1) para essa verificação.",
                                    "Considere casos edge: n=0 (padrão vazio sempre ocorre?), m=0 (texto vazio).",
                                    "Escreva um parágrafo resumindo as consequências de violar a restrição."
                                  ],
                                  "verification": "Responda: 'O que acontece se n > m?' com justificativa lógica e exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para desenhos visuais",
                                    "Exemplos de strings com n > m",
                                    "Referência teórica de algoritmos"
                                  ],
                                  "tips": [
                                    "Pense geometricamente: P não cabe em T como uma substring."
                                  ],
                                  "learningObjective": "Compreender as razões lógicas e de eficiência da restrição.",
                                  "commonMistakes": [
                                    "Achar que n > m permite matches parciais",
                                    "Ignorar que match exato requer n ≤ m",
                                    "Confundir com overlaps circulares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e testar a verificação em cenários práticos",
                                  "subSteps": [
                                    "Escolha um texto real (ex: frase de livro) e padrão maior que o texto.",
                                    "Implemente e rode a verificação em código real (Python ou similar).",
                                    "Teste múltiplos casos: n < m, n = m, n > m, n=0.",
                                    "Registre resultados e discuta otimizações.",
                                    "Reflita: como isso se integra a algoritmos como KMP ou Boyer-Moore?"
                                  ],
                                  "verification": "Forneça logs de testes mostrando comportamento correto em todos casos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente de programação (Python/Jupyter)",
                                    "Strings de teste variadas",
                                    "Documentação de len() em linguagens"
                                  ],
                                  "tips": [
                                    "Use asserts para automação: assert n <= m or 'impossível'."
                                  ],
                                  "learningObjective": "Aplicar a verificação de forma robusta e testada.",
                                  "commonMistakes": [
                                    "Não testar edges como strings vazias",
                                    "Erros de codificação UTF-8 afetando len()",
                                    "Assumir sempre n ≤ m sem verificar"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto T = 'programacao' (m=10), Padrão P = 'algoritmoscomplexos' (n=17). Verificação: 17 > 10 → 'Nenhuma ocorrência possível'. Isso evita buscas inúteis em T, poupando tempo computacional.",
                              "finalVerifications": [
                                "Identifica corretamente n e m em qualquer par T/P dado.",
                                "Implementa verificação if n > m com saída apropriada.",
                                "Explica logicamente por que n > m impossibilita matches.",
                                "Trata casos edge (n=0, m=0) corretamente.",
                                "Integra a verificação como otimização inicial em fluxos de algoritmo.",
                                "Testa com exemplos reais e documenta resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo de n e m (100% correto).",
                                "Corretude lógica na análise de n > m (sem falhas conceituais).",
                                "Eficiência da implementação (verificação O(1) no início).",
                                "Cobertura de casos edge e testes abrangentes.",
                                "Clareza na explicação escrita e verbal das implicações.",
                                "Integração prática com algoritmos de matching."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Desigualdades e propriedades de comprimentos (aritmética básica).",
                                "Lógica: Condicionais booleanas e raciocínio dedutivo.",
                                "Programação: Manipulação de strings e controle de fluxo.",
                                "Análise de dados: Pré-processamento de entradas para eficiência."
                              ],
                              "realWorldApplication": "Em motores de busca como Google ou editores de texto (VS Code find/replace), verifica-se se o termo de busca cabe no documento antes de indexar, evitando processamento desnecessário em arquivos grandes, como logs de sistemas ou genomas em bioinformática."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Ocorrência de Padrão",
                        "description": "Uma ocorrência do padrão P no texto T na posição inicial i (0 ≤ i ≤ m - n) é definida por T[i + j] = P[j] para todo j = 0, 1, ..., n-1, onde os índices começam em 0.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Definir match exato",
                            "description": "Formalizar a condição de emparelhamento exato: o substring T[i..i+n-1] é idêntico a P.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Strings e Substrings",
                                  "subSteps": [
                                    "Defina string como uma sequência finita de caracteres.",
                                    "Explique substring como uma sequência contígua de caracteres de uma string maior.",
                                    "Aprenda indexação de strings (geralmente 0-based: posição i inicia em 0).",
                                    "Diferencie o texto T (string principal) do padrão P (string a ser encontrada).",
                                    "Pratique identificando substrings em exemplos simples como T='abcde', substring T[1:4]='bcd'."
                                  ],
                                  "verification": "Escreva definições próprias e identifique 3 substrings em uma string exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples (Notepad ou similar)"
                                  ],
                                  "tips": "Sempre visualize a string com índices anotados para evitar confusões.",
                                  "learningObjective": "Dominar terminologia essencial para emparelhamento.",
                                  "commonMistakes": [
                                    "Usar indexação 1-based em vez de 0-based",
                                    "Confundir substring com subsequência não contígua"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Problema do Emparelhamento de Padrões",
                                  "subSteps": [
                                    "Descreva o problema: dada T de tamanho m e P de tamanho n, encontrar posições i onde P ocorre em T.",
                                    "Defina n = comprimento de P, m = comprimento de T.",
                                    "Explique que match só ocorre se m >= n.",
                                    "Discuta a necessidade de comparação posição por posição.",
                                    "Liste condições prévias: T e P são strings sobre o mesmo alfabeto."
                                  ],
                                  "verification": "Resuma o problema em uma frase e verifique com um diagrama simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para diagramas",
                                    "Exemplos impressos de strings"
                                  ],
                                  "tips": "Desenhe T e possíveis posições de P sobrepostas para visualizar.",
                                  "learningObjective": "Contextualizar o match exato no problema maior.",
                                  "commonMistakes": [
                                    "Ignorar que n deve ser <= m",
                                    "Confundir P com parte de T sem contiguidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Condição de Match Exato",
                                  "subSteps": [
                                    "Estabeleça a definição: Um match exato em posição i se T[i..i+n-1] == P[0..n-1].",
                                    "Explique notação: T[i..i+n-1] significa caracteres de i até i+n-1 inclusive.",
                                    "Formalize matematicamente: Para todo j de 0 a n-1, T[i+j] = P[j].",
                                    "Verifique limites: i+n-1 < m para evitar overflow.",
                                    "Escreva a condição em pseudocódigo: for j=0 to n-1 if T[i+j] != P[j] no match."
                                  ],
                                  "verification": "Escreva a definição formal e prove com um exemplo curto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo em editor",
                                    "Folha para fórmulas matemáticas"
                                  ],
                                  "tips": "Use setas para mapear posições de P sobre T.",
                                  "learningObjective": "Formalizar precisamente a condição de igualdade.",
                                  "commonMistakes": [
                                    "Erro nos limites: i+n-1 >= m",
                                    "Comparar apenas comprimentos sem conteúdo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar a Definição em Exemplos",
                                  "subSteps": [
                                    "Aplique em T='abcde', P='bc': match em i=1 pois T[1:3]='bc'.",
                                    "Teste negativo: T='abc', P='bd' - sem match.",
                                    "Verifique múltiplos: T='ABAB', P='AB' - matches em i=0 e i=2.",
                                    "Implemente verificação manual para 2 exemplos complexos.",
                                    "Registre posições de matches em uma tabela."
                                  ],
                                  "verification": "Identifique todos matches em um T e P dados e justifique.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela em papel ou Excel simples",
                                    "Strings de exemplo anotadas"
                                  ],
                                  "tips": "Comece com strings curtas para ganhar confiança antes de longas.",
                                  "learningObjective": "Aplicar a definição prática e corretamente.",
                                  "commonMistakes": [
                                    "Pular verificação de todos j",
                                    "Contar índices errados em matches múltiplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado T = 'ABABDABACDABABCABAB' (m=19) e P = 'ABABCABAB' (n=9), verifique match em i=10: T[10:18] = 'ABABCABAB' == P, sim match exato.",
                              "finalVerifications": [
                                "Defina formalmente match exato usando notação T[i..i+n-1] == P.",
                                "Identifique corretamente matches em T='mississippi', P='iss' (i=1,4).",
                                "Explique por que não há match se i+n-1 >= m.",
                                "Prove igualdade posição por posição para um exemplo.",
                                "Diferencie match exato de aproximado ou parcial.",
                                "Escreva pseudocódigo para checar um i específico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (T[i..i+n-1]).",
                                "Correção em identificação de matches e não-matches.",
                                "Uso consistente de indexação 0-based.",
                                "Explicação clara da condição para todo j: T[i+j]=P[j].",
                                "Tratamento correto de limites de string.",
                                "Aplicação em exemplos variados sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Igualdade de sequências e indução em comprimentos.",
                                "Linguística: Análise de padrões em textos e morfemas.",
                                "Biologia: Matching de sequências de DNA ou proteínas.",
                                "Processamento de Sinais: Detecção de padrões em sequências numéricas.",
                                "Literatura: Busca de motivos ou frases exatas em textos."
                              ],
                              "realWorldApplication": "Em motores de busca de texto (Ctrl+F no Word), algoritmos de busca como Boyer-Moore, análise genômica para encontrar genes exatos em sequências de DNA, detecção de plágio em documentos e filtros antispam em emails."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Identificar posições de ocorrência",
                            "description": "Dado T e P, listar todas as posições i onde ocorre um match exato, verificando manualmente a condição para pequenos exemplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o texto T e o padrão P",
                                  "subSteps": [
                                    "Leia atentamente o texto T e identifique seu comprimento total (número de caracteres).",
                                    "Analise o padrão P e note seu comprimento exato (len(P)).",
                                    "Confirme que len(T) >= len(P); caso contrário, não há matches possíveis.",
                                    "Escreva T e P em linhas separadas para visualização clara, numerando as posições de T de 1 a len(T).",
                                    "Defina que um match ocorre se T[i..i+len(P)-1] == P exatamente."
                                  ],
                                  "verification": "Você pode recitar os comprimentos de T e P e apontar onde um match poderia ocorrer.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta para anotar T e P",
                                    "Exemplo impresso ou tela"
                                  ],
                                  "tips": "Use índices 1-based para iniciantes (posição 1 é o primeiro caractere).",
                                  "learningObjective": "Entender os componentes básicos do problema de emparelhamento.",
                                  "commonMistakes": [
                                    "Confundir len(T) com len(P)",
                                    "Usar índices 0-based inadvertidamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escanear o texto T posição por posição",
                                  "subSteps": [
                                    "Comece na posição i=1 de T.",
                                    "Para cada i de 1 até len(T) - len(P) + 1, marque o segmento T[i..i+len(P)-1].",
                                    "Compare caractere por caractere esse segmento com P.",
                                    "Se todos os caracteres coincidirem, anote 'match' na posição i; caso contrário, 'no match'.",
                                    "Avance para i+1 e repita."
                                  ],
                                  "verification": "Lista completa de 'match' ou 'no match' para cada posição possível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel com T numerado",
                                    "Lápis para marcar segmentos"
                                  ],
                                  "tips": "Desenhe caixas ao redor de cada segmento possível para visualização.",
                                  "learningObjective": "Desenvolver habilidade de comparação sistemática de substrings.",
                                  "commonMistakes": [
                                    "Pular posições ou sobrepor incorretamente segmentos",
                                    "Comparar substrings desalinhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Registrar todas as posições de match",
                                  "subSteps": [
                                    "Revise a lista de escaneamento e colete todas as posições i marcadas como 'match'.",
                                    "Liste-as em ordem crescente em uma nova linha.",
                                    "Para cada posição, reescreva o substring correspondente para confirmar == P.",
                                    "Conte o número total de matches.",
                                    "Se não houver matches, liste como 'nenhuma posição'."
                                  ],
                                  "verification": "Lista numerada de posições com substrings confirmados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de escaneamento do Step 2"
                                  ],
                                  "tips": "Use uma tabela: Posição | Substring | Match? para organização.",
                                  "learningObjective": "Praticar registro preciso e ordenado de resultados.",
                                  "commonMistakes": [
                                    "Incluir falsos positivos",
                                    "Esquecer de verificar sobreposições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a lista final de posições",
                                  "subSteps": [
                                    "Para cada posição listada, extraia novamente T[i..i+len(P)-1] e compare com P.",
                                    "Verifique se todas as posições possíveis foram consideradas (até len(T)-len(P)+1).",
                                    "Teste com uma variação pequena de T ou P para checar consistência.",
                                    "Discuta ou explique verbalmente por que cada posição é ou não um match.",
                                    "Documente a lista final como resposta."
                                  ],
                                  "verification": "Todas as posições validadas sem discrepâncias.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista final do Step 3",
                                    "T e P originais"
                                  ],
                                  "tips": "Leia em voz alta as comparações para detectar erros.",
                                  "learningObjective": "Garantir precisão e robustez na identificação.",
                                  "commonMistakes": [
                                    "Ignorar validação",
                                    "Confundir matches sobrepostos como separados"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado T = 'mississippi' (len=11) e P = 'iss' (len=3), escaneie: i=1: mis=no; i=2: iss=yes; i=3: ssi=no; i=4: sip=no; i=5: iss=yes; i=6: ssi=no; i=7: sip=no; i=8: ipp=no; i=9: ppi=no. Posições: 2, 5.",
                              "finalVerifications": [
                                "Lista todas as posições i onde T[i..i+len(P)-1] == P exatamente.",
                                "Número de posições corresponde ao esperado para o exemplo.",
                                "Nenhuma posição além de len(T)-len(P)+1 incluída.",
                                "Substrings extraídos confirmam matches.",
                                "Lista em ordem crescente sem duplicatas.",
                                "Caso sem matches, explicitamente indicado."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos matches corretos identificados.",
                                "Completude: Todas as posições possíveis escaneadas.",
                                "Clareza: Lista bem formatada com explicações.",
                                "Validação: Evidência de verificação de cada match.",
                                "Eficiência: Escaneamento sistemático sem redundâncias.",
                                "Explicação: Capacidade de justificar cada posição."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Padrões e sequências em álgebra.",
                                "Biologia: Busca de sequências em DNA (motifs genéticos).",
                                "Linguística: Análise de padrões em textos e morfologia.",
                                "Estatística: Frequência de substrings em dados."
                              ],
                              "realWorldApplication": "Em bioinformática, identificar posições de genes em sequências de DNA; em processamento de texto, encontrar todas as ocorrências de uma palavra em um documento para análise de sentimentos ou busca avançada."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Escrever condição formal de ocorrência",
                            "description": "Escrever a equação ∀j ∈ {0..n-1}, T[i+j] = P[j], e determinar o intervalo válido para i: 0 ≤ i ≤ m-n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes e notação básica",
                                  "subSteps": [
                                    "Defina T como o texto de comprimento m (ex: T tem m caracteres, índices de 0 a m-1).",
                                    "Defina P como o padrão de comprimento n (n ≤ m, índices de 0 a n-1).",
                                    "Identifique i como a posição inicial de alinhamento no texto T.",
                                    "Explique j como o deslocamento relativo dentro do padrão (j varia de 0 a n-1).",
                                    "Anote os símbolos: ∀ para 'para todo', ∈ para 'pertence a'."
                                  ],
                                  "verification": "Escreva definições claras de T, P, m, n, i e j com um exemplo simples (ex: T='abc', m=3).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de strings curtas"
                                  ],
                                  "tips": "Sempre use indexação base 0 para consistência com programação.",
                                  "learningObjective": "Dominar a notação padrão de strings, comprimentos e índices usados em emparelhamento de padrões.",
                                  "commonMistakes": [
                                    "Confundir comprimento m de T com n de P",
                                    "Usar indexação base 1 em vez de 0",
                                    "Ignorar que n ≤ m"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a condição de igualdade para um deslocamento j",
                                  "subSteps": [
                                    "Para um j fixo, escreva T[i + j] = P[j], significando que o caractere em posição i+j de T deve igualar o j-ésimo de P.",
                                    "Desenhe um diagrama alinhando P sobre T começando em i.",
                                    "Teste com um exemplo: T='abcd', P='bc', i=1, j=0: T[1]='b'==P[0]; j=1: T[2]='c'==P[1].",
                                    "Verifique o que acontece se não igualar (não é match).",
                                    "Generalize: isso deve valer para cada posição j no padrão."
                                  ],
                                  "verification": "Para um exemplo dado, escreva e valide T[i+j] = P[j] para j=0 e j=1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para diagramas de alinhamento",
                                    "Strings de exemplo"
                                  ],
                                  "tips": "Visualize o 'deslizamento' de P sobre T para entender o alinhamento.",
                                  "learningObjective": "Entender a correspondência caractere-por-caractere em uma posição i fixa.",
                                  "commonMistakes": [
                                    "Escrever T[i] = P[j] em vez de T[i+j]",
                                    "Confundir ordem de índices",
                                    "Esquecer que j é relativo a P"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a condição para todos os j usando quantificação",
                                  "subSteps": [
                                    "Estenda a igualdade para todos j: escreva ∀j ∈ {0..n-1}, T[i+j] = P[j].",
                                    "Defina o conjunto {0..n-1} como os índices válidos de P.",
                                    "Reescreva em notação matemática compacta, garantindo ∀ antes da condição.",
                                    "Teste com exemplo: para T='ABCDABC', P='ABC', i=4, verifique todos j=0,1,2.",
                                    "Confirme que se qualquer j falhar, não há ocorrência."
                                  ],
                                  "verification": "Escreva a fórmula completa ∀j ∈ {0..n-1}, T[i+j] = P[j] e valide com um exemplo numérico.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha para fórmulas",
                                    "Calculadora para índices (opcional)"
                                  ],
                                  "tips": "Leia em voz alta: 'Para todo j de 0 a n-1, T[i+j] equals P[j]' para fixar.",
                                  "learningObjective": "Aplicar quantificação universal para definir matching exato do padrão.",
                                  "commonMistakes": [
                                    "Escrever ∃ (existe) em vez de ∀ (para todo)",
                                    "Intervalo errado como {1..n}",
                                    "Omitir vírgula após ∈"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar e adicionar o intervalo válido para i",
                                  "subSteps": [
                                    "Estabeleça i ≥ 0 (não pode começar antes do texto).",
                                    "Para caber todo P, o último caractere P[n-1] deve estar em T[i + n - 1] < m, logo i ≤ m - n.",
                                    "Combine: 0 ≤ i ≤ m - n.",
                                    "Justifique: se i > m-n, i+n-1 ≥ m, acesso fora do texto.",
                                    "Inclua na definição formal completa."
                                  ],
                                  "verification": "Calcule m-n para um exemplo e liste i possíveis (ex: m=7, n=3 → i=0 a 4).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel para cálculos de intervalos"
                                  ],
                                  "tips": "Pense em i como 'espaço sobrando' no final: m - n.",
                                  "learningObjective": "Derivar e especificar restrições de bounds para posições válidas de ocorrência.",
                                  "commonMistakes": [
                                    "Escrever i ≤ m - n + 1 (off-by-one)",
                                    "i < 0 ou i > m",
                                    "Confundir m-n com n-m"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Combinar tudo em uma definição formal completa e verificar",
                                  "subSteps": [
                                    "Escreva a definição final: P ocorre em i se 0 ≤ i ≤ m-n e ∀j ∈ {0..n-1}, T[i+j] = P[j].",
                                    "Crie um exemplo completo e teste todas i possíveis.",
                                    "Identifique posições de ocorrência em um texto dado.",
                                    "Compare com pseudocódigo de verificação.",
                                    "Revise por erros de notação ou lógica."
                                  ],
                                  "verification": "Forneça T e P, liste todas i onde ocorre e justifique com a fórmula.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos complexos de T e P",
                                    "Pseudocódigo de loop"
                                  ],
                                  "tips": "Teste bordas: i=0, i=m-n, e um i inválido.",
                                  "learningObjective": "Sintetizar a condição formal completa de ocorrência de padrão.",
                                  "commonMistakes": [
                                    "Omitir o range de i",
                                    "Notação inconsistente",
                                    "Falhar em testar bounds"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto T = 'ABCDABC' (m=7), Padrão P = 'ABC' (n=3). Verificação para i=4 (válido pois 0 ≤ 4 ≤ 7-3=4): ∀j ∈ {0..2}, T[4+j] = P[j] → j=0: T[4]='A'== 'A'; j=1: T[5]='B'=='B'; j=2: T[6]='C'=='C'. Ocorrências em i=0 e i=4.",
                              "finalVerifications": [
                                "Escreve corretamente ∀j ∈ {0..n-1}, T[i+j] = P[j].",
                                "Especifica exatamente 0 ≤ i ≤ m-n.",
                                "Valida com exemplo: lista i válidos e verifica matching.",
                                "Explica por que i ≤ m-n (evita overflow).",
                                "Distingue de matching parcial (ex: não requer todos j iguais).",
                                "Testa caso n > m (nenhuma ocorrência possível)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (∀, ∈, intervalos).",
                                "Correção lógica da condição de igualdade e bounds.",
                                "Clareza e completude da definição formal.",
                                "Uso correto de exemplos para ilustração.",
                                "Justificativa dos limites de i.",
                                "Ausência de erros off-by-one em cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de predicados e teoria de conjuntos.",
                                "Linguística: Análise de padrões em sequências textuais.",
                                "Biologia: Busca de sequências em genomas (DNA matching).",
                                "Engenharia: Fundamento para algoritmos de compressão e busca."
                              ],
                              "realWorldApplication": "Essencial em algoritmos de busca de padrões como Knuth-Morris-Pratt (KMP) para motores de busca (Google), análise de DNA em bioinformática, detecção de plágio em textos e filtros antispam em emails."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.4",
                        "name": "Definição Formal do Problema",
                        "description": "O Problema do Emparelhamento de Padrões (String Matching Problem) recebe como entrada um texto T ∈ Σ^m e um padrão P ∈ Σ^n, e deve outputar o conjunto de todas as posições i em que P ocorre em T, ou indicar se não há ocorrências.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.4.1",
                            "name": "Enunciar entradas e saídas",
                            "description": "Descrever formalmente: Input: T, P; Output: lista de i's onde T[i..i+n-1] = P, ou 'não encontrado'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Input e Output em Problemas Algorítmicos",
                                  "subSteps": [
                                    "Revise a definição do Problema do Emparelhamento de Padrões: dado um texto T e um padrão P, encontrar todas as ocorrências de P em T.",
                                    "Identifique T como a string principal (texto de busca) e P como a substring a ser localizada.",
                                    "Entenda que inputs são dados de entrada e outputs são resultados esperados em notação formal.",
                                    "Discuta a importância da precisão na descrição formal para análise de algoritmos.",
                                    "Anote exemplos simples de strings T e P."
                                  ],
                                  "verification": "Escreva uma definição informal do problema em suas próprias palavras e compare com a descrição padrão.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples"
                                  ],
                                  "tips": [
                                    "Use notação matemática básica como |T| para comprimento de T.",
                                    "Comece com strings curtas para visualização."
                                  ],
                                  "learningObjective": "Ao final deste passo, você será capaz de explicar intuitivamente o que são T e P no contexto do emparelhamento de padrões.",
                                  "commonMistakes": [
                                    "Confundir T com P (texto vs. padrão)",
                                    "Ignorar comprimentos das strings (m e n)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente as Entradas (Input)",
                                  "subSteps": [
                                    "Declare Input como duas strings: T (texto de comprimento m) e P (padrão de comprimento n).",
                                    "Especifique que T e P pertencem ao alfabeto Σ (ex: {a,b,c,...}).",
                                    "Inclua restrições comuns: 1 ≤ n ≤ m ≤ 10^6, assumindo strings não vazias.",
                                    "Escreva a notação: Input: T ∈ Σ^m, P ∈ Σ^n.",
                                    "Verifique com um exemplo: T = 'abcabc', P = 'bc'."
                                  ],
                                  "verification": "Escreva a declaração formal de input e valide com um par de strings exemplo.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Documentação de notação algorítmica (opcional)"
                                  ],
                                  "tips": [
                                    "Sempre inclua os comprimentos m e n para clareza.",
                                    "Use subscritos para índices: T[0..m-1]."
                                  ],
                                  "learningObjective": "Ao final deste passo, você será capaz de descrever formalmente as entradas usando notação matemática padrão.",
                                  "commonMistakes": [
                                    "Esquecer de especificar o domínio das strings (Σ)",
                                    "Não mencionar comprimentos m e n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente as Saídas (Output)",
                                  "subSteps": [
                                    "Descreva output como lista de índices i (0-based) onde T[i..i+n-1] = P.",
                                    "Especifique que i satisfaz 0 ≤ i ≤ m - n.",
                                    "Inclua o caso 'não encontrado': lista vazia ou mensagem explícita.",
                                    "Ordene a lista em ordem crescente de i.",
                                    "Escreva: Output: lista de i's tal que T[i..i+n-1] = P, ou 'não encontrado'."
                                  ],
                                  "verification": "Construa a declaração de output e teste com T='abcabc', P='bc' → [1,4].",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Calculadora para índices"
                                  ],
                                  "tips": [
                                    "Índices 0-based são padrão em CS; confirme convenção.",
                                    "Visualize substrings manualmente."
                                  ],
                                  "learningObjective": "Ao final deste passo, você será capaz de formalizar o output incluindo casos edge.",
                                  "commonMistakes": [
                                    "Usar índices 1-based em vez de 0-based",
                                    "Esquecer overlaps (ex: P='aa' em T='aaa')"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Input e Output em uma Descrição Formal Completa",
                                  "subSteps": [
                                    "Junte as definições: Input: T, P; Output: lista de i's onde T[i..i+n-1] = P ou 'não encontrado'.",
                                    "Adicione detalhes: m = |T|, n = |P|, lista ordenada.",
                                    "Teste a descrição com múltiplos exemplos, incluindo não-encontrado.",
                                    "Revise por completude e precisão.",
                                    "Compare com definições padrão de livros como CLRS."
                                  ],
                                  "verification": "Escreva a descrição completa e valide com 3 exemplos variados.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel para rascunhos",
                                    "Exemplos de strings pré-preparados"
                                  ],
                                  "tips": [
                                    "Mantenha conciso mas preciso; evite ambiguidades.",
                                    "Inclua pseudocódigo se ajudar."
                                  ],
                                  "learningObjective": "Ao final deste passo, você será capaz de enunciar entradas e saídas de forma formal e completa.",
                                  "commonMistakes": [
                                    "Lista não ordenada",
                                    "Falta de tratamento para n > m"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo: T = 'ABABDABACDABABCABAB' (m=19), P = 'ABABC' (n=5). Output: [10, 14] (pois T[10:14]='ABABC', T[14:18]='ABABC'). Caso não encontrado: P='XYZ' → 'não encontrado'.",
                              "finalVerifications": [
                                "Descreva corretamente input como T e P com notação formal.",
                                "Liste output como posições i onde substring matches.",
                                "Trate caso de não encontrado explicitamente.",
                                "Use índices 0-based e especifique range i ≤ m-n.",
                                "Valide com exemplo prático sem erros.",
                                "Explique diferenças entre overlaps e não-overlaps."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (Σ, m, n).",
                                "Correta definição de matching substring.",
                                "Tratamento completo de casos edge (n=0, n>m, vazio).",
                                "Clareza e concisão da descrição.",
                                "Validação com exemplos concretos.",
                                "Uso consistente de convenções (0-based indexing)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Notação de conjuntos e funções (Σ^m).",
                                "Linguística: Análise de padrões em textos e linguagens naturais.",
                                "Biologia: Busca de sequências em DNA (T=genoma, P=genoma viral).",
                                "Engenharia de Software: Especificação formal de APIs."
                              ],
                              "realWorldApplication": "Em motores de busca como Google (busca de termos em páginas web), editores de texto (Ctrl+F), análise de DNA para identificar genes, detecção de plágio em documentos e sistemas de segurança cibernética para padrões maliciosos em logs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.4.2",
                            "name": "Discutir variantes do problema",
                            "description": "Explicar variantes como encontrar uma ocorrência qualquer, todas as ocorrências sobrepostas, ou reportar apenas o número de matches.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal do Problema Padrão de Emparelhamento",
                                  "subSteps": [
                                    "Relembre a definição padrão: dado texto T de tamanho n e padrão P de tamanho m, encontrar todas as posições i onde P é substring de T iniciando em i.",
                                    "Identifique a saída padrão: lista de posições de início das ocorrências não-sobrepostas.",
                                    "Anote as premissas: índices 0-based, matches exatos, complexidade O(n+m).",
                                    "Compare com problemas relacionados como busca simples vs. eficiente (KMP).",
                                    "Desenhe um diagrama simples de T e P com uma match destacada."
                                  ],
                                  "verification": "Escreva um resumo de 1 parágrafo da definição padrão e confirme com uma referência (ex: livro de algoritmos).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de algoritmos (ex: CLRS), papel e caneta ou editor de texto.",
                                  "tips": "Use pseudocódigo para ilustrar a saída esperada do problema padrão.",
                                  "learningObjective": "Compreender o problema base para contrastar com variantes.",
                                  "commonMistakes": "Confundir emparelhamento com alinhamento aproximado ou ignorar sobreposições implícitas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Descrever Variantes Comuns",
                                  "subSteps": [
                                    "Liste variantes: (1) Primeira ocorrência qualquer; (2) Todas ocorrências não-sobrepostas; (3) Todas ocorrências sobrepostas; (4) Apenas contagem de matches.",
                                    "Para cada uma, defina a saída: ex: para primeira, retorne o menor i; para contagem, retorne inteiro k.",
                                    "Forneça exemplos concretos: T='aaabaaa', P='aaa' – primeira: i=0; sobrepostas: i=0,1,4; contagem:3.",
                                    "Discuta quando usar cada: primeira para busca rápida, contagem para estatísticas.",
                                    "Crie uma tabela comparativa com colunas: Variante, Saída, Exemplo."
                                  ],
                                  "verification": "Crie uma tabela com 4 variantes e verifique se cobre diferenças de saída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou tabela em Markdown, exemplos de strings prontos.",
                                  "tips": "Sempre inclua casos com sobreposições para destacar diferenças.",
                                  "learningObjective": "Catalogar variantes com descrições precisas e exemplos.",
                                  "commonMistakes": "Omitir sobreposições ou confundir não-sobrepostas com todas as possíveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Diferenças em Complexidade e Implicações Algorítmicas",
                                  "subSteps": [
                                    "Compare complexidades: todas as variantes O(n+m) com algoritmos adequados (KMP para primeira/não-sobrepostas, Z-algorithm para sobrepostas).",
                                    "Discuta adaptações: para contagem, modifique KMP para somar matches sem listar.",
                                    "Avalie trade-offs: listar todas vs. contagem (espaço O(k) vs. O(1)).",
                                    "Considere casos extremos: P vazio (n+1 matches), m>n (zero matches).",
                                    "Escreva pseudocódigo modificado para uma variante (ex: contagem)."
                                  ],
                                  "verification": "Implemente pseudocódigo para contagem e teste com exemplo T='aaabaaa', P='aaa' (esperado:3).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de código ou papel para pseudocódigo, calculadora para casos extremos.",
                                  "tips": "Foquem em como o algoritmo base se adapta sem reescrever do zero.",
                                  "learningObjective": "Entender impactos nas soluções algorítmicas das variantes.",
                                  "commonMistakes": "Assumir mesma complexidade sem considerar saída (ex: listar k grande usa mais espaço)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Discussão com Exemplos e Síntese",
                                  "subSteps": [
                                    "Escolha um problema real: T=sequência DNA, P=enzima motif.",
                                    "Discuta todas variantes nesse contexto e escolha a mais adequada.",
                                    "Sintetize em um parágrafo: 'Variantes permitem flexibilidade dependendo da necessidade de saída'.",
                                    "Crie perguntas de auto-teste: 'Qual variante para relatório de frequência?'",
                                    "Revise e refine sua tabela e pseudocódigos."
                                  ],
                                  "verification": "Escreva um ensaio curto (200 palavras) discutindo variantes e autoavalie cobertura.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplo de dados reais (ex: string longa de texto ou DNA), timer para escrita.",
                                  "tips": "Ligue variantes a cenários práticos para tornar discussão envolvente.",
                                  "learningObjective": "Sintetizar discussão fluida e contextualizada de variantes.",
                                  "commonMistakes": "Focar só em teoria sem ligar a aplicações ou exemplos concretos."
                                }
                              ],
                              "practicalExample": "Texto T = 'mississippi', Padrão P = 'iss'. Variantes: (1) Primeira ocorrência: posição 1; (2) Todas não-sobrepostas: posições 1,4; (3) Todas sobrepostas: posições 1,4 (sem sobreposição aqui); (4) Contagem: 2. Discuta como KMP encontra primeira em O(n+m), e adaptação para contagem soma flags de match.",
                              "finalVerifications": [
                                "Pode listar e definir pelo menos 4 variantes principais com exemplos corretos.",
                                "Explica diferenças de saída e impacto em espaço/tempo para cada variante.",
                                "Fornece pseudocódigo adaptado para pelo menos duas variantes.",
                                "Identifica casos extremos e como tratá-los em cada variante.",
                                "Liga variantes a um exemplo prático real.",
                                "Discute adequadamente quando escolher cada variante."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e exemplos (sem erros factuais).",
                                "Profundidade na análise de complexidade e adaptações algorítmicas.",
                                "Clareza na estrutura da discussão (tabelas, diagramas usados).",
                                "Cobertura completa de variantes comuns (mínimo 4).",
                                "Relevância de exemplos e conexões práticas.",
                                "Identificação correta de erros comuns e trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de linguagens formais e autômatos finitos para modelar matches.",
                                "Biologia: Análise de sequências genéticas (motifs em DNA/RNA).",
                                "Linguística: Processamento de linguagem natural para busca de padrões em textos.",
                                "Engenharia de Software: Otimização de buscas em logs e sistemas de monitoramento."
                              ],
                              "realWorldApplication": "Em ferramentas de busca como grep ou editores de texto (VS Code find), variantes permitem: primeira match para navegação rápida, todas sobrepostas para análise léxica em compiladores, contagem para relatórios de frequência em mineração de dados ou detecção de padrões em genomas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.4.3",
                            "name": "Relacionar com complexidade",
                            "description": "Mencionar a solução ingênua de complexidade O((m-n+1)n) e a importância de algoritmos eficientes O(m + n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Solução Ingênua para Emparelhamento de Padrões",
                                  "subSteps": [
                                    "Defina o problema: dado um texto T de comprimento m e um padrão P de comprimento n, encontre todas as ocorrências de P em T.",
                                    "Descreva a abordagem ingênua: para cada posição i de 0 a m-n em T, compare P[0..n-1] com T[i..i+n-1] caractere por caractere.",
                                    "Implemente um pseudocódigo simples para essa solução.",
                                    "Execute manualmente em um exemplo pequeno: T = 'abcdeabc', P = 'abc' (posições 0 e 5).",
                                    "Registre o número total de comparações realizadas."
                                  ],
                                  "verification": "Pseudocódigo escrito e exemplo executado corretamente, mostrando todas as comparações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplos de strings simples"
                                  ],
                                  "tips": "Comece com strings curtas para visualizar o processo; foque nas sobreposições desnecessárias.",
                                  "learningObjective": "Identificar e implementar a solução brute-force para string matching.",
                                  "commonMistakes": [
                                    "Confundir índices de início (i de 0 a m-n)",
                                    "Ignorar falhas precoces nas comparações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Complexidade da Solução Ingênua",
                                  "subSteps": [
                                    "Conte o número de comparações no pior caso: para cada i (m-n+1 posições), até n comparações.",
                                    "Derive a notação Big O: O((m-n+1) * n), que simplifica para O(m*n) quando m >> n.",
                                    "Calcule exemplos numéricos: m=1000, n=10 → até 990*10 = 9900 comparações.",
                                    "Discuta casos: melhor caso O((m-n+1)*1) se mismatches imediatos; pior caso O(m*n).",
                                    "Compare com casos reais onde m é muito maior que n (ex: busca em livros)."
                                  ],
                                  "verification": "Fórmula O((m-n+1)n) derivada e exemplos calculados com valores corretos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou planilha",
                                    "Gráficos de complexidade (opcional)"
                                  ],
                                  "tips": "Use somatórios para precisão: total comparações ≤ Σ_{i=0}^{m-n} min(n, posição do mismatch).",
                                  "learningObjective": "Calcular e expressar a complexidade temporal da solução ingênua.",
                                  "commonMistakes": [
                                    "Esquecer o +1 em m-n+1",
                                    "Confundir com O(m+n) prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Limitações e Necessidade de Algoritmos Eficientes",
                                  "subSteps": [
                                    "Discuta cenários problemáticos: m=10^6 (genoma), n=100 → 10^8 operações, lento.",
                                    "Explique impactos: tempo de execução, escalabilidade em big data.",
                                    "Introduza complexidade ideal: O(m + n) linear, processando texto uma vez.",
                                    "Mencione algoritmos como KMP (pré-processa P em O(n), busca em O(m)).",
                                    "Compare ganhos: para m=10^6, n=100, ingênuo ~10^8 vs eficiente ~10^6."
                                  ],
                                  "verification": "Exemplos de cenários com tempos estimados e menção a KMP ou similar.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigos introdutórios sobre KMP",
                                    "Cronômetro para simulações"
                                  ],
                                  "tips": "Pense em termos relativos: fator de speedup m/n vezes melhor.",
                                  "learningObjective": "Reconhecer quando a solução ingênua falha e por que eficiência importa.",
                                  "commonMistakes": [
                                    "Subestimar o pior caso",
                                    "Achar O(m*n) 'aceitável' para grandes m"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Relacionar Complexidades no Contexto Geral",
                                  "subSteps": [
                                    "Resuma diferenças: ingênua O((m-n+1)n) vs eficiente O(m+n).",
                                    "Crie uma tabela comparativa: complexidade, casos de uso, implementações.",
                                    "Discuta trade-offs: pré-processamento em KMP vs simplicidade ingênua.",
                                    "Aplique a problemas similares: busca em arquivos, DNA matching.",
                                    "Conclua importância: eficiência fundamental para software escalável."
                                  ],
                                  "verification": "Tabela comparativa completa e conclusão escrita relacionando ao contexto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela em Markdown ou Excel",
                                    "Pseudocódigos de KMP básico"
                                  ],
                                  "tips": "Visualize com gráficos de tempo vs m para fixar a diferença.",
                                  "learningObjective": "Relacionar soluções ingênuas e eficientes com análise de complexidade.",
                                  "commonMistakes": [
                                    "Ignorar pré-processamento em O(n)",
                                    "Não simplificar O((m-n+1)n) para O(mn)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de busca de plágio, texto T (artigo de 10.000 palavras, m=50.000 chars) e padrão P ('teorema de Pitágoras', n=20). Solução ingênua faz ~49.980*20=~1M comparações (lento); KMP faz ~50.020, permitindo buscas instantâneas em milhões de documentos.",
                              "finalVerifications": [
                                "Explicar verbalmente a derivação de O((m-n+1)n).",
                                "Calcular complexidade para m=1e6, n=100 em ambos os casos.",
                                "Identificar pelo menos 2 algoritmos O(m+n) e seu princípio.",
                                "Comparar tempos em um cenário real com números aproximados.",
                                "Discutir impacto em aplicações como busca de texto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da complexidade ingênua (100% correto).",
                                "Clareza na distinção entre pior/melhor casos.",
                                "Profundidade na justificativa da necessidade de O(m+n).",
                                "Uso correto de notação Big O e exemplos numéricos.",
                                "Conexão explícita com escalabilidade e mundo real.",
                                "Completude da tabela comparativa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e funções de crescimento (Big O).",
                                "Estatística: Análise de performance em datasets grandes.",
                                "Física/Química: Busca de padrões em sequências genéticas ou espectros.",
                                "Linguística: Análise de textos e detecção de similaridades."
                              ],
                              "realWorldApplication": "Motores de busca como Google usam variantes de KMP para indexar e buscar na web em tempo linear, lidando com trilhões de páginas; detecção de vírus em sequências de DNA evita brute-force ineficiente em genomas gigantes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Algoritmo Naive",
                    "description": "Método brute-force para comparar o padrão com todas as posições possíveis do texto.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Funcionamento Básico do Algoritmo Naive",
                        "description": "O algoritmo naive é um método brute-force que compara o padrão P de tamanho m com o texto T de tamanho n, iniciando a comparação em cada uma das n - m + 1 posições possíveis do texto, verificando caractere por caractere até encontrar uma correspondência completa ou uma falha.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Descrever o processo de deslizamento do padrão",
                            "description": "Explicar como o algoritmo posiciona o padrão no início do texto (posição i=0) e avança i de 0 até n-m, comparando T[i+j] com P[j] para j de 0 a m-1 em cada posição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes básicos do deslizamento",
                                  "subSteps": [
                                    "Identifique o texto T de comprimento n e o padrão P de comprimento m.",
                                    "Compreenda que n >= m é uma premissa para o deslizamento ser viável.",
                                    "Visualize o padrão P sendo 'colocado' sobre o texto T começando em i=0.",
                                    "Note que o deslizamento avança i de 0 até n-m em incrementos de 1.",
                                    "Desenhe um diagrama simples mostrando T e P sobrepostos na posição inicial."
                                  ],
                                  "verification": "Crie um diagrama manual ou digital mostrando T e P em i=0 e confirme que a sobreposição cobre m caracteres de T.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho como Draw.io",
                                    "Exemplos de strings T e P"
                                  ],
                                  "tips": "Use strings curtas inicialmente para visualização clara.",
                                  "learningObjective": "Compreender a configuração inicial e os limites do deslizamento.",
                                  "commonMistakes": "Confundir n e m ou assumir n < m sem verificação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar comparações na posição atual i",
                                  "subSteps": [
                                    "Para a posição i atual, inicie j=0.",
                                    "Compare T[i+j] com P[j] para j de 0 até m-1.",
                                    "Se todas as comparações forem iguais, um match é encontrado em i.",
                                    "Registre o resultado da comparação caractere por caractere.",
                                    "Pare o loop j se houver mismatch em algum j."
                                  ],
                                  "verification": "Liste as comparações para uma posição i específica e indique se é match ou mismatch.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Strings de exemplo",
                                    "Planilha ou pseudocódigo para anotar comparações"
                                  ],
                                  "tips": "Anote cada T[i+j] vs P[j] em uma tabela para clareza.",
                                  "learningObjective": "Dominar o processo de comparação sequencial em uma posição fixa.",
                                  "commonMistakes": "Pular j ou comparar índices incorretos como T[i] com P[j] sem offset."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar mismatch e avançar o deslizamento",
                                  "subSteps": [
                                    "Ao detectar mismatch em T[i+j] != P[j], pare as comparações atuais.",
                                    "Avance i para i+1 (deslize o padrão uma posição à direita).",
                                    "Repita o processo de comparação na nova posição i.",
                                    "Continue até i > n-m, onde não há mais sobreposição possível.",
                                    "Monitore o número total de posições testadas (n-m+1)."
                                  ],
                                  "verification": "Simule 3 posições consecutivas com mismatch e confirme o avanço correto de i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de texto com mismatches",
                                    "Simulador online de string matching ou papel"
                                  ],
                                  "tips": "Use setas para mostrar o 'deslize' visualmente no diagrama.",
                                  "learningObjective": "Aprender a transição de uma posição para a próxima após falha.",
                                  "commonMistakes": "Avançar i por mais de 1 ou continuar j após mismatch."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar o processo e registrar todos os matches",
                                  "subSteps": [
                                    "Execute o loop completo de i=0 a n-m.",
                                    "Colete todas as posições i onde match completo ocorreu.",
                                    "Calcule o número total de comparações realizadas.",
                                    "Descreva verbalmente ou por escrito o fluxo inteiro do deslizamento.",
                                    "Compare com uma implementação pseudocódigo para validação."
                                  ],
                                  "verification": "Forneça uma descrição completa do processo para um exemplo dado, listando matches encontrados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo do Naive Algorithm",
                                    "Ferramenta de execução como Python REPL"
                                  ],
                                  "tips": "Conte as comparações para entender a ineficiência do naive.",
                                  "learningObjective": "Sintetizar o processo de deslizamento completo.",
                                  "commonMistakes": "Parar prematuramente antes de i = n-m ou ignorar matches múltiplos."
                                }
                              ],
                              "practicalExample": "Texto T = 'ababcabcacbab', n=12; Padrão P = 'abc', m=3. Posições: i=0 ('aba' !=), i=1 ('bab' !=), i=2 ('abc' == match em 2), i=4 ('abc' == match em 4), até i=9. Matches em posições 2 e 4.",
                              "finalVerifications": [
                                "Descreva corretamente o range de i (0 a n-m).",
                                "Explique o loop aninhado j=0 a m-1 para cada i.",
                                "Identifique matches em um exemplo dado.",
                                "Calcule o número de posições testadas (n-m+1).",
                                "Diferencie deslizamento naive de otimizações como KMP.",
                                "Visualize ou desenhe o processo para strings dadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do posicionamento inicial i=0.",
                                "Correta explicação das comparações T[i+j] vs P[j].",
                                "Entendimento do avanço i++ após mismatch.",
                                "Identificação correta de limites (n-m).",
                                "Capacidade de aplicar a um exemplo concreto.",
                                "Clareza na distinção entre match e mismatch."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Loops for e índices em sequências.",
                                "Física: Analogia com varredura de ondas ou busca linear em sinais.",
                                "Linguística: Busca de padrões em textos e análise linguística.",
                                "Estatística: Probabilidade de matches em strings aleatórias."
                              ],
                              "realWorldApplication": "Usado em editores de texto para 'encontrar e substituir', filtros de spam em emails comparando padrões de palavras suspeitas, e pré-processamento em motores de busca como Ctrl+F em documentos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Identificar o número de posições iniciais possíveis",
                            "description": "Calcular e justificar que, para texto de tamanho n e padrão de tamanho m, existem exatamente n - m + 1 posições iniciais para alinhar o padrão no texto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de texto e padrão",
                                  "subSteps": [
                                    "Defina o texto T como uma string de comprimento n.",
                                    "Defina o padrão P como uma string de comprimento m.",
                                    "Explique que n ≥ m é uma premissa comum para alinhamentos válidos."
                                  ],
                                  "verification": "Escreva definições claras de T, n, P e m com um exemplo simples.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use strings curtas para facilitar a visualização inicial.",
                                  "learningObjective": "Identificar e definir precisamente os tamanhos n e m em problemas de emparelhamento de padrões.",
                                  "commonMistakes": "Confundir o comprimento da string com o número de caracteres visíveis (ignorar espaços ou caracteres especiais)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar o alinhamento do padrão no texto",
                                  "subSteps": [
                                    "Desenhe o texto T horizontalmente.",
                                    "Posicione o padrão P sobre T começando na posição inicial 0 (ou 1, dependendo da convenção).",
                                    "Deslize P uma posição à direita, garantindo que P caiba completamente em T.",
                                    "Continue deslizando até que P não caiba mais."
                                  ],
                                  "verification": "Desenhe o texto e marque todas as posições onde P cabe completamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado e caneta",
                                    "Ferramenta online de visualização de strings (opcional)"
                                  ],
                                  "tips": "Use | para separar o início do padrão em cada alinhamento.",
                                  "learningObjective": "Visualizar graficamente quantas vezes o padrão pode ser alinhado completamente no texto.",
                                  "commonMistakes": "Contar posições onde P sai dos limites do texto como válidas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contar manualmente as posições iniciais possíveis",
                                  "subSteps": [
                                    "Liste os índices iniciais possíveis (ex: 0,1,2,...).",
                                    "Conte quantas posições permitem que os m caracteres de P se encaixem nos n de T.",
                                    "Compare a contagem com valores de teste (ex: n=5, m=2 → 4 posições)."
                                  ],
                                  "verification": "Registre a contagem para pelo menos 3 exemplos diferentes e confira visualmente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora simples"
                                  ],
                                  "tips": "Comece com índices baseados em 0 para consistência com programação.",
                                  "learningObjective": "Contar precisamente o número de alinhamentos válidos por inspeção.",
                                  "commonMistakes": "Incluir a posição final onde apenas parte de P cabe (ex: i=n-m)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e justificar a fórmula geral n - m + 1",
                                  "subSteps": [
                                    "Observe que o primeiro alinhamento é i=0.",
                                    "O último é i = n - m.",
                                    "O número de posições é (n - m) - 0 + 1 = n - m + 1.",
                                    "Justifique: cada deslize avança 1 posição, e todos os i de 0 a n-m são válidos."
                                  ],
                                  "verification": "Aplique a fórmula a exemplos anteriores e prove igualdade com a contagem manual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para derivação",
                                    "Exemplos de strings variadas"
                                  ],
                                  "tips": "Pense em termos de 'janelas deslizantes' de tamanho m em uma sequência de n.",
                                  "learningObjective": "Derivar matematicamente e justificar a fórmula exata para qualquer n e m.",
                                  "commonMistakes": "Esquecer o '+1' na contagem de intervalos (confundir com n-m)."
                                }
                              ],
                              "practicalExample": "Texto T = 'ABCDE' (n=5), Padrão P = 'BC' (m=2). Posições iniciais: i=0 ('AB'), i=1 ('BC'), i=2 ('CD'), i=3 ('DE') → 4 posições = 5-2+1=4.",
                              "finalVerifications": [
                                "Calcula corretamente n-m+1 para n=10, m=3 (8 posições).",
                                "Explica o papel do '+1' na fórmula.",
                                "Identifica casos edge: m=1 (n posições), m=n (1 posição), n=m-1 (0 posições).",
                                "Justifica por que todas as posições de 0 a n-m são válidas.",
                                "Aplica a um exemplo com strings longas sem erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (100% correto).",
                                "Clareza na justificativa visual e matemática.",
                                "Capacidade de lidar com casos edge sem hesitação.",
                                "Contagem manual consistente com fórmula em exemplos.",
                                "Explicação verbal fluida e sem ambiguidades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética de intervalos e contagem de elementos em sequências.",
                                "Lógica e Raciocínio: Identificação de padrões em sequências discretas.",
                                "Programação: Fundamento para loops em algoritmos de busca (for i in 0 to n-m).",
                                "Estatística: Conceito de janelas deslizantes em análise de séries temporais."
                              ],
                              "realWorldApplication": "Em motores de busca de texto (como Ctrl+F em editores), detecção de substrings em DNA sequencing, filtros anti-spam em e-mails, e algoritmos de compressão de dados que escaneiam padrões repetidos."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Reconhecer o tratamento de mismatches",
                            "description": "Descrever o que acontece quando um caractere não coincide (mismatch): o algoritmo para a comparação atual, avança para a próxima posição i e reinicia a verificação do padrão do início.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o conceito de mismatch no Algoritmo Naive",
                                  "subSteps": [
                                    "Estude a definição: um mismatch ocorre quando o caractere text[i + j] não é igual a pattern[j], durante a comparação interna do loop j.",
                                    "Identifique a ação imediata: o loop interno de j é interrompido (break ou return ao loop externo), sem avançar j.",
                                    "Compreenda o reset: j é reiniciado para 0, preparando para uma nova tentativa de match a partir do início do padrão.",
                                    "Note o avanço: o índice i do texto é incrementado em 1 (i++), movendo a janela de comparação uma posição à frente.",
                                    "Revise o pseudocódigo relevante: for j=0 to m-1; if text[i+j] != pattern[j] { j=0; i++; break; }"
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e aponte a linha exata no pseudocódigo onde o mismatch é tratado.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Pseudocódigo do Algoritmo Naive",
                                    "Diagrama de fluxo do algoritmo"
                                  ],
                                  "tips": [
                                    "Visualize a 'janela' de comparação deslizando: mismatch 'joga fora' a tentativa atual e desliza apenas i."
                                  ],
                                  "learningObjective": "Compreender precisamente o que é um mismatch e as ações exatas (reset j=0, i++) desencadeadas.",
                                  "commonMistakes": [
                                    "Confundir mismatch com falha total (não reinicia j)",
                                    "Achar que i avança mais que 1 posição",
                                    "Ignorar que j volta a 0 sempre"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular um mismatch em um exemplo simples passo a passo",
                                  "subSteps": [
                                    "Escolha texto='ABCDA', padrão='AB': pos i=1, j=0: B==A? Não → mismatch, i=2, j=0.",
                                    "Anote estados: Antes mismatch (i=1,j=0: text[1]='B' != pattern[0]='A'), Após: i=2, j=0.",
                                    "Desenhe tabela: colunas i, j, text[i+j], pattern[j], match/mismatch.",
                                    "Execute manualmente: avance i até len(text)-len(pattern)+1.",
                                    "Confirme: algoritmo continua sem pular posições desnecessariamente."
                                  ],
                                  "verification": "Preencha uma tabela de simulação mostrando o mismatch e o reset correto de j.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela",
                                    "Ferramenta online de simulação de strings (ex: Python REPL)"
                                  ],
                                  "tips": [
                                    "Use strings curtas primeiro (len(text)=5-10) para evitar confusão; trace todos os estados."
                                  ],
                                  "learningObjective": "Aplicar o conceito de mismatch em uma execução manual controlada.",
                                  "commonMistakes": [
                                    "Avançar i para i+j em vez de i+1",
                                    "Não resetar j=0 após mismatch",
                                    "Parar simulação após primeiro mismatch"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar tratamento de mismatch com cenários de match",
                                  "subSteps": [
                                    "Simule texto='ABAB', padrão='AB': i=0 match completo (j=0-1), encontrado; i=2 match novamente.",
                                    "Introduza mismatch: texto='ABCB', i=0 match j=0 A=A, j=1 B=B; i=1? B!=A mismatch → i=2, C!=A, i=3 B!=A fim.",
                                    "Destaque diferença: match avança i += len(pattern) após sucesso; mismatch sempre i +=1 e j=0.",
                                    "Registre múltiplos mismatches seguidos para ver ineficiência.",
                                    "Questione: 'Por que naive? Porque reinicia j sempre, sem otimizações.'"
                                  ],
                                  "verification": "Descreva diferenças em um parágrafo comparativo e simule ambos cenários.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Exemplos impressos ou digitais de strings variadas",
                                    "Vídeo curto de animação do Naive (YouTube)"
                                  ],
                                  "tips": [
                                    "Cores diferentes para match (verde) vs mismatch (vermelho) na tabela acelera compreensão."
                                  ],
                                  "learningObjective": "Diferenciar comportamentos de match vs mismatch para reforçar o tratamento específico.",
                                  "commonMistakes": [
                                    "Confundir avanço pós-match (i += m) com mismatch (i +=1)",
                                    "Achar que match parcial salva progresso em j"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar mismatches em código e cenários reais",
                                  "subSteps": [
                                    "Implemente pseudocódigo em Python simples e rode com print em mismatch.",
                                    "Exemplo: def naive(text, pat): for i in range(len(text)-len(pat)+1): j=0; while j<len(pat) and text[i+j]==pat[j]: j+=1; if j==len(pat): return i; else: i+=1 # mismatch implícito.",
                                    "Adicione logs: print('Mismatch at i=',i,' j=',j) antes de i+=1.",
                                    "Teste casos: overlapping patterns, all mismatches, multiple.",
                                    "Analise saída: confirme reset j e avanço i=1 sempre."
                                  ],
                                  "verification": "Execute código com 3 casos diferentes e capture prints de mismatches.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Replit)",
                                    "Strings de teste pré-definidas"
                                  ],
                                  "tips": [
                                    "Use assert para verificar: após mismatch, próximo i deve ser atual+1 e j=0."
                                  ],
                                  "learningObjective": "Reconhecer e depurar o tratamento de mismatches em implementações práticas.",
                                  "commonMistakes": [
                                    "Implementar KMP-like otimização por engano",
                                    "Não logar estados corretamente",
                                    "Ignorar boundary cases (i perto do fim)"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto: 'ACAB', Padrão: 'AB'. i=0: A==A (j=1), C!=B (mismatch) → i=1, j=0. i=1: C!=A → i=2, j=0. i=2: A==A (j=1), B==B → encontrado em i=2. Note: dois mismatches consecutivos, cada um avança i+1 e reseta j.",
                              "finalVerifications": [
                                "Explique em 1 frase o que acontece num mismatch.",
                                "Simule corretamente um exemplo com pelo menos 1 mismatch.",
                                "Identifique reset de j=0 e i+=1 em pseudocódigo.",
                                "Diferencie de match completo.",
                                "Trace 3 mismatches seguidos sem erros.",
                                "Explique por que isso torna o algoritmo 'naive'."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do reset j=0 e i+=1 (obrigatório).",
                                "Correta simulação manual com tabela ou logs.",
                                "Compreensão de ineficiência em casos de mismatches frequentes.",
                                "Uso correto de terminologia (mismatch, janela deslizante).",
                                "Identificação em código/pseudocódigo.",
                                "Ausência de confusão com algoritmos otimizados como KMP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de sequências e falhas em alinhamentos.",
                                "Linguística: Reconhecimento de padrões em processamento de texto natural.",
                                "Biologia: Busca de sub-sequências em genomas (DNA matching).",
                                "Engenharia de Software: Depuração de loops aninhados em buscas lineares."
                              ],
                              "realWorldApplication": "Em editores de texto (Ctrl+F para 'find'), scanners de antivírus detectando assinaturas de malware em arquivos, e ferramentas de bioinformática procurando padrões genéticos em sequências de DNA, onde mismatches frequentes destacam a necessidade de otimizações como Boyer-Moore."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.1.2",
                        "name": "Pseudocódigo e Implementação",
                        "description": "Representação formal do algoritmo em pseudocódigo e diretrizes para codificação em linguagens de programação, enfatizando laços aninhados para comparações.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.2.1",
                            "name": "Escrever o pseudocódigo completo do algoritmo naive",
                            "description": "Produzir o pseudocódigo padrão: para i de 0 a n-m: para j de 0 a m-1: se T[i+j] != P[j] break; se j==m retornar i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função e inicializar variáveis",
                                  "subSteps": [
                                    "Escreva a assinatura da função como 'naiveMatch(T, P)' onde T é o texto e P é o padrão.",
                                    "Defina n como o comprimento de T (n = length(T)).",
                                    "Defina m como o comprimento de P (m = length(P)).",
                                    "Adicione verificação básica: se m > n, retorne -1 (não encontrado).",
                                    "Prepare para retornar a posição inicial do match ou -1."
                                  ],
                                  "verification": "Verifique se as variáveis n e m estão definidas corretamente e a assinatura da função está clara.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use notação consistente como 'length(T)' para evitar ambiguidades.",
                                  "learningObjective": "Compreender os parâmetros de entrada e inicializações necessárias para o algoritmo naive.",
                                  "commonMistakes": [
                                    "Confundir T (texto) com P (padrão)",
                                    "Esquecer de tratar caso m > n",
                                    "Usar índices 1-based em vez de 0-based"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o loop externo para deslizamento do padrão",
                                  "subSteps": [
                                    "Inicie o loop externo: para i de 0 até n - m (inclusivo).",
                                    "Explique que i representa a posição inicial possível do padrão em T.",
                                    "Garanta que o loop pare antes de n - m + 1 para evitar overflow.",
                                    "Anote que para cada i, tentaremos alinhar P começando em T[i].",
                                    "Teste mentalmente com um exemplo pequeno: n=5, m=2, i vai de 0 a 3."
                                  ],
                                  "verification": "Simule o loop externo com valores pequenos e confirme que i varia de 0 a n-m.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para simulação",
                                    "Exemplo de strings curtas"
                                  ],
                                  "tips": "Lembre-se: n-m garante que o padrão caiba completamente no texto.",
                                  "learningObjective": "Dominar o conceito de 'deslizamento' do padrão sobre o texto.",
                                  "commonMistakes": [
                                    "Loop até n em vez de n-m",
                                    "Incluir i = n-m+1 causando acesso inválido",
                                    "Usar i < n-m em vez de i <= n-m"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop interno para comparação de caracteres",
                                  "subSteps": [
                                    "Dentro do loop externo, inicie loop interno: para j de 0 até m-1.",
                                    "Em cada iteração, compare T[i + j] com P[j].",
                                    "Se T[i + j] != P[j], execute 'break' para pular para próximo i.",
                                    "Se todas comparações passarem (j chega a m), é um match.",
                                    "Simule uma posição i com mismatch no meio."
                                  ],
                                  "verification": "Trace o loop interno para uma posição i específica e veja se break ocorre corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Strings de exemplo escritas",
                                    "Lápis para tracing"
                                  ],
                                  "tips": "Use i + j para acessar a posição alinhada no texto.",
                                  "learningObjective": "Entender a comparação caractere por caractere e detecção de mismatch.",
                                  "commonMistakes": [
                                    "Comparar T[i] com P[j] em vez de T[i+j]",
                                    "Loop j até m em vez de m-1",
                                    "Faltar o break no mismatch"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar verificação de match e retorno",
                                  "subSteps": [
                                    "Após o loop interno, verifique se j == m (todos caracteres combinaram).",
                                    "Se sim, retorne i (posição do match).",
                                    "Após todos os loops externos, retorne -1 (padrão não encontrado).",
                                    "Escreva o pseudocódigo completo unindo todas as partes.",
                                    "Revise a indentação para clareza."
                                  ],
                                  "verification": "Execute pseudocódigo mentalmente em um exemplo completo e confirme retornos corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo parcial",
                                    "Exemplo pronto para teste"
                                  ],
                                  "tips": "A verificação j==m deve vir logo após o loop interno.",
                                  "learningObjective": "Finalizar o algoritmo com lógica de sucesso e falha.",
                                  "commonMistakes": [
                                    "Retornar dentro do loop interno sem break",
                                    "Esquecer retorno -1 no final",
                                    "Indentação errada confundindo escopo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e refinar o pseudocódigo",
                                  "subSteps": [
                                    "Escolha um exemplo: T='ABABCD', P='ABC'.",
                                    "Simule passo a passo: trace i=0,1,... e j para cada.",
                                    "Verifique mismatches e match (deve retornar -1).",
                                    "Outro exemplo: T='ABCABC', P='BC' (retorna 1).",
                                    "Corrija qualquer erro encontrado e finalize."
                                  ],
                                  "verification": "Pseudocódigo produz saída correta em pelo menos 3 exemplos variados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vários pares T/P",
                                    "Tabela para tracing"
                                  ],
                                  "tips": "Use tracing em papel para visualizar alinhamentos.",
                                  "learningObjective": "Validar a correção do pseudocódigo através de simulações.",
                                  "commonMistakes": [
                                    "Não testar casos de não-match",
                                    "Ignorar bordas como i=0 ou i=n-m",
                                    "Erros de off-by-one em simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto T = 'ABABDABACDABABCABAB', Padrão P = 'ABABCABAB'. Simule o pseudocódigo: loop i de 0 a 18-9=9. Em i=10, j vai até 8 comparando T[10:19] == P[0:9], match retorna 10.",
                              "finalVerifications": [
                                "Pseudocódigo inicia com função naiveMatch(T, P) e define n=length(T), m=length(P).",
                                "Loop externo: for i = 0 to n-m.",
                                "Loop interno: for j = 0 to m-1, compara T[i+j] == P[j], break se !=.",
                                "Após loop interno: if j == m return i.",
                                "Após loops: return -1.",
                                "Notação clara, sem erros de sintaxe em pseudocódigo."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: loops e condições refletem algoritmo naive exatamente.",
                                "Precisão nos índices: i de 0 a n-m, j de 0 a m-1, T[i+j].",
                                "Tratamento completo: mismatch com break, match com return i, no match -1.",
                                "Clareza e legibilidade: indentação adequada e comentários opcionais.",
                                "Robustez: considera casos edge como m=0, m>n, n=m.",
                                "Simulação manual: funciona em exemplos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: aritmética de índices e limites de loops (off-by-one errors).",
                                "Lógica e Estruturas de Controle: aninhamento de loops e condicionais.",
                                "Análise de Algoritmos: introdução a complexidade O((n-m+1)*m).",
                                "Programação Geral: transição de pseudocódigo para código real (ex: Python)."
                              ],
                              "realWorldApplication": "Base para funções de busca em editores de texto (Ctrl+F), ferramentas como grep/unix find, detecção de plágio em documentos e pré-processamento em busca full-text como Google."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.1.2.2",
                            "name": "Implementar o algoritmo em pseudocódigo executável",
                            "description": "Converter o pseudocódigo em uma linguagem como Python, incluindo funções para encontrar todas as ocorrências ou a primeira ocorrência do padrão no texto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar pseudocódigo e preparar ambiente Python",
                                  "subSteps": [
                                    "Analise o pseudocódigo do algoritmo Naive: para cada posição i no texto, compare o padrão caractere por caractere.",
                                    "Instale um editor de código como VS Code ou Jupyter Notebook.",
                                    "Crie um novo arquivo Python chamado naive_matcher.py.",
                                    "Defina funções básicas: uma para primeira ocorrência e outra para todas.",
                                    "Importe módulos necessários, como sys para entrada/saída se aplicável."
                                  ],
                                  "verification": "Pseudocódigo mapeado em comentários no código Python e ambiente pronto com arquivo criado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code, PyCharm), Python 3.x instalado",
                                  "tips": "Use comentários para traduzir cada linha do pseudocódigo diretamente.",
                                  "learningObjective": "Entender e mapear lógica pseudocódigo para sintaxe Python.",
                                  "commonMistakes": "Ignorar índices base 0 em Python vs. 1 em pseudocódigo; não usar strings imutáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar função para primeira ocorrência",
                                  "subSteps": [
                                    "Defina def find_first_occurrence(text, pattern): com parâmetros strings.",
                                    "Obtenha comprimentos: n = len(text), m = len(pattern).",
                                    "Loop for i in range(n - m + 1):",
                                    "  Verifique match: for j in range(m): if text[i+j] != pattern[j]: break else: return i.",
                                    "Retorne -1 se não encontrado."
                                  ],
                                  "verification": "Função retorna índice correto ou -1 para texto='abcabc', pattern='abc' -> 0; pattern='d' -> -1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Arquivo Python do step 1, documentação Python strings",
                                  "tips": "Use enumerate ou range simples; teste com print intermediário.",
                                  "learningObjective": "Traduzir loop aninhado do pseudocódigo para Python com controle de fluxo.",
                                  "commonMistakes": "Off-by-one em range(n - m + 1); esquecer return -1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar função para todas as ocorrências",
                                  "subSteps": [
                                    "Defina def find_all_occurrences(text, pattern): retornando lista de índices.",
                                    "Inicialize lista occurrences = [].",
                                    "Loop for i in range(n - m + 1):",
                                    "  Verifique match similar ao step 2, se match append i à lista.",
                                    "Retorne a lista."
                                  ],
                                  "verification": "Para texto='abcabcabc', pattern='abc' retorna [0,3,6]; pattern='abca' retorna [].",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Arquivo Python atualizado, exemplos de teste",
                                  "tips": "Reutilize lógica de match em função helper para evitar duplicação.",
                                  "learningObjective": "Estender implementação para múltiplas matches coletando em lista.",
                                  "commonMistakes": "Não resetar j em verificação interna; incluir overlaps incorretos (Naive permite overlaps)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e documentar o código",
                                  "subSteps": [
                                    "Crie função de teste com asserts: assert find_first_occurrence('abcabc', 'bc') == 1.",
                                    "Teste casos edge: pattern vazio, texto vazio, pattern maior que texto.",
                                    "Execute com inputs variados e verifique saídas.",
                                    "Adicione docstrings e comentários.",
                                    "Meça tempo de execução com timeit para texto grande."
                                  ],
                                  "verification": "Todos testes passam sem erros; código documentado com pelo menos 80% cobertura de casos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python unittest ou pytest opcional, timeit module",
                                  "tips": "Use input() para testes interativos; profile com cProfile se lento.",
                                  "learningObjective": "Garantir robustez e corretude através de testes sistemáticos.",
                                  "commonMistakes": "Esquecer casos edge como m=0 ou n<m; não tratar strings vazias."
                                }
                              ],
                              "practicalExample": "Texto: 'mississippi', Padrão: 'iss' -> Primeira: 1, Todas: [1,4]. Implemente funções que outputem isso corretamente, testando em Jupyter com print(posições).",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou runtime em Python 3.",
                                "find_first_occurrence retorna índice correto ou -1.",
                                "find_all_occurrences retorna lista completa de posições sem duplicatas ou misses.",
                                "Funciona com casos edge: strings vazias, pattern == text, overlaps.",
                                "Tempo de execução O((n-m+1)*m) demonstrado em texto grande (n=10^5).",
                                "Código limpo com docstrings e comentários."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Matches exatos em todos testes (90% peso).",
                                "Eficiência: Implementa Naive sem otimizações extras (20% peso).",
                                "Legibilidade: Código indentado, nomes claros, comentários (20% peso).",
                                "Robustez: Trata edges sem crashes (20% peso).",
                                "Documentação: Docstrings e uso completo (15% peso).",
                                "Testes: Pelo menos 5 casos cobertos (15% peso)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de complexidade O(n*m) com somatórios e limites.",
                                "Linguagens: Parsing textual similar a processamento NLP básico.",
                                "Física/Engenharia: Detecção de padrões em sinais/dados experimentais.",
                                "Estatística: Busca de sequências em dados genômicos ou séries temporais."
                              ],
                              "realWorldApplication": "Implementado em ferramentas de busca como grep (versão naive), editores de texto (find/replace), biologia computacional para matching de DNA subsequências, e filtros anti-spam para padrões em emails."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.1.2.3",
                            "name": "Testar a implementação com casos simples",
                            "description": "Executar o algoritmo em exemplos como T='abcabc', P='abc' (encontra posições 0 e 3) e T='aaaaa', P='aa' (encontra múltiplas sobreposições).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar casos de teste e ambiente de execução",
                                  "subSteps": [
                                    "Identificar e documentar o primeiro caso: T='abcabc', P='abc', output esperado: posições [0,3]",
                                    "Identificar e documentar o segundo caso: T='aaaaa', P='aa', output esperado: posições [0,1,2,3] considerando sobreposições",
                                    "Configurar a implementação do algoritmo Naive em código (ex: Python ou pseudocódigo)",
                                    "Criar uma estrutura para registrar resultados reais vs esperados",
                                    "Executar uma simulação manual rápida para confirmar expectativas"
                                  ],
                                  "verification": "Casos de teste documentados em um arquivo ou comentário de código com inputs/outputs esperados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code, Jupyter), linguagem de programação (Python recomendada)",
                                  "tips": "Sempre anote outputs esperados manualmente antes de codificar para evitar viés.",
                                  "learningObjective": "Dominar a preparação de testes unitários para validação algorítmica.",
                                  "commonMistakes": "Ignorar sobreposições no caso 'aaaaa' e 'aa', prevendo apenas [0,2,4] em vez de todas as posições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar teste no primeiro caso: T='abcabc', P='abc'",
                                  "subSteps": [
                                    "Chamar a função naive_match('abcabc', 'abc')",
                                    "Registrar as posições retornadas pelo algoritmo",
                                    "Comparar com esperado [0,3]",
                                    "Simular o alinhamento manual: posição 0 (abc|abc), deslize para 3 (abc|abc)",
                                    "Anotar qualquer discrepância em log"
                                  ],
                                  "verification": "Função retorna exatamente [0,3] sem erros ou crashes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Código fonte do algoritmo Naive, terminal ou notebook para execução",
                                  "tips": "Use print statements para visualizar comparações caractere por caractere durante execução.",
                                  "learningObjective": "Aplicar o algoritmo em strings sem sobreposições para validar matching básico.",
                                  "commonMistakes": "Índices off-by-one, como reportar 1 e 4 em vez de 0 e 3."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar teste no segundo caso: T='aaaaa', P='aa'",
                                  "subSteps": [
                                    "Chamar a função naive_match('aaaaa', 'aa')",
                                    "Registrar posições: deve capturar todas sobreposições [0,1,2,3]",
                                    "Comparar com esperado, verificando janela deslizante sobreposta",
                                    "Simular manualmente: aa|aaaa, a|aaaa (match em 1), etc.",
                                    "Anotar tempo de execução para notar ineficiência (O(n*m))"
                                  ],
                                  "verification": "Função retorna [0,1,2,3] corretamente, demonstrando detecção de sobreposições.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Mesmo código e ambiente do step anterior",
                                  "tips": "Pause a execução com debugger para inspecionar loops em sobreposições.",
                                  "learningObjective": "Entender e validar comportamento em casos de sobreposição máxima.",
                                  "commonMistakes": "Pular posições sobrepostas, retornando apenas [0,2] por lógica errada de avanço."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados, debugar e verificar robustez",
                                  "subSteps": [
                                    "Comparar todos resultados reais vs esperados em tabela",
                                    "Identificar e corrigir bugs (ex: loop while mal condicionado)",
                                    "Executar novamente após correções",
                                    "Testar variação simples: T='ab', P='abc' (no match)",
                                    "Documentar lições aprendidas e cobertura de testes"
                                  ],
                                  "verification": "100% match entre esperados e reais; sem crashes em casos simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Debugger integrado (pdb em Python), planilha para tabela de resultados",
                                  "tips": "Use asserts em código para automação: assert result == expected.",
                                  "learningObjective": "Desenvolver habilidades de debugging e análise de resultados algorítmicos.",
                                  "commonMistakes": "Não testar no-match, assumindo apenas casos positivos."
                                }
                              ],
                              "practicalExample": "Em Python: def naive_match(T, P): positions = []; for i in range(len(T)-len(P)+1): match=True; for j in range(len(P)): if T[i+j]!=P[j]: match=False; break; if match: positions.append(i); return positions. Teste: print(naive_match('abcabc','abc')) -> [0,3]; print(naive_match('aaaaa','aa')) -> [0,1,2,3].",
                              "finalVerifications": [
                                "Algoritmo retorna [0,3] para T='abcabc', P='abc'",
                                "Algoritmo retorna [0,1,2,3] para T='aaaaa', P='aa'",
                                "Nenhuma posição extra ou faltante em ambos casos",
                                "Execução sem erros ou timeouts em strings curtas",
                                "Logs mostram alinhamentos corretos passo a passo"
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% das posições corretas identificadas",
                                "Cobertura: Sobreposições e matches exatos validados",
                                "Eficiência observada: Comportamento O(n*m) sem otimizações extras",
                                "Robustez: Funciona com len(T) >= len(P) e casos no-match",
                                "Documentação: Testes e resultados bem registrados"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de sequências e teoria de strings finitas",
                                "Engenharia de Software: Práticas de TDD (Test-Driven Development)",
                                "Lógica e Verificação: Provas por casos em computação formal",
                                "Biologia Computacional: Matching de padrões em sequências de DNA"
                              ],
                              "realWorldApplication": "Busca de padrões em textos (ex: Ctrl+F em editores), detecção de sequências genéticas repetidas em genomas, filtros anti-spam por padrões em emails, análise de logs de sistemas para eventos recorrentes."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.1.3",
                        "name": "Análise de Complexidade Computacional",
                        "description": "Avaliação da complexidade temporal do algoritmo naive nos casos pior, médio e melhor, destacando O(n m) no pior caso.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.3.1",
                            "name": "Derivar a complexidade no pior caso",
                            "description": "Explicar que no pior caso (ex: T='aaaaa...a', P='aaa...ab'), realiza (n-m+1)*m comparações, resultando em Θ(n m) tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o funcionamento do algoritmo Naive de emparelhamento de padrões",
                                  "subSteps": [
                                    "Identifique os loops principais: loop externo sobre posições i de 0 a n-m em T.",
                                    "Descreva o loop interno: para cada i, compara j de 0 a m-1 entre T[i+j] e P[j].",
                                    "Explique quando o loop interno para: mismatch ou match completo.",
                                    "Anote que cada comparação é uma operação unitária.",
                                    "Desenhe um diagrama simples do fluxo do algoritmo."
                                  ],
                                  "verification": "Escreva pseudocódigo do algoritmo e conte manualmente as comparações em um exemplo pequeno (T='abcde', P='ab').",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Foque apenas nas comparações de caracteres; ignore avanços de ponteiro.",
                                  "learningObjective": "Compreender precisamente quantas comparações ocorrem em execuções típicas.",
                                  "commonMistakes": [
                                    "Confundir shifts com comparações",
                                    "Ignorar que o loop interno reinicia em cada i"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e exemplificar o caso pior",
                                  "subSteps": [
                                    "Defina pior caso: máxima número de comparações, quando mismatches ocorrem tarde.",
                                    "Escolha exemplo: T = 'aaaaa...a' (todas 'a', n chars), P = 'aaa...ab' (m-1 'a' + 'b').",
                                    "Simule primeira posição i=0: compara m-1 'a' iguais, mismatch no último.",
                                    "Note que para cada i, compara m-1 chars antes de falhar.",
                                    "Verifique que isso se repete para todos os n-m+1 inícios."
                                  ],
                                  "verification": "Simule o exemplo com n=5, m=3 (T='aaaaa', P='aab') e liste todas as comparações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para simulação",
                                    "Strings curtas para teste"
                                  ],
                                  "tips": "Use strings repetitivas para visualizar o 'deslize lento'.",
                                  "learningObjective": "Reconhecer padrões que maximizam comparações no Naive.",
                                  "commonMistakes": [
                                    "Achar que mismatch imediato é pior caso",
                                    "Usar P sem mismatch final"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contar o número total de comparações no pior caso",
                                  "subSteps": [
                                    "Para cada posição i (há n-m+1 posições), conte m-1 comparações bem-sucedidas + 1 mismatch = m comparações.",
                                    "Corrija: na verdade, m comparações por posição, pois compara até o mismatch no m-ésimo.",
                                    "Some: (n-m+1) posições × m comparações cada = (n-m+1)m.",
                                    "Simplifique para Θ(n m) quando n >> m.",
                                    "Confirme com exemplo numérico: n=5, m=3 → 3 posições × 3 = 9 comparações."
                                  ],
                                  "verification": "Calcule para n=10, m=4 e simule para validar o total.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha para contagem"
                                  ],
                                  "tips": "Lembre: cada falha no final conta todas m comparações.",
                                  "learningObjective": "Derivar fórmula exata de comparações: Θ((n-m+1)m).",
                                  "commonMistakes": [
                                    "Contar só m-1 por posição",
                                    "Esquecer o +1 no número de posições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expressar a complexidade assintótica e concluir",
                                  "subSteps": [
                                    "Analise assintótica: (n-m+1)m ≈ n m quando m fixo ou n grande.",
                                    "Use notação Θ: tempo é Θ(n m) no pior caso.",
                                    "Compare com melhor caso O(m) ou médio O(n).",
                                    "Discuta implicações: ineficiente para n,m grandes.",
                                    "Registre a derivação completa em uma fórmula anotada."
                                  ],
                                  "verification": "Escreva prova formal: 'No pior caso, ∑_{i=0}^{n-m} m = m(n-m+1) = Θ(n m)'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha para prova",
                                    "Referência de notação assintótica"
                                  ],
                                  "tips": "Foquem em limites inferiores e superiores para Θ.",
                                  "learningObjective": "Formalizar a complexidade como Θ(n m).",
                                  "commonMistakes": [
                                    "Dizer O(n m) sem Θ",
                                    "Confundir pior com médio caso"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere T = 'aaaaaaaaaa' (n=10), P = 'aaaaab' (m=6). Para cada i de 0 a 4 (5 posições), o algoritmo compara 6 caracteres (5 'a' iguais + mismatch 'b'), total 5×6=30 comparações, confirmando (10-6+1)×6=30 ≈ Θ(10×6).",
                              "finalVerifications": [
                                "Explicar verbalmente por que o pior caso ocorre com padrões quase idênticos.",
                                "Calcular corretamente comparações para novo exemplo (n=7, m=3).",
                                "Derivar fórmula (n-m+1)m sem hesitação.",
                                "Identificar que Θ(n m) é quadrático em n para m~n.",
                                "Simular em código simples e contar operações.",
                                "Diferenciar de complexidade no melhor caso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de comparações por posição (m exatas).",
                                "Correta identificação do pior caso com exemplo válido.",
                                "Derivação assintótica rigorosa para Θ(n m).",
                                "Uso correto de notação Big Theta com justificativa.",
                                "Capacidade de generalizar para tamanhos arbitrários.",
                                "Ausência de erros aritméticos na soma total."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries aritméticas e somas ( (n-m+1)m ).",
                                "Probabilidade: Contraste com análise de caso médio/expected.",
                                "Engenharia de Software: Impacto em performance de buscas de texto.",
                                "Matemática Discreta: Contagem de operações em loops aninhados."
                              ],
                              "realWorldApplication": "Em editores de texto como VS Code ou grep, entender isso motiva uso de algoritmos eficientes como KMP (O(n+m)) para buscas em arquivos grandes, evitando lentidão quadrática em textos repetitivos como logs ou DNA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.1.3.2",
                            "name": "Analisar o melhor caso",
                            "description": "Descrever o melhor caso (mismatch imediato em todas posições): Θ(n) comparações, pois apenas o primeiro caractere é checado em cada posição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Funcionamento do Algoritmo Naive",
                                  "subSteps": [
                                    "Estude o pseudocódigo do algoritmo Naive para emparelhamento de padrões.",
                                    "Identifique o loop principal que itera sobre as posições i de 0 até n-m.",
                                    "Entenda que, para cada i, o algoritmo compara caracteres T[i+j] com P[j] até um mismatch ou match completo.",
                                    "Registre mentalmente onde cada comparação de caractere ocorre.",
                                    "Diferencie o foco em comparações de caracteres do resultado de matching."
                                  ],
                                  "verification": "Escreva o pseudocódigo do algoritmo Naive de memória, destacando as comparações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo do algoritmo Naive",
                                    "Exemplos simples de texto T e padrão P"
                                  ],
                                  "tips": "Concentre-se exclusivamente no contador de comparações de caracteres, ignorando temporais por enquanto.",
                                  "learningObjective": "Compreender o fluxo exato do algoritmo e localizar todas as operações de comparação.",
                                  "commonMistakes": [
                                    "Confundir o algoritmo Naive com variantes otimizadas como KMP.",
                                    "Ignorar o limite n-m no loop principal.",
                                    "Focar apenas no match final em vez das comparações intermediárias."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as Condições do Melhor Caso",
                                  "subSteps": [
                                    "Defina o melhor caso como o input que minimiza o número total de comparações.",
                                    "Observe que mismatches precoces reduzem comparações por posição i.",
                                    "Especifique o cenário extremo: mismatch imediato no primeiro caractere (j=0) para todas as posições i.",
                                    "Escolha exemplos onde P[0] não aparece em nenhuma T[i] para i=0 até n-m.",
                                    "Confirme que nenhum alinhamento prossegue além da primeira comparação."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o que constitui um 'mismatch imediato em todas posições'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de strings: T='AAAAAAAAAA', P='BXX'",
                                    "Papel para anotar condições"
                                  ],
                                  "tips": "Teste com P[0] sendo um caractere ausente em T para garantir mismatch universal.",
                                  "learningObjective": "Reconhecer precisamente o input que leva ao número mínimo de comparações.",
                                  "commonMistakes": [
                                    "Confundir melhor caso com match completo (que pode exigir mais comparações).",
                                    "Esquecer que o loop roda até n-m, não n.",
                                    "Assumir que m=1 é o único caso."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contar o Número Exato de Comparações",
                                  "subSteps": [
                                    "Para cada posição i (de 0 a n-m), execute exatamente uma comparação: T[i] vs P[0].",
                                    "Conte o número de iterações do loop externo: n - m + 1.",
                                    "Some as comparações: exatamente 1 por i, totalizando n - m + 1.",
                                    "Simule com um exemplo pequeno para validar a contagem.",
                                    "Registre a fórmula geral independentemente de n e m específicos."
                                  ],
                                  "verification": "Para n=10, m=3, calcule e justifique o número total de comparações (deve ser 8).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhar alinhamentos de strings",
                                    "Exemplos numéricos variados"
                                  ],
                                  "tips": "Desenhe visualmente os alinhamentos P sobre T para cada i e marque as comparações feitas.",
                                  "learningObjective": "Quantificar com precisão o número de operações no cenário de melhor caso.",
                                  "commonMistakes": [
                                    "Contar m comparações por posição em vez de 1.",
                                    "Usar n em vez de n-m+1 para o total.",
                                    "Incluir comparações após mismatch."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expressar a Complexidade Assintótica",
                                  "subSteps": [
                                    "Analise n - m + 1 assintoticamente: quando m é fixo ou o(n), resulta em Θ(n).",
                                    "Justifique o bound tight: Ω(n) (pelo menos n-m+1) e O(n) (no máximo).",
                                    "Escreva a notação formal: número de comparações é Θ(n).",
                                    "Compare brevemente com outros casos para contextualizar.",
                                    "Conclua que o melhor caso é linear no tamanho do texto."
                                  ],
                                  "verification": "Escreva e explique a notação Θ(n) aplicada ao melhor caso do Naive.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de notações assintóticas (O, Ω, Θ)",
                                    "Gráfico simples de crescimento"
                                  ],
                                  "tips": "Lembre-se: Θ(n) requer constantes c1, c2 >0 tais que c1 n ≤ comp ≤ c2 n para n grande.",
                                  "learningObjective": "Aplicar corretamente a análise assintótica ao melhor caso.",
                                  "commonMistakes": [
                                    "Classificar erroneamente como O(1) ou Θ(m).",
                                    "Confundir com o pior caso Θ(nm).",
                                    "Ignorar o papel de m na análise."
                                  ]
                                }
                              ],
                              "practicalExample": "Texto T = 'AAAAAAAAAA' (n=10, todos 'A'), Padrão P = 'BDEF' (m=4, inicia com 'B'). Para i=0 a 6 (7 posições), cada alinhamento faz apenas T[i]=='B'? (Não, 'A'!='B'), total 7 comparações. Como 7 = 10-4+1, é Θ(n). Simule no papel: nenhum prossegue além da primeira comparação.",
                              "finalVerifications": [
                                "Pode simular o algoritmo passo a passo com um exemplo de mismatch imediato?",
                                "Calcula corretamente n-m+1 comparações para valores dados de n e m?",
                                "Explica por que o total é Θ(n) e não O(1)?",
                                "Distingue o melhor caso do pior caso em termos de comparações?",
                                "Fornece um exemplo concreto onde isso ocorre na prática?",
                                "Descreve o impacto se m > n?"
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa do mismatch imediato (100%)",
                                "Cálculo exato de n-m+1 comparações (95-100%)",
                                "Uso correto e justificado de Θ(n) (100%)",
                                "Explicação clara com exemplo prático (90-100%)",
                                "Ausência de confusão com outros casos de complexidade (95%)",
                                "Generalização assintótica rigorosa (90-100%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Análise assintótica e funções de crescimento",
                                "Estatística: Modelagem de casos extremos e probabilidades baixas",
                                "Engenharia de Software: Avaliação de performance em cenários otimistas",
                                "Linguística Computacional: Processamento eficiente de consultas de texto"
                              ],
                              "realWorldApplication": "Em motores de busca como Google ou editores de texto (Ctrl+F), o melhor caso ocorre em buscas por termos inexistentes (ex: 'zzyzx' em documento inglês comum), permitindo falha rápida em Θ(n) e liberação de recursos para otimizações em casos comuns de 'nenhum resultado encontrado', economizando CPU em grandes corpora de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.1.3.3",
                            "name": "Discutir limitações e quando usar",
                            "description": "Comparar com algoritmos eficientes como Knuth-Morris-Pratt (O(n+m)) e identificar cenários onde o naive é aceitável (n e m pequenos).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Complexidade do Algoritmo Naive",
                                  "subSteps": [
                                    "Analise o pior caso do Naive String Matching, onde ocorrem falhas frequentes no início do padrão.",
                                    "Calcule o tempo de execução: O(n * m), onde n é o comprimento do texto e m do padrão.",
                                    "Implemente um exemplo simples em Python para medir o tempo em casos grandes.",
                                    "Compare com casos médios e melhores para entender variações.",
                                    "Registre os resultados em uma tabela de complexidades."
                                  ],
                                  "verification": "Crie uma tabela comparativa mostrando O(n*m) para diferentes tamanhos de n e m, e confirme com testes empíricos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (Python)",
                                    "Textos de teste com tamanhos variados (pequeno: 100 chars, grande: 1M chars)"
                                  ],
                                  "tips": "Use timeit no Python para medições precisas; foque em casos de pior performance como padrão 'aaa...a' em texto 'a...ab'.",
                                  "learningObjective": "Compreender profundamente por que o Naive pode ser quadrático e seus impactos.",
                                  "commonMistakes": [
                                    "Confundir complexidade média com pior caso.",
                                    "Ignorar overhead de constantes em implementações reais.",
                                    "Usar inputs pequenos demais para observar ineficiências."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Complexidade do Algoritmo Knuth-Morris-Pratt (KMP)",
                                  "subSteps": [
                                    "Revise o pré-processamento do padrão para criar a tabela de falha (prefix function).",
                                    "Entenda como o KMP evita reescaneios desnecessários, alcançando O(n + m).",
                                    "Implemente uma versão básica do KMP e compare tempos com o Naive.",
                                    "Analise o pré-processamento: O(m) e matching: O(n).",
                                    "Teste com os mesmos inputs do Step 1."
                                  ],
                                  "verification": "Implemente KMP e mostre que o tempo é linear em logs ou prints de execução.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código fonte do KMP (disponível online ou implemente)",
                                    "Mesmos textos de teste do Step 1"
                                  ],
                                  "tips": "Comece com um vídeo curto sobre KMP para visualização; debugue a tabela de falha passo a passo.",
                                  "learningObjective": "Dominar os princípios do KMP e sua superioridade assintótica.",
                                  "commonMistakes": [
                                    "Erro na construção da tabela de prefixo (falha em overlaps).",
                                    "Comparar apenas tempos sem considerar pré-processamento.",
                                    "Achar KMP 'mágico' sem entender o shift."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Naive vs. KMP em Detalhes",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: complexidade, constantes, memória, simplicidade de código.",
                                    "Meça tempos reais para n=10^6, m=10^3 em ambos algoritmos.",
                                    "Discuta trade-offs: Naive é mais simples (menos código, erros).",
                                    "Analise quando o Naive ganha (m muito pequeno, hardware moderno).",
                                    "Grave um vídeo ou diagrama explicando as diferenças."
                                  ],
                                  "verification": "Produza uma tabela e gráfico de performance comprovando superioridade do KMP em grandes n/m.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha (Google Sheets/Excel)",
                                    "Biblioteca matplotlib para gráficos",
                                    "Códigos dos Steps anteriores"
                                  ],
                                  "tips": "Normalize tempos por tamanho de input; rode testes múltiplas vezes para médias.",
                                  "learningObjective": "Capacitar comparações quantitativas e qualitativas entre algoritmos.",
                                  "commonMistakes": [
                                    "Focar só em teoria sem benchmarks reais.",
                                    "Ignorar que KMP tem overhead inicial.",
                                    "Concluir erroneamente que Naive é sempre ruim."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Cenários de Uso e Limitações do Naive",
                                  "subSteps": [
                                    "Liste limitações: ineficiente para n>10^5 e m>100; alto uso de CPU em loops.",
                                    "Defina thresholds: use Naive se n*m < 10^7 operações (regra prática).",
                                    "Cenários aceitáveis: protótipos, scripts rápidos, m fixo pequeno (ex: busca em UI).",
                                    "Discuta quando evitar: buscas em arquivos grandes, streaming de dados.",
                                    "Crie regras de decisão em pseudocódigo."
                                  ],
                                  "verification": "Escreva um fluxograma ou regras que decidam entre Naive e KMP baseado em n e m.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (Draw.io)",
                                    "Exemplos reais de aplicações"
                                  ],
                                  "tips": "Considere custo de implementação: Naive para aprendizado inicial.",
                                  "learningObjective": "Aplicar análise de complexidade para escolhas práticas de algoritmos.",
                                  "commonMistakes": [
                                    "Ser muito rígido: sempre preferir eficiente sem contexto.",
                                    "Subestimar simplicidade em cenários de baixa performance.",
                                    "Não considerar bibliotecas built-in que otimizam."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um editor de texto simples como Notepad++, implementar busca de palavra 'error' em log de 10k linhas (n=100k chars, m=5): Naive é instantâneo e simples; para log de 1M linhas, KMP previne lentidão perceptível.",
                              "finalVerifications": [
                                "Explicar verbalmente por que O(n*m) falha em n=10^6, m=10^3.",
                                "Mostrar benchmark onde KMP é 100x mais rápido.",
                                "Listar 3 cenários onde Naive é preferível.",
                                "Criar regra: 'Se n*m > 10^8, use KMP'.",
                                "Comparar linhas de código: Naive ~10 vs KMP ~50.",
                                "Identificar limitação: Naive não lida bem com overlaps complexos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de complexidades (O(n*m) vs O(n+m)).",
                                "Uso de evidências empíricas (benchmarks/gráficos).",
                                "Identificação correta de thresholds práticos.",
                                "Balanceamento entre eficiência e simplicidade.",
                                "Clareza na comunicação de limitações.",
                                "Aplicação a cenários reais sem exageros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Assintótica e Big O Notation.",
                                "Engenharia de Software: Trade-offs de Design e Refatoração.",
                                "Estatística: Análise de Performance Empírica e Medição de Tempos.",
                                "Física/Computação: Modelagem de Processos Sequenciais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps mobile para busca rápida em listas pequenas (Naive ok), vs. motores de busca como Google (usa variantes de KMP/Aho-Corasick para eficiência em bilhões de chars); scripts de automação em logs de servidores onde simplicidade acelera prototipagem."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Algoritmo Knuth-Morris-Pratt (KMP)",
                    "description": "Algoritmo eficiente que usa tabela de falhas para evitar recomputações desnecessárias.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Tabela de Prefixos (Função de Falha)",
                        "description": "Estrutura de dados que, para cada posição i no padrão, armazena o tamanho do maior prefixo próprio que também é sufixo do prefixo de comprimento i+1, permitindo saltos eficientes durante a busca.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Identificar prefixos e sufixos próprios",
                            "description": "Dado um padrão, identificar manualmente todos os prefixos e sufixos próprios e determinar o maior prefixo que é também sufixo para posições iniciais da tabela.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos de prefixos e sufixos próprios",
                                  "subSteps": [
                                    "Defina prefixo próprio: substring inicial de uma string S[0..k-1] onde 1 ≤ k < |S|.",
                                    "Defina sufixo próprio: substring final de uma string S[|S|-k..|S|-1] onde 1 ≤ k < |S|.",
                                    "Diferencie de prefixo/sufixo impróprios (string inteira).",
                                    "Liste exemplos para S = 'ABC': prefixos próprios ['A','AB'], sufixos próprios ['C','BC'].",
                                    "Confirme que prefixos/sufixos próprios excluem a string vazia."
                                  ],
                                  "verification": "Escreva definições e liste prefixos/sufixos próprios para duas strings exemplo sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, caneta, quadro branco opcional",
                                  "tips": "Use diagramas visuais: desenhe a string e marque inícios/fins.",
                                  "learningObjective": "Dominar definições precisas de prefixos e sufixos próprios em strings.",
                                  "commonMistakes": "Incluir string vazia ou string inteira como próprios."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar prefixos e sufixos próprios para substring P[0..i]",
                                  "subSteps": [
                                    "Escolha posição i inicial (ex: i=1 para P[0..1]).",
                                    "Escreva substring S = P[0..i].",
                                    "Liste todos prefixos próprios de S (tamanhos 1 a i).",
                                    "Liste todos sufixos próprios de S (tamanhos 1 a i).",
                                    "Compare pares de mesmo tamanho visualmente."
                                  ],
                                  "verification": "Para i=1 em exemplo, liste prefixos ['A'] e sufixos ['A'] corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, exemplo de padrão impresso",
                                  "tips": "Alinhe prefixos à esquerda e sufixos à direita para facilitar comparação.",
                                  "learningObjective": "Gerar listas completas de prefixos e sufixos próprios para qualquer substring inicial.",
                                  "commonMistakes": "Esquecer tamanhos intermediários ou confundir ordem da string."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o maior prefixo que é também sufixo",
                                  "subSteps": [
                                    "Comece pelo maior tamanho possível k=i e desça até 0.",
                                    "Para cada k, compare prefixo S[0..k-1] == sufixo S[i-k+1..i].",
                                    "Registre o maior k onde coincidem.",
                                    "Se nenhum k>0, defina como 0.",
                                    "Anote na tabela de prefixos para posição i: pi[i] = k."
                                  ],
                                  "verification": "Para S='AA' (i=1), confirme pi[1]=1; para 'AAB' (i=2), pi[2]=0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela em branco para pi[], régua para alinhar comparações",
                                  "tips": "Compare caractere por caractere de trás para frente para eficiência.",
                                  "learningObjective": "Determinar pi[i] como comprimento máximo de prefixo-sufixo próprio.",
                                  "commonMistakes": "Parar no primeiro match sem verificar maiores k."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar iterativamente para posições iniciais e construir tabela parcial",
                                  "subSteps": [
                                    "Repita passos 2-3 para i=1 até i=5 (ou comprimento inicial desejado).",
                                    "Preencha tabela pi[0]=0 sempre, então pi[1] a pi[n-1].",
                                    "Verifique consistência: pi[i] < i+1.",
                                    "Desenhe a tabela final com posições e valores.",
                                    "Teste com variação do padrão para validar."
                                  ],
                                  "verification": "Construa tabela completa para P='AABA': pi = [0,1,0,1] sem discrepâncias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou papel com colunas para i, S[0..i], pi[i]",
                                  "tips": "Pratique com padrões repetitivos primeiro para ganhar confiança.",
                                  "learningObjective": "Construir manualmente tabela de prefixos para posições iniciais do KMP.",
                                  "commonMistakes": "Definir pi[0] incorretamente ou ignorar que pi[i] deve ser < i+1."
                                }
                              ],
                              "practicalExample": "Para padrão P = 'AABA':\n- i=1, S='AA': prefixos ['A'], sufixos ['A'] → pi[1]=1\n- i=2, S='AAB': prefixos ['A','AA'], sufixos ['B','AB'] → nenhum match → pi[2]=0\n- i=3, S='AABA': prefixos ['A','AA','AAB'], sufixos ['A','BA','ABA'] → 'A' match → pi[3]=1\nTabela: [0,1,0,1]",
                              "finalVerifications": [
                                "pi[0] sempre 0.",
                                "Para cada i, pi[i] ≤ i.",
                                "pi[i] é o maior k onde P[0..k-1] == P[i-k+1..i].",
                                "Listas de prefixos/sufixos estão completas e sem string inteira.",
                                "Nenhum pi[i] > 0 onde strings não coincidem.",
                                "Tabela construída manualmente bate com exemplo conhecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de prefixo/sufixo próprios (100% correto).",
                                "Listas exaustivas de prefixos/sufixos para cada i (sem omissões).",
                                "Identificação correta do maior k coincidente (verificação caractere por caractere).",
                                "Tabela pi preenchida corretamente para todas posições iniciais.",
                                "Explicação clara de pelo menos um passo com diagrama.",
                                "Tempo de execução manual < 90 minutos para padrão de 10 chars."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Prefixos/sufixos em morfologia de palavras (ex: 'un-happy').",
                                "Matemática: Teoria de strings e autômatos finitos.",
                                "Biologia: Análise de sequências de DNA (padrões repetitivos em genomas).",
                                "Engenharia de Software: Otimização de algoritmos de busca em código."
                              ],
                              "realWorldApplication": "No algoritmo KMP, essa tabela acelera buscas de padrões em textos grandes, como motores de busca (Google), editores de texto (VS Code find/replace) e bioinformática (encontrar genes em sequências genéticas), reduzindo comparações de O(n*m) para O(n+m)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Calcular a tabela de prefixos manualmente",
                            "description": "Construir a tabela π (pi) para um padrão dado, como 'ABABABC', preenchendo cada entrada com o comprimento do maior prefixo-sufixo correspondente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o padrão e inicializar a tabela de prefixos",
                                  "subSteps": [
                                    "Escreva o padrão P, por exemplo, 'ABABABC'. Identifique o comprimento m = 7.",
                                    "Crie uma tabela π com m entradas (índices 0 a 6), inicialize π[0] = 0 e as demais como vazias.",
                                    "Inicialize as variáveis de controle: i = 1 (posição atual no padrão), len = 0 (comprimento do prefixo-sufixo candidato atual)."
                                  ],
                                  "verification": "Confirme que π[0] = 0, i = 1 e len = 0 estão anotados corretamente no papel.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Padrão de exemplo: 'ABABABC'"
                                  ],
                                  "tips": "Lembre-se: prefixos e sufixos são próprios (não a string inteira), então π[i] sempre < i+1.",
                                  "learningObjective": "Compreender os conceitos fundamentais e preparar a estrutura para o cálculo manual da tabela π.",
                                  "commonMistakes": [
                                    "Esquecer de definir π[0] = 0",
                                    "Usar índices 1-baseados em vez de 0-baseados",
                                    "Não anotar len e i claramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular π[i] para posições com matches diretos (extensão de len)",
                                  "subSteps": [
                                    "Para i=1 (len=0): P[1]='B' ≠ P[0]='A'; como len=0, sem backtrack, defina π[1]=0 (len permanece 0).",
                                    "i=2 (len=0): P[2]='A' == P[0]='A'; incremente len=1, defina π[2]=1.",
                                    "i=3 (len=1): P[3]='B' == P[1]='B'; len=2, π[3]=2.",
                                    "i=4 (len=2): P[4]='A' == P[2]='A'; len=3, π[4]=3.",
                                    "i=5 (len=3): P[5]='B' == P[3]='B'; len=4, π[5]=4."
                                  ],
                                  "verification": "A tabela parcial é [0, 0, 1, 2, 3, 4, _] e len=4 após i=5.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel com inicialização do Step 1"
                                  ],
                                  "tips": "Observe que len é carregado da iteração anterior, permitindo extensão contínua sem recomeçar do zero.",
                                  "learningObjective": "Executar matches diretos para construir prefixos-sufixos crescentes usando len persistente.",
                                  "commonMistakes": [
                                    "Redefinir len=0 após cada i",
                                    "Comparar com posição errada de P[len]",
                                    "Perder o carry-over de len"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Lidar com mismatch usando backtrack via função de falha",
                                  "subSteps": [
                                    "Para i=6 (len=4): P[6]='C' ≠ P[4]='A'; inicie while: len = π[3] = 2.",
                                    "len=2: 'C' ≠ P[2]='A'; len = π[1] = 0.",
                                    "len=0: 'C' ≠ P[0]='A'; sem match, defina π[6]=0 (len permanece 0).",
                                    "Anota a sequência de backtracks para visualização."
                                  ],
                                  "verification": "π[6] = 0 calculado corretamente, com backtracks documentados: 4 → 2 → 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel com tabela parcial do Step 2"
                                  ],
                                  "tips": "Trate len como um 'ponteiro de estado'; backtrack simula falhas em um autômato de string.",
                                  "learningObjective": "Aplicar o loop de backtrack recursivo usando valores prévios de π para resolver mismatches.",
                                  "commonMistakes": [
                                    "Ignorar o while e setar π[i]=0 imediatamente",
                                    "Erro em π[len-1] (use len-1 correto)",
                                    "Confundir P[i] com P[len]"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e verificar a tabela π completa",
                                  "subSteps": [
                                    "Para cada i=1 a 6, verifique se P[0 até π[i]-1] == P[i-π[i]+1 até i].",
                                    "Exemplo i=2 (π=1): P[0]='A' == P[2]='A'.",
                                    "i=5 (π=4): P[0:3]='ABAB' == P[2:5]='ABAB'.",
                                    "Confirme que π[i] é o maior possível testando len+1 quando aplicável.",
                                    "Anote qualquer discrepância e recalcule."
                                  ],
                                  "verification": "Todas as 6 verificações de strings iguais passam; tabela final: [0,0,1,2,3,4,0].",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel com tabela completa"
                                  ],
                                  "tips": "Use alinhamento visual: escreva o padrão duas vezes sobrepostas para checar prefixo-sufixo.",
                                  "learningObjective": "Garantir a correção e maximalidade da tabela π através de validação explícita.",
                                  "commonMistakes": [
                                    "Pular verificação de maximalidade",
                                    "Erro em slicing de strings (off-by-one)",
                                    "Não checar entradas com π[i]>0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o padrão 'ABABABC', aplique os steps: inicialize π[0]=0, matches diretos dão [0,0,1,2,3,4,?], backtrack em i=6 (4→2→0) dá π[6]=0. Tabela final [0,0,1,2,3,4,0] otimiza buscas no KMP evitando recomeços.",
                              "finalVerifications": [
                                "Tabela π calculada corretamente como [0,0,1,2,3,4,0] para 'ABABABC'.",
                                "Backtrack em i=6 explicado: len 4→2→0.",
                                "Verificou igualdade de prefixo-sufixo para pelo menos i=2,4,5.",
                                "Identifica π[5]=4 como ABAB == ABAB.",
                                "Explica por que π[6]=0 (nenhum prefixo termina em 'C').",
                                "Aplica o processo a um padrão similar de tamanho 4-5."
                              ],
                              "assessmentCriteria": [
                                "Tabela π final exata e completa.",
                                "Todos subSteps executados com cálculos precisos.",
                                "Backtrack descrito corretamente com sequência de lens.",
                                "Verificações de validação passam para todas entradas.",
                                "Objetivos de aprendizado articulados por step.",
                                "Identifica e corrige erros comuns demonstrados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções de borda em teoria de strings e automatos finitos.",
                                "Linguística: Detecção de padrões repetidos e morfemas em análise textual.",
                                "Biologia Computacional: Alinhamento e busca de sequências em genomas de DNA.",
                                "Engenharia: Otimização de algoritmos em processamento de big data e compressão."
                              ],
                              "realWorldApplication": "No algoritmo KMP, a tabela π permite busca de padrões em textos longos em tempo linear O(n+m), essencial em ferramentas como editores de texto (Ctrl+F), motores de busca web, análise de logs de segurança, matching de sequências genéticas em bioinformática e detecção de plágio em documentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Interpretar o uso da tabela em falhas",
                            "description": "Explicar como a tabela evita recomputações ao indicar, em caso de mismatch, o estado de matching anterior sem voltar ao início.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Mismatch no Algoritmo KMP",
                                  "subSteps": [
                                    "Revise o processo de busca padrão no KMP, identificando onde ocorre um mismatch.",
                                    "Explique o que aconteceria em uma busca ingênua: voltar ao início após mismatch.",
                                    "Identifique o problema de recomputação em buscas ingênuas.",
                                    "Discuta como o KMP usa estados de matching para otimizar.",
                                    "Anote os termos chave: posição i no texto, j no padrão, estado atual."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o fluxo de mismatch na busca ingênua vs. KMP.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, diagrama do algoritmo KMP impresso ou digital.",
                                  "tips": "Desenhe setas para visualizar o 'deslize' do padrão no texto.",
                                  "learningObjective": "Entender o problema que a tabela de falhas resolve.",
                                  "commonMistakes": "Confundir mismatch com falha total; assumir que KMP sempre volta ao zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Construção e Significado da Tabela de Prefixos",
                                  "subSteps": [
                                    "Revise como a tabela π (prefix table) é construída para o padrão.",
                                    "Para cada posição k no padrão, π[k] é o comprimento do maior prefixo próprio que é sufixo.",
                                    "Entenda que π[k] indica o 'estado de falha' ou matching parcial.",
                                    "Liste valores da tabela para um padrão exemplo como 'AABAAC'.",
                                    "Explique que a tabela armazena transições de falha pré-computadas."
                                  ],
                                  "verification": "Construa a tabela π para um padrão dado e explique cada valor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou planilha para π, exemplos de padrões escritos.",
                                  "tips": "Use a regra KMP para π: enquanto mismatch, vá para π[j-1].",
                                  "learningObjective": "Dominar o que cada entrada na tabela representa.",
                                  "commonMistakes": "Calcular π incorretamente como overlap total em vez de prefixo-sufixo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Uso da Tabela Durante um Mismatch",
                                  "subSteps": [
                                    "Simule um mismatch: quando padrão[j] != texto[i], defina j = π[j-1].",
                                    "Explique por quê: j aponta para o estado de matching anterior válido.",
                                    "Repita até match ou j=0, evitando recomputar do início.",
                                    "Compare com busca ingênua: KMP 'pula' usando a tabela.",
                                    "Registre o ganho: menos comparações ao reutilizar overlaps."
                                  ],
                                  "verification": "Aplique em um exemplo curto e trace j após mismatch.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplo de texto e padrão impressos, tabela π pronta.",
                                  "tips": "Pinte o estado j atual e novas posições para visualizar saltos.",
                                  "learningObjective": "Explicar como a tabela evita recomputações.",
                                  "commonMistakes": "Definir j = π[j] em vez de π[j-1]; ignorar loop de falhas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Validar o Processo Completo",
                                  "subSteps": [
                                    "Escolha um exemplo completo e trace toda a busca com falhas.",
                                    "Conte o número de comparações com e sem tabela.",
                                    "Identifique múltiplos mismatches e como a tabela os resolve.",
                                    "Implemente pseudocódigo simples focando na linha de falha.",
                                    "Discuta eficiência: O(n+m) vs. O((n-m+1)*m)."
                                  ],
                                  "verification": "Produza um trace tabular com posições i, j, ações e tabela usada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Pseudocódigo KMP, ferramenta online como KMP visualizer.",
                                  "tips": "Use tabelas para traces: colunas i, texto[i], padrão[j], π[j-1], novo j.",
                                  "learningObjective": "Aplicar a interpretação em simulação real.",
                                  "commonMistakes": "Perder matches parciais; contar comparações erradas."
                                }
                              ],
                              "practicalExample": "Padrão: 'ABABAC', Texto: 'ABABACAB'. Tabela π: [0,0,1,2,3,0]. No mismatch em i=5 ('A' vs 'C'), j=5, π[4]=3, novo j=3 ('A'=='A'), continua sem voltar ao início, encontrando match em i=6.",
                              "finalVerifications": [
                                "Explica corretamente como π[j-1] indica estado anterior em mismatch.",
                                "Simula trace sem erros em exemplo com múltiplas falhas.",
                                "Compara eficiência KMP vs. ingênua numericamente.",
                                "Identifica quando j volta a 0 e por quê.",
                                "Descreve tabela π como 'mapa de saltos' para falhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de π[j-1] como ponte para matching parcial.",
                                "Correção no trace de simulação (sem desvios lógicos).",
                                "Quantificação do benefício: menos recomputações.",
                                "Uso correto de termos: prefixo-sufixo, estado de falha.",
                                "Capacidade de generalizar para padrões arbitrários.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos finitos e funções de transição.",
                                "Linguística Computacional: Análise de padrões em textos naturais.",
                                "Engenharia de Software: Otimização de algoritmos de string matching.",
                                "Biologia Computacional: Busca de sequências em DNA."
                              ],
                              "realWorldApplication": "Em editores de texto como VS Code para 'find & replace' eficientes em arquivos grandes; em bioinformática para alinhar sequências genéticas sem recomputar overlaps; em sistemas de detecção de plágio ou busca em motores de busca."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Construção da Tabela de Prefixos",
                        "description": "Algoritmo O(m) para computar a tabela de prefixos de forma linear, utilizando uma variável de comprimento atual de matching para preencher a tabela iterativamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Executar o algoritmo de construção passo a passo",
                            "description": "Simular a construção da tabela para um padrão exemplo, gerenciando o ponteiro 'len' e comparando caracteres para atualizar valores de π[i].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o padrão exemplo e inicializar variáveis",
                                  "subSteps": [
                                    "Selecione um padrão exemplo, como P = 'AABAABAA' (m = 8), e anote os caracteres com índices de 0 a 7.",
                                    "Crie o array π de tamanho m, inicializando todos os elementos com 0.",
                                    "Defina explicitamente π[0] = 0.",
                                    "Inicialize as variáveis de controle: i = 1, len = 0.",
                                    "Desenhe uma tabela para registrar i, len, P[i], P[len], ação e π atualizado."
                                  ],
                                  "verification": "Confirme que π = [0, 0, 0, 0, 0, 0, 0, 0], i = 1 e len = 0, com tabela de registro pronta.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência ao pseudocódigo do KMP",
                                    "Calculadora para índices (opcional)"
                                  ],
                                  "tips": "Use cores diferentes para prefixo e sufixo na anotação para visualizar bordas.",
                                  "learningObjective": "Configurar o estado inicial corretamente para simular a construção da tabela π.",
                                  "commonMistakes": [
                                    "Iniciar i = 0 em vez de 1",
                                    "Esquecer de anotar índices do padrão",
                                    "Inicializar len ≠ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular avanço quando há match (P[i] == P[len])",
                                  "subSteps": [
                                    "Para a posição atual i, compare P[i] com P[len].",
                                    "Se iguais, incremente len (len += 1).",
                                    "Atribua π[i] = len.",
                                    "Incremente i (i += 1).",
                                    "Exemplo inicial: i=1, len=0, P[1]='A' == P[0]='A', len=1, π[1]=1, i=2. Registre na tabela."
                                  ],
                                  "verification": "Após o match, verifique se π[i-1] foi atualizado corretamente, i e len avançaram, e a anotação está consistente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de registro iniciada",
                                    "Padrão anotado"
                                  ],
                                  "tips": "Sempre anote o valor de π[i] imediatamente após o match para evitar confusão.",
                                  "learningObjective": "Executar corretamente as atualizações em casos de correspondência de caracteres.",
                                  "commonMistakes": [
                                    "Incrementar i sem setar π[i]",
                                    "Esquecer de incrementar len",
                                    "Confundir P[i] com P[len]"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar mismatch com backtrack (P[i] != P[len])",
                                  "subSteps": [
                                    "Se P[i] != P[len] e len > 0, defina len = π[len - 1] (backtrack).",
                                    "Não incremente i; reavalie a comparação P[i] == P[novo len].",
                                    "Se após backtrack(s) ainda mismatch e len == 0, defina π[i] = 0 e incremente i.",
                                    "Continue o processo até match ou len=0.",
                                    "Exemplo: i=2, len=1, 'B' != 'A', len=π[0]=0; 'B' != 'A', π[2]=0, i=3."
                                  ],
                                  "verification": "Confirme que len foi reduzido corretamente via π[len-1], sem avançar i prematuramente, e π[i] setado só quando necessário.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de registro",
                                    "Pseudocódigo KMP para referência"
                                  ],
                                  "tips": "Conte os backtracks em uma pilha mental ou anote 'backtrack to len=X' para rastrear.",
                                  "learningObjective": "Aplicar o mecanismo de fallback usando a tabela π para resolver mismatches eficientemente.",
                                  "commonMistakes": [
                                    "Incrementar i durante backtrack",
                                    "Setar len = 0 diretamente sem usar π[len-1]",
                                    "Loop infinito por não atualizar len corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar o loop até i == m e validar a tabela",
                                  "subSteps": [
                                    "Continue o while i < m, alternando entre steps 2 e 3 conforme necessário.",
                                    "Registre todas as iterações até i == m.",
                                    "Para cada π[i], verifique manualmente se P[0..π[i]-1] == P[i-π[i]+1..i].",
                                    "Confirme a tabela final para o exemplo: π = [0, 1, 0, 1, 2, 3, 4, 5]."
                                  ],
                                  "verification": "i == m, tabela completa sem erros de índice, e pelo menos 2 verificações manuais de bordas confirmadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de registro completa",
                                    "Padrão e π final esperados"
                                  ],
                                  "tips": "Valide bordas grandes primeiro (ex: π[7]=5) para confiança na simulação.",
                                  "learningObjective": "Finalizar a simulação e validar a corretude da tabela π construída.",
                                  "commonMistakes": [
                                    "Parar cedo antes de i==m",
                                    "Ignorar validação de prefixo-sufixo",
                                    "Erros de transcrição na tabela final"
                                  ]
                                }
                              ],
                              "practicalExample": "Padrão P = 'AABAABAA' (índices 0-7: A,A,B,A,A,B,A,A).\nSimulação resumida:\n- i=1,len=0: match A=A → len=1,π[1]=1,i=2\n- i=2,len=1: mismatch B≠A → len=0; mismatch B≠A → π[2]=0,i=3\n- i=3,len=0: match A=A → len=1,π[3]=1,i=4\n- i=4,len=1: match A=A → len=2,π[4]=2,i=5\n- i=5,len=2: match B=B → len=3,π[5]=3,i=6\n- i=6,len=3: match A=A → len=4,π[6]=4,i=7\n- i=7,len=4: match A=A → len=5,π[7]=5,i=8\nTabela final: [0,1,0,1,2,3,4,5]",
                              "finalVerifications": [
                                "Tabela π completa com m elementos e π[0]=0",
                                "Todos π[i] ≤ i e representam bordas válidas (prefixo == sufixo)",
                                "Ponteiro len gerenciado corretamente sem valores inválidos",
                                "Simulação reproduz tabela correta para o exemplo dado",
                                "Nenhum erro de índice ou loop durante backtracks"
                              ],
                              "assessmentCriteria": [
                                "Inicialização precisa de π, i e len",
                                "Atualizações corretas em matches (len++, π[i]=len, i++)",
                                "Backtracks precisos usando len = π[len-1]",
                                "Tratamento correto de mismatches com len=0 (π[i]=0, i++)",
                                "Validação final com verificações de bordas manuais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções prefixo-sufixo e recursão em bordas",
                                "Lógica e Algoritmos: Estruturas de controle while e condicionais aninhadas",
                                "Programação: Manipulação de arrays, índices e simulação manual de código"
                              ],
                              "realWorldApplication": "Simulação manual essencial para depuração de implementações KMP em busca de textos (ex: editores como VS Code), detecção de padrões em DNA (bioinformática) ou compressão de dados, onde eficiência O(m) evita buscas ineficientes em strings longas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Implementar construção da tabela em pseudocódigo",
                            "description": "Escrever o pseudocódigo completo para computar π, incluindo inicialização, loop principal e tratamento de mismatches recursivos via π[len-1].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a tabela π e variáveis auxiliares",
                                  "subSteps": [
                                    "Declare um array π de tamanho m (comprimento do padrão P), inicializando todos os elementos como 0.",
                                    "Defina π[0] = 0 explicitamente.",
                                    "Inicialize as variáveis i = 1 (índice atual no padrão) e len = 0 (comprimento do prefixo atual).",
                                    "Escreva o cabeçalho do pseudocódigo: função ComputePrefixTable(P) onde m = length(P).",
                                    "Adicione comentários explicando o propósito de cada variável."
                                  ],
                                  "verification": "Verifique se π[0] está definido como 0 e se i e len estão inicializados corretamente no pseudocódigo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto ou papel para rascunho, documentação do KMP.",
                                  "tips": "Sempre comente o código para clareza; lembre-se que π representa o maior prefixo próprio que é sufixo.",
                                  "learningObjective": "Compreender o estado inicial da construção da tabela de prefixos.",
                                  "commonMistakes": "Esquecer de inicializar π[0] ou confundir i com len."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o loop principal para casos de match",
                                  "subSteps": [
                                    "Inicie um loop while i < m.",
                                    "Dentro do loop, verifique se P[i] == P[len]; se sim, incremente len (len = len + 1).",
                                    "Atribua π[i] = len.",
                                    "Incremente i (i = i + 1).",
                                    "Adicione indentação correta para mostrar a estrutura condicional."
                                  ],
                                  "verification": "Simule o loop com i=1 e um match simples; confirme que π[i] é atualizado corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplo de padrão curto como 'AAA', calculadora manual.",
                                  "tips": "Use indentação consistente para diferenciar blocos if/else.",
                                  "learningObjective": "Dominar a extensão do prefixo quando caracteres coincidem.",
                                  "commonMistakes": "Incrementar i antes de atribuir π[i], ou esquecer de atualizar len."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o tratamento de mismatches recursivos",
                                  "subSteps": [
                                    "No else do if (P[i] != P[len]), verifique se len != 0.",
                                    "Se len != 0, defina len = π[len - 1] (backtrack recursivo).",
                                    "Senão (len == 0), defina π[i] = 0 e incremente i.",
                                    "Garanta que o backtrack não cause loop infinito simulando.",
                                    "Adicione um comentário explicando o 'mismatch recursivo via π[len-1]'."
                                  ],
                                  "verification": "Teste com padrão 'ABABAC'; verifique se len é corretamente backtrackado em mismatches.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para simular execuções passo a passo, tabela de exemplo pré-calculada.",
                                  "tips": "Pense no len como um ponteiro para o próximo candidato de prefixo.",
                                  "learningObjective": "Implementar corretamente o backtracking para eficiência O(m).",
                                  "commonMistakes": "Usar len-- em vez de π[len-1], ou não verificar len != 0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar o pseudocódigo e validar estrutura geral",
                                  "subSteps": [
                                    "Feche o loop while e retorne a tabela π.",
                                    "Adicione seções de pré-condições (P não vazio) e pós-condições (π válida).",
                                    "Revise o pseudocódigo completo por sintaxe e lógica.",
                                    "Simule com um exemplo completo para garantir terminação.",
                                    "Formate com quebras de linha e comentários padronizados."
                                  ],
                                  "verification": "Execute mentalmente ou em pseudocódigo simulator; confirme π correta para padrão teste.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Pseudocódigo simulator online ou papel.",
                                  "tips": "Sempre teste com padrões como 'AABAACAABAA' para casos complexos.",
                                  "learningObjective": "Produzir pseudocódigo completo, legível e verificável.",
                                  "commonMistakes": "Loop infinito por falta de incremento de i no mismatch len==0."
                                }
                              ],
                              "practicalExample": "Para o padrão P = 'ABABAC' (m=6):\nπ = [0, 0, 1, 2, 0, 1]\nExecução: i=1, P[1]='B'!=P[0]='A' → π[1]=0, i=2\ni=2, P[2]='A'==P[0] → len=1, π[2]=1, i=3\ni=3, P[3]='B'==P[1]='B' → len=2, π[3]=2, i=4\ni=4, P[4]='A'!=P[2]='A'? Wait, 'A'==P[2]='A'? No: len=2, P[4]='A'!=P[2]='A'? P='A B A B A C', P[2]='A', P[4]='A'==P[2], len=3? Simulate fully.",
                              "finalVerifications": [
                                "π[0] == 0",
                                "Para todo i, 0 ≤ π[i] < i",
                                "π[i] é o maior k tal que P[0..k-1] == P[i-k+1..i]",
                                "O algoritmo termina em exatamente m iterações (O(m))",
                                "Nenhum índice fora de bounds",
                                "Backtrack correto em mismatches"
                              ],
                              "assessmentCriteria": [
                                "Pseudocódigo cobre inicialização, match e mismatch corretamente",
                                "Uso preciso de π[len-1] para recursão",
                                "Estrutura de loop while i < m sem erros lógicos",
                                "Clareza com comentários e formatação",
                                "Simulação manual produz π correta para exemplo dado",
                                "Eficiência implícita O(m) sem loops aninhados"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções de prefixo-sufixo e relações recursivas",
                                "Linguagens Formais: Autômatos finitos e transições de falha",
                                "Engenharia de Software: Especificação formal via pseudocódigo",
                                "Análise de Algoritmos: Prova de complexidade linear"
                              ],
                              "realWorldApplication": "Construção da tabela π é o pré-processamento essencial no KMP para buscas eficientes em textos grandes, como busca em documentos (Google), matching de DNA em bioinformática, detecção de plágio em códigos fonte e compressão de strings em bancos de dados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Provar complexidade O(m) da construção",
                            "description": "Analisar o número de operações, mostrando que cada posição i é processada uma vez e os 'backups' totais somam no máximo m.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o algoritmo de construção da tabela de prefixos π do KMP",
                                  "subSteps": [
                                    "Leia o pseudocódigo completo da construção da tabela π para um padrão P de comprimento m.",
                                    "Identifique o loop principal: for i = 1 to m-1.",
                                    "Explique as variáveis: length (comprimento do prefixo atual) inicializado em 0, π[0] = 0.",
                                    "Descreva o while interno: enquanto length > 0 e P[i] != P[length], length = π[length-1].",
                                    "Note o if: se P[i] == P[length], length++ e π[i] = length; senão π[i] = length."
                                  ],
                                  "verification": "Escreva o pseudocódigo de memória e identifique corretamente o loop while como o responsável pelos 'backups'.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Pseudocódigo do KMP prefix table",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Desenhe um fluxograma do algoritmo para visualizar os fluxos de length.",
                                  "learningObjective": "Compreender a estrutura exata do algoritmo para análise posterior.",
                                  "commonMistakes": "Confundir π[i] com length final ou ignorar que π[0] é sempre 0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar as iterações do loop principal (avanços de i)",
                                  "subSteps": [
                                    "Observe que o loop for executa exatamente m-1 vezes (i de 1 a m-1).",
                                    "Cada iteração de i conta como uma operação básica (O(1) por si só).",
                                    "Registre que i é incrementado monotonicamente, processando cada posição uma vez.",
                                    "Ignore temporariamente o while interno para isolar este custo: total de m operações.",
                                    "Confirme que não há saltos ou repetições em i."
                                  ],
                                  "verification": "Conte e prove que o número de execuções do corpo do for é exatamente m-1.",
                                  "estimatedTime": "10 minutes",
                                  "materials": [
                                    "Pseudocódigo",
                                    "Exemplo de padrão simples"
                                  ],
                                  "tips": "Pense em i como um ponteiro que só avança, nunca retrocede.",
                                  "learningObjective": "Estabelecer o custo base do loop externo como O(m).",
                                  "commonMistakes": "Achar que i pode ser processado múltiplas vezes ou contar i=0 separadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que o número total de execuções do while interno (backups) é no máximo m",
                                  "subSteps": [
                                    "Note que length só aumenta no 'if match' com length++, e começa em 0.",
                                    "Todo aumento de length é +1, e length nunca excede i+1 ≤ m.",
                                    "Cada execução do while diminui length estritamente (pois π[length-1] < length).",
                                    "O total de aumentos de length ao longo do algoritmo é no máximo m (pois max length = m).",
                                    "Como cada backup é uma diminuição, e diminuições não podem exceder aumentos acumulados, total de backups ≤ m."
                                  ],
                                  "verification": "Escreva uma argumentação formal: #aumentos ≤ m, #diminuições ≤ #aumentos, logo #backups = O(m).",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Papel para contagens",
                                    "Exemplo com backups"
                                  ],
                                  "tips": "Use contadores imaginários: incremente um para cada ++length, decremente para cada while.",
                                  "learningObjective": "Dominar a prova por amortização do número de backups.",
                                  "commonMistakes": "Esquecer que π[length-1] < length garante diminuição estrita, ou contar aumentos errados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a complexidade total e verificar com exemplo prático",
                                  "subSteps": [
                                    "Some os custos: loop principal O(m) + backups O(m) = O(m) total.",
                                    "Aplique a prova em um exemplo concreto, contando operações explicitamente.",
                                    "Confirme que para qualquer padrão, a contagem bate com a prova teórica.",
                                    "Discuta por que isso é linear e eficiente comparado a abordagens ingênuas.",
                                    "Escreva a notação big-O formal: Tempo de construção da tabela π é O(m)."
                                  ],
                                  "verification": "Para um padrão dado, conte operações e veja ≤ 2m.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Exemplo 'aacaa'",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Escolha padrões com e sem backups para contrastar.",
                                  "learningObjective": "Integrar a análise e afirmar a complexidade O(m).",
                                  "commonMistakes": "Adicionar custos extras desnecessários ou falhar na soma final."
                                }
                              ],
                              "practicalExample": "Considere o padrão P = 'aacaa' (m=5). Construção: π=[0,1,0,1,2]. Operações: i=1: match, length=1 (1 avanço). i=2: mismatch, 1 backup (length=0), no match (1 avanço). i=3: match, length=1 (1 avanço). i=4: match, length=2 (1 avanço). Total: 4 avanços i + 1 backup = 5 operações ≤ 2m=10, confirmando O(m).",
                              "finalVerifications": [
                                "Explicar corretamente como length aumenta e diminui.",
                                "Provar que #backups ≤ m com argumento de amortização.",
                                "Contar operações em um exemplo e mostrar ≤ c*m para constante c.",
                                "Afirmar que total é O(m) sem termos ocultos.",
                                "Identificar que i processa cada posição exatamente uma vez.",
                                "Diferenciar custo da construção da busca subsequente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do algoritmo e variáveis.",
                                "Correção na prova dos backups (diminuição estrita e amortização).",
                                "Análise quantitativa correta do loop principal.",
                                "Conclusão big-O justificada com soma de custos.",
                                "Uso consistente de notação e termos técnicos.",
                                "Exemplo prático com contagem explícita de operações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução e análise assintótica (big-O).",
                                "Lógica: Argumentos de invariantes e contadores amortizados.",
                                "Engenharia de Software: Análise de complexidade em algoritmos reais.",
                                "Física/Matemática: Conceitos de movimento browniano ou contagens cumulativas."
                              ],
                              "realWorldApplication": "Na busca de padrões em genomas (bioinformática), logs de servidores ou motores de busca, a construção O(m) da tabela KMP permite pré-processamento rápido do padrão, viabilizando buscas eficientes em textos gigantescos sem timeouts."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Algoritmo de Busca KMP",
                        "description": "Processo de emparelhamento que utiliza a tabela de prefixos para processar o texto em O(n) tempo, avançando no padrão ou pulando via função de falha em mismatches.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Simular busca KMP em texto e padrão",
                            "description": "Executar o algoritmo manualmente em um texto como 'ABABABCDABABABCABABABC' com padrão 'ABABABC', rastreando q (estado) e reportando ocorrências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a Tabela de Prefixo (Pi Array) para o Padrão",
                                  "subSteps": [
                                    "Escreva o padrão 'ABABABC' em uma linha.",
                                    "Inicialize pi[0] = 0.",
                                    "Para cada posição i de 1 a 6, compute o comprimento do prefixo próprio mais longo que é também sufixo até i, usando k como comprimento atual.",
                                    "Se padrão[i] == padrão[k], incremente k e defina pi[i] = k; senão, volte k usando pi[k-1] até match ou k=0.",
                                    "Registre a tabela final: pi = [0, 0, 1, 2, 3, 0, 1]"
                                  ],
                                  "verification": "Verifique se pi = [0, 0, 1, 2, 3, 0, 1] calculando manualmente para 'ABABABC'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para anotar"
                                  ],
                                  "tips": "Sempre compare caracteres exatos e use backtrack apenas quando mismatch.",
                                  "learningObjective": "Compreender e calcular a tabela de prefixo que permite skips eficientes em mismatches.",
                                  "commonMistakes": [
                                    "Confundir prefixo com sufixo",
                                    "Não resetar k corretamente em mismatches",
                                    "Esquecer pi[0]=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Variáveis Iniciais da Simulação",
                                  "subSteps": [
                                    "Escreva o texto 'ABABABCDABABABCABABABC'.",
                                    "Inicialize i=0 (posição no texto), q=0 (estado atual, comprimento do match).",
                                    "Lembre que len(padrão)=7; match completo quando q=7.",
                                    "Prepare uma tabela para rastrear i, texto[i], q, próximo q.",
                                    "Revise a pi array ao lado para referência rápida."
                                  ],
                                  "verification": "Confirme inicialização: i=0, q=0, pi array pronta e texto/padrão visíveis.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Marcadores coloridos para texto/padrão/pi"
                                  ],
                                  "tips": "Use cores diferentes: azul para texto, vermelho para padrão, verde para q.",
                                  "learningObjective": "Preparar o ambiente de simulação rastreando estado q como 'quanto do padrão já matchou'.",
                                  "commonMistakes": [
                                    "Começar q=1",
                                    "Confundir i (texto) com posição no padrão",
                                    "Ignorar len(padrão)=7"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Matching Passo a Passo pelo Texto",
                                  "subSteps": [
                                    "Para cada i de 0 a len(texto)-1: se texto[i] == padrão[q], incremente q.",
                                    "Se q == 7, registre ocorrência em i-6, reset q = pi[q-1].",
                                    "Se mismatch (texto[i] != padrão[q]), se q>0 set q=pi[q-1] e recompare; senão i++.",
                                    "Continue até i=21, rastreando q em cada passo.",
                                    "Anote sequência de q: 0,1,2,1,2,3,0,0,1,2,3,4,5,6,0,1,... até match em i=13."
                                  ],
                                  "verification": "Rastreie q para primeiros 5 chars: deve ser 0->1(A==A),1->2(B==B),2->1(A!=A? wait match), etc.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela impressa com colunas i, texto[i], q atual, ação"
                                  ],
                                  "tips": "Faça um passo por vez, verbalize 'match? sim/não, q=?'.",
                                  "learningObjective": "Simular a transição de estados q usando pi para backtrack em mismatches.",
                                  "commonMistakes": [
                                    "Não usar pi em mismatch",
                                    "Resetar q=0 em todo mismatch",
                                    "Perder contagem de i"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar e Registrar Ocorrências de Matches",
                                  "subSteps": [
                                    "Monitore quando q atinge 7: posição de início = i - 7 + 1.",
                                    "Para o exemplo, match em i=13 (q=7), início=7.",
                                    "Reset q = pi[6]=1 após match.",
                                    "Continue simulação até fim; verifique múltiplos overlaps.",
                                    "Liste todas ocorrências: posição 7-13: 'ABABABC'."
                                  ],
                                  "verification": "Confirme pelo menos uma ocorrência em posição 7 no texto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de posições de match anotada"
                                  ],
                                  "tips": "Assinale matches no texto com underline para visualizar overlaps.",
                                  "learningObjective": "Identificar e reportar posições exatas onde padrão ocorre usando q==M.",
                                  "commonMistakes": [
                                    "Não resetar q após match",
                                    "Calcular posição errada (use i - M +1)",
                                    "Ignorar overlaps"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Validar a Simulação Completa",
                                  "subSteps": [
                                    "Revise toda a tabela de simulação para consistência.",
                                    "Conte mismatches e skips via pi vs busca ingênua.",
                                    "Compare com execução em código ou ferramenta online.",
                                    "Discuta eficiência: KMP evita rechecagens.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Simulação completa mostra match em posição 7 sem erros em q.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta online KMP visualizer opcional"
                                  ],
                                  "tips": "Compare tempo mental vs código para validar.",
                                  "learningObjective": "Validar simulação e entender vantagens do KMP sobre busca simples.",
                                  "commonMistakes": [
                                    "Pular validação",
                                    "Confundir com Boyer-Moore",
                                    "Não notar eficiência"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto: 'ABABABCDABABABCABABABC', Padrão: 'ABABABC'. Simule: pi=[0,0,1,2,3,0,1]. Matches em posição 7 ('ABABABC' de 7-13). q vai 0,1,2,... até 7 em i=13, reset para 1.",
                              "finalVerifications": [
                                "Tabela pi correta: [0,0,1,2,3,0,1]",
                                "Match detectado corretamente em posição 7",
                                "Transições de q corretas em pelo menos 5 mismatches",
                                "Reset de q após match usando pi[6]=1",
                                "Sem erros em sequência de estados q",
                                "Posição final i=21 processada"
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de pi (100% match com esperada)",
                                "Correta transição de q em matches/mismatches (90%+ passos corretos)",
                                "Detecção precisa de ocorrências e resets",
                                "Rastreamento completo sem perda de i/q",
                                "Explicação clara de pelo menos um backtrack via pi",
                                "Análise de eficiência vs busca ingênua"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Strings e Autômatos Finitos",
                                "Biologia: Busca de sequências em DNA (BLAST usa ideias similares)",
                                "Engenharia de Software: Otimização de algoritmos de busca em grandes datasets",
                                "Linguística Computacional: Análise de padrões em textos naturais"
                              ],
                              "realWorldApplication": "Usado em motores de busca como Google para indexação eficiente, ferramentas de genômica para encontrar genes em genomas, editores de texto para 'find/replace' avançado, e detecção de plágio em documentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1",
                              "10.1.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Implementar o matching KMP completo",
                            "description": "Codificar em pseudocódigo ou linguagem a combinação de construção da tabela e busca, retornando posições de matches.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar a função de construção da tabela LPS (Longest Prefix Suffix)",
                                  "subSteps": [
                                    "Inicialize um array pi de tamanho len(padrão), com pi[0] = 0.",
                                    "Defina variáveis length = 0 e i = 1.",
                                    "Em um loop while i < len(padrão): se padrão[i] == padrão[length], incremente length e defina pi[i] = length, i++.",
                                    "Senão, enquanto length > 0 e padrão[i] != padrão[length], defina length = pi[length-1].",
                                    "Se padrão[i] == padrão[length], length++, senão length = 0.",
                                    "Defina pi[i] = length e i++."
                                  ],
                                  "verification": "Teste a função com padrão 'AABAACAABAA' e verifique se pi = [0,1,2,1,0,1,2,3,2,1] está correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (Python ou pseudocódigo)",
                                    "Papel para simular manualmente"
                                  ],
                                  "tips": "Sempre comece com length=0 para evitar off-by-one errors; debugue imprimindo o array pi passo a passo.",
                                  "learningObjective": "Compreender e codificar o algoritmo para calcular a tabela de prefixos próprios mais longos.",
                                  "commonMistakes": [
                                    "Esquecer de resetar length para pi[length-1] no loop interno",
                                    "Não tratar o caso i=0 corretamente",
                                    "Índices fora dos limites do array"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a lógica de busca KMP utilizando a tabela LPS",
                                  "subSteps": [
                                    "Receba texto e padrão; compute a tabela LPS do padrão.",
                                    "Inicialize i=0 (para texto), j=0 (para padrão).",
                                    "Em um while i < len(texto): se texto[i] == padrão[j], i++, j++; se j == len(padrão), registre match em i-j, j = LPS[j-1].",
                                    "Senão, se j > 0, j = LPS[j-1]; senão i++.",
                                    "Continue até i == len(texto)."
                                  ],
                                  "verification": "Execute com texto='ABABDABACDABABCABAB' e padrão='ABABCABAB'; deve encontrar match em posição 10.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de teste prontos"
                                  ],
                                  "tips": "Use uma lista para coletar posições de matches; imprima i e j em cada iteração para depuração.",
                                  "learningObjective": "Dominar o mecanismo de deslizamento eficiente usando backtracking via LPS.",
                                  "commonMistakes": [
                                    "Incrementar i incorretamente após mismatch",
                                    "Não resetar j para LPS[j-1] após match completo",
                                    "Ignorar múltiplos overlaps"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar construção LPS e busca em uma função KMP completa",
                                  "subSteps": [
                                    "Crie função kmp(texto, padrão) que chama computeLPS(padrão) para obter lps.",
                                    "Implemente a busca dentro da função, coletando posições em uma lista.",
                                    "Retorne a lista de posições iniciais de matches (0-based).",
                                    "Adicione tratamento para padrão vazio ou texto vazio (retornar []).",
                                    "Teste unitário rápido com padrão igual ao texto."
                                  ],
                                  "verification": "Chame kmp('AAAA', 'AA') e confirme retornos [0,1,2].",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Framework de testes como unittest (opcional)"
                                  ],
                                  "tips": "Mantenha funções modulares: computeLPS separada da busca para reutilização.",
                                  "learningObjective": "Construir uma implementação encapsulada e reutilizável do KMP completo.",
                                  "commonMistakes": [
                                    "Não chamar computeLPS antes da busca",
                                    "Retornar posições erradas (fim em vez de início)",
                                    "Falhar em casos onde len(padrão) > len(texto)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a implementação com casos abrangentes",
                                  "subSteps": [
                                    "Crie testes para: padrão não encontrado, múltiplos matches, overlaps, casos edge (padrão vazio, texto vazio, padrão=texto).",
                                    "Meça tempo de execução para texto grande (ex: 10^6 chars) vs busca ingênua.",
                                    "Corrija bugs identificados comparando com implementação conhecida.",
                                    "Documente a função com comentários e exemplos.",
                                    "Otimize se necessário (verificar complexidade O(n+m))."
                                  ],
                                  "verification": "Todos os testes passam e eficiência é linear.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Conjunto de testes pré-definidos",
                                    "Cronômetro para performance"
                                  ],
                                  "tips": "Use asserts ou prints para validar; compare com bibliotecas como Python's str.find em loops.",
                                  "learningObjective": "Garantir robustez e corretude através de testes sistemáticos.",
                                  "commonMistakes": [
                                    "Esquecer casos sem matches",
                                    "Erros em overlaps como 'aaa' em 'aaaa'",
                                    "Não medir performance"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto: 'ABABDABACDABABCABAB', Padrão: 'ABABCABAB'. LPS do padrão: [0,0,1,2,0,1,2,0,1]. Matches encontrados na posição 10 (0-based). Código em pseudocódigo: função kmp retorna [10].",
                              "finalVerifications": [
                                "Função retorna lista correta de posições para padrões com overlaps.",
                                "Tabela LPS é computada corretamente para padrões variados.",
                                "Complexidade é O(n + m) confirmada por testes de performance.",
                                "Funciona para edge cases: padrões vazios, textos curtos, sem matches.",
                                "Implementação em pseudocódigo ou linguagem é legível e comentada.",
                                "Múltiplos matches são todos capturados sem duplicatas."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% dos testes passam.",
                                "Eficiência: Tempo linear em textos grandes.",
                                "Clareza: Código modular com funções separadas (LPS e busca).",
                                "Robustez: Trata todos edge cases sem crashes.",
                                "Documentação: Comentários explicam lógica chave.",
                                "Originalidade: Implementação própria, não copiada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de autômatos finitos e funções de transição.",
                                "Bioinformática: Busca de padrões em sequências de DNA/RNA.",
                                "Engenharia de Software: Otimização de algoritmos de string matching.",
                                "Ciência de Dados: Pré-processamento em mineração de texto."
                              ],
                              "realWorldApplication": "Usado em editores de texto (Ctrl+F eficiente), motores de busca (Google), análise genômica (BLAST usa variantes), detecção de plágio em documentos e compressão de dados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Analisar complexidade total O(n + m)",
                            "description": "Demonstrar que o algoritmo processa cada caractere do texto exatamente uma vez, com transições de estado custando O(1) amortizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Pré-processamento do Padrão (Computação da Tabela π)",
                                  "subSteps": [
                                    "Examine o algoritmo de construção da tabela π (prefix function) para o padrão de comprimento m.",
                                    "Trace o processo de preenchimento da tabela π, contando comparações de caracteres.",
                                    "Identifique que cada posição j no padrão é visitada no máximo duas vezes (avanço e recuo).",
                                    "Calcule o número total de operações na construção da π, mostrando que é O(m)."
                                  ],
                                  "verification": "Construa manualmente a tabela π para um padrão exemplo e confirme que o número de operações é ≤ 2m.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Implementação do KMP em pseudocódigo",
                                    "Exemplo de padrão: 'ABABABC'"
                                  ],
                                  "tips": "Use um quadro para visualizar o ponteiro i e j durante a construção.",
                                  "learningObjective": "Entender que o pré-processamento custa O(m) devido ao movimento limitado dos ponteiros.",
                                  "commonMistakes": "Confundir o custo da π com O(m²); lembre-se do amortizado pelas falhas limitadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Fase de Busca no Texto",
                                  "subSteps": [
                                    "Descreva o loop principal de matching no texto de comprimento n, avançando o estado q.",
                                    "Mostre que para cada caractere do texto, há exatamente uma comparação com o padrão.",
                                    "Explique as transições de falha: quando q < π[q-1], o estado recua, mas avance no texto sempre ocorre.",
                                    "Argumente que o número total de transições de estado é ≤ 2n (um avanço por caractere + recuos limitados).",
                                    "Demonstre que cada recuo é compensado por avanços prévios, levando a O(1) amortizado por transição."
                                  ],
                                  "verification": "Simule a busca em um texto exemplo, contando avanços e recuos no estado q.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo KMP",
                                    "Texto exemplo: 'ABABABCA'",
                                    "Padrão: 'ABABAC'"
                                  ],
                                  "tips": "Mantenha contadores separados para 'match' e 'mismatch' para visualizar o amortizado.",
                                  "learningObjective": "Compreender que o texto é processado linearmente, com recuos não excedendo avanços.",
                                  "commonMistakes": "Achar que mismatches causam O(nm); foque no fato de que texto avança sempre."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar o Custo Amortizado das Transições de Estado",
                                  "subSteps": [
                                    "Defina o potencial como o estado atual q (profundidade no padrão).",
                                    "Mostre que um match aumenta q em 1 (ΔΦ = +1, custo efetivo 0).",
                                    "Para mismatch, recuo diminui q, mas cada recuo custa O(1) e é pago por matches prévios.",
                                    "Some sobre n passos: total de mudanças em q é ≤ 2n (sobe até m, desce no máximo n vezes).",
                                    "Conclua que transições custam O(n) no total."
                                  ],
                                  "verification": "Aplique análise potencial em uma execução com muitos recuos e verifique total ≤ 2n.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha com análise potencial",
                                    "Exemplo com padrão repetitivo: 'AAAA' em 'AAAAAAAA'"
                                  ],
                                  "tips": "Pense em 'dívida' de matches pagando recuos futuros.",
                                  "learningObjective": "Dominar prova amortizada para mostrar O(n) na busca.",
                                  "commonMistakes": "Ignorar que q nunca excede m, limitando recuos totais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Complexidades e Concluir O(n + m)",
                                  "subSteps": [
                                    "Some custos: pré-processamento O(m) + busca O(n).",
                                    "Confirme independência: m e n são tamanhos fixos, sem dependência quadrática.",
                                    "Compare com força bruta O((n-m+1)m) para destacar eficiência.",
                                    "Discuta casos extremos: padrão todo igual, texto todo diferente.",
                                    "Escreva formalmente: T(n,m) ≤ 2m + 2n = O(n + m)."
                                  ],
                                  "verification": "Escreva uma prova curta de 1 página resumindo a análise total.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resumo de provas anteriores",
                                    "Tabela de comparações com Naive"
                                  ],
                                  "tips": "Use notação big-O explicitamente na conclusão.",
                                  "learningObjective": "Integrar análises parciais em complexidade total precisa.",
                                  "commonMistakes": "Esquecer pré-processamento ou superestimar buscas."
                                }
                              ],
                              "practicalExample": "Para padrão P='AABAAC' (m=6) e texto T='AABAACAABAAX' (n=12), construa π=[0,1,0,1,2,0], então busque: processa 12 chars do T (12 comparações), com 2 matches completos e recuos totais <12, confirmando <24 operações +6 para π.",
                              "finalVerifications": [
                                "Construir π e contar operações ≤2m.",
                                "Simular busca contando avanços/recuos ≤2n.",
                                "Aplicar potencial e somar ΔΦ + custo real = O(n).",
                                "Testar com n=1000, m=100: tempo real linear.",
                                "Escrever equação T(n,m)≤2n+2m.",
                                "Comparar com implementação timed vs naive."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de operações na π (O(m)).",
                                "Correta argumentação de processamento único do texto.",
                                "Uso válido de análise amortizada/potencial.",
                                "Tratamento de casos extremos sem exceções.",
                                "Conclusão formal O(n+m) sem termos extras.",
                                "Clareza na prova escrita e exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise amortizada e funções de potencial (Cálculo I/II).",
                                "Matemática Discreta: Autômatos finitos e linguagens regulares.",
                                "Engenharia de Software: Otimização de algoritmos de string em compiladores.",
                                "Bioinformática: Alinhamento de sequências de DNA (BLAST usa ideias similares)."
                              ],
                              "realWorldApplication": "Em editores de texto como VS Code ou grep Unix, busca de padrões em arquivos grandes (n=GB) é O(n+m), permitindo buscas instantâneas em código-fonte ou logs sem lentidão quadrática."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.4",
                            "name": "Comparar KMP com busca ingênua",
                            "description": "Contrastar o número de comparações em cenários como texto 'aaaaa...a' com padrão 'aaa...', mostrando eficiência do KMP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o funcionamento da busca ingênua",
                                  "subSteps": [
                                    "Explique o algoritmo de busca ingênua: para cada posição i no texto, compare o padrão caractere por caractere a partir de i.",
                                    "Escreva pseudocódigo simples da busca ingênua.",
                                    "Implemente um exemplo básico em pseudocódigo ou código (ex: texto='abcde', padrão='cd').",
                                    "Conte o número de comparações de caracteres realizadas.",
                                    "Discuta casos médios e piores intuitivamente."
                                  ],
                                  "verification": "Pseudocódigo correto e contagem de comparações precisa no exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou IDE para pseudocódigo"
                                  ],
                                  "tips": "Sempre comece contando comparações explícitas de caracteres para evitar confusão com shifts.",
                                  "learningObjective": "Compreender o mecanismo básico e o custo computacional da busca ingênua.",
                                  "commonMistakes": [
                                    "Confundir shifts de posição com comparações de caracteres",
                                    "Ignorar falhas parciais no início"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o algoritmo KMP e sua tabela de falha (pi)",
                                  "subSteps": [
                                    "Explique a pré-computação da tabela pi (prefix function): para cada posição no padrão, o maior prefixo que é sufixo.",
                                    "Construa a tabela pi para um padrão simples como 'aaa'.",
                                    "Descreva como usar a tabela durante a busca: em mismatch, shift usando pi[j-1].",
                                    "Implemente pseudocódigo do KMP completo.",
                                    "Compare conceitualmente com ingênua: shifts otimizados."
                                  ],
                                  "verification": "Tabela pi correta para 'aaa' (ex: [0,1,2]) e pseudocódigo funcional.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela pi",
                                    "Exemplos de padrões repetitivos"
                                  ],
                                  "tips": "Lembre-se: pi[i] é o comprimento do prefixo-sufixo próprio até i.",
                                  "learningObjective": "Dominar a construção e uso da tabela pi no KMP.",
                                  "commonMistakes": [
                                    "Erro na computação de pi (confundir com KMP inteiro)",
                                    "Não resetar estado corretamente em mismatches"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular cenário pior-caso na busca ingênua",
                                  "subSteps": [
                                    "Escolha texto T = 'aaaaa...a' (n=10 'a's), padrão P = 'aaa' (m=3).",
                                    "Simule passo a passo: inicie em i=0, compare até mismatch, shift i+=1, repita.",
                                    "Conte todas as comparações de caracteres (esperado: ~n*m no pior caso).",
                                    "Registre o número total: para este caso, 3+2+1 + 3+2+1 + ... até fim.",
                                    "Generalize para textos/padrões de 'a's: O((n-m+1)*m) comparações."
                                  ],
                                  "verification": "Contagem correta: 21 comparações para n=10, m=3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela de simulação",
                                    "Strings longas de 'a'"
                                  ],
                                  "tips": "Use uma tabela para rastrear posição i, j e comparações acumuladas.",
                                  "learningObjective": "Quantificar ineficiência da ingênua em padrões repetitivos.",
                                  "commonMistakes": [
                                    "Subestimar comparações em shifts parciais",
                                    "Parar simulação cedo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular o mesmo cenário no KMP",
                                  "subSteps": [
                                    "Use mesmo T e P: construa pi para P='aaa' → [0,1,2].",
                                    "Simule busca: inicie i=0, j=0; avance j em matches, use pi em mismatches.",
                                    "Conte comparações: KMP faz ~2n no pior caso para este padrão.",
                                    "Registre total: para n=10, m=3, ~10-15 comparações.",
                                    "Compare números exatos com ingênua."
                                  ],
                                  "verification": "Contagem correta: ~10 comparações, shifts eficientes via pi.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesma planilha de simulação",
                                    "Tabela pi pré-computada"
                                  ],
                                  "tips": "Visualize o 'backtrack' via pi como reutilização de overlaps.",
                                  "learningObjective": "Demonstrar eficiência prática do KMP no pior caso da ingênua.",
                                  "commonMistakes": [
                                    "Erro no shift: j = pi[j-1] em mismatch",
                                    "Contar pré-computação como busca"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar métricas e analisar eficiência geral",
                                  "subSteps": [
                                    "Tabule números: ingênua vs KMP para múltiplos tamanhos (n=10,100).",
                                    "Discuta complexidades: ingênua O(nm) vs KMP O(n+m).",
                                    "Teste outro cenário (ex: padrão não-repetitivo) para equilíbrio.",
                                    "Conclua vantagens: KMP sempre <= ingênua, ótimo em repetições.",
                                    "Implemente código simples para validar contagens."
                                  ],
                                  "verification": "Tabela comparativa precisa e conclusão sobre O(n) vs O(nm).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python simples para contadores",
                                    "Gráfico de comparações"
                                  ],
                                  "tips": "Implemente contadores explícitos em código para automação.",
                                  "learningObjective": "Sintetizar comparação quantitativa e qualitativa.",
                                  "commonMistakes": [
                                    "Ignorar pré-processamento O(m) do KMP",
                                    "Generalizar de um caso só"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um texto de 1000 'a's procurando 'aaa': ingênua faz ~300.000 comparações (lento); KMP faz ~1000 (rápido). Simule em código Python com contadores para ver na prática.",
                              "finalVerifications": [
                                "Calcula corretamente comparações em 'aaaaa...a' (n=10) com 'aaa': ingênua=21, KMP=10.",
                                "Constrói tabela pi correta para padrões repetitivos.",
                                "Explica por que KMP é O(n+m) usando overlaps.",
                                "Identifica quando ingênua falha (padrões com auto-overlaps).",
                                "Compara em código: tempo de execução real difere por fator 100+.",
                                "Generaliza para bioinformática: busca em genomas longos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de comparações (erro <5%).",
                                "Correção na tabela pi e lógica de shift.",
                                "Análise qualitativa de eficiência (complexidades assintóticas).",
                                "Uso de exemplos múltiplos além do fornecido.",
                                "Implementação funcional em pseudocódigo/código.",
                                "Conclusão clara sobre superioridade do KMP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica O(nm) vs O(n), funções prefixo-sufixo.",
                                "Estatística: Análise de casos pior/médio/melhor probabilísticos.",
                                "Biologia Computacional: Busca de padrões em sequências de DNA/RNA.",
                                "Engenharia de Software: Otimização de algoritmos em editores de texto.",
                                "Linguística Computacional: Processamento de linguagem natural (PLN)."
                              ],
                              "realWorldApplication": "Em motores de busca como Google ou editores como VS Code (Ctrl+F), KMP acelera buscas em arquivos grandes; em bioinformática, encontra genes em genomas humanos (bilhões de bases) sem travar, contrastando com ingênua que seria inviável."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Tabela de Prefixos (Função de Falha)",
                    "description": "Pré-processamento do padrão para computar os maiores prefixos próprios que são sufixos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Prefixos e Sufixos Próprios",
                        "description": "Compreensão dos conceitos fundamentais de prefixos próprios e sufixos em strings, essenciais para o pré-processamento no algoritmo de emparelhamento de padrões.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Identificar prefixos próprios de uma string",
                            "description": "Dado uma string, listar todos os seus prefixos próprios, excluindo a string inteira, e explicar por que eles são chamados de 'próprios'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de prefixo em strings",
                                  "subSteps": [
                                    "Leia a definição: Um prefixo de uma string S é qualquer substring inicial contígua de S, incluindo a string vazia e S inteira.",
                                    "Analise exemplos: Para S = 'abc', prefixos são '', 'a', 'ab', 'abc'.",
                                    "Pratique identificando: Escreva todos os prefixos de 'hello'.",
                                    "Diferencie de substring: Prefixos começam sempre no índice 0.",
                                    "Registre em um caderno para fixar."
                                  ],
                                  "verification": "Liste todos os prefixos de uma string exemplo como 'xyz' e confirme que inclui vazia e total.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples"
                                  ],
                                  "tips": [
                                    "Sempre comece do início da string.",
                                    "Inclua a string vazia inicialmente para entender o conceito completo."
                                  ],
                                  "learningObjective": "Definir precisamente o que é um prefixo e listar todos para uma string dada.",
                                  "commonMistakes": [
                                    "Confundir prefixo com sufixo ou substring arbitrária.",
                                    "Esquecer a string vazia ou a string inteira."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e diferenciar prefixos próprios",
                                  "subSteps": [
                                    "Aprenda a definição: Prefixos próprios são prefixos que excluem a string inteira (e geralmente a vazia em contextos computacionais).",
                                    "Exemplo prático: Para 'abc', prefixos próprios: 'a', 'ab'.",
                                    "Compare: Liste prefixos totais vs. próprios para 'banana'.",
                                    "Explique verbalmente: 'Por que próprios? Porque são prefixos 'próprios' ou estritos, menores que a original.'",
                                    "Anote a justificativa: Deriva de 'proper prefix' em teoria de linguagens formais."
                                  ],
                                  "verification": "Explique em 2 frases por que 'ab' é prefixo próprio de 'abc', mas 'abc' não é.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos impressos de strings"
                                  ],
                                  "tips": [
                                    "'Próprios' indica exclusão da string completa, como herdeiros próprios em direito."
                                  ],
                                  "learningObjective": "Distinguir prefixos próprios dos prefixos gerais e justificar o termo.",
                                  "commonMistakes": [
                                    "Incluir a string inteira.",
                                    "Excluir todos os prefixos curtos ou incluir vazia desnecessariamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver método para listar prefixos próprios",
                                  "subSteps": [
                                    "Algoritmo simples: Para string S de tamanho n, gere S[0..k-1] para k=1 a n-1.",
                                    "Implemente manualmente: Para 'AABAAC' (n=6), liste: 'A', 'AA', 'AAB', 'AABA', 'AABAA'.",
                                    "Automatize em pseudocódigo: for i in 1 to n-1: prefix = S[0:i]; add to list.",
                                    "Teste com 3 strings variadas: 'a', 'aa', 'abcde'.",
                                    "Valide: Confirme que todos são prefixos e nenhum é a string toda."
                                  ],
                                  "verification": "Gere e liste prefixos próprios para uma nova string como 'pattern' sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou Python IDLE",
                                    "Papel para rascunho"
                                  ],
                                  "tips": [
                                    "Use slicing em linguagens como Python: S[:k] para k=1 a len(S)-1.",
                                    "Conte sempre o comprimento para evitar off-by-one."
                                  ],
                                  "learningObjective": "Aplicar algoritmo iterativo para extrair todos os prefixos próprios.",
                                  "commonMistakes": [
                                    "Erro de índice: começar em 0 ou incluir n.",
                                    "Listar duplicatas em strings com repetições."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar compreensão e contextualizar",
                                  "subSteps": [
                                    "Revise lista: Para 'mississippi', liste e cheque manualmente.",
                                    "Explique contexto: Prefixos próprios são base para tabela de prefixos no KMP.",
                                    "Resolva exercício: Identifique prefixos próprios de 'abab'.",
                                    "Autoavalie: Marque erros comuns e corrija.",
                                    "Discuta importância: Como ajuda em matching de padrões eficientes."
                                  ],
                                  "verification": "Responda quiz: Liste para 2 strings e explique 'próprios' em contexto KMP.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quiz impresso ou digital",
                                    "Referência KMP básica"
                                  ],
                                  "tips": [
                                    "Visualize a string como array de chars para indexing preciso."
                                  ],
                                  "learningObjective": "Integrar o conceito ao contexto de análise de algoritmos e autoavaliar.",
                                  "commonMistakes": [
                                    "Ignorar repetições em strings palindrômicas.",
                                    "Confundir com bordas ou períodos em KMP."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a string S = 'AABAAC':\n- Prefixos próprios: 'A', 'AA', 'AAB', 'AABA', 'AABAA'.\nExplicação: São todos os prefixos iniciais de comprimento 1 a 5 (excluindo os 6 chars totais), chamados 'próprios' por serem estritos e menores que S, fundamentais para calcular a função de prefixo π no algoritmo KMP.",
                              "finalVerifications": [
                                "Lista correta e completa de prefixos próprios para qualquer string dada.",
                                "Explicação precisa do termo 'próprios' sem inclusão da string inteira.",
                                "Identificação correta de prefixos próprios vs. prefixos gerais.",
                                "Aplicação do algoritmo em strings com repetições (ex: 'aaa').",
                                "Conexão com tabela de prefixos em KMP.",
                                "Ausência de erros de indexação ou duplicatas."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos prefixos próprios listados corretamente.",
                                "Completude: Todos de len=1 a n-1 incluídos.",
                                "Clareza na explicação do termo 'próprios'.",
                                "Eficiência do método descrito (O(n) tempo).",
                                "Correção em casos edge: strings de len=1 ou vazia.",
                                "Integração contextual com emparelhamento de padrões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Subsequências e subestruturas em sequências discretas.",
                                "Linguística: Análise morfológica de prefixos em palavras.",
                                "Biologia Computacional: Identificação de prefixos em sequências de DNA/RNA.",
                                "Engenharia de Software: Processamento de strings em parsers e compiladores."
                              ],
                              "realWorldApplication": "No algoritmo Knuth-Morris-Pratt (KMP), prefixos próprios são usados para construir a tabela de falha (prefix function π), permitindo buscas de padrões em textos grandes de forma eficiente O(n+m), aplicado em editores de texto, motores de busca (Google), bioinformática (BLAST) e compressão de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Identificar sufixos próprios de uma string",
                            "description": "Dado uma string, listar todos os seus sufixos próprios, excluindo a string inteira, e verificar se um prefixo próprio coincide com um sufixo próprio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de prefixos e sufixos próprios",
                                  "subSteps": [
                                    "Defina prefixo próprio: substring inicial de S, excluindo S inteira.",
                                    "Defina sufixo próprio: substring final de S, excluindo S inteira.",
                                    "Diferencie de prefixos/sufixos impróprios (que incluem S inteira).",
                                    "Identifique exemplos simples: para 'abc', prefixos próprios ['a','ab'], sufixos próprios ['bc','c']."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as definições e dê 2 exemplos corretos sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples"
                                  ],
                                  "tips": [
                                    "Lembre-se: próprios excluem a string completa.",
                                    "Use diagramas para visualizar posições na string."
                                  ],
                                  "learningObjective": "Dominar definições precisas de prefixos e sufixos próprios em strings.",
                                  "commonMistakes": [
                                    "Incluir a string inteira como prefixo/sufixo próprio.",
                                    "Confundir prefixo com sufixo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar a lista completa de sufixos próprios de uma string",
                                  "subSteps": [
                                    "Comece pela string S de comprimento n.",
                                    "Gere sufixos de comprimento 1 até n-1, iniciando do final: S[i..n-1] para i=1 a n-1.",
                                    "Liste-os em ordem decrescente ou crescente de tamanho.",
                                    "Exclua explicitamente S[0..n-1].",
                                    "Valide manualmente para string curta (ex: 'aa' → ['a'])."
                                  ],
                                  "verification": "Liste sufixos próprios para 'banana' e confirme: ['anana','nana','ana','na','a'].",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Python REPL ou editor (opcional para automação inicial)"
                                  ],
                                  "tips": [
                                    "Trabalhe de trás para frente para sufixos.",
                                    "Anote índices para evitar duplicatas.",
                                    "Teste com strings repetidas como 'aaa'."
                                  ],
                                  "learningObjective": "Implementar método sistemático para extrair todos sufixos próprios.",
                                  "commonMistakes": [
                                    "Gerar sufixos de comprimento n.",
                                    "Omitir sufixos curtos como comprimento 1.",
                                    "Duplicar se string tem repetições."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar a lista de prefixos próprios e preparar para verificação",
                                  "subSteps": [
                                    "Gere prefixos próprios: S[0..j] para j=0 a n-2.",
                                    "Liste em ordem crescente de tamanho.",
                                    "Compare manualmente com lista de sufixos próprios do passo anterior.",
                                    "Identifique potenciais matches por inspeção visual ou conjunto.",
                                    "Registre pares (prefixo, sufixo) onde strings são iguais."
                                  ],
                                  "verification": "Para 'aa', prefixos ['a'], sufixos ['a'], match encontrado: 'a' == 'a'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmas do passo 2",
                                    "Folha com listas prontas"
                                  ],
                                  "tips": [
                                    "Use conjuntos para comparação rápida em mente.",
                                    "Ordene listas por tamanho para matches eficientes.",
                                    "Priorize comprimentos iguais."
                                  ],
                                  "learningObjective": "Extrair prefixos próprios e compará-los sistematicamente com sufixos.",
                                  "commonMistakes": [
                                    "Incluir prefixo de comprimento n.",
                                    "Comparar strings de tamanhos diferentes.",
                                    "Ignorar matches exatos por erro de digitação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar coincidências e documentar resultados",
                                  "subSteps": [
                                    "Para cada prefixo próprio, busque em sufixos próprios por igualdade exata.",
                                    "Registre todos matches encontrados (ou 'nenhum').",
                                    "Explique por que um match ocorre (ex: padrões repetidos).",
                                    "Teste com 2 strings: uma com match ('aa'), uma sem ('abc').",
                                    "Documente em tabela: prefixo | sufixo | match?."
                                  ],
                                  "verification": "Produza relatório correto para 'mississippi': matches como 'i'=='i', 'issi'=='issi', etc.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Strings de teste pré-definidas"
                                  ],
                                  "tips": [
                                    "Automatize mentalmente: 'if prefix == suffix' para cada par.",
                                    "Foco em border detection para KMP contexto.",
                                    "Valide com comprimentos iguais primeiro."
                                  ],
                                  "learningObjective": "Detectar e validar coincidências entre prefixos e sufixos próprios.",
                                  "commonMistakes": [
                                    "Match parcial em vez de exato.",
                                    "Esquecer múltiplos matches na mesma string.",
                                    "Confundir ordem das strings."
                                  ]
                                }
                              ],
                              "practicalExample": "Para S = 'aab': Sufixos próprios: ['ab', 'b']. Prefixos próprios: ['a', 'aa']. Verificação: Nenhum prefixo coincide com sufixo (mas pratique com 'aaa': sufixos ['aa','a'], prefixos ['a','aa'] → matches 'aa' e 'a'). Implemente em pseudocódigo: suffixes = [S[i:] for i in 1 to len-1], então cheque interseção com prefixes.",
                              "finalVerifications": [
                                "Lista todos sufixos próprios corretamente para string de 10 chars.",
                                "Gera prefixos próprios sem incluir string inteira.",
                                "Identifica pelo menos 80% dos matches corretos em exemplo com múltiplos.",
                                "Explica verbalmente um match encontrado ou ausência.",
                                "Aplica a 3 strings novas sem erros.",
                                "Documenta em formato tabular claro.",
                                "Relaciona a função de falha KMP."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos sufixos/prefixos listados (100%).",
                                "Precisão: Nenhum incluído impróprio ou faltante.",
                                "Eficiência: Método O(n^2) implícito ok, mas lista correta.",
                                "Correção de matches: Igualdade exata string a string.",
                                "Clareza: Listas ordenadas e tabeladas.",
                                "Contexto: Liga a prefix table em KMP.",
                                "Criatividade: Testa strings edge-case (vazia, len=1)."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise de morfemas e padrões repetidos em palavras.",
                                "Biologia: Identificação de padrões em sequências de DNA/RNA para alinhamento.",
                                "Matemática: Teoria de linguagens formais e autômatos.",
                                "Processamento de Texto: Compressão de dados via padrões repetidos (LZW).",
                                "Criptografia: Detecção de padrões em cifras repetitivas."
                              ],
                              "realWorldApplication": "Fundamento da Tabela de Prefixos (Função de Falha) no algoritmo KMP para matching de padrões em O(n+m), usado em editores de texto (busca/ substituição), bioinformática (busca de genes em genomas), motores de busca (Google-like indexing) e detecção de plágio em documentos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Encontrar o maior prefixo próprio que é sufixo",
                            "description": "Para uma substring de um padrão, determinar o comprimento do maior prefixo próprio que também é sufixo, justificando o cálculo manualmente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender prefixo próprio e sufixo próprio",
                                  "subSteps": [
                                    "Defina prefixo próprio: qualquer prefixo da string exceto a string inteira.",
                                    "Defina sufixo próprio: qualquer sufixo da string exceto a string inteira.",
                                    "Escreva exemplos simples: para 'abc', prefixos próprios ['a','ab'], sufixos próprios ['c','bc'].",
                                    "Note que prefixos e sufixos devem ter o mesmo comprimento para comparar.",
                                    "Pratique com string de 3-4 caracteres para fixar."
                                  ],
                                  "verification": "Liste corretamente prefixos e sufixos próprios de uma string exemplo sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Sempre exclua a string completa para 'próprio'.",
                                  "learningObjective": "Diferenciar prefixos e sufixos próprios de uma string.",
                                  "commonMistakes": [
                                    "Incluir a string inteira como prefixo/sufixo",
                                    "Confundir ordem de caracteres"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar listas completas de prefixos e sufixos para a substring",
                                  "subSteps": [
                                    "Anote a substring dada (ex: 'abcab').",
                                    "Liste todos prefixos próprios: comece do tamanho 1 até n-1.",
                                    "Liste todos sufixos próprios: do tamanho 1 até n-1, invertendo do final.",
                                    "Alinhe por comprimento decrescente para facilitar comparação.",
                                    "Verifique comprimentos: devem ir de 1 a len(substring)-1."
                                  ],
                                  "verification": "Listas de prefixos e sufixos estão completas e sem duplicatas ou erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para comprimentos"
                                  ],
                                  "tips": "Use abreviações para strings longas, mas escreva completas para curtas.",
                                  "learningObjective": "Gerar sistematicamente todas as substrings prefixo e sufixo próprias.",
                                  "commonMistakes": [
                                    "Esquecer prefixos/sufixos de comprimento intermediário",
                                    "Erros de digitação em substrings"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar prefixos e sufixos para identificar matches",
                                  "subSteps": [
                                    "Comece pelo maior comprimento possível (len-1) e desça.",
                                    "Para cada comprimento k, compare prefixo de tamanho k com sufixo de tamanho k.",
                                    "Registre matches: anote o comprimento e a string coincidente.",
                                    "Pare ao encontrar o primeiro (maior) match ou continue até k=0.",
                                    "Se nenhum match, o valor é 0."
                                  ],
                                  "verification": "Identifique pelo menos um match correto ou confirme 0 com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para alinhamento lado a lado",
                                    "Marcadores coloridos para matches"
                                  ],
                                  "tips": "Alinhe visualmente: escreva prefixo acima do sufixo para comparar caractere por caractere.",
                                  "learningObjective": "Comparar strings de mesmo comprimento para igualdade exata.",
                                  "commonMistakes": [
                                    "Comparar comprimentos errados",
                                    "Ignorar mismatches parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar o cálculo e registrar o comprimento final",
                                  "subSteps": [
                                    "Escreva o maior k encontrado e copie as strings matching.",
                                    "Justifique: mostre alinhamento caractere por caractere.",
                                    "Explique por que não há maior: verifique k+1 falhou onde.",
                                    "Registre o valor para a tabela de prefixos (pi[i] = k).",
                                    "Teste com variação da string para validar compreensão."
                                  ],
                                  "verification": "Justificativa escrita cobre todos matches e falhas, com valor correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para justificativa",
                                    "Exemplos de referência online (opcional)"
                                  ],
                                  "tips": "Use setas para mostrar onde mismatch ocorre em k maiores.",
                                  "learningObjective": "Documentar raciocínio manual para reprodutibilidade.",
                                  "commonMistakes": [
                                    "Selecionar match menor ignorando maiores",
                                    "Falta de justificativa para falhas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a substring 'abcab' (comprimento 5):\n- Prefixos próprios: 'a', 'ab', 'abc', 'abca'\n- Sufixos próprios: 'b', 'ab', 'cab', 'bcab'\nComparando por tamanho 4: 'abca' != 'bcab'\nTamanho 3: 'abc' != 'cab'\nTamanho 2: 'ab' == 'ab' (match!)\nTamanho 1: 'a' != 'b'\nMaior: comprimento 2 ('ab').",
                              "finalVerifications": [
                                "Lista todos prefixos e sufixos próprios corretamente.",
                                "Identifica o maior k com match exato.",
                                "Justifica por que k+1 não funciona.",
                                "Valor final bate com cálculo manual independente.",
                                "Aplica a uma segunda string sem erros.",
                                "Explica o papel na tabela de prefixos KMP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de prefixos/sufixos (100% corretos).",
                                "Correção do maior k identificado.",
                                "Qualidade da justificativa (detalhada e visual).",
                                "Eficiência na comparação (inicia pelo maior k).",
                                "Ausência de erros comuns como inclusão de string completa.",
                                "Clareza na documentação para revisão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de strings e funções de comprimento.",
                                "Linguística: Análise morfológica de prefixos/sufixos em palavras.",
                                "Biologia Computacional: Busca de padrões em sequências de DNA.",
                                "Engenharia de Software: Otimização de algoritmos de busca."
                              ],
                              "realWorldApplication": "Esse cálculo é o cerne da função de falha no algoritmo KMP, usado em motores de busca como Google para padrões em textos gigantes, editores de código para 'find & replace' eficiente, e bioinformática para alinhamento de sequências genéticas sem reprocessar overlaps desnecessários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Estrutura da Tabela de Prefixos",
                        "description": "Definição e representação da tabela de prefixos (função de falha), que armazena para cada posição i o tamanho do maior prefixo próprio que é sufixo da substring do padrão até i.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Definir a função π (tabela de prefixos)",
                            "description": "Explicar formalmente a função π[i] como o comprimento do maior k tal que o prefixo de tamanho k da substring P[0..i] é igual ao sufixo de tamanho k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Prefixos e Sufixos em Strings",
                                  "subSteps": [
                                    "Defina o que é uma string e substring.",
                                    "Identifique o prefixo de uma substring como a parte inicial.",
                                    "Identifique o sufixo de uma substring como a parte final.",
                                    "Diferencie prefixo e sufixo com exemplos simples como 'abc' prefixo 'ab', sufixo 'bc'.",
                                    "Pratique identificando prefixos e sufixos em uma string de teste."
                                  ],
                                  "verification": "Liste corretamente todos os prefixos e sufixos de uma string exemplo como 'AABAA'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto simples"
                                  ],
                                  "tips": "Sempre comece do tamanho 1 até o comprimento total da string.",
                                  "learningObjective": "Compreender prefixos e sufixos como base para a função π.",
                                  "commonMistakes": "Confundir prefixo com sufixo ou incluir a string inteira como prefixo próprio."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Prefixos e Sufixos Próprios",
                                  "subSteps": [
                                    "Defina prefixo próprio: prefixo que não é a string inteira.",
                                    "Defina sufixo próprio: sufixo que não é a string inteira.",
                                    "Explique que para π[i], consideramos a substring S = P[0..i].",
                                    "Identifique pares de prefixo e sufixo próprios de mesmo tamanho em S.",
                                    "Compare prefixo e sufixo caractere por caractere para igualdade."
                                  ],
                                  "verification": "Para S='AABAA', liste o maior k onde prefixo de k == sufixo de k (k=2: 'AA'=='AA').",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de strings impressos ou em editor"
                                  ],
                                  "tips": "Use alinhamento visual: escreva a string e marque prefixos/sufixos lado a lado.",
                                  "learningObjective": "Distinguir prefixos/sufixos próprios e verificar igualdade.",
                                  "commonMistakes": "Incluir k igual ao comprimento total de S, violando 'próprio'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente a Função π[i]",
                                  "subSteps": [
                                    "Estabeleça a notação: Para padrão P, π[i] para i de 0 a m-1, onde m=|P|.",
                                    "Defina π[i] = max { k | 0 ≤ k < i+1 e P[0..k-1] == P[i-k+1..i] }.",
                                    "Escreva a definição em palavras: maior k tal que prefixo de k de P[0..i] == sufixo de k de P[0..i].",
                                    "Note que π[0] = 0 sempre.",
                                    "Confirme que k deve ser o maior possível."
                                  ],
                                  "verification": "Escreva a definição formal exata e aplique a i=0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha com definição anotada, exemplos de P"
                                  ],
                                  "tips": "Memorize: π[i] mede sobreposição border da substring P[0..i].",
                                  "learningObjective": "Articular a definição matemática precisa de π[i].",
                                  "commonMistakes": "Esquecer que k < i+1 ou confundir índices (0-based)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Definição em um Exemplo Simples",
                                  "subSteps": [
                                    "Escolha P = 'ABABAC', compute π para cada i passo a passo.",
                                    "Para i=0: π[0]=0.",
                                    "Para i=1: verifique k=1: 'A'=='B'? Não → π[1]=0.",
                                    "Para i=2: k=1 'A'=='A'? Sim; k=2 'AB'=='BA'? Não → π[2]=1.",
                                    "Continue até i=5 e verifique π = [0,0,1,2,3,0].",
                                    "Compare seu cálculo com tabela conhecida."
                                  ],
                                  "verification": "Gere a tabela π completa para P='ABABAC' corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora de string ou papel para alinhamentos"
                                  ],
                                  "tips": "Desenhe tabelas com bordas para visualizar matches.",
                                  "learningObjective": "Calcular π[i] manualmente usando a definição.",
                                  "commonMistakes": "Parar no primeiro k em vez do maior; erros de indexação."
                                }
                              ],
                              "practicalExample": "Para o padrão P = \"AABAACAABAA\", a função π é calculada como π = [0,1,2,0,1,2,3,4,5,6,7], onde π[10]=7 porque o prefixo 'AABAACA' (k=7) iguala o sufixo 'AABAACA' da substring P[0..10].",
                              "finalVerifications": [
                                "Definição formal de π[i] recitada corretamente sem erros.",
                                "Cálculo de π para string simples de 5 chars sem falhas.",
                                "Identificação correta do maior k para pelo menos 3 posições i.",
                                "Explicação de por que π[0]=0 sempre.",
                                "Diferenciação clara entre prefixo/sufixo próprios vs. totais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (100% match com formal).",
                                "Correção em cálculos manuais de π (zero erros em exemplo).",
                                "Explicação clara de matches prefixo-sufixo.",
                                "Uso correto de notação e índices 0-based.",
                                "Capacidade de justificar o 'maior k' escolhido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de linguagens formais e autômatos.",
                                "Linguística Computacional: Análise de padrões em textos naturais.",
                                "Engenharia de Software: Otimização de algoritmos de busca.",
                                "Probabilidade: Modelos de Markov em strings aleatórias."
                              ],
                              "realWorldApplication": "A função π é o coração do pré-processamento no Algoritmo de Knuth-Morris-Pratt (KMP), permitindo buscas de padrões em textos gigantescos (ex: busca em DNA, motores de busca web) em tempo linear O(n+m), evitando reescaneios desnecessários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Inicializar a tabela de prefixos",
                            "description": "Criar uma tabela π de tamanho m (comprimento do padrão) inicializada com zeros e entender o valor π[0] = 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e Propósito da Tabela de Prefixos π",
                                  "subSteps": [
                                    "Estude a definição da tabela π no algoritmo KMP: ela armazena o comprimento do maior prefixo próprio que é também sufixo para cada prefixo do padrão.",
                                    "Analise por que π[0] deve ser sempre 0: o prefixo de comprimento 1 não tem prefixo próprio.",
                                    "Revise um exemplo simples de padrão, como 'A', para confirmar π = [0].",
                                    "Anote a importância da inicialização para o preenchimento posterior da tabela.",
                                    "Compare com a tabela de falhas em autômatos finitos."
                                  ],
                                  "verification": "Explique em suas palavras o que π representa e por que todos os valores iniciais são 0, incluindo um diagrama simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Material didático sobre algoritmo KMP",
                                    "Caderno e caneta para anotações",
                                    "Exemplos de padrões de strings"
                                  ],
                                  "tips": "Visualize a tabela como um array que será preenchido iterativamente; a inicialização garante que não haja resíduos de computações anteriores.",
                                  "learningObjective": "Dominar o conceito teórico da tabela π e sua inicialização obrigatória com zeros.",
                                  "commonMistakes": [
                                    "Confundir prefixo próprio com a string inteira",
                                    "Achar que π[0] pode ser 1 ou outro valor",
                                    "Ignorar o contexto do algoritmo KMP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o Tamanho Correto da Tabela",
                                  "subSteps": [
                                    "Identifique o padrão P fornecido (ex: 'ABABAC').",
                                    "Calcule m = len(P), o comprimento do padrão.",
                                    "Declare um array π de tamanho exato m em pseudocódigo ou linguagem de programação.",
                                    "Confirme que o índice varia de 0 a m-1.",
                                    "Teste com um padrão de comprimento conhecido para validar o cálculo."
                                  ],
                                  "verification": "Mostre o valor de m e a declaração da tabela vazia para um padrão dado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (Python, C++)",
                                    "Exemplos de padrões de teste"
                                  ],
                                  "tips": "Sempre use len(P) ou P.length() para evitar erros manuais de contagem.",
                                  "learningObjective": "Calcular precisamente o tamanho da tabela baseado no padrão.",
                                  "commonMistakes": [
                                    "Usar tamanho m+1 em vez de m",
                                    "Confundir m com n (texto)",
                                    "Índices off-by-one"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar Todos os Elementos da Tabela com Zero",
                                  "subSteps": [
                                    "Atribua π[0] = 0 explicitamente.",
                                    "Use um loop para definir π[i] = 0 para i de 1 a m-1, ou inicialize o array inteiro com zeros.",
                                    "Em Python: π = [0] * m; Em C++: vector<int> π(m, 0);",
                                    "Imprima ou visualize a tabela para confirmar todos zeros.",
                                    "Salve o código ou esboço em papel."
                                  ],
                                  "verification": "Execute ou simule e confirme que todos os m elementos são 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE ou interpretador Python/C++",
                                    "Papel para esboço manual"
                                  ],
                                  "tips": "Inicializações em lote (como [0]*m) são eficientes e evitam loops desnecessários.",
                                  "learningObjective": "Implementar a inicialização prática da tabela π de forma eficiente.",
                                  "commonMistakes": [
                                    "Esquecer π[0]",
                                    "Inicializar com 1s ou valores garbage",
                                    "Loop de 0 a m (off-by-one)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Documentar a Inicialização Completa",
                                  "subSteps": [
                                    "Inspecione cada posição da tabela para zeros.",
                                    "Teste com um padrão pequeno (m=3) e gere saída.",
                                    "Documente o código com comentários explicando cada linha.",
                                    "Compare com uma implementação de referência do KMP.",
                                    "Prepare para o próximo passo: preenchimento da tabela."
                                  ],
                                  "verification": "Gere uma tabela inicializada e afirme 'Tabela π inicializada corretamente com m elementos todos zero'.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código do step anterior",
                                    "Documentação KMP online"
                                  ],
                                  "tips": "Sempre imprima a tabela após inicialização para depuração visual.",
                                  "learningObjective": "Garantir a correção da inicialização através de verificações.",
                                  "commonMistakes": [
                                    "Não testar com exemplos",
                                    "Pular verificação achando desnecessária",
                                    "Alterar valores acidentalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o padrão P = 'ABABAC' (m=6), crie π = [0, 0, 0, 0, 0, 0]. Em Python: pattern = 'ABABAC'; m = len(pattern); pi = [0] * m; print(pi) → [0, 0, 0, 0, 0, 0]. Isso prepara para o preenchimento onde π[2]=1 (prefixo 'AB' é sufixo).",
                              "finalVerifications": [
                                "Tabela π tem exatamente m elementos.",
                                "Todos os elementos π[i] == 0 para i=0 a m-1.",
                                "π[0] é explicitamente 0.",
                                "Código ou esboço roda sem erros.",
                                "Tamanho m corresponde ao len(P).",
                                "Preparado para computar valores não-zero em steps subsequentes."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual: explica por que inicializar com zeros.",
                                "Precisão no tamanho: m calculado corretamente.",
                                "Implementação eficiente: usa inicialização em lote.",
                                "Verificação completa: todos elementos inspecionados.",
                                "Documentação clara: comentários no código.",
                                "Testes com exemplos: pelo menos 2 padrões testados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores e arrays lineares, funções de comprimento de prefixos.",
                                "Programação: Inicialização de estruturas de dados e loops.",
                                "Análise de Algoritmos: Pré-processamento em O(m) para otimização.",
                                "Engenharia de Software: Boas práticas de depuração e verificação."
                              ],
                              "realWorldApplication": "Na busca eficiente de padrões em textos grandes, como em editores de texto (VS Code 'Find'), motores de busca (Google), detecção de plágio ou análise de DNA em bioinformática, onde a tabela π inicializada acelera a correspondência evitando reescaneios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Interpretar valores da tabela",
                            "description": "Dada uma tabela de prefixos preenchida, interpretar o que cada entrada representa em termos de sobreposições no padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral da tabela de prefixos",
                                  "subSteps": [
                                    "Revise a definição: a tabela π[i] armazena o comprimento do maior prefixo próprio de P[0..i] que também é sufixo de P[0..i].",
                                    "Identifique os índices: π[0] sempre é 0; valores vão de 0 a i.",
                                    "Observe que valores representam 'deslizamentos' ou sobreposições possíveis no padrão.",
                                    "Anote a relação com o algoritmo KMP: usado para pular mismatches.",
                                    "Pratique visualizando a tabela como um array alinhado ao padrão."
                                  ],
                                  "verification": "Desenhe a tabela para um padrão simples e confirme que π[0]=0 e valores não excedem o índice.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, caneta, exemplo de padrão como 'ABAB'",
                                  "tips": "Sempre alinhe a tabela abaixo do padrão para visualizar prefixos e sufixos.",
                                  "learningObjective": "Dominar o propósito e layout da tabela de prefixos.",
                                  "commonMistakes": "Confundir prefixo com sufixo inteiro; lembrar que é prefixo próprio (não o padrão todo)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o significado de um valor individual π[i] = k",
                                  "subSteps": [
                                    "Para π[i] = k, marque os primeiros k caracteres de P[0..i] (prefixo).",
                                    "Marque os últimos k caracteres de P[0..i] (sufixo) e confirme igualdade.",
                                    "Visualize o 'deslizamento': o padrão pode ser shiftado por (i+1 - k) posições.",
                                    "Teste com k=0: nenhum overlap, backtrack total.",
                                    "Registre exemplos onde k > 0 indica overlap parcial."
                                  ],
                                  "verification": "Para uma entrada dada, escreva o prefixo e sufixo correspondentes e prove igualdade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela de prefixos impressa ou digital, highlighter para marcar strings.",
                                  "tips": "Use setas para conectar prefixo e sufixo na string para visualização clara.",
                                  "learningObjective": "Explicar precisamente o que π[i] = k significa em termos de strings.",
                                  "commonMistakes": "Interpretar k como posição de mismatch em vez de comprimento de overlap."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar sobreposições e implicações de shifts",
                                  "subSteps": [
                                    "Para cada π[i], calcule o shift possível: shift = i + 1 - π[i].",
                                    "Compare múltiplas entradas: veja como π[i] refere π[π[i]-1] para bordas.",
                                    "Desenhe diagramas de overlap: sobreponha o padrão consigo mesmo usando k.",
                                    "Analise cadeia de falhas: se mismatch em i, vá para π[i-1].",
                                    "Pratique com padrões com overlaps repetidos como 'AAA'."
                                  ],
                                  "verification": "Para toda a tabela, liste shifts e desenhe um diagrama de overlap sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de desenho como Draw.io ou papel quadriculado.",
                                  "tips": "Comece com padrões curtos (5-7 chars) para evitar confusão.",
                                  "learningObjective": "Conectar valores da tabela a sobreposições visuais e shifts no matching.",
                                  "commonMistakes": "Ignorar que overlaps são próprios (k < i+1); confundir com tabela de Z-algorithm."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar interpretação em um cenário de matching simulado",
                                  "subSteps": [
                                    "Simule um mismatch no texto usando a tabela: avance q = π[q-1].",
                                    "Interprete como a tabela permite 'pular' para overlap existente.",
                                    "Compare eficiência: sem tabela, backtrack total; com tabela, shift otimizado.",
                                    "Teste com texto que tem o padrão: verifique como overlaps aceleram.",
                                    "Documente o papel da interpretação para depuração de KMP."
                                  ],
                                  "verification": "Simule matching completo em um texto curto e explique uso de cada π[i] relevante.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Texto de exemplo com padrão, calculadora para índices.",
                                  "tips": "Use pseudocódigo KMP ao lado para correlacionar tabela com execução.",
                                  "learningObjective": "Usar interpretação da tabela para simular e entender o algoritmo KMP.",
                                  "commonMistakes": "Aplicar shift errado (usar k em vez de i+1-k); esquecer borda em q=0."
                                }
                              ],
                              "practicalExample": "Padrão P = 'AABAACAAB'. Tabela π = [0, 1, 0, 1, 2, 2, 3, 4, 2]. Para i=7 (P[0..7]='AABAACAA'), π[7]=4: prefixo 'AABA' == sufixo 'AACA'? Não, corrija: para 'AABAACAA', prefixo 'AABA' e sufixo 'CAAA'? Exemplo preciso: P='ABABAC', π=[0,0,1,2,3,0]. Para i=4 ('ABABA'), π[4]=3: prefixo 'ABA' == sufixo 'ABA'. Isso indica overlap de 3 chars, shift de 2 posições.",
                              "finalVerifications": [
                                "Explicar corretamente π[i]=k para 3 entradas diferentes de uma tabela dada.",
                                "Desenhar overlap visual para qualquer valor k > 0.",
                                "Calcular shift correto para todas as entradas.",
                                "Simular um mismatch usando a tabela sem erros.",
                                "Diferenciar de outros arrays como Z-box.",
                                "Identificar padrão sem overlap (todos π[i]=0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de prefixo e sufixo iguais (100% match).",
                                "Correta visualização de overlaps e shifts.",
                                "Explicação clara do impacto no algoritmo KMP.",
                                "Uso consistente de termos técnicos (prefixo próprio, sufixo).",
                                "Capacidade de aplicar em novos padrões sem orientação.",
                                "Detecção e correção de erros comuns em interpretações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções discretas e arrays indexados.",
                                "Linguística: Reconhecimento de padrões em sequências linguísticas/strings.",
                                "Biologia Computacional: Matching de sequências de DNA/proteínas.",
                                "Engenharia de Software: Otimização de algoritmos de busca."
                              ],
                              "realWorldApplication": "Na busca de padrões em grandes textos (ex: Google Search, grep otimizado), detecção de plágio em documentos, análise genômica para encontrar genes repetidos em DNA, e compiladores para scanning léxico eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Algoritmo de Construção da Tabela de Prefixos",
                        "description": "Algoritmo eficiente O(m) para computar a tabela de prefixos usando uma variável de comprimento de borda e loops de falha.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Implementar o loop principal do algoritmo",
                            "description": "Descrever o pseudocódigo do algoritmo: para i de 1 a m-1, usar k como comprimento da borda atual e ajustar com while quando P[i] != P[k].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a tabela de prefixos e variáveis de controle",
                                  "subSteps": [
                                    "Criar um array pi de tamanho m (comprimento do padrão P), inicializando todos os elementos com 0.",
                                    "Definir pi[0] = 0 explicitamente.",
                                    "Inicializar i = 1 (índice atual no padrão).",
                                    "Inicializar k = 0 (comprimento da borda atual).",
                                    "Garantir que o padrão P esteja indexado corretamente (0-based)."
                                  ],
                                  "verification": "Verifique se pi é um array de zeros com tamanho m, i=1, k=0 e pi[0]=0.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Pseudocódigo do algoritmo",
                                    "Editor de código (Python/JS)",
                                    "Padrão de teste curto como 'ABC'"
                                  ],
                                  "tips": "Use índices 0-based para consistência com linguagens de programação comuns.",
                                  "learningObjective": "Entender e configurar o estado inicial necessário para o loop principal.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar pi[0] = 0.",
                                    "Usar 1-based indexing incorretamente.",
                                    "Definir i=0 em vez de i=1."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o loop externo principal (for i de 1 a m-1)",
                                  "subSteps": [
                                    "Estruturar um loop que itera i de 1 até m-1.",
                                    "Dentro do loop, preparar para comparar P[i] com P[k].",
                                    "Manter o controle de i incrementando apenas após atualizações.",
                                    "Garantir que o loop pare corretamente em i == m.",
                                    "Adicionar prints ou logs para depuração de i e k em cada iteração."
                                  ],
                                  "verification": "Execute o loop vazio com um padrão de teste e confirme que i vai de 1 a m-1 sem erros.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Padrão de teste como 'AABA'"
                                  ],
                                  "tips": "Use um for loop com range(1, m) em Python para precisão.",
                                  "learningObjective": "Dominar o escopo e iteração do loop principal que processa cada posição do padrão.",
                                  "commonMistakes": [
                                    "Loop de 0 a m-1 em vez de 1 a m-1.",
                                    "Incrementar i dentro de loops internos acidentalmente.",
                                    "Condição de parada errada (i <= m-1 vs i < m)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o while interno para ajuste da borda em caso de mismatch",
                                  "subSteps": [
                                    "Adicionar um while onde k > 0 e P[i] != P[k].",
                                    "Dentro do while, definir k = pi[k-1].",
                                    "Continuar o while até match ou k=0.",
                                    "Não incrementar i ou k no while.",
                                    "Testar com mismatch para ver retrocessos em k."
                                  ],
                                  "verification": "Com padrão 'ABCD', confirme que no mismatch, k volta para pi[k-1] corretamente.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Pseudocódigo detalhado",
                                    "Editor com debugger",
                                    "Padrões com mismatches como 'AABX'"
                                  ],
                                  "tips": "O while simula 'fallback' na borda; visualize como árvore de falhas.",
                                  "learningObjective": "Implementar o mecanismo de falha que otimiza a busca evitando reescaneios.",
                                  "commonMistakes": [
                                    "Usar k = pi[k] em vez de pi[k-1].",
                                    "Incrementar k no while.",
                                    "Condição while sem k > 0, causando loop infinito."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar atualizações após comparação (match e no match)",
                                  "subSteps": [
                                    "Após while, se P[i] == P[k], então k += 1 e pi[i] = k, depois i += 1.",
                                    "Senão (k==0 e mismatch), pi[i] = 0 e i += 1.",
                                    "Integrar isso logo após o while no loop principal.",
                                    "Verificar que k não é incrementado no mismatch.",
                                    "Rodar o algoritmo completo em um exemplo."
                                  ],
                                  "verification": "Para padrão 'AABAAB', pi deve ser [0,1,0,1,2,2]; confira valores finais.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Exemplos de padrões testados",
                                    "Debugger ou prints"
                                  ],
                                  "tips": "Match estende a borda; mismatch zera ou retrocede.",
                                  "learningObjective": "Completar o ciclo de atualização da tabela pi para todas as posições.",
                                  "commonMistakes": [
                                    "Incrementar k no caso de mismatch.",
                                    "Esquecer i += 1 após atualizações.",
                                    "Definir pi[i] incorretamente no match."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o padrão P = 'AABAAC' (m=6):\n- Inicial: pi=[0,0,0,0,0,0], i=1, k=0\n- i=1: P[1]='A'==P[0]='A' → k=1, pi[1]=1, i=2\n- i=2: P[2]='B'!=P[1]='A' → while k=1>0, k=pi[0]=0; !=P[0]='A' → pi[2]=0, i=3\n- Continua até pi=[0,1,0,1,2,0]\nImplemente e imprima pi para verificar.",
                              "finalVerifications": [
                                "Tabela pi tem tamanho m com pi[0]=0.",
                                "Para cada i=1 a m-1, pi[i] ≤ i.",
                                "Propriedade de borda: P[0..pi[i]-1] == P[i-pi[i]+1..i] para todo i.",
                                "Algoritmo roda em O(m) tempo (sem loops infinitos).",
                                "Teste com padrões repetidos ('AAAA') dá pi=[0,1,2,3].",
                                "Teste com sem bordas ('ABC') dá pi=[0,0,0]."
                              ],
                              "assessmentCriteria": [
                                "Correção: pi computada exatamente como no algoritmo manual.",
                                "Eficiência: While interno não excede O(m) total.",
                                "Clareza: Código legível com comentários nos loops.",
                                "Robustez: Trata padrões vazios ou m=1 corretamente.",
                                "Depuração: Logs mostram evolução de i e k.",
                                "Generalidade: Funciona para qualquer string alfabeto."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de autômatos finitos e funções de transição.",
                                "Engenharia de Software: Otimização de algoritmos de string matching.",
                                "Linguística Computacional: Análise de padrões em textos.",
                                "Ciência de Dados: Pré-processamento para buscas eficientes em grandes datasets."
                              ],
                              "realWorldApplication": "O loop principal constrói a tabela de prefixos usada no Algoritmo de Knuth-Morris-Pratt (KMP) para busca de padrões em textos gigantescos, como em motores de busca (Google), editores de DNA em bioinformática ou detecção de plágio em documentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Calcular manualmente a tabela para um padrão",
                            "description": "Passo a passo, computar a tabela π para padrões como 'ababaca' ou 'aabaaab', mostrando ajustes de k em casos de falha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o padrão e inicializar a tabela π",
                                  "subSteps": [
                                    "Escreva o padrão P e seus índices de 0 a m-1 (ex: 'ababaca' -> 0:a, 1:b, 2:a, 3:b, 4:a, 5:c, 6:a).",
                                    "Crie uma tabela π com m entradas, inicialmente vazias.",
                                    "Defina π[0] = 0.",
                                    "Inicialize a variável k = 0 (comprimento do prefixo-sufixo atual).",
                                    "Prepare espaço para anotar backtracks e alinhamentos."
                                  ],
                                  "verification": "Confirme que π[0] = 0, o padrão está indexado corretamente e k=0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Padrão exemplo escrito ('ababaca')"
                                  ],
                                  "tips": [
                                    "Use cores para destacar prefixos potenciais.",
                                    "Lembre-se: prefixos próprios excluem o string inteiro."
                                  ],
                                  "learningObjective": "Configurar o ambiente inicial para o cálculo manual da função de falha π.",
                                  "commonMistakes": [
                                    "Definir π[0] diferente de 0.",
                                    "Indexar o padrão a partir de 1.",
                                    "Confundir o padrão P com o texto de busca."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular π[i] para posições iniciais com matches diretos",
                                  "subSteps": [
                                    "Inicie i = 1.",
                                    "Se P[i] == P[k], defina π[i] = k + 1 e k = k + 1.",
                                    "Continue para i seguinte enquanto houver match direto.",
                                    "Anote o alinhamento prefixo-sufixo para cada i (ex: i=2 em 'ababaca', prefixo 'a' == sufixo 'a').",
                                    "Pare antes do primeiro mismatch significativo."
                                  ],
                                  "verification": "Verifique π[1] até o ponto de mismatch (ex: π = [0,0,1,...] correto).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Padrão 'ababaca'"
                                  ],
                                  "tips": [
                                    "Visualize alinhando o início do padrão com o final da substring atual.",
                                    "Anote k após cada match."
                                  ],
                                  "learningObjective": "Aplicar a extensão direta de k em casos de match sem falha.",
                                  "commonMistakes": [
                                    "Incrementar k sem verificar P[i] == P[k].",
                                    "Definir π[i] = 0 incorretamente em match com k=0."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Lidar com mismatches através de backtracking",
                                  "subSteps": [
                                    "Quando P[i] != P[k] e k > 0, defina k = π[k-1] e repita a comparação.",
                                    "Continue o while até k=0 ou match.",
                                    "Após while: se P[i] == P[k], π[i] = k + 1 e k = k + 1; senão π[i] = 0 e k = 0.",
                                    "Anote a cadeia de backtracks (ex: i=5 em 'ababaca': k=3 → π[2]=1 → π[0]=0).",
                                    "Avance i e repita."
                                  ],
                                  "verification": "Simule backtrack completo e confirme π[i] correto (ex: π[5]=0).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para diagramas de backtrack",
                                    "Padrão 'ababaca'"
                                  ],
                                  "tips": [
                                    "Desenhe setas para cada backtrack k → π[k-1].",
                                    "Pratique com mismatch profundo."
                                  ],
                                  "learningObjective": "Executar corretamente o mecanismo de falha e backtrack da função π.",
                                  "commonMistakes": [
                                    "Interromper backtrack antes de k=0.",
                                    "Usar π[k] em vez de π[k-1].",
                                    "Confundir índices i e k."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar a tabela e validar propriedades",
                                  "subSteps": [
                                    "Continue o processo até i = m-1.",
                                    "Para cada π[i] > 0, verifique manualmente P[0..π[i]-1] == P[i-π[i]+1..i].",
                                    "Confirme propriedades: π[0]=0, π[i] ≤ i para todos i, consistência em backtracks.",
                                    "Teste com segundo padrão (ex: 'aabaaab' → [0,1,0,1,2,2,3]).",
                                    "Registre a tabela final completa."
                                  ],
                                  "verification": "Tabela 100% correta e verificada em pelo menos 3 posições.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Padrões 'ababaca' e 'aabaaab'"
                                  ],
                                  "tips": [
                                    "Verificação prefixo-sufixo reforça compreensão.",
                                    "Compare com implementação conhecida se disponível."
                                  ],
                                  "learningObjective": "Validar e finalizar a tabela π garantindo correção.",
                                  "commonMistakes": [
                                    "Pular verificação prefixo-sufixo.",
                                    "Erros de cópia nos valores finais.",
                                    "Ignorar π[i] > i."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o padrão 'ababaca' (m=7):\nπ = [0, 0, 1, 2, 3, 0, 1]\n\nPasso a passo:\n- i=1 (b), k=0: b ≠ a → π[1]=0, k=0\n- i=2 (a), k=0: a = a → π[2]=1, k=1\n- i=3 (b), k=1: b = b → π[3]=2, k=2\n- i=4 (a), k=2: a = a → π[4]=3, k=3\n- i=5 (c), k=3: c ≠ b → k=π[2]=1; c ≠ b → k=π[0]=0; c ≠ a → π[5]=0, k=0\n- i=6 (a), k=0: a = a → π[6]=1, k=1",
                              "finalVerifications": [
                                "π[0] = 0",
                                "Para todo i, π[i] ≤ i",
                                "Para cada π[i] > 0, P[0..π[i]-1] == P[i-π[i]+1..i]",
                                "Backtracks levam a valores consistentes (sem loops)",
                                "Tabela completa sem lacunas",
                                "Teste com pelo menos dois padrões diferentes"
                              ],
                              "assessmentCriteria": [
                                "Todos os valores de π calculados corretamente",
                                "Explicação clara de pelo menos um backtrack completo",
                                "Verificação manual de prefixo-sufixo em 3+ posições",
                                "Identificação correta de matches diretos vs. falhas",
                                "Tempo de execução manual eficiente e sem erros",
                                "Generalização para padrões semelhantes"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de strings finitas e funções border",
                                "Linguística Computacional: Detecção de padrões repetitivos em texto",
                                "Biologia Computacional: Alinhamento de sequências genéticas (DNA)",
                                "Engenharia de Software: Pré-processamento em algoritmos de busca otimizados"
                              ],
                              "realWorldApplication": "A tabela π é o coração do Algoritmo KMP para busca de padrões em textos grandes, usada em editores de texto (busca rápida Ctrl+F), motores de busca web, análise de logs de segurança, compressão de dados (ex: LZ77) e bioinformática para encontrar genes em genomas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Analisar complexidade do algoritmo",
                            "description": "Provar que a construção da tabela é O(m) argumentando que cada posição i é processada uma vez e os while loops amortizados avançam i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o algoritmo de construção da tabela de prefixos",
                                  "subSteps": [
                                    "Leia o pseudocódigo completo do algoritmo de KMP para construção da tabela π (prefix table).",
                                    "Identifique o loop principal: for i = 1 to m-1.",
                                    "Note as variáveis: length (comprimento do prefixo atual), π[i] = length.",
                                    "Entenda o while loop interno: while (length > 0 && pattern[i] != pattern[length]) length = π[length-1]."
                                  ],
                                  "verification": "Escreva o pseudocódigo de memória e explique verbalmente o fluxo para um colega.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Pseudocódigo do algoritmo KMP, editor de texto ou papel e caneta.",
                                  "tips": "Desenhe um diagrama de fluxo para visualizar os loops.",
                                  "learningObjective": "Compreender a estrutura exata do algoritmo para análise de complexidade.",
                                  "commonMistakes": "Confundir tabela π com a função de falha final; ignorar que i inicia em 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o loop principal e o processamento de cada posição i",
                                  "subSteps": [
                                    "Observe que o loop for executa exatamente m-1 vezes (uma por i de 1 a m-1).",
                                    "Para cada i, há uma comparação inicial: if pattern[i] == pattern[length].",
                                    "Se igual, length++ e π[i] = length; isso é O(1) por i.",
                                    "Argumente que cada i é 'visitado' exatamente uma vez no loop externo."
                                  ],
                                  "verification": "Conte manualmente o número de iterações do loop for em um exemplo com m=5.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplo de padrão curto (ex: 'AABAA'), calculadora para contar.",
                                  "tips": "Use um contador imaginário para cada entrada no loop for.",
                                  "learningObjective": "Provar que o custo do loop externo é Θ(m).",
                                  "commonMistakes": "Contar i de 0 a m-1 em vez de 1 a m-1; esquecer o -1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar os while loops internos e sua amortização",
                                  "subSteps": [
                                    "No while: cada iteração faz length = π[length-1], que diminui length.",
                                    "Note que length nunca aumenta no while; só diminui.",
                                    "Para cada i, o número de while pode ser até i, mas globalmente: cada decremento de length 'avança' para uma posição menor.",
                                    "Prove por potencial: total de execuções de while < m, pois cada posição é 'pulada' no máximo uma vez por decremento acumulado."
                                  ],
                                  "verification": "Simule o while em um exemplo e some o total de iterações de while sobre todos i.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Padrão com backtracks (ex: 'ABABAC'), tabela π pré-computada.",
                                  "tips": "Pense em 'length' como um ponteiro que só avança ou recua, mas recuos são pagos pelos avanços anteriores.",
                                  "learningObjective": "Entender análise amortizada para provar que while loops custam O(m) no total.",
                                  "commonMistakes": "Assumir pior caso por i é O(m), ignorando amortização global."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar custos e concluir a complexidade O(m)",
                                  "subSteps": [
                                    "Custo loop for: m vezes O(1) = O(m).",
                                    "Custo whiles: cada execução decrementa length, e length aumenta no máximo m vezes no total (ao longo de todo algoritmo).",
                                    "Assim, total whiles < m +1 = O(m).",
                                    "Outras operações (atribuições): O(1) por i ou whiles, total O(m).",
                                    "Escreva a prova formal: T(m) ≤ m + m = 2m = O(m)."
                                  ],
                                  "verification": "Escreva uma prova curta em 5 linhas e verifique se cobre todos os casos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para equações, referência de análise amortizada básica.",
                                  "tips": "Use o lemma: número total de decrementos ≤ número total de incrementos de length.",
                                  "learningObjective": "Formalizar a prova de linearidade da construção da tabela.",
                                  "commonMistakes": "Esquecer que incrementos de length são limitados a m."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com exemplo numérico e generalizar",
                                  "subSteps": [
                                    "Escolha padrão 'ABABAC' (m=6), construa π: [0,0,1,2,0,1].",
                                    "Conte operações: loop for 5x, whiles: total 3 execuções.",
                                    "Repita para padrões piores (ex: 'AAAAA'): π=[0,1,2,3,4], whiles=0.",
                                    "Generalize: para qualquer padrão, total ≤ 2m.",
                                    "Discuta por que não é O(m²)."
                                  ],
                                  "verification": "Implemente contador em pseudocódigo e rode para m=10.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Exemplos de padrões variados.",
                                  "tips": "Teste padrões repetitivos e com mismatches para ver amortização.",
                                  "learningObjective": "Aplicar a prova em prática e internalizar o argumento.",
                                  "commonMistakes": "Usar exemplo simples demais que esconde backtracks."
                                }
                              ],
                              "practicalExample": "Para o padrão 'ABABAC' (m=6):\n- i=1: A!=B, length=0 → π[1]=0 (0 while)\n- i=2: B==B, length=1 → π[2]=1 (0 while)\n- i=3: A==A, length=2 → π[3]=2 (0 while)\n- i=4: B!=A, while: length=1 (B==B? no), length=0 → π[4]=0 (2 whiles)\n- i=5: A==A, length=1 → π[5]=1 (0 while)\nTotal: 5 iterações for + 2 whiles = 7 ops < 2*6.",
                              "finalVerifications": [
                                "Explicar verbalmente por que cada i é processado uma vez.",
                                "Provar que total de whiles ≤ m.",
                                "Calcular ops para um padrão dado e confirmar < 2m.",
                                "Identificar onde length aumenta/decrementa em um trace.",
                                "Escrever prova em notação big-O.",
                                "Comparar com algoritmo ingênuo O(m²)."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação do loop principal como Θ(m).",
                                "Uso preciso de análise amortizada para whiles.",
                                "Exemplo prático com contagem exata de operações.",
                                "Prova formal concisa e sem falhas lógicas.",
                                "Reconhecimento de que todas operações são O(1) unitárias.",
                                "Generalização para qualquer padrão de tamanho m."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise amortizada e somas telescópicas.",
                                "Matemática Discreta: Relações de recorrência e invariantes.",
                                "Engenharia de Software: Otimização de algoritmos em prática.",
                                "Probabilidade: Análise média vs pior caso em strings aleatórias."
                              ],
                              "realWorldApplication": "Na busca eficiente de padrões em textos grandes (ex: Ctrl+F em editores como VS Code ou grep no Linux), onde pré-processar o padrão em O(m) permite buscas totais em O(n+m), essencial em genômica (busca de sequências DNA) e detecção de plágio em documentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.4",
                            "name": "Aplicar em contexto do KMP",
                            "description": "Explicar como a tabela de prefixos é usada na fase de busca do algoritmo KMP para saltos eficientes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Construção e Estrutura da Tabela de Prefixos",
                                  "subSteps": [
                                    "Relembre o algoritmo de construção da tabela de prefixos (π) para um padrão P, onde π[i] é o comprimento do maior prefixo próprio que é também sufixo da substring P[0..i].",
                                    "Calcule manualmente a tabela para um padrão simples como 'ABABABC'.",
                                    "Identifique os valores de π para cada posição e anote os possíveis 'saltos' implícitos (backtracks).",
                                    "Compare com uma tabela vazia para entender o impacto na eficiência.",
                                    "Desenhe um diagrama da tabela destacando bordas (border lengths)."
                                  ],
                                  "verification": "A tabela calculada coincide com implementações padrão (ex: para 'ABABABC', π = [0,0,1,2,3,0,1]).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, editor de texto para padrões, link para visualizador KMP online (ex: GeeksforGeeks).",
                                  "tips": "Sempre comece com π[0] = 0; use o valor de π[i-1] como ponto de partida para eficiência.",
                                  "learningObjective": "Compreender a tabela de prefixos como base para otimizações na busca.",
                                  "commonMistakes": "Confundir prefixo próprio com prefixo total; ignorar que π[i] < i+1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Fase de Busca Ingênua vs. Otimizada",
                                  "subSteps": [
                                    "Simule a busca ingênua em um texto T = 'ABABABCDABABABCABABABC' para padrão P = 'ABABABC', contando comparações.",
                                    "Identifique falhas de matching e backtracks manuais (ex: após mismatch, voltar ao início).",
                                    "Introduza a lógica KMP: ao mismatch em posição q, defina q = π[q-1] para salto eficiente.",
                                    "Compare o número de comparações: ingênua (~O(m*n)) vs. KMP (O(n+m)).",
                                    "Anote posições de salto usando a tabela."
                                  ],
                                  "verification": "Número de backtracks reduzidos corretamente em simulação manual.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado para alinhar T e P, calculadora para contar operações.",
                                  "tips": "Marque mismatches com 'X' e saltos com setas para visualização clara.",
                                  "learningObjective": "Diferenciar busca linear de busca otimizada com prefix table.",
                                  "commonMistakes": "Aplicar π incorretamente em mismatches parciais; confundir i (texto) com q (padrão)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular a Aplicação Completa da Tabela na Fase de Busca",
                                  "subSteps": [
                                    "Implemente pseudocódigo da fase de busca KMP: i=0, q=0; while i < n: if T[i]==P[q] then i++,q++; else if q>0 q=π[q-1] else i++; if q==m report match.",
                                    "Execute passo a passo no exemplo T e P, registrando estado de q e i a cada iteração.",
                                    "Identifique e explique saltos: ex: mismatch em 'D' vs 'A', q volta para π[2]=1.",
                                    "Repita com múltiplos matches/ocorrências sobrepostas.",
                                    "Meça eficiência: total de operações < len(T) + len(P)."
                                  ],
                                  "verification": "Simulação encontra todas ocorrências corretas sem backtrack excessivo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Pseudocódigo impresso, planilha Excel para rastrear i/q, código Python simples para validar.",
                                  "tips": "Use uma tabela de estados com colunas i, T[i], q, P[q], ação, π usada.",
                                  "learningObjective": "Executar a fase de busca KMP usando a tabela para saltos.",
                                  "commonMistakes": "Não resetar q=0 quando q==0 em mismatch; ignorar matches sobrepostos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Generalizar a Eficiência dos Saltos",
                                  "subSteps": [
                                    "Calcule complexidade: prove que cada iteração avança i ou reduz q, total O(n+m).",
                                    "Teste com padrões ruins (ex: 'AAAAA' em 'AAAAAAAA'), mostrando saltos longos.",
                                    "Compare com Rabin-Karp ou Boyer-Moore para contexto.",
                                    "Crie variação: aplique em texto com ruído e múltiplos padrões.",
                                    "Documente lições: tabela evita reescaneio desnecessário."
                                  ],
                                  "verification": "Análise escrita explica por que KMP é linear e saltos evitam O(n*m).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico de comparações vs. tamanho, referências teóricas (CLRS livro).",
                                  "tips": "Pense em autômato de string: π define transições de falha.",
                                  "learningObjective": "Generalizar uso da tabela para eficiência em qualquer padrão/texto.",
                                  "commonMistakes": "Superestimar complexidade; confundir construção π (O(m)) com busca (O(n))."
                                }
                              ],
                              "practicalExample": "Dado texto T = 'ABABABCDABABABCABABABC' e padrão P = 'ABABABC', a tabela π = [0,0,1,2,3,0,1]. Na busca, após match parcial 'ABABA' (q=5), mismatch 'D'!='B', q=π[4]=3 (salto para 'ABA'), evitando recomeço do zero. Encontra match em posição 11.",
                              "finalVerifications": [
                                "Explicar verbalmente como π[q-1] determina o salto em mismatch.",
                                "Simular KMP completo em novo exemplo sem erros.",
                                "Comparar número de operações KMP vs. ingênuo (>20% redução).",
                                "Identificar matches sobrepostos corretamente.",
                                "Implementar pseudocódigo funcional.",
                                "Analisar caso de pior cenário (padrão periódico)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de π para saltos (100% correto).",
                                "Compreensão conceitual: explicar 'por quê' dos saltos (rubrica 1-5).",
                                "Eficiência demonstrada em simulações (contagem exata de ops).",
                                "Generalização para novos padrões/textos.",
                                "Clareza em diagramas e rastreamento de estados.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos Finitos e linguagens regulares.",
                                "Biologia Computacional: Matching de sequências de DNA/RNA.",
                                "Engenharia de Software: Otimização em editores de texto (busca e substituição).",
                                "Física: Processamento de sinais (padrões em ondas).",
                                "Linguística: Análise de padrões em corpora textuais."
                              ],
                              "realWorldApplication": "Em motores de busca como Google ou editores como VS Code para find/replace eficiente em arquivos grandes; em bioinformática para alinhamento de sequências genéticas (ex: BLAST usa ideias similares); em compiladores para scanning léxico rápido."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Algoritmo Rabin-Karp",
                    "description": "Técnica baseada em hashing para comparar fingerprints do padrão e texto.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Hashing em Strings",
                        "description": "Representação numérica de substrings do texto e do padrão por meio de funções hash polinomiais para permitir comparações eficientes.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Calcular hash de uma string estática",
                            "description": "Implementar a função hash para uma string fixa de comprimento m, utilizando a fórmula h(P) = (P[0]*b^{m-1} + P[1]*b^{m-2} + ... + P[m-1]) mod q, onde b é a base, q é um primo grande e caracteres são mapeados para números.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros e mapear a string para números",
                                  "subSteps": [
                                    "Escolha uma string estática P de comprimento m (ex: 'abc', m=3).",
                                    "Defina a base b (tipicamente 31 ou 256) e um primo grande q (ex: 101 para testes simples).",
                                    "Mapeie cada caractere P[i] para um número inteiro: use ord(P[i]) ou mapeamento simples como 'a'=1, 'b'=2, etc.",
                                    "Crie um array numérico com os valores mapeados.",
                                    "Verifique se todos os caracteres foram mapeados corretamente."
                                  ],
                                  "verification": "Confirme que o array de números corresponde à string original e que b e q são apropriados (q primo maior que valores possíveis).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de código (Python/Jupyter)",
                                    "Tabela ASCII ou alfabeto para mapeamento"
                                  ],
                                  "tips": "Use mapeamento 'a'=0 para simplificar cálculos iniciais; evite q muito pequeno para evitar colisões prematuras.",
                                  "learningObjective": "Entender como representar strings como sequências numéricas para hashing.",
                                  "commonMistakes": [
                                    "Mapear incorretamente caracteres maiúsculos/minúsculos",
                                    "Escolher b=1 ou q não primo",
                                    "Ignorar o comprimento m"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as potências de b necessárias",
                                  "subSteps": [
                                    "Inicialize uma lista de potências: b^0 = 1.",
                                    "Calcule iterativamente b^{k} para k de 1 a m-1: potência[k] = potência[k-1] * b.",
                                    "Aplique módulo q em cada potência para evitar overflow: potência[k] = (potência[k-1] * b) % q.",
                                    "Liste todas as potências de b^{m-1} até b^0.",
                                    "Verifique as potências com um exemplo pequeno (ex: b=2, m=3: 4,2,1)."
                                  ],
                                  "verification": "As potências devem satisfazer potência[k] = (b * potência[k-1]) % q e potência[0]=1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou código Python para pow(b, k, q)",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Use função pow(b, exp, q) em Python para eficiência; calcule do maior para o menor expoente.",
                                  "learningObjective": "Dominar cálculo eficiente de potências modulares para evitar números grandes.",
                                  "commonMistakes": [
                                    "Esquecer o módulo q nas potências intermediárias",
                                    "Confundir ordem das potências (b^{m-1} para P[0])",
                                    "Overflow em cálculos manuais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a soma ponderada e aplicar módulo final",
                                  "subSteps": [
                                    "Inicialize hash_value = 0.",
                                    "Para cada i de 0 a m-1: adicione (P_num[i] * potência[m-1-i]) % q à hash_value.",
                                    "Aplique módulo q após cada adição: hash_value = (hash_value + termo) % q.",
                                    "Continue até processar todos os caracteres.",
                                    "Retorne o hash_value final."
                                  ],
                                  "verification": "Calcule manualmente para string pequena e compare com implementação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código para protótipo",
                                    "Exemplo de string fixa para teste"
                                  ],
                                  "tips": "Implemente em loop for reverso para clareza; teste com string de 1 caractere (deve ser P[0] % q).",
                                  "learningObjective": "Implementar o polinômio hash corretamente com multiplicações ponderadas.",
                                  "commonMistakes": [
                                    "Índice errado nas potências (usar i em vez de m-1-i)",
                                    "Esquecer % q na soma",
                                    "Soma sem módulo levando a overflow"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar a função completa",
                                  "subSteps": [
                                    "Escreva uma função def hash_string(P, b, q): que retorna o hash.",
                                    "Teste com string 'abc', b=31, q=101 (esperado: calcular e validar).",
                                    "Teste casos edge: string vazia (0), m=1, caracteres repetidos.",
                                    "Compare hashes de strings diferentes para verificar distinção.",
                                    "Documente a função com comentários."
                                  ],
                                  "verification": "Função retorna hash correto para múltiplos testes; sem erros de runtime.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python ou pseudocódigo",
                                    "Unidade de teste simples"
                                  ],
                                  "tips": "Use assert para testes automáticos; imprima passos intermediários para debug.",
                                  "learningObjective": "Criar uma função reutilizável e testável para hashing.",
                                  "commonMistakes": [
                                    "Função não lida com m=0",
                                    "Hardcode valores em vez de parâmetros",
                                    "Ignorar casos com caracteres não alfabéticos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para P='abc' (mapeado como [0,1,2]), b=31, q=101: potências [31^2=961%101=61, 31%101=31, 1]; hash = ((0*61 + 1*31 + 2*1) % 101) = 33.",
                              "finalVerifications": [
                                "Hash calculado manualmente bate com a função implementada.",
                                "Potências mod q estão corretas para m até 10.",
                                "Função lida com strings de diferentes comprimentos sem erro.",
                                "Hashes distinguem 'abc' de 'abd'.",
                                "Nenhum overflow ou erro numérico em q grande (10^9+7).",
                                "Tempo de execução é O(m) linear."
                              ],
                              "assessmentCriteria": [
                                "Correção: hash matches fórmula exata.",
                                "Eficiência: Usa módulo em cada passo para evitar overflow.",
                                "Robustez: Trata edge cases (m=0,1).",
                                "Clareza: Código comentado e legível.",
                                "Precisão: Mapeamento de chars consistente.",
                                "Testes: Pelo menos 3 testes válidos incluídos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e polinômios.",
                                "Criptografia: Bases de funções hash como SHA.",
                                "Análise de Algoritmos: Complexidade O(m) pré-processamento.",
                                "Linguagens: Manipulação de strings em programação."
                              ],
                              "realWorldApplication": "Pré-computação de hashes em algoritmos de busca como Rabin-Karp para detecção de plágio, busca em texto ou detecção de padrões em DNA/sequências genéticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Escolha de parâmetros de hash",
                            "description": "Selecionar base b (tipicamente 256 para ASCII) e módulo q (primo de 64 bits) para minimizar colisões, considerando propriedades matemáticas como q > |Σ|^m.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel dos parâmetros b e q no hashing Rabin-Karp",
                                  "subSteps": [
                                    "Estude a fórmula do hash de uma string: h = s[0]*b^{m-1} + s[1]*b^{m-2} + ... + s[m-1]*b^0 mod q",
                                    "Identifique b como a base (representa o 'place value' como em números decimais)",
                                    "Explique q como o módulo para manter hashes em um range finito e reduzir colisões",
                                    "Analise por que colisões ocorrem e como b e q influenciam a probabilidade (aprox. 1/q)",
                                    "Revise propriedades: q deve ser primo para uniformidade, b coprimo com q"
                                  ],
                                  "verification": "Resuma em 3 frases o impacto de b e q em colisões; confira com documentação Rabin-Karp",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Rabin-Karp (Wikipedia ou CLRS)",
                                    "Notebook Jupyter para fórmulas"
                                  ],
                                  "tips": "Visualize b como 'potências de 10' em números; teste com string pequena manualmente",
                                  "learningObjective": "Entender matematicamente como b e q afetam a função hash e colisões",
                                  "commonMistakes": [
                                    "Confundir b com alfabeto size",
                                    "Ignorar que q primo evita ciclos ruins",
                                    "Achar que maior q sempre melhor (overhead computacional)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar a base b adequada ao alfabeto",
                                  "subSteps": [
                                    "Determine o tamanho do alfabeto |Σ| (ex: 256 para ASCII estendido)",
                                    "Escolha b = |Σ| ou b = |Σ| + 1 para representar caracteres unicamente",
                                    "Verifique que b e q sejam coprimos (gcd(b, q) = 1)",
                                    "Considere b primo para melhor distribuição, mas 256 é prático para ASCII",
                                    "Calcule potências b^k mod q pré-computadas para eficiência"
                                  ],
                                  "verification": "Para Σ=256, justifique b=256 e compute gcd(256, q_exemplo)=1",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora modular online (Wolfram Alpha)",
                                    "Lista de primos pequenos"
                                  ],
                                  "tips": "Use b=131 ou 37 para texto inglês se |Σ| pequeno; evite b=1 ou b=0",
                                  "learningObjective": "Selecionar b otimizado para o alfabeto e comprimento de padrões",
                                  "commonMistakes": [
                                    "Escolher b < |Σ| (perda de info)",
                                    "b muito grande (overflow rápido)",
                                    "Não checar coprimalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escolher o módulo q primo de 64 bits",
                                  "subSteps": [
                                    "Selecione q primo próximo de 2^64 para maximizar range sem overflow uint64",
                                    "Garanta q > |Σ|^m para m máximo de padrões (ex: q > 256^100 usa q~10^18)",
                                    "Escolha primos comuns: 10^9+7, 10^9+9, 2^64-59 (para mod nativo)",
                                    "Teste primalidade com Miller-Rabin ou listas pré-geradas",
                                    "Avalie trade-off: q maior = menos colisões, mas mais computação"
                                  ],
                                  "verification": "Encontre 3 primos de 64 bits e verifique q > 256^50 com logaritmos",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de primos grandes (NIST ou Python sympy.isprime)",
                                    "Calculadora log10 para |Σ|^m"
                                  ],
                                  "tips": "Use q=2^61-1 (Mersenne primo) para mod rápido; double-hash com 2 q's",
                                  "learningObjective": "Escolher q que minimiza colisões via propriedades primas e tamanho",
                                  "commonMistakes": [
                                    "q não primo (bias em resíduos)",
                                    "q pequeno (muitas colisões)",
                                    "Ignorar overflow em computação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar parâmetros e minimizar colisões",
                                  "subSteps": [
                                    "Simule hashes para strings sem colisão (ex: 'abc' vs 'abd')",
                                    "Calcule probabilidade de colisão falsa: ~m*n / q para textos T e P",
                                    "Ajuste se P(colisão) > 0.01: aumente q ou use double hashing",
                                    "Teste com dataset real: strings aleatórias e verifique falsos positivos",
                                    "Documente escolha: b=256, q=10^9+7 para m<=100"
                                  ],
                                  "verification": "Rode simulação com 1000 strings; taxa colisão <1%",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python script Rabin-Karp",
                                    "Dataset strings (Lorem Ipsum gerado)"
                                  ],
                                  "tips": "Double hash: 2 funções independentes, colisão só se ambas",
                                  "learningObjective": "Validar empiricamente parâmetros para cenários reais",
                                  "commonMistakes": [
                                    "Não testar com worst-case (strings repetitivas)",
                                    "Assumir teoria basta sem simulação",
                                    "Esquecer pré-computar h e powers"
                                  ]
                                }
                              ],
                              "practicalExample": "Para busca de padrão 'algorithm' em texto ASCII de 1MB (m=9, |Σ|=256), escolha b=256, q=1000000007 (primo 30 bits, mas escale para 2^64-59). Compute hash inicial: ord('a')*256^8 + ... mod q. Rolling: subtraia s[0]*256^9, multiplique por 256, adicione novo char. Teste: sem colisões em 10k matches simulados.",
                              "finalVerifications": [
                                "Explica fórmula hash e papel de b/q",
                                "Justifica b=256 para ASCII e coprimalidade",
                                "Seleciona q primo > |Σ|^m com exemplo numérico",
                                "Calcula P(colisão) < 10^-6 para caso dado",
                                "Propõe double hashing se necessário",
                                "Simula rolling hash manual para string curta"
                              ],
                              "assessmentCriteria": [
                                "Precisão na escolha de b baseado em |Σ| (100%)",
                                "Correta identificação de q primo e tamanho adequado (90-100%)",
                                "Compreensão de colisões e validação (85%+)",
                                "Uso de propriedades matemáticas (gcd, >|Σ|^m)",
                                "Eficiência prática (tempo computacional considerado)",
                                "Criatividade em exemplos e simulações"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular, teoria dos números (primos, gcd)",
                                "Estatística: Probabilidade de colisões, análise de birthday paradox",
                                "Criptografia: Funções hash seguras (SHA vs rolling)",
                                "Análise de Algoritmos: Big-O de Rabin-Karp O(n+m)",
                                "Engenharia de Software: Otimização de parâmetros em bibliotecas (ex: Python hashlib)"
                              ],
                              "realWorldApplication": "Em motores de busca como Google (indexação rápida), detecção de plágio em ferramentas educacionais (Turnitin), compiladores para busca de substrings em código fonte, e bioinformática para matching de sequências DNA."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Comparar fingerprints",
                            "description": "Verificar se o hash do padrão é igual ao hash de uma substring do texto, reconhecendo que igualdade de hashes indica possível match (com risco de colisão).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Fingerprint em Hashing de Strings",
                                  "subSteps": [
                                    "Defina fingerprint como uma representação numérica compacta (hash) de uma string.",
                                    "Explique que hashes permitem comparações rápidas sem comparar caracteres individualmente.",
                                    "Discuta colisões: hashes iguais não garantem strings iguais, mas indicam candidatos a verificação exata."
                                  ],
                                  "verification": "Resuma em 2-3 frases o papel dos fingerprints na detecção de padrões e o risco de colisão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação do algoritmo Rabin-Karp",
                                    "Exemplos de funções hash simples"
                                  ],
                                  "tips": "Pense nos fingerprints como 'impressões digitais' resumidas: rápidas para comparar, mas verifique o original se baterem.",
                                  "learningObjective": "Entender o propósito dos fingerprints e suas limitações inerentes.",
                                  "commonMistakes": [
                                    "Confundir igualdade de hash com igualdade de string.",
                                    "Ignorar completamente o risco de colisões."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Fingerprint do Padrão",
                                  "subSteps": [
                                    "Converta caracteres do padrão em valores numéricos (ex: 'a'=1, 'b'=2, etc.).",
                                    "Escolha base b (ex: 31) e módulo M (ex: 10^9+7) para evitar overflow.",
                                    "Calcule hash h = ((s[0]*b^{m-1} + s[1]*b^{m-2} + ... + s[m-1]*b^0) mod M), onde m é o comprimento do padrão."
                                  ],
                                  "verification": "Calcule manualmente o hash de um padrão exemplo como 'abc' e confira com uma calculadora.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou planilha para potências"
                                  ],
                                  "tips": "Pré-calcule potências de b para facilitar cálculos manuais.",
                                  "learningObjective": "Dominar o cálculo polinomial do hash para o padrão fixo.",
                                  "commonMistakes": [
                                    "Esquecer de aplicar o módulo M após cada operação.",
                                    "Usar índices errados nas potências (começar de b^0 no final)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar Fingerprints de Substrings no Texto com Rolling Hash",
                                  "subSteps": [
                                    "Para a primeira substring de tamanho m: calcule hash como no padrão.",
                                    "Pré-compute p = b^m mod M para rolling.",
                                    "Para substrings subsequentes: h_novo = (h_antigo - s[i]*p) * b + s[i+m] mod M."
                                  ],
                                  "verification": "Compute hashes para as 3 primeiras janelas de um texto exemplo e liste-os.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de texto longo e padrão",
                                    "Simulador online de rolling hash (opcional)"
                                  ],
                                  "tips": "Sempre aplique mod M após subtração para manter valores positivos.",
                                  "learningObjective": "Implementar eficientemente o rolling hash para escanear o texto inteiro.",
                                  "commonMistakes": [
                                    "Subtrair sem multiplicar por b depois.",
                                    "Overflow numérico sem módulo adequado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Fingerprints e Lidar com Colisões",
                                  "subSteps": [
                                    "Compare hash do padrão com hash de cada substring: se iguais, marque como match candidato.",
                                    "Para candidatos, compare as strings caractere por caractere para confirmar.",
                                    "Analise probabilidade de colisão: com M grande (64-bit), risco é baixo (~1/M)."
                                  ],
                                  "verification": "Em um exemplo com colisão artificial, identifique o match verdadeiro e o falso positivo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python simples para Rabin-Karp",
                                    "Exemplos com colisões conhecidas"
                                  ],
                                  "tips": "A verificação exata é crucial: hashes são filtros, não decisores finais.",
                                  "learningObjective": "Aplicar comparação de hashes corretamente, sempre com verificação verbatim em matches.",
                                  "commonMistakes": [
                                    "Tratar hash igual como match definitivo sem verificação.",
                                    "Escolher M muito pequeno, aumentando colisões."
                                  ]
                                }
                              ],
                              "practicalExample": "Padrão P='AB' (A=1,B=2), base b=10, M=13. Hash P=(1*10 + 2) mod 13=12. Texto T='XABCD' (X=24,A=1,B=2,C=3,D=4). Janela1 'XA':(24*10+1)=241 mod13=7. Janela2 'AB':12. Igual! Verifique strings: 'AB'=='AB' → match real. Janela3 'BC':(2*10+3)=23 mod13=10.",
                              "finalVerifications": [
                                "Explica o risco de colisão e por que verificar strings verbatim.",
                                "Calcula hashes corretamente para padrão e 3+ janelas.",
                                "Implementa rolling hash sem erros aritméticos.",
                                "Identifica matches candidatos e confirma com comparação direta.",
                                "Discute impacto de escolha de b e M na precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de hash e rolling (obrigatório).",
                                "Compreensão clara de colisões demonstrada em exemplos.",
                                "Eficiência reconhecida: O(M) pré-processamento + O(N) escaneamento.",
                                "Verificação verbatim aplicada corretamente em todos candidatos.",
                                "Exemplos práticos fornecidos sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e avaliação de polinômios.",
                                "Criptografia: Conceitos de funções hash e ataques de colisão.",
                                "Processamento de Dados: Indexação e busca em grandes corpora de texto.",
                                "Estatística: Probabilidades de falsos positivos em hashing."
                              ],
                              "realWorldApplication": "Em motores de busca como Google para detectar páginas duplicadas, ferramentas anti-plágio como Turnitin para comparar trechos de documentos, e compiladores/edi tores para busca e substituição eficiente em código fonte."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Rolling Hash",
                        "description": "Técnica para computar hashes de substrings sobrepostas do texto em tempo O(1) por posição, evitando recálculo completo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Pré-computar hash inicial do texto",
                            "description": "Calcular o hash da primeira janela de comprimento m no texto T usando a mesma fórmula do padrão, em O(n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Parâmetros Iniciais do Rolling Hash",
                                  "subSteps": [
                                    "Identifique o comprimento m do padrão.",
                                    "Selecione uma base b (ex: primo como 31 ou 256) e um módulo p (primo grande como 10^9+7).",
                                    "Converta os primeiros m caracteres do texto T em valores numéricos usando ord(c) ou mapeamento simples.",
                                    "Prepare um array ou lista com os valores numéricos dos caracteres T[0] a T[m-1].",
                                    "Anote os valores para referência futura."
                                  ],
                                  "verification": "Lista de parâmetros (m, b, p, T_num[0..m-1]) está completa e correta.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (Python recomendado)",
                                    "Papel e caneta para anotações",
                                    "Calculadora para testes modulares"
                                  ],
                                  "tips": "Escolha b próximo ao tamanho do alfabeto para boa distribuição; p deve ser maior que possíveis hashes para evitar overflow imediato.",
                                  "learningObjective": "Compreender e preparar os componentes fundamentais para o cálculo eficiente do hash inicial.",
                                  "commonMistakes": [
                                    "Escolher b ou p muito pequenos levando a colisões frequentes",
                                    "Erro na conversão de caracteres para números (ex: esquecer ASCII offset)",
                                    "Usar m incorreto baseado no padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a Variável de Hash",
                                  "subSteps": [
                                    "Defina hash_value = 0.",
                                    "Entenda que o cálculo iterativo simula o polinômio horner: ((T[0]*b + T[1])*b + T[2]) ...",
                                    "Prepare uma variável para rastrear passos intermediários (opcional para debug).",
                                    "Confirme que o índice inicia em 0 da janela.",
                                    "Teste inicial: hash_value * b + T[0] deve ser o primeiro valor."
                                  ],
                                  "verification": "hash_value inicial é 0 e primeira iteração produz T[0] % p.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Código Python ou pseudocódigo",
                                    "Exemplo de texto simples"
                                  ],
                                  "tips": "Sempre use inteiros grandes ou BigInt em linguagens para evitar overflow antes do mod.",
                                  "learningObjective": "Dominar a inicialização correta que permite iterações eficientes em O(1) por caractere.",
                                  "commonMistakes": [
                                    "Inicializar hash com T[0] em vez de 0",
                                    "Esquecer de aplicar %p na primeira iteração",
                                    "Confundir ordem MSB/LSB"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o Loop Iterativo para Cálculo do Hash",
                                  "subSteps": [
                                    "Inicie um loop for i de 0 até m-1.",
                                    "Em cada iteração: hash_value = (hash_value * b + T_num[i]) % p.",
                                    "Registre o valor de hash_value após cada iteração para verificação.",
                                    "Garanta que todas operações sejam feitas com multiplicação antes da adição e mod final.",
                                    "Saia do loop com hash_value final."
                                  ],
                                  "verification": "Hash final matches cálculo manual polinomial expandido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Implementação em Python",
                                    "Exemplo numérico anotado"
                                  ],
                                  "tips": "Implemente em código para automatizar; imprima intermediários para debug.",
                                  "learningObjective": "Implementar o núcleo do pré-computo em O(m) tempo usando método de Horner otimizado.",
                                  "commonMistakes": [
                                    "Aplicar mod após adição mas antes de multiplicação",
                                    "Índice off-by-one no loop",
                                    "Overflow sem mod intermediário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Armazenar o Hash Inicial",
                                  "subSteps": [
                                    "Calcule o hash via fórmula polinomial direta: sum T[i] * b^(m-1-i) % p para comparar.",
                                    "Compare o resultado iterativo com o direto; devem ser iguais.",
                                    "Armazene hash_inicial para uso no Rabin-Karp subsequente.",
                                    "Teste com um segundo exemplo pequeno para confirmação.",
                                    "Documente o processo para rolling hash futuro."
                                  ],
                                  "verification": "Hashes iterativo e direto coincidem; código roda sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código com função de verificação dupla",
                                    "Dois exemplos de teste"
                                  ],
                                  "tips": "Use asserts em código para automação de verificações.",
                                  "learningObjective": "Validar a correção do algoritmo e prepará-lo para extensões como rolling hash.",
                                  "commonMistakes": [
                                    "Erro em potência b^(m-1-i) na verificação direta",
                                    "Ignorar mod p na comparação",
                                    "Não testar com m=1"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto T='abc' (a=1, b=2, c=3), m=3, b=5, p=11. Inicial: hash=0. i=0: (0*5+1)%11=1. i=1: (1*5+2)%11=7. i=2: (7*5+3)%11=38%11=5. Verificação polinomial: 1*25 + 2*5 + 3*1 =38%11=5. Hash inicial=5.",
                              "finalVerifications": [
                                "Hash inicial calculado corretamente via iterativo e matches polinomial.",
                                "Tempo de execução é O(m) confirmado por medição.",
                                "Nenhum overflow ou erro modular detectado.",
                                "Hash pode ser usado para comparação inicial com hash do padrão.",
                                "Código lida com diferentes tamanhos de m e textos.",
                                "Testes com edge cases (m=1, m=n) passam."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Hash correto em todos testes (100%).",
                                "Eficiência: Implementação O(m) sem loops desnecessários.",
                                "Robustez: Trata overflow e mods corretamente.",
                                "Clareza: Código comentado com passos intermediários.",
                                "Verificação: Inclui dupla checagem (iterativo vs. direto).",
                                "Generalidade: Funciona para qualquer T, m, b, p válidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e método de Horner para polinômios.",
                                "Criptografia: Conceitos básicos de funções hash e rolling hashes em blockchain.",
                                "Processamento de Dados: Pré-processamento em big data e string matching.",
                                "Programação: Otimização de loops e manipulação numérica em linguagens."
                              ],
                              "realWorldApplication": "Pré-computar o hash inicial é crucial no algoritmo Rabin-Karp para buscas rápidas de padrões em textos massivos, como indexação em motores de busca (Google), detecção de plágio em documentos acadêmicos ou detecção de intrusão em logs de rede."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Atualizar hash rolante",
                            "description": "Atualizar o hash da janela seguinte removendo o caractere que sai (multiplicando por b e subtraindo) e adicionando o novo caractere, tudo mod q, em O(1) por passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a fórmula do hash rolante inicial",
                                  "subSteps": [
                                    "Represente o hash da janela atual como H = s[i]*b^{k-1} + s[i+1]*b^{k-2} + ... + s[i+k-1]*b^0 mod q, onde k é o tamanho da janela.",
                                    "Precalcule o valor de b^{k-1} mod q para uso eficiente na remoção.",
                                    "Mapeie os caracteres da string para valores numéricos (ex: 'A'=1, 'B'=2).",
                                    "Calcule o hash inicial manualmente para uma janela de exemplo.",
                                    "Verifique o hash inicial comparando com cálculo polinomial direto."
                                  ],
                                  "verification": "O hash calculado manualmente coincide com a fórmula polinomial mod q.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de código para cálculos; tabela de potências de b mod q.",
                                  "tips": "Use uma base b pequena (ex: 31 ou 10) para facilitar cálculos iniciais.",
                                  "learningObjective": "Entender a representação polinomial do hash para manipulação eficiente.",
                                  "commonMistakes": "Esquecer o módulo q no cálculo das potências ou mapear chars incorretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Remover o caractere de saída da janela",
                                  "subSteps": [
                                    "Subtraia o termo do caractere de saída: temp = H - s[i] * b^{k-1} mod q.",
                                    "Ajuste para negativo: se temp < 0, adicione q até positivo.",
                                    "Multiplique pelo fator de rolagem: new_H = temp * b mod q.",
                                    "Registre o índice i atual e avance i = i+1.",
                                    "Confirme que a subtração preserva o valor modular."
                                  ],
                                  "verification": "O new_H representa corretamente o hash sem o primeiro caractere, multiplicado por b.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora modular ou código Python para verificação; string de exemplo.",
                                  "tips": "Precalcule b^{k-1} uma única vez para toda a execução.",
                                  "learningObjective": "Dominar a remoção do caractere mais antigo em O(1) usando aritmética modular.",
                                  "commonMistakes": "Não tratar valores negativos após subtração ou esquecer o módulo após multiplicação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar o novo caractere à janela",
                                  "subSteps": [
                                    "Identifique o novo caractere s[i+k-1].",
                                    "Adicione ao hash: H = new_H + s[i+k-1] * b^0 mod q.",
                                    "Aplique o módulo q imediatamente após a adição.",
                                    "Atualize o índice da janela para a posição seguinte.",
                                    "Compare o novo hash com cálculo direto da janela atualizada."
                                  ],
                                  "verification": "O hash finalizado é idêntico ao hash recalculado da nova janela do zero.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesma string de exemplo; função auxiliar para hash naive.",
                                  "tips": "Sempre aplique mod q em cada operação para evitar overflow.",
                                  "learningObjective": "Implementar a adição do caractere entrante mantendo O(1).",
                                  "commonMistakes": "Usar potência errada para o novo caractere (sempre b^0=1) ou pular o módulo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e otimizar o processo completo",
                                  "subSteps": [
                                    "Execute o ciclo de atualização para 3-5 janelas consecutivas.",
                                    "Compare todos os hashes rolantes com hashes naive independentes.",
                                    "Meça o tempo de execução para confirmar O(1) por passo.",
                                    "Teste com diferentes bases b e módulos q primos.",
                                    "Documente os valores pré-calculados necessários."
                                  ],
                                  "verification": "Todos os hashes rolantes coincidem com cálculos independentes e o tempo é constante.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código de teste em Python ou C++; strings variadas de comprimento 10-50.",
                                  "tips": "Escolha q como primo grande para reduzir colisões.",
                                  "learningObjective": "Validar a corretude e eficiência do rolling hash em sequência.",
                                  "commonMistakes": "Overflow em linguagens sem bigints; não pré-calcular potências."
                                }
                              ],
                              "practicalExample": "Considere a string S = \"AABAB\", k=3, b=10, q=13, chars A=1, B=2. Hash inicial para \"AAB\": (1*100 + 1*10 + 2*1) mod 13 = 112 mod 13 = 6. Próxima janela \"ABA\": temp = 6 - 1*100 mod 13 = 6 - 9 = -3 +13=10; new_H=10*10 mod13=100 mod13=9; +2=11 mod13=11. Verifique: 1*100+2*10+1=121 mod13=4? Espere, ajuste exemplo: use b=31, mas simplificado em código.",
                              "finalVerifications": [
                                "Hashes rolantes coincidem com hashes naive para todas as janelas.",
                                "Cada atualização leva O(1) tempo, sem dependência de k.",
                                "Nenhum overflow ou erro modular em testes com strings longas.",
                                "Funciona com múltiplas bases b e q primos.",
                                "Pré-cálculo de b^{k-1} é usado corretamente.",
                                "Tratamento de valores negativos é robusto."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% de hashes idênticos aos naive.",
                                "Eficiência: Tempo por passo constante, independente de k.",
                                "Robustez: Funciona sem erros para q primo > |alfabeto|*k.",
                                "Clareza: Código comentado explicando cada operação modular.",
                                "Testes: Pelo menos 5 strings variadas com k=3-10.",
                                "Otimização: Pré-cálculo de potências expostas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e propriedades de congruências.",
                                "Programação: Otimização de algoritmos com pré-processamento.",
                                "Criptografia: Fundamentos de funções hash e rolling hashes em assinaturas digitais.",
                                "Biologia Computacional: Busca de padrões em sequências de DNA."
                              ],
                              "realWorldApplication": "Usado no algoritmo Rabin-Karp para busca eficiente de padrões em textos grandes, como detecção de plágio em documentos, busca em motores de busca (Google), matching de sequências genéticas em bioinformática e compiladores para análise léxica rápida."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Gerenciar overflow em rolling hash",
                            "description": "Implementar operações modulares corretas para evitar overflow em linguagens como C++ ou Java, usando tipos de 128 bits ou BigInteger.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Overflow em Rolling Hash",
                                  "subSteps": [
                                    "Estude o algoritmo Rabin-Karp e o conceito de rolling hash, focando na fórmula de hash: h = (h * base + s[i]) % mod.",
                                    "Identifique onde overflow ocorre: multiplicação h * base pode exceder 64 bits em strings longas.",
                                    "Analise exemplos numéricos: calcule hash manualmente para string 'abcde' com base=31, mod=10^9+7, mostrando overflow em int64.",
                                    "Compare linguagens: C++ usa uint64_t suscetível a wrap-around; Java usa long com risco similar.",
                                    "Revise aritmética modular: propriedades como (a*b) % m = [(a%m)*(b%m)] % m, mas ineficiente sem tipos grandes."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo causas de overflow e riscos (ex: falsos positivos/negativos em matches).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação Rabin-Karp (GeeksforGeeks ou CLRS), calculadora ou Python para simulações numéricas.",
                                  "tips": "Use papel e lápis para cálculos manuais de hash em strings curtas para visualizar overflow.",
                                  "learningObjective": "Explicar precisamente como e por que overflow afeta rolling hash em implementações padrão.",
                                  "commonMistakes": "Confundir overflow com wrap-around int64 (que não é modular correto); ignorar impacto em matches."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Configurar Tipos de Dados de Alta Precisão",
                                  "subSteps": [
                                    "Em C++: Inclua <boost/multiprecision/cpp_int.hpp> ou use __int128; defina hash como __int128.",
                                    "Em Java: Importe java.math.BigInteger; inicialize hash como BigInteger.ZERO.",
                                    "Escolha módulo primo grande (ex: 2^64 para C++ implícito, ou 10^9+7 explícito).",
                                    "Configure base (primo como 29,31,37) como constante de alta precisão.",
                                    "Implemente funções auxiliares: mul_mod(a,b,mod) usando tipos grandes antes de % mod.",
                                    "Teste inicial: Compile/crie código snippet multiplicando dois números grandes sem overflow."
                                  ],
                                  "verification": "Execute snippet que multiplica 2^60 * 2^60 e aplica % mod, confirmando resultado correto vs int64.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador C++ (g++ com -std=c++17), IDE Java (IntelliJ/Eclipse), docs __int128 e BigInteger.",
                                  "tips": "Em C++, caste para __int128 em operações: (__int128)a * b % mod; evite casting desnecessário.",
                                  "learningObjective": "Configurar tipos de 128 bits ou BigInteger para operações seguras em rolling hash.",
                                  "commonMistakes": "Usar uint64_t com casting incorreto; esquecer de reduzir mod após cada operação em BigInteger."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Rolling Hash com Operações Modulares Seguras",
                                  "subSteps": [
                                    "Escreva função de pré-computação: powers[0]=1, powers[i]=powers[i-1]*base % mod.",
                                    "Implemente hash forward: para cada char, hash = (hash * base + ord(s[i])) % mod usando tipos grandes.",
                                    "Adicione rolling: para janela deslizante, hash = (hash - s[i-len]*powers[len] + s[i]) * base_inv % mod (se necessário).",
                                    "Para Rabin-Karp completo: compare hash do pattern com hashes da text.",
                                    "Otimize: Use dois hashes com mods/primos diferentes para reduzir colisões.",
                                    "Integre em código full: função bool rabinKarp(string text, string pat)."
                                  ],
                                  "verification": "Compile e rode em input teste: text='AABAACAADAABAAABAA', pat='AABA', deve achar matches sem crash/overflow.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (VSCode), exemplos de teste de strings com padrões repetidos.",
                                  "tips": "Sempre reduza % mod após multiplicação/add; debugue imprimindo hashes intermediários como strings.",
                                  "learningObjective": "Codificar rolling hash modular sem overflow, mantendo O(n+m) tempo.",
                                  "commonMistakes": "Esquecer % mod após add/sub; usar base^len incorreta no rolling back; colisões por mod pequeno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Otimizar a Implementação",
                                  "subSteps": [
                                    "Crie casos de teste: strings longas (10^5 chars), padrões com overflow potencial, edge cases (len=0,1).",
                                    "Meça performance: compare tempo com/ sem handling (deve ser similar).",
                                    "Verifique corretude: todos matches encontrados? Nenhum falso positivo?",
                                    "Otimize: Pré-compute powers; use double hash.",
                                    "Profile overflow: Adicione asserts ou logs para valores intermediários > 2^64.",
                                    "Documente código com comentários sobre handling."
                                  ],
                                  "verification": "Unit tests passam 100% (use Google Test ou JUnit); nenhum overflow detectado em runs longos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Framework de testes (Catch2 para C++, JUnit para Java), gerador de strings aleatórias.",
                                  "tips": "Teste com mod=2^64-59 (primo) em C++ para uint128 implícito; evite mod explícito se possível.",
                                  "learningObjective": "Validar implementação robusta contra overflow em cenários reais.",
                                  "commonMistakes": "Testes só com strings curtas; ignorar subtração no rolling (pode underflow); não testar colisões."
                                }
                              ],
                              "practicalExample": "Implemente Rabin-Karp para text='GEEKSFORGEEKS', pat='GEEKS'. Sem handling: hash intermediário ~31^5 excede uint64 após posição 5. Com __int128 em C++: hash = ((__int128)hash * 31 + 'K') % MOD; encontra match em pos 0 e 8 corretamente, sem falsos positivos.",
                              "finalVerifications": [
                                "Hashes intermediários nunca excedem capacidade do tipo (ver logs ou asserts).",
                                "Todos matches reais são detectados sem falsos negativos.",
                                "Nenhum falso positivo em textos com padrões similares mas diferentes.",
                                "Performance O(n+m) confirmada em strings de 10^6 chars.",
                                "Funciona em ambos C++ e Java com resultados idênticos.",
                                "Rolling hash atualiza corretamente em janelas deslizantes."
                              ],
                              "assessmentCriteria": [
                                "Correção modular: todas operações usam tipos grandes antes de %.",
                                "Eficiência: tempo e espaço O(n), sem loops desnecessários.",
                                "Robustez: lida com edge cases e strings longas sem crash.",
                                "Clareza: código comentado, funções modulares.",
                                "Segurança: evita colisões com double hashing opcional.",
                                "Portabilidade: funciona em C++/Java sem vendor-specific.",
                                "Testes: cobertura >90% com casos de overflow."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular, propriedades de congruências.",
                                "Análise Numérica: Precisão de ponto fixo e erros de arredondamento.",
                                "Engenharia de Software: Gerenciamento de erros em computação de alta performance.",
                                "Criptografia: Hashing seguro e funções de hash rolling em blockchain."
                              ],
                              "realWorldApplication": "Em ferramentas anti-plágio como Turnitin (detecção de cópias em docs longos), busca de malware (matching signatures em arquivos binários), compiladores (busca de substrings em código fonte), e motores de busca como Google (indexação eficiente de padrões em web crawls)."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Algoritmo Rabin-Karp Completo",
                        "description": "Integração do hashing e rolling hash para busca de padrão em texto, com verificação explícita de colisões.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Implementar busca Rabin-Karp",
                            "description": "Executar o algoritmo completo: pré-processar hashes de P e T[0..m-1], deslizar a janela comparando hashes e reportando posições onde hashes coincidem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar parâmetros e funções auxiliares",
                                  "subSteps": [
                                    "Escolha uma base 'd' (ex: 10 para decimal, 256 para ASCII) e um primo grande 'q' (ex: 10^9 + 7).",
                                    "Implemente função para calcular potência modular: pow(d, m-1, q) onde m = len(P).",
                                    "Defina funções para converter string em números: ord(c) - ord('A') + 1 ou similar.",
                                    "Crie estrutura para armazenar texto T, padrão P, e listas de resultados.",
                                    "Implemente função auxiliar para hash de substring: soma (t[i] * d^(m-1-i)) % q."
                                  ],
                                  "verification": "Verifique se pow(d, m-1, q) retorna valor correto comparando com cálculo manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (Python recomendado)",
                                    "Documentação de Rabin-Karp",
                                    "Calculadora para testes modulares"
                                  ],
                                  "tips": [
                                    "Use pow(base, exp, mod) built-in do Python para eficiência.",
                                    "Escolha q primo grande para minimizar colisões."
                                  ],
                                  "learningObjective": "Entender os parâmetros fundamentais do Rabin-Karp e preparar funções modulares.",
                                  "commonMistakes": [
                                    "Escolher q não primo levando a mais colisões.",
                                    "Esquecer de usar módulo em potências causando overflow.",
                                    "Usar base muito pequena para padrões longos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pré-processar hash do padrão P",
                                  "subSteps": [
                                    "Calcule h_p = 0.",
                                    "Para cada caractere p em P: h_p = (h_p * d + valor(p)) % q.",
                                    "Armazene h_p como hash do padrão.",
                                    "Teste com P pequeno: ex: P='AB', d=10, q=13 → hash=1*10+2=12.",
                                    "Adicione comentário explicando prevenção de overflow."
                                  ],
                                  "verification": "Imprima h_p e compare com cálculo manual para P de comprimento 1-3.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python iniciado",
                                    "Exemplos manuais de hash"
                                  ],
                                  "tips": [
                                    "Sempre aplique % q após cada multiplicação para evitar números gigantes.",
                                    "Use variáveis descritivas como pattern_hash."
                                  ],
                                  "learningObjective": "Dominar o cálculo de hash rolante para o padrão fixo.",
                                  "commonMistakes": [
                                    "Calcular hash sem módulo causando int overflow.",
                                    "Inverter ordem de caracteres no hash.",
                                    "Usar len(P) incorretamente como expoente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular hash inicial da janela T[0..m-1] e preparar loop",
                                  "subSteps": [
                                    "Calcule h_t = 0 para janela inicial T[0:m].",
                                    "Para i em 0 a m-1: h_t = (h_t * d + valor(T[i])) % q.",
                                    "Armazene h = h_t e precompute p = pow(d, m-1, q).",
                                    "Inicialize lista de resultados vazia.",
                                    "Verifique se h == h_p no início, se sim, cheque colisão."
                                  ],
                                  "verification": "Para T[:m], confirme que h_t == h_p manualmente se P está no início.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Strings de teste curtas"
                                  ],
                                  "tips": [
                                    "Copie o loop de hash de P para T inicial para consistência.",
                                    "Teste com T que começa com P exato."
                                  ],
                                  "learningObjective": "Implementar hash rolante inicial e preparar para atualizações.",
                                  "commonMistakes": [
                                    "Índices off-by-one na janela inicial.",
                                    "Esquecer de pré-computar p = d^(m-1) % q.",
                                    "Não inicializar h_t corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar deslizamento da janela e verificação de colisões",
                                  "subSteps": [
                                    "Para i de m a len(T)-1:",
                                    "Atualize h = (h * d - valor(T[i-m]) * p + valor(T[i])) % q; se h < 0: h += q.",
                                    "Se h == h_p, verifique caracteres: for j=0 to m-1, if T[i-m+1+j] != P[j], não match.",
                                    "Se match confirmado, adicione i-m+1 à lista de resultados.",
                                    "Retorne lista de posições no final."
                                  ],
                                  "verification": "Execute com exemplo conhecido e cheque se posições reportadas são corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código completo parcial",
                                    "Exemplo de teste padrão"
                                  ],
                                  "tips": [
                                    "Ajuste h negativo com +q para manter positivo.",
                                    "Verificação de colisão é crucial para precisão."
                                  ],
                                  "learningObjective": "Dominar a atualização O(1) do hash e detecção de matches reais.",
                                  "commonMistakes": [
                                    "Erro no cálculo h * d - T[i-m]*p + T[i].",
                                    "Índice errado na verificação de strings.",
                                    "Esquecer ajuste h < 0."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar a implementação completa",
                                  "subSteps": [
                                    "Defina função rabin_karp(T, P) retornando posições.",
                                    "Teste 1: T='ABABDABACDABABCABAB', P='ABAB' → espera posições [0, 4, 13].",
                                    "Teste 2: Casos com colisão intencional (mesmo hash, strings diferentes).",
                                    "Teste 3: P não encontrado, T mais curto que P.",
                                    "Meça tempo para T grande (10^5 chars) e confirme O(n+m).",
                                    "Adicione asserts ou prints para depuração."
                                  ],
                                  "verification": "Todos testes passam sem erros e output correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Unittests ou pytest",
                                    "Strings de teste variadas"
                                  ],
                                  "tips": [
                                    "Use casos edge: m=0, n<m, todos chars iguais.",
                                    "Profile para confirmar eficiência."
                                  ],
                                  "learningObjective": "Validar implementação robusta com testes abrangentes.",
                                  "commonMistakes": [
                                    "Não tratar m > n.",
                                    "Falhar em colisões levando a falsos positivos.",
                                    "Overflow não tratado em loops longos."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente rabin_karp('ABABDABACDABABCABAB', 'ABABCABAB'). Deve retornar [10, 12] pois 'ABABCABAB' ocorre nessas posições no texto (verificação manual confirma matches exatos após hashes). Use d=10, q=13 para simulação manual.",
                              "finalVerifications": [
                                "Hashes são calculados corretamente com módulo q sem overflow.",
                                "Janela desliza corretamente atualizando hash em O(1).",
                                "Colisões são verificadas por comparação de strings.",
                                "Todas posições de match são reportadas precisamente.",
                                "Função lida com casos edge (P vazio, T < P).",
                                "Eficiência demonstrada em input grande."
                              ],
                              "assessmentCriteria": [
                                "Correção: Encontra todos matches sem falsos positivos.",
                                "Eficiência: Tempo O(n+m) em testes.",
                                "Robustez: Trata overflow, negativos, edges.",
                                "Clareza: Código comentado, variáveis nomeadas bem.",
                                "Modularidade: Funções auxiliares separadas.",
                                "Testes: Cobertura de casos positivos/negativos/colisões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e polinômios rolantes.",
                                "Probabilidade: Análise de colisões hash.",
                                "Física: Modelagem de rolling hashes como ondas deslizantes.",
                                "Segurança: Conceitos de hashing em criptografia."
                              ],
                              "realWorldApplication": "Detecção de plágio em documentos (busca substrings idênticas), busca em genomas (DNA patterns), motores de busca de texto (Google-like substring matching), ferramentas anti-vírus (assinaturas de malware)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Tratar colisões por verificação explícita",
                            "description": "Quando hashes coincidem, comparar os caracteres da substring com o padrão caractere por caractere para confirmar o match verdadeiro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Colisões no Rabin-Karp",
                                  "subSteps": [
                                    "Estude o mecanismo de rolling hash no Rabin-Karp e identifique pontos onde hashes de substrings podem coincidir sem serem iguais.",
                                    "Analise exemplos matemáticos de colisões usando aritmética modular (ex: base 10, módulo pequeno).",
                                    "Explique verbalmente ou por escrito por que a verificação explícita é essencial para evitar falsos positivos.",
                                    "Compare com outros algoritmos como KMP, destacando a trade-off velocidade vs. precisão.",
                                    "Crie um diagrama ilustrando um hash collision em uma string de exemplo."
                                  ],
                                  "verification": "Resuma em 3-5 frases o que é uma colisão e sua solução, com um exemplo numérico correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta para diagramas, calculadora para hashes manuais, documentação do Rabin-Karp.",
                                  "tips": "Use um módulo pequeno (ex: 101) para simular colisões facilmente durante o estudo.",
                                  "learningObjective": "Entender as causas matemáticas de colisões e a necessidade de verificação explícita.",
                                  "commonMistakes": "Confundir colisão de hash com falha no rolling hash; ignorar o impacto de módulos pequenos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Função de Verificação Explícita",
                                  "subSteps": [
                                    "Defina uma função que receba o texto, posição inicial da substring suspeita e o padrão.",
                                    "Implemente um loop para comparar cada caractere da substring com o correspondente do padrão.",
                                    "Adicione retorno booleano: true se todos caracteres coincidirem, false caso contrário.",
                                    "Teste a função isoladamente com strings iguais e diferentes.",
                                    "Otimize para eficiência usando funções built-in como string slicing e comparação direta."
                                  ],
                                  "verification": "Execute a função com inputs que simulam colisão (ex: hashes iguais, strings diferentes) e confirme retornos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (Python/Java), strings de teste pré-definidas.",
                                  "tips": "Use slicing eficiente: text[i:i+len(pattern)] == pattern para protótipo rápido.",
                                  "learningObjective": "Criar uma verificação robusta e eficiente caractere por caractere.",
                                  "commonMistakes": "Erro off-by-one no slicing; não tratar padrões vazios ou textos curtos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar a Verificação no Algoritmo Rabin-Karp Principal",
                                  "subSteps": [
                                    "Localize o loop principal de sliding window no código Rabin-Karp existente.",
                                    "Adicione uma condição if (hash_text == hash_pattern) seguida da chamada à função de verificação.",
                                    "Se verificação retornar true, registre a posição como match verdadeiro.",
                                    "Atualize o código para coletar todas as posições de matches confirmados.",
                                    "Garanta que o rolling hash continue independentemente da verificação."
                                  ],
                                  "verification": "Rode o algoritmo completo em um texto com colisões conhecidas e liste apenas matches verdadeiros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código base do Rabin-Karp, debugger ou print statements para hashes.",
                                  "tips": "Use logging para printar hashes e resultados de verificação durante depuração.",
                                  "learningObjective": "Integrar seamless a verificação sem quebrar o fluxo de rolling hash.",
                                  "commonMistakes": "Chamar verificação em toda iteração (ineficiente); parar o loop após primeiro match falso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar o Tratamento de Colisões",
                                  "subSteps": [
                                    "Crie casos de teste: sem colisões, com colisões falsas, múltiplos matches verdadeiros.",
                                    "Meça performance: tempo com e sem verificações frequentes.",
                                    "Compare saídas com algoritmo exato como KMP.",
                                    "Analise edge cases: padrão maior que texto, texto com caracteres especiais.",
                                    "Refatore código para maior legibilidade e adicione comentários explicativos."
                                  ],
                                  "verification": "Todos testes passam com 100% matches corretos; performance aceitável (<2x slowdown).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Suite de testes unitários, timer para performance, comparador com KMP.",
                                  "tips": "Escolha módulo primo grande (ex: 10^9+7) para reduzir colisões reais nos testes.",
                                  "learningObjective": "Validar robustez do tratamento de colisões em cenários reais.",
                                  "commonMistakes": "Ignorar overflow em hashes durante testes; não testar colisões intencionais."
                                }
                              ],
                              "practicalExample": "Texto: 'ababcabcacba', Padrão: 'abcab'. No Rabin-Karp com módulo pequeno, posição 2 ('babca') pode ter hash colidindo com 'abcab', mas verificação explícita compara 'b-a', falha e confirma apenas matches verdadeiros em pos 0 e 4.",
                              "finalVerifications": [
                                "Hashes coincidentes disparam verificação explícita corretamente.",
                                "Matches verdadeiros são reportados com posições exatas.",
                                "Falsos positivos por colisão são eliminados.",
                                "Algoritmo completa sem crashes em edge cases.",
                                "Performance permanece O(n+m) em média.",
                                "Código é legível com comentários sobre verificação."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% matches precisos em testes com colisões.",
                                "Eficiência: Verificação só chamada quando hashes igualam.",
                                "Robustez: Lida com strings vazias, tamanhos desiguais.",
                                "Clareza: Função de verificação modular e documentada.",
                                "Testes: Cobertura de colisões falsas e verdadeiras.",
                                "Otimização: Uso de slicing e comparações nativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e propriedades de hashes polinomiais.",
                                "Probabilidade: Cálculo de chance de colisões em hashing.",
                                "Engenharia de Software: Tratamento de falsos positivos em detecção.",
                                "Criptografia: Conceitos semelhantes em funções hash seguras como SHA."
                              ],
                              "realWorldApplication": "Em ferramentas de busca de texto como editores de código (VS Code find), detecção de plágio em plataformas educacionais (Turnitin), e indexação de documentos em bancos de dados (Elasticsearch), onde hashes rápidos filtram candidatos e verificação explícita garante precisão."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Analisar complexidade do Rabin-Karp",
                            "description": "Derivar tempo médio O(n + m) e pior caso O(nm), explicando dependência na probabilidade de colisões falsas com bom hash.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Funcionamento do Algoritmo Rabin-Karp",
                                  "subSteps": [
                                    "Relembre o pré-processamento: compute hash do padrão P de tamanho m e hash inicial do texto T[0..m-1].",
                                    "Entenda o rolling hash: fórmula para atualizar hash de T[i..i+m-1] como h_i = (d * h_{i-1} - T[i-1]*b^{m-1} + T[i+m-1]) mod q.",
                                    "Descreva o loop principal: compare hashes e verifique colisão falsa apenas quando hashes iguais.",
                                    "Identifique quando ocorre comparação de caracteres completa."
                                  ],
                                  "verification": "Escreva pseudocódigo resumido e simule em exemplo pequeno (texto 'abcabc', padrão 'abc').",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo do Rabin-Karp",
                                    "Papel e lápis para simulação",
                                    "Calculadora para hashes modulares"
                                  ],
                                  "tips": "Use um primo grande q e base b=256 para simulações manuais.",
                                  "learningObjective": "Compreender componentes para análise de complexidade.",
                                  "commonMistakes": [
                                    "Ignorar overflow em cálculos modulares",
                                    "Confundir tamanho n do texto com m do padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Complexidade no Pior Caso",
                                  "subSteps": [
                                    "Identifique cenário pior: hashes sempre colidem falsamente.",
                                    "Conte operações: cada posição i=0 a n-m requer update hash O(1) + comparação completa O(m).",
                                    "Some pré-processamento O(m + n).",
                                    "Conclua O(n + m + (n-m+1)*m) = O(nm)."
                                  ],
                                  "verification": "Escreva equação formal e prove com exemplo adversarial (padrão todo 'a's, texto repetindo).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo adversarial escrito",
                                    "Folha para contagem de operações"
                                  ],
                                  "tips": "Conte shifts e comparações separadamente.",
                                  "learningObjective": "Derivar bound superior O(nm).",
                                  "commonMistakes": [
                                    "Subestimar comparações em colisões",
                                    "Esquecer pré-processamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Complexidade no Caso Médio",
                                  "subSteps": [
                                    "Defina probabilidade de colisão falsa: para hash bom, Pr(hash(P)=hash(S)) ≈ 1/|H| onde |H| grande.",
                                    "Assuma colisão rara: maioria comparações hash param em O(1), verificação rara O(m).",
                                    "Calcule tempo médio: O(n + m) + O(n * (1/|H|) * m) ≈ O(n + m) se |H| >> n.",
                                    "Use expected value para formalizar."
                                  ],
                                  "verification": "Compute Pr(colisão) para exemplo e estime tempo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de probabilidade básica",
                                    "Exemplo numérico com q=10^9+7"
                                  ],
                                  "tips": "Escolha |H| = 10^9 para ilustrar.",
                                  "learningObjective": "Entender dependência probabilística.",
                                  "commonMistakes": [
                                    "Confundir pior com médio",
                                    "Ignorar que O(1) médio requer hash uniforme"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Dependência em Hash e Sintetizar",
                                  "subSteps": [
                                    "Explique 'bom hash': funções como double hashing ou polinomial com primo grande.",
                                    "Analise impacto ruim hash: aproxima pior caso.",
                                    "Compare com KMP (sempre O(n+m)) vs Rabin-Karp (rápido prático).",
                                    "Resuma tempos: médio O(n+m), pior O(nm)."
                                  ],
                                  "verification": "Explique verbalmente ou escreva parágrafo síntese.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela comparativa KMP vs RK"
                                  ],
                                  "tips": "Mencione bibliotecas como Python's rolling hash.",
                                  "learningObjective": "Sintetizar análise completa.",
                                  "commonMistakes": [
                                    "Superestimar bom hash como garantia",
                                    "Omitir trade-offs"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise complexidade para texto T='abracadabra' (n=11), padrão P='abra' (m=4): compute hashes manualmente, identifique colisões e derive tempo exato vs médio.",
                              "finalVerifications": [
                                "Deriva corretamente O(nm) pior caso com prova.",
                                "Explica O(n+m) médio com probabilidade 1/|H|.",
                                "Identifica exemplo adversarial.",
                                "Discute escolha de q e b.",
                                "Compara com outros algoritmos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de bounds.",
                                "Clareza na explicação probabilística.",
                                "Uso correto de notação Big-O.",
                                "Identificação de premissas (hash bom).",
                                "Exemplos concretos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística (expected value, colisões).",
                                "Teoria dos Números (aritmética modular, primos).",
                                "Matemática Discreta (funções hash polinomiais).",
                                "Engenharia de Software (análise assintótica)."
                              ],
                              "realWorldApplication": "Em motores de busca como Google para indexação rápida de textos massivos, detecção de plágio em documentos e busca em genomas biológicos, onde colisões são raras com hashes de 128+ bits."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.6",
                    "name": "Algoritmo Boyer-Moore",
                    "description": "Algoritmo que pula posições usando heurísticas de caracteres ruins e bons.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.6.1",
                        "name": "Heurística de Caracteres Ruins (Bad Character Rule)",
                        "description": "Heurística que acelera a busca pulando posições no texto com base no caractere do texto que causou o mismatch, comparando sua última ocorrência no padrão.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.1.1",
                            "name": "Explicar o funcionamento da heurística de caracteres ruins",
                            "description": "Descrever como, em caso de mismatch na posição i, o shift é calculado como o máximo entre 1 e (i - última_posição_do_caractere_no_padrão), permitindo pular caracteres irrelevantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto de mismatch no Algoritomo Boyer-Moore",
                                  "subSteps": [
                                    "Revise o funcionamento básico do Boyer-Moore: alinhamento do padrão P de comprimento m com o texto T na posição s.",
                                    "Identifique um mismatch na posição i (0 ≤ i < m), onde T[s+i] ≠ P[i].",
                                    "Explique que, em vez de shift de 1, usamos heurísticas para shifts maiores.",
                                    "Note que a heurística de caracteres ruins foca no caractere mismatched T[s+i].",
                                    "Discuta por que pular alinhamentos ruins acelera a busca."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito um cenário de mismatch com posições s, i e m.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo do Boyer-Moore",
                                    "Exemplo de texto e padrão simples"
                                  ],
                                  "tips": "Sempre relacione i à posição relativa no alinhamento atual.",
                                  "learningObjective": "Identificar e contextualizar um mismatch no Boyer-Moore.",
                                  "commonMistakes": [
                                    "Confundir i com a posição absoluta em T",
                                    "Ignorar que i é relativo ao padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a tabela de caracteres ruins (bad character table)",
                                  "subSteps": [
                                    "Precompute para cada caractere c no alfabeto a última posição last[c] em P (da direita para a esquerda).",
                                    "Inicialize last[c] = -1 para todos c; para j de m-1 downto 0: last[P[j]] = j.",
                                    "Para o caractere mismatched x = T[s+i], obtenha last[x].",
                                    "Se x não aparece em P, last[x] = -1.",
                                    "Entenda que last[x] indica o alinhamento mais à direita possível sem desperdiçar."
                                  ],
                                  "verification": "Construa a tabela para P = 'EXAMPLE' e verifique last['X'] = 3.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela",
                                    "Implementação em Python para testar"
                                  ],
                                  "tips": "Precompute a tabela uma vez no início para eficiência O(1) por consulta.",
                                  "learningObjective": "Criar e interpretar a tabela de última ocorrência de caracteres no padrão.",
                                  "commonMistakes": [
                                    "Atualizar last de esquerda para direita (deve ser direita para esquerda)",
                                    "Esquecer de setar -1 para caracteres ausentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o shift usando a heurística de caracteres ruins",
                                  "subSteps": [
                                    "No mismatch em i, com x = T[s+i], shift = max(1, i - last[x]).",
                                    "Se last[x] = -1, shift = i + 1 (pula todo o padrão).",
                                    "Atualize s = s + shift.",
                                    "Repita o alinhamento até match ou fim de T.",
                                    "Explique: i - last[x] garante que last[x] alinhe com x se possível, pulando irrelevantes."
                                  ],
                                  "verification": "Para P='EXAMPLE', i=2, x='M', last['M']=-1, calcule shift=3.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo anotado de texto e padrão",
                                    "Calculadora para shifts múltiplos"
                                  ],
                                  "tips": "Lembre: max(1, ...) evita shifts zero que causariam loop.",
                                  "learningObjective": "Aplicar a fórmula de shift corretamente em um mismatch.",
                                  "commonMistakes": [
                                    "Usar min em vez de max",
                                    "Confundir last[x] com posição de primeira ocorrência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o impacto e condições especiais da heurística",
                                  "subSteps": [
                                    "Discuta por que isso pula 'caracteres irrelevantes': otimiza skips baseados em mismatches.",
                                    "Considere quando heurística é ótima: textos com padrões repetidos ou alfabeto grande.",
                                    "Combine com heurística de boa sufixo (não foco aqui).",
                                    "Simule múltiplos mismatches em um texto.",
                                    "Avalie complexidade: pré-processamento O(m + σ), onde σ é tamanho alfabeto."
                                  ],
                                  "verification": "Simule busca completa em T='ABABABC' com P='ABC' e liste shifts.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Simulador online de Boyer-Moore",
                                    "Vídeo explicativo curto"
                                  ],
                                  "tips": "Visualize alinhamentos com setas para shifts.",
                                  "learningObjective": "Explicar o raciocínio otimizador e limitações da heurística.",
                                  "commonMistakes": [
                                    "Achar que shift sempre pula para além de i",
                                    "Ignorar que heurística pode ser subótima em alguns casos"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto T = 'HERE IS A SIMPLE EXAMPLE', Padrão P = 'EXAMPLE' (m=7). Alinhe em s=11 ('SIMPLE '). Mismatch em i=2: T[13]='M' ≠ P[2]='A'. last['M']=-1, shift=max(1,2-(-1))=3. Novo s=14 ('E EXA...'), encontra match em s=17.",
                              "finalVerifications": [
                                "Construa corretamente a tabela bad character para qualquer P dado.",
                                "Calcule shift preciso para mismatch em i com x específico.",
                                "Simule 3 alinhamentos completos mostrando shifts.",
                                "Explique verbalmente por que shift = i - last[x] otimiza.",
                                "Identifique quando last[x]=-1 e shift=i+1.",
                                "Compare tempo com shift ingênuo de 1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula shift = max(1, i - last[x]).",
                                "Correta construção da tabela last[] da direita para esquerda.",
                                "Explicação clara do skip de 'caracteres irrelevantes'.",
                                "Exemplo prático executado sem erros.",
                                "Uso correto de posições relativas (i vs. absolutas).",
                                "Integração com contexto Boyer-Moore."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de máximos e posições em sequências.",
                                "Probabilidade: Heurística otimiza buscas em textos reais com distribuições de caracteres.",
                                "Engenharia de Software: Otimização de algoritmos de string matching.",
                                "Linguística Computacional: Aplicações em processamento de texto natural."
                              ],
                              "realWorldApplication": "Usado em editores de texto (ex: grep, Sublime Text) para busca rápida de padrões longos em arquivos grandes, em antivírus para detecção de assinaturas de malware, e em bioinformática para alinhamento de sequências de DNA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.2",
                            "name": "Construir a tabela de caracteres ruins",
                            "description": "Para um padrão P de tamanho m e alfabeto Σ, criar uma tabela bc[char] = última posição de char em P (ou -1 se ausente), usada para pré-processamento em O(m + |Σ|).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Padrão e Definir o Alfabeto",
                                  "subSteps": [
                                    "Identifique o padrão P e seu tamanho m (comprimento de P).",
                                    "Defina o alfabeto Σ explicitamente ou assuma um conjunto padrão (ex: letras minúsculas a-z).",
                                    "Liste todos os caracteres únicos presentes em P.",
                                    "Anote as posições (índices de 0 a m-1) de cada ocorrência de caracteres em P.",
                                    "Confirme que Σ inclui todos os possíveis caracteres relevantes para o contexto."
                                  ],
                                  "verification": "Crie um diagrama manual do padrão P com índices e caracteres únicos listados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples; string P de exemplo.",
                                  "tips": "Comece com um P curto (m ≤ 10) para prática inicial.",
                                  "learningObjective": "Compreender os inputs necessários para construir a tabela bc.",
                                  "commonMistakes": "Confundir tamanho m com número de caracteres únicos; ignorar caracteres fora de Σ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a Tabela de Caracteres Ruins",
                                  "subSteps": [
                                    "Crie um array ou mapa bc de tamanho |Σ|, indexado pelos caracteres de Σ.",
                                    "Inicialize todos os valores de bc[char] para -1.",
                                    "Garanta que os índices correspondam aos códigos dos caracteres (ex: 'a' = 0 para alfabeto a-z).",
                                    "Teste a inicialização imprimindo ou visualizando a tabela vazia.",
                                    "Documente o mapeamento de caracteres para índices se Σ for customizado."
                                  ],
                                  "verification": "A tabela bc deve mostrar todos -1 para cada char em Σ.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Linguagem de programação (Python/Java) ou planilha; código para inicializar array.",
                                  "tips": "Use um dicionário em Python para Σ grande ou irregular.",
                                  "learningObjective": "Implementar uma estrutura de dados inicializada corretamente para bc.",
                                  "commonMistakes": "Índices incorretos para caracteres (ex: ord('a') em Python); não cobrir todo Σ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher a Tabela com Últimas Posições",
                                  "subSteps": [
                                    "Percorra P da esquerda para a direita (índice i de 0 a m-1).",
                                    "Para cada caractere P[i], defina bc[P[i]] = i (sobrescrevendo para última posição).",
                                    "Pule caracteres já processados se múltiplas ocorrências.",
                                    "Após o loop, confirme que apenas a última posição foi registrada para cada char.",
                                    "Calcule o tempo de complexidade: O(m + |Σ|)."
                                  ],
                                  "verification": "Para cada char em P, bc[char] deve ser a posição máxima i onde P[i] == char.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código fonte com loop for; debugger ou print statements.",
                                  "tips": "Use um loop reverso opcionalmente para eficiência conceitual, mas forward é padrão.",
                                  "learningObjective": "Capturar a heurística de 'última ocorrência' em O(m).",
                                  "commonMistakes": "Registrar primeira em vez de última posição; processar chars fora de P."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Testar a Tabela",
                                  "subSteps": [
                                    "Teste com chars presentes: bc deve retornar posição exata da última ocorrência.",
                                    "Teste com chars ausentes: bc deve retornar -1.",
                                    "Simule um shift usando bc em um texto T simples.",
                                    "Meça o tempo de construção e compare com O(m + |Σ|).",
                                    "Corrija discrepâncias comparando manualmente com P."
                                  ],
                                  "verification": "Todos os testes passam: posições corretas e -1 para ausentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código de teste unitário; texto T de exemplo para simulação Boyer-Moore.",
                                  "tips": "Escreva funções de teste automatizadas para reutilização.",
                                  "learningObjective": "Garantir correção e usabilidade da tabela no algoritmo completo.",
                                  "commonMistakes": "Não testar chars ausentes; erros de off-by-one em posições."
                                }
                              ],
                              "practicalExample": "Para P = \"hedeh\", m=5, Σ={a-z}. Última 'h'=3, 'e'=4, 'd'=2, outros -1. Tabela: bc['h']=3, bc['e']=4, bc['d']=2, bc['a']=-1, etc. Pré-processamento: percorre P (O(5)), inicializa 26 slots (O(26)).",
                              "finalVerifications": [
                                "bc[char] == posição máxima i em P onde P[i]==char, para todo char presente.",
                                "bc[char] == -1 para todo char ausente em P.",
                                "Tempo de construção ≤ O(m + |Σ|) em testes empíricos.",
                                "Tabela usada corretamente em shift de Boyer-Moore simulado.",
                                "Nenhum overwrite incorreto em múltiplas ocorrências.",
                                "Estrutura bc acessível em O(1) por char."
                              ],
                              "assessmentCriteria": [
                                "Precisão das posições: 100% corretas para últimas ocorrências.",
                                "Cobertura completa de Σ com -1 apropriados.",
                                "Eficiência: implementação em O(m + |Σ|) sem loops desnecessários.",
                                "Robustez: lida com P vazio, m=1, Σ grande.",
                                "Clareza do código: comentários e nomes variáveis intuitivos.",
                                "Testes: pelo menos 5 casos cobrindo edge cases."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Arrays e funções de mapeamento (funções injetoras).",
                                "Programação: Estruturas de dados (hash tables, arrays) e análise de complexidade.",
                                "Engenharia de Software: Pré-processamento e otimização de algoritmos de string.",
                                "Lógica e Raciocínio: Heurísticas e regras de decisão em busca."
                              ],
                              "realWorldApplication": "Pré-processamento essencial no Algoritmo Boyer-Moore para busca rápida de padrões em textos grandes, usado em editores (VS Code find), ferramentas de busca (grep), detecção de vírus (antivírus), e genômica (busca de sequências DNA)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.3",
                            "name": "Aplicar a heurística de caracteres ruins na busca",
                            "description": "Durante a comparação do padrão com o texto, ao encontrar mismatch em posição i, computar shift = max(1, i - bc[texto[j+i]]), onde j é posição no texto, e avançar j por esse shift.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Iniciar a comparação alinhada do padrão com o texto na posição j",
                                  "subSteps": [
                                    "Alinhe o final do padrão P (comprimento m) com a posição j + m - 1 no texto T",
                                    "Inicie a comparação dos caracteres de trás para frente: para i de m-1 até 0, compare P[i] com T[j + i]",
                                    "Se todos os caracteres coincidirem, declare match na posição j",
                                    "Se encontrar mismatch em alguma posição i, anote i e o caractere T[j + i] e prossiga",
                                    "Registre o estado atual para depuração"
                                  ],
                                  "verification": "Verifique se a comparação inicia do final do padrão e detecta corretamente match total ou mismatch em i específico",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela bc pré-computada",
                                    "Exemplos de padrão P e texto T",
                                    "Papel e caneta ou editor de código para simulação"
                                  ],
                                  "tips": "Sempre comece do final para maximizar o uso da heurística de caracteres ruins",
                                  "learningObjective": "Dominar o alinhamento e fluxo inicial de comparação no Boyer-Moore",
                                  "commonMistakes": [
                                    "Comparar da esquerda para a direita",
                                    "Erro no cálculo de índices j + i",
                                    "Ignorar match total"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o caractere ruim e consultar a tabela bc",
                                  "subSteps": [
                                    "No mismatch encontrado em posição i, identifique o caractere ruim c = T[j + i]",
                                    "Consulte a tabela bc[c], onde bc[c] é a posição mais à direita de c no padrão P (ou -1 se ausente)",
                                    "Confirme que bc foi pré-computada corretamente: bc[c] = max {k | P[k] = c} para k < m",
                                    "Anote o valor r = bc[c] para cálculo subsequente",
                                    "Valide se c aparece no padrão e ajuste r adequadamente"
                                  ],
                                  "verification": "Confirme que bc[c] retorna o índice correto da última ocorrência de c no padrão",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela bc impressa ou em código",
                                    "Padrão P anotado com posições de caracteres"
                                  ],
                                  "tips": "Pré-compute bc uma vez para eficiência; use -1 para caracteres não presentes",
                                  "learningObjective": "Entender o papel da tabela bad character na detecção de shifts seguros",
                                  "commonMistakes": [
                                    "Usar posição errada para bc[c]",
                                    "Confundir bc com good suffix",
                                    "Não tratar caracteres ausentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o valor do shift usando a heurística",
                                  "subSteps": [
                                    "Com i (posição do mismatch) e r = bc[T[j + i]], calcule shift = i - r",
                                    "Ajuste shift = max(1, shift) para evitar shifts zero",
                                    "Se r = -1 (caractere ausente), shift = i + 1 efetivamente",
                                    "Verifique se o shift não ultrapassa o alinhamento necessário (j + shift < len(T) - m + 1)",
                                    "Documente o cálculo: shift = max(1, i - bc[T[j + i]])"
                                  ],
                                  "verification": "Execute o cálculo em um exemplo e confirme que shift >=1 e pula posições inválidas",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou simulador de código",
                                    "Exemplos numéricos de i, j e bc"
                                  ],
                                  "tips": "O shift garante que o caractere ruim não cause mismatch imediato novamente",
                                  "learningObjective": "Aplicar precisamente a fórmula de shift da heurística de caracteres ruins",
                                  "commonMistakes": [
                                    "Esquecer max(1, ...)",
                                    "Usar i + bc em vez de i - bc",
                                    "Calcular shift = 0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o shift e continuar a busca",
                                  "subSteps": [
                                    "Atualize a posição j = j + shift",
                                    "Se j + m - 1 >= len(T), pare a busca (fim do texto)",
                                    "Caso contrário, reinicie a comparação na nova posição j (volta ao step 1)",
                                    "Registre todos os shifts aplicados para análise de performance",
                                    "Continue até encontrar match ou esgotar o texto"
                                  ],
                                  "verification": "Simule o loop completo e confirme que j avança corretamente sem loops infinitos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de Boyer-Moore ou código Python/Java",
                                    "Texto longo para teste"
                                  ],
                                  "tips": "Combine com heurística good-suffix para shifts maiores quando possível",
                                  "learningObjective": "Integrar a heurística no loop principal de busca eficiente",
                                  "commonMistakes": [
                                    "Não reiniciar comparação após shift",
                                    "Shift negativo ou zero",
                                    "Overflow de índices"
                                  ]
                                }
                              ],
                              "practicalExample": "Padrão P='abc' (m=3), bc={'a':0,'b':1,'c':2, outros:-1}. Texto T='abdcabc'. Em j=0: compare i=2 'c'vs'd' (mismatch i=2, c_ruim='d', bc['d']=-1, shift=max(1,2-(-1))=3), j=3. Em j=3: 'a'vs'a', 'b'vs'b', 'c'vs'c' (match em j=4, pois alinhado).",
                              "finalVerifications": [
                                "Calcula shift corretamente para mismatches com caracteres presentes e ausentes",
                                "Avança j sem shifts inválidos (sempre >=1)",
                                "Detecta matches corretos após shifts",
                                "Loop termina apropriadamente no fim do texto",
                                "Performance melhora com skips maiores que busca ingênua",
                                "bc table é consultada precisamente em cada mismatch"
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula shift = max(1, i - bc[T[j+i]]) (100% correto)",
                                "Correta detecção e tratamento de mismatches",
                                "Integração fluida no loop de busca Boyer-Moore",
                                "Eficiência demonstrada em exemplos (menos comparações)",
                                "Ausência de erros de índice ou overflow",
                                "Explicação clara do raciocínio em simulações"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções de mapeamento (bc como lookup table) e máximos/mínimos",
                                "Algoritmos: Otimização de complexidade O(n/m) média",
                                "Engenharia de Software: Tabelas de pré-processamento para eficiência",
                                "Probabilidade: Análise heurística baseada em distribuições de caracteres",
                                "Lógica: Raciocínio dedutivo em shifts seguros"
                              ],
                              "realWorldApplication": "Usado em editores de texto (busca rápida em VS Code/Sublime), ferramentas de busca como grep otimizado, antivírus para scanning de assinaturas de malware, e motores de busca de DNA em bioinformática para padrões genéticos longos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.1.1",
                              "10.1.3.6.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.2",
                        "name": "Heurística de Suffixos Bons (Good Suffix Rule)",
                        "description": "Heurística que pula posições baseando-se em sufixos do padrão que já casaram com o texto, usando shifts pré-computados para maximizar o avanço.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.2.1",
                            "name": "Explicar o funcionamento da heurística de sufixos bons",
                            "description": "Descrever as duas regras: shift para o sufixo bom inteiro e shifts para sufixos parciais, permitindo pular quando um sufixo de comprimento l casa, buscando ocorrências anteriores no padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Sufixos Bons",
                                  "subSteps": [
                                    "Defina o que é um 'sufixo bom' no contexto do Boyer-Moore: um sufixo do padrão que casa com uma substring do texto.",
                                    "Identifique quando um sufixo bom é detectado: após uma comparação parcial onde o final do padrão casa, mas há mismatch no início.",
                                    "Revise o papel das heurísticas no Boyer-Moore: pular caracteres para eficiência.",
                                    "Diferencie sufixo bom inteiro de sufixos parciais.",
                                    "Estude a tabela de sufixos bons (good-suffix table) usada para shifts."
                                  ],
                                  "verification": "Explique em suas palavras o que é um sufixo bom e dê um exemplo simples com padrão 'abc' e texto 'xbc'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo do Boyer-Moore",
                                    "Vídeo introdutório sobre Boyer-Moore (5 min)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Desenhe o padrão e o texto lado a lado para visualizar mismatches.",
                                  "learningObjective": "Compreender a definição e detecção de sufixos bons como base para as regras de shift.",
                                  "commonMistakes": [
                                    "Confundir sufixo bom com prefixo",
                                    "Ignorar que sufixos bons são do final do padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a Primeira Regra: Shift para o Sufixo Bom Inteiro",
                                  "subSteps": [
                                    "Descreva a regra: Quando um sufixo de comprimento l casa no texto, mas o caractere imediatamente antes do padrão não casa, shift para alinhar o sufixo bom inteiro novamente.",
                                    "Calcule o shift: Posicione o padrão para que o sufixo bom anterior no padrão alinhe com o sufixo bom no texto.",
                                    "Exemplo: Padrão 'heuristic', sufixo 'istic' casa, shift para próxima possível ocorrência do 'istic' no padrão.",
                                    "Implemente logicamente: Se não houver sufixo bom anterior, shift pelo comprimento do padrão.",
                                    "Compare com heurística de caracteres ruins para entender complementaridade."
                                  ],
                                  "verification": "Aplique a regra manualmente em um exemplo: padrão 'abcde', texto 'xbcdeyabcde', mostre o shift após mismatch.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos impressos de padrões e textos",
                                    "Calculadora para comprimentos",
                                    "Ferramenta online de simulação Boyer-Moore"
                                  ],
                                  "tips": "Sempre marque o sufixo bom com cores diferentes no diagrama.",
                                  "learningObjective": "Dominar a regra de shift para sufixo bom inteiro e calcular shifts corretos.",
                                  "commonMistakes": [
                                    "Shift incorreto para o comprimento total sem verificar ocorrências anteriores",
                                    "Confundir com shift de 1 posição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Segunda Regra: Shifts para Sufixos Parciais",
                                  "subSteps": [
                                    "Defina sufixos parciais: Sufixos mais curtos que o sufixo bom atual, mas que ocorrem antes no padrão.",
                                    "Busque o sufixo bom mais longo que é um sufixo parcial e aparece como prefixo ou interno anterior no padrão.",
                                    "Calcule shift: Alinhe esse sufixo parcial com o sufixo bom no texto.",
                                    "Pré-processe a tabela de sufixos: Para cada posição i, encontre o shift máximo baseado em sufixos bons.",
                                    "Integre com a primeira regra: Use a que dá o maior shift."
                                  ],
                                  "verification": "Construa a tabela de sufixos bons para padrão 'mississippi' e demonstre shifts para um mismatch.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha para tabela de sufixos",
                                    "Pseudocódigo de pré-processamento",
                                    "Exemplos de padrões complexos"
                                  ],
                                  "tips": "Comece com padrões simples como 'aaa' para entender recursão de sufixos.",
                                  "learningObjective": "Aplicar a regra de sufixos parciais e construir tabelas de shift.",
                                  "commonMistakes": [
                                    "Não buscar a ocorrência mais à esquerda no padrão",
                                    "Ignorar sufixos que não são prefixos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Aplicar Ambas as Regras no Algoritmo Completo",
                                  "subSteps": [
                                    "Combine as regras: Após mismatch, escolha o máximo shift entre caractere ruim, sufixo bom inteiro e parcial.",
                                    "Simule o algoritmo completo com as heurísticas de sufixos.",
                                    "Discuta pré-processamento: Construir tabela em O(m + σ) onde m é comprimento do padrão.",
                                    "Analise complexidade: Pulos maiores levam a O(n/m) no pior caso.",
                                    "Teste com casos extremos: Padrões repetitivos vs. únicos."
                                  ],
                                  "verification": "Simule busca completa de 'algorithm' em 'this is an algorithm example' usando apenas heurística de sufixos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador online Boyer-Moore",
                                    "Papel para rastrear posições",
                                    "Código Python simples para validar"
                                  ],
                                  "tips": "Rastreie posição atual do padrão (i) e texto (j) em uma tabela.",
                                  "learningObjective": "Integrar heurísticas de sufixos bons ao fluxo do Boyer-Moore.",
                                  "commonMistakes": [
                                    "Não maximizar shifts entre regras",
                                    "Erro no pré-processamento da tabela"
                                  ]
                                }
                              ],
                              "practicalExample": "Padrão: 'ABCDABD'. Texto: 'ABCDABDXABCDABY'. Após mismatch em 'X' (sufixo bom 'ABD' de len=3), primeira regra shifts para alinhar próximo 'ABD' no padrão (posição 4), segunda regra considera sufixo parcial 'BD' ou 'D' para shifts maiores. Resultado: shift de 4 posições, pulando eficientemente.",
                              "finalVerifications": [
                                "Construa corretamente a tabela de sufixos bons para um padrão dado.",
                                "Explique e aplique a primeira regra em um exemplo com diagrama.",
                                "Demonstre a segunda regra identificando sufixos parciais.",
                                "Simule shifts em uma busca completa sem erros.",
                                "Compare shifts com e sem heurística, mostrando eficiência.",
                                "Identifique casos onde sufixos bons superam caracteres ruins."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição das duas regras (100% correta).",
                                "Capacidade de construir tabela de sufixos bons sem erros.",
                                "Correta aplicação de shifts em exemplos (máximo shift escolhido).",
                                "Uso de diagramas claros para visualização.",
                                "Explicação da integração com outras heurísticas.",
                                "Análise qualitativa de eficiência (pulos vs. comparações)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Strings e Autômatos Finitos (KMP relacionado).",
                                "Biologia Computacional: Busca de padrões em sequências de DNA.",
                                "Engenharia de Software: Otimização de algoritmos de busca em editores de texto.",
                                "Linguística Computacional: Análise de similaridade em textos naturais."
                              ],
                              "realWorldApplication": "Usado em editores como grep, editores de código (VS Code find), busca em genomas (BLAST variantes), e ferramentas de segurança para detecção de assinaturas de malware em logs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.2.2",
                            "name": "Construir as tabelas de sufixos bons",
                            "description": "Criar tabela gs[1..m] onde gs[i] é o shift para o sufixo de P[i..m] que casa, e tabela de shifts para bordas, em tempo O(m) usando Z-algorithm ou KMP-like.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Padrão e Inicializar as Tabelas",
                                  "subSteps": [
                                    "Obtenha o padrão P e calcule m = comprimento de P (considere indexação 1-based: P[1..m]).",
                                    "Crie o array gs[1..m] e inicialize todos os elementos com o valor m (shift padrão que pula o sufixo inteiro).",
                                    "Crie o padrão invertido R[1..m] onde R[i] = P[m - i + 1] para cada i.",
                                    "Inicialize uma tabela auxiliar bordaShift[1..m] com valores m + 1 (para shifts de bordas)."
                                  ],
                                  "verification": "Confirme que todos gs[i] == m, bordaShift[i] == m+1 e R é exatamente o reverse de P através de inspeção manual ou print.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo de padrão P (ex: 'AABAAC')",
                                    "Editor de código (Python/C++)",
                                    "Papel e caneta para desenhos"
                                  ],
                                  "tips": "Mantenha consistência na indexação 1-based para evitar off-by-one errors durante a implementação.",
                                  "learningObjective": "Compreender a configuração inicial das tabelas de shifts para a heurística de sufixos bons.",
                                  "commonMistakes": "Confundir indexação 0-based com 1-based; inverter incorretamente o padrão R; esquecer de inicializar elementos do array."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o Z-Array do Padrão Invertido R",
                                  "subSteps": [
                                    "Implemente o Z-algorithm em R: Z[1] = 0; para k=2 a m, compute Z[k] como o maior comprimento onde R[1..Z[k]] == R[k..k+Z[k]-1].",
                                    "Use a otimização da 'caixa Z' (mantenha l e r como extremos da caixa ativa) para garantir tempo O(m).",
                                    "Calcule Z para todo R e armazene em array Z[1..m].",
                                    "Valide os primeiros valores manualmente (ex: compare Z[2] com alinhamento direto).",
                                    "Teste a implementação com R pequeno (ex: R='AABAA')."
                                  ],
                                  "verification": "Calcule Z manualmente para um R de tamanho pequeno (m<=5) e compare com o output do algoritmo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Implementação prévia ou template do Z-algorithm",
                                    "Exemplos de strings para teste (ex: 'AABAA')",
                                    "Debugger de código"
                                  ],
                                  "tips": "Atualize r = max(r, k + Z[k] - 1) na caixa Z para pular computações desnecessárias.",
                                  "learningObjective": "Aplicar o Z-algorithm eficientemente para detectar matches de prefixos em sufixos reversos do padrão.",
                                  "commonMistakes": "Implementação ingênua levando a O(m^2); erro na atualização da caixa Z (r ou l incorretos); confundir Z com pi do KMP."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher a Tabela gs com Shifts de Continuação Usando Z-Array",
                                  "subSteps": [
                                    "Para cada i de 1 a m: se Z[i] > 0, compute shift_cand = i - Z[i]; atualize gs[i] = min(gs[i], shift_cand).",
                                    "Isso captura o shift onde o sufixo P[i..m] pode continuar alinhando com um prefixo similar via overlap detectado em R.",
                                    "Mantenha gs[i] = m se não houver Z[i] > 0 (sem continuação útil).",
                                    "Registre os updates em um log para análise.",
                                    "Verifique que todos shifts propostos são positivos e <= m."
                                  ],
                                  "verification": "Para cada i, simule o shift gs[i] no padrão P e confirme que alinha o sufixo bom corretamente com algum prefixo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Array Z computado",
                                    "Padrão P",
                                    "Código para simulação de shifts"
                                  ],
                                  "tips": "O shift i - Z[i] alinha a parte matching; sempre tome o mínimo para otimização.",
                                  "learningObjective": "Construir shifts para casos de continuação direta de sufixos bons usando matches do Z-array.",
                                  "commonMistakes": "Não usar min() para updates múltiplos; shifts negativos ou >m; ignorar casos Z[i]=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar Shifts para Bordas e Finalizar as Tabelas",
                                  "subSteps": [
                                    "Compute a função pi[1..m] do KMP para o padrão original P (pi[j] = longest proper prefix-suffix border até j).",
                                    "Para cada i=1 a m: let l = m - i + 1 (comprimento do sufixo); let b = pi[l]; if b > 0, shift_borda = l - b; atualize gs[i] = min(gs[i], shift_borda).",
                                    "Isso captura shifts baseados em bordas do sufixo quando não há continuação direta.",
                                    "Ajuste gs[m] = 1 (shift mínimo para último char); confirme todos gs[i] >=1.",
                                    "Teste a tabela completa com uma busca Boyer-Moore simulada em um texto curto."
                                  ],
                                  "verification": "Use a tabela gs em uma simulação de Boyer-Moore e confirme que shifts evitam rechecagens desnecessárias.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Função pi KMP implementada",
                                    "Texto de teste (ex: 'AABAACAABAACAABAAC')",
                                    "Simulador de Boyer-Moore"
                                  ],
                                  "tips": "Bordas fornecem shifts alternativos menores; integre com continuação via min().",
                                  "learningObjective": "Integrar shifts de bordas com continuação para tabela gs completa em O(m).",
                                  "commonMistakes": "Usar pi de R ao invés de P; não tratar b=0; esquecer ajuste final para gs[m]."
                                }
                              ],
                              "practicalExample": "Considere P = 'AABAAC' (m=6), R='CAABAA'. Z para R: [0, 0, 2, 0, 1, 2] (aprox.). Após passos: gs[1]=6, gs[2]=3 (exemplo de continuação), gs[3]=2 (borda), gs[4]=6, gs[5]=1, gs[6]=1. Teste em T='AABAACAABAACAABAAC': aplique shifts corretos sem backtrack excessivo.",
                              "finalVerifications": [
                                "Tabela gs correta para P='AABAAC' com shifts mínimos.",
                                "Implementação roda em O(m) (teste com m=10^5).",
                                "Explicação clara do papel de Z-array e pi em shifts.",
                                "Simulação de Boyer-Moore usa gs corretamente sem erros.",
                                "Casos edge (m=1, sem overlaps) tratados.",
                                "Diferença entre shift de continuação e borda explicada."
                              ],
                              "assessmentCriteria": [
                                "gs[1..m] contém shifts corretos e mínimos para 3+ exemplos (100% precisão).",
                                "Todo processo em tempo O(m), comprovado por análise/código.",
                                "Código funcional, legível, com comentários sobre fórmulas.",
                                "Tratamento correto de casos sem matches (gs[i]=m).",
                                "Integração com tabela de bad chars para Boyer-Moore completo.",
                                "Testes unitários passam para padrões variados."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmo Z e KMP: pré-processamentos lineares para string matching.",
                                "Teoria das Strings: conceitos de borders, prefixes e sufixos.",
                                "Bioinformática: busca de padrões em sequências de DNA/proteínas.",
                                "Análise de Algoritmos: prova de O(m) via amortização.",
                                "Engenharia de Software: otimizações em bibliotecas de busca (ex: std::search)."
                              ],
                              "realWorldApplication": "Essas tabelas aceleram a busca de padrões em textos grandes, usadas em ferramentas como GNU grep (com variantes Boyer-Moore), editores como Vim para 'search', bibliotecas de programação (Python re, Java Pattern), bioinformática (BLAST para genes), antivírus (detecção de signatures) e motores de busca web para indexação eficiente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.6.2.3",
                            "name": "Aplicar a heurística de sufixos bons na busca",
                            "description": "Ao mismatch após match de sufixo de comprimento l, usar gs[l] como shift; se mismatch no início do sufixo, usar shift para a próxima possível ocorrência do sufixo no padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o match de sufixo bom durante comparação da direita para a esquerda",
                                  "subSteps": [
                                    "Alinhe o padrão P (tamanho m) com o texto T na posição atual j.",
                                    "Inicie a comparação em P[m-1] com T[j + m - 1], prosseguindo para a esquerda até P[0] com T[j].",
                                    "Registre a posição i do primeiro mismatch onde P[i] ≠ T[j + i].",
                                    "Calcule o comprimento do sufixo bom l = m - i - 1 (número de caracteres que coincidiram do final até i+1).",
                                    "Confirme que l > 0 indica um sufixo bom matchado."
                                  ],
                                  "verification": "Desenhe o alinhamento e confirme que l está correto comparando manualmente os caracteres.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhar alinhamentos",
                                    "Exemplo de padrão P e texto T"
                                  ],
                                  "tips": "Use barras verticais (|) para visualizar o alinhamento entre P e T e destaque mismatches.",
                                  "learningObjective": "Dominar a detecção precisa do comprimento l de sufixos bons em comparações reversas.",
                                  "commonMistakes": [
                                    "Iniciar comparação da esquerda para a direita.",
                                    "Calcular l incorretamente (use l = m - i - 1).",
                                    "Ignorar l=0 como caso sem sufixo bom."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Consultar a tabela gs[l] e aplicar o shift básico",
                                  "subSteps": [
                                    "Acesse a tabela pré-computada gs para o valor gs[l].",
                                    "Entenda que gs[l] é o shift mínimo para alinhar a próxima possível ocorrência do sufixo de comprimento l no padrão.",
                                    "Atualize a posição j no texto: novo j = j + gs[l].",
                                    "Re-alinhe o padrão na nova posição e prepare para próxima comparação.",
                                    "Registre o shift aplicado para rastrear a otimização."
                                  ],
                                  "verification": "Verifique se o novo alinhamento posiciona corretamente o sufixo l sobre uma possível match futura.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela gs pré-computada para o padrão",
                                    "Papel para anotar shifts"
                                  ],
                                  "tips": "Lembre-se: gs[l] é sempre ≥1 para evitar loops infinitos.",
                                  "learningObjective": "Aplicar shifts de sufixos bons para pular seções irrelevantes do texto eficientemente.",
                                  "commonMistakes": [
                                    "Usar índice errado na tabela (sempre gs[l], não gs[i]).",
                                    "Confundir gs com tabela de bad character.",
                                    "Aplicar shift = l em vez de gs[l]."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Tratar o caso especial de mismatch no início do sufixo",
                                  "subSteps": [
                                    "Identifique se o mismatch ocorre imediatamente antes do sufixo matchado (i = m - l - 1).",
                                    "Nesse caso, gs[l] reflete a distância para a próxima ocorrência do sufixo l dentro do próprio padrão.",
                                    "Se o sufixo l não ocorre novamente, gs[l] = m (ou m - l + 1 dependendo da implementação).",
                                    "Aplique o shift gs[l] para alinhar essa ocorrência anterior ou pular adequadamente.",
                                    "Confirme que o shift maximiza o salto sem perder matches possíveis."
                                  ],
                                  "verification": "Simule o alinhamento pós-shift e veja se o sufixo l está alinhado com sua próxima instância no padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Padrão com sufixos sobrepostos",
                                    "Tabela gs detalhada"
                                  ],
                                  "tips": "Pré-compute gs considerando sobreposições de sufixos para shifts ótimos.",
                                  "learningObjective": "Gerenciar shifts em padrões com sufixos repetidos ou únicos corretamente.",
                                  "commonMistakes": [
                                    "Tratar como caso normal e usar shift=1.",
                                    "Ignorar sobreposições no padrão.",
                                    "Usar shift = m sempre no caso especial."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular a aplicação completa da heurística em uma busca de exemplo",
                                  "subSteps": [
                                    "Selecione um padrão e texto exemplo e compute/obtenha tabela gs.",
                                    "Execute a busca Boyer-Moore aplicando good suffix em múltiplos alinhamentos.",
                                    "Combine com bad character rule tomando max(shift_badchar, gs[l]).",
                                    "Conte o número de comparações e verifique todas ocorrências encontradas.",
                                    "Compare a eficiência com busca ingênua."
                                  ],
                                  "verification": "A simulação encontra todas as ocorrências com número reduzido de comparações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel ou editor de código para simulação",
                                    "Exemplo completo P e T"
                                  ],
                                  "tips": "Registre cada step com j inicial, l, gs[l], novo j para auditoria.",
                                  "learningObjective": "Integrar a heurística de sufixos bons na execução completa do Boyer-Moore.",
                                  "commonMistakes": [
                                    "Não combinar com bad char (use max).",
                                    "Off-by-one em índices de j.",
                                    "Parar após primeiro match sem continuar."
                                  ]
                                }
                              ],
                              "practicalExample": "Padrão P = \"abcab\" (m=5), tabela gs = [5, 3, 2, 0, 0] (ex: gs[2]=2 pois sufixo 'ab' ocorre em pos 0-1 e 3-4). Texto T = \"xxabcabcab\". Em alinhamento j=2: comparações da direita: b==b, a==a (l=2), c!=c? Suponha mismatch em c vs x, então l=2, shift gs[2]=2, novo j=4, alinhando próxima 'ab' eficientemente.",
                              "finalVerifications": [
                                "Identifica l corretamente em alinhamentos com mismatch.",
                                "Aplica gs[l] para shifts precisos.",
                                "Gerencia casos especiais de mismatch inicial.",
                                "Simula busca completa sem perda de matches.",
                                "Demonstra redução no número de comparações.",
                                "Explica o papel de gs na otimização geral."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% no cálculo de l e gs[l].",
                                "Correta aplicação de shifts em 90%+ dos casos simulados.",
                                "Identificação e tratamento correto de casos especiais.",
                                "Eficiência comprovada (menos de 50% das comparações da busca naive).",
                                "Explicações claras sem erros conceituais.",
                                "Integração suave com outras regras do Boyer-Moore."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria das linguagens formais e autômatos de strings.",
                                "Engenharia de Software: Otimização de performance em algoritmos de string matching.",
                                "Ciência de Dados: Processamento eficiente de grandes volumes de texto e logs.",
                                "Biologia Computacional: Detecção de padrões em sequências genômicas."
                              ],
                              "realWorldApplication": "Aplicada no algoritmo Boyer-Moore para buscas ultrarrápidas em textos massivos, como em utilitários Unix grep/ag, editores como Vim/VSCode, indexação de motores de busca (Google), análise de logs em cibersegurança, e bioinformática para encontrar motivos em genomas (BLAST-like tools), reduzindo tempo de O(nm) para O(n/m) em casos médios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.2.1",
                              "10.1.3.6.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.3",
                        "name": "Algoritmo Boyer-Moore Completo",
                        "description": "Integração das heurísticas de caracteres ruins e sufixos bons, escolhendo o maior shift em cada passo para busca eficiente de padrão em texto.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.3.1",
                            "name": "Descrever a execução geral do algoritmo Boyer-Moore",
                            "description": "Iniciar com j=0 no texto T de tamanho n; comparar P de trás para frente; em mismatch, shift = max(bad_char_shift, good_suffix_shift); repetir até j >= n-m.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Inicialização e Configuração Prévia",
                                  "subSteps": [
                                    "Leia a descrição do texto T de tamanho n e o padrão P de tamanho m.",
                                    "Precompute as tabelas de shift: bad_char_shift (para cada caractere possível, shift baseado na última ocorrência em P) e good_suffix_shift (para cada sufixo de P).",
                                    "Inicialize a posição j = 0 no texto T.",
                                    "Verifique se m > n; se sim, não há match.",
                                    "Prepare para o loop principal enquanto j <= n - m."
                                  ],
                                  "verification": "Confirme que as tabelas de shift foram corretamente computadas para um exemplo pequeno e j está em 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhar tabelas",
                                    "Implementação de código em Python para pré-computação (opcional)"
                                  ],
                                  "tips": "Comece com strings pequenas para visualizar as tabelas de shift claramente.",
                                  "learningObjective": "Compreender como o algoritmo se prepara antes da busca principal, incluindo pré-computação de shifts.",
                                  "commonMistakes": [
                                    "Confundir bad_char_shift com good_suffix_shift",
                                    "Esquecer de inicializar j=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a Comparação de Trás para Frente",
                                  "subSteps": [
                                    "Comece comparando o último caractere de P com T[j + m - 1].",
                                    "Continue comparando para trás (i = m-1 downto 0) até encontrar mismatch ou match completo.",
                                    "Se match completo (todos caracteres iguais), retorne a posição j.",
                                    "Registre a posição do mismatch k onde T[j + k] != P[k].",
                                    "Pule para cálculo de shift se houver mismatch."
                                  ],
                                  "verification": "Simule a comparação em um exemplo e anote se o match ou mismatch foi detectado corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de texto e padrão impresso",
                                    "Simulador online de Boyer-Moore (se disponível)"
                                  ],
                                  "tips": "Desenhe setas apontando para trás na string para visualizar a comparação.",
                                  "learningObjective": "Dominar o processo de alinhamento e comparação reversa do padrão no texto.",
                                  "commonMistakes": [
                                    "Comparar da esquerda para direita em vez de trás para frente",
                                    "Perder o índice k do mismatch"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Aplicar o Shift em Caso de Mismatch",
                                  "subSteps": [
                                    "Para o caractere mismatched T[j + k], calcule bad_char_shift: distância da última ocorrência desse caractere em P para o final de P.",
                                    "Calcule good_suffix_shift para o sufixo a partir do mismatch: o maior shift que mantém o sufixo bom alinhado.",
                                    "Defina shift = max(bad_char_shift[T[j + k]], good_suffix_shift[k]).",
                                    "Atualize j = j + shift.",
                                    "Se shift == 0, incremente j em 1 para evitar loop infinito."
                                  ],
                                  "verification": "Calcule shifts para um mismatch específico e verifique se j avança corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabelas de shift pré-computadas",
                                    "Calculadora ou planilha para shifts"
                                  ],
                                  "tips": "Sempre pegue o máximo dos dois shifts para otimização.",
                                  "learningObjective": "Aprender a heurística de shift que torna o algoritmo eficiente.",
                                  "commonMistakes": [
                                    "Usar min em vez de max para shifts",
                                    "Ignorar good_suffix_shift quando maior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar o Loop Principal e Condições de Parada",
                                  "subSteps": [
                                    "Repita o processo de comparação e shift enquanto j <= n - m.",
                                    "Se j > n - m, pare: não há mais posições possíveis.",
                                    "Se match encontrado em qualquer iteração, registre todas as ocorrências.",
                                    "Opcionalmente, continue para múltiplos matches ajustando j após match.",
                                    "Documente o número total de comparações feitas."
                                  ],
                                  "verification": "Execute o loop completo em um exemplo e liste todas as posições j visitadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo completo de T e P",
                                    "Pseudocódigo do algoritmo"
                                  ],
                                  "tips": "Conte o número de comparações para apreciar a eficiência vs. busca ingênua.",
                                  "learningObjective": "Entender o fluxo iterativo completo até a conclusão.",
                                  "commonMistakes": [
                                    "Parar cedo se j == n-m",
                                    "Não lidar com múltiplos matches"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar a Execução Geral e Complexidade",
                                  "subSteps": [
                                    "Resuma os passos em um fluxograma.",
                                    "Compare com busca ingênua: destaque skips grandes via shifts.",
                                    "Discuta complexidade: O(n/m) no pior caso prático.",
                                    "Teste com casos edge: P vazio, P maior que T, todos caracteres iguais.",
                                    "Explique por que compara de trás para frente otimiza shifts."
                                  ],
                                  "verification": "Crie um fluxograma e teste casos edge sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma como Draw.io",
                                    "Casos de teste variados"
                                  ],
                                  "tips": "Use cores no fluxograma para match, mismatch e shifts.",
                                  "learningObjective": "Sintetizar a visão geral da execução e suas vantagens.",
                                  "commonMistakes": [
                                    "Subestimar complexidade prática",
                                    "Ignorar casos edge"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto T = 'ABAAABCDABAAABCDABAAABCD', Padrão P = 'ABCD'. Inicial j=0, compara de trás: mismatch em D vs A, bad_char_shift[D]=4 (não em P? ajuste), good_suffix=0, shift=1 ou mais. Continua até match em posições 5,13,21, pulando eficientemente.",
                              "finalVerifications": [
                                "Pode descrever verbalmente os 4 passos principais sem consultar notas.",
                                "Simula corretamente a execução em um exemplo com pelo menos 2 mismatches e 1 match.",
                                "Calcula shifts corretamente para um mismatch arbitrário.",
                                "Identifica quando o algoritmo para e por quê.",
                                "Explica a diferença entre bad_char e good_suffix shifts.",
                                "Compara número de comparações com busca linear no mesmo exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da comparação reversa (deve ser 100% correta).",
                                "Correção no cálculo de shifts (max de bad_char e good_suffix).",
                                "Completude do loop: inclui inicialização, mismatch handling e parada.",
                                "Uso correto de heurísticas para eficiência.",
                                "Capacidade de aplicar em exemplo prático sem erros.",
                                "Clareza na explicação de pré-computação de tabelas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de strings e funções de shift como automatos finitos.",
                                "Engenharia de Software: Otimização de algoritmos em busca de texto (ex: editores).",
                                "Física/Química: Padrões em sequências genéticas ou espectros (bioinformática).",
                                "Linguística: Análise de padrões em corpora de texto.",
                                "Estatística: Análise de complexidade média em textos reais."
                              ],
                              "realWorldApplication": "Usado em ferramentas como grep, editores de texto (VS Code, Sublime), busca em DNA (bioinformática), antivírus para assinaturas de malware e motores de busca de arquivos em sistemas operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.1.1",
                              "10.1.3.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.6.3.2",
                            "name": "Implementar o algoritmo Boyer-Moore em pseudocódigo",
                            "description": "Escrever pseudocódigo com pré-processamento de tabelas bc e gs, loop principal com comparações reversas e escolha de shift máximo, reportando posições de match.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar o Pré-processamento da Tabela Bad Character (BC)",
                                  "subSteps": [
                                    "Defina o alfabeto possível (ex: caracteres ASCII) e inicialize a tabela BC com shift igual ao tamanho do padrão (m).",
                                    "Para cada posição i no padrão (de 0 a m-2), defina bc[padrão[i]] = m - 1 - i.",
                                    "Para o último caractere do padrão, defina bc[padrão[m-1]] = m.",
                                    "Trate caracteres não presentes no padrão atribuindo shift = m.",
                                    "Teste a tabela com um exemplo simples para validar shifts."
                                  ],
                                  "verification": "Execute a função de pré-processamento com um padrão exemplo e imprima a tabela BC; verifique se os shifts estão corretos manualmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para esboços",
                                    "Editor de texto ou IDE para pseudocódigo",
                                    "Referência ao algoritmo Boyer-Moore"
                                  ],
                                  "tips": "Comece com um alfabeto pequeno para depuração; use um array indexado por código ASCII.",
                                  "learningObjective": "Compreender e codificar a heurística bad character para skips eficientes em mismatches.",
                                  "commonMistakes": [
                                    "Esquecer de tratar caracteres ausentes no padrão",
                                    "Índices off-by-one no cálculo de shifts",
                                    "Não inicializar todos os entradas da tabela"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Pré-processamento da Tabela Good Suffix (GS)",
                                  "subSteps": [
                                    "Inicialize duas tabelas auxiliares: uma para shifts de good suffix e outra para good suffix propriamente dita.",
                                    "Preencha a tabela de good suffix comparando sufixos do padrão com o padrão inteiro (Z-algorithm like).",
                                    "Para cada posição i, compute o maior shift onde o sufixo após i combina com algum prefixo.",
                                    "Ajuste shifts para casos onde o sufixo não é bom, usando o shift do caractere mismatched.",
                                    "Valide com um padrão exemplo, como 'ABCDABD', calculando shifts manualmente."
                                  ],
                                  "verification": "Imprima a tabela GS para um padrão teste e compare com valores esperados de uma implementação de referência.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Referência detalhada do Boyer-Moore GS",
                                    "Ferramenta de depuração para arrays",
                                    "Exemplos de padrões com sufixos repetidos"
                                  ],
                                  "tips": "Use loops duplos otimizados; foque em eficiência O(m) aproximada.",
                                  "learningObjective": "Dominar a heurística good suffix para maximizar shifts em matches parciais.",
                                  "commonMistakes": [
                                    "Confundir shifts de prefixo e sufixo",
                                    "Não lidar com o caso de todo o padrão como good suffix",
                                    "Erros em comparações de strings invertidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar o Loop Principal com Comparações Reversas",
                                  "subSteps": [
                                    "Inicialize posição s = 0 no texto.",
                                    "Enquanto s <= n - m (n=tamanho texto, m=tamanho padrão):",
                                    "  Alinhe padrão no texto em s e compare do final para o início (j = m-1 downto 0).",
                                    "  Se mismatch em j, pare e compute shift.",
                                    "  Se match completo (j==-1), reporte s e avance s por 1 (ou otimize).",
                                    "Integre verificação de match completo."
                                  ],
                                  "verification": "Simule o loop com texto e padrão pequenos, rastreando posições de comparação manualmente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de texto e padrões",
                                    "Debugger ou simulador de pseudocódigo"
                                  ],
                                  "tips": "Comparações reversas aceleram detecção de mismatches iniciais; use índices relativos.",
                                  "learningObjective": "Implementar a busca reversa central do Boyer-Moore para eficiência sublinear.",
                                  "commonMistakes": [
                                    "Comparar na ordem errada (frente para trás)",
                                    "Off-by-one em limites de loop",
                                    "Não avançar s corretamente após match"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Regras de Shift Máximo e Reportar Matches",
                                  "subSteps": [
                                    "Em mismatch em posição j: compute shift_bc = j - bc[texto[s+j]].",
                                    "  Compute shift_gs baseado na tabela GS para o sufixo mismatched.",
                                    "  Escolha shift = max(shift_bc, shift_gs).",
                                    "  Avance s += shift.",
                                    "Colete e retorne lista de posições de matches.",
                                    "Adicione tratamento de borda: s + m > n."
                                  ],
                                  "verification": "Rode o pseudocódigo completo em 3-5 casos teste, comparando saídas com busca ingênua ou KMP.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Casos de teste variados (padrões longos, curtos, texto com/ sem matches)",
                                    "Referência de complexidade O(n/m)"
                                  ],
                                  "tips": "Sempre pegue o shift maior para pular mais; debugue shifts com prints.",
                                  "learningObjective": "Combinar heurísticas BC e GS para shifts ótimos e reporting preciso.",
                                  "commonMistakes": [
                                    "Escolher shift mínimo em vez de máximo",
                                    "Índice errado em texto[s+j]",
                                    "Não reportar múltiplos overlaps"
                                  ]
                                }
                              ],
                              "practicalExample": "Padrão: 'ABCDABD', Texto: 'ABCDABCDABDE'. Pré-processe BC e GS, execute loop: matches em posições 0 e 4. Demonstre shifts: mismatch leva a skip de 3 via GS.",
                              "finalVerifications": [
                                "Tabelas BC e GS geram shifts corretos para padrão teste.",
                                "Loop detecta todos matches sem falsos positivos.",
                                "Shifts máximos são aplicados corretamente em mismatches.",
                                "Pseudocódigo lida com padrões/ textos vazios ou iguais.",
                                "Complexidade simulada é sublinear (menos comparações que n*m).",
                                "Posições reportadas estão em ordem crescente."
                              ],
                              "assessmentCriteria": [
                                "Correção das tabelas de pré-processamento (BC e GS validadas).",
                                "Implementação precisa do loop reverso sem erros de índice.",
                                "Lógica de shift max(BC, GS) funcional e otimizada.",
                                "Report de matches completo e preciso.",
                                "Pseudocódigo legível, com comentários e tratamento de bordas.",
                                "Eficiência demonstrada em testes com múltiplos casos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Strings e Autômatos Finitos.",
                                "Engenharia de Software: Otimização de Algoritmos e Profiling.",
                                "Processamento de Dados: Aplicações em Bioinformática (busca de sequências DNA).",
                                "Física Computacional: Simulações com padrões periódicos.",
                                "Cibersegurança: Detecção de assinaturas em scans de malware."
                              ],
                              "realWorldApplication": "Usado em editores de texto (grep, Vim), busca de arquivos (anti-vírus como ClamAV), indexação de motores de busca e análise genômica para alinhamento de sequências rápidas em grandes datasets."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.1.2",
                              "10.1.3.6.1.3",
                              "10.1.3.6.2.2",
                              "10.1.3.6.2.3"
                            ]
                          },
                          {
                            "id": "10.1.3.6.3.3",
                            "name": "Analisar a complexidade do algoritmo Boyer-Moore",
                            "description": "Explicar tempo de pré-processamento O(m + |Σ|), pior caso O(n m), mas médio O(n / m), sublinear em prática para padrões longos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo Boyer-Moore e suas Fases Principais",
                                  "subSteps": [
                                    "Estude a estrutura geral do algoritmo: pré-processamento (tabelas de bad character e good suffix) e fase de busca.",
                                    "Identifique os componentes chave: shift rules baseadas em mismatches e matches.",
                                    "Desenhe um diagrama de fluxo do algoritmo para visualizar as comparações realizadas.",
                                    "Liste as variáveis: n (comprimento do texto), m (comprimento do padrão), |Σ| (tamanho do alfabeto).",
                                    "Explique como o algoritmo pula caracteres usando as heurísticas."
                                  ],
                                  "verification": "Crie um resumo de 1 página descrevendo as fases e confirme com um colega ou autoavaliação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pseudocódigo do Boyer-Moore",
                                    "Diagrama do algoritmo",
                                    "Notas de aula sobre emparelhamento de padrões"
                                  ],
                                  "tips": "Use cores diferentes para bad character (azul) e good suffix (verde) no diagrama para diferenciar heurísticas.",
                                  "learningObjective": "Compreender as fases do algoritmo para basear a análise de complexidade.",
                                  "commonMistakes": [
                                    "Confundir bad character com good suffix",
                                    "Ignorar o impacto das heurísticas de salto no número de comparações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Complexidade do Pré-processamento",
                                  "subSteps": [
                                    "Analise a construção da tabela bad character: para cada caractere em Σ, defina o shift (O(|Σ|)).",
                                    "Analise a tabela good suffix: para cada posição no padrão, compute shifts (O(m^2) na implementação ingênua, mas otimizada para O(m + |Σ|)).",
                                    "Some as complexidades: O(m) para percorrer o padrão + O(|Σ|) para heurística de caractere ruim.",
                                    "Justifique por que é O(m + |Σ|) no total.",
                                    "Implemente um exemplo simples em pseudocódigo para medir o tempo."
                                  ],
                                  "verification": "Escreva a notação big-O para pré-processamento e teste com padrões de tamanhos variados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Implementação em Python ou pseudocódigo",
                                    "Exemplos de padrões: 'abc', 'mississippi'"
                                  ],
                                  "tips": "Lembre-se que |Σ| é fixo em prática (ex: 256 para ASCII), tornando-o eficiente.",
                                  "learningObjective": "Dominar a análise assintótica do pré-processamento.",
                                  "commonMistakes": [
                                    "Superestimar como O(m |Σ|)",
                                    "Esquecer otimizações na good suffix"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Complexidade no Pior Caso",
                                  "subSteps": [
                                    "Descreva o pior caso: quando shifts são mínimos (ex: padrão todo 'a's, texto todo 'a's seguido de mismatch).",
                                    "Conte o número máximo de comparações: até m por posição no texto, total O(n m).",
                                    "Construa um exemplo adversarial: texto 'a'*n + 'b', padrão 'a'*m.",
                                    "Prove formalmente: em cada tentativa, pode comparar até m caracteres antes de shift 1.",
                                    "Compare com naive string search (também O(n m))."
                                  ],
                                  "verification": "Gere um par texto/padrão pior-caso e rode o algoritmo contando comparações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Boyer-Moore com contador de comparações",
                                    "Ferramenta de profiling como timeit em Python"
                                  ],
                                  "tips": "Use strings longas (n=10^5, m=10^3) para observar o O(n m).",
                                  "learningObjective": "Identificar e provar o bound superior no pior caso.",
                                  "commonMistakes": [
                                    "Achar que heurísticas evitam sempre O(n m)",
                                    "Confundir com caso médio"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade no Caso Médio e Prática Sublinear",
                                  "subSteps": [
                                    "Explique modelo probabilístico: assume texto aleatório, padrão fixo.",
                                    "Derive O(n / m): shifts médios são proporcionais a m devido a heurísticas.",
                                    "Discuta sublinearidade prática: para padrões longos, saltos grandes reduzem comparações para < n.",
                                    "Cite análises teóricas (ex: Boyer-Moore é O(n / m) em média).",
                                    "Teste empiricamente com textos reais (ex: DNA, código fonte)."
                                  ],
                                  "verification": "Rode experimentos em datasets variados e plote comparações vs. n.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Datasets: texto inglês, DNA sequences",
                                    "Gráficos com matplotlib",
                                    "Referências teóricas (paper original Boyer-Moore)"
                                  ],
                                  "tips": "Compare com KMP para validar eficiência prática.",
                                  "learningObjective": "Entender por que Boyer-Moore é superior na prática apesar do pior caso.",
                                  "commonMistakes": [
                                    "Ignorar dependência em |Σ| e distribuição de caracteres",
                                    "Generalizar pior caso para todos"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o padrão 'algorithm' (m=8) em um texto de 1MB de um livro (n=1e6). Pré-processamento: O(8+256). Pior caso teórico O(1e6*8)=8e6, mas prática: ~1e6/8=125k comparações devido a saltos em mismatches como 'a' vs 'l'.",
                              "finalVerifications": [
                                "Explica corretamente O(m + |Σ|) para pré-processamento?",
                                "Identifica e exemplifica O(n m) no pior caso?",
                                "Deriva ou cita O(n / m) para caso médio?",
                                "Discute sublinearidade prática com evidências?",
                                "Compara com outros algoritmos como KMP?",
                                "Aplica análise a um exemplo concreto?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação big-O (100% correto)",
                                "Uso de exemplos concretos e experimentos (mínimo 2)",
                                "Profundidade na distinção pior/medio caso (detalhes heurísticas)",
                                "Clareza na explicação oral/escrita",
                                "Evidências empíricas de testes",
                                "Conexão com teoria assintótica"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e notação Big-O/Theta",
                                "Probabilidade: Modelos para análise de caso médio",
                                "Estatística: Experimentos empíricos e profiling",
                                "Engenharia de Software: Otimização de algoritmos em busca de texto"
                              ],
                              "realWorldApplication": "Usado em editores como grep/vi para busca rápida em arquivos grandes, scanners de antivírus para padrões de malware, e indexação de busca em bancos de dados de texto (ex: Google-like string matching em logs)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.3.1",
                              "10.1.3.6.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Paradigmas de Programação",
                "description": "Exploração de divisão e conquista, método guloso e programação dinâmica para o design de algoritmos eficientes.",
                "totalSkills": 29,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Paradigma de Divisão e Conquista",
                    "description": "Técnica que divide problemas em subproblemas independentes, resolve recursivamente e combina soluções para eficiência.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Definição e Princípios do Paradigma de Divisão e Conquista",
                        "description": "Compreensão dos fundamentos do paradigma, incluindo a divisão de problemas em subproblemas independentes, resolução recursiva e combinação de soluções para alcançar eficiência computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Definir o paradigma de divisão e conquista",
                            "description": "Explicar detalhadamente a técnica que divide um problema em subproblemas menores e independentes, resolve-os de forma recursiva e combina as soluções parciais para formar a solução completa do problema original, destacando sua aplicação em problemas de grande escala.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico do Paradigma de Divisão e Conquista",
                                  "subSteps": [
                                    "Leia a definição formal: 'Divisão e Conquista (D&C) é um paradigma algorítmico que resolve problemas dividindo-os em subproblemas menores e independentes.'",
                                    "Identifique os três componentes principais: Dividir (break down), Conquistar (solve subproblems), Combinar (merge solutions).",
                                    "Compare com abordagens lineares para destacar a eficiência em problemas de grande escala.",
                                    "Anote em suas palavras o que significa 'subproblemas independentes'.",
                                    "Visualize um diagrama simples de árvore de recursão."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o conceito básico e os três componentes principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Diagrama de exemplo de D&C (impresso ou online)"
                                  ],
                                  "tips": "Use analogias cotidianas, como dividir uma pizza em fatias para comer mais facilmente.",
                                  "learningObjective": "Entender a essência do paradigma D&C e seus componentes fundamentais.",
                                  "commonMistakes": [
                                    "Confundir com iteração simples",
                                    "Ignorar a independência dos subproblemas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Recursão e Independência dos Subproblemas",
                                  "subSteps": [
                                    "Estude como a recursão é aplicada: a função chama a si mesma em subproblemas menores até base case.",
                                    "Diferencie subproblemas independentes (não dependem uns dos outros) de dependentes (como em programação dinâmica).",
                                    "Implemente pseudocódigo recursivo simples para um problema como soma de array.",
                                    "Discuta por que independência permite paralelização e eficiência.",
                                    "Resolva um exercício: divida 'calcular fatorial' em subproblemas."
                                  ],
                                  "verification": "Crie pseudocódigo recursivo para um problema simples e explique a independência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código ou papel para pseudocódigo",
                                    "Referência de recursão básica"
                                  ],
                                  "tips": "Sempre defina o caso base para evitar recursão infinita.",
                                  "learningObjective": "Dominar o papel da recursão e independência no D&C.",
                                  "commonMistakes": [
                                    "Esquecer o caso base",
                                    "Assumir dependência entre subproblemas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar as Etapas Detalhadas: Dividir, Conquistar e Combinar",
                                  "subSteps": [
                                    "Detalhe 'Dividir': quebrar em subproblemas de tamanho metade ou constante menor.",
                                    "Detalhe 'Conquistar': resolver recursivamente ou diretamente se pequeno.",
                                    "Detalhe 'Combinar': mesclar soluções de forma eficiente (ex: merge em O(n)).",
                                    "Trace um exemplo passo a passo em um fluxograma.",
                                    "Calcule complexidade: T(n) = 2T(n/2) + O(n) para Merge Sort.",
                                    "Compare tempo com abordagem ingênua."
                                  ],
                                  "verification": "Desenhe um fluxograma das três etapas com um exemplo numérico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (Draw.io ou papel)",
                                    "Calculadora para análise de complexidade"
                                  ],
                                  "tips": "Foque na eficiência do combine; é onde a magia acontece.",
                                  "learningObjective": "Mapear precisamente as três etapas do paradigma.",
                                  "commonMistakes": [
                                    "Subestimar custo do combine",
                                    "Não reduzir tamanho uniformemente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Sintetizar a Definição Completa",
                                  "subSteps": [
                                    "Escreva uma definição completa em 200 palavras, incluindo recursão, independência e aplicações em escala.",
                                    "Identifique problemas ideais para D&C (ex: ordenação, busca).",
                                    "Discuta limitações: overhead de recursão em problemas pequenos.",
                                    "Crie uma tabela comparando D&C com outros paradigmas.",
                                    "Teste sua definição explicando para um 'parceiro de estudo' fictício."
                                  ],
                                  "verification": "Produza uma definição escrita e tabela comparativa revisada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Tabela modelo de paradigmas"
                                  ],
                                  "tips": "Inclua fórmula de recorrência para credibilidade.",
                                  "learningObjective": "Formular uma definição precisa e contextualizada do paradigma.",
                                  "commonMistakes": [
                                    "Definição superficial sem exemplos",
                                    "Omitir aplicações em grande escala"
                                  ]
                                }
                              ],
                              "practicalExample": "No Merge Sort: Divida array em metades recursivamente (divide), ordene subarrays (conquista), mescle ordenados (combine). Para [8,3,7,1], divide em [8,3] e [7,1], ordena subarrays, mescla em [1,3,7,8].",
                              "finalVerifications": [
                                "Pode listar e explicar os três passos principais do D&C?",
                                "Consegue escrever pseudocódigo recursivo com caso base?",
                                "Identifica subproblemas independentes em um exemplo?",
                                "Explica por que D&C é ideal para problemas de grande escala?",
                                "Traça a recursão em uma árvore para Merge Sort?",
                                "Compara complexidade T(n) = 2T(n/2) + O(n)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição dos componentes (dividir, conquistar, combinar)",
                                "Compreensão clara de recursão e independência",
                                "Uso correto de exemplos e pseudocódigo",
                                "Análise de complexidade e aplicações em escala",
                                "Identificação de limitações e erros comuns",
                                "Clareza e estrutura na explicação escrita"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências e análise assintótica (O(n log n))",
                                "Física: Modelagem de sistemas hierárquicos (ex: simulações de partículas)",
                                "Engenharia: Otimização de processos industriais em etapas",
                                "Economia: Decomposição de problemas de otimização em submercados"
                              ],
                              "realWorldApplication": "Usado em bibliotecas padrão como std::sort no C++ (Merge Sort/Quick Sort híbrido) para ordenar terabytes de dados em bancos de dados e motores de busca como Google, reduzindo tempo de processamento de dias para minutos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Identificar os três passos principais",
                            "description": "Reconhecer e descrever os passos divide (divisão do problema), conquer (conquista recursiva dos subproblemas) e combine (combinação das soluções), com exemplos simples como busca binária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Definições dos Três Passos Principais",
                                  "subSteps": [
                                    "Leia a definição do passo 'Divide': quebrar o problema original em subproblemas menores e independentes.",
                                    "Estude o passo 'Conquer': resolver recursivamente os subproblemas de forma base ou trivial.",
                                    "Analise o passo 'Combine': mesclar as soluções dos subproblemas para formar a solução do problema original.",
                                    "Compare os três passos em uma tabela simples para fixar as diferenças.",
                                    "Resuma cada passo em uma frase curta."
                                  ],
                                  "verification": "Escreva um resumo de 3 frases, uma para cada passo, e verifique se cobrem divisão, resolução recursiva e combinação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Diagrama ilustrativo de Divide and Conquer (busque online)"
                                  ],
                                  "tips": "Use analogias cotidianas, como dividir uma pizza (divide), comer fatias (conquer), montar o todo (combine).",
                                  "learningObjective": "Memorizar e diferenciar precisamente os três passos fundamentais do paradigma.",
                                  "commonMistakes": "Confundir 'Conquer' com iteração em vez de recursão; ignorar a independência dos subproblemas no 'Divide'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar um Exemplo Simples: Busca Binária",
                                  "subSteps": [
                                    "Revise o algoritmo de busca binária em uma lista ordenada.",
                                    "Identifique o 'Divide': calcular o ponto médio e dividir a lista em duas metades.",
                                    "Localize o 'Conquer': recursão nas metades até encontrar o elemento ou chegar ao fim.",
                                    "Encontre o 'Combine': retornar o resultado da recursão sem necessidade de combinação complexa (caso base).",
                                    "Desenhe um fluxograma destacando cada passo."
                                  ],
                                  "verification": "Rotule um pseudocódigo de busca binária com D, C, C e explique para si mesmo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pseudocódigo de busca binária impresso ou digital",
                                    "Ferramenta de desenho como Draw.io ou papel"
                                  ],
                                  "tips": "Execute mentalmente com uma lista exemplo: [1,3,5,7,9], buscando 5.",
                                  "learningObjective": "Aplicar os três passos a um algoritmo familiar para reconhecimento prático.",
                                  "commonMistakes": "Omitir recursão no 'Conquer'; achar que busca binária não combina por ser simples."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Identificação em Outro Exemplo: Merge Sort",
                                  "subSteps": [
                                    "Estude o algoritmo Merge Sort.",
                                    "Marque o 'Divide': dividir recursivamente a lista até listas de um elemento.",
                                    "Identifique o 'Conquer': listas de um elemento são casos base (já ordenadas).",
                                    "Destaque o 'Combine': mesclar listas ordenadas adjacentes.",
                                    "Compare com busca binária para padrões comuns."
                                  ],
                                  "verification": "Crie um diagrama de árvore para Merge Sort de 8 elementos, rotulando cada nó com D/C/C.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplo de lista para ordenar: [38,27,43,3,9,82,10]",
                                    "Vídeo tutorial curto de Merge Sort (opcional)"
                                  ],
                                  "tips": "Pense em 'Combine' como 'colar' fatias ordenadas de volta.",
                                  "learningObjective": "Generalizar a identificação dos passos para algoritmos de ordenação.",
                                  "commonMistakes": "Confundir 'Conquer' com merge; subestimar o papel recursivo no 'Divide'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever e Testar Independente",
                                  "subSteps": [
                                    "Escolha um algoritmo novo como Closest Pair of Points.",
                                    "Descreva os três passos em parágrafos curtos.",
                                    "Crie um exemplo próprio simples e rotule os passos.",
                                    "Explique verbalmente ou grave áudio identificando os passos.",
                                    "Revise erros anteriores e ajuste."
                                  ],
                                  "verification": "Escreva uma descrição de 200 palavras de um algoritmo rotulando D/C/C corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Lista de algoritmos Divide and Conquer (Wikipedia)"
                                  ],
                                  "tips": "Use flashcards: um lado definição, outro exemplo rotulado.",
                                  "learningObjective": "Desenvolver autonomia para identificar passos em qualquer contexto.",
                                  "commonMistakes": "Forçar os passos em algoritmos não-D&C; descrições vagas sem exemplos."
                                }
                              ],
                              "practicalExample": "Em busca binária para encontrar 7 em [1,3,5,7,9,11]: Divide (ponto médio 5, divide em [1,3,5] e [7,9,11]); Conquer (recursão em direita até achar 7); Combine (retorna o índice encontrado).",
                              "finalVerifications": [
                                "Lista corretamente os três passos com definições precisas.",
                                "Identifica D/C/C em busca binária e Merge Sort sem erros.",
                                "Descreve passos em um exemplo novo com diagrama.",
                                "Explica diferenças entre Conquer recursivo e casos base.",
                                "Diferencia de outros paradigmas como Greedy.",
                                "Cria fluxograma rotulado para qualquer algoritmo D&C."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições: 100% cobertura de divide, conquer recursivo, combine.",
                                "Uso correto de exemplos: pelo menos dois algoritmos analisados.",
                                "Profundidade de subpassos: cada passo justificado com lógica.",
                                "Clareza na descrição: linguagem acessível e sem ambiguidades.",
                                "Criatividade: exemplo próprio viável e rotulado.",
                                "Ausência de erros comuns: recursão destacada, independência de subproblemas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recursão e indução matemática.",
                                "Física: Divisão de problemas complexos em partículas elementares.",
                                "Engenharia: Decomposição de sistemas em módulos (design modular).",
                                "Gestão: Estratégias de divide et impera em projetos.",
                                "Biologia: Divisão celular e recombinação genética."
                              ],
                              "realWorldApplication": "Desenvolvimento de software eficiente (ex: ordenação em bancos de dados com Merge Sort), otimização de buscas em apps (busca binária em dicionários), análise de dados em IA (algoritmos D&C para big data), e resolução de problemas em empresas dividindo tarefas complexas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Diferenciar de outros paradigmas",
                            "description": "Comparar o paradigma de divisão e conquista com programação dinâmica e método guloso, enfatizando a independência dos subproblemas e ausência de sobreposição em relação à sobreposição em PD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Princípios Fundamentais do Paradigma Divisão e Conquista (DC)",
                                  "subSteps": [
                                    "Defina DC: um problema é dividido em subproblemas independentes menores, resolvidos recursivamente e combinados.",
                                    "Identifique os componentes chave: divide (partir), conquer (resolver base), combine (juntar resultados).",
                                    "Enfatize independência: subproblemas não se sobrepõem e são resolvidos uma vez.",
                                    "Estude recorrência típica: T(n) = a*T(n/b) + f(n).",
                                    "Examine exemplo simples: Merge Sort."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras sobre DC e verifique se menciona independência de subproblemas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre DC",
                                    "Vídeo Khan Academy: Divide and Conquer"
                                  ],
                                  "tips": "Desenhe um diagrama de árvore de recursão para visualizar a independência.",
                                  "learningObjective": "Compreender os pilares de DC e sua característica de subproblemas independentes.",
                                  "commonMistakes": "Confundir DC com recursão simples sem combinação explícita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Programação Dinâmica (PD) e suas Diferenças Iniciais com DC",
                                  "subSteps": [
                                    "Defina PD: resolve problemas com subproblemas sobrepostos e estrutura ótima, usando memoização ou tabela bottom-up.",
                                    "Identifique sobreposição: mesmos subproblemas resolvidos múltiplas vezes na recursão ingênua.",
                                    "Compare com DC: PD lida com sobreposição ausente em DC; DC tem subproblemas independentes.",
                                    "Estude recorrência: dp[i] depende de dp[j] para j < i.",
                                    "Exemplo: Fibonacci com memoização vs recursão DC-like (ineficiente)."
                                  ],
                                  "verification": "Crie uma tabela comparando DC e PD em 3 colunas: subproblemas, sobreposição, eficiência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de Fibonacci PD",
                                    "Artigo GeeksforGeeks: DP vs DC"
                                  ],
                                  "tips": "Use uma árvore de chamadas recursivas para destacar sobreposições em PD.",
                                  "learningObjective": "Diferenciar PD de DC focando em sobreposição de subproblemas.",
                                  "commonMistakes": "Achar que toda recursão é DC; ignorar necessidade de memoização em PD."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Método Guloso (MG) e Contrastes com DC e PD",
                                  "subSteps": [
                                    "Defina MG: faz escolhas localmente ótimas esperando global, com propriedade de escolha segura.",
                                    "Identifique ausência de garantias em subproblemas: não recursivo como DC/PD.",
                                    "Compare: MG não divide recursivamente (DC) nem usa sobreposição (PD); foca em ganância imediata.",
                                    "Verifique optimalidade: prova por troca ou matrioska.",
                                    "Exemplo: Seleção de Atividades vs Merge Sort (DC)."
                                  ],
                                  "verification": "Liste 2 problemas onde MG falha e DC/PD succeeds, explicando por quê.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de problemas gulosos",
                                    "Livro CLRS: Capítulo Guloso"
                                  ],
                                  "tips": "Pergunte: 'Essa escolha local leva ao ótimo global?' para validar MG.",
                                  "learningObjective": "Reconhecer quando MG difere de DC/PD pela falta de recursão estruturada.",
                                  "commonMistakes": "Aplicar MG onde subestrutura ótima requer PD ou independência DC."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Comparações e Aplicar em Exemplos Práticos",
                                  "subSteps": [
                                    "Crie tabela comparativa: linhas para independência/sobreposição, recursão, optimalidade, exemplos.",
                                    "Enfatize: DC (independente, sem overlap), PD (overlap, bottom-up), MG (local greedy).",
                                    "Analise trade-offs: tempo DC O(n log n), PD O(n^2), MG O(n log n).",
                                    "Teste com problema unificado: Soma Máxima Subarray (DC, PD, Kadane-MG).",
                                    "Resuma em mindmap."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as 3 diferenças chave para um parente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para tabela",
                                    "Ferramenta online como Draw.io para diagramas"
                                  ],
                                  "tips": "Use cores: verde para DC, vermelho para PD overlap, azul para MG ganância.",
                                  "learningObjective": "Integrar conhecimentos para diferenciar paradigmas com confiança.",
                                  "commonMistakes": "Generalizar demais; lembrar que DC pode ter overlap se mal projetado."
                                }
                              ],
                              "practicalExample": "Para o problema de Fibonacci: DC ingênuo recalcula subproblemas independentes mas explode (2^n); PD memoiza overlaps (O(n)); MG não aplica pois não há ganância clara. Compare com Merge Sort (DC puro: divide arrays independentes) vs 0/1 Knapsack (PD por overlaps) vs Fractional Knapsack (MG por ganância viável).",
                              "finalVerifications": [
                                "Pode listar 3 diferenças chave entre DC, PD e MG?",
                                "Descreve corretamente ausência de overlap em DC vs presença em PD?",
                                "Identifica quando MG falha vs DC/PD?",
                                "Cria tabela comparativa precisa?",
                                "Explica independência de subproblemas em DC com exemplo?",
                                "Distingue recursão DC de bottom-up PD?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de independência vs sobreposição (40%)",
                                "Uso de exemplos corretos e relevantes (20%)",
                                "Clareza na tabela ou diagrama comparativo (15%)",
                                "Compreensão de trade-offs de complexidade (15%)",
                                "Capacidade de explicar verbalmente diferenças (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de recorrências e Master Theorem",
                                "Lógica e Filosofia: Raciocínio indutivo vs dedutivo em escolhas ótimas",
                                "Economia: Otimização gulosa em alocação de recursos",
                                "Engenharia de Software: Escolha de design patterns para eficiência"
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, engenheiros usam DC para ordenação paralelizável (Merge Sort em big data), PD para otimização de rotas (Google Maps), e MG para compressão (Huffman em arquivos ZIP), escolhendo paradigma baseado em overlap e estrutura para escalabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Estrutura de um Algoritmo de Divisão e Conquista",
                        "description": "Análise da estrutura típica de implementação de algoritmos nesse paradigma, focando em recursão e integração dos componentes.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Implementar o caso base recursivo",
                            "description": "Codificar o caso base de um algoritmo de divisão e conquista, garantindo que problemas triviais sejam resolvidos diretamente sem recursão adicional, como em Merge Sort para arrays de tamanho 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Caso Base em Recursão",
                                  "subSteps": [
                                    "Estude a definição: o caso base é a condição mais simples que resolve o problema sem chamadas recursivas adicionais.",
                                    "Analise exemplos clássicos como fatorial (n=0 ou n=1 retorna 1) ou Fibonacci (n=0 retorna 0, n=1 retorna 1).",
                                    "Identifique o papel: para a recursão infinita, garantindo terminação.",
                                    "Compare com caso recursivo: onde o problema é dividido em subproblemas menores.",
                                    "Desenhe um diagrama de chamadas recursivas mostrando onde o caso base para a árvore."
                                  ],
                                  "verification": "Explique em suas próprias palavras o que é um caso base e dê um exemplo simples, registrando em um documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Vídeos tutoriais sobre recursão (ex: Khan Academy)"
                                  ],
                                  "tips": "Sempre pergunte: 'Qual é o problema trivial que eu sei resolver diretamente?'",
                                  "learningObjective": "Dominar o conceito teórico do caso base e sua importância na recursão.",
                                  "commonMistakes": [
                                    "Confundir caso base com condição recursiva",
                                    "Esquecer que o caso base deve ser O(1) ou constante"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Casos Base em Algoritmos de Divisão e Conquista",
                                  "subSteps": [
                                    "Revise a estrutura D&C: dividir, conquistar, combinar.",
                                    "Analise Merge Sort: para subarrays de tamanho <=1, não dividir mais.",
                                    "Estude outros exemplos: Binary Search (array de 1 elemento), QuickSort (partição vazia).",
                                    "Liste condições comuns: tamanho do input = 0, 1 ou valor específico.",
                                    "Pratique identificando em pseudocódigo fornecido."
                                  ],
                                  "verification": "Anote 3 exemplos de casos base em D&C e justifique por que param a recursão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de Merge Sort e Binary Search",
                                    "Editor de texto"
                                  ],
                                  "tips": "Pense em 'tamanho do problema': quando é pequeno o suficiente para resolver diretamente.",
                                  "learningObjective": "Reconhecer padrões de casos base específicos para D&C.",
                                  "commonMistakes": [
                                    "Definir caso base muito restritivo (ex: só n=0)",
                                    "Ignorar casos vazios (n=0)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar o Caso Base para Merge Sort",
                                  "subSteps": [
                                    "Escreva a assinatura da função recursiva: mergeSort(arr, left, right).",
                                    "Implemente a condição: if (left >= right) return o subarray [left..right].",
                                    "Garanta retorno correto: copie ou retorne o array inalterado.",
                                    "Adicione comentários explicando por que é O(1).",
                                    "Teste sintaxe em um compilador."
                                  ],
                                  "verification": "Execute com array de tamanho 1 e confirme que retorna sem recursão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python/Java)",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Use índices left/right para flexibilidade em subarrays.",
                                  "learningObjective": "Implementar código funcional para o caso base em contexto real.",
                                  "commonMistakes": [
                                    "Retornar null ou vazio incorretamente",
                                    "Usar loops desnecessários no caso base"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar o Caso Base Isoladamente",
                                  "subSteps": [
                                    "Crie testes unitários: array tamanho 0, 1 e 2.",
                                    "Meça tempo de execução para confirmar eficiência.",
                                    "Use debugger para inspecionar chamadas: verifique parada na base.",
                                    "Simule stack trace manualmente em papel.",
                                    "Corrija erros e reteste."
                                  ],
                                  "verification": "Todos testes passam com 100% de cobertura para casos base.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Framework de testes (unittest em Python)",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Sempre teste bordas primeiro: empty, single element.",
                                  "learningObjective": "Validar robustez do caso base através de testes.",
                                  "commonMistakes": [
                                    "Não testar n=0",
                                    "Ignorar overflow de índices"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Merge Sort, codifique: def mergeSort(arr, left, right): if left >= right: return arr[left:right+1]. Para [5], retorna [5] diretamente, sem dividir.",
                              "finalVerifications": [
                                "Função retorna corretamente subarrays de tamanho 0 ou 1 sem recursão.",
                                "Não há stack overflow em inputs pequenos.",
                                "Tempo de execução é O(1) para casos base.",
                                "Código é legível com comentários explicativos.",
                                "Testes unitários cobrem todos cenários triviais.",
                                "Integração com passos recursivos não quebra o base."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Resolve trivial cases perfeitamente.",
                                "Eficiência: Operação constante no caso base.",
                                "Clareza: Código autoexplicativo e comentado.",
                                "Robustez: Lida com edge cases (vazio, null).",
                                "Conformidade: Segue padrão D&C exato.",
                                "Testabilidade: Fácil de unit test."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática (base + passo indução).",
                                "Lógica: Condições de parada em provas por casos.",
                                "Engenharia de Software: Testes de borda e TDD.",
                                "Análise de Algoritmos: Contribuição para recorrência T(n)."
                              ],
                              "realWorldApplication": "Em ordenação de terabytes de dados em bancos como Google ou bancos financeiros, o caso base garante eficiência em subproblemas triviais durante merges paralelos, evitando overhead desnecessário."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Projetar a etapa de divisão",
                            "description": "Desenvolver a lógica para dividir o problema original em dois ou mais subproblemas independentes de tamanho aproximadamente metade, utilizando recursão para chamadas subsequentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Problema Original",
                                  "subSteps": [
                                    "Leia e compreenda a descrição completa do problema, identificando entradas, saídas e restrições.",
                                    "Determine o tamanho do problema (N) e o que o torna computacionalmente intensivo.",
                                    "Identifique padrões ou estruturas repetitivas na entrada que sugiram divisão natural.",
                                    "Mapeie a solução desejada em termos do problema inteiro.",
                                    "Anote suposições sobre independência de subpartes."
                                  ],
                                  "verification": "Escreva um resumo de 1 parágrafo descrevendo o problema, suas entradas/saídas e tamanho N.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do problema",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Sempre pergunte: 'O que acontece se eu dividir a entrada em partes menores?'",
                                  "learningObjective": "Compreender profundamente o problema para identificar oportunidades de divisão.",
                                  "commonMistakes": "Ignorar restrições ou assumir independência sem verificação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Estratégia de Divisão",
                                  "subSteps": [
                                    "Procure simetrias ou divisões naturais na estrutura de dados (ex: arrays em metades).",
                                    "Defina pontos de corte que equilibrem os subproblemas (idealmente N/2 cada).",
                                    "Verifique se os subproblemas podem ser resolvidos independentemente.",
                                    "Esboce a recursão conceitual: T(N) = a * T(N/b) + f(N), com a>=2, b>=2.",
                                    "Teste mentalmente com N pequeno (ex: N=4 -> dois de N=2)."
                                  ],
                                  "verification": "Desenhe um diagrama de árvore de recursão mostrando a divisão inicial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para diagramas",
                                    "Exemplos de D&C como Merge Sort"
                                  ],
                                  "tips": "Priorize divisões balanceadas para otimizar complexidade.",
                                  "learningObjective": "Reconhecer padrões que permitem divisão equilibrada e independente.",
                                  "commonMistakes": "Criar subproblemas dependentes ou desbalanceados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar os Subproblemas",
                                  "subSteps": [
                                    "Defina parâmetros de entrada para cada subproblema (ex: subarray[left..mid], subarray[mid+1..right]).",
                                    "Especifique como mapear soluções de subproblemas de volta ao original.",
                                    "Garanta que subproblemas sejam idênticos em forma ao original (auto-similaridade).",
                                    "Escreva pseudocódigo para a função de divisão.",
                                    "Valide com exemplo concreto: entrada N=8 -> sub de N=4."
                                  ],
                                  "verification": "Escreva definições formais dos subproblemas e pseudocódigo da divisão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código ou pseudocódigo",
                                    "Exemplo de problema específico"
                                  ],
                                  "tips": "Use índices ou slices para precisão em arrays.",
                                  "learningObjective": "Traduzir intuição em definições precisas e recursivas.",
                                  "commonMistakes": "Esquecer de passar parâmetros corretos na recursão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Refinar a Lógica de Divisão",
                                  "subSteps": [
                                    "Simule a divisão passo a passo com entrada pequena.",
                                    "Confirme independência: solução de um sub não afeta o outro.",
                                    "Meça balanceamento: confirme ~N/2 por subproblema.",
                                    "Ajuste para casos base (N=1 ou N pequeno).",
                                    "Documente condições de parada da recursão."
                                  ],
                                  "verification": "Execute simulação manual e anote resultados esperados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou simulador manual",
                                    "Código de teste simples"
                                  ],
                                  "tips": "Sempre teste com N=1,2,4 para capturar edge cases.",
                                  "learningObjective": "Assegurar robustez e corretude da etapa de divisão.",
                                  "commonMistakes": "Não tratar casos base ou divisões ímpares."
                                }
                              ],
                              "practicalExample": "Em Merge Sort para ordenar array [4,2,7,1,5,3,8,6]: Divida em [4,2,7,1] e [5,3,8,6] (metades de tamanho 4), resolvendo recursivamente cada metade independentemente antes de mesclar.",
                              "finalVerifications": [
                                "Os subproblemas são independentes (nenhuma dependência mútua)?",
                                "Cada subproblema tem tamanho aproximadamente N/2?",
                                "A recursão é chamada com parâmetros corretos para subproblemas?",
                                "Casos base estão definidos para evitar recursão infinita?",
                                "Diagrama de recursão mostra balanceamento?",
                                "Simulação manual com N pequeno produz divisão esperada?"
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na definição dos subproblemas (nota 1-5).",
                                "Correção lógica da divisão e independência comprovada (sim/não).",
                                "Balanceamento demonstrado (desvio <10% de N/2).",
                                "Pseudocódigo executável sem erros de parâmetro.",
                                "Profundidade de verificação em simulações (cobertura de casos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de equações de recorrência lineares.",
                                "Design de Software: Princípios de modularidade e refatoração.",
                                "Física: Divisão de problemas complexos em partículas independentes (ex: simulações).",
                                "Estatística: Divisão de datasets em subamostras para análise paralela."
                              ],
                              "realWorldApplication": "Em processamento paralelo multi-core, como no QuickSort para bancos de dados massivos, dividindo consultas SQL em subconsultas independentes para acelerar buscas em terabytes de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Implementar a combinação de soluções",
                            "description": "Criar a função que mescla ou combina as soluções dos subproblemas resolvidos, otimizando o tempo dessa etapa para manter a eficiência geral do algoritmo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar as saídas dos subproblemas",
                                  "subSteps": [
                                    "Identifique o tipo de dados e estrutura retornados por cada subproblema (ex: arrays ordenados, árvores balanceadas).",
                                    "Liste as propriedades invariantes garantidas pelas sub-soluções (ex: ordenação, unicidade, soma total).",
                                    "Defina o formato e tipo da solução final combinada, garantindo compatibilidade.",
                                    "Crie um diagrama ilustrando o fluxo de dados da combinação.",
                                    "Verifique restrições de tamanho e complexidade das sub-soluções."
                                  ],
                                  "verification": "Crie uma tabela ou diagrama documentando entradas, saídas e propriedades de cada subproblema.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo dos subproblemas",
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Foque nas interfaces: o que entra e sai de cada parte.",
                                  "learningObjective": "Compreender as dependências e invariantes das sub-soluções para uma combinação correta.",
                                  "commonMistakes": [
                                    "Ignorar propriedades como ordenação",
                                    "Assumir tamanhos iguais para subproblemas",
                                    "Não considerar casos vazios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a lógica de combinação",
                                  "subSteps": [
                                    "Escolha a estratégia de merge adequada (ex: ponteiros duplos para arrays ordenados, heurísticas para árvores).",
                                    "Defina o algoritmo passo a passo em pseudocódigo, priorizando eficiência linear ou logarítmica.",
                                    "Calcule a complexidade temporal da combinação (T_combine(n)) para manter T(n) = 2T(n/2) + T_combine(n).",
                                    "Considere casos base e edge cases (ex: subproblemas vazios ou desbalanceados).",
                                    "Esboce um fluxograma da função combine."
                                  ],
                                  "verification": "Escreva pseudocódigo completo e valide manualmente com exemplos pequenos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo base",
                                    "Calculadora para análise de Big O"
                                  ],
                                  "tips": "Mantenha T_combine(n) = O(n) para eficiência em Divisão e Conquista clássica.",
                                  "learningObjective": "Projetar uma combinação eficiente que preserve a recorrência do algoritmo.",
                                  "commonMistakes": [
                                    "Usar soluções quadráticas como nested loops desnecessários",
                                    "Esquecer casos edge",
                                    "Ignorar balanceamento de subproblemas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a função de combinação em código",
                                  "subSteps": [
                                    "Escreva a assinatura da função (ex: combine(left, right) -> result).",
                                    "Implemente o loop principal de merge seguindo o pseudocódigo.",
                                    "Adicione tratamento de casos especiais (vazio, um lado só).",
                                    "Integre a função ao esqueleto principal do algoritmo de D&C.",
                                    "Adicione comentários explicando cada linha crítica."
                                  ],
                                  "verification": "Execute unit tests com entradas pequenas e compare saídas esperadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Linguagem escolhida (Python, Java)"
                                  ],
                                  "tips": "Use estruturas mutáveis se possível para evitar cópias desnecessárias.",
                                  "learningObjective": "Traduzir design em código funcional e modular.",
                                  "commonMistakes": [
                                    "Índices off-by-one em merges",
                                    "Não liberar memória em linguagens como C++",
                                    "Copiar dados desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar e validar a eficiência da combinação",
                                  "subSteps": [
                                    "Meça o tempo de execução da combine isoladamente com inputs grandes.",
                                    "Compare com benchmarks teóricos (ex: O(n) vs observado).",
                                    "Profile o código para identificar gargalos na combinação.",
                                    "Ajuste otimizações como cache-friendly access ou paralelismo se aplicável.",
                                    "Teste integração completa no algoritmo D&C com análise de recorrência."
                                  ],
                                  "verification": "Gere relatório com tempos de execução e gráficos de escalabilidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas de profiling (timeit em Python, VisualVM em Java)",
                                    "Datasets de teste crescentes"
                                  ],
                                  "tips": "Use inputs balanceados para simular recorrência real.",
                                  "learningObjective": "Garantir que a combinação não degrade a eficiência global do algoritmo.",
                                  "commonMistakes": [
                                    "Otimizar prematuramente sem medir",
                                    "Testar só casos pequenos",
                                    "Ignorar overhead de alocação"
                                  ]
                                }
                              ],
                              "practicalExample": "No Merge Sort, a função combine mescla dois subarrays ordenados usando dois ponteiros: avance o menor elemento de cada subarray para o resultado final, garantindo O(n) tempo e preservando a ordenação geral.",
                              "finalVerifications": [
                                "A função combine produz saída correta para todos os casos testados.",
                                "Complexidade temporal da combine é O(n) ou melhor, confirmada por medições.",
                                "Integração no algoritmo D&C mantém eficiência global (ex: O(n log n) para Merge Sort).",
                                "Edge cases (subproblemas vazios, desbalanceados) são tratados corretamente.",
                                "Código é legível, comentado e modular.",
                                "Testes unitários cobrem 90%+ do código da combine."
                              ],
                              "assessmentCriteria": [
                                "Correção: Saída exata para entradas variadas (90% peso).",
                                "Eficiência: Tempo dentro do limite teórico (20% peso).",
                                "Modularidade: Função isolável e reutilizável (15% peso).",
                                "Tratamento de erros: Robustez a inputs inválidos (10% peso).",
                                "Documentação: Comentários e análise clara (15% peso).",
                                "Escalabilidade: Performance em n=10^6 (10% peso)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de recorrências e soma de séries (Master Theorem).",
                                "Engenharia de Software: Design de interfaces e modularidade.",
                                "Física/Engenharia: Mesclagem em simulações paralelas (ex: partículas).",
                                "Estatística: Combinação de amostras ordenadas em dados grandes.",
                                "Negócios: Otimização de processos em supply chain (merge de rotas)."
                              ],
                              "realWorldApplication": "Em bancos de dados, a combinação é usada em merge joins para unir tabelas ordenadas eficientemente; em machine learning, para mesclar features de submodelos em ensembles; e em computação gráfica, para combinar subimagens em renderização paralela."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.4",
                            "name": "Escrever pseudocódigo completo",
                            "description": "Construir o pseudocódigo integral de um algoritmo clássico como QuickSort ou Estrutura de Fast Fourier Transform, integrando todos os componentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios do QuickSort e Divisão e Conquista",
                                  "subSteps": [
                                    "Revise o paradigma de divisão e conquista: dividir problema em subproblemas, conquistar recursivamente e combinar.",
                                    "Estude o QuickSort: seleciona pivô, particiona array em menores/maiores, recursão em subarrays.",
                                    "Identifique componentes chave: função partition, recursão, casos base (array vazio ou tamanho 1).",
                                    "Analise complexidade: O(n log n) médio, O(n²) pior caso.",
                                    "Desenhe fluxograma manual do QuickSort em um array exemplo [5,3,8,4,2]."
                                  ],
                                  "verification": "Crie um diagrama ou resumo escrito confirmando compreensão dos componentes e fluxograma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referências online sobre QuickSort (Wikipedia, GeeksforGeeks)",
                                    "Editor de texto para notas"
                                  ],
                                  "tips": "Use animações visuais online para visualizar partições.",
                                  "learningObjective": "Dominar a lógica conceitual do QuickSort antes de codificar.",
                                  "commonMistakes": "Confundir QuickSort com MergeSort; ignorar análise de pivô."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever pseudocódigo da função Partition",
                                  "subSteps": [
                                    "Defina parâmetros: array A, low, high índices.",
                                    "Escolha pivô (ex: último elemento A[high]).",
                                    "Inicialize i = low-1 para menores; percorra j de low a high-1.",
                                    "Se A[j] <= pivô, incremente i e troque A[i] e A[j].",
                                    "Após loop, troque pivô com A[i+1] e retorne posição i+1."
                                  ],
                                  "verification": "Teste logicamente com array [5,3,8,4,2], pivô=2; confirme partição correta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de texto ou papel",
                                    "Array de exemplo impresso"
                                  ],
                                  "tips": "Escreva trocas explicitamente com variáveis temporárias.",
                                  "learningObjective": "Construir o coração do QuickSort: partição eficiente.",
                                  "commonMistakes": "Índices off-by-one em i e j; esquecer troca final do pivô."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver pseudocódigo da função QuickSort principal",
                                  "subSteps": [
                                    "Defina QuickSort(A, low, high): se low < high, calcule p = Partition(A, low, high).",
                                    "Recurse em subarray esquerdo: QuickSort(A, low, p-1).",
                                    "Recurse em subarray direito: QuickSort(A, p+1, high).",
                                    "Adicione casos base explicitamente no início.",
                                    "Inclua chamada inicial: QuickSort(array, 0, tamanho-1)."
                                  ],
                                  "verification": "Trace execução completa em array pequeno, verificando recursão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Ferramenta de desenho para árvore de recursão"
                                  ],
                                  "tips": "Use indentação para mostrar recursão claramente.",
                                  "learningObjective": "Integrar recursão com partição de forma coesa.",
                                  "commonMistakes": "Não tratar low >= high; recursão infinita sem base."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, otimizar e documentar o pseudocódigo completo",
                                  "subSteps": [
                                    "Combine Partition e QuickSort em um bloco coeso.",
                                    "Adicione comentários para cada linha chave.",
                                    "Otimize pivô (ex: mediana de três) se aplicável.",
                                    "Inclua pré-condições (array não-nulo) e pós-condições (array ordenado).",
                                    "Formate com convenções: palavras-chave em maiúscula, indentação consistente."
                                  ],
                                  "verification": "Leia em voz alta; simule execução em 2-3 arrays variados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de texto avançado (VS Code, Notepad++)"
                                  ],
                                  "tips": "Use pseudocódigo legível, não código real; foque em clareza.",
                                  "learningObjective": "Produzir pseudocódigo profissional e completo.",
                                  "commonMistakes": "Falta de comentários; formatação inconsistente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar o pseudocódigo final",
                                  "subSteps": [
                                    "Compare com referências padrão de QuickSort.",
                                    "Teste edge cases: array vazio, um elemento, duplicados, reverso.",
                                    "Meça complexidade no pseudocódigo.",
                                    "Peça feedback simulado ou revise por clareza.",
                                    "Finalize versão polida."
                                  ],
                                  "verification": "Pseudocódigo passa em todos testes lógicos sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referências padrão de algoritmos (CLRS livro ou site)"
                                  ],
                                  "tips": "Registre tempo de execução teórico para validação.",
                                  "learningObjective": "Garantir robustez e precisão do pseudocódigo.",
                                  "commonMistakes": "Ignorar casos edge; otimização prematura."
                                }
                              ],
                              "practicalExample": "Pseudocódigo QuickSort para array [4,2,7,1,3]:\nPROCEDURE Partition(A, low, high):\n  pivot = A[high]\n  i = low - 1\n  FOR j = low TO high-1:\n    IF A[j] <= pivot:\n      i = i + 1\n      SWAP A[i], A[j]\n  SWAP A[i+1], A[high]\n  RETURN i+1\n\nPROCEDURE QuickSort(A, low, high):\n  IF low < high:\n    p = Partition(A, low, high)\n    QuickSort(A, low, p-1)\n    QuickSort(A, p+1, high)\n\n// Chamada: QuickSort(arr, 0, 4) resulta em [1,2,3,4,7]",
                              "finalVerifications": [
                                "Pseudocódigo ordena corretamente array de teste.",
                                "Todos componentes (partition, recursão, base) presentes.",
                                "Sem erros lógicos em trace manual.",
                                "Complexidade analisada e correta.",
                                "Formatação clara com comentários.",
                                "Edge cases tratados explicitamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão lógica: partição e recursão corretas (30%)",
                                "Completude: todos componentes integrados (25%)",
                                "Clareza e legibilidade do pseudocódigo (20%)",
                                "Tratamento de casos base e edge (15%)",
                                "Documentação e comentários adequados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recursão e análise assintótica (Big O).",
                                "Física: Modelagem de processos divididos (ex: simulações).",
                                "Estatística: Análise de performance empírica em dados.",
                                "Engenharia de Software: Design de algoritmos escaláveis."
                              ],
                              "realWorldApplication": "QuickSort é usado em bibliotecas padrão (Java Arrays.sort, Python TimSort híbrido) para ordenar grandes datasets em bancos de dados, motores de busca e processamento de big data, otimizando consultas e rankings."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Análise de Complexidade Computacional",
                        "description": "Técnicas para analisar o tempo e espaço de algoritmos de divisão e conquista usando equações de recorrência e métodos de solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Formular equações de recorrência",
                            "description": "Derivar a equação de recorrência T(n) = a T(n/b) + f(n) para um algoritmo D&C, identificando a, b e f(n) com base na divisão, recursão e combinação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral de um algoritmo Divide and Conquer (D&C)",
                                  "subSteps": [
                                    "Revise os três componentes principais: Dividir (divide o problema), Conquistar (resolve subproblemas recursivamente), Combinar (une soluções).",
                                    "Identifique o tamanho do problema original n e como ele é dividido em subproblemas menores.",
                                    "Estude exemplos clássicos como Merge Sort ou Binary Search para visualizar o padrão recursivo.",
                                    "Anote a forma geral da recorrência: T(n) = a T(n/b) + f(n).",
                                    "Explique em suas palavras o papel de cada fase no contexto da recursão."
                                  ],
                                  "verification": "Você pode diagramar a árvore de recursão para um exemplo simples como Merge Sort?",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Pseudocódigo de Merge Sort ou Binary Search",
                                    "Papel e caneta para desenhar árvore de recursão"
                                  ],
                                  "tips": "Sempre comece visualizando a recursão como uma árvore para entender a divisão.",
                                  "learningObjective": "Entender os componentes fundamentais de D&C e sua representação recursiva.",
                                  "commonMistakes": [
                                    "Confundir 'dividir' com 'conquistar'",
                                    "Ignorar o custo da combinação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os parâmetros a e b da recursão",
                                  "subSteps": [
                                    "Conte o número de subproblemas criados na fase de divisão (isso é 'a').",
                                    "Determine o fator de redução do tamanho do problema (n/b, onde b é o divisor).",
                                    "Verifique se os subproblemas são de tamanhos iguais (típico em D&C balanceado).",
                                    "Registre a e b para o algoritmo específico analisado.",
                                    "Compare com exemplos: Merge Sort (a=2, b=2), Binary Search (a=1, b=2)."
                                  ],
                                  "verification": "Você pode extrair a=2 e b=2 do pseudocódigo de Merge Sort?",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Pseudocódigo do algoritmo alvo",
                                    "Tabela para anotar a e b"
                                  ],
                                  "tips": "a é o número de chamadas recursivas; b é quanto o tamanho diminui (ex: metade = b=2).",
                                  "learningObjective": "Identificar precisamente a e b baseados na fase de divisão.",
                                  "commonMistakes": [
                                    "Contar subproblemas incorretamente",
                                    "Usar b=1 para buscas binárias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar o custo f(n) das fases de divisão e combinação",
                                  "subSteps": [
                                    "Calcule o tempo da fase de divisão (ex: dividir array em O(1) ou O(n)).",
                                    "Estime o tempo da fase de combinação (ex: merge em O(n)).",
                                    "Some os custos não-recursivos e expresse em notação assintótica (O(n), O(1), etc.).",
                                    "Ignore custos dentro das chamadas recursivas (T(n/b)).",
                                    "Valide com profiling mental: f(n) deve crescer com n, mas não recursivamente."
                                  ],
                                  "verification": "Você pode justificar f(n) = O(n) para o merge em Merge Sort?",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Pseudocódigo anotado",
                                    "Calculadora para somas simbólicas"
                                  ],
                                  "tips": "f(n) é o 'trabalho extra' fora da recursão; foque em loops ou operações lineares.",
                                  "learningObjective": "Isolar e quantificar o custo não-recursivo f(n).",
                                  "commonMistakes": [
                                    "Incluir custos recursivos em f(n)",
                                    "Subestimar combinação como O(1)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular, escrever e validar a equação de recorrência",
                                  "subSteps": [
                                    "Substitua a, b e f(n) na forma geral: T(n) = a T(n/b) + f(n).",
                                    "Escreva condições base: T(1) = O(1) ou similar.",
                                    "Teste a equação com n pequeno (ex: n=4) contando expansões.",
                                    "Verifique consistência com teorema Master ou desenhos de árvore.",
                                    "Reescreva para múltiplos algoritmos para praticar."
                                  ],
                                  "verification": "A equação expandida bate com o número de operações reais no algoritmo?",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Papel para expansão manual da recorrência",
                                    "Ferramenta online como recurrence-plotter se disponível"
                                  ],
                                  "tips": "Sempre inclua Θ ou O para precisão assintótica em f(n).",
                                  "learningObjective": "Montar e validar a recorrência completa.",
                                  "commonMistakes": [
                                    "Esquecer base case",
                                    "Usar notação errada como O em vez de Θ"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e refinar com exemplos variados",
                                  "subSteps": [
                                    "Aplique a D&C em Binary Search: identifique a=1, b=2, f(n)=O(1).",
                                    "Teste em QuickSort médio: a=2, b=2, f(n)=O(n).",
                                    "Compare equações e discuta diferenças em complexidade.",
                                    "Resolva um exercício novo sem olhar soluções.",
                                    "Documente lições aprendidas em um resumo."
                                  ],
                                  "verification": "Você formula corretamente T(n) para Binary Search como T(n)=T(n/2)+O(1)?",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Lista de exercícios D&C",
                                    "Soluções modelo para auto-verificação"
                                  ],
                                  "tips": "Varie tamanhos de subproblemas para D&C desbalanceados.",
                                  "learningObjective": "Generalizar a formulação para algoritmos D&C diversos.",
                                  "commonMistakes": [
                                    "Generalizar incorretamente de um exemplo",
                                    "Ignorar variações em f(n)"
                                  ]
                                }
                              ],
                              "practicalExample": "No Merge Sort: O array de tamanho n é dividido em 2 subarrays de n/2 (a=2, b=2). A divisão é O(1), mas combinar (merge) custa O(n), então f(n)=O(n). Equação: T(n) = 2 T(n/2) + O(n), com T(1)=O(1).",
                              "finalVerifications": [
                                "Pode formular T(n) corretamente para Merge Sort?",
                                "Identifica a, b e f(n) em Binary Search?",
                                "Valida a equação expandindo manualmente para n=8?",
                                "Distingue custos recursivos de não-recursivos?",
                                "Aplica a QuickSort médio: T(n)=2T(n/2)+O(n)?",
                                "Inclui base case apropriada?"
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa de a e b (30%)",
                                "Cálculo correto de f(n) com justificativa (25%)",
                                "Formulação completa da equação com base case (20%)",
                                "Validação via expansão ou teorema Master (15%)",
                                "Generalização para 2+ exemplos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Resolução de recorrências lineares",
                                "Análise Assintótica: Notação Big-O/Theta no teorema Master",
                                "Programação: Implementação e profiling de algoritmos recursivos",
                                "Matemática: Séries geométricas em expansões de árvore",
                                "Engenharia de Software: Otimização de performance"
                              ],
                              "realWorldApplication": "Em processamento de big data (ex: sorting em bancos de dados como Hadoop), formular recorrências ajuda a prever tempo de execução, escolher algoritmos eficientes e escalar sistemas para milhões de registros."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Aplicar o Método do Mestre",
                            "description": "Resolver equações de recorrência usando o Teorema do Mestre, classificando casos (1, 2, 3) e determinando a complexidade assintótica Θ(g(n)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Forma Padrão das Equações de Recorrência para o Teorema do Mestre",
                                  "subSteps": [
                                    "Identifique a forma geral T(n) = a T(n/b) + f(n), onde a ≥ 1, b > 1.",
                                    "Explique o significado de cada parâmetro: a (número de subproblemas), b (tamanho relativo), f(n) (custo de combinação).",
                                    "Diferencie recorrências aplicáveis do Mestre de outras formas (ex: não divisíveis por b).",
                                    "Escreva 3 exemplos de recorrências na forma padrão.",
                                    "Compare com recorrências lineares para reforçar diferenças."
                                  ],
                                  "verification": "Liste corretamente a forma geral e 3 exemplos válidos sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a notas de aula sobre análise de algoritmos",
                                    "Calculadora básica"
                                  ],
                                  "tips": "Sempre normalize n para potências de b se necessário; foque em assintótica.",
                                  "learningObjective": "Reconhecer e decompor recorrências na forma padrão do Mestre.",
                                  "commonMistakes": [
                                    "Confundir f(n) com o custo total",
                                    "Ignorar constantes em a ou b",
                                    "Aplicar a formas não padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar os Três Casos do Teorema do Mestre",
                                  "subSteps": [
                                    "Memorize Caso 1: Se f(n) = O(n^{log_b a - ε}) para ε > 0, então T(n) = Θ(n^{log_b a}).",
                                    "Memorize Caso 2: Se f(n) = Θ(n^{log_b a} log^k n) para k ≥ 0, então T(n) = Θ(n^{log_b a} log^{k+1} n).",
                                    "Memorize Caso 3: Se f(n) = Ω(n^{log_b a + ε}) para ε > 0 e af(n) ≤ c f(n) para c < 1, então T(n) = Θ(f(n)).",
                                    "Derive intuitivamente cada caso usando árvore de recorrência.",
                                    "Escreva as condições e soluções para cada caso em uma tabela."
                                  ],
                                  "verification": "Recite os três casos com condições e soluções corretas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Quadro branco ou papel",
                                    "Vídeo tutorial sobre Teorema do Mestre (ex: YouTube MIT OCW)",
                                    "Tabela de logaritmos"
                                  ],
                                  "tips": "Use log_b a como 'profundidade crítica'; visualize árvores para intuição.",
                                  "learningObjective": "Dominar as condições e soluções exatas dos três casos.",
                                  "commonMistakes": [
                                    "Esquecer a condição de regularidade no Caso 3",
                                    "Confundir k em Caso 2",
                                    "Usar O em vez de Θ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar Recorrências nos Casos Apropriados",
                                  "subSteps": [
                                    "Calcule log_b a para a recorrência dada.",
                                    "Compare f(n) com n^{log_b a} usando limites assintóticos (ex: L'Hôpital se necessário).",
                                    "Teste condições de cada caso sequencialmente: 1, depois 2, depois 3.",
                                    "Classifique 5 recorrências de exemplo variadas.",
                                    "Justifique cada classificação com cálculos numéricos ou gráficos."
                                  ],
                                  "verification": "Classifique corretamente 5 recorrências diferentes com justificativas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha com exemplos de recorrências",
                                    "Software como Wolfram Alpha para logs"
                                  ],
                                  "tips": "Assinta sempre: ignore constantes baixas; use ε pequeno para testes.",
                                  "learningObjective": "Classificar precisamente qualquer recorrência nos casos 1, 2 ou 3.",
                                  "commonMistakes": [
                                    "Erro em cálculo de log_b a",
                                    "Comparar polinômios sem expoentes",
                                    "Pular condição de regularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Equações de Recorrência Aplicando o Teorema",
                                  "subSteps": [
                                    "Para uma recorrência dada, classifique o caso.",
                                    "Aplique a fórmula correspondente, simplificando Θ(g(n)).",
                                    "Verifique com expansão manual da árvore para pequenos n.",
                                    "Resolva 4 problemas completos: um de cada caso + um borderline.",
                                    "Anote a complexidade final Θ(.) para cada."
                                  ],
                                  "verification": "Resolva 4 recorrências com soluções corretas e verificadas.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Exercícios impressos ou digitais",
                                    "Referência rápida do teorema",
                                    "Planilha Excel para simulações"
                                  ],
                                  "tips": "Sempre escreva Θ explícito; teste com n=2^k para validação.",
                                  "learningObjective": "Aplicar o teorema end-to-end para obter complexidades assintóticas.",
                                  "commonMistakes": [
                                    "Aplicar caso errado após classificação",
                                    "Esquecer log no Caso 2",
                                    "Não simplificar Θ"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Validar Soluções com Exemplos Reais",
                                  "subSteps": [
                                    "Resolva recorrências de algoritmos conhecidos (Merge Sort, Binary Search).",
                                    "Compare sua solução com complexidades padrão conhecidas.",
                                    "Identifique quando Mestre não se aplica e sugira alternativas.",
                                    "Crie e resolva 2 recorrências originais.",
                                    "Revise todos os erros anteriores e corrija."
                                  ],
                                  "verification": "Resolva exemplos reais corretamente e crie 2 originais válidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo de algoritmos D&C",
                                    "Livro 'CLRS' capítulo 4 (opcional)",
                                    "Timer para prática timed"
                                  ],
                                  "tips": "Conecte a teoria com código: implemente um e meça empiricamente.",
                                  "learningObjective": "Consolidar aplicação em contextos reais e autoavaliação.",
                                  "commonMistakes": [
                                    "Assumir aplicabilidade sem verificar forma",
                                    "Ignorar casos não cobertos pelo Mestre"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Merge Sort: T(n) = 2T(n/2) + Θ(n). Aqui, a=2, b=2, log_b a=1, f(n)=Θ(n)=Θ(n^1). Como f(n)=Θ(n^{log_b a}), é Caso 2 com k=0, logo T(n)=Θ(n log n). Verifique expandindo: nível 0: n, nível 1: 2*(n/2)=n, etc., log n níveis, total n log n.",
                              "finalVerifications": [
                                "Classifique corretamente recorrências em Casos 1, 2 e 3 com justificativa.",
                                "Aplique fórmulas para obter Θ(g(n)) exata em 5+ exemplos.",
                                "Explique intuição da árvore de recorrência para qualquer caso.",
                                "Identifique quando o Mestre não se aplica.",
                                "Resolva uma recorrência original criada por você.",
                                "Compare com soluções conhecidas de algoritmos padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de casos (90%+ acerto).",
                                "Correção matemática nas condições e soluções Θ(.).",
                                "Justificativas assintóticas claras e concisas.",
                                "Uso correto de notação Big-Theta e limites.",
                                "Capacidade de generalizar para exemplos não vistos.",
                                "Identificação de erros comuns e autocorreção."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e logaritmos (Cálculo I/II).",
                                "Engenharia de Software: Otimização de algoritmos D&C em projetos.",
                                "Física/Engenharia: Modelagem recursiva em simulações (ex: fractais).",
                                "Economia: Análise de crescimento em modelos recursivos.",
                                "Estatística: Complexidade em algoritmos de machine learning."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, o Método do Mestre é usado para analisar Merge Sort (busca eficiente em bancos de dados), Strassen's Matrix Multiplication (IA e gráficos), e algoritmos de divide-and-conquer em big data, garantindo escalabilidade Θ(n log n) em vez de pior."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Usar árvore de recorrência",
                            "description": "Construir e analisar a árvore de recorrência para visualizar o custo total em cada nível e somar para obter a complexidade exata ou assintótica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a relação de recorrência do algoritmo",
                                  "subSteps": [
                                    "Examine o algoritmo de divisão e conquista para identificar o tamanho do subproblema (ex: n/2).",
                                    "Determine o número de subproblemas recursivos (ex: 2 para Merge Sort).",
                                    "Identifique o custo do trabalho fora da recursão (ex: cn para merge).",
                                    "Escreva a relação de recorrência no formato T(n) = a T(n/b) + f(n).",
                                    "Verifique as condições base (ex: T(1) = c)."
                                  ],
                                  "verification": "Confirme que a relação de recorrência está escrita corretamente e corresponde ao pseudocódigo do algoritmo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pseudocódigo do algoritmo, papel e caneta ou software de desenho como Draw.io.",
                                  "tips": "Sempre comece pelas condições base para evitar loops infinitos na análise.",
                                  "learningObjective": "Compreender e formalizar a recorrência associada ao algoritmo.",
                                  "commonMistakes": "Confundir o custo recursivo com o custo não-recursivo; ignorar condições base."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a árvore de recorrência",
                                  "subSteps": [
                                    "Desenhe o nó raiz representando T(n) com custo f(n).",
                                    "Crie 'a' branches para os subproblemas T(n/b), adicionando custos f(n/b) em cada nível.",
                                    "Continue expandindo até atingir a condição base (profundidade log_b n níveis).",
                                    "Rotule cada nó com seu custo e marque folhas com custo base.",
                                    "Garanta simetria na árvore para recorrências balanceadas."
                                  ],
                                  "verification": "A árvore deve ter altura log_b n, com folhas corretamente identificadas e custos proporcionais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha ou ferramenta digital como Lucidchart.",
                                  "tips": "Use cores diferentes para custos recursivos e não-recursivos para visualização clara.",
                                  "learningObjective": "Visualizar a estrutura recursiva como uma árvore hierárquica.",
                                  "commonMistakes": "Desenhar profundidade errada (não log_b n); omitir custos em nós internos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o custo total por nível da árvore",
                                  "subSteps": [
                                    "No nível 0 (raiz): custo = f(n).",
                                    "No nível k: número de nós = a^k, custo por nó = f(n / b^k), total = a^k * f(n / b^k).",
                                    "Repita para todos os níveis até as folhas.",
                                    "Liste os custos totais por nível em uma tabela.",
                                    "Some os custos das folhas separadamente se necessário."
                                  ],
                                  "verification": "Verifique se o custo por nível segue a fórmula a^k * f(n/b^k) e soma corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, planilha Excel ou papel para tabelas.",
                                  "tips": "Reconheça padrões geométricos para simplificar cálculos em níveis profundos.",
                                  "learningObjective": "Quantificar o trabalho realizado em cada camada da recursão.",
                                  "commonMistakes": "Erro no cálculo de a^k ou n/b^k; somar folhas incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar custos para complexidade exata e analisar assintótica",
                                  "subSteps": [
                                    "Some os custos de todos os níveis: T(n) = soma_{k=0}^{log_b n -1} a^k f(n/b^k) + custo das folhas.",
                                    "Simplifique a soma usando séries geométricas se aplicável.",
                                    "Compare f(n) com n^{log_b a} para aplicar o Master Theorem.",
                                    "Determine a notação Big-O, Theta ou Omega baseada na dominância.",
                                    "Escreva a complexidade final (ex: T(n) = Θ(n log n))."
                                  ],
                                  "verification": "A soma deve coincidir com a solução conhecida do algoritmo; análise assintótica deve ser precisa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Fórmulas do Master Theorem impressas, calculadora gráfica.",
                                  "tips": "Memorize os 3 casos do Master Theorem para aceleração.",
                                  "learningObjective": "Derivar complexidade exata e assintótica a partir da árvore.",
                                  "commonMistakes": "Ignorar o custo das folhas; aplicar Master Theorem sem verificar condições."
                                }
                              ],
                              "practicalExample": "Para Merge Sort: T(n) = 2T(n/2) + n. Árvore: raiz n, nível 1: 2*n/2=n, nível 2: 4*n/4=n, ... até log n níveis com soma n log n + n folhas.",
                              "finalVerifications": [
                                "Árvore desenhada com profundidade correta e custos rotulados.",
                                "Custos por nível calculados e tabelados precisamente.",
                                "Soma total resulta na complexidade exata T(n).",
                                "Análise assintótica matches com teoremas conhecidos.",
                                "Condições base e simetria da árvore validadas.",
                                "Exemplo prático resolvido sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da recorrência (30%).",
                                "Qualidade visual e completude da árvore (25%).",
                                "Correção nos cálculos de custos por nível (20%).",
                                "Derivação correta da complexidade final (15%).",
                                "Explicação clara da análise assintótica (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries geométricas e somas infinitas.",
                                "Matemática: Teoria dos grafos (árvores como estruturas acíclicas).",
                                "Física: Modelagem hierárquica de sistemas fractais.",
                                "Economia: Análise de custos em processos de divisão de tarefas."
                              ],
                              "realWorldApplication": "Em otimização de software, como no Google Maps (algoritmos de busca espacial via divide-and-conquer), onde árvores de recorrência ajudam a prever tempo de execução para escalabilidade em grandes datasets."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Método Guloso",
                    "description": "Abordagem que toma escolhas localmente ótimas em cada etapa, visando solução global eficiente sem backtracking.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Definição e Princípios Básicos do Método Guloso",
                        "description": "Compreensão fundamental do método guloso como paradigma que seleciona a opção localmente ótima em cada etapa, sem revisitar decisões anteriores, visando eficiência computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Identificar características do método guloso",
                            "description": "Reconhecer que o método guloso toma decisões irrevogáveis baseadas em critérios locais ótimos, sem backtracking, e diferencia-lo de outros paradigmas como programação dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as características principais do método guloso",
                                  "subSteps": [
                                    "Liste 5 características: 1) Critério de escolha local ótimo; 2) Decisões irrevogáveis; 3) Sem backtracking; 4) Estrutura recursiva simples; 5) Ordenação prévia dos dados.",
                                    "Classifique cada uma como 'essencial' ou 'opcional'.",
                                    "Crie cartões de memória com cada característica e exemplo.",
                                    "Compare com pseudocódigo de um algoritmo guloso simples.",
                                    "Teste-se recitando as características em ordem aleatória."
                                  ],
                                  "verification": "Liste todas as 5 características corretamente em menos de 1 minuto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de exemplo (ex: GitHub repo de algoritmos), app Anki para flashcards"
                                  ],
                                  "tips": "Associe cada característica a uma imagem mental vívida para melhor retenção.",
                                  "learningObjective": "Reconhecer e nomear todas as características chave do método guloso.",
                                  "commonMistakes": [
                                    "Achar que sempre garante ótimo global (nem sempre), confundir ordenação com backtracking"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar o método guloso de outros paradigmas",
                                  "subSteps": [
                                    "Compare com Programação Dinâmica (PD): guloso sem sobreposição/subproblemas, PD resolve subproblemas.",
                                    "Compare com Força Bruta: guloso poda opções, força bruta explora todas.",
                                    "Crie uma tabela comparativa com colunas: Backtracking (Sim/Não), Tempo, Garantia Ótimo.",
                                    "Analise um problema onde guloso falha (ex: mochila 0/1) vs PD.",
                                    "Discuta prós/cons em um diário de aprendizado."
                                  ],
                                  "verification": "Preencha corretamente uma tabela comparativa sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela em Excel/Google Sheets, exemplos de problemas clássicos (mochila, knapsack)"
                                  ],
                                  "tips": "Use setas na tabela para mostrar similaridades e diferenças visuais.",
                                  "learningObjective": "Distinguir claramente guloso de PD, força bruta e backtracking.",
                                  "commonMistakes": [
                                    "Achar PD como 'guloso melhorado' (PD é exaustivo), ignorar condições de otimalidade gulosa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação em exemplos práticos",
                                  "subSteps": [
                                    "Analise o problema 'Troca de Moedas': identifique decisões locais irrevogáveis.",
                                    "Classifique 3 algoritmos como 'guloso ou não' e justifique.",
                                    "Modifique um exemplo guloso para adicionar backtracking e observe impacto.",
                                    "Resolva um quiz com 5 questões de identificação de características.",
                                    "Ensine o conceito a um par ou grave um vídeo explicativo."
                                  ],
                                  "verification": "Resolva um quiz com 100% de acerto e explique um exemplo corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Quiz online (LeetCode easy greedy problems), gravador de vídeo celular"
                                  ],
                                  "tips": "Comece com problemas onde guloso funciona perfeitamente para reforçar confiança.",
                                  "learningObjective": "Identificar características em contextos reais de algoritmos.",
                                  "commonMistakes": [
                                    "Não verificar propriedade de otimalidade gulosa, classificar incorretamente algoritmos híbridos"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de Seleção de Atividades (Interval Scheduling), o algoritmo guloso ordena atividades por tempo de término e seleciona a que termina primeiro (decisão local ótima irrevogável), sem reconsiderar escolhas anteriores, maximizando o número de atividades sem sobreposição, diferentemente da PD que consideraria todas combinações.",
                              "finalVerifications": [
                                "Liste e explique 5 características principais sem hesitação.",
                                "Diferencie guloso de PD em um problema específico.",
                                "Identifique se um pseudocódigo dado é guloso.",
                                "Explique por que um problema não é resolvível por guloso.",
                                "Crie um exemplo próprio de algoritmo guloso.",
                                "Responda a um quiz de 10 questões com 90%+ acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e características (sem omissões).",
                                "Capacidade de diferenciação clara com exemplos.",
                                "Uso correto de terminologia técnica.",
                                "Aplicação em exemplos práticos sem erros.",
                                "Compreensão de limitações e condições de otimalidade.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização linear e desigualdades.",
                                "Economia: Tomada de decisões marginais e curtos prazos.",
                                "Física: Abordagens aproximadas em simulações (ex: trajetórias).",
                                "Gestão: Planejamento de projetos com priorização local.",
                                "Biologia: Algoritmos evolutivos inspirados em ganância local."
                              ],
                              "realWorldApplication": "Em roteirização de entregas (ex: Google Maps aproximado), o algoritmo guloso escolhe o próximo ponto mais próximo (local ótimo), sem recalcular todo o caminho, economizando tempo computacional em cenários reais de logística e navegação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Explicar o processo de decisão gulosa",
                            "description": "Descrever o fluxo típico: seleção da melhor escolha imediata, atualização do problema restante e repetição até resolução completa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Decisão Gulosa",
                                  "subSteps": [
                                    "Defina algoritmo guloso como uma estratégia que faz a escolha localmente ótima em cada etapa.",
                                    "Identifique os critérios para propriedade gulosa: escolha ótima local leva à solução ótima global.",
                                    "Revise exemplos iniciais como seleção de moedas para troco mínimo.",
                                    "Anote os três elementos principais: seleção imediata, atualização e repetição.",
                                    "Compare com programação dinâmica para destacar diferenças."
                                  ],
                                  "verification": "Escreva uma definição de 3-5 frases do processo guloso e liste seus componentes principais.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a Khan Academy ou GeeksforGeeks sobre algoritmos gulosos"
                                  ],
                                  "tips": "Use analogias cotidianas, como escolher o lanche mais barato primeiro em um orçamento limitado.",
                                  "learningObjective": "Dominar a definição e princípios básicos para explicar o 'porquê' da decisão gulosa.",
                                  "commonMistakes": "Confundir com busca exaustiva; lembrar que guloso não garante ótimo global sempre."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever a Seleção da Melhor Escolha Imediata",
                                  "subSteps": [
                                    "Explique como ordenar ou avaliar opções pela métrica gulosa (ex: menor valor de troco).",
                                    "Descreva a função de escolha: selecione o item que maximiza o critério local.",
                                    "Ilustre com pseudocódigo: 'enquanto problema não resolvido: escolha = argmax(benefício local)'",
                                    "Discuta como a escolha é 'irrevogável' na abordagem gulosa.",
                                    "Pratique verbalizando: 'Nesta etapa, pegamos a opção que parece melhor agora'."
                                  ],
                                  "verification": "Crie um fluxograma simples mostrando apenas a fase de seleção.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel",
                                    "Pseudocódigo de exemplo online"
                                  ],
                                  "tips": "Sempre relacione à métrica específica do problema para evitar generalizações vagas.",
                                  "learningObjective": "Saber articular precisamente como e por que a escolha imediata é feita.",
                                  "commonMistakes": "Ignorar viabilidade; sempre verificar se a escolha é válida para o subproblema."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Atualização do Problema Restante",
                                  "subSteps": [
                                    "Descreva remover a escolha selecionada e ajustar restrições restantes.",
                                    "Mostre como o subproblema é reduzido: ex: subtrair valor da moeda do troco devido.",
                                    "Explique independência: nova escolha não afeta decisões passadas.",
                                    "Use diagrama: estado inicial → seleção → estado atualizado.",
                                    "Pratique com exemplo: após escolher atividade que termina cedo, ignore horários conflitantes."
                                  ],
                                  "verification": "Simule uma iteração manual em papel para um problema de troco de 36 centavos com moedas [1,5,10,25].",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel para simulação manual",
                                    "Exemplos de problemas gulosos em PDF ou site"
                                  ],
                                  "tips": "Pense como 'limpar a mesa' após cada escolha para visualizar o restante.",
                                  "learningObjective": "Entender como o problema evolui após cada decisão local.",
                                  "commonMistakes": "Não atualizar corretamente restrições, levando a soluções inválidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar a Repetição até Resolução Completa",
                                  "subSteps": [
                                    "Descreva o loop: repetir seleção e atualização até problema resolvido (conjunto vazio).",
                                    "Explique condição de parada: sem opções viáveis ou objetivo alcançado.",
                                    "Sintetize o fluxo completo em um parágrafo coeso.",
                                    "Teste com ciclo completo em exemplo de seleção de atividades.",
                                    "Prepare explicação verbal ou escrita para um público iniciante."
                                  ],
                                  "verification": "Escreva ou grave uma explicação de 1 minuto cobrindo todo o processo.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Gravador de voz ou Google Docs",
                                    "Exemplo completo de algoritmo guloso"
                                  ],
                                  "tips": "Use setas em fluxogramas para mostrar iterações repetidas claramente.",
                                  "learningObjective": "Capacitar a narrar o ciclo inteiro de forma fluida e lógica.",
                                  "commonMistakes": "Parar prematuramente; garantir que o loop cubra todos os casos."
                                }
                              ],
                              "practicalExample": "No problema de troco ótimo com moedas de 1, 5, 10 e 25 centavos para 36 centavos: 1) Selecione 25 (maior ≤36), 2) Atualize para 11 restantes, 3) Selecione 10 (maior ≤11), 4) Atualize para 1, 5) Selecione 1. Repetir até zero.",
                              "finalVerifications": [
                                "Pode listar e ordenar os três passos principais do processo guloso?",
                                "Consegue simular o processo em um exemplo simples sem erros?",
                                "Explica diferenças entre guloso e exaustivo?",
                                "Identifica quando propriedade gulosa se aplica?",
                                "Descreve o processo em menos de 2 minutos com clareza?",
                                "Aplica o processo a um novo problema básico?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos três passos principais (seleção, atualização, repetição).",
                                "Uso de linguagem clara e acessível, sem jargões desnecessários.",
                                "Inclusão de ilustração ou exemplo concreto na explicação.",
                                "Demonstração de compreensão da irrevogabilidade das escolhas.",
                                "Capacidade de relacionar ao contexto de otimização local vs global.",
                                "Fluidez e lógica no fluxo da explicação completa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização e funções objetivo lineares.",
                                "Economia: Tomada de decisões sob restrições de recursos limitados.",
                                "Física: Princípios de minimalidade em caminhos ótimos (ex: refração de luz).",
                                "Negócios: Estratégias de maximização de lucros imediatos em supply chain."
                              ],
                              "realWorldApplication": "Em roteamento GPS (Dijkstra guloso seleciona menor distância imediata), compiladores (alocação de registradores priorizando uso frequente) e planejamento de entregas (selecionar frete mais barato por etapa para otimizar custos totais)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Comparar com backtracking e exaustão",
                            "description": "Analisar por que o método guloso evita exploração exaustiva de todas as possibilidades, destacando sua eficiência em tempo e espaço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Exploração Exaustiva: Backtracking e Exaustão",
                                  "subSteps": [
                                    "Defina exaustão (brute force) como testar todas as combinações possíveis.",
                                    "Explique backtracking como uma busca recursiva que constrói soluções candidatas e abandona ramos inválidos.",
                                    "Identifique exemplos clássicos: N-Rainhas para backtracking, geração de subconjuntos para exaustão.",
                                    "Discuta o espaço de busca exponencial em ambos os métodos.",
                                    "Compare os dois: backtracking poda, mas ainda explora muito."
                                  ],
                                  "verification": "Escreva definições curtas e um diagrama de árvore de busca para um problema simples como subconjuntos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Recursos online: Khan Academy sobre backtracking"
                                  ],
                                  "tips": "Use analogia de labirinto: exaustão verifica todos os caminhos, backtracking para em becos sem saídas.",
                                  "learningObjective": "Compreender os mecanismos de exploração exaustiva e suas limitações iniciais.",
                                  "commonMistakes": [
                                    "Confundir backtracking com guloso (guloso não retrocede)",
                                    "Ignorar poda no backtracking"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Método Guloso e sua Estratégia de Escolha Local",
                                  "subSteps": [
                                    "Defina método guloso: faz escolhas localmente ótimas esperando otimalidade global.",
                                    "Descreva princípios: viabilidade, irrevogabilidade, otimalidade (greedy choice property).",
                                    "Exemplo básico: seleção de moedas ou atividades sem sobreposição.",
                                    "Explique ausência de retrocesso: uma vez escolhido, não revisita.",
                                    "Discuta condições para garantia de otimalidade (matroide, submodularidade)."
                                  ],
                                  "verification": "Implemente pseudocódigo simples para problema de seleção de atividades guloso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Vídeo: 'Greedy Algorithms' no YouTube (MIT OCW)"
                                  ],
                                  "tips": "Pense em 'ganância': pega o melhor imediato sem olhar o futuro distante.",
                                  "learningObjective": "Dominar como o guloso evita exploração total por decisões irrevogáveis.",
                                  "commonMistakes": [
                                    "Achar que guloso sempre é ótimo (não é, ex: knapsack 0/1)",
                                    "Confundir com programação dinâmica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Mecanismos de Exploração e Decisão",
                                  "subSteps": [
                                    "Compare exploração: exaustão/backtracking visitam todas/não viáveis; guloso segue um caminho único.",
                                    "Analise decisão: guloso usa heurística local vs. verificação global nos outros.",
                                    "Discuta trade-offs: guloso rápido mas pode falhar em otimalidade; exaustão correto mas lento.",
                                    "Use tabela comparativa: colunas para método, exploração, retrocesso, garantia.",
                                    "Exemplo: problema de intervalo de atividades – brute force 2^n vs. guloso O(n log n)."
                                  ],
                                  "verification": "Crie uma tabela comparativa preenchida para 2 problemas (atividades e frações).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Artigo: 'Greedy vs Brute Force' no GeeksforGeeks"
                                  ],
                                  "tips": "Visualize árvores: backtracking tem galhos múltiplos, guloso é uma linha reta.",
                                  "learningObjective": "Identificar diferenças qualitativas na forma como cada método navega o espaço de soluções.",
                                  "commonMistakes": [
                                    "Subestimar casos onde guloso falha",
                                    "Ignorar que backtracking pode ser exponencial mesmo com poda"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Eficiência em Tempo e Espaço",
                                  "subSteps": [
                                    "Calcule complexidades: exaustão O(2^n), backtracking O(n!), guloso O(n log n) ou O(n).",
                                    "Compare espaço: recursão profunda em backtracking usa pilha O(n), guloso O(1) extra.",
                                    "Grafique curvas de crescimento para n=20-30 (guloso linear vs. exponencial).",
                                    "Discuta escalabilidade: guloso para instâncias grandes, exaustão só para pequenas.",
                                    "Conclua vantagens: guloso evita explosão combinatória."
                                  ],
                                  "verification": "Plote gráfico simples de tempo vs. n para os três métodos usando ferramenta online.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Desmos ou Python/Matplotlib para gráficos",
                                    "Tabela de complexidades de referência"
                                  ],
                                  "tips": "Use notação Big-O: exponencial cresce rápido, polinomial é gerenciável.",
                                  "learningObjective": "Quantificar por que guloso é eficiente, evitando exaustão.",
                                  "commonMistakes": [
                                    "Confundir tempo médio com pior caso",
                                    "Esquecer espaço auxiliar em guloso (heap)"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de Seleção de Atividades (múltiplas atividades com horários sobrepostos, maximizar número sem conflito): Brute force testa 2^n subconjuntos (tempo explosivo); Backtracking constrói sequências recusivamente, podando inválidas (ainda O(n!)); Guloso ordena por fim mais cedo e seleciona greedy (O(n log n), espaço O(n)). Para 20 atividades, brute force é inviável, guloso instantâneo.",
                              "finalVerifications": [
                                "Explique verbalmente diferenças em exploração para um colega.",
                                "Resolva um problema pequeno manualmente com os três métodos.",
                                "Identifique quando guloso falha vs. backtracking succeeds.",
                                "Compare tempos para n=10 em pseudocódigo.",
                                "Desenhe árvore de busca contrastando os métodos.",
                                "Liste 3 problemas onde guloso é preferível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre exploração exaustiva e greedy (80% correto).",
                                "Uso correto de notação Big-O para complexidades (todas calculadas).",
                                "Exemplos relevantes e tabelas comparativas completas.",
                                "Explicação clara de eficiência em tempo/espaço com gráficos.",
                                "Identificação de limitações do guloso.",
                                "Conexão com propriedades greedy choice."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (seleção de vértices independentes).",
                                "Otimização: Pesquisa Operacional (problemas de mochila e scheduling).",
                                "Física: Modelagem de sistemas com restrições locais (ex: refração de luz).",
                                "Economia: Decisões marginais e ganância em alocação de recursos."
                              ],
                              "realWorldApplication": "Em roteirização de entregas (ex: Google Maps ou apps de delivery), guloso seleciona próxima parada mais curta (eficiente para milhões de pontos), evitando exaustão que travaria o sistema; economiza bateria em dispositivos móveis e permite atualizações em tempo real."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Propriedades de Otimalidade",
                        "description": "Estudo das condições matemáticas que garantem que soluções locais levem à solução global ótima no método guloso.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Entender a Propriedade de Escolha Gulosa",
                            "description": "Explicar que existe uma escolha gulosa ótima que pode ser incluída em alguma solução ótima global, permitindo construção incremental.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Algoritmos Gulosos",
                                  "subSteps": [
                                    "Leia a definição de algoritmo guloso: faz escolhas localmente ótimas na esperança de solução global ótima.",
                                    "Identifique características: irrevogabilidade das escolhas e construção incremental.",
                                    "Estude exemplos básicos como seleção de atividades ou troco ótimo.",
                                    "Anote diferenças entre guloso e exaustivo (brute force).",
                                    "Resuma em um diagrama as etapas típicas de um algoritmo guloso."
                                  ],
                                  "verification": "Crie um resumo de 100 palavras explicando o que é um algoritmo guloso e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Algorithms' (CLRS), Capítulo 16",
                                    "Vídeo Khan Academy sobre Algoritmos Guloso",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias cotidianas, como escolher o menor troco disponível primeiro em uma loja.",
                                  "learningObjective": "Compreender o conceito base de algoritmos guloso para contextualizar a propriedade de escolha.",
                                  "commonMistakes": [
                                    "Confundir guloso com recursivo",
                                    "Ignorar a irrevogabilidade das escolhas",
                                    "Achar que todo problema guloso é sempre ótimo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Propriedade de Escolha Gulosa",
                                  "subSteps": [
                                    "Defina formalmente: Em uma solução ótima global O*, existe pelo menos uma escolha gulosa ótima g que pertence a O*.",
                                    "Explique 'escolha gulosa ótima': a melhor escolha local possível pelo critério guloso.",
                                    "Diferencie de propriedade de otimalidade subestrutura.",
                                    "Escreva a propriedade em pseudocódigo ou notação matemática: O* contém g.",
                                    "Discuta implicações: permite remover g e resolver subproblema recursivamente."
                                  ],
                                  "verification": "Escreva a definição da propriedade em suas palavras e forneça um pseudocódigo ilustrativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas do Step 1",
                                    "Artigo Wikipedia 'Greedy algorithm' seção Provas",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Pense na propriedade como 'uma peça do quebra-cabeça ótima encaixa na solução gulosa'.",
                                  "learningObjective": "Dominar a definição precisa da propriedade de escolha gulosa.",
                                  "commonMistakes": [
                                    "Confundir com troca ótima (exchange property)",
                                    "Achar que toda escolha gulosa está em toda solução ótima",
                                    "Ignorar o 'pelo menos uma'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Importância para Construção Incremental",
                                  "subSteps": [
                                    "Explique como a propriedade permite prova por indução: base + passo indutivo removendo g.",
                                    "Descreva o processo: Escolha g, inclua em solução, resolva subproblema de forma ótima.",
                                    "Compare com casos onde propriedade falha (ex: problema do knapsack 0/1).",
                                    "Crie um fluxograma mostrando construção incremental usando a propriedade.",
                                    "Discuta condições para propriedade valer (matroide, etc., em nível introdutório)."
                                  ],
                                  "verification": "Desenhe um fluxograma da prova por indução usando a propriedade e explique verbalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fluxograma tool como Draw.io",
                                    "Exemplos de CLRS",
                                    "Vídeo MIT OCW sobre Guloso"
                                  ],
                                  "tips": "Visualize como 'cortando' a escolha gulosa da solução ótima, o resto permanece ótimo.",
                                  "learningObjective": "Entender como a propriedade habilita soluções corretas e provas de otimalidade.",
                                  "commonMistakes": [
                                    "Pular a indução e achar que basta escolher sempre o melhor local",
                                    "Confundir com propriedade de subestrutura de PD",
                                    "Não testar com contraexemplos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em um Exemplo Prático",
                                  "subSteps": [
                                    "Escolha o problema de Seleção de Atividades: ordene por fim mais cedo.",
                                    "Identifique a escolha gulosa: atividade com menor tempo de fim.",
                                    "Prove a propriedade: mostre que ela está em alguma solução ótima.",
                                    "Simule a construção: inclua, remova conflito, repita.",
                                    "Teste com um conjunto de 5 atividades e verifique otimalidade."
                                  ],
                                  "verification": "Resolva o exemplo com 5 atividades e prove que a solução gulosa é ótima usando a propriedade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel para simulação",
                                    "Exemplo pronto de seleção de atividades",
                                    "Calculadora"
                                  ],
                                  "tips": "Comece com atividades sobrepostas para ver conflitos claramente.",
                                  "learningObjective": "Aplicar a propriedade para validar um algoritmo guloso clássico.",
                                  "commonMistakes": [
                                    "Ordenar errado (por início em vez de fim)",
                                    "Não provar a propriedade explicitamente",
                                    "Usar brute force sem comparar"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de Seleção de Atividades, considere atividades A(1-4), B(3-5), C(0-6), D(5-7), E(8-9), F(8-11). A escolha gulosa ótima é A (termina primeiro em 4). Qualquer solução ótima (ex: A,D,E) inclui A. Remova A, resolva subproblema {D,E} recursivamente.",
                              "finalVerifications": [
                                "Defina corretamente a propriedade de escolha gulosa em termos precisos.",
                                "Identifique a escolha gulosa ótima em um exemplo dado.",
                                "Prove usando indução que a propriedade leva a solução ótima.",
                                "Distinga problemas onde a propriedade vale de onde não vale.",
                                "Aplique em um novo exemplo simples como troco com moedas canônicas.",
                                "Explique por que falha em knapsack 0/1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (sem omissões chave).",
                                "Clareza na explicação da prova por indução.",
                                "Correção na identificação e aplicação em exemplos.",
                                "Uso de terminologia técnica apropriada.",
                                "Capacidade de contraexemplos para casos de falha.",
                                "Profundidade na conexão com construção incremental."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização linear e indução matemática.",
                                "Economia: Decisões marginais e escolhas locais em alocação de recursos.",
                                "Física: Princípio da menor ação em trajetórias ótimas.",
                                "Gestão: Planejamento de projetos priorizando tarefas curtas (CPM)."
                              ],
                              "realWorldApplication": "Em roteirização de entregas (Vehicle Routing), escolher a entrega mais próxima primeiro como escolha gulosa, garantindo que ela faça parte de uma rota ótima global, otimizando combustível e tempo em logística como Amazon ou Uber Eats."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Compreender a Subestrutura Ótima",
                            "description": "Reconhecer que o problema restante após uma escolha gulosa ótima possui subestrutura ótima, similar à divisão e conquista.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Subestrutura Ótima em Divide-and-Conquer",
                                  "subSteps": [
                                    "Estude a definição de subestrutura ótima em algoritmos divide-and-conquer, como no problema de pontos mais próximos ou merge sort.",
                                    "Identifique como o problema original é dividido em subproblemas independentes cujas soluções ótimas compõem a solução global.",
                                    "Analise um exemplo simples, desenhando a árvore de recursão para visualizar a composição.",
                                    "Explique por que a otimalidade é preservada na combinação das soluções dos subproblemas.",
                                    "Registre notas sobre as condições necessárias para subestrutura ótima."
                                  ],
                                  "verification": "Escreva um parágrafo explicando subestrutura ótima em divide-and-conquer com um diagrama simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre divide-and-conquer",
                                    "Vídeo tutorial de 10 minutos sobre merge sort",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use diagramas de árvore para visualizar a divisão recursiva e composição.",
                                  "learningObjective": "Compreender o conceito fundamental de subestrutura ótima em algoritmos clássicos.",
                                  "commonMistakes": "Confundir subestrutura ótima com sobreposição de subproblemas típica de programação dinâmica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Processo Guloso e Identificar o Subproblema Restante",
                                  "subSteps": [
                                    "Selecione um problema guloso clássico como Agendamento de Intervalos (Interval Scheduling).",
                                    "Descreva a escolha gulosa ótima: selecione a atividade compatível que termina primeiro.",
                                    "Defina o subproblema restante: conjunto de atividades que iniciam após o término da escolhida.",
                                    "Ordene as atividades por tempo de término e simule a primeira iteração.",
                                    "Confirme que o subproblema tem a mesma forma do problema original."
                                  ],
                                  "verification": "Desenhe um gráfico de linha do tempo com atividades e circule a escolha gulosa e o subproblema.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplo de 8-10 atividades com horários de início/fim",
                                    "Ferramenta de desenho como Draw.io ou papel"
                                  ],
                                  "tips": "Sempre ordene previamente por tempo de término para simular corretamente.",
                                  "learningObjective": "Reconhecer como a escolha gulosa reduz o problema a um subproblema estruturalmente similar.",
                                  "commonMistakes": "Não verificar compatibilidade das atividades restantes com a escolha gulosa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a Propriedade de Subestrutura Ótima no Contexto Guloso",
                                  "subSteps": [
                                    "Assuma uma solução ótima S* para o problema original que não inclui a escolha gulosa g.",
                                    "Mostre via troca de elementos: substitua o primeiro elemento de S* por g sem diminuir o número de atividades.",
                                    "Prove que o subproblema restante tem solução ótima S'** que combina com g para formar solução ótima global.",
                                    "Use prova por casos ou contradição para validar a preservação da otimalidade.",
                                    "Teste com um conjunto pequeno de atividades para validar empiricamente."
                                  ],
                                  "verification": "Escreva uma prova curta de 200-300 palavras ou um argumento formal para o exemplo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Pseudocódigo do algoritmo guloso para Interval Scheduling",
                                    "Livro-texto ou slides sobre propriedades gulosas"
                                  ],
                                  "tips": " Empregue a técnica de 'troca gulosa' comum em provas de otimalidade.",
                                  "learningObjective": "Demonstrar matematicamente que o subproblema guloso preserva otimalidade.",
                                  "commonMistakes": "Assumir otimalidade sem considerar soluções alternativas que possam ser melhores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Divide-and-Conquer e Generalizar para Outros Problemas",
                                  "subSteps": [
                                    "Compare a recursão gulosa (escolha + subproblema) com divide-and-conquer (dividir + conquistar + combinar).",
                                    "Identifique similaridades: ambos dependem de subproblemas ótimos independentes.",
                                    "Aplique a problemas como Árvore Geradora Mínima (MST) ou Codificação de Huffman.",
                                    "Discuta contraexemplos onde falha, como Knapsack 0/1.",
                                    "Crie uma tabela resumindo problemas com essa propriedade."
                                  ],
                                  "verification": "Elabore uma tabela comparativa e liste 3 problemas gulosos com subestrutura ótima.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de problemas gulosos clássicos",
                                    "Planilha ou tabela em Markdown"
                                  ],
                                  "tips": "Foque em padrões recorrentes nas provas de otimalidade gulosa.",
                                  "learningObjective": "Generalizar a subestrutura ótima como ponte conceitual entre paradigmas.",
                                  "commonMistakes": "Generalizar erroneamente para todos os problemas resolvidos por heurística gulosa."
                                }
                              ],
                              "practicalExample": "No Agendamento de Intervalos, considere atividades A(1-4), B(3-5), C(0-6), D(5-7), E(8-9), F(8-10). Escolha gulosa: A (termina em 4). Subproblema restante: D(5-7), E(8-9), F(8-10) — idêntico ao original, permitindo seleção gulosa de D, depois E.",
                              "finalVerifications": [
                                "Explica corretamente a composição da solução ótima após escolha gulosa?",
                                "Identifica precisamente o subproblema restante em um exemplo?",
                                "Valida a propriedade via prova de troca ou contradição?",
                                "Compara adequadamente com divide-and-conquer?",
                                "Aplica a propriedade a pelo menos dois problemas gulosos adicionais?",
                                "Reconhece limitações em problemas sem subestrutura ótima?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual da subestrutura ótima (25%)",
                                "Qualidade da análise e prova do subproblema (25%)",
                                "Uso efetivo de exemplos e diagramas (20%)",
                                "Profundidade da comparação com outros paradigmas (15%)",
                                "Clareza e generalização para aplicações (10%)",
                                "Identificação de erros comuns e limitações (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução matemática e recursão em provas de corretude",
                                "Economia: Otimização sequencial de recursos escassos",
                                "Engenharia de Software: Design de algoritmos eficientes e escaláveis",
                                "Gestão: Planejamento de cronogramas e alocação ótima de tarefas"
                              ],
                              "realWorldApplication": "Em logística de entregas (como rotas de caminhões), após selecionar a entrega mais próxima viável (gulosa), o subproblema das entregas restantes preserva estrutura ótima, permitindo planejamento recursivo eficiente; similar em compiladores para codificação ótima de dados em redes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Verificar otimalidade em problemas",
                            "description": "Aplicar testes para propriedades guloso-compatíveis, identificando quando o método garante solução ótima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as três propriedades fundamentais do método guloso",
                                  "subSteps": [
                                    "Estude a propriedade de subestrutura ótima: soluções ótimas de subproblemas compõem a solução ótima global.",
                                    "Analise a propriedade de escolha gulosa: a escolha local ótima pode ser estendida para solução ótima global.",
                                    "Revise a propriedade de otimalidade segura: a escolha gulosa leva a uma solução ótima.",
                                    "Compare com exemplos clássicos como seleção de atividades.",
                                    "Anote definições em suas próprias palavras."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando cada propriedade com um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Algoritmos (ex: Cormen), caderno e caneta, acesso a slides online sobre algoritmos gulosos"
                                  ],
                                  "tips": "Use diagramas para visualizar como subproblemas se conectam na solução global.",
                                  "learningObjective": "Identificar e definir precisamente as três propriedades que garantem otimalidade no método guloso.",
                                  "commonMistakes": "Confundir escolha gulosa com solução ótima sem verificar subestrutura."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender os testes sistemáticos para verificar cada propriedade",
                                  "subSteps": [
                                    "Para subestrutura ótima: tente construir solução ótima sem a escolha gulosa e veja se falha.",
                                    "Para escolha gulosa: prove que qualquer solução ótima deve incluir a escolha gulosa.",
                                    "Para otimalidade segura: mostre por indução que após a escolha, o subproblema restante é ótimo.",
                                    "Pratique formalizando testes matemáticos com notação Σ ou indução.",
                                    "Liste critérios de falha para cada teste."
                                  ],
                                  "verification": "Crie uma tabela com as três propriedades, testes e exemplos de prova para cada uma.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel quadriculado, calculadora, vídeo-aulas sobre provas de algoritmos gulosos (YouTube/Khan Academy)"
                                  ],
                                  "tips": "Comece com indução forte para otimalidade segura; desenhe árvores de decisões.",
                                  "learningObjective": "Dominar os procedimentos formais para testar propriedades guloso-compatíveis.",
                                  "commonMistakes": "Ignorar contra-exemplos ao testar subestrutura ótima."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar testes em um problema exemplo para verificar otimalidade",
                                  "subSteps": [
                                    "Escolha o problema de seleção de atividades: ordene por tempo de fim.",
                                    "Aplique teste de subestrutura ótima: prove para subconjunto de atividades.",
                                    "Teste escolha gulosa: mostre que a atividade com menor fim deve ser incluída.",
                                    "Verifique otimalidade segura via indução no número de atividades.",
                                    "Compare solução gulosa com ótima exaustiva."
                                  ],
                                  "verification": "Implemente o algoritmo guloso em pseudocódigo e prove otimalidade com os três testes.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE simples (ex: VS Code), conjunto de dados de exemplo com 10 atividades"
                                  ],
                                  "tips": "Use intervalos sobrepostos para testar falhas potenciais.",
                                  "learningObjective": "Executar testes completos em um problema conhecido para confirmar garantia de otimalidade.",
                                  "commonMistakes": "Assumir otimalidade sem prova formal de todos os testes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar problemas não-gulosos e generalizar a verificação",
                                  "subSteps": [
                                    "Analise problema da mochila 0/1: aplique testes e encontre falha na escolha gulosa.",
                                    "Crie um contra-exemplo onde guloso falha (ex: pesos e valores desbalanceados).",
                                    "Generalize: liste características de problemas guloso-compatíveis (matroide, etc.).",
                                    "Pratique em 2-3 problemas variados (ex: Huffman vs. Dijkstra).",
                                    "Documente quando recorrer a programação dinâmica."
                                  ],
                                  "verification": "Para dois problemas, um guloso e um não, escreva relatório de 1 página com testes e conclusão.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Lista de problemas de algoritmos online (LeetCode, GeeksforGeeks), timer para prática"
                                  ],
                                  "tips": "Sempre busque contra-exemplos primeiro para refutar otimalidade gulosa.",
                                  "learningObjective": "Diferenciar problemas ótimos-gulosos de não-ótimos e justificar com testes.",
                                  "commonMistakes": "Generalizar sucesso em um exemplo para todos os problemas similares."
                                }
                              ],
                              "practicalExample": "No problema de Seleção de Atividades, dado atividades com intervalos [1,4], [3,5], [0,6], [5,7], ordenadas por fim: selecione [1,4], depois [5,7]. Testes confirmam: subestrutura ótima (subproblemas após fim), escolha gulosa (primeiro fim menor é ótimo), otimalidade segura (indução prova máximo).",
                              "finalVerifications": [
                                "Lista corretamente as três propriedades com definições precisas.",
                                "Aplica testes em um novo problema e conclui corretamente se é guloso-ótimo.",
                                "Identifica contra-exemplo válido para problema não-guloso.",
                                "Prova otimalidade por indução em exemplo clássico.",
                                "Explica por que um algoritmo guloso falha em caso específico.",
                                "Gera lista de 5 problemas guloso-compatíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e testes das propriedades (80% acerto).",
                                "Capacidade de provar otimalidade formalmente em exemplos.",
                                "Identificação correta de falhas em contra-exemplos.",
                                "Uso consistente de indução e contra-exemplos.",
                                "Generalização para novos problemas sem erros lógicos.",
                                "Clareza na documentação de verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Otimização e Indução Matemática.",
                                "Economia: Alocação ótima de recursos escassos.",
                                "Engenharia de Software: Design de heurísticas eficientes.",
                                "Física: Modelagem de sistemas com escolhas locais ótimas (ex: trajetórias mínimas)."
                              ],
                              "realWorldApplication": "Em logística, verificar se ordenar entregas por distância mais curta garante rota ótima (guloso-compatível em certos grafos); em finanças, testar se selecionar investimentos por maior ROI imediato leva a portfólio ótimo; em compiladores, otimizar código com escolhas gulosas seguras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.4",
                            "name": "Analisar falhas de otimalidade",
                            "description": "Identificar cenários onde propriedades não se aplicam, como no problema da mochila fracionária vs. 0-1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Propriedades de Otimalidade para Algoritmos Gulosos",
                                  "subSteps": [
                                    "Defina propriedade de escolha gulosa ótima: uma escolha local ótima leva a uma solução global ótima.",
                                    "Defina propriedade de subestrutura ótima: a solução ótima para o problema inclui soluções ótimas para subproblemas.",
                                    "Estude exemplos onde ambas as propriedades se aplicam, como seleção de atividades.",
                                    "Identifique pré-requisitos: conhecimento básico de algoritmos gulosos e problemas de otimização.",
                                    "Anote as condições necessárias para um algoritmo guloso ser correto."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando as duas propriedades com um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de algoritmos (ex: CLRS), notas de aula, papel e caneta",
                                  "tips": "Use diagramas para visualizar como a escolha gulosa se propaga para a solução global.",
                                  "learningObjective": "Compreender as condições teóricas que garantem a otimalidade de algoritmos gulosos.",
                                  "commonMistakes": "Confundir escolha gulosa com heurística sem propriedades de otimalidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Problema da Mochila Fracionária",
                                  "subSteps": [
                                    "Descreva o problema: maximizar valor com peso limitado, itens fracionáveis.",
                                    "Implemente ou simule o algoritmo guloso: ordene por valor/densidade de peso.",
                                    "Prove por que funciona: escolha gulosa preserva otimalidade devido à fracionabilidade.",
                                    "Calcule um exemplo numérico com 3 itens e capacidade 10.",
                                    "Compare com solução ótima via programação dinâmica simples."
                                  ],
                                  "verification": "Resolva um exemplo com itens de densidades variadas e confirme que guloso = ótimo.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Calculadora ou Python/Jupyter para simulações, exemplos online de mochila fracionária",
                                  "tips": "Sempre ordene por densidade decrescente e preencha até o limite exato.",
                                  "learningObjective": "Reconhecer cenários onde propriedades de otimalidade se aplicam perfeitamente.",
                                  "commonMistakes": "Ignorar que fracionabilidade permite ajuste fino sem perda de otimalidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Problema da Mochila 0-1 e Falhas do Guloso",
                                  "subSteps": [
                                    "Descreva o problema: itens indivisíveis (0-1), maximizar valor com peso limitado.",
                                    "Aplique algoritmo guloso por densidade e encontre um contraexemplo.",
                                    "Use exemplo clássico: itens A (peso 2, valor 3), B (peso 3, valor 4), C (peso 3, valor 5), capacidade 5.",
                                    "Mostre que guloso pega A+C (valor 8) mas ótimo é B+C (valor 9).",
                                    "Explique violação: escolha gulosa não preserva subestrutura ótima."
                                  ],
                                  "verification": "Construa e resolva pelo menos dois contraexemplos diferentes, comparando guloso vs. ótimo.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "Papel quadriculado para tabelas, pseudocódigo para guloso e PD",
                                  "tips": "Busque contraexemplos onde itens de alta densidade mas peso grande bloqueiam combinações melhores.",
                                  "learningObjective": "Identificar falhas específicas quando itens são indivisíveis.",
                                  "commonMistakes": "Assumir que guloso sempre falha sem contraexemplo concreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar Identificação de Falhas de Otimalidade",
                                  "subSteps": [
                                    "Liste critérios para detectar falhas: ausência de subestrutura ótima ou escolha gulosa não ótima.",
                                    "Aplique a outros problemas: troco ótimo (funciona), mochila 0-1 (falha), Huffman (funciona).",
                                    "Crie um checklist: 1) Pode haver combinações indivisíveis melhores? 2) Escolha local afeta global?",
                                    "Pratique com problema novo: invente um e teste propriedades.",
                                    "Documente padrões comuns de falha em problemas NP-difíceis."
                                  ],
                                  "verification": "Analise 3 problemas adicionais e classifique se guloso é ótimo ou falha, justificando.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Lista de problemas de otimização (Wikipedia, Khan Academy), editor de texto",
                                  "tips": "Sempre valide com contraexemplo pequeno antes de generalizar.",
                                  "learningObjective": "Desenvolver habilidade para prever falhas de otimalidade em novos cenários.",
                                  "commonMistakes": "Generalizar de um exemplo sem testar múltiplos casos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Sintetizar Análise de Falhas",
                                  "subSteps": [
                                    "Resolva exercícios mistos: identifique falhas em 5 cenários propostos.",
                                    "Compare guloso vs. exaustivo/PD em código simples.",
                                    "Escreva relatório: 'Quando propriedades falham e por quê'.",
                                    "Discuta limitações: heurística vs. garantia de otimalidade.",
                                    "Autoavalie usando critérios de verificação finais."
                                  ],
                                  "verification": "Produza um portfólio com 3 análises completas de falhas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente de programação (Python), problemas de prática online (LeetCode, HackerRank)",
                                  "tips": "Implemente código para automatizar testes de contraexemplos.",
                                  "learningObjective": "Consolidar análise crítica de otimalidade em contextos variados.",
                                  "commonMistakes": "Focar só em mochila sem generalizar para outros paradigmas."
                                }
                              ],
                              "practicalExample": "No problema da mochila 0-1 com capacidade 5: Item1 (peso=2, valor=3, densidade=1.5), Item2 (peso=3, valor=4, densidade=1.33), Item3 (peso=3, valor=5, densidade=1.67). Guloso pega Item1+Item3 (peso=5, valor=8), mas ótimo é Item2+Item3 (peso=6? Espera, ajuste: Item2+Item3 excede, wait clássico: Item1 (10/60), Item2(20/100), Item3(30/60), cap=50. Guloso: Item2(20)+Item1 parcial mas 0-1: pega Item2+Item3? Use padrão: dois itens grandes vs. três pequenos.",
                              "finalVerifications": [
                                "Explica corretamente por que guloso falha na mochila 0-1 com contraexemplo numérico.",
                                "Identifica propriedades violadas em cenários dados.",
                                "Constrói contraexemplo original para um novo problema.",
                                "Compara sucesso na fracionária vs. falha na 0-1.",
                                "Lista critérios gerais para prever falhas de otimalidade.",
                                "Aplica análise a pelo menos dois problemas além da mochila."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de propriedades de otimalidade (30%)",
                                "Qualidade e validade de contraexemplos (25%)",
                                "Profundidade de análise de falhas (20%)",
                                "Generalização para outros problemas (15%)",
                                "Clareza na explicação e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização linear e inteira, programação dinâmica.",
                                "Economia: Alocação de recursos limitados e trade-offs indivisíveis.",
                                "Engenharia: Design de heurísticas em sistemas de scheduling.",
                                "Física: Problemas de empacotamento e otimização de carga."
                              ],
                              "realWorldApplication": "Em logística, o guloso por densidade falha ao alocar contêineres indivisíveis (0-1), levando a subutilização; análise de falhas guia uso de PD para rotas de entrega otimizadas em e-commerce como Amazon."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Aplicações e Exemplos Clássicos",
                        "description": "Exploração de problemas resolvidos eficientemente pelo método guloso, com análise de complexidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Implementar codificação de Huffman",
                            "description": "Construir árvore de Huffman para compressão de dados, calculando frequências e unindo nós de menor prioridade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular Frequências dos Caracteres",
                                  "subSteps": [
                                    "Percorra a string de entrada caractere por caractere.",
                                    "Utilize uma estrutura de dados como dicionário ou mapa para contar as ocorrências de cada caractere único.",
                                    "Registre a frequência de cada caractere, ignorando espaços ou caracteres especiais se necessário.",
                                    "Verifique se a soma das frequências equals o comprimento da string.",
                                    "Ordene as frequências em ordem crescente para visualização inicial."
                                  ],
                                  "verification": "Confirme que a soma das frequências corresponde ao tamanho da string de entrada e que todos os caracteres únicos foram capturados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python ou Java recomendado)",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "String de teste exemplo"
                                  ],
                                  "tips": "Use collections.Counter no Python para agilizar o processo.",
                                  "learningObjective": "Compreender como determinar probabilidades de caracteres para priorização na árvore.",
                                  "commonMistakes": [
                                    "Não tratar strings vazias ou com um único caractere.",
                                    "Contar espaços como caracteres separadamente sem intenção.",
                                    "Erros de indexação em linguagens como C++."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Nós da Árvore e Fila de Prioridade",
                                  "subSteps": [
                                    "Crie uma classe ou estrutura para Nó de Huffman com campos: caractere, frequência, nós esquerdo e direito.",
                                    "Inicialize a fila de prioridade (min-heap) com nós folha para cada caractere e sua frequência.",
                                    "Configure a fila para ordenar por frequência crescente.",
                                    "Adicione um identificador único aos nós para depuração.",
                                    "Teste a inserção e extração mínima da fila."
                                  ],
                                  "verification": "Extraia os dois nós de menor frequência e confirme que estão ordenados corretamente pela fila.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca heapq (Python) ou PriorityQueue (Java)",
                                    "Editor de código",
                                    "Exemplo de frequências calculadas"
                                  ],
                                  "tips": "Use heapq.nlargest ou heappushpop para eficiência.",
                                  "learningObjective": "Dominar o uso de filas de prioridade para seleção gulosa de nós mínimos.",
                                  "commonMistakes": [
                                    "Não implementar comparação correta para nós compostos.",
                                    "Esquecer de marcar nós internos sem caractere.",
                                    "Heap máximo em vez de mínimo."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Árvore de Huffman",
                                  "subSteps": [
                                    "Enquanto houver mais de um nó na fila, extraia os dois menores.",
                                    "Crie um novo nó pai com frequência igual à soma dos filhos.",
                                    "Atribua o menor à esquerda e o próximo à direita.",
                                    "Insira o novo nó pai de volta na fila.",
                                    "Repita até restar um único nó raiz."
                                  ],
                                  "verification": "A árvore resultante deve ter altura logarítmica e todos os folhas com caracteres originais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código da fila de prioridade",
                                    "Ferramentas de visualização de árvores (opcional, como Graphviz)"
                                  ],
                                  "tips": "Desenhe a árvore manualmente para o exemplo antes de codificar.",
                                  "learningObjective": "Aplicar o paradigma guloso na construção ótima de árvores de prefixo.",
                                  "commonMistakes": [
                                    "Atribuir filhos incorretamente (esquerda/direita afeta códigos).",
                                    "Loop infinito se fila não diminuir.",
                                    "Não somar frequências corretamente nos pais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar Códigos Huffman a Partir da Árvore",
                                  "subSteps": [
                                    "Inicie uma travessia recursiva ou iterativa da raiz.",
                                    "Atribua '0' para ramo esquerdo e '1' para direito.",
                                    "Colete o código completo apenas nos nós folha (caracteres).",
                                    "Armazene em um dicionário: caractere -> código binário.",
                                    "Valide que nenhum código é prefixo de outro."
                                  ],
                                  "verification": "Todos os códigos gerados devem ser únicos e prefix-free; teste com a string original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Árvore construída",
                                    "Dicionário para mapear códigos"
                                  ],
                                  "tips": "Use recursão com parâmetros current_code e current_node.",
                                  "learningObjective": "Entender como a estrutura da árvore define códigos de comprimento variável.",
                                  "commonMistakes": [
                                    "Gerar códigos em folhas internas.",
                                    "Invertar 0/1 entre esquerda/direita.",
                                    "Sobrecarga de recursão em árvores desbalanceadas."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar Codificação e Decodificação",
                                  "subSteps": [
                                    "Codifique: substitua cada caractere pelo seu código Huffman na string binária.",
                                    "Calcule taxa de compressão: tamanho binário / tamanho original * 8 (bits).",
                                    "Decodifique: inicie na raiz, siga 0 esquerda/1 direita até folha, resete.",
                                    "Teste com a string original para verificar fidelidade.",
                                    "Otimize para grandes entradas com bitstrings."
                                  ],
                                  "verification": "Decodificação deve retornar exatamente a string original; compressão >0% para textos repetitivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Códigos gerados",
                                    "Funções de teste unitário"
                                  ],
                                  "tips": "Use bitarray ou integers para binários eficientes.",
                                  "learningObjective": "Validar a reversibilidade e eficiência da compressão Huffman.",
                                  "commonMistakes": [
                                    "Erro em reset da decodificação (ficar preso).",
                                    "Não alinhar bits corretamente.",
                                    "Ignorar taxa de compressão em avaliação."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a string 'aabc': Frequências a:2, b:1, c:1. Árvore: raiz soma 4, com 'a'(2) e sub-árvore 'b'(1)+'c'(1). Códigos: a:0, b:10, c:11. Codificada: 0 0 10 11 (001011). Decodifica de volta para 'aabc'. Compressão: 6 bits vs 32 bits ASCII.",
                              "finalVerifications": [
                                "A codificação produz string binária mais curta que a original para dados com redundância.",
                                "A decodificação reconstrói perfeitamente a mensagem original.",
                                "Todos os códigos são prefix-free (nenhum é prefixo de outro).",
                                "A árvore tem complexidade O(n log n) em construção.",
                                "Testes com múltiplas strings variam mostram consistência.",
                                "Frequências e códigos coincidem com cálculo manual."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Decodificação 100% fiel.",
                                "Eficiência: Tempo O(n log n), espaço O(n).",
                                "Compressão ótima para frequências dadas (códigos mais curtos para mais frequentes).",
                                "Robustez: Trata casos edge (string vazia, um caractere).",
                                "Clareza: Código comentado e modular.",
                                "Validação: Taxa de compressão calculada e reportada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Informação e Entropia de Shannon.",
                                "Probabilidade e Estatística: Distribuição de frequências e desigualdade.",
                                "Análise de Algoritmos: Complexidade gulosa vs dinâmica.",
                                "Ciência de Dados: Pré-processamento para machine learning compressivo.",
                                "Física: Codificação em telecomunicações e sinal digital."
                              ],
                              "realWorldApplication": "Implementada em algoritmos ZIP, GZIP, PNG, JPEG e MP3 para compressão sem perda de arquivos, reduzindo armazenamento e transmissão de dados em web, backups e streaming."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Resolver problema da seleção de atividades",
                            "description": "Ordenar atividades por tempo de término e selecionar a que termina primeiro compatível, provando otimalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema da Seleção de Atividades",
                                  "subSteps": [
                                    "Defina o problema: dada uma lista de atividades com intervalos de início e fim, selecione o máximo número sem sobreposições.",
                                    "Identifique a estratégia gulosa: ordenar por tempo de término crescente e selecionar a atividade compatível que termina primeiro.",
                                    "Discuta por que guloso funciona aqui: prova via propriedade de escolha gulosa e subestrutura ótima.",
                                    "Represente atividades como pares (início, fim) em uma lista.",
                                    "Crie um exemplo simples com 3-4 atividades para visualizar."
                                  ],
                                  "verification": "Escreva uma definição clara do problema e liste 3 atividades exemplo com horários sem sobreposição possível.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para notas"
                                  ],
                                  "tips": "Sempre desenhe uma linha do tempo para visualizar sobreposições.",
                                  "learningObjective": "Entender a formulação do problema e a intuição do algoritmo guloso.",
                                  "commonMistakes": [
                                    "Confundir ordenação por início em vez de fim",
                                    "Ignorar a necessidade de prova de otimalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ordenar as Atividades por Tempo de Término",
                                  "subSteps": [
                                    "Colete a lista de atividades como array de objetos ou tuplas (início, fim, nome).",
                                    "Implemente ordenação estável por tempo de fim crescente usando sort() em Python ou equivalente.",
                                    "Teste a ordenação com um exemplo: verifique se atividades com fins iguais mantêm ordem relativa.",
                                    "Discuta complexidade: O(n log n) devido à ordenação.",
                                    "Valide que nenhuma atividade sobreposta é priorizada incorretamente."
                                  ],
                                  "verification": "Execute código de ordenação e imprima a lista ordenada; confirme visualmente a ordem dos fins.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Python ou linguagem similar"
                                  ],
                                  "tips": "Use chave de ordenação lambda fim: atividades.sort(key=lambda x: x[1]).",
                                  "learningObjective": "Dominar a etapa crucial de ordenação que habilita a escolha gulosa.",
                                  "commonMistakes": [
                                    "Ordenar por início ao invés de fim",
                                    "Esquecer ordenação estável para empates"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Seleção Gulosa",
                                  "subSteps": [
                                    "Inicie com a primeira atividade (a que termina mais cedo).",
                                    "Itere pela lista ordenada: selecione a próxima atividade cujo início >= fim da última selecionada.",
                                    "Mantenha uma lista de atividades selecionadas e o último fim.",
                                    "Implemente em loop while ou for com índice.",
                                    "Retorne a lista selecionada e seu tamanho."
                                  ],
                                  "verification": "Rode o algoritmo no exemplo e confirme que seleciona o máximo possível sem overlaps.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python com lista de testes"
                                  ],
                                  "tips": "Use uma variável last_end para rastrear o fim da última selecionada.",
                                  "learningObjective": "Codificar o núcleo do algoritmo guloso de forma eficiente O(n).",
                                  "commonMistakes": [
                                    "Selecionar atividade que sobrepõe (erro em >=)",
                                    "Não iterar após a primeira"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a Otimalidade da Solução",
                                  "subSteps": [
                                    "Explique a Propriedade de Escolha Gulosa: a atividade que termina primeiro está em alguma solução ótima.",
                                    "Prove por contradição: suponha solução ótima sem ela, troque por ela sem piorar.",
                                    "Mostre Subestrutura Ótima: após escolha gulosa, resto é instância menor ótima.",
                                    "Indução: base (1 atividade), passo (adicione e prove).",
                                    "Compare com solução ótima conhecida para validar."
                                  ],
                                  "verification": "Escreva prova em pseudocódigo ou parágrafos e teste contra exemplo onde guloso falha em outros problemas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel para prova",
                                    "Exemplos de instâncias ótimas"
                                  ],
                                  "learningObjective": "Compreender e provar por que o guloso é ótimo aqui, não em geral.",
                                  "commonMistakes": [
                                    "Confundir com knapsack onde guloso falha",
                                    "Prova incompleta sem indução"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Analisar a Implementação",
                                  "subSteps": [
                                    "Crie casos de teste: sem overlaps, todos overlaps, empates em fim.",
                                    "Meça tempo de execução para n=1000 atividades.",
                                    "Compare com brute-force para pequenos n.",
                                    "Analise complexidade total O(n log n).",
                                    "Documente código com comentários."
                                  ],
                                  "verification": "Todos testes passam e tamanho selecionado == ótimo conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Gerador de testes aleatórios"
                                  ],
                                  "tips": "Use assert para automação de testes.",
                                  "learningObjective": "Validar implementação e análise de performance.",
                                  "commonMistakes": [
                                    "Testes insuficientes para bordas",
                                    "Ignorar complexidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Atividades: A(1-4), B(3-5), C(0-6), D(5-7), E(3-9), F(8-9), G(8-10). Ordenadas por fim: A(4), B(5), C(6), D(7), F(9), G(10), E(9). Seleção gulosa: A (fim=4), D (5>=4, fim=7), F (8>=7, fim=9). Total: 3, que é ótimo.",
                              "finalVerifications": [
                                "Algoritmo seleciona máximo número de atividades não sobrepostas.",
                                "Ordenação correta por tempo de término crescente.",
                                "Prova de otimalidade inclui escolha gulosa e subestrutura ótima.",
                                "Complexidade O(n log n) confirmada.",
                                "Código passa em casos de borda (n=0,1, todos overlaps).",
                                "Exemplo prático resolvido corretamente."
                              ],
                              "assessmentCriteria": [
                                "Corretude: solução ótima em todos testes.",
                                "Eficiência: ordenação e seleção O(n log n).",
                                "Clareza: código comentado e prova estruturada.",
                                "Completude: todos substeps implementados.",
                                "Robustez: lida com empates e entradas inválidas.",
                                "Análise: prova formal e complexidade explicada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Ordenação e prova por indução.",
                                "Gestão: Otimização de agendamentos de recursos.",
                                "Física: Agendamento de uso de equipamentos laboratoriais.",
                                "Economia: Alocação eficiente de tempo em projetos."
                              ],
                              "realWorldApplication": "Agendamento de salas de aula ou reuniões em empresas para maximizar o número de eventos sem conflitos, otimizando uso de recursos limitados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Aplicar Kruskal para MST",
                            "description": "Implementar algoritmo de Kruskal: ordenar arestas por peso e adicionar sem ciclos usando Union-Find.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a representação do grafo e ordenar as arestas",
                                  "subSteps": [
                                    "Represente o grafo não direcionado como uma lista de arestas, cada uma com vértices u, v e peso w.",
                                    "Colete todas as arestas em uma lista.",
                                    "Ordene a lista de arestas em ordem crescente de peso.",
                                    "Verifique se o grafo está conectado (opcional, usando DFS/BFS)."
                                  ],
                                  "verification": "Lista de arestas ordenada corretamente e sem duplicatas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para esboço",
                                    "Editor de código (Python ou pseudocódigo)"
                                  ],
                                  "tips": "Use tuplas (peso, u, v) para ordenação fácil em Python: sorted(edges, key=lambda x: x[0]).",
                                  "learningObjective": "Compreender a entrada do algoritmo e preparar dados para iteração eficiente.",
                                  "commonMistakes": [
                                    "Esquecer arestas",
                                    "Ordenar incorretamente (decrescente)",
                                    "Não tratar grafos desconexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a estrutura Union-Find (DSU)",
                                  "subSteps": [
                                    "Crie um array parent[] inicializado com parent[i] = i para cada vértice.",
                                    "Implemente a função find(x) com path compression: while parent[x] != x: x = parent[parent[x]].",
                                    "Implemente a função union(x, y): raizX = find(x), raizY = find(y), se diferentes, parent[raizX] = raizY.",
                                    "Adicione rank[] opcional para union by rank e otimizar.",
                                    "Teste find e union em um grafo pequeno."
                                  ],
                                  "verification": "Executar find em todos vértices retorna raízes corretas sem ciclos prematuros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código em Python",
                                    "Exemplos de grafos pequenos"
                                  ],
                                  "tips": "Sempre chame find antes de union para detectar ciclos.",
                                  "learningObjective": "Dominar Union-Find para detecção eficiente de ciclos em grafos.",
                                  "commonMistakes": [
                                    "Não usar path compression",
                                    "Union sem verificar raízes iguais",
                                    "Índices fora do range"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o núcleo do algoritmo Kruskal",
                                  "subSteps": [
                                    "Inicialize MST como lista vazia e contador de arestas = 0.",
                                    "Para cada aresta na lista ordenada: se find(u) != find(v), adicione à MST e union(u,v), incremente contador.",
                                    "Pare quando contador == V-1 (número de vértices menos 1).",
                                    "Registre o custo total somando pesos das arestas na MST.",
                                    "Ignore arestas que formariam ciclos."
                                  ],
                                  "verification": "MST tem exatamente V-1 arestas e nenhum ciclo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de arestas ordenada",
                                    "Estrutura Union-Find implementada"
                                  ],
                                  "tips": "Mantenha um conjunto de vértices para confirmar conectividade.",
                                  "learningObjective": "Aplicar greedy choice property para construir MST incrementalmente.",
                                  "commonMistakes": [
                                    "Adicionar aresta que forma ciclo",
                                    "Continuar após V-1 arestas",
                                    "Erro em soma de custos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e otimizar o resultado",
                                  "subSteps": [
                                    "Verifique se todas arestas na MST conectam o grafo (usar Union-Find final).",
                                    "Calcule o custo total da MST.",
                                    "Compare com Prim's ou custo manual para validação.",
                                    "Otimize código: O(E log E) devido à ordenação.",
                                    "Teste com casos edge: grafo desconexo, uma aresta, ciclo completo."
                                  ],
                                  "verification": "Custo mínimo confirmado e grafo conectado sem ciclos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Ferramentas de teste (asserts)"
                                  ],
                                  "tips": "Para grafos desconexos, retorne 'floresta' em vez de árvore.",
                                  "learningObjective": "Garantir correção e eficiência do algoritmo.",
                                  "commonMistakes": [
                                    "Não detectar grafo desconexo",
                                    "Erros em casos especiais",
                                    "Ineficiência em grandes grafos"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices A,B,C,D. Arestas: A-B(1), B-C(1), A-C(3), B-D(3), C-D(4), A-D(5). Ordenadas: (1,AB),(1,BC),(3,AC),(3,BD),(4,CD),(5,AD). Kruskal adiciona AB, BC (agora ABC conectados), pula AC (ciclo), adiciona BD (conecta D). MST: AB,BC,BD. Custo: 5.",
                              "finalVerifications": [
                                "Lista de arestas ordenada corretamente.",
                                "Union-Find detecta ciclos sem falhas.",
                                "MST tem V-1 arestas e custo mínimo.",
                                "Código roda em O(E log E).",
                                "Testes em grafos variados passam.",
                                "Grafo final é conectado sem ciclos."
                              ],
                              "assessmentCriteria": [
                                "Correção na ordenação e Union-Find (40%).",
                                "Implementação do loop principal sem erros (30%).",
                                "Validação e tratamento de casos edge (15%).",
                                "Eficiência e código limpo (10%).",
                                "Explicação do processo (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Matroides.",
                                "Engenharia: Otimização de redes elétricas.",
                                "Economia: Problemas de custo mínimo em logística.",
                                "Biologia: Filogenia e árvores evolutivas."
                              ],
                              "realWorldApplication": "Projeto de redes de telecomunicações: conectar cidades com cabos de fibra ótica minimizando custo total, evitando loops desnecessários."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Programação Dinâmica",
                    "description": "Método que resolve problemas otimizando subproblemas sobrepostos e reutilizando soluções via memoização ou tabelas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Princípios Fundamentais da Programação Dinâmica",
                        "description": "Conceitos básicos que definem quando e por que usar programação dinâmica, incluindo subproblemas sobrepostos e subestrutura ótima.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Identificar subproblemas sobrepostos",
                            "description": "Analisar uma recursão para detectar subproblemas que se repetem múltiplas vezes, calculando o número de chamadas únicas versus totais para justificar a necessidade de otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Recursão e Subproblemas",
                                  "subSteps": [
                                    "Revise a definição de recursão: uma função que chama a si mesma para resolver subproblemas menores.",
                                    "Identifique o caso base e os subproblemas recursivos em uma função simples.",
                                    "Diferencie subproblemas independentes de sobrepostos, usando diagramas iniciais.",
                                    "Estude exemplos clássicos como Fibonacci recursivo.",
                                    "Anote características de subproblemas sobrepostos: repetição múltipla na árvore de chamadas."
                                  ],
                                  "verification": "Explique em suas palavras o que são subproblemas sobrepostos e dê um exemplo não-Fibonacci.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Notebook com Python para testar recursão simples"
                                  ],
                                  "tips": [
                                    "Comece com funções pequenas (n=4 ou 5) para visualizar facilmente.",
                                    "Desenhe sempre a árvore de chamadas manualmente."
                                  ],
                                  "learningObjective": "Dominar definições chave para análise posterior.",
                                  "commonMistakes": [
                                    "Confundir recursão com iteração.",
                                    "Ignorar casos base ao identificar subproblemas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Visualizar a Árvore de Chamadas Recursivas",
                                  "subSteps": [
                                    "Escolha uma função recursiva exemplo (ex: fib(n)).",
                                    "Desenhe manualmente a árvore de chamadas para n=5, marcando cada chamada.",
                                    "Rotule cada nó com o subproblema (ex: fib(3)).",
                                    "Conte o número total de chamadas na árvore.",
                                    "Implemente a função em código e use print statements para gerar a árvore automaticamente."
                                  ],
                                  "verification": "Desenhe a árvore completa para fib(5) e liste todas as chamadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Papel quadriculado para árvores"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para destacar repetições.",
                                    "Limite n pequeno para evitar árvores grandes."
                                  ],
                                  "learningObjective": "Visualizar estrutura recursiva para detectar padrões.",
                                  "commonMistakes": [
                                    "Erros na contagem de chamadas filhos.",
                                    "Não marcar casos base claramente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar e Quantificar Subproblemas Sobrepostos",
                                  "subSteps": [
                                    "Inspecione a árvore: circule subproblemas que aparecem mais de uma vez.",
                                    "Liste todos os subproblemas únicos (ex: fib(3) aparece quantas vezes?).",
                                    "Calcule chamadas totais vs. únicas: Totais = soma de todos nós; Únicas = número de subproblemas distintos.",
                                    "Compute o fator de sobreposição: Totais / Únicas.",
                                    "Repita para outra função, como binomial coefficients."
                                  ],
                                  "verification": "Para fib(5), forneça: chamadas totais=15, únicas=6, fator=2.5.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para contagem",
                                    "Código Python com contadores"
                                  ],
                                  "tips": [
                                    "Use um conjunto (set) em código para rastrear únicos automaticamente.",
                                    "Compare com funções sem overlap como fatorial."
                                  ],
                                  "learningObjective": "Quantificar overlaps para medir ineficiência.",
                                  "commonMistakes": [
                                    "Contar nós folhas duas vezes.",
                                    "Confundir profundidade com contagem total."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar Otimização e Validar Análise",
                                  "subSteps": [
                                    "Compare tempo/exponencial da recursão pura vs. memoizada.",
                                    "Explique por que overlaps justificam DP: evita recomputação.",
                                    "Implemente memoização e meça chamadas reduzidas.",
                                    "Teste com input maior (n=30) para ver explosão sem otimização.",
                                    "Documente conclusão: 'Overlaps detectados justificam DP quando fator >1.5'."
                                  ],
                                  "verification": "Mostre código memoizado com contagem reduzida e explique economia.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com functools.lru_cache",
                                    "Cronômetro para medir tempo"
                                  ],
                                  "tips": [
                                    "Use @lru_cache para memoização rápida.",
                                    "Registre prints de chamadas antes/depois."
                                  ],
                                  "learningObjective": "Conectar detecção a otimização prática.",
                                  "commonMistakes": [
                                    "Assumir todo recursão tem overlap.",
                                    "Não validar com medições reais."
                                  ]
                                }
                              ],
                              "practicalExample": "Na função recursiva para Fibonacci fib(5): árvore tem 15 chamadas totais, mas apenas 6 subproblemas únicos (fib(0) a fib(5)). fib(2) é chamado 3 vezes, justificando memoização que reduz para 6 chamadas.",
                              "finalVerifications": [
                                "Desenhe árvore correta para fib(6) com contagens exatas.",
                                "Identifique overlaps em função de coeficientes binomiais C(5,3).",
                                "Calcule fator de sobreposição >2 para justificar DP.",
                                "Implemente e compare recursão vs memoizada em tempo/chamadas.",
                                "Explique verbalmente para um par: 'Por que fib(3) é sobreposto?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na árvore de chamadas (100% dos nós corretos).",
                                "Contagem correta de únicas vs totais (erro <5%).",
                                "Identificação de todos overlaps principais.",
                                "Justificativa clara com números quantitativos.",
                                "Aplicação correta de memoização com redução comprovada.",
                                "Análise de outro exemplo além de Fibonacci."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de recorrências e árvores de derivação.",
                                "Engenharia de Software: Otimização de performance e profiling.",
                                "Física: Modelagem de sistemas recursivos como fractais.",
                                "Economia: Otimização de recursos em cadeias de suprimentos."
                              ],
                              "realWorldApplication": "Em machine learning, detectar overlaps em recursões de árvores de decisão acelera treinamento; em computação gráfica, otimiza renderização de fractais como Mandelbrot, reduzindo tempo de horas para segundos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Verificar subestrutura ótima",
                            "description": "Determinar se a solução ótima de um problema pode ser construída de forma eficiente a partir de soluções ótimas de subproblemas, usando exemplos como Fibonacci ou sequências de editância mínima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de subestrutura ótima",
                                  "subSteps": [
                                    "Leia a definição formal: uma solução ótima para o problema pode ser construída eficientemente a partir de soluções ótimas para subproblemas.",
                                    "Identifique os componentes chave: optimalidade das subsoluções e construção eficiente da solução global.",
                                    "Reescreva a definição em suas próprias palavras, usando uma analogia simples (ex: montanha-russa onde cada seção é perfeita).",
                                    "Explique por que isso diferencia DP de recursão ingênua.",
                                    "Discuta os dois requisitos: sobreposição (relacionado, mas separado) e subestrutura ótima."
                                  ],
                                  "verification": "Explique o conceito para um colega ou grave um vídeo de 1 minuto resumindo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Algorithms' (CLRS), capítulo de Programação Dinâmica",
                                    "Notas em papel ou editor de texto"
                                  ],
                                  "tips": "Use diagramas de árvore de recursão para visualizar como subsoluções se combinam.",
                                  "learningObjective": "Definir precisamente subestrutura ótima e seus requisitos.",
                                  "commonMistakes": "Confundir com 'sobreposição de subproblemas'; subestrutura foca em optimalidade, não só reutilização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar subestrutura ótima no Fibonacci",
                                  "subSteps": [
                                    "Revise a recorrência: F(n) = F(n-1) + F(n-2), com F(0)=0, F(1)=1.",
                                    "Construa a tabela DP para F(6) manualmente.",
                                    "Verifique: F(5) é ótima? Sim, pois é unívoca. F(6) = F(5) + F(4), ambas ótimas.",
                                    "Demonstre eficiência: valores são reutilizados sem recomputação.",
                                    "Argumente por indução: assuma para k < n, então para n."
                                  ],
                                  "verification": "Desenhe a tabela DP para F(6) e anote quais subsoluções são usadas na solução ótima.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela",
                                    "Python ou calculadora para validar valores"
                                  ],
                                  "tips": "Comece com n pequeno (F(3)) para ver o padrão claramente.",
                                  "learningObjective": "Identificar e justificar subestrutura ótima em um problema clássico.",
                                  "commonMistakes": "Assumir optimalidade sem prova; sempre use indução para problemas recursivos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar subestrutura ótima na Distância de Edição",
                                  "subSteps": [
                                    "Entenda o problema: mínimo de operações (insert, delete, substitute) para transformar S1 em S2.",
                                    "Escreva a recorrência DP: dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1] + custo).",
                                    "Construa tabela para S1='kit', S2='sit'.",
                                    "Verifique: cada dp[i][j] é ótimo para prefixos i,j? Sim, por escolha mínima das opções ótimas.",
                                    "Mostre construção da solução global a partir da tabela preenchida."
                                  ],
                                  "verification": "Preencha a tabela para o exemplo e trace o caminho ótimo, justificando subsoluções.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado para tabela 4x4",
                                    "Implementação Python simples de Levenshtein"
                                  ],
                                  "tips": "Preencha a tabela linha por linha, focando em como células dependem de vizinhas ótimas.",
                                  "learningObjective": "Aplicar verificação em problema de strings com múltiplas escolhas.",
                                  "commonMistakes": "Ignorar casos base (strings vazias); sempre inicialize dp[0][j] e dp[i][0]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver e aplicar checklist geral para verificação",
                                  "subSteps": [
                                    "Crie checklist: 1. Subproblemas claros? 2. Solução ótima global usa só ótimas subs? 3. Combinação eficiente? 4. Prova por indução possível?",
                                    "Teste em problema com propriedade: Longest Common Subsequence (LCS).",
                                    "Teste em problema sem: Torre de Hanói (movimentos não se decompõem em ótimos independentes).",
                                    "Aplique a um novo problema: problema da mochila 0/1.",
                                    "Registre conclusões em um relatório curto."
                                  ],
                                  "verification": "Use o checklist em dois problemas novos e justifique respostas por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de problemas DP (online: GeeksforGeeks)",
                                    "Planilha ou documento para checklist"
                                  ],
                                  "tips": "Para contraexemplos, procure problemas onde greedy falha mas DP não se aplica diretamente.",
                                  "learningObjective": "Criar método sistemático para verificar subestrutura ótima em qualquer problema.",
                                  "commonMistakes": "Checklist incompleto; sempre inclua prova de optimalidade das subsoluções."
                                }
                              ],
                              "practicalExample": "No Fibonacci F(5): solução ótima é 5, construída de F(4)=3 (ótima para n=4) + F(3)=2 (ótima para n=3), consultados em O(1) da tabela DP, evitando recomputação exponencial.",
                              "finalVerifications": [
                                "Explica definição com precisão, incluindo eficiência.",
                                "Justifica subestrutura em Fibonacci e Distância de Edição com tabelas.",
                                "Aplica checklist corretamente a problemas com e sem a propriedade.",
                                "Identifica erros comuns em análises de outros alunos.",
                                "Prova por indução em pelo menos um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual e uso de termos corretos (30%)",
                                "Qualidade das tabelas DP e análises de exemplos (25%)",
                                "Profundidade da prova por indução (20%)",
                                "Criatividade e acurácia do checklist geral (15%)",
                                "Identificação de contraexemplos e distinções claras (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de recorrência e indução matemática.",
                                "Economia: Otimização dinâmica em modelos de decisão sequencial.",
                                "Bioinformática: Alinhamento de sequências genéticas via distância de edição.",
                                "Engenharia de Software: Refatoração de código com decomposição ótima."
                              ],
                              "realWorldApplication": "Verificar subestrutura ótima permite aplicar DP em cenários reais como correção ortográfica (distância de edição em processadores de texto), otimização de rotas em GPS (shortest path com restrições), análise de genomas em bioinformática e alocação de recursos em gerenciamento de projetos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Comparar com outros paradigmas",
                            "description": "Diferenciar programação dinâmica de divisão e conquista e método guloso, destacando a presença de sobreposições e optimalidade em problemas como a mochila.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Programação Dinâmica (DP)",
                                  "subSteps": [
                                    "Identifique os princípios chave da DP: subproblemas sobrepostos e estrutura ótima.",
                                    "Estude como a DP usa memoização ou tabelas bottom-up para evitar recomputações.",
                                    "Analise o problema da mochila como exemplo clássico de DP.",
                                    "Implemente uma versão simples da DP para mochila em pseudocódigo.",
                                    "Compare complexidade temporal: O(nW) para mochila."
                                  ],
                                  "verification": "Crie uma tabela DP manual para uma instância pequena de mochila e verifique se resolve corretamente sem recomputações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GeeksforGeeks: Dynamic Programming",
                                    "Livro 'Introduction to Algorithms' (CLRS), Capítulo 15",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Sempre desenhe a tabela DP antes de codificar para visualizar sobreposições.",
                                  "learningObjective": "Compreender como a DP lida com subproblemas sobrepostos e garante optimalidade.",
                                  "commonMistakes": "Confundir DP com recursão pura, ignorando memoização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Divisão e Conquista (D&C)",
                                  "subSteps": [
                                    "Defina D&C: dividir problema em subproblemas independentes, conquistar e combinar.",
                                    "Exemplos: Merge Sort, Quick Sort – subproblemas não se sobrepõem.",
                                    "Aplique D&C ao problema da mochila: tente dividir, note ausência de sobreposições.",
                                    "Calcule complexidade: geralmente O(n log n) ou similar, sem memoização.",
                                    "Compare com DP: D&C não armazena resultados intermediários."
                                  ],
                                  "verification": "Resolva uma instância de mochila via D&C recursivo e conte recomputações manuais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wikipedia: Divide and Conquer",
                                    "CLRS Capítulo 4",
                                    "Ferramenta online de visualização de algoritmos como VisuAlgo"
                                  ],
                                  "tips": "Use árvore de recursão para visualizar divisões em D&C.",
                                  "learningObjective": "Identificar quando subproblemas em D&C são independentes e não se sobrepõem.",
                                  "commonMistakes": "Aplicar D&C a problemas com sobreposições, levando a exponencial tempo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Algoritmo Guloso (Greedy)",
                                  "subSteps": [
                                    "Explique greedy: escolha local ótima em cada passo, esperando global ótima.",
                                    "Exemplos: Mochila fracionária funciona, mas 0/1 não garante optimalidade.",
                                    "Teste greedy na mochila 0/1: ordene por valor/peso, compare com ótimo.",
                                    "Discuta condições para greedy funcionar: propriedade de matroide ou subestrutura gulosa.",
                                    "Complexidade: O(n log n) para ordenação, mas pode falhar em optimalidade."
                                  ],
                                  "verification": "Encontre contraexemplo onde greedy falha na mochila 0/1 e calcule solução ótima manualmente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GeeksforGeeks: Greedy Algorithms",
                                    "CLRS Capítulo 16",
                                    "Exemplos interativos em LeetCode"
                                  ],
                                  "tips": "Sempre teste greedy com casos pequenos para validar optimalidade.",
                                  "learningObjective": "Reconhecer limitações do greedy em problemas sem garantia de optimalidade global.",
                                  "commonMistakes": "Assumir greedy sempre ótimo sem verificar propriedades."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Paradigmas Usando Mochila",
                                  "subSteps": [
                                    "Tabela comparativa: sobreposições (DP sim, D&C/greedy não), optimalidade (DP sim, greedy nem sempre).",
                                    "Simule execução dos três na mesma instância de mochila.",
                                    "Discuta quando escolher cada: DP para sobreposições, D&C para independência, greedy para velocidade.",
                                    "Analise trade-offs: tempo, espaço, garantias.",
                                    "Crie fluxograma de decisão para paradigmas."
                                  ],
                                  "verification": "Escreva um relatório de 1 página comparando os três em mochila, com tabela e exemplo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabelas",
                                    "Pseudocódigo unificado",
                                    "Artigo sobre Knapsack variants"
                                  ],
                                  "tips": "Use cores em tabelas comparativas para destacar diferenças chave.",
                                  "learningObjective": "Diferenciar paradigmas baseado em sobreposições e optimalidade.",
                                  "commonMistakes": "Ignorar que D&C pode ter sobreposições em alguns problemas, mas não as explora."
                                }
                              ],
                              "practicalExample": "No problema da mochila 0/1 com capacidade 5, itens: (v1=6,p1=2), (v2=4,p2=3), (v3=5,p3=3). Greedy (por v/p): pega 1º (6), sobra 3, pega 3º parcial? Não, 0/1 pega só 1º=6. DP: tabela mostra ótimo 6+? Não, combina 2º+3º=9. D&C: recursão explode sem memo.",
                              "finalVerifications": [
                                "Explique em 2 minutos diferenças de sobreposições entre DP e D&C.",
                                "Identifique por que greedy falha na mochila 0/1 com contraexemplo.",
                                "Monte tabela DP vs. execução greedy para instância dada.",
                                "Descreva quando usar cada paradigma.",
                                "Compare complexidades em O-notação para mochila.",
                                "Crie fluxograma de escolha de paradigma."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de sobreposições (DP vs. outros).",
                                "Correta distinção de optimalidade garantida.",
                                "Uso correto de exemplo da mochila com cálculos.",
                                "Clareza na tabela comparativa.",
                                "Análise de trade-offs tempo/espaço.",
                                "Capacidade de generalizar para outros problemas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Otimização e Programação Linear.",
                                "Economia: Alocação ótima de recursos limitados.",
                                "Engenharia de Software: Design de algoritmos eficientes.",
                                "Física: Modelagem de problemas de maximização sob restrições."
                              ],
                              "realWorldApplication": "Em logística para otimizar cargas em caminhões (mochila), portfólios de investimento (selecionar ativos com risco limitado), ou planejamento de projetos (alocar tempo/budget para tarefas dependentes)."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Memoização (Abordagem Top-Down)",
                        "description": "Técnica de armazenamento de resultados de subproblemas em uma estrutura de dados durante a recursão descendente para evitar recomputações.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Implementar memoização em função recursiva",
                            "description": "Converter uma função recursiva ingênua, como cálculo de Fibonacci, para usar um array ou mapa de memoização, medindo a redução de tempo de O(2^n) para O(n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a função recursiva original",
                                  "subSteps": [
                                    "Implemente uma função recursiva ingênua para calcular o n-ésimo número de Fibonacci (ex: fib(n) = fib(n-1) + fib(n-2))",
                                    "Teste a função com valores pequenos (n=10, 20) e observe os resultados corretos",
                                    "Meça o tempo de execução para n=35-40 usando módulos como timeit em Python",
                                    "Desenhe ou trace a árvore de chamadas recursivas para n=5, identificando chamadas redundantes",
                                    "Calcule a complexidade temporal aproximada (O(2^n)) com base no número de chamadas"
                                  ],
                                  "verification": "A função retorna valores corretos de Fibonacci, mas demora mais de 1 segundo para n=40, confirmando ineficiência",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado",
                                    "Módulo timeit"
                                  ],
                                  "tips": "Use print ou debugger para visualizar chamadas recursivas; comece com n pequeno para evitar timeouts",
                                  "learningObjective": "Identificar e quantificar a ineficiência exponencial da recursão ingênua",
                                  "commonMistakes": [
                                    "Usar valores de n muito pequenos sem medir lentidão",
                                    "Esquecer condições base (fib(0)=0, fib(1)=1)",
                                    "Confundir complexidade temporal com espacial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender e preparar a estrutura de memoização",
                                  "subSteps": [
                                    "Estude o conceito de memoização: armazenar resultados de subproblemas em uma estrutura de dados (array ou dicionário)",
                                    "Escolha a estrutura: para Fibonacci, use um dicionário com chave=n e valor=fib(n), ou array de tamanho n+1",
                                    "Inicialize a estrutura vazia (ex: memo = {} ou memo = [None] * (n+1))",
                                    "Planeje a lógica: antes de recursão, verifique se resultado está no memo; se sim, retorne; senão, calcule e armazene",
                                    "Trace manualmente para n=5 como o memo preencheria, evitando recomputações"
                                  ],
                                  "verification": "Crie um diagrama ou pseudocódigo mostrando como o memo evita chamadas redundantes",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Documentação Python dict/list",
                                    "Exemplos online de memoização (não copie código)"
                                  ],
                                  "tips": "Prefira dicionário para flexibilidade; array é mais eficiente para índices inteiros sequenciais como Fibonacci",
                                  "learningObjective": "Compreender como memoização transforma recursão top-down em programação dinâmica eficiente",
                                  "commonMistakes": [
                                    "Inicializar memo com valores errados (ex: todos zeros)",
                                    "Não tratar chaves ausentes corretamente",
                                    "Confundir memoização com cache global vs local"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a função recursiva com memoização",
                                  "subSteps": [
                                    "Modifique a função original adicionando o parâmetro memo (ou use closure/global)",
                                    "Adicione verificação: if n in memo: return memo[n]",
                                    "Calcule recursivamente e armazene: memo[n] = fib(n-1, memo) + fib(n-2, memo)",
                                    "Mantenha condições base inalteradas",
                                    "Escreva comentários explicando cada linha relacionada à memoização"
                                  ],
                                  "verification": "Execute fib_memo(40) e confirme que retorna o valor correto sem lentidão excessiva",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmo editor e Python do step 1",
                                    "Calculadora online para Fibonacci(40) para validação"
                                  ],
                                  "tips": "Passe memo como parâmetro para evitar globals; teste incrementalmente com n=5 primeiro",
                                  "learningObjective": "Aplicar memoização para otimizar recursão, garantindo O(n) tempo e espaço",
                                  "commonMistakes": [
                                    "Mutar memo sem verificar existência",
                                    "Recursão infinita por erro em condições base",
                                    "Não passar memo recursivamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, medir performance e analisar melhorias",
                                  "subSteps": [
                                    "Implemente testes unitários para ambas funções (recursiva e memoizada) com n=10,20,30,40",
                                    "Meça tempos de execução lado a lado usando timeit (média de 100 runs)",
                                    "Conte o número de chamadas recursivas (adicione contador global ou no memo)",
                                    "Compare complexidades: confirme redução de O(2^n) para O(n) via contadores e tempos",
                                    "Otimize se necessário (ex: array vs dict) e documente diferenças"
                                  ],
                                  "verification": "Tempo memoizado < 1ms para n=40 vs >1s recursivo; contagens mostram ~2n chamadas vs 2^n",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca timeit e unittest",
                                    "Gráfico simples (matplotlib opcional) para tempos"
                                  ],
                                  "tips": "Use @lru_cache para comparação rápida, mas implemente manualmente primeiro",
                                  "learningObjective": "Validar empiricamente a melhoria de performance e complexidade",
                                  "commonMistakes": [
                                    "Medir apenas uma execução (use loops)",
                                    "Ignorar overhead do dict vs array",
                                    "Não validar corretude numérica"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente fib_recursiva(40) que demora ~4s e fib_memo(40) que executa em <1ms. Conte chamadas: recursiva ~2^40, memo ~80. Código Python: def fib_memo(n, memo={}): if n in memo: return memo[n]; if n<2: return n; memo[n]=fib_memo(n-1,memo)+fib_memo(n-2,memo); return memo[n]",
                              "finalVerifications": [
                                "Função memoizada retorna valores idênticos à recursiva para n=0-40",
                                "Tempo de execução reduzido em pelo menos 100x para n=40",
                                "Número de chamadas recursivas é linear (O(n)) via contador",
                                "Estrutura memo é preenchida corretamente sem duplicatas",
                                "Código inclui comentários e testes unitários",
                                "Complexidade analisada corretamente como O(n) tempo/espaço"
                              ],
                              "assessmentCriteria": [
                                "Código limpo, legível com indentação e comentários explicativos",
                                "Implementação manual de memo sem decoradores prontos",
                                "Medições precisas de performance com múltiplas execuções",
                                "Análise correta de complexidade pré e pós-memoização",
                                "Tratamento robusto de casos base e erros (ex: n negativo)",
                                "Uso eficiente de estrutura de dados (dict ou array otimizado)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências recursivas e relações de recorrência",
                                "Física: Simulações recursivas em sistemas dinâmicos (ex: órbitas caóticas)",
                                "Economia: Otimização de portfólios com programação dinâmica",
                                "Engenharia: Cache em algoritmos de roteamento de redes",
                                "Biologia: Modelagem de árvores filogenéticas com memoização"
                              ],
                              "realWorldApplication": "Em compiladores para otimizar parsing de árvores sintáticas; em jogos para cálculo rápido de caminhos (ex: minimax com alpha-beta); em machine learning para evitar recomputações em árvores de decisão; em APIs web para cache de consultas recursivas como grafos sociais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Gerenciar estados na memoização",
                            "description": "Definir chaves compostas para memoização em problemas multidimensionais, como o problema da mochila 0/1, garantindo unicidade dos subproblemas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de estado em memoização multidimencional",
                                  "subSteps": [
                                    "Analise o problema da mochila 0/1 e identifique os parâmetros recursivos principais: índice do item atual (i) e peso restante (w).",
                                    "Defina o que constitui um 'estado': uma combinação única de parâmetros que determina o subproblema.",
                                    "Estude exemplos simples de memoização unidimensional para contrastar com multidimensional.",
                                    "Liste todas as dimensões variáveis no problema (ex: i de 0 a n, w de 0 a W).",
                                    "Desenhe um diagrama de recursão mostrando sobreposições de subproblemas."
                                  ],
                                  "verification": "Crie um diagrama ou tabela listando 5 estados únicos para um exemplo pequeno de mochila.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Exemplo de código recursivo sem memoização"
                                  ],
                                  "tips": "Sempre pergunte: 'Este par (i,w) leva ao mesmo subproblema independentemente do caminho?'",
                                  "learningObjective": "Entender que estados multidimensionais capturam todas as variáveis relevantes para unicidade.",
                                  "commonMistakes": [
                                    "Ignorar dimensões fixas como capacidade total",
                                    "Confundir estado com solução ótima",
                                    "Subestimar o número de estados possíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar dimensões do estado para o problema específico",
                                  "subSteps": [
                                    "Escreva a função recursiva base para mochila 0/1: dp(i, w) = max(dp(i+1, w), peso[i] + dp(i+1, w-peso[i])) se w >= peso[i].",
                                    "Liste variáveis mutáveis: i (itens restantes), w (peso disponível).",
                                    "Verifique dependências: o resultado depende apenas de i e w, não de itens escolhidos anteriormente.",
                                    "Calcule tamanho aproximado do espaço de estados: (n+1) * (W+1).",
                                    "Compare com problemas semelhantes, como subsequence longest common."
                                  ],
                                  "verification": "Documente as dimensões em um mapa mental ou tabela, confirmando independência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Exemplo de dados de mochila: pesos=[1,3,4], valores=[1,4,5], W=7"
                                  ],
                                  "tips": "Use pseudocódigo para visualizar recursão antes de codificar.",
                                  "learningObjective": "Identificar precisamente as dimensões mínimas necessárias para definir subproblemas únicos.",
                                  "commonMistakes": [
                                    "Incluir dimensões redundantes como itens selecionados",
                                    "Esquecer limites (i=0 ou w=0)",
                                    "Confundir com bottom-up onde ordem difere"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir chaves compostas únicas para o dicionário de memoização",
                                  "subSteps": [
                                    "Escolha formato de chave: tupla (i, w) ou string 'i_w'.",
                                    "Implemente em Python: memo = {} e chave = (i, w) ou f'{i}_{w}'.",
                                    "Teste unicidade: gere 10 chaves diferentes e verifique colisões.",
                                    "Defina verificação de chave válida: 0 <= i <= n e 0 <= w <= W.",
                                    "Adicione tratamento para chaves inválidas retornando 0."
                                  ],
                                  "verification": "Execute código gerando chaves e imprima memo após 20 chamadas recursivas; confirme sem duplicatas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou Jupyter Notebook",
                                    "Biblioteca functools.lru_cache para comparação opcional"
                                  ],
                                  "tips": "Tuplas são hasháveis e imutáveis; prefira-as sobre strings para performance.",
                                  "learningObjective": "Criar chaves compostas que garantam lookup O(1) e evitem recomputação.",
                                  "commonMistakes": [
                                    "Usar listas como chaves (não hasháveis)",
                                    "Chaves com separadores ambíguos como ',', causando colisões",
                                    "Não sanitizar valores negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar memoização na recursão e validar funcionalidade",
                                  "subSteps": [
                                    "Modifique função recursiva: if chave in memo: return memo[chave]; ... memo[chave] = resultado.",
                                    "Implemente função completa para mochila com dados de teste.",
                                    "Meça performance: compare tempo/recursões com e sem memo.",
                                    "Debugue casos base: i==n (0) ou w==0 (0).",
                                    "Teste com instâncias variadas: pequena, média e grande."
                                  ],
                                  "verification": "Execute testes unitários: solução ótima matches com abordagem bottom-up conhecida.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python completo",
                                    "Ferramentas de profiling como timeit",
                                    "Casos de teste pré-definidos"
                                  ],
                                  "tips": "Use print(len(memo)) para confirmar preenchimento parcial sem explosão.",
                                  "learningObjective": "Aplicar memoização top-down resolvendo problema eficientemente.",
                                  "commonMistakes": [
                                    "Atualizar memo após recursão sem checar existência",
                                    "Stack overflow por falta de memo em ramos profundos",
                                    "Ignorar cache miss em casos base"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema da mochila 0/1 com itens pesos=[2,3,4], valores=[3,4,5], W=5: estado (i=1,w=3) considera item 1 (peso 3) levando a max(4 + dp(2,0)=4, dp(2,3)=5? não cabe)=4; chave '(1,3)' armazena 4 evitando recomputação.",
                              "finalVerifications": [
                                "Pode definir chave única para qualquer par (i,w) no problema da mochila.",
                                "Função memoizada retorna mesmo resultado que recursão pura mas mais rápido.",
                                "Número de entradas no memo é <= (n+1)*(W+1).",
                                "Sem stack overflow em instâncias médias (n=100, W=1000).",
                                "Chaves capturam todas dimensões, comprovado por testes de equivalência.",
                                "Tratamento correto de casos base sem memo infinito."
                              ],
                              "assessmentCriteria": [
                                "Chaves são compostas, únicas e cobrem todas dimensões variáveis (pontos: 25%).",
                                "Implementação evita recomputação comprovadamente (tempo reduzido >90%, pontos: 25%).",
                                "Código limpo com verificações de bounds e casos base (pontos: 20%).",
                                "Explicação clara de por quê dimensões escolhidas garantem unicidade (pontos: 15%).",
                                "Testes abrangentes com métricas de performance (pontos: 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conjuntos e funções de múltiplas variáveis (espaço de estados como grade cartesiana).",
                                "Análise de Algoritmos: Complexidade temporal O(nW) vs exponencial.",
                                "Engenharia de Software: Otimização de caching em aplicações web (Redis keys compostas).",
                                "Economia: Otimização de portfólio com restrições multidimensionais.",
                                "Física: Problemas de otimização em mecânica quântica (estados compostos)."
                              ],
                              "realWorldApplication": "Em logística, otimizar carregamento de caminhões com restrições de peso e volume (dimensões: item_index, peso_restante, volume_restante), reduzindo tempo de planejamento de horas para segundos em e-commerces como Amazon."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Analisar complexidade com memoização",
                            "description": "Calcular tempo e espaço da memoização top-down, incluindo overhead de recursão e tamanho da tabela, para problemas como longest common subsequence.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a recursão pura sem memoização e sua complexidade",
                                  "subSteps": [
                                    "Revise a definição recursiva do problema, como LCS(X[0..m], Y[0..n]).",
                                    "Desenhe a árvore de recursão para um exemplo pequeno (m=3, n=3).",
                                    "Conte o número total de chamadas recursivas e identifique sobreposições.",
                                    "Calcule a complexidade temporal (exponencial, tipicamente O(2^{m+n})).",
                                    "Discuta por que isso é ineficiente para entradas grandes."
                                  ],
                                  "verification": "Desenhe a árvore de recursão e calcule corretamente o número de chamadas para um caso teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhar árvore",
                                    "Exemplo de código recursivo LCS em Python"
                                  ],
                                  "tips": [
                                    "Comece com strings pequenas para visualizar sobreposições claramente.",
                                    "Use memoização mental para contar chamadas únicas."
                                  ],
                                  "learningObjective": "Identificar subproblemas sobrepostos e complexidade exponencial da recursão pura.",
                                  "commonMistakes": [
                                    "Ignorar chamadas base no cálculo.",
                                    "Confundir profundidade da árvore com total de nós."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar memoização top-down com tabela de cache",
                                  "subSteps": [
                                    "Crie uma tabela de memoização (dicionário ou matriz 2D de tamanho (m+1) x (n+1)).",
                                    "Modifique a função recursiva para verificar a tabela antes de recursar.",
                                    "Preencha a tabela com -1 inicialmente para indicar 'não computado'.",
                                    "Teste com um exemplo pequeno e trace as chamadas.",
                                    "Meça o número de entradas únicas na tabela após execução."
                                  ],
                                  "verification": "Execute o código memoizado e confirme que cada subproblema é computado apenas uma vez.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python/Jupyter)",
                                    "Strings de teste: 'abcde' e 'ace'"
                                  ],
                                  "tips": [
                                    "Use tuplas (i,j) como chaves no dicionário para simplicidade.",
                                    "Imprima chamadas para depurar o fluxo."
                                  ],
                                  "learningObjective": "Aplicar memoização para evitar recomputações desnecessárias.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar a tabela após recursão.",
                                    "Usar índices errados na matriz 2D."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar complexidade temporal com memoização",
                                  "subSteps": [
                                    "Identifique o número de subproblemas únicos: O(m*n).",
                                    "Para cada subproblema, analise o trabalho constante: 2 chamadas recursivas + verificação de tabela.",
                                    "Considere overhead de recursão: pilha de profundidade O(m+n).",
                                    "Some o custo total: tempo = O(m*n) para preenchimento + overhead.",
                                    "Compare com recursão pura via contadores de chamadas."
                                  ],
                                  "verification": "Escreva a recorrência e resolva para T(m,n) = O(m*n).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de cálculo para contagens",
                                    "Código com contadores de chamadas"
                                  ],
                                  "tips": [
                                    "Pense em estados únicos (i,j); cada um é visitado uma vez.",
                                    "Ignore overhead para notação big-O principal."
                                  ],
                                  "learningObjective": "Calcular tempo como número de estados vezes trabalho por estado.",
                                  "commonMistakes": [
                                    "Contar todas chamadas recursivas em vez de únicas.",
                                    "Esquecer verificação de tabela como O(1)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar complexidade espacial incluindo overhead",
                                  "subSteps": [
                                    "Calcule tamanho da tabela: O(m*n) para matriz ou O(m*n) entradas no dicionário.",
                                    "Adicione overhead da pilha recursiva: O(m+n) frames no pior caso.",
                                    "Discuta trade-offs: espaço extra por velocidade.",
                                    "Otimize se possível (e.g., 1D array para alguns problemas).",
                                    "Verifique com profiler de memória em código."
                                  ],
                                  "verification": "Anote S(m,n) = O(m*n + m + n) e teste com entradas crescentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Profiler de memória (Python: memory_profiler)",
                                    "Código LCS memoizado"
                                  ],
                                  "tips": [
                                    "Matriz 2D é intuitiva; dicionário tem overhead de hash.",
                                    "Pior caso da pilha é cadeia sem matches."
                                  ],
                                  "learningObjective": "Incluir todos componentes: tabela + recursão + variáveis locais.",
                                  "commonMistakes": [
                                    "Ignorar pilha recursiva.",
                                    "Confundir com bottom-up (sem recursão)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para LCS entre X='AGGTAB' (m=6) e Y='GXTXAYB' (n=7): sem memo, ~2^13 chamadas; com memo, 7*8=56 estados, tempo O(42), espaço O(49) + O(13) pilha. Trace mostra preenchimento único por célula.",
                              "finalVerifications": [
                                "Calcule corretamente tempo O(mn) e espaço O(mn + m + n) para LCS.",
                                "Trace um exemplo pequeno mostrando evitações de recomputação.",
                                "Compare tempos de execução recursivo vs memoizado empiricamente.",
                                "Identifique overhead da recursão em profundidade máxima.",
                                "Explique por que memoização não é O(1) por chamada.",
                                "Aplique análise a variação como edit distance."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de subproblemas únicos (mn).",
                                "Inclusão de overhead recursivo no espaço.",
                                "Uso correto de notação assintótica (big-O).",
                                "Identificação de trabalho constante por estado.",
                                "Comparação qualitativa/quantitativa com recursão pura.",
                                "Correção em exemplo prático como LCS."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de recorrências e análise assintótica.",
                                "Engenharia de Software: Otimização de performance e profiling.",
                                "Bioinformática: Alinhamento de sequências genéticas.",
                                "Economia: Análise custo-benefício de trade-offs tempo-espaço."
                              ],
                              "realWorldApplication": "Em bioinformática, memoização top-down acelera alinhamento de sequências de DNA (LCS-like), reduzindo de horas em recursão pura para segundos em genomas grandes, essencial para descoberta de genes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Abordagem Bottom-Up com Tabelas",
                        "description": "Construção iterativa de soluções de subproblemas menores para maiores, preenchendo uma tabela de forma sistemática sem recursão.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Construir tabela DP bottom-up",
                            "description": "Preencher uma tabela DP para Fibonacci ou problema da mochila, definindo ordem de computação e condições de base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e a estrutura da tabela DP",
                                  "subSteps": [
                                    "Escolha um problema adequado para DP bottom-up, como Fibonacci(n) ou Knapsack 0/1.",
                                    "Identifique os estados: para Fibonacci, dp[i] representa o i-ésimo número de Fibonacci; para Knapsack, dp[i][w] é o valor máximo com i itens e peso w.",
                                    "Determine as dimensões da tabela: array 1D para Fibonacci (tamanho n+1), 2D para Knapsack (itens x capacidade).",
                                    "Inicialize a tabela com valores neutros (ex: -1 ou 0) para rastrear preenchimento.",
                                    "Anote os parâmetros de entrada: n para Fibonacci, lista de pesos/valores e capacidade W para Knapsack."
                                  ],
                                  "verification": "Confirme que a tabela foi declarada com dimensões corretas e índices nomeados logicamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de código (Python/Jupyter)",
                                    "Exemplo de problema: Fibonacci(6) ou Knapsack com 3 itens"
                                  ],
                                  "tips": [
                                    "Comece com problemas 1D simples antes de 2D.",
                                    "Desenhe a tabela vazia para visualizar."
                                  ],
                                  "learningObjective": "Compreender como mapear o problema recursivo para uma tabela iterativa.",
                                  "commonMistakes": [
                                    "Índices off-by-one (ex: dp[0] vs dp[1])",
                                    "Confundir dimensões para problemas multidimensionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer as condições de base",
                                  "subSteps": [
                                    "Para Fibonacci: defina dp[0] = 0 e dp[1] = 1.",
                                    "Para Knapsack: inicialize dp[0][w] = 0 para todos w (0 itens), e dp[i][0] = 0 para todos i (capacidade 0).",
                                    "Preencha todas as bases explicitamente na tabela.",
                                    "Verifique consistência: bases devem resolver subproblemas triviais sem recorrência.",
                                    "Documente por que essas bases são verdadeiras (ex: F_0 = 0 por definição)."
                                  ],
                                  "verification": "As células de base estão preenchidas corretamente e coincidem com soluções manuais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela esboçada do Step 1",
                                    "Referência de definições do problema"
                                  ],
                                  "tips": [
                                    "Sempre liste bases antes de recorrências para evitar loops infinitos mentais.",
                                    "Use loops aninhados em código para automação."
                                  ],
                                  "learningObjective": "Estabelecer fundações corretas que propagam soluções upward.",
                                  "commonMistakes": [
                                    "Esquecer dp[0] ou inicializar com valores errados",
                                    "Não cobrir todos os casos de capacidade zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a ordem de computação e preencher a tabela bottom-up",
                                  "subSteps": [
                                    "Estabeleça a ordem: para Fibonacci, for i from 2 to n: dp[i] = dp[i-1] + dp[i-2].",
                                    "Para Knapsack: for i from 1 to num_itens: for w from 1 to W: dp[i][w] = max(dp[i-1][w], dp[i-1][w-peso[i]] + valor[i] if w >= peso[i]).",
                                    "Preencha célula por célula seguindo a ordem dependente (subproblemas resolvidos primeiro).",
                                    "Calcule e anote cada célula, rastreando dependências.",
                                    "Implemente em pseudocódigo ou código real para validar."
                                  ],
                                  "verification": "Cada célula não-base depende apenas de células já preenchidas; trace uma célula aleatória.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela com bases preenchidas",
                                    "Pseudocódigo ou IDE para simulação"
                                  ],
                                  "tips": [
                                    "Desenhe setas de dependência para visualizar fluxo bottom-up.",
                                    "Otimize espaço se possível (ex: 1D para Knapsack)."
                                  ],
                                  "learningObjective": "Garantir preenchimento iterativo sem recursão, respeitando dependências.",
                                  "commonMistakes": [
                                    "Ordem errada (top-down acidental)",
                                    "Índice fora dos limites no max"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair resultado, verificar e otimizar",
                                  "subSteps": [
                                    "Leia o valor final: dp[n] para Fibonacci, dp[num_itens][W] para Knapsack.",
                                    "Valide manualmente para n pequeno (ex: Fibonacci(5)=5).",
                                    "Compare com solução recursiva ingênua para confirmação.",
                                    "Otimize se aplicável: reduza dimensões ou use variáveis auxiliares.",
                                    "Documente o tempo/espaço: O(n) tempo para ambos."
                                  ],
                                  "verification": "Resultado final bate com valor conhecido; tabela completa sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela preenchida",
                                    "Calculadora ou código executável"
                                  ],
                                  "tips": [
                                    "Teste com n=0,1 para edge cases.",
                                    "Meça complexidade contando preenchimentos."
                                  ],
                                  "learningObjective": "Concluir o processo DP com validação e análise.",
                                  "commonMistakes": [
                                    "Ler índice errado no final",
                                    "Ignorar edge cases como n=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Fibonacci(5): Crie dp[0..5]. Bases: dp[0]=0, dp[1]=1. Preencha: dp[2]=1, dp[3]=2, dp[4]=3, dp[5]=5. Resultado: 5. Para Knapsack (itens: (peso=1,val=1), (2,3), (3,4); W=4): dp[3][4]=5 (escolhendo itens 2 e 1).",
                              "finalVerifications": [
                                "Tabela preenchida completamente sem lacunas ou erros de índice.",
                                "Condições de base corretas e propagadas.",
                                "Ordem bottom-up respeitada (nenhuma célula usa valor futuro).",
                                "Resultado final matches solução conhecida.",
                                "Pseudocódigo ou código roda sem erros e produz tabela idêntica.",
                                "Análise de complexidade documentada (tempo O(n*W) ou O(n))."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de estados e dimensões (80% correto).",
                                "Bases e recorrência sem erros lógicos (100% match).",
                                "Ordem de preenchimento iterativa e dependente correta.",
                                "Validação completa com pelo menos 2 exemplos.",
                                "Otimização básica identificada (ex: espaço).",
                                "Documentação clara de cada step."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências lineares e sequências.",
                                "Otimização: Problemas de maximização como em Economia.",
                                "Estatística: Computação de probabilidades cumulativas.",
                                "Engenharia: Planejamento de recursos em projetos."
                              ],
                              "realWorldApplication": "Em software de roteamento (ex: Google Maps otimizando caminhos com DP), finanças (otimização de portfólio como Knapsack), bioinformática (alinhamento de sequências) e jogos (caminhos ótimos em grids)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Otimizar espaço em tabelas DP",
                            "description": "Reduzir uso de memória de O(n^2) para O(n) em problemas como mochila ou caixeiro viajante, usando rolagem de arrays ou variáveis auxiliares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o uso de memória em tabelas DP padrão",
                                  "subSteps": [
                                    "Revise uma implementação bottom-up padrão de DP para um problema como Mochila 0/1, usando uma tabela 2D dp[n+1][W+1].",
                                    "Calcule o espaço usado: O(n * W) para Mochila, onde n é número de itens e W é capacidade.",
                                    "Identifique que muitas células não são reutilizadas após certas iterações.",
                                    "Compare com problemas como Caixeiro Viajante (TSP), onde dp[n][2^n] pode ser otimizado similarmente.",
                                    "Anote exemplos onde O(n^2) ou O(nW) é problemático (ex: W=10^5)."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando o overhead de memória e dê um exemplo numérico de uso de espaço.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Exemplos de código DP para Mochila e TSP"
                                  ],
                                  "tips": "Sempre visualize a tabela preenchendo linha por linha para ver dependências.",
                                  "learningObjective": "Entender por que tabelas DP full consomem O(n^2) ou O(nW) e quando otimizar.",
                                  "commonMistakes": [
                                    "Confundir tempo O(nW) com espaço O(nW)",
                                    "Ignorar limites de W grandes em problemas reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar dependências entre células para identificar otimizações",
                                  "subSteps": [
                                    "Para Mochila: note que dp[i][w] depende só de dp[i-1][w] e dp[i-1][w-weight[i]].",
                                    "Desenhe um diagrama de dependências mostrando que só a linha anterior é necessária.",
                                    "Para TSP: identifique que subproblemas dependem de máscaras anteriores, permitindo rolagem em duas arrays.",
                                    "Determine o estado mínimo necessário: para 1D, use uma array e itere reverso para evitar sobrescrita.",
                                    "Liste condições para otimização: dependências unidirecionais e locais."
                                  ],
                                  "verification": "Crie um diagrama de dependências para Mochila com i=3, w=5 e confirme dependências.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Pense em 'o que eu preciso do passado?' – só vizinhos imediatos.",
                                  "learningObjective": "Mapear dependências para reduzir dimensões da tabela DP.",
                                  "commonMistakes": [
                                    "Assumir dependência em toda a tabela",
                                    "Esquecer direção da iteração (frente vs reverso)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar rolagem de arrays ou variáveis auxiliares",
                                  "subSteps": [
                                    "Converta tabela 2D para duas arrays: prev e curr, alternando uso (O(W) espaço).",
                                    "Ou use uma array 1D, iterando w de W para weight[i] em ordem reversa para Mochila.",
                                    "Implemente para TSP: use dp[2][state_size] e role entre 0 e 1.",
                                    "Adicione prints ou logs para comparar valores com versão full.",
                                    "Meça memória com ferramentas como Python's memory_profiler."
                                  ],
                                  "verification": "Execute código otimizado vs original; confirme saídas iguais e memória <= O(W).",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "Linguagem Python ou C++",
                                    "Biblioteca memory_profiler (pip install)"
                                  ],
                                  "tips": "Para 1D em Mochila, sempre itere w decrescente para não usar valores atualizados cedo.",
                                  "learningObjective": "Codificar DP space-optimized mantendo corretude.",
                                  "commonMistakes": [
                                    "Iterar w crescente em 1D (causa uso múltiplo do item)",
                                    "Não alternar corretamente em rolagem 2D"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, validar e generalizar a otimização",
                                  "subSteps": [
                                    "Teste com casos: pequeno (n=5,W=10), grande (n=100,W=1000).",
                                    "Compare tempo e memória usando timeit e profilers.",
                                    "Generalize: discuta quando usar (W >> n) vs manter 2D (cache melhor).",
                                    "Aplique a outro problema como Longest Common Subsequence (LCS) com O(min(m,n)).",
                                    "Documente trade-offs: espaço vs cache locality."
                                  ],
                                  "verification": "Gere relatório com métricas: espaço reduzido em X%, tempo similar, testes passam.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Test cases prontos para Mochila",
                                    "Profiler de memória e tempo"
                                  ],
                                  "tips": "Use asserts para validar dp[final] igual em ambas versões.",
                                  "learningObjective": "Validar otimizações e saber quando aplicá-las.",
                                  "commonMistakes": [
                                    "Otimizar sem testar corretude",
                                    "Ignorar slowdown por pior cache em arrays pequenos"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva Mochila 0/1 com itens [(2,3), (3,4), (4,5)], W=10. Versão full: dp[4][11]. Otimizada: array de 11 elems, iterando reverso. Resultado esperado: valor 7 (itens 1 e 3). Compare memória: full ~176 bytes, otimizada ~44 bytes.",
                              "finalVerifications": [
                                "Saída do algoritmo otimizado idêntica à versão full para 10+ casos de teste.",
                                "Uso de memória reduzido para O(W) ou O(n), confirmado por profiler.",
                                "Algoritmo lida corretamente com W até 10^5 sem StackOverflow ou TLE.",
                                "Dependências preservadas: nenhum valor sobrescrito prematuramente.",
                                "Tempo de execução similar ou melhor em datasets grandes.",
                                "Código comentado explica rolagem e direção de iteração."
                              ],
                              "assessmentCriteria": [
                                "Corretude: resultados exatos em todos testes.",
                                "Eficiência espacial: comprovadamente O(n) ou O(W).",
                                "Clareza do código: comentários em pontos chave de otimização.",
                                "Generalização: funciona para Mochila e pelo menos um outro problema.",
                                "Análise: relatório com métricas de memória/tempo.",
                                "Robustez: edge cases como W=0, n=0, itens zero-weight."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização linear e recorrências matemáticas.",
                                "Engenharia de Software: Trade-offs performance/memória em sistemas embarcados.",
                                "Economia: Alocação ótima de recursos limitados (knapsack em finanças).",
                                "Física: Simulações com restrições computacionais (modelos dinâmicos)."
                              ],
                              "realWorldApplication": "Em logística (otimização de carga em caminhões com W grande), compiladores (alocação de registradores), bioinformática (alinhamento de sequências com sequências longas), e jogos (pathfinding com estados limitados por memória mobile)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Reconstruir solução ótima",
                            "description": "A partir da tabela preenchida, rastrear decisões ótimas para recuperar a solução completa, como itens selecionados na mochila.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a posição inicial da solução ótima na tabela",
                                  "subSteps": [
                                    "Examine a tabela DP bottom-up preenchida, onde linhas representam itens (1 a n) e colunas representam capacidades (0 a W).",
                                    "Localize a célula na última linha (item n) e última coluna (capacidade W), que contém o valor ótimo dp[n][W].",
                                    "Registre o valor ótimo encontrado.",
                                    "Confirme que todas as células anteriores foram preenchidas corretamente antes de prosseguir.",
                                    "Anote o índice do item atual (i = n)."
                                  ],
                                  "verification": "Verifique se dp[n][W] é maior ou igual a qualquer outro valor na última linha ou coluna final.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela DP preenchida",
                                    "Folha de papel ou editor de texto para anotações"
                                  ],
                                  "tips": "Sempre inicie pelo 'canto inferior direito' da tabela para evitar confusões.",
                                  "learningObjective": "Compreender a localização do valor ótimo final na tabela de programação dinâmica.",
                                  "commonMistakes": [
                                    "Iniciar pela célula (0,0)",
                                    "Ignorar se a tabela foi preenchida corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a regra de backtracking para o item atual",
                                  "subSteps": [
                                    "Compare dp[i][w] com dp[i-1][w] (não incluir o item). Se dp[i][w] == dp[i-1][w], o item i não é incluído; mova para i-1, mesma w.",
                                    "Caso contrário, compare com dp[i-1][w - peso[i]]. Se dp[i][w] == dp[i-1][w - peso[i]] + valor[i], inclua o item i; registre-o e mova para i-1, w - peso[i].",
                                    "Registre a decisão: 'incluir' ou 'excluir' o item i na lista de solução.",
                                    "Atualize os índices i e w para a próxima iteração.",
                                    "Repita até i == 0."
                                  ],
                                  "verification": "Simule um passo manualmente e confirme que a igualdade das regras é respeitada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela DP",
                                    "Lista de itens com pesos e valores"
                                  ],
                                  "tips": "Use setas na tabela para marcar o caminho de backtracking visualmente.",
                                  "learningObjective": "Dominar a regra de decisão para rastrear inclusões e exclusões de itens.",
                                  "commonMistakes": [
                                    "Confundir a ordem das comparações (não incluir vs incluir)",
                                    "Esquecer de subtrair o peso ao incluir"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Rastrear o caminho completo até a origem e coletar a solução",
                                  "subSteps": [
                                    "Continue o backtracking iterativamente de i = n até i = 0, aplicando a regra do passo anterior.",
                                    "Mantenha uma lista ordenada dos itens incluídos (do maior para o menor índice).",
                                    "Ao chegar em i = 0, pare e liste todos os itens selecionados.",
                                    "Calcule o peso total e valor total da solução coletada.",
                                    "Compare com o valor ótimo dp[n][W] para consistência inicial."
                                  ],
                                  "verification": "O peso total dos itens ≤ W e o valor total == dp[n][W].",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela DP anotada",
                                    "Calculadora para somas"
                                  ],
                                  "tips": "Trabalhe de trás para frente para manter a ordem natural dos itens.",
                                  "learningObjective": "Executar o backtracking completo para recuperar a solução exata.",
                                  "commonMistakes": [
                                    "Parar prematuramente antes de i=0",
                                    "Incluir itens com peso que exceda W"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar a solução ótima",
                                  "subSteps": [
                                    "Liste explicitamente os itens selecionados, seus pesos, valores e totais.",
                                    "Verifique se não há outra combinação com mesmo valor ótimo mas diferente composição (se aplicável).",
                                    "Documente o caminho percorrido na tabela (células visitadas).",
                                    "Teste alterando um item e veja se o valor muda corretamente.",
                                    "Escreva a solução em formato legível: 'Itens: [lista], Peso total: X, Valor: Y'."
                                  ],
                                  "verification": "Solução atende exatamente ao valor ótimo sem exceder capacidade.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Solução anotada",
                                    "Código ou planilha para validação opcional"
                                  ],
                                  "tips": "Implemente em pseudocódigo para automatizar em casos maiores.",
                                  "learningObjective": "Garantir a correção e completude da solução reconstruída.",
                                  "commonMistakes": [
                                    "Não validar os totais finais",
                                    "Omitir itens de zero valor"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema da Mochila: Capacidade W=5, Itens: A(peso=2,valor=3), B(3,4), C(1,2). Tabela DP final: dp[3][5]=5. Backtrack: dp[3][5]=5 == dp[2][5]=5? Não, então inclua B (peso3), vá dp[2][2]. dp[2][2]=3 == dp[1][2]=3? Não, inclua A (peso2), vá dp[1][0]=0. Solução: B e A (peso5, valor7? Espere, ajuste: assume tabela correta com solução B+C valor6). Solução: Itens B e C.",
                              "finalVerifications": [
                                "Valor total da solução reconstruída igual a dp[n][W].",
                                "Peso total dos itens ≤ W.",
                                "Todos os passos de backtracking respeitam as regras de decisão.",
                                "Lista de itens é completa sem duplicatas ou omissões.",
                                "Caminho na tabela leva de (n,W) a (0,0).",
                                "Solução é factível e ótima."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação das regras de backtracking (100% das decisões corretas).",
                                "Completude da lista de itens selecionados.",
                                "Correção dos totais de peso e valor.",
                                "Clareza na documentação do caminho percorrido.",
                                "Capacidade de validar manualmente sem erros.",
                                "Tempo de execução eficiente dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências e otimização discreta.",
                                "Algoritmos: Backtracking em grafos implícitos.",
                                "Economia: Alocação ótima de recursos limitados.",
                                "Engenharia de Software: Recuperação de soluções em DP para problemas reais."
                              ],
                              "realWorldApplication": "Em logística, reconstruir seleções ótimas de itens em contêineres com capacidade limitada; em finanças, recuperar portfólios de investimentos ótimos a partir de tabelas de maximização de retorno sob restrições de risco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Algoritmos Numéricos Avançados",
                "description": "Algoritmos computacionais avançados para resolução de problemas numéricos.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Método de Newton-Raphson",
                    "description": "Algoritmo iterativo para aproximação de raízes de equações não-lineares, com análise de convergência quadrática.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1.1",
                        "name": "Definição e Derivação do Método de Newton-Raphson",
                        "description": "Conceito fundamental que abrange a motivação geométrica e a derivação matemática da fórmula iterativa para encontrar raízes de equações não-lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1.1",
                            "name": "Explicar a motivação geométrica do método",
                            "description": "Descrever como o método utiliza a tangente à curva f(x) no ponto inicial para aproximar a raiz, ilustrando com gráficos e exemplos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Raiz e a Necessidade de Aproximações Geométricas",
                                  "subSteps": [
                                    "Defina uma raiz de uma função f(x) como o ponto onde f(x) = 0.",
                                    "Discuta limitações de soluções analíticas para equações não-lineares.",
                                    "Introduza a ideia de aproximação local usando geometria da curva.",
                                    "Explique o papel da derivada como inclinação da tangente.",
                                    "Esboce uma curva genérica f(x) com uma raiz e um ponto inicial próximo."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o que é uma raiz e por que usamos aproximações geométricas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora gráfica ou software como Desmos/GeoGebra"
                                  ],
                                  "tips": "Use funções quadráticas simples para visualização inicial.",
                                  "learningObjective": "Compreender o problema de encontrar raízes e a motivação para aproximações lineares locais.",
                                  "commonMistakes": [
                                    "Confundir raiz com máximo/mínimo local",
                                    "Ignorar a importância da proximidade inicial ao ponto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Equação da Tangente no Ponto Inicial",
                                  "subSteps": [
                                    "Escolha um ponto inicial x₀ próximo à raiz estimada.",
                                    "Calcule f(x₀) e f'(x₀), a derivada no ponto.",
                                    "Escreva a equação da reta tangente: y = f(x₀) + f'(x₀)(x - x₀).",
                                    "Verifique que no ponto x₀, a tangente toca a curva e tem a mesma inclinação.",
                                    "Compare a tangente com a curva em pontos próximos para validar a aproximação."
                                  ],
                                  "verification": "Derive e escreva corretamente a equação da tangente para uma função dada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de plotagem (GeoGebra ou Python/Matplotlib)"
                                  ],
                                  "tips": "Lembre-se: a tangente é a melhor aproximação linear local.",
                                  "learningObjective": "Dominar a construção geométrica e algébrica da reta tangente.",
                                  "commonMistakes": [
                                    "Erro no sinal da derivada",
                                    "Confundir tangente com secante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encontrar a Aproximação da Raiz via Interseção da Tangente",
                                  "subSteps": [
                                    "Defina a interseção da tangente com o eixo x (y=0).",
                                    "Resolva 0 = f(x₀) + f'(x₀)(x₁ - x₀) para x₁.",
                                    "Simplifique para x₁ = x₀ - f(x₀)/f'(x₀), a fórmula do Newton-Raphson.",
                                    "Interprete geometricamente: o passo é proporcional ao erro dividido pela inclinação.",
                                    "Repita o processo para mostrar convergência iterativa."
                                  ],
                                  "verification": "Calcule x₁ corretamente a partir de x₀ e confirme que é uma melhoria.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de cálculo",
                                    "Exemplos impressos de funções"
                                  ],
                                  "tips": "Garanta f'(x₀) ≠ 0 para evitar divisão por zero.",
                                  "learningObjective": "Derivar a fórmula iterativa a partir da geometria da tangente.",
                                  "commonMistakes": [
                                    "Inverter o sinal na fórmula",
                                    "Não considerar casos onde f' é zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Ilustrar com Gráficos e Exemplos Simples",
                                  "subSteps": [
                                    "Plote a curva f(x), tangente em x₀ e interseção em x₁.",
                                    "Aplique a um exemplo: f(x) = x² - 2, x₀ = 1.",
                                    "Mostre iterações subsequentes convergindo para √2 ≈ 1.414.",
                                    "Compare com método da bissecção para destacar eficiência geométrica.",
                                    "Discuta condições de convergência via gráfico."
                                  ],
                                  "verification": "Desenhe o gráfico completo com pelo menos duas iterações e explique a convergência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfica impressa ou digital",
                                    "Ferramenta de desenho vetorial"
                                  ],
                                  "tips": "Use cores diferentes para curva, tangentes e raízes.",
                                  "learningObjective": "Aplicar e visualizar a motivação geométrica em exemplos concretos.",
                                  "commonMistakes": [
                                    "Escala inadequada no gráfico",
                                    "Não mostrar convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 2 (raiz √2 ≈ 1.414), inicie com x₀ = 1. f(1) = -1, f'(x) = 2x, f'(1) = 2. Tangente: y = -1 + 2(x - 1). Interseção com x: x₁ = 1 - (-1)/2 = 1.5. Próxima iteração: x₂ ≈ 1.416, convergindo rapidamente ao gráfico da parábola.",
                              "finalVerifications": [
                                "Desenhar corretamente a curva, tangente e interseção para um exemplo dado.",
                                "Derivar a fórmula de Newton-Raphson geometricamente sem erros.",
                                "Explicar verbalmente por que a tangente fornece uma boa aproximação local.",
                                "Identificar visualmente a convergência em um gráfico iterativo.",
                                "Comparar com outro método e justificar superioridade.",
                                "Aplicar a um novo exemplo simples com cálculo preciso."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação da tangente como aproximação linear (peso: 25%).",
                                "Precisão na derivação da fórmula iterativa (peso: 25%).",
                                "Qualidade do gráfico ilustrativo com legendas (peso: 20%).",
                                "Compreensão de condições de convergência (peso: 15%).",
                                "Uso correto de exemplos numéricos (peso: 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Conceitos de derivadas e linearização Taylor.",
                                "Geometria Analítica: Equações de retas e interseções.",
                                "Física: Aproximações lineares em movimento e trajetórias curvas.",
                                "Programação: Implementação de iteradores numéricos em Python.",
                                "Estatística: Otimização em regressão não-linear."
                              ],
                              "realWorldApplication": "O método de Newton-Raphson é fundamental em engenharia para resolver equações não-lineares em estruturas, em finanças para modelagem de derivativos, em machine learning para treinamento de redes neurais via gradiente descendente (variante), e em simulações físicas para encontrar equilíbrios estáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.1.2",
                            "name": "Derivar a fórmula iterativa usando expansão de Taylor",
                            "description": "Realizar a derivação passo a passo da fórmula x_{n+1} = x_n - f(x_n)/f'(x_n) a partir da aproximação linear de Taylor de segunda ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a expansão de Taylor de primeira ordem",
                                  "subSteps": [
                                    "Lembre-se da fórmula geral da expansão de Taylor de ordem 1 para uma função f diferenciável ao redor de um ponto x_n: f(x) ≈ f(x_n) + f'(x_n)(x - x_n).",
                                    "Entenda que essa é a aproximação linear tangente à curva em x_n.",
                                    "Discuta o termo de resto (Lagrange) para justificar a precisão local: R_1(x) = (1/2)f''(ξ)(x - x_n)^2, onde ξ está entre x e x_n.",
                                    "Escreva a fórmula em um papel para uma função exemplo simples, como f(x) = x^2.",
                                    "Verifique graficamente ou numericamente por que a aproximação é boa perto de x_n."
                                  ],
                                  "verification": "Escreva corretamente a fórmula de Taylor de ordem 1 e compute para f(x)=x^2 em x_n=1, comparando com o valor real em x=1.1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Gráfico de f(x)=x^2 (opcional)"
                                  ],
                                  "tips": "Visualize a reta tangente como a melhor aproximação linear local.",
                                  "learningObjective": "Compreender a base teórica da aproximação linear via Taylor.",
                                  "commonMistakes": [
                                    "Confundir ordem 1 com ordem 2 (incluir f''/2)",
                                    "Ignorar o termo de resto e assumir exatidão global"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a expansão de Taylor à função f ao redor de x_n",
                                  "subSteps": [
                                    "Dada f contínua e f' contínua, escreva f(x) ≈ f(x_n) + f'(x_n)(x - x_n).",
                                    "Assuma que x_n é uma aproximação inicial próxima à raiz f(r)=0.",
                                    "Substitua variáveis para clareza: denote a aproximação como L(x) = f(x_n) + f'(x_n)(x - x_n).",
                                    "Confirme que L(x_n) = f(x_n) e L'(x_n) = f'(x_n), validando a tangência.",
                                    "Discuta por que usamos ordem 1 para iteração quadrática convergente."
                                  ],
                                  "verification": "Escreva L(x) para uma f dada e verifique L(x_n)=f(x_n) e L'(x)=f'(x_n).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplo de função f(x) impresso"
                                  ],
                                  "tips": "Pense em L(x) como o modelo linear local que 'imita' f perto de x_n.",
                                  "learningObjective": "Aplicar corretamente a expansão de Taylor de ordem 1 a uma função arbitrária.",
                                  "commonMistakes": [
                                    "Escrever erroneamente o coeficiente de (x - x_n)",
                                    "Usar f'' prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir x_{n+1} como a raiz da aproximação linear",
                                  "subSteps": [
                                    "Para encontrar a próxima aproximação à raiz, resolva L(x_{n+1}) = 0.",
                                    "Substitua: f(x_n) + f'(x_n)(x_{n+1} - x_n) = 0.",
                                    "Isolar x_{n+1}: f'(x_n)(x_{n+1} - x_n) = -f(x_n).",
                                    "Divida por f'(x_n) (assumindo f'(x_n) ≠ 0): x_{n+1} - x_n = -f(x_n)/f'(x_n).",
                                    "Conclua: x_{n+1} = x_n - f(x_n)/f'(x_n)."
                                  ],
                                  "verification": "Resolva algebricamente e chegue à fórmula exata x_{n+1} = x_n - f(x_n)/f'(x_n).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para verificação numérica opcional"
                                  ],
                                  "tips": "Trate isso como resolver uma equação linear simples para x.",
                                  "learningObjective": "Derivar a atualização iterativa resolvendo a aproximação linear para zero.",
                                  "commonMistakes": [
                                    "Dividir incorretamente ou inverter o sinal do termo -f(x_n)",
                                    "Esquecer de subtrair x_n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e justificar a fórmula iterativa do método de Newton-Raphson",
                                  "subSteps": [
                                    "Reconheça que a fórmula é o método de Newton-Raphson para raízes.",
                                    "Explique a convergência quadrática sob condições (f'' contínua, x_0 próximo).",
                                    "Compare com métodos lineares como biseção (mais lento).",
                                    "Teste com f(x)=x^2-2, x_0=1: compute x_1 e veja melhoria.",
                                    "Discuta limitações: f'(x_n)=0 causa falha."
                                  ],
                                  "verification": "Explique em 2-3 frases por que isso leva à convergência rápida e cite o exemplo numérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre-se: cada iteração 'corrige' usando a tangente local.",
                                  "learningObjective": "Interpretar a derivação como base para o algoritmo iterativo e suas propriedades.",
                                  "commonMistakes": [
                                    "Achar que é exato (é aproximado)",
                                    "Ignorar hipótese f'(x_n)≠0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 2 (raiz √2 ≈1.414), com x_0=1: f(1)= -1, f'(1)=2, então x_1=1 - (-1)/2 = 1.5. Aproximação melhora de |1-1.414|=0.414 para |1.5-1.414|=0.086. Próxima: x_2=1.5 - (2.25-2)/3 ≈1.4167, erro <0.003.",
                              "finalVerifications": [
                                "Derivação algebrica completa da fórmula x_{n+1} = x_n - f(x_n)/f'(x_n) sem erros.",
                                "Explicação correta da aproximação linear como tangente em x_n.",
                                "Cálculo numérico de 2 iterações em um exemplo converge à raiz.",
                                "Identificação de condições para validade (f, f' contínuas, f'(x_n)≠0).",
                                "Comparação gráfica ou tabular da aproximação vs. f real perto de x_n.",
                                "Justificativa da ordem de convergência quadrática via análise do erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação passo a passo (100% correto).",
                                "Completude dos subpassos com justificativas teóricas.",
                                "Correção no exemplo prático com cálculos numéricos exatos.",
                                "Profundidade na discussão de limitações e convergência.",
                                "Clareza na explicação oral ou escrita da intuição geométrica.",
                                "Criatividade em conexões com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Expansões de Taylor e teorema do valor médio.",
                                "Programação: Implementação em Python para automação de iterações.",
                                "Física: Modelagem de trajetórias ou equilíbrios não-lineares.",
                                "Estatística: Otimização de máxima verossimilhança via Newton."
                              ],
                              "realWorldApplication": "Usado em engenharia para resolver equações não-lineares em estruturas (ex: tensão em vigas), em machine learning para otimizar redes neurais (gradiente Newton), e em finanças para precificar opções via equações diferenciais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.1.3",
                            "name": "Identificar requisitos para a função f(x)",
                            "description": "Listar e justificar as condições necessárias sobre f(x), como diferenciabilidade e f'(x) ≠ 0 próximo à raiz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos do Método de Newton-Raphson",
                                  "subSteps": [
                                    "Recordar a fórmula iterativa: x_{n+1} = x_n - f(x_n)/f'(x_n)",
                                    "Entender que o método usa a aproximação linear da tangente em x_n",
                                    "Identificar que o método busca raízes onde f(x) = 0",
                                    "Discutir a necessidade de uma boa estimativa inicial x_0",
                                    "Explicar por que o método é quadrático em convergência sob certas condições"
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a iteração e seu propósito geométrico",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre Newton-Raphson",
                                    "Gráfico de função exemplo (ex: f(x)=x^2-2)",
                                    "Calculadora ou software como Desmos"
                                  ],
                                  "tips": [
                                    "Visualize a tangente aproximando a curva perto da raiz para intuição.",
                                    "Compare com métodos lineares como bisseção para contrastar."
                                  ],
                                  "learningObjective": "Compreender a base teórica que impõe requisitos à função f(x)",
                                  "commonMistakes": [
                                    "Confundir a iteração com a regra de derivação simples.",
                                    "Ignorar o papel da derivada na linearização."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar os Requisitos Matemáticos Essenciais para f(x)",
                                  "subSteps": [
                                    "Requisito 1: f(x) deve ser contínua no intervalo de interesse",
                                    "Requisito 2: f(x) deve ser diferenciável (f' existe) em um intervalo ao redor da raiz",
                                    "Requisito 3: f'(x) ≠ 0 próximo à raiz (especificamente, f'(raiz) ≠ 0)",
                                    "Requisito 4: Existência de pelo menos uma raiz real no domínio",
                                    "Requisito 5: Boa estimativa inicial x_0 próxima à raiz"
                                  ],
                                  "verification": "Produzir uma lista numerada com os 5 principais requisitos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de requisitos em papel ou digital",
                                    "Exemplos de funções (f(x)=x^2, f(x)=sin(x))"
                                  ],
                                  "tips": [
                                    "Use o teorema do valor médio para ligar continuidade e diferenciabilidade.",
                                    "Priorize requisitos que afetam a derivada."
                                  ],
                                  "learningObjective": "Identificar precisamente as condições sobre f(x) necessárias para o método",
                                  "commonMistakes": [
                                    "Esquecer continuidade, achando que só derivada basta.",
                                    "Listar f'(x)=0 como requisito em vez de proibição."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Justificar Cada Requisito com Base na Derivação",
                                  "subSteps": [
                                    "Justificar continuidade: Garante existência de raiz pelo teorema de Bolzano se f(a)f(b)<0",
                                    "Justificar diferenciabilidade: Necessária para definir f' na iteração x_{n+1}",
                                    "Justificar f'(x)≠0: Evita divisão por zero e garante convergência quadrática (ordem 2)",
                                    "Analisar erro: e_{n+1} ≈ (f''(ξ)/2f'(raiz)) e_n^2, requer f'(raiz)≠0",
                                    "Discutir casos patológicos: raízes múltiplas onde f'(raiz)=0 causam convergência linear"
                                  ],
                                  "verification": "Escrever parágrafo justificando cada requisito com equação ou teorema",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Derivação do método (folha com Taylor)",
                                    "Livro de análise numérica (cap. Newton)"
                                  ],
                                  "tips": [
                                    "Derive o erro usando expansão de Taylor de 2ª ordem para clareza.",
                                    "Teste com f(x)=x^2 (raiz simples) vs f(x)=x^3 (múltipla)."
                                  ],
                                  "learningObjective": "Explicar matematicamente por que cada requisito é crucial para convergência",
                                  "commonMistakes": [
                                    "Justificar f'(x)≠0 só por 'divisão por zero', ignorando convergência.",
                                    "Confundir ordem de convergência com requisitos globais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Requisitos em uma Função Exemplo e Discutir Limitações",
                                  "subSteps": [
                                    "Escolher f(x) = x^3 - 2x + 2 e computar f' (x) = 3x^2 - 2",
                                    "Verificar continuidade: sim, polinômio",
                                    "Verificar diferenciabilidade: sim, em R",
                                    "Encontrar raízes aproximadas e checar f'(x)≠0 perto delas",
                                    "Simular iterações se requisito violado (ex: f(x)=x^{1/3} não diferenciável em 0)"
                                  ],
                                  "verification": "Relatório curto: 'Função atende? Justificativa?' para 2 exemplos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/MATLAB para plot e iterações",
                                    "Papel para esboços"
                                  ],
                                  "tips": [
                                    "Plote f e f' para visualização intuitiva.",
                                    "Considere modificações de Newton para raízes múltiplas."
                                  ],
                                  "learningObjective": "Aplicar identificação e verificação de requisitos em cenários reais",
                                  "commonMistakes": [
                                    "Assumir todo polinômio ok sem checar f'=0.",
                                    "Ignorar não-diferenciabilidade em pontos críticos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - 2x + 2: 1) Contínua: sim (polinômio). 2) Diferenciável: sim, f'(x)=3x^2-2. 3) Raiz ~0.85, f'(0.85)~0.13≠0. Justificativa: Permite iterações estáveis sem divisão zero e convergência rápida.",
                              "finalVerifications": [
                                "Lista corretamente os 5 requisitos principais sem omissões",
                                "Justifica f'(raiz)≠0 com análise de erro quadrático",
                                "Identifica violações em exemplos como f(x)=x^{1/3} ou raízes múltiplas",
                                "Explica impacto de má estimativa inicial",
                                "Verifica requisitos em uma função dada com f e f' plotados",
                                "Discute teorema de convergência local de Newton"
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem (100% dos requisitos corretos)",
                                "Profundidade das justificativas (cita teoremas/Taylor)",
                                "Capacidade de aplicação em exemplos novos (80% acerto)",
                                "Clareza na distinção entre requisitos locais/globais",
                                "Identificação de limitações e alternativas",
                                "Uso correto de terminologia (diferenciabilidade, convergência quadrática)"
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Expansões de Taylor e teorema do valor médio",
                                "Análise Numérica: Teoria de erros e convergência de métodos iterativos",
                                "Programação: Implementação numérica com verificação de f'≠0",
                                "Física Computacional: Solução de EDOs não-lineares em simulações",
                                "Otimização: Gradiente descendente como variante de Newton"
                              ],
                              "realWorldApplication": "Em finanças, resolve equações implícitas para precificação de derivativos (Black-Scholes); em machine learning, otimiza redes neurais via Newton para mínimos locais; em engenharia, encontra equilíbrios em sistemas não-lineares como fluxo de fluidos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.1.2",
                        "name": "Algoritmo Iterativo e Implementação",
                        "description": "Estrutura algorítmica do método, incluindo pseudocódigo, critérios de parada e implementação prática.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.2.1",
                            "name": "Escrever o pseudocódigo completo do algoritmo",
                            "description": "Construir o pseudocódigo com parâmetros de entrada (função f, derivada f', chute inicial x0, tolerância ε, máximo de iterações), loop iterativo e verificação de convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a assinatura da função e inicializar variáveis",
                                  "subSteps": [
                                    "Escrever a declaração da função com os parâmetros: f (função), f' (derivada), x0 (chute inicial), ε (tolerância), max_iter (máximo de iterações).",
                                    "Inicializar a variável x com o valor de x0.",
                                    "Opcionalmente, inicializar um contador de iterações i = 0.",
                                    "Garantir que a notação do pseudocódigo seja clara e consistente (ex: 'FUNÇÃO NewtonRaphson(f, f_prime, x0, epsilon, max_iter)').",
                                    "Verificar se todos os parâmetros estão explicitamente listados."
                                  ],
                                  "verification": "A declaração da função inclui todos os 5 parâmetros corretos e x é inicializado como x0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência ao algoritmo Newton-Raphson"
                                  ],
                                  "tips": "Use convenções padrão de pseudocódigo para facilitar a leitura, como palavras em maiúsculas para comandos.",
                                  "learningObjective": "Compreender e especificar corretamente os insumos necessários para o método de Newton-Raphson.",
                                  "commonMistakes": [
                                    "Esquecer o parâmetro de tolerância ε ou máximo de iterações",
                                    "Inicializar x incorretamente",
                                    "Usar nomes de variáveis inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar o loop iterativo principal",
                                  "subSteps": [
                                    "Iniciar um loop 'PARA i DE 1 ATÉ max_iter' ou equivalente com contador.",
                                    "Incrementar o contador i no início ou fim do loop.",
                                    "Calcular fx = f(x) e fpx = f'(x) dentro do loop.",
                                    "Calcular a nova aproximação x_novo = x - fx / fpx.",
                                    "Atualizar x = x_novo após os cálculos."
                                  ],
                                  "verification": "O loop está presente com iterações limitadas por max_iter e inclui os cálculos de fx, fpx e x_novo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo simples de função para testar mentalmente"
                                  ],
                                  "tips": "Evite divisão por zero verificando se fpx != 0, mas foque no núcleo primeiro.",
                                  "learningObjective": "Implementar a fórmula iterativa central do método de Newton-Raphson.",
                                  "commonMistakes": [
                                    "Colocar o loop sem limite de iterações",
                                    "Erro na fórmula: usar + em vez de -",
                                    "Atualizar x antes de verificar convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar verificações de convergência",
                                  "subSteps": [
                                    "Após calcular fx, verificar se |fx| < ε; se sim, retornar x.",
                                    "Após calcular x_novo, verificar se |x_novo - x| < ε; se sim, retornar x_novo.",
                                    "Posicionar as verificações logo após os cálculos relevantes, antes de atualizar x.",
                                    "Usar notação absoluta clara, como 'SE ABS(fx) < epsilon ENTÃO RETORNAR x'.",
                                    "Garantir que as verificações saiam do loop prematuramente se convergirem."
                                  ],
                                  "verification": "Ambas as condições de convergência (|f(x)| < ε e |Δx| < ε) estão implementadas corretamente dentro do loop.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência matemática do método",
                                    "Calculadora para simular valores"
                                  ],
                                  "tips": "A verificação em f(x) é para raiz exata; em Δx para estabilidade numérica.",
                                  "learningObjective": "Garantir parada eficiente do algoritmo quando converge.",
                                  "commonMistakes": [
                                    "Verificar apenas uma condição",
                                    "Usar ε sem absoluto",
                                    "Colocar verificações fora do loop"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar o algoritmo com tratamento de não convergência",
                                  "subSteps": [
                                    "Após o loop, adicionar um retorno final de x (ou mensagem de 'não convergiu').",
                                    "Opcionalmente, retornar o número de iterações realizadas.",
                                    "Revisar o pseudocódigo completo para fluxo lógico.",
                                    "Testar mentalmente com um exemplo simples.",
                                    "Ajustar indentação para clareza visual."
                                  ],
                                  "verification": "O pseudocódigo tem um retorno após o loop e fluxo lógico completo sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo parcial dos steps anteriores"
                                  ],
                                  "tips": "Inclua um comentário para casos de não convergência para robustez.",
                                  "learningObjective": "Completar o algoritmo de forma robusta e legível.",
                                  "commonMistakes": [
                                    "Esquecer retorno após loop",
                                    "Loop infinito sem break",
                                    "Indentação confusa"
                                  ]
                                }
                              ],
                              "practicalExample": "Para encontrar a raiz positiva de f(x) = x² - 2 (aprox. √2 ≈ 1.414), use f'(x) = 2x, x0 = 1, ε = 0.001, max_iter = 10. Pseudocódigo: fx = 1²-2=-1, fpx=2*1=2, x_novo=1-(-1)/2=1.5; |fx|=1>0.001, |Δx|=0.5>0.001; continua até convergir em ~1.414 após poucas iterações.",
                              "finalVerifications": [
                                "Todos os 5 parâmetros estão na assinatura da função.",
                                "Loop iterativo limitado por max_iter.",
                                "Cálculo correto: x_novo = x - f(x)/f'(x).",
                                "Duas verificações de convergência: |f(x)| < ε e |x_novo - x| < ε.",
                                "Retorno após loop para não convergência.",
                                "Notação clara e indentada corretamente."
                              ],
                              "assessmentCriteria": [
                                "Corretude lógica da iteração e convergência (100% pontos).",
                                "Clareza e consistência da notação pseudocódigo (20%).",
                                "Presença de todos os elementos obrigatórios (parâmetros, loop, verificações).",
                                "Tratamento implícito de casos edge (ex: f'≠0 comentado).",
                                "Fluxo lógico sem ambiguidades ou erros.",
                                "Legibilidade geral (indentação, comentários opcionais)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial e limites.",
                                "Física: Resolução de equações não-lineares em modelagem.",
                                "Engenharia: Otimização numérica em simulações.",
                                "Inteligência Artificial: Minimização de funções de perda em gradiente descendente.",
                                "Análise de Dados: Solvers em bibliotecas como SciPy."
                              ],
                              "realWorldApplication": "O método é amplamente usado em software de engenharia (ex: MATLAB, solvers de equações não-lineares), otimização em machine learning (encontrar mínimos locais), simulações físicas (equilíbrio em estruturas) e finanças (preços de opções via equações diferenciais)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2.2",
                            "name": "Implementar o método em linguagem de programação",
                            "description": "Codificar o algoritmo em Python ou C++, incluindo cálculo numérico de f e f', tratamento de erros (divisão por zero) e saída de resultados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir funções matemáticas f(x) e f'(x)",
                                  "subSteps": [
                                    "Escolha uma equação exemplo, como f(x) = x² - 2 (raiz √2 ≈ 1.414).",
                                    "Crie a função def f(x): return x**2 - 2 em Python.",
                                    "Crie a derivada def df(x): return 2*x.",
                                    "Adicione testes unitários simples: print(f(1)) deve ser -1, print(df(1)) deve ser 2.",
                                    "Comente o código explicando o propósito de cada função."
                                  ],
                                  "verification": "Execute o script e confirme que f(1) ≈ -1 e df(1) = 2 sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python 3+, editor de código (VS Code ou PyCharm), terminal para execução.",
                                  "tips": "Use nomes descritivos e docstrings para funções (ex: '''Função objetivo''' ).",
                                  "learningObjective": "Representar funções matemáticas e suas derivadas de forma programática e testável.",
                                  "commonMistakes": "Erros de sintaxe em expressões matemáticas (ex: ** para potência); esquecer parênteses em retornos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o núcleo iterativo do método Newton-Raphson",
                                  "subSteps": [
                                    "Defina parâmetros iniciais: x0 = 1.0 (chute inicial), tol = 1e-6, max_iter = 100.",
                                    "Crie uma lista para armazenar iterações: iterations = []",
                                    "Inicie loop while iter < max_iter and abs(f(x)) > tol:",
                                    "Calcule fx = f(x), dfx = df(x), x_new = x - fx / dfx.",
                                    "Atualize x = x_new, append iteração à lista, incremente iter."
                                  ],
                                  "verification": "Execute com poucos iterações manuais; confirme convergência para ≈1.414 em 5-6 passos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo do step 1; acesso a documentação Python (docs.python.org).",
                                  "tips": "Use abs() para tolerância em diferenças absolutas ou relativas para robustez.",
                                  "learningObjective": "Codificar a iteração x_{n+1} = x_n - f(x_n)/f'(x_n) com controle de loop.",
                                  "commonMistakes": "Loop infinito por falta de condição de parada; divisão sem check de dfx=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar tratamento de erros e exceções",
                                  "subSteps": [
                                    "Adicione try-except no cálculo de x_new: if abs(dfx) < 1e-10: raise ValueError('Derivada próxima de zero').",
                                    "Verifique convergência: if iter >= max_iter: raise RuntimeError('Não convergiu em max_iter').",
                                    "Trate exceções principais: ZeroDivisionError, ValueError, RuntimeError com mensagens amigáveis.",
                                    "Adicione validação de entrada: if tol <= 0 or max_iter <= 0: raise ValueError('Parâmetros inválidos').",
                                    "Teste cenários: dfx=0 forçado, max_iter baixo."
                                  ],
                                  "verification": "Force erros (ex: x0 onde df=0) e confirme que exceções são capturadas e reportadas corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo do step 1; exemplos de exceções Python.",
                                  "tips": "Use logging em vez de print para erros em produção; hierarquize exceções.",
                                  "learningObjective": "Garantir robustez do código com handling de casos edge como divisão por zero.",
                                  "commonMistakes": "Ignorar exceções silenciosamente (bare except); thresholds inadequados para dfx."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar saída de resultados e testes",
                                  "subSteps": [
                                    "Crie função print_results(iterations, root): formate tabela com iteração, x, f(x).",
                                    "Imprima raiz final com precisão: print(f'Raiz aproximada: {root:.10f}').",
                                    "Adicione main() com exemplo: newton_raphson(1.0, 1e-6, 100).",
                                    "Teste com múltiplos casos: f(x)=x**3-2x-5, x0=2.0; valide contra raízes conhecidas.",
                                    "Comente todo o código e adicione README com uso."
                                  ],
                                  "verification": "Execute main(); confirme tabela de iterações e raiz precisa (erro < tol).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo do step 1; calculadora ou Wolfram Alpha para validação manual.",
                                  "tips": "Use f-strings para formatação limpa; salve iterações em CSV para análise.",
                                  "learningObjective": "Produzir saídas legíveis e validar implementação com testes empíricos.",
                                  "commonMistakes": "Formatação pobre (muitos decimais); falta de precisão na saída final."
                                }
                              ],
                              "practicalExample": "Implemente em Python para f(x) = x³ - 2x - 5 = 0 com x0=2.0, tol=1e-6. O código deve iterar ~5 vezes, output tabela de x_n e f(x_n), convergir para ≈2.09455, tratar se df(x)=3x²-2≈0.",
                              "finalVerifications": [
                                "Código executa sem crashes para casos válidos e inválidos.",
                                "Converge corretamente para raízes conhecidas (ex: √2 em <10 iterações).",
                                "Tabela de iterações mostra redução monotonic em |f(x)|.",
                                "Exceções disparam apropriadamente para divisão por zero ou não-convergência.",
                                "Saída final tem precisão ≥6 casas decimais e erro < tol.",
                                "Código é legível com comentários em ≥80% das linhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão algorítmica: iteração segue fórmula exata de Newton-Raphson.",
                                "Robustez: ≥3 tipos de erros tratados com mensagens claras.",
                                "Eficiência: max_iter razoável, convergência em <20 passos para exemplos padrão.",
                                "Qualidade de código: indentação PEP8, funções modulares, testes embutidos.",
                                "Documentação: docstrings, comentários explicando matemática e lógica.",
                                "Usabilidade: main() executável standalone com exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo I/II (derivadas, convergência de sequências).",
                                "Física: Simulações numéricas (equilíbrio em mecânica não-linear).",
                                "Engenharia: Otimização em controle de sistemas (solvers de EDOs).",
                                "Estatística: Maximização de verossimilhança em modelos probabilísticos."
                              ],
                              "realWorldApplication": "Solvers de equações não-lineares em software de engenharia (MATLAB/NumPy), finanças (preços de opções Black-Scholes), machine learning (otimização de gradiente), e simulações científicas (fluidodinâmica, química computacional)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2.3",
                            "name": "Executar iterações manualmente para um exemplo",
                            "description": "Aplicar o método passo a passo à equação f(x) = x² - 2 = 0 com x0 = 1, calculando pelo menos 4 iterações e analisando a aproximação da raiz √2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o problema e inicializar variáveis",
                                  "subSteps": [
                                    "Defina a função f(x) = x² - 2.",
                                    "Calcule a derivada f'(x) = 2x.",
                                    "Escolha o ponto inicial x₀ = 1.",
                                    "Anote o valor aproximado de √2 ≈ 1.41421356 para referência futura.",
                                    "Crie uma tabela com colunas: n, x_n, f(x_n), f'(x_n), x_{n+1}."
                                  ],
                                  "verification": "Tabela inicial preenchida corretamente com x₀ = 1, f(x₀) = -1, f'(x₀) = 2.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Use uma tabela organizada para rastrear todos os valores e evitar confusões nas iterações.",
                                  "learningObjective": "Entender a configuração inicial do método de Newton-Raphson e preparar ferramentas para cálculos iterativos.",
                                  "commonMistakes": [
                                    "Esquecer de calcular f'(x) corretamente",
                                    "Usar valor inicial inadequado sem justificativa",
                                    "Não anotar √2 para comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a primeira iteração (calcular x₁)",
                                  "subSteps": [
                                    "Calcule f(x₀) = 1² - 2 = -1.",
                                    "Calcule f'(x₀) = 2 × 1 = 2.",
                                    "Aplique a fórmula: x₁ = x₀ - f(x₀)/f'(x₀) = 1 - (-1)/2 = 1 + 0.5 = 1.5.",
                                    "Preencha a tabela com os valores: n=0, x₀=1, f= -1, f'=2, x₁=1.5.",
                                    "Verifique se f'(x₀) ≠ 0."
                                  ],
                                  "verification": "x₁ calculado como exatamente 1.5 e registrado na tabela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel com tabela",
                                    "Calculadora"
                                  ],
                                  "tips": "Faça os cálculos à mão primeiro para entender o processo, depois use calculadora para confirmar.",
                                  "learningObjective": "Aplicar corretamente a fórmula de iteração uma vez e registrar resultados.",
                                  "commonMistakes": [
                                    "Erro de sinal em f(x₀) - f'(x)",
                                    "Dividir por f(x) em vez de f'(x)",
                                    "Arredondar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a segunda iteração (calcular x₂)",
                                  "subSteps": [
                                    "Calcule f(x₁) = 1.5² - 2 = 2.25 - 2 = 0.25.",
                                    "Calcule f'(x₁) = 2 × 1.5 = 3.",
                                    "Aplique a fórmula: x₂ = 1.5 - 0.25/3 ≈ 1.5 - 0.083333 ≈ 1.416667.",
                                    "Preencha a tabela com n=1, x₁=1.5, f=0.25, f'=3, x₂≈1.4167.",
                                    "Compare x₂ com √2 para notar melhoria."
                                  ],
                                  "verification": "x₂ ≈ 1.4167 (com 4 casas decimais) e tabela atualizada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel com tabela atualizada",
                                    "Calculadora"
                                  ],
                                  "tips": "Mantenha pelo menos 5 casas decimais para precisão em iterações subsequentes.",
                                  "learningObjective": "Executar iteração subsequente usando resultado anterior e observar convergência inicial.",
                                  "commonMistakes": [
                                    "Usar x₀ em vez de x₁",
                                    "Erro aritmético em 0.25/3",
                                    "Ignorar casas decimais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar as iterações terceira e quarta (x₃ e x₄)",
                                  "subSteps": [
                                    "Para x₃: f(1.4167) ≈ 2.007 - 2 ≈ 0.007, f'(1.4167) ≈ 2.8333, x₃ ≈ 1.4167 - 0.007/2.8333 ≈ 1.4142.",
                                    "Preencha tabela para n=2.",
                                    "Para x₄: f(1.4142) ≈ 2.0000 - 2 ≈ 0.00007, f'(1.4142) ≈ 2.8284, x₄ ≈ 1.4142 - 0.00007/2.8284 ≈ 1.41421.",
                                    "Preencha tabela para n=3.",
                                    "Confirme f'(x_n) ≠ 0 em todas."
                                  ],
                                  "verification": "x₃ ≈ 1.4142 e x₄ ≈ 1.41421 registrados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel com tabela",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use aproximações consistentes e calcule f(x) com precisão para evitar propagação de erros.",
                                  "learningObjective": "Completar múltiplas iterações e manter precisão numérica.",
                                  "commonMistakes": [
                                    "Propagação de erros de arredondamento",
                                    "Confundir ordem das iterações",
                                    "Calcular f' errado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar a aproximação e convergência",
                                  "subSteps": [
                                    "Compare x₄ ≈ 1.41421 com √2 ≈ 1.41421356 (erro ≈ 0.00000356).",
                                    "Calcule erros relativos: |x_{n+1} - x_n| e |x_n - √2| para cada iteração.",
                                    "Observe que o erro diminui quadraticamente (característica do Newton-Raphson).",
                                    "Discuta por que converge rapidamente para esta equação.",
                                    "Resuma em uma frase a aproximação obtida."
                                  ],
                                  "verification": "Tabela de erros calculada e conclusão de convergência escrita.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela completa",
                                    "Valor exato de √2"
                                  ],
                                  "tips": "Plote os valores em um gráfico simples para visualizar convergência.",
                                  "learningObjective": "Interpretar resultados iterativos e avaliar qualidade da aproximação.",
                                  "commonMistakes": [
                                    "Não calcular erros",
                                    "Concluir convergência sem evidência",
                                    "Comparar com valor errado de √2"
                                  ]
                                }
                              ],
                              "practicalExample": "Aplicando manualmente: x0=1 → x1=1.5 → x2≈1.4167 → x3≈1.4142 → x4≈1.41421, aproximando √2 com erro < 10^{-5} após 4 iterações, demonstrando convergência quadrática.",
                              "finalVerifications": [
                                "Tabela completa com 4 iterações e valores corretos até 4 casas decimais.",
                                "Erros relativos calculados e decrescentes.",
                                "x4 dentro de 0.001 de √2.",
                                "Fórmula de iteração aplicada consistentemente.",
                                "f'(x_n) ≠ 0 verificado em todas iterações.",
                                "Conclusão escrita sobre aproximação da raiz."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética nos cálculos (sem erros > 0.001).",
                                "Organização clara da tabela de iterações.",
                                "Correta aplicação da fórmula Newton-Raphson.",
                                "Análise qualitativa e quantitativa da convergência.",
                                "Identificação de erros relativos e comparação com √2.",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial e raízes de equações não-lineares.",
                                "Física: Aproximações numéricas em mecânica orbital e potenciais.",
                                "Engenharia: Otimização em design de estruturas e controle de sistemas.",
                                "Economia: Modelos de equilíbrio em mercados dinâmicos."
                              ],
                              "realWorldApplication": "Em software de engenharia para resolver equações não-lineares em simulações de fluidos, otimização de redes neurais em IA, e precificação de derivativos financeiros onde raízes aproximadas são essenciais para precisão computacional eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.1.3",
                        "name": "Análise de Convergência Quadrática",
                        "description": "Estudo teórico da taxa de convergência, condições de garantia e análise assintótica do erro.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.3.1",
                            "name": "Descrever condições para convergência local",
                            "description": "Explicar as hipóteses de Banach (f contínua, f' contínua e invertível, f'' limitada) que garantem convergência a partir de um chute inicial próximo à raiz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de convergência local no Método de Newton-Raphson",
                                  "subSteps": [
                                    "Defina convergência local como a propriedade onde, a partir de um chute inicial suficientemente próximo da raiz, a sequência de iterações converge para a raiz exata.",
                                    "Diferencie convergência local de convergência global, destacando que a local depende de um bairro ao redor da raiz.",
                                    "Revise a iteração do Newton: x_{n+1} = x_n - f(x_n)/f'(x_n), e introduza o conceito de atração quadrática.",
                                    "Estude o papel das derivadas na análise de erro: e_{n+1} ≈ (f''(ξ)/(2 f'(r))) e_n².",
                                    "Identifique que as condições de Banach garantem contração no espaço de Banach para o operador de Newton."
                                  ],
                                  "verification": "Escreva uma definição precisa de convergência local e explique por que ela é 'local' em suas próprias palavras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires), notas de aula sobre Newton-Raphson, calculadora gráfica."
                                  ],
                                  "tips": "Visualize graficamente o método com funções como f(x) = x² - 2 para intuitivamente ver o 'bairro de atração'.",
                                  "learningObjective": "Dominar a definição e motivação de convergência local no contexto do Newton-Raphson.",
                                  "commonMistakes": "Confundir convergência local com global; ignorar que o método pode divergir longe da raiz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e descrever as hipóteses principais de Banach",
                                  "subSteps": [
                                    "Liste a primeira hipótese: f é contínua e diferenciável em um intervalo fechado ao redor da raiz r.",
                                    "Descreva a segunda: f' é contínua e invertível em r (i.e., f'(r) ≠ 0), garantindo que a derivada não zere na raiz.",
                                    "Explique a terceira: f'' existe e é contínua (ou limitada) em um bairro de r, controlando o termo quadrático no erro.",
                                    "Relacione essas hipóteses ao teorema do ponto fixo de Banach aplicado ao operador g(x) = x - f(x)/f'(x).",
                                    "Verifique matematicamente que |g'(x)| < 1 em um bairro pequeno garante contração."
                                  ],
                                  "verification": "Enumere as três hipóteses com descrições curtas e justifique por que cada uma é necessária.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Teorema de Banach em PDF, exemplos de funções satisfazendo/não satisfazendo as hipóteses, papel e lápis para derivações."
                                  ],
                                  "tips": "Use contraexemplos: f(x) = x^{1/3} onde f'(r)=0 falha; memorize as hipóteses como 'f suave, f' não-zero, f'' domada'.",
                                  "learningObjective": "Memorizar e explicar precisamente as três hipóteses de Banach para convergência local.",
                                  "commonMistakes": "Esquecer que f' deve ser invertível apenas na raiz; confundir f contínua com f diferenciável."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o papel do chute inicial próximo à raiz",
                                  "subSteps": [
                                    "Defina o 'chute inicial próximo': existe δ > 0 tal que se |x_0 - r| < δ, então converge.",
                                    "Estude a prova esboçada: mostrar que g(x) é contração com constante k < 1 em B(r, δ), via |g'(x)| ≤ k.",
                                    "Calcule explicitamente δ baseado em M = sup |f''|/|f'(r)|, garantindo k = M δ / 2 < 1.",
                                    "Discuta como escolher x_0: use gráficos, bounds ou métodos auxiliares como bissecção.",
                                    "Simule numericamente: itere com x_0 dentro/fora de δ e observe convergência/divergência."
                                  ],
                                  "verification": "Para f(x)=x²-2, r=√2, calcule δ aproximado e teste dois x_0, um dentro e um fora.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software como Python/MATLAB para simulações, tabela de valores de f, f', f''."
                                  ],
                                  "tips": "Comece com δ pequeno (ex: 0.1) e aumente gradualmente para mapear o raio de convergência.",
                                  "learningObjective": "Entender quantitativamente como a proximidade inicial ativa as hipóteses para convergência.",
                                  "commonMistakes": "Assumir que qualquer chute funciona; não quantificar δ explicitamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar as condições e discutir convergência quadrática",
                                  "subSteps": [
                                    "Resuma todas as condições: f C², f'(r)≠0, x_0 próximo o suficiente.",
                                    "Explique a ordem quadrática: erro dobra em precisão a cada iteração (e_{n+1} ~ e_n²).",
                                    "Compare com bissecção (linear): Newton é mais eficiente localmente.",
                                    "Discuta limitações: singularidades em f', oscilações se fora do bairro.",
                                    "Pratique descrevendo verbalmente: 'Sob hipóteses de Banach, Newton converge quadraticamente localmente.'"
                                  ],
                                  "verification": "Escreva um parágrafo completo descrevendo as condições e sua garantia de convergência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Resumo em uma folha, exemplos de taxas de convergência em tabela."
                                  ],
                                  "tips": "Use analogia: 'Como um funil – largo em cima (global incerto), estreito embaixo (local rápido)'.",
                                  "learningObjective": "Capacitar-se a descrever integralmente as condições e implicações.",
                                  "commonMistakes": "Ignorar a ordem quadrática como consequência direta das hipóteses."
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - 2x + 1 com raiz r ≈ 0.7549 (f'(r) ≈ 1.21 ≠0, f'' limitada), escolha x_0 = 0.8 (<δ≈0.1). Itere: x1≈0.754877, x2≈0.754877 (quadrática!). Com x_0=1.5, diverge inicialmente.",
                              "finalVerifications": [
                                "Liste corretamente as três hipóteses de Banach sem omissões.",
                                "Explique o papel de cada hipótese na prova de contração.",
                                "Calcule δ aproximado para um exemplo dado.",
                                "Descreva verbalmente as condições em 1 minuto.",
                                "Simule convergência com x_0 próximo vs. distante.",
                                "Compare taxa quadrática com método linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão na enunciação das hipóteses (f C¹, f'(r)≠0, f'' limitada).",
                                "Compreensão quantitativa do raio δ e constante de Lipschitz.",
                                "Uso correto de notação matemática (e_{n+1} ~ C e_n²).",
                                "Capacidade de aplicar a exemplos concretos.",
                                "Identificação de cenários onde condições falham.",
                                "Clareza na descrição oral/escrita das condições."
                              ],
                              "crossCurricularConnections": [
                                "Análise Real: Teorema do Ponto Fixo de Banach.",
                                "Programação: Implementação numérica em Python (SciPy).",
                                "Física: Solução de EDOs não-lineares em simulações.",
                                "Otimização: Gradiente descendente modificado em ML."
                              ],
                              "realWorldApplication": "Em machine learning, otimização de redes neurais usa variantes de Newton para convergência rápida em mínimos locais próximos; em engenharia, resolve equações não-lineares em estruturas (ex: equilíbrio de vigas) garantindo precisão com chutes iniciais de modelos lineares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3.2",
                            "name": "Demonstrar a convergência quadrática",
                            "description": "Provar que o erro satisfaz |e_{n+1}| ≈ (f''(ξ)/(2 f'(α))) |e_n|², onde α é a raiz, mostrando ordem de convergência 2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Newton-Raphson e Definir o Erro",
                                  "subSteps": [
                                    "Relembre a iteração do método: x_{n+1} = x_n - f(x_n)/f'(x_n), onde α é a raiz simples (f(α)=0, f'(α)≠0).",
                                    "Defina o erro e_n = x_n - α.",
                                    "Expresse x_{n+1} em termos de α: e_{n+1} = x_{n+1} - α.",
                                    "Assuma que f é duas vezes diferenciável e f'(α) ≠ 0.",
                                    "Escreva a equação do erro inicial: e_{n+1} = e_n - f(x_n)/f'(x_n)."
                                  ],
                                  "verification": "Verifique se a definição de e_n está correta e se a equação inicial de e_{n+1} foi derivada sem erros algébricos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto para anotações",
                                    "Livro ou notas sobre métodos numéricos",
                                    "Calculadora simbólica opcional (ex: SymPy)"
                                  ],
                                  "tips": "Comece com uma função simples como f(x) = x² - 2 para visualizar intuitivamente.",
                                  "learningObjective": "Entender a base iterativa do método e a notação de erro para análise de convergência.",
                                  "commonMistakes": "Confundir e_n com α - x_n; esquecer que α é raiz simples com f'(α)≠0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Expansão de Taylor para f(x_n) ao Redor de α",
                                  "subSteps": [
                                    "Expanda f(x_n) usando Taylor de segunda ordem: f(x_n) = f(α + e_n) = f(α) + f'(α)e_n + (f''(ξ)/2)e_n², para algum ξ entre α e x_n.",
                                    "Como f(α)=0, simplifique para f(x_n) = f'(α)e_n + (f''(ξ)/2)e_n².",
                                    "Agora expanda f'(x_n): f'(x_n) = f'(α + e_n) = f'(α) + f''(η)e_n, para algum η entre α e x_n.",
                                    "Substitua essas expansões na iteração de Newton.",
                                    "Mantenha termos até ordem quadrática, descartando higher-order se necessário."
                                  ],
                                  "verification": "Confirme que as expansões de Taylor estão corretas e que os restos de Lagrange foram identificados com ξ e η.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para derivações",
                                    "Referência de teorema de Taylor",
                                    "Software como Mathematica ou papel para cálculos manuais"
                                  ],
                                  "tips": "Desenhe o gráfico da função para visualizar ξ e η entre α e x_n.",
                                  "learningObjective": "Dominar a aplicação de séries de Taylor em análise de erros numéricos.",
                                  "commonMistakes": "Esquecer o termo f(α)=0; usar expansão de primeira ordem apenas, perdendo o quadrático."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Relação de Erro e_{n+1} em Termos de e_n",
                                  "subSteps": [
                                    "Substitua f(x_n)/f'(x_n) = [f'(α)e_n + (f''(ξ)/2)e_n²] / [f'(α) + f''(η)e_n].",
                                    "Divida numerador e denominador por f'(α): = e_n [1 + (f''(ξ)/(2 f'(α))) e_n] / [1 + (f''(η)/f'(α)) e_n].",
                                    "Use aproximação para pequenos e_n: 1/(1 + δ) ≈ 1 - δ + δ², onde δ = (f''(η)/f'(α)) e_n.",
                                    "Multiplique: e_{n+1} ≈ e_n [1 + C e_n] [1 - δ + δ²], onde C = f''(ξ)/(2 f'(α)).",
                                    "Colete termos: até ordem quadrática, e_{n+1} ≈ [f''(ξ)/(2 f'(α))] e_n²."
                                  ],
                                  "verification": "Simplifique algébricamente até obter |e_{n+1}| ≈ |f''(ξ)/(2 f'(α))| |e_n|².",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico para simplificações",
                                    "Papel quadriculado para álgebra"
                                  ],
                                  "tips": "Trabalhe com símbolos genéricos antes de números; verifique limites para e_n → 0.",
                                  "learningObjective": "Derivar precisamente a relação assintótica do erro quadrático.",
                                  "commonMistakes": "Erros em aproximações de série (ex: parar em 1 - δ sem δ²); confundir ξ e η."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Demonstrar a Ordem de Convergência Quadrática",
                                  "subSteps": [
                                    "Defina ordem de convergência: lim_{n→∞} |e_{n+1}| / |e_n|^p = L ≠ 0,∞ implica ordem p.",
                                    "Para p=2, mostre lim |e_{n+1}| / |e_n|² = |f''(ξ)/(2 f'(α))|, que existe e é finito sob hipóteses.",
                                    "Como e_n → 0, ξ → α, então constante ≈ |f''(α)/(2 f'(α))|.",
                                    "Confirme numericamente com iterações para uma função teste.",
                                    "Conclua que a convergência é quadrática localmente."
                                  ],
                                  "verification": "Verifique o limite e simule 5-10 iterações para observar |e_{n+1}| / |e_n|² aproximando constante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou MATLAB para simulação numérica",
                                    "Função teste f(x)=x²-2"
                                  ],
                                  "tips": "Use log-log plot de erros para visualizar ordem 2.",
                                  "learningObjective": "Interpretar a relação de erro como prova de ordem 2 de convergência.",
                                  "commonMistakes": "Confundir ordem quadrática com linear; ignorar condições locais (próximo de α)."
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 2 (raiz α=√2≈1.4142, f'(x)=2x, f''(x)=2), inicie com x_0=1.5. Calcule iterações: x1≈1.4167, e0=-0.0858, e1≈0.0025; verifique |e1| / |e0|² ≈ 0.354 ≈ f''(α)/(2f'(α))=2/(2*1.4142*2)≈0.353.",
                              "finalVerifications": [
                                "Derivação completa da expansão de Taylor sem erros algébricos.",
                                "Relação de erro |e_{n+1}| ≈ C |e_n|² explicitamente escrita com C = f''(ξ)/(2 f'(α)).",
                                "Identificação correta de ξ no teorema do resto.",
                                "Demonstração do limite para ordem de convergência 2.",
                                "Simulação numérica confirmando o comportamento quadrático.",
                                "Condições de f diferenciável duas vezes e f'(α)≠0 explicitadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de Taylor (pontos cheios se resto de Lagrange correto).",
                                "Correção na aproximação assintótica do erro (até O(e_n³) implícito).",
                                "Clareza na explicação do limite para ordem p=2.",
                                "Uso apropriado de notação (e_n, ξ, α).",
                                "Exemplo numérico com pelo menos 3 iterações e cálculo de |e_{n+1}/e_n²|.",
                                "Ausência de erros comuns como inversão de sinais ou ordens erradas."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial e Integral: Expansões de Taylor e restos de Lagrange.",
                                "Álgebra Linear: Aplicações em sistemas não-lineares e Jacobianos.",
                                "Estatística: Análise de erros em aproximações numéricas probabilísticas.",
                                "Física Computacional: Solução de equações em simulações dinâmicas."
                              ],
                              "realWorldApplication": "Em machine learning, o método de Newton é usado em otimização de redes neurais (ex: segundo ordem em TensorFlow), onde convergência quadrática acelera treinamento perto do mínimo, reduzindo iterações em problemas de regressão logística ou visão computacional."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3.3",
                            "name": "Comparar com outros métodos numéricos",
                            "description": "Analisar vantagens da convergência quadrática em relação ao método da bisseção (linear) ou secante (superlinear), com exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos dos Métodos Numéricos",
                                  "subSteps": [
                                    "Descreva o método da bisseção: intervalo inicial [a,b], ponto médio, convergência linear.",
                                    "Explique o método da secante: aproximação usando dois pontos iniciais, convergência superlinear.",
                                    "Detalhe o método de Newton-Raphson: iteração x_{n+1} = x_n - f(x_n)/f'(x_n), convergência quadrática.",
                                    "Liste pré-condições para cada método (ex: continuidade, derivada não zero).",
                                    "Compare requisitos iniciais: bisseção precisa de intervalo, outros de chute inicial."
                                  ],
                                  "verification": "Escreva um resumo de 1 parágrafo por método e identifique diferenças chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, calculadora, notas de aula sobre algoritmos numéricos.",
                                  "tips": "Use diagramas de fluxo para visualizar iterações de cada método.",
                                  "learningObjective": "Compreender os fundamentos e iterações de bisseção, secante e Newton-Raphson.",
                                  "commonMistakes": "Confundir secante com Newton (secante não usa derivada); ignorar condições de parada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Taxas de Convergência",
                                  "subSteps": [
                                    "Defina convergência linear: erro reduz por fator constante <1 por iteração.",
                                    "Explique superlinear para secante: ordem entre 1 e 2 (aprox. 1.618 pela constante de Feigenbaum).",
                                    "Descreva convergência quadrática de Newton: erro ~ erro anterior ao quadrado.",
                                    "Estude fórmulas assintóticas: |e_{n+1}| ≈ C |e_n|^p, onde p=1 (bisseção), p≈1.618 (secante), p=2 (Newton).",
                                    "Discuta impacto: Newton converge muito mais rápido perto da raiz."
                                  ],
                                  "verification": "Calcule manualmente a ordem de convergência para uma sequência de erros fictícia.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de fórmulas, software como Python ou MATLAB para plotar erros.",
                                  "tips": "Plote log(erros) vs iterações para visualizar quadraticidade (parábola).",
                                  "learningObjective": "Diferenciar e quantificar linear, superlinear e quadrática convergência.",
                                  "commonMistakes": "Assumir convergência sempre; não considerar região de atração inicial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Teoricamente Vantagens e Desvantagens",
                                  "subSteps": [
                                    "Liste vantagens de Newton: velocidade (quadrática) vs bisseção (lenta, linear).",
                                    "Compare com secante: Newton mais rápido, mas requer derivada; secante não.",
                                    "Discuta desvantagens: Newton sensível a chute inicial, pode divergir sem f'≠0.",
                                    "Crie tabela comparativa: precisão, custo computacional, robustez.",
                                    "Analise cenários: bisseção para raízes múltiplas, Newton para suaves."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 critérios.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha (Excel/Google Sheets) para tabela, referências teóricas.",
                                  "tips": "Priorize custo por dígito de precisão: Newton ~log(log(eps)), bisseção ~log(eps).",
                                  "learningObjective": "Analisar trade-offs teóricos entre os métodos.",
                                  "commonMistakes": "Ignorar custo de derivada em Newton; superestimar robustez da bisseção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar Comparações Numéricas com Exemplos",
                                  "subSteps": [
                                    "Escolha f(x) = x^2 - 2, raiz √2 ≈1.414, chute inicial x0=2.",
                                    "Implemente bisseção: 20 iterações, registre erros.",
                                    "Rode secante com x0=2, x1=3, compare iterações para 1e-10 precisão.",
                                    "Aplique Newton: calcule iterações, observe aceleração quadrática.",
                                    "Plote curvas de erro e conte iterações totais."
                                  ],
                                  "verification": "Gere gráfico ou tabela mostrando número de iterações: bisseção>secante>Newton.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (NumPy/SciPy) ou MATLAB, Jupyter Notebook.",
                                  "tips": "Use loop while com tolerância 1e-12; log erros para análise.",
                                  "learningObjective": "Demonstrar superioridade prática da convergência quadrática.",
                                  "commonMistakes": "Chutes iniciais ruins causando divergência; arredondamento numérico."
                                }
                              ],
                              "practicalExample": "Resolva f(x) = x^3 - 2x - 5 = 0 (raiz ≈2.094). Bisseção (intervalo [2,3]): ~30 iterações para 1e-10. Secante (2,3): ~8 iterações. Newton (x0=2.1, f'=3x^2-2): ~5 iterações. Erro em Newton cai de 0.01 para 1e-12 em 3 passos.",
                              "finalVerifications": [
                                "Explicar verbalmente por que Newton é mais rápido que bisseção em 2 minutos.",
                                "Preencher tabela comparativa sem consultar notas.",
                                "Implementar código que compara iterações para nova função.",
                                "Identificar cenário onde bisseção é preferível (ex: sem derivada).",
                                "Plotar erros confirmando quadraticidade (curva parabólica em log-log).",
                                "Discutir limitações de Newton em 3 frases."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ordens de convergência (quadrática vs linear).",
                                "Correção em exemplos numéricos (iterações <10% erro).",
                                "Profundidade da tabela comparativa (cobertura de trade-offs).",
                                "Qualidade de gráficos/plots (legendas, escalas log).",
                                "Análise de vantagens contextualizadas (ex: custo derivada).",
                                "Clareza em verificações finais (explicações concisas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de erros em Cálculo Numérico e Séries de Taylor.",
                                "Estatística: Modelagem de erros assintóticos e testes de precisão.",
                                "Engenharia: Otimização em simulações CFD ou controle de sistemas.",
                                "Física: Solução de equações não-lineares em mecânica quântica.",
                                "Machine Learning: Otimizadores como Newton em redes neurais."
                              ],
                              "realWorldApplication": "Em finanças, Newton acelera precificação de opções (equações Black-Scholes); em IA, otimiza funções de perda em treinamento de modelos, reduzindo tempo de convergência de horas para minutos comparado a gradiente descendente (linear)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Método da Secante",
                    "description": "Técnica sem derivadas para encontrar raízes, baseada em interpolação linear e convergência superlinear.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1.1",
                        "name": "Fundamentos e Motivação do Método da Secante",
                        "description": "Compreender a base teórica do método da secante como uma técnica de aproximação de raízes sem o uso de derivadas, utilizando interpolação linear entre dois pontos iniciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1.1",
                            "name": "Diferenciar método da secante do método de Newton-Raphson",
                            "description": "Explicar as semelhanças e diferenças, destacando que o método da secante substitui a derivada por uma aproximação via razão de diferenças finitas, evitando cálculos de derivadas analíticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Newton-Raphson",
                                  "subSteps": [
                                    "Lembre-se da fórmula iterativa: x_{n+1} = x_n - f(x_n) / f'(x_n)",
                                    "Entenda a interpretação geométrica: aproximação linear via tangente na curva f(x)",
                                    "Identifique os requisitos: um ponto inicial x_0 e derivada analítica f'(x)",
                                    "Discuta a ordem de convergência: quadrática sob condições ideais",
                                    "Aplique a um exemplo simples, como f(x) = x² - 2, com x_0 = 1"
                                  ],
                                  "verification": "Reproduza a fórmula corretamente e compute 2-3 iterações manualmente para f(x) = x² - 2",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Gráfico de f(x) = x² - 2"
                                  ],
                                  "tips": [
                                    "Visualize a tangente tocando a curva no ponto atual para melhor compreensão geométrica"
                                  ],
                                  "learningObjective": "Compreender os fundamentos matemáticos e requisitos do método de Newton-Raphson",
                                  "commonMistakes": [
                                    "Confundir com método da bisseção (que não usa derivadas)",
                                    "Esquecer que requer derivada explícita",
                                    "Não considerar condições de convergência como f'(x) ≠ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Método da Secante",
                                  "subSteps": [
                                    "Aprenda a fórmula: x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1}))",
                                    "Interprete geometricamente: aproximação linear via secante entre dois pontos consecutivos",
                                    "Note os requisitos: dois pontos iniciais x_0 e x_1, sem derivada analítica",
                                    "Discuta a ordem de convergência: superlinear, aproximadamente 1.618 (número de ouro)",
                                    "Aplique ao mesmo exemplo f(x) = x² - 2 com x_0 = 1 e x_1 = 1.5"
                                  ],
                                  "verification": "Escreva a fórmula da secante e compute 2-3 iterações para o exemplo dado",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Tabela para registrar iterações"
                                  ],
                                  "tips": [
                                    "A secante é como uma 'tangente aproximada' usando diferenças finitas"
                                  ],
                                  "learningObjective": "Dominar a formulação e interpretação do método da secante",
                                  "commonMistakes": [
                                    "Confundir os índices de x_n e x_{n-1}",
                                    "Dividir por zero se f(x_n) = f(x_{n-1})",
                                    "Escolher pontos iniciais muito próximos causando instabilidade numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar as Fórmulas Matemáticas",
                                  "subSteps": [
                                    "Mostre que a secante aproxima f'(x_n) ≈ [f(x_n) - f(x_{n-1})] / (x_n - x_{n-1})",
                                    "Substitua na fórmula de Newton para derivar a de secante",
                                    "Compare visualmente: tangente (Newton) vs. secante (dois pontos)",
                                    "Calcule numericamente a aproximação da derivada para o exemplo f(x) = x² - 2",
                                    "Registre erros de aproximação em iterações iniciais"
                                  ],
                                  "verification": "Derive a fórmula da secante a partir de Newton e calcule a derivada aproximada com erro < 10%",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para derivação",
                                    "Calculadora gráfica ou software como Python/Desmos"
                                  ],
                                  "tips": [
                                    "Use Δx pequeno mas não zero para boa aproximação da derivada"
                                  ],
                                  "learningObjective": "Reconhecer a relação matemática entre os dois métodos",
                                  "commonMistakes": [
                                    "Ignorar o sinal na diferença finita",
                                    "Não simplificar corretamente a substituição",
                                    "Confundir derivada forward vs. backward"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Semelhanças e Diferenças Qualitativas",
                                  "subSteps": [
                                    "Liste semelhanças: ambos iterativos, convergência rápida, buscam raízes de f(x)=0",
                                    "Destaque diferenças: Newton usa 1 ponto + derivada; secante usa 2 pontos sem derivada",
                                    "Compare custo computacional: Newton requer df/dx; secante apenas 2 avaliações de f",
                                    "Discuta cenários de uso: secante quando derivada desconhecida ou cara",
                                    "Avalie estabilidade: secante mais sensível a pontos iniciais ruins"
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 5 semelhanças/diferenças",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em papel ou Excel",
                                    "Referências teóricas (opcional)"
                                  ],
                                  "tips": [
                                    "Pense em funções black-box onde derivada não está disponível"
                                  ],
                                  "learningObjective": "Diferenciar claramente os métodos em termos práticos e teóricos",
                                  "commonMistakes": [
                                    "Superestimar convergência da secante como quadrática",
                                    "Ignorar que secante pode divergir mais facilmente",
                                    "Confundir com método da falsa posição"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva √2 ≈ raiz de f(x) = x² - 2 = 0. Inicie Newton com x0=1, f'(x)=2x: iterações [1, 1.5, 1.4167, 1.4142]. Secante com x0=1, x1=1.5: [1.5, 1.4167, 1.4142]. Note: secante evitou calcular f'(x)=2x.",
                              "finalVerifications": [
                                "Pode derivar a fórmula da secante a partir de Newton-Raphson?",
                                "Explica corretamente por que secante evita derivadas analíticas?",
                                "Identifica pelo menos 3 semelhanças e 3 diferenças principais?",
                                "Compara número de avaliações de função por iteração?",
                                "Discute cenários onde secante é preferível?",
                                "Reproduz iterações corretas para um exemplo numérico?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática da relação entre métodos (80%+ correto)",
                                "Completude da tabela comparativa (mín. 5 itens por categoria)",
                                "Correção numérica em exemplos (erro < 0.01 na raiz)",
                                "Clareza na explicação verbal de diferenças chave",
                                "Identificação de aplicações práticas sem derivadas",
                                "Análise de convergência e estabilidade"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (derivadas) e análise numérica",
                                "Programação: Implementação em Python (bibliotecas como NumPy/SciPy)",
                                "Física: Modelagem de equações diferenciais sem derivadas analíticas",
                                "Engenharia: Otimização em simulações computacionais",
                                "Estatística: Aproximações em métodos de máxima verossimilhança"
                              ],
                              "realWorldApplication": "Em machine learning, o método da secante é usado em otimizadores como quasi-Newton (ex: Broyden) para gradientes aproximados em funções black-box, evitando derivadas caras em redes neurais profundas ou simulações financeiras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.1.2",
                            "name": "Identificar condições iniciais para aplicação",
                            "description": "Determinar escolhas adequadas de pontos iniciais x0 e x1 para garantir convergência, considerando intervalos onde a função muda de sinal ou é contínua e diferenciável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os pré-requisitos teóricos para convergência do Método da Secante",
                                  "subSteps": [
                                    "Estude o Teorema do Valor Intermediário (TVI): se f contínua em [a,b] e f(a)*f(b)<0, existe raiz em (a,b).",
                                    "Revise condições de convergência: f contínua, f' e f'' existentes e contínuas no intervalo, f'(ξ) ≠ 0 perto da raiz.",
                                    "Entenda que o método da secante requer dois pontos iniciais x0 e x1 próximos da raiz, sem necessariamente mudança de sinal obrigatória como na bissecção.",
                                    "Analise a ordem de convergência superlinear (φ≈1.618).",
                                    "Liste as hipóteses de Banach para teorema de ponto fixo aplicado à secante."
                                  ],
                                  "verification": "Escreva um resumo com os 3 principais teoremas e condições necessárias para convergência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre TVI e derivadas"
                                  ],
                                  "tips": "Compare com método da bissecção: secante não garante contenção da raiz, mas é mais rápida.",
                                  "learningObjective": "Identificar e explicar as condições teóricas essenciais para aplicação do método.",
                                  "commonMistakes": [
                                    "Confundir com bissecção (exigir sempre mudança de sinal)",
                                    "Ignorar f'' contínua",
                                    "Achar que secante requer derivada explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a função para detectar intervalos candidatos com mudança de sinal",
                                  "subSteps": [
                                    "Plote ou tabule f(x) em intervalos amplos para visualizar raízes aproximadas.",
                                    "Calcule f(a) e f(b) para vários [a,b] e identifique onde f(a)*f(b) < 0.",
                                    "Confirme continuidade de f em [a,b] avaliando limites ou domínio.",
                                    "Selecione intervalos estreitos para precisão inicial.",
                                    "Registre pelo menos 2-3 intervalos candidatos."
                                  ],
                                  "verification": "Crie uma tabela com intervalos [a,b], f(a), f(b) e sinal de f(a)*f(b).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB para plotar f(x)",
                                    "Papel milimetrado para esboço gráfico"
                                  ],
                                  "tips": "Comece com intervalos de comprimento 1-2 para eficiência.",
                                  "learningObjective": "Localizar intervalos onde TVI garante existência de raiz.",
                                  "commonMistakes": [
                                    "Escolher intervalos onde f não muda sinal",
                                    "Ignorar descontinuidades",
                                    "Usar pontos muito distantes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar diferenciabilidade e outras condições locais",
                                  "subSteps": [
                                    "Calcule f'(x) e verifique se f'(x) ≠ 0 próximo à raiz estimada.",
                                    "Avalie f''(x) para continuidade no intervalo.",
                                    "Teste se |f(x1) - f(x0)| / |x1 - x0| ≈ |f'(ξ)| ≠ 0 (aproximação de derivada).",
                                    "Confirme que x0 ≠ x1 e f(x0) ≠ f(x1).",
                                    "Use gráfico ou tabela para validar monotonia local."
                                  ],
                                  "verification": "Liste f', f'' e confirme ausência de singularidades no intervalo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software simbólico como SymPy para derivadas",
                                    "Gráficos de f, f' e f''"
                                  ],
                                  "tips": "Se f' muda sinal na raiz, método pode falhar; prefira onde f' monotônica.",
                                  "learningObjective": "Garantir condições de Lipschitz e contratibilidade para convergência.",
                                  "commonMistakes": [
                                    "Não verificar f'(raiz)=0 (multiplicidade alta)",
                                    "Pontos iniciais idênticos",
                                    "Intervalo com plateau (f'=0)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e validar pontos iniciais x0 e x1",
                                  "subSteps": [
                                    "Escolha x0 e x1 no intervalo com mudança de sinal, preferencialmente próximos.",
                                    "Execute 2-3 iterações manuais da secante para checar convergência inicial.",
                                    "Ajuste se iterações divergem (ex: trocar pontos ou estreitar intervalo).",
                                    "Documente razões da escolha (proximidade, sinal oposto).",
                                    "Compare com bissecção para validar."
                                  ],
                                  "verification": "Mostre as primeiras 3 iterações convergindo para a raiz.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou script Python para iterações",
                                    "Função de teste específica"
                                  ],
                                  "tips": "x1 - x0 pequeno acelera, mas muito pequeno causa numérica instável.",
                                  "learningObjective": "Escolher x0, x1 ótimos garantindo convergência rápida.",
                                  "commonMistakes": [
                                    "Pontos muito próximos causando overflow",
                                    "Não testar iterações iniciais",
                                    "Escolha baseada só em gráfico sem cálculo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - 2x - 5, teste [2, 2.5]: f(2) ≈ -1, f(2.5) ≈ 2.625 >0 (muda sinal). f'(x)=3x²-2 >0 em [2,2.5], f''(x)=6x>0 contínua. Escolha x0=2, x1=2.5. Iteração 1: x2 ≈ 2.152 (converge para ≈2.094).",
                              "finalVerifications": [
                                "Explica TVI e por que f(a)*f(b)<0 garante raiz.",
                                "Lista condições: f, f', f'' contínuas e f'(raiz)≠0.",
                                "Identifica corretamente intervalos para função dada.",
                                "Executa 3 iterações iniciais convergentes.",
                                "Justifica escolha de x0/x1 com evidências.",
                                "Compara com método da falsa posição."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de mudança de sinal (100% dos intervalos corretos).",
                                "Correta verificação de diferenciabilidade (sem erros em f'/f'').",
                                "Escolha de x0/x1 levando a convergência em <5 iterações.",
                                "Documentação completa com tabelas/gráficos.",
                                "Explicação clara das condições teóricas.",
                                "Ausência de erros comuns como pontos idênticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo Diferencial e Integral (TVI, derivadas).",
                                "Física: Modelagem numérica de equações não lineares em dinâmica.",
                                "Engenharia: Otimização em estruturas (cargas críticas).",
                                "Estatística: Estimação de parâmetros em regressão não linear."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, determinar velocidades críticas de estol em perfis aerodinâmicos resolvendo f(v)=Cd(v)-Cl(v)*α=0 numericamente, escolhendo v0/v1 baseados em testes de túnel de vento para convergência rápida e precisa."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.1.3",
                            "name": "Reconhecer a interpolação linear subjacente",
                            "description": "Derivar a fórmula da secante a partir da interpolação polinomial de Lagrange de grau 1 entre dois pontos, entendendo como isso aproxima a tangente local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Conceitos Básicos de Interpolação Linear",
                                  "subSteps": [
                                    "Defina interpolação polinomial como uma aproximação de uma função por um polinômio que passa exatamente pelos pontos dados.",
                                    "Explique que para dois pontos (x0, f(x0)) e (x1, f(x1)), o polinômio de grau 1 é a reta secante.",
                                    "Discuta como a interpolação linear é o caso mais simples de aproximação local de funções contínuas.",
                                    "Identifique que ela minimiza o erro em intervalos pequenos."
                                  ],
                                  "verification": "Escreva a equação geral da reta secante entre dois pontos e confirme que passa por ambos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Gráfica de função exemplo (ex: f(x)=x²)"
                                  ],
                                  "tips": "Visualize graficamente: a secante é a linha conectando dois pontos na curva.",
                                  "learningObjective": "Compreender a interpolação linear como base para aproximações numéricas.",
                                  "commonMistakes": [
                                    "Confundir interpolação com regressão (que minimiza erro quadrático)",
                                    "Ignorar que deve passar exatamente pelos pontos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula de Lagrange para Interpolação de Grau 1",
                                  "subSteps": [
                                    "Escreva a forma geral de Lagrange: P(x) = ∑ y_i * l_i(x), onde l_i(x) são as funções base.",
                                    "Para grau 1 (n=1), compute l0(x) = (x - x1)/(x0 - x1) e l1(x) = (x - x0)/(x1 - x0).",
                                    "Simplifique P(x) = f(x0) * (x - x1)/(x0 - x1) + f(x1) * (x - x0)/(x1 - x0).",
                                    "Verifique que P(x0) = f(x0) e P(x1) = f(x1).",
                                    "Reescreva como a fórmula da secante: [f(x1) - f(x0)] / (x1 - x0) * (x - x0) + f(x0)."
                                  ],
                                  "verification": "Derive e simplifique a fórmula de Lagrange grau 1, confirmando igualdade com a equação da reta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como SymPy",
                                    "Folha de derivação"
                                  ],
                                  "tips": "Use notação consistente para x0 e x1 para evitar confusão nos denominadores.",
                                  "learningObjective": "Dominar a derivação explícita da interpolação linear via Lagrange.",
                                  "commonMistakes": [
                                    "Inverter os termos em l_i(x)",
                                    "Esquecer o sinal nos numeradores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conectar a Interpolação Linear ao Método da Secante",
                                  "subSteps": [
                                    "No método da secante, use iterações com x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1})).",
                                    "Reconheça que (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1})) é o inverso da inclinação da secante.",
                                    "Mostre que a fórmula da secante é exatamente P'(x) avaliado em x_n, onde P é a interpolação linear.",
                                    "Derive explicitamente que a atualização é a interseção da secante com o eixo x."
                                  ],
                                  "verification": "Substitua na fórmula da secante e mostre que corresponde à raiz da interpolação linear.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo numérico impresso",
                                    "Software de plotagem como Desmos ou Python/Matplotlib"
                                  ],
                                  "tips": "Pense na secante como aproximando a derivada: inclinação ≈ f'(ξ) para algum ξ no intervalo.",
                                  "learningObjective": "Entender como a secante emerge da interpolação linear no contexto de busca de raízes.",
                                  "commonMistakes": [
                                    "Confundir secante com tangente (que usa derivada exata)",
                                    "Errar o sinal na iteração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a Aproximação à Tangente Local",
                                  "subSteps": [
                                    "Explique que quando x1 → x0, a inclinação da secante tende à derivada f'(x0) (definição de derivada).",
                                    "Discuta o teorema do valor médio: existe ξ tal que inclinação secante = f'(ξ).",
                                    "Compare graficamente: secante vs. tangente em pontos próximos.",
                                    "Avalie o erro de aproximação: O(h) onde h = |x1 - x0|, melhor que bissecção.",
                                    "Conclua que o método da secante usa interpolação para substituir derivada computacionalmente cara."
                                  ],
                                  "verification": "Calcule limite da inclinação secante quando x1 → x0 e mostre igual a f'(x0).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos comparativos",
                                    "Livro de análise numérica (cap. métodos sem derivadas)"
                                  ],
                                  "tips": "Use expansões de Taylor para quantificar o erro: f(x1) ≈ f(x0) + f'(x0)(x1-x0) + O(h²).",
                                  "learningObjective": "Reconhecer a interpolação linear como aproximação à derivada no método da secante.",
                                  "commonMistakes": [
                                    "Achar que secante é exata como tangente",
                                    "Ignorar convergência superlinear da secante"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 2 (raiz ≈1.414), tome x0=1, f(x0)=-1; x1=2, f(x1)=2. Secante: inclinação m=(2-(-1))/(2-1)=3. Equação: y = 3(x-1) -1. Raiz da secante: x2=1 +1/3≈1.333. Próxima iteração aproxima melhor a tangente f'(x)=2x≈2.828 em x≈1.414.",
                              "finalVerifications": [
                                "Derivar corretamente a fórmula de Lagrange grau 1 e mostrá-la equivalente à secante.",
                                "Explicar verbalmente como a secante aproxima a tangente local.",
                                "Aplicar a um exemplo numérico e plotar secante vs. tangente.",
                                "Identificar o papel da interpolação no método da secante.",
                                "Calcular limite da secante para derivada.",
                                "Discutir erro de truncamento qualitativamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (sem erros aritméticos).",
                                "Compreensão conceitual: ligação clara entre Lagrange, secante e derivada.",
                                "Habilidade em aplicar a exemplos concretos com cálculos corretos.",
                                "Análise qualitativa do erro e convergência.",
                                "Visualização gráfica precisa.",
                                "Explicação fluida sem hesitações."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Definição de derivada como limite de secantes.",
                                "Álgebra Linear: Bases de Lagrange como combinação linear.",
                                "Física: Aproximações lineares em dinâmica (método de Euler).",
                                "Machine Learning: Regressão linear local em kernel methods.",
                                "Estatística: Intervalos de confiança via aproximações lineares."
                              ],
                              "realWorldApplication": "No método da secante para resolver equações não-lineares em engenharia (ex: equilíbrio químico, fluxos em CFD), finanças (modelos Black-Scholes implícitos) e machine learning (otimização sem gradientes em redes neurais grandes), onde derivadas analíticas são indisponíveis ou caras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.1.2",
                        "name": "Algoritmo e Iteração do Método",
                        "description": "Dominar o procedimento passo a passo do algoritmo, incluindo critérios de parada e atualização dos pontos de aproximação.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.2.1",
                            "name": "Escrever a fórmula iterativa da secante",
                            "description": "Formular x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1})), explicando cada termo e sua interpretação geométrica como interseção da secante com o eixo x.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os fundamentos do método da secante",
                                  "subSteps": [
                                    "Lembre-se do método de Newton-Raphson e sua dependência na derivada.",
                                    "Entenda que o método da secante aproxima a derivada usando dois pontos: x_n e x_{n-1}.",
                                    "Visualize geometricamente: a secante é a reta que passa por (x_{n-1}, f(x_{n-1})) e (x_n, f(x_n)).",
                                    "Identifique a interseção dessa secante com o eixo x como a próxima aproximação x_{n+1}.",
                                    "Compare com métodos de ponto fixo para contextualizar convergência."
                                  ],
                                  "verification": "Desenhe um gráfico simples mostrando a secante e sua interseção com o eixo x.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Gráfica online como Desmos ou GeoGebra"
                                  ],
                                  "tips": "Comece com uma função simples como f(x) = x^2 - 2 para visualizar.",
                                  "learningObjective": "Compreender a base geométrica e algébrica do método da secante.",
                                  "commonMistakes": [
                                    "Confundir com método da bisseção (que usa intervalos)",
                                    "Ignorar a necessidade de duas aproximações iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula iterativa da secante",
                                  "subSteps": [
                                    "Parta da equação da reta secante: inclinação m = (f(x_n) - f(x_{n-1})) / (x_n - x_{n-1}).",
                                    "Escreva a equação da reta: y - f(x_n) = m (x - x_n).",
                                    "Encontre a interseção com o eixo x (y=0): 0 - f(x_n) = m (x_{n+1} - x_n).",
                                    "Resolva para x_{n+1}: x_{n+1} = x_n - f(x_n) / m.",
                                    "Substitua m para obter: x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1}})."
                                  ],
                                  "verification": "Escreva a derivação completa em um papel e confira com uma referência confiável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para testes numéricos simples"
                                  ],
                                  "tips": "Use álgebra simbólica passo a passo para evitar erros de sinal.",
                                  "learningObjective": "Derivar a fórmula iterativa a partir da geometria da secante.",
                                  "commonMistakes": [
                                    "Erro no sinal da inclinação m",
                                    "Inverter numerador e denominador de m"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar cada termo da fórmula",
                                  "subSteps": [
                                    "x_n: Aproximação atual do zero da função.",
                                    "f(x_n): Valor da função na aproximação atual.",
                                    "x_n - x_{n-1}: Diferença entre aproximações consecutivas (Δx).",
                                    "f(x_n) - f(x_{n-1}): Diferença nos valores da função (Δf).",
                                    "Razão Δx / Δf: Aproximação da derivada inversa f'(x_n)^{-1}.",
                                    "Produto final: Correção aplicada a x_n para obter x_{n+1}."
                                  ],
                                  "verification": "Crie uma tabela explicando cada termo com um exemplo numérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabela"
                                  ],
                                  "tips": "Associe cada termo à sua contraparte no método de Newton (onde Δf / Δx ≈ f').",
                                  "learningObjective": "Interpretar o significado algébrico de cada componente da fórmula.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente a razão como derivada em vez de inversa",
                                    "Esquecer que é uma aproximação finita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar geometricamente e formular a iteração completa",
                                  "subSteps": [
                                    "Desenhe f(x), pontos (x_{n-1}, f(x_{n-1})) e (x_n, f(x_n)).",
                                    "Trace a secante e marque sua interseção com o eixo x como x_{n+1}.",
                                    "Explique como a fórmula captura essa interseção exata.",
                                    "Discuta condições de convergência: f diferenciável, aproximações iniciais próximas.",
                                    "Escreva pseudocódigo para a iteração: while |f(x_n)| > tol { x_{n+1} = ... }."
                                  ],
                                  "verification": "Implemente um ciclo manual com 3 iterações e verifique convergência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (Python/Matplotlib ou Desmos)",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Use cores diferentes no gráfico para secante, tangente (Newton) e eixo x.",
                                  "learningObjective": "Conectar a fórmula à visualização geométrica e preparar para implementação.",
                                  "commonMistakes": [
                                    "Desenhar secante errada (não passando pelos dois pontos)",
                                    "Ignorar divisão por zero se f(x_n) = f(x_{n-1})"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x^2 - 2 (encontrar √2), com x_0 = 1, x_1 = 1.5: x_2 = 1.5 - (1.5^2 - 2)*(1.5-1)/((1.5^2-2)-(1^2-2)) ≈ 1.4167. Repita até |f(x_n)| < 0.001.",
                              "finalVerifications": [
                                "Escrever corretamente a fórmula x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1}}).",
                                "Explicar verbalmente o papel de cada termo em 1 minuto.",
                                "Desenhar diagrama geométrico preciso com secante e interseção.",
                                "Calcular manualmente 2 iterações para f(x) = x^2 - 2 com x_0=1, x_1=2.",
                                "Identificar risco de divisão por zero e como mitigar.",
                                "Comparar convergência com método de Newton em exemplo simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e fórmula (100% correto).",
                                "Clareza na explicação de termos e geometria.",
                                "Profundidade dos subpassos e exemplos práticos.",
                                "Correção nos cálculos numéricos e verificações.",
                                "Criatividade nas conexões geométricas e dicas.",
                                "Completude de todos os campos em steps."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo numérico e análise de erros.",
                                "Ciência da Computação: Implementação em programação numérica (Python/NumPy).",
                                "Física: Resolução de equações não lineares em dinâmica.",
                                "Engenharia: Otimização em simulações de estruturas.",
                                "Estatística: Aproximação de raízes em modelagem probabilística."
                              ],
                              "realWorldApplication": "Usado em softwares de otimização como MATLAB ou SciPy para resolver equações não lineares em finanças (preços de opções), engenharia (fluxo de fluidos) e machine learning (otimização de gradiente sem derivadas explícitas)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2.2",
                            "name": "Implementar o loop iterativo em pseudocódigo",
                            "description": "Construir o algoritmo completo com inicialização, iterações até critério de tolerância (ex: |x_{n+1} - x_n| < ε ou |f(x_{n+1})| < ε) e tratamento de falhas como divisão por zero.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros iniciais e função objetivo",
                                  "subSteps": [
                                    "Especifique a função f(x) a ser resolvida (ex: f(x) = x^3 - 2x - 5).",
                                    "Defina a tolerância ε (ex: 1e-6) e número máximo de iterações (ex: 100).",
                                    "Inicialize duas aproximações iniciais x0 e x1 (ex: x0 = 2, x1 = 3).",
                                    "Declare variáveis auxiliares como iteração = 0 e flag de convergência.",
                                    "Escreva em pseudocódigo: FUNÇÃO f(x) { ... } e ASSIGN ε = ..., max_iter = ...;"
                                  ],
                                  "verification": "Verifique se todas as variáveis estão declaradas corretamente e f(x) é implementada sem erros sintáticos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou papel para pseudocódigo",
                                    "Calculadora para testar f(x) em pontos iniciais"
                                  ],
                                  "tips": "Escolha x0 e x1 próximos da raiz estimada para convergência rápida; teste f(x0) e f(x1) ≠ 0.",
                                  "learningObjective": "Entender a configuração inicial necessária para o método da secante.",
                                  "commonMistakes": [
                                    "Esquecer de definir f(x)",
                                    "Escolher x0 = x1 levando a denom=0 imediato",
                                    "Tolerância ε muito pequena causando loop infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o cabeçalho do loop iterativo",
                                  "subSteps": [
                                    "Defina x_prev = x0 e x_curr = x1.",
                                    "Inicie o loop WHILE com condição: iteração < max_iter AND |x_curr - x_prev| >= ε AND |f(x_curr)| >= ε.",
                                    "Incrementar contador de iterações no início do loop.",
                                    "Escreva: WHILE (iter < max_iter AND ABS(x_curr - x_prev) >= ε AND ABS(f(x_curr)) >= ε) { ... }",
                                    "Adicione incremento: iter = iter + 1;"
                                  ],
                                  "verification": "Simule manualmente 1-2 iterações para confirmar que o loop inicia corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para simulação manual",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": "Use ambos critérios de parada para robustez: diferença entre iterações e valor da função.",
                                  "learningObjective": "Construir a estrutura de controle do loop com critérios de convergência.",
                                  "commonMistakes": [
                                    "Usar apenas um critério de parada",
                                    "Incrementar iteração após o loop",
                                    "Esquecer condição de max_iter"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a nova aproximação dentro do loop",
                                  "subSteps": [
                                    "Calcule denom = f(x_curr) - f(x_prev).",
                                    "Se denom == 0, saia do loop com erro.",
                                    "Calcule x_new = x_curr - f(x_curr) * (x_curr - x_prev) / denom.",
                                    "Atualize x_prev = x_curr e x_curr = x_new.",
                                    "Escreva em pseudocódigo: denom = f(x_curr) - f(x_prev); IF denom == 0 THEN BREAK; x_new = ...;"
                                  ],
                                  "verification": "Execute cálculo manual para uma iteração e confirme x_new.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python para validar fórmula"
                                  ],
                                  "tips": "A fórmula da secante aproxima a derivada; divida por zero é o erro mais comum.",
                                  "learningObjective": "Implementar a fórmula iterativa do método da secante.",
                                  "commonMistakes": [
                                    "Erro na fórmula: confundir ordem de x_curr e x_prev",
                                    "Não atualizar x_prev corretamente",
                                    "Ignorar sinal na subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar tratamento de falhas e saída final",
                                  "subSteps": [
                                    "Após o loop, verifique se convergiu: IF |f(x_curr)| < ε THEN output 'Raiz aproximada: ' + x_curr ELSE 'Não convergiu'.",
                                    "Output número de iterações usadas.",
                                    "Adicione tratamento para max_iter excedido.",
                                    "Escreva: IF ABS(f(x_curr)) < ε THEN PRINT 'Solução: ', x_curr, ' em ', iter, ' iterações' ELSE PRINT 'Falha'.",
                                    "Teste o pseudocódigo completo com valores iniciais."
                                  ],
                                  "verification": "Simule o pseudocódigo inteiro com exemplo e confirme saída correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para trace completo do algoritmo"
                                  ],
                                  "tips": "Sempre inclua output de diagnóstico como iterações para depuração.",
                                  "learningObjective": "Garantir robustez com tratamento de erros e saída clara.",
                                  "commonMistakes": [
                                    "Não tratar não-convergência",
                                    "Output incorreto de variáveis",
                                    "Esquecer reset de flags"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - 2x - 5 = 0, ε=1e-6, x0=2, x1=3:\nINÍCIO\nf(x) = x^3 - 2x - 5\nε = 0.000001; max_iter=100; x_prev=2; x_curr=3; iter=0\nWHILE (iter < 100 AND ABS(x_curr - x_prev) >= ε AND ABS(f(x_curr)) >= ε)\n  iter = iter + 1\n  denom = f(x_curr) - f(x_prev)\n  IF denom == 0 THEN BREAK\n  x_new = x_curr - f(x_curr)*(x_curr - x_prev)/denom\n  x_prev = x_curr\n  x_curr = x_new\nFIM WHILE\nIF ABS(f(x_curr)) < ε THEN PRINT 'Raiz: ', x_curr FIM",
                              "finalVerifications": [
                                "O loop para quando |x_{n+1} - x_n| < ε OU |f(x_{n+1})| < ε.",
                                "Tratamento de denom=0 interrompe iteração sem crash.",
                                "Número máximo de iterações é respeitado.",
                                "Saída inclui raiz aproximada e número de iterações.",
                                "Pseudocódigo é legível e segue sintaxe padrão.",
                                "Teste manual com exemplo converge corretamente."
                              ],
                              "assessmentCriteria": [
                                "Correção da fórmula da secante (peso 30%).",
                                "Critérios de parada duplos e precisos (20%).",
                                "Tratamento robusto de divisão por zero (20%).",
                                "Estrutura clara do pseudocódigo (15%).",
                                "Inicialização e variáveis auxiliares completas (10%).",
                                "Saída informativa com verificação final (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aproximação de derivadas e métodos numéricos para raízes.",
                                "Física: Simulações de equações diferenciais em dinâmica.",
                                "Engenharia: Otimização em controle de sistemas e modelagem.",
                                "Estatística: Solução de equações em regressão não-linear."
                              ],
                              "realWorldApplication": "Implementado em bibliotecas como SciPy (Python) para solvers de raízes em finanças (preços de opções), engenharia (equilíbrios químicos) e machine learning (otimização sem gradientes)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2.3",
                            "name": "Aplicar critérios de parada e detecção de erros",
                            "description": "Definir e justificar critérios como máximo de iterações (ex: 100), tolerância absoluta/relativa e detecção de estagnação ou ciclos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Definir Critérios de Parada Padrão",
                                  "subSteps": [
                                    "Estude os critérios básicos: máximo de iterações (ex: 100), tolerância absoluta (|f(x)| < ε) e tolerância relativa (|x_{n+1} - x_n| / |x_n| < ε).",
                                    "Analise vantagens e desvantagens de cada critério, como prevenção de loops infinitos com max_iter.",
                                    "Escolha valores iniciais apropriados baseados na precisão desejada e custo computacional.",
                                    "Documente as justificativas matemáticas para cada escolha."
                                  ],
                                  "verification": "Liste os critérios definidos com fórmulas e justificativas em um documento ou comentário de código.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Referências: Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Comece com tolerâncias conservadoras (ex: 1e-6) e ajuste baseado em testes preliminares.",
                                  "learningObjective": "Identificar e justificar critérios de parada adequados para convergência numérica.",
                                  "commonMistakes": "Escolher tolerâncias muito pequenas levando a iterações desnecessárias ou overflow numérico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Detecção de Erros: Estagnação e Ciclos",
                                  "subSteps": [
                                    "Defina estagnação: se |x_{n} - x_{n-1}| < δ por k iterações consecutivas (ex: δ=1e-10, k=5).",
                                    "Defina detecção de ciclos: monitore as últimas m aproximações para padrões repetidos (ex: m=10).",
                                    "Implemente contadores e flags no pseudocódigo para rastrear esses eventos.",
                                    "Teste logicamente com cenários hipotéticos de não-convergência."
                                  ],
                                  "verification": "Simule manualmente 3 casos (convergência, estagnação, ciclo) e verifique se a detecção ativa.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Calculadora ou Python REPL para simulações manuais"
                                  ],
                                  "tips": "Use uma lista deslizante para armazenar histórico de iterações e facilitar detecção de ciclos.",
                                  "learningObjective": "Desenvolver mecanismos robustos para identificar falhas de convergência no método iterativo.",
                                  "commonMistakes": "Ignorar flutuações numéricas ao definir estagnação, confundindo com convergência real."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Critérios no Algoritmo da Secante",
                                  "subSteps": [
                                    "Modifique o loop principal do método da secante para checar todos os critérios a cada iteração.",
                                    "Inclua saídas específicas: 'Convergido por tolerância', 'Max iterações', 'Estagnação detectada', etc.",
                                    "Implemente em código Python, com função secante(x0, x1, f, max_iter=100, tol=1e-6).",
                                    "Adicione logging para rastrear iterações e valores."
                                  ],
                                  "verification": "Execute o código com um problema conhecido e confirme que para corretamente com mensagem apropriada.",
                                  "estimatedTime": "90 minutes",
                                  "materials": [
                                    "Python 3+ com NumPy (opcional)",
                                    "IDE como VS Code ou Jupyter Notebook"
                                  ],
                                  "tips": "Estruture o código com funções separadas para cada checagem para facilitar depuração.",
                                  "learningObjective": "Incorporar critérios de parada e erro de forma modular em um algoritmo numérico real.",
                                  "commonMistakes": "Verificar critérios na ordem errada, permitindo overrides inadequados (ex: max_iter antes de tolerância)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Justificar e Analisar o Implementado",
                                  "subSteps": [
                                    "Teste com funções variadas: convergente rápida, lenta, com estagnação e cíclica.",
                                    "Meça desempenho: número de iterações, tempo de execução e precisão final.",
                                    "Justifique escolhas comparando com benchmarks (ex: sem critérios vs. com).",
                                    "Otimize parâmetros baseados em resultados empíricos."
                                  ],
                                  "verification": "Gere relatório com tabelas de resultados para 5 testes diferentes.",
                                  "estimatedTime": "75 minutes",
                                  "materials": [
                                    "Jupyter Notebook para plots e tabelas",
                                    "Funções de teste: f(x)=x^2-2, f(x)=e^x - 3x"
                                  ],
                                  "tips": "Use asserts unitários para validar saídas esperadas em casos edge.",
                                  "learningObjective": "Avaliar e refinar critérios de parada para robustez em cenários reais.",
                                  "commonMistakes": "Não testar casos de falha, assumindo que o algoritmo sempre converge."
                                }
                              ],
                              "practicalExample": "Implemente o método da secante para f(x) = x^3 - 2x - 5 = 0 com x0=2, x1=3. Use max_iter=100, tol_abs=1e-6, tol_rel=1e-8, estagnação δ=1e-10 por 5 iterações. O algoritmo deve convergir em ~8 iterações para x≈2.0946, parando por tolerância absoluta em f(x).",
                              "finalVerifications": [
                                "O algoritmo para dentro de max_iter sem exceder.",
                                "Tolerâncias abs/rel ativam corretamente em convergência.",
                                "Detecção de estagnação/ciclos gera alerta apropriado em testes falhos.",
                                "Precisão final atende especificações (ex: |f(x_final)| < 1e-6).",
                                "Logging registra todos os eventos de parada.",
                                "Código é modular e reutilizável para outras funções.",
                                "Testes cobrem 80% dos cenários edge."
                              ],
                              "assessmentCriteria": [
                                "Justificativas matemáticas claras para cada critério (nota 1-5).",
                                "Implementação correta sem bugs lógicos (nota 1-5).",
                                "Eficiência: iterações mínimas necessárias (nota 1-5).",
                                "Robustez em testes falhos (nota 1-5).",
                                "Clareza do código e documentação (nota 1-5).",
                                "Análise comparativa com baseline (nota 1-5)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Convergência e Análise de Erro Numérico.",
                                "Estatística: Modelos de Incerteza e Intervalos de Confiança em Aproximações.",
                                "Física: Simulações Numéricas em Dinâmica e Equações Diferenciais.",
                                "Engenharia de Software: Design de Algoritmos Robustos e Tratamento de Exceções.",
                                "Economia: Otimização Numérica em Modelos Financeiros."
                              ],
                              "realWorldApplication": "Em machine learning, para otimizar hiperparâmetros via gradiente descendente modificado, evitando iterações infinitas em datasets grandes; ou em engenharia aeroespacial para resolver equações não lineares em simulações de fluxo, garantindo precisão sem sobrecarga computacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.1.3",
                        "name": "Análise de Convergência e Complexidade",
                        "description": "Analisar a ordem de convergência superlinear (aproximadamente 1.618, número de ouro) e a complexidade computacional do método.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.3.1",
                            "name": "Demonstrar a ordem de convergência superlinear",
                            "description": "Provar que a ordem α satisfaz α(α-1) = 1, resultando em α ≈ 1.618, e explicar por que isso é mais lento que quadrático do Newton mas ainda eficiente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição de Ordem de Convergência",
                                  "subSteps": [
                                    "Defina formalmente a ordem de convergência α para uma sequência {x_n} convergindo para raiz r, onde lim_{n→∞} |e_{n+1}| / |e_n|^α = λ > 0, com e_n = x_n - r.",
                                    "Explique o conceito de convergência superlinear (α > 1) e distinga de linear (α = 1) e quadrática (α = 2).",
                                    "Discuta a importância assintótica: como o erro diminui mais rápido para α maiores.",
                                    "Revise exemplos: método de biseção (linear), Newton (quadrático).",
                                    "Prepare anotações para derivação do método da secante."
                                  ],
                                  "verification": "Escreva a definição matemática e dê um exemplo numérico simples confirmando α=2 para Newton.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, notas de análise numérica, calculadora.",
                                  "tips": "Use notação exata para limites; pratique com funções polinomiais simples.",
                                  "learningObjective": "Dominar a definição precisa e sua interpretação assintótica.",
                                  "commonMistakes": "Confundir ordem α com constante de proporcionalidade λ; ignorar o limite assintótico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Relação Assintótica de Erro para o Método da Secante",
                                  "subSteps": [
                                    "Lembre o método da secante: x_{n+1} = x_n - f(x_n) (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1})).",
                                    "Expanda f em série de Taylor ao redor da raiz r: f(x_n) ≈ f'(r) e_n + (f''(r)/2) e_n^2 + O(e_n^3).",
                                    "Derive a aproximação de erro: e_{n+1} ≈ - [f''(r)/(2 f'(r))] e_n e_{n-1} + termos de ordem superior.",
                                    "Assuma comportamento assintótico |e_n| ∼ C μ^n para grandes n, levando à relação para α.",
                                    "Simplifique para obter a equação característica α(α - 1) = 1."
                                  ],
                                  "verification": "Mostre algebricamente que a relação de erro leva a α(α - 1) = 1.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel quadriculado, livro de métodos numéricos (ex: Burden & Faires), software simbólico como SymPy (opcional).",
                                  "tips": "Mantenha termos de ordem superior consistentes; verifique com f''(r) ≠ 0.",
                                  "learningObjective": "Derivar a expansão de erro específica do método da secante.",
                                  "commonMistakes": "Esquecer o fator 1/2 na Taylor de f''; assumir f'(r)=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver a Equação para a Ordem α e Interpretar",
                                  "subSteps": [
                                    "Resolva α(α - 1) = 1 → α^2 - α - 1 = 0 usando fórmula quadrática: α = [1 + √5]/2 ≈ 1.618.",
                                    "Verifique que α ≈ 1.618 é a raiz positiva (descartar negativa).",
                                    "Relacione com o número de ouro φ e propriedades: φ^2 = φ + 1.",
                                    "Calcule numericamente φ ≈ 1.618034 e discuta precisão.",
                                    "Confirme superlinear: 1 < α < 2."
                                  ],
                                  "verification": "Compute α com 5 casas decimais e mostre φ(φ - 1) = 1 numericamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, tabela de raízes quadráticas.",
                                  "tips": "Use √5 ≈ 2.236 para cálculo manual rápido.",
                                  "learningObjective": "Calcular e reconhecer α como número de ouro.",
                                  "commonMistakes": "Escolher raiz negativa; arredondar prematuramente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Método de Newton e Discutir Eficiência",
                                  "subSteps": [
                                    "Recapitule Newton: α=2, e_{n+1} ≈ K e_n^2 (mais rápido).",
                                    "Compare: secante requer duas iterações para simular uma de Newton, mas α≈1.618 ainda superlinear.",
                                    "Discuta custo: secante não precisa f', mas usa mais função evaluations (2 vs 1).",
                                    "Explique eficiência: convergência 'raiz quadrada' de Newton por iteração.",
                                    "Conclua quando usar: sem derivadas disponíveis."
                                  ],
                                  "verification": "Escreva tabela comparativa de α, custo por iteração e aplicações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha ou papel para tabela, exemplos computacionais.",
                                  "tips": "Pense em complexidade total: secante ~1.618^n vs Newton 2^n.",
                                  "learningObjective": "Avaliar trade-offs práticos entre métodos.",
                                  "commonMistakes": "Ignorar custo de avaliações de f; superestimar lentidão da secante."
                                }
                              ],
                              "practicalExample": "Para f(x) = x^2 - 2 (raiz √2 ≈1.414), inicie com x0=1, x1=2. Compute 5 iterações da secante: x2≈1.5, x3≈1.4167, etc. Estime α numericamente via log-log plot de log|e_{n+1}| vs log|e_n|, aproximando inclinação ≈1.618.",
                              "finalVerifications": [
                                "Deriva corretamente e_{n+1} ≈ -[f''(r)/(2f'(r))] e_n e_{n-1}.",
                                "Resolve α^2 - α -1 =0 obtendo α=(1+√5)/2.",
                                "Explica superlinearidade e relação com número de ouro.",
                                "Compara α_secante=1.618 < α_Newton=2, justificando eficiência relativa.",
                                "Fornece exemplo numérico confirmando ordem ≈1.618.",
                                "Discute condições: f'(r)≠0, f''(r)≠0."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de erro (sem erros algébricos).",
                                "Correção no cálculo de α e verificação numérica.",
                                "Clareza na explicação de superlinear vs quadrático.",
                                "Profundidade na comparação de eficiência e custos computacionais.",
                                "Uso correto de notação assintótica e limites.",
                                "Integração de exemplo prático com interpretação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Pura: Equação característica e número de ouro em sequências Fibonacci.",
                                "Física: Métodos numéricos em simulações diferenciais sem derivadas analíticas.",
                                "Engenharia: Otimização em controle de sistemas reais sem modelos exatos.",
                                "Economia/Finanças: Solvers para equações implícitas em precificação de derivativos."
                              ],
                              "realWorldApplication": "No machine learning, o método da secante otimiza hiperparâmetros em redes neurais sem gradientes analíticos explícitos, convergindo eficientemente em cenários de 'caixa-preta' como simulações financeiras ou modelagem climática."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3.2",
                            "name": "Calcular complexidade temporal e espacial",
                            "description": "Avaliar O(n) tempo por iteração (com n iterações até convergência) e O(1) espaço, comparando com métodos que requerem derivadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o pseudocódigo do Método da Secante",
                                  "subSteps": [
                                    "Leia a definição do método da secante para encontrar raízes de f(x)=0 usando aproximações x0 e x1 iniciais.",
                                    "Escreva ou memorize o pseudocódigo: enquanto |x1 - x0| > ε, compute x2 = x1 - f(x1)*(x1 - x0)/(f(x1) - f(x0)), atualize x0 = x1, x1 = x2.",
                                    "Identifique as operações principais: avaliações de f(x), subtrações, multiplicações e divisão.",
                                    "Anote que não há derivadas explícitas, diferentemente do método de Newton.",
                                    "Teste manualmente uma iteração com f(x) = x^2 - 2, x0=1, x1=2."
                                  ],
                                  "verification": "Recite o pseudocódigo e execute uma iteração manual sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo impresso ou digital do método da secante",
                                    "Função teste f(x) = x^2 - 2",
                                    "Calculadora ou papel para cálculos manuais"
                                  ],
                                  "tips": "Visualize o processo como interpolação linear entre pontos (x0, f(x0)) e (x1, f(x1)).",
                                  "learningObjective": "Compreender a estrutura iterativa e operações por iteração do método.",
                                  "commonMistakes": [
                                    "Confundir com método da bissecção (que usa intervalos fechados)",
                                    "Incluir derivadas no pseudocódigo",
                                    "Ignorar a condição de parada |x1 - x0| > ε"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar complexidade temporal por iteração",
                                  "subSteps": [
                                    "Liste todas as operações aritméticas em uma iteração: 2 avaliações f(x) (assumindo O(1) cada), 1 subtração (x1-x0), 1 subtração f(x1)-f(x0), 1 multiplicação, 1 divisão.",
                                    "Conte o número fixo de operações: aproximadamente 6-8 operações básicas, independentemente do input size n.",
                                    "Conclua que por iteração é O(1), pois não depende de n (tamanho do problema).",
                                    "Considere custo de f(x): se f é O(1), total O(1); discuta se f for mais complexa.",
                                    "Registre: O(1) tempo por iteração."
                                  ],
                                  "verification": "Escreva a contagem de operações e justifique O(1) em um papel.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo anotado",
                                    "Tabela para contar operações aritméticas",
                                    "Exemplo de f(x) simples"
                                  ],
                                  "tips": "Ignore constantes; foque em crescimento assintótico com n.",
                                  "learningObjective": "Identificar e contar operações para derivar complexidade temporal unitária.",
                                  "commonMistakes": [
                                    "Contar iterações como parte do tempo por iteração",
                                    "Assumir f(x) como O(n)",
                                    "Confundir com loops aninhados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar complexidade espacial",
                                  "subSteps": [
                                    "Identifique variáveis usadas: x0, x1, x2 (temporária), f_x0, f_x1, ε (constante).",
                                    "Note que todas são escalares (O(1) espaço cada), sem arrays ou estruturas crescendo com n.",
                                    "Confirme ausência de armazenamento de histórico de iterações.",
                                    "Compare com métodos que armazenam gradientes ou hessianas (O(n) ou mais).",
                                    "Conclua O(1) espaço total."
                                  ],
                                  "verification": "Liste todas as variáveis e seu tamanho, somando para O(1).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo",
                                    "Diagrama de memória simples (desenho à mão)"
                                  ],
                                  "tips": "Pense em 'espaço auxiliar' além de input/output.",
                                  "learningObjective": "Avaliar uso de memória estática no algoritmo.",
                                  "commonMistakes": [
                                    "Incluir input size n no espaço (mas secante é para equações escalares)",
                                    "Esquecer variáveis temporárias como f_x1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estimar número de iterações até convergência e complexidade total",
                                  "subSteps": [
                                    "Lembre ordem de convergência φ ≈ 1.618; número de iterações k ≈ log_φ (1/ε) / log_φ (erro inicial).",
                                    "Aproxime como O(log(1/ε)) iterações para precisão ε, mas note descrição como n iterações até convergência.",
                                    "Multiplique: tempo total O(n) onde n = iterações, com O(1) por iteração.",
                                    "Espaço permanece O(1), pois não armazena histórico.",
                                    "Simule numericamente para validar: rode até convergência e conte iterações."
                                  ],
                                  "verification": "Execute simulação e relate número de iterações observadas vs. teórico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Implementação simples em Python ou calculadora",
                                    "Função f(x) = e^x - 3x^2",
                                    "ε = 1e-6"
                                  ],
                                  "tips": "Use log para estimar: k ≈ (ln(erro_inicial/ε)) / ln(φ).",
                                  "learningObjective": "Combinar análise por iteração com contagem total para complexidade global.",
                                  "commonMistakes": [
                                    "Assumir convergência linear O(1/ε)",
                                    "Ignorar dependência logarítmica em ε",
                                    "Confundir n com input size"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar com métodos baseados em derivadas",
                                  "subSteps": [
                                    "Revise Newton-Raphson: cada iteração precisa f(x) e f'(x), ainda O(1) tempo por iteração se f' O(1).",
                                    "Note: secante evita computar/analisar derivadas, útil quando f' desconhecida ou cara.",
                                    "Compare iterações: ambos superlineares, mas secante precisa 2 pontos iniciais.",
                                    "Discuta trade-offs: secante O(1) sem derivadas vs. Newton potencialmente mais rápido mas requer f'.",
                                    "Registre: secante O(n) tempo total, O(1) espaço, similar a Newton sem custo de derivadas."
                                  ],
                                  "verification": "Escreva tabela comparativa de complexidades e trade-offs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigos de secante e Newton",
                                    "Tabela de comparação (Excel ou papel)"
                                  ],
                                  "tips": "Enfatize cenários onde derivadas são impraticáveis (ex: funções black-box).",
                                  "learningObjective": "Contextualizar complexidade relativa a alternativas.",
                                  "commonMistakes": [
                                    "Assumir Newton O(n^2) por derivadas",
                                    "Ignorar que ambos são O(1) por iteração"
                                  ]
                                }
                              ],
                              "practicalExample": "Para encontrar raiz de f(x) = x^2 - 2 ≈1.414 (chute inicial x0=1, x1=2, ε=1e-6): rode 5 iterações (O(1) cada, total ~30 operações aritméticas), use apenas 4 variáveis escalares (O(1) espaço). Compare com Newton: similar iterações mas precisa f'(x)=2x.",
                              "finalVerifications": [
                                "Pode derivar O(1) tempo por iteração listando operações?",
                                "Justifica O(1) espaço identificando variáveis?",
                                "Estima corretamente número de iterações como O(log(1/ε))?",
                                "Calcula tempo total como O(n) com n=iterações?",
                                "Compara precisamente com Newton-Raphson?",
                                "Simula exemplo numérico sem erros?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de operações e notação Big-O",
                                "Justificativas matemáticas claras para convergência",
                                "Correção na análise espacial (sem vazamentos)",
                                "Profundidade na comparação com métodos derivados",
                                "Uso correto de exemplos práticos e simulações",
                                "Clareza e estrutura na tabela comparativa"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Ordem de Convergência",
                                "Física: Simulações Numéricas em Equações Diferenciais",
                                "Engenharia de Software: Otimização em Algoritmos Black-Box",
                                "Economia: Modelos de Otimização Não-Linear sem Gradientes",
                                "Machine Learning: Métodos Sem Derivadas (Zero-Order Optimization)"
                              ],
                              "realWorldApplication": "Em engenharia financeira para resolver equações implícitas em precificação de opções (onde derivadas analíticas são complexas), ou em simulações físicas black-box sem fórmulas derivadas explícitas, economizando tempo de desenvolvimento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3.3",
                            "name": "Resolver exemplo numérico manualmente",
                            "description": "Aplicar o método passo a passo para f(x) = x^2 - 2 com x0=1, x1=2, calculando iterações até precisão de 10^{-4} e analisando erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o problema e calcular valores iniciais",
                                  "subSteps": [
                                    "Escreva a função f(x) = x² - 2 e identifique a raiz aproximada (√2 ≈ 1.414).",
                                    "Defina os pontos iniciais x₀ = 1 e x₁ = 2.",
                                    "Calcule f(x₀) = 1² - 2 = -1 e f(x₁) = 2² - 2 = 2.",
                                    "Estabeleça o critério de parada: |x_{n+1} - x_n| < 10^{-4}.",
                                    "Prepare uma tabela com colunas: n, x_n, f(x_n), x_{n+1}."
                                  ],
                                  "verification": "Tabela inicial preenchida corretamente com x₀, x₁, f(x₀) e f(x₁), sem erros aritméticos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Calculadora científica (opcional para verificação)"
                                  ],
                                  "tips": "Mantenha frações exatas nas divisões para maior precisão inicial.",
                                  "learningObjective": "Compreender o setup do método da secante e preparar dados iniciais.",
                                  "commonMistakes": [
                                    "Usar valores errados para x₀ ou x₁.",
                                    "Confundir f(x) com outra função, como x² + 2."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar as primeiras iterações do método da secante",
                                  "subSteps": [
                                    "Aplique a fórmula: x₂ = x₁ - f(x₁) * (x₁ - x₀) / (f(x₁) - f(x₀)) = 2 - 2*(2-1)/(2 - (-1)) = 2 - 2/3 ≈ 1.6667.",
                                    "Calcule f(x₂) ≈ f(1.6667) = (1.6667)² - 2 ≈ 0.7778.",
                                    "Verifique se |x₂ - x₁| < 10^{-4}; se não, prossiga.",
                                    "Preencha a tabela com x₂ e f(x₂).",
                                    "Calcule x₃ = x₂ - f(x₂) * (x₂ - x₁) / (f(x₂) - f(x₁)) ≈ 1.6667 - 0.7778*(1.6667-2)/(0.7778-2) ≈ 1.6182."
                                  ],
                                  "verification": "Primeiras três aproximações (x₂ e x₃) calculadas corretamente na tabela, com diferenças absolutas registradas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Registre arredondamentos com pelo menos 6 casas decimais para evitar propagação de erros.",
                                  "learningObjective": "Dominar o cálculo iterativo da fórmula da secante.",
                                  "commonMistakes": [
                                    "Erro na fórmula: confundir com método de Newton (divide por f'(x)).",
                                    "Arredondar prematuramente, perdendo precisão."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Continuar iterações até atingir a precisão desejada",
                                  "subSteps": [
                                    "Continue calculando x₄, x₅, etc., usando a fórmula até |x_{n+1} - x_n| < 10^{-4}.",
                                    "Exemplo: prossiga até x₆ ≈ 1.4142, onde a diferença é inferior à tolerância.",
                                    "Registre f(x_n) e a diferença |x_{n+1} - x_n| em cada iteração na tabela.",
                                    "Pare assim que o critério for satisfeito e anote o número de iterações (tipicamente 5-6).",
                                    "Compare com o valor exato √2 ≈ 1.414213562 para validar."
                                  ],
                                  "verification": "Tabela completa com todas iterações até convergência, mostrando a última diferença < 10^{-4}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Calculadora",
                                    "Tabela de √2 para referência"
                                  ],
                                  "tips": "Use notação científica para números pequenos e verifique cálculos cruzando com calculadora.",
                                  "learningObjective": "Aplicar iterações múltiplas e monitorar convergência.",
                                  "commonMistakes": [
                                    "Continuar iterações desnecessárias após convergência.",
                                    "Ignorar sinal dos erros absolutos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar erros e convergência",
                                  "subSteps": [
                                    "Calcule o erro absoluto em cada iteração: e_n = |x_n - √2|.",
                                    "Calcule o erro relativo: e_r,n = |x_n - √2| / |√2|.",
                                    "Observe a ordem de convergência (aproximadamente 1.618, número de ouro para secante).",
                                    "Registre o número total de iterações e compare complexidade com outros métodos.",
                                    "Discuta se a convergência foi quadrática ou superlinear."
                                  ],
                                  "verification": "Gráfico ou tabela de erros mostrando redução progressiva e análise escrita de convergência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel",
                                    "Caneta",
                                    "Valor exato de √2",
                                    "Gráficos simples (opcional)"
                                  ],
                                  "tips": "Plote erros em log-log para visualizar ordem de convergência.",
                                  "learningObjective": "Avaliar precisão e eficiência do método da secante.",
                                  "commonMistakes": [
                                    "Usar erro relativo sem normalizar pelo valor verdadeiro.",
                                    "Confundir ordem de convergência com método de Newton (quadrática)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e complexidade computacional",
                                  "subSteps": [
                                    "Resuma a raiz encontrada (ex: x_final ≈ 1.4142).",
                                    "Calcule custo: número de avaliações de f (2 iniciais + 1 por iteração).",
                                    "Compare com bisseção (mais lento) ou Newton (mais rápido, mas precisa derivada).",
                                    "Discuta limitações: sensibilidade a x₀, x₁ ruins.",
                                    "Conclua sobre aplicabilidade em análise de algoritmos."
                                  ],
                                  "verification": "Relatório curto com raiz, iterações, erros finais e comparação de complexidade.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel",
                                    "Caneta"
                                  ],
                                  "tips": "Enfatize que secante tem complexidade O(n) com n iterações ~ log(precisão).",
                                  "learningObjective": "Conectar cálculo manual à análise teórica de complexidade.",
                                  "commonMistakes": [
                                    "Ignorar custo de avaliações de função em complexidade.",
                                    "Superestimar velocidade sem contar iterações."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva manualmente o método da secante para g(x) = x³ - 2x - 5 = 0 (raiz ≈ 2.0946) com x₀=2, x₁=3, até 10^{-4}, registrando tabela de iterações e erros.",
                              "finalVerifications": [
                                "Raiz aproximada correta dentro de 10^{-4} (≈1.4142).",
                                "Tabela completa com pelo menos 5 iterações e diferenças <10^{-4}.",
                                "Erros absolutos e relativos calculados corretamente.",
                                "Análise de convergência superlinear confirmada.",
                                "Número de iterações e custo computacional registrados."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos manuais (40%).",
                                "Completude da tabela e verificações (20%).",
                                "Análise de erros e convergência (20%).",
                                "Interpretação de complexidade (10%).",
                                "Clareza e organização do trabalho (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo Numérico e Análise de Erros.",
                                "Física: Modelagem de Equações Diferenciais Não-Lineares.",
                                "Engenharia: Otimização em Design Estrutural.",
                                "Estatística: Análise de Sensibilidade Numérica."
                              ],
                              "realWorldApplication": "Aplicado em engenharia para encontrar raízes de equações não-lineares em simulações de fluidos, otimização de estruturas civis e previsão financeira, onde derivadas são caras ou desconhecidas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3.4",
                            "name": "Comparar desempenho com outros métodos numéricos",
                            "description": "Contrastar número de iterações e precisão com bissecção e Newton para funções teste, destacando vantagens em suavidade e custo computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os princípios dos métodos numéricos",
                                  "subSteps": [
                                    "Estude o método da bissecção: entenda que requer derivada não, convergência linear, intervalo inicial.",
                                    "Analise o método de Newton-Raphson: destaque a necessidade de derivada, convergência quadrática.",
                                    "Revise o método da secante: note que aproxima a derivada, ordem de convergência superlinear (≈1.618).",
                                    "Liste métricas chave: número de iterações, precisão (erro absoluto), custo computacional (operações por iteração).",
                                    "Compare teoricamente suavidade: secante não precisa de derivada suave."
                                  ],
                                  "verification": "Resuma em um quadro comparativo as características de cada método.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula, caneta e papel.",
                                  "tips": "Use tabelas para organizar informações teóricas antes de simulações.",
                                  "learningObjective": "Compreender diferenças teóricas para embasar comparações empíricas.",
                                  "commonMistakes": "Confundir ordem de convergência de secante com quadrática de Newton."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e preparar funções teste",
                                  "subSteps": [
                                    "Escolha funções contínuas com raízes conhecidas: ex. f(x)=x²-2 (raiz √2), f(x)=e^x - 3x².",
                                    "Defina intervalos iniciais comuns para bissecção e pontos iniciais para Newton/secante.",
                                    "Estabeleça tolerância de precisão (ex: 10^-6) e máximo de iterações (ex: 100).",
                                    "Prepare planilha ou código para registrar raízes exatas.",
                                    "Teste continuidade e suavidade das funções selecionadas."
                                  ],
                                  "verification": "Liste 3 funções teste com raízes exatas e intervalos/pontos iniciais documentados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, software como MATLAB ou Python (NumPy).",
                                  "tips": "Priorize funções com diferentes graus de suavidade para destacar vantagens da secante.",
                                  "learningObjective": "Preparar cenários realistas para testes comparativos.",
                                  "commonMistakes": "Escolher funções sem raízes reais ou com derivada zero em pontos críticos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar os algoritmos em código",
                                  "subSteps": [
                                    "Codifique o método da bissecção em Python: loop até critério de parada.",
                                    "Implemente Newton-Raphson: inclua função derivada analítica.",
                                    "Desenvolva método da secante: use aproximação de derivada por diferenças finitas.",
                                    "Crie funções genéricas para coletar: iterações, erros por iteração, tempo de CPU.",
                                    "Teste implementações em uma função simples para depuração."
                                  ],
                                  "verification": "Execute código em uma função teste e verifique convergência correta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com bibliotecas NumPy, SciPy, Jupyter Notebook.",
                                  "tips": "Use funções modulares para fácil troca de métodos e funções teste.",
                                  "learningObjective": "Dominar implementação prática para experimentação.",
                                  "commonMistakes": "Erro na atualização de pontos no secante (confundir x0 e x1)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar experimentos e coletar dados",
                                  "subSteps": [
                                    "Rode cada método para todas funções teste, repetindo 5 vezes para médias.",
                                    "Registre: iterações totais, precisão final, tempo computacional, erros intermediários.",
                                    "Varie tolerâncias (10^-4 a 10^-10) para analisar trade-offs.",
                                    "Gere gráficos: iterações vs. precisão, tempo vs. precisão.",
                                    "Salve dados em CSV para análise posterior."
                                  ],
                                  "verification": "Apresente tabela com médias de 3 métricas para cada método/função.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Jupyter Notebook, bibliotecas Pandas e Matplotlib.",
                                  "tips": "Use %timeit no Jupyter para medir custo computacional precisamente.",
                                  "learningObjective": "Coletar dados empíricos robustos para comparação.",
                                  "commonMistakes": "Ignorar variabilidade devido a pontos iniciais sensíveis."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e destacar vantagens",
                                  "subSteps": [
                                    "Compare número de iterações: secante vs. bissecção (mais rápida), vs. Newton (similar).",
                                    "Avalie precisão: destaque convergência superlinear da secante.",
                                    "Analise custo: secante evita derivadas caras, vantajosa em não-suave.",
                                    "Discuta limitações: secante pode divergir sem boas iniciais.",
                                    "Conclua com quadro final de prós/contras."
                                  ],
                                  "verification": "Escreva relatório de 1 página com conclusões baseadas em dados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Pandas para análise estatística.",
                                  "tips": "Use boxplots para visualizar variabilidade entre runs.",
                                  "learningObjective": "Interpretar dados para decisões informadas em escolha de métodos.",
                                  "commonMistakes": "Generalizar resultados de uma função para todas."
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - 2x - 5 (raiz ≈2.0946), com [1.5, 2.5] para bissecção e x0=2, x1=2.1 para secante: bissecção leva ~25 iterações, Newton ~5, secante ~7; secante destaca-se em custo sem derivada explícita.",
                              "finalVerifications": [
                                "Capacidade de gerar quadro comparativo com dados reais de pelo menos 3 funções.",
                                "Explicação verbal das vantagens da secante em suavidade e custo.",
                                "Gráficos corretos de convergência para todos métodos.",
                                "Identificação de cenários onde secante supera Newton (ex: derivada custosa).",
                                "Relatório com conclusões quantitativas (ex: secante 20% mais rápida em média)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos dados coletados (erro <1% em raízes).",
                                "Profundidade da análise comparativa (métricas múltiplas).",
                                "Qualidade dos gráficos e visualizações.",
                                "Correção teórica nas explicações de convergência.",
                                "Clareza no destaque de trade-offs (suavidade vs. custo).",
                                "Robustez: testes com múltiplas runs e funções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de erros e ordem de convergência (cálculo).",
                                "Estatística: Análise de dados experimentais e médias/variâncias.",
                                "Engenharia de Software: Implementação eficiente de algoritmos.",
                                "Física: Modelagem numérica em simulações (ex: equações diferenciais)."
                              ],
                              "realWorldApplication": "Em otimização de machine learning para hiperparâmetros sem gradientes analíticos, ou simulações financeiras onde derivadas são instáveis, reduzindo custo computacional em clusters."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Quadratura Numérica de Gauss",
                    "description": "Métodos avançados de integração numérica com precisão elevada usando polinômios ortogonais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Polinômios Ortogonais",
                        "description": "Fundamentos dos polinômios ortogonais, com ênfase nos polinômios de Legendre, usados na quadratura de Gauss para integração exata de polinômios de grau até 2n-1.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Definir ortogonalidade em espaços de funções",
                            "description": "Explicar o conceito de ortogonalidade no espaço L2[-1,1] e calcular o produto interno de polinômios para verificar ortogonalidade dos polinômios de Legendre.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Ortogonalidade em Espaços Vetoriais Finito-Dimensionais",
                                  "subSteps": [
                                    "Revise o conceito de produto interno em espaços euclidianos: <u,v> = soma u_i v_i",
                                    "Defina vetores ortogonais: dois vetores u e v são ortogonais se <u,v> = 0",
                                    "Explique o que é uma base ortogonal e sua importância para decomposições",
                                    "Discuta ortonormalidade como ortogonalidade com normas unitárias",
                                    "Forneça um exemplo simples em R^2: vetores (1,0) e (0,1)"
                                  ],
                                  "verification": "Escreva a definição de ortogonalidade e dê um exemplo numérico correto em R^2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Caderno para anotações",
                                    "Calculadora básica"
                                  ],
                                  "tips": [
                                    "Visualize ortogonalidade como ângulo de 90 graus entre vetores.",
                                    "Use setas para desenhar vetores no plano."
                                  ],
                                  "learningObjective": "Dominar a noção intuitiva de ortogonalidade antes de generalizar para funções.",
                                  "commonMistakes": [
                                    "Confundir ortogonal com perpendicular apenas em geometria euclidiana.",
                                    "Esquecer que ortogonalidade requer produto interno zero, não soma de produtos zero."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Espaço L²[-1,1] e o Produto Interno para Funções",
                                  "subSteps": [
                                    "Defina o espaço L²[-1,1] como funções f contínuas tais que ∫_{-1}^1 |f(x)|² dx < ∞",
                                    "Estabeleça o produto interno: <f,g> = ∫_{-1}^1 f(x) g(x) dx",
                                    "Defina a norma: ||f|| = sqrt(<f,f>)",
                                    "Explique ortogonalidade funcional: <f,g> = 0 implica f ⊥ g",
                                    "Calcule exemplos simples: <1,1> = ∫_{-1}^1 1 dx = 2"
                                  ],
                                  "verification": "Compute <x,1> = ∫_{-1}^1 x dx e confirme que é zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de cálculo simbólico (ex: Wolfram Alpha ou SymPy)",
                                    "Papel milimetrado",
                                    "Tabela de integrais"
                                  ],
                                  "tips": [
                                    "Pense no produto interno como uma 'projeção média' ao longo do intervalo.",
                                    "Use simetria par/ímpar para integrais rápidas."
                                  ],
                                  "learningObjective": "Generalizar produto interno de vetores discretos para funções contínuas.",
                                  "commonMistakes": [
                                    "Usar limites errados no integral (ex: 0 a 1 em vez de -1 a 1).",
                                    "Confundir L² com L¹ (integral de |f| em vez de |f|²)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Apresentar os Polinômios de Legendre",
                                  "subSteps": [
                                    "Defina P₀(x) = 1, P₁(x) = x, P₂(x) = (3x² - 1)/2",
                                    "Descreva a propriedade de ortogonalidade: ∫_{-1}^1 P_m(x) P_n(x) dx = 0 se m ≠ n",
                                    "Mencione a norma: ∫_{-1}^1 [P_n(x)]² dx = 2/(2n+1)",
                                    "Gere P₃(x) = (5x³ - 3x)/2 usando fórmula recursiva básica",
                                    "Liste os primeiros 4 polinômios em uma tabela"
                                  ],
                                  "verification": "Escreva as fórmulas explícitas de P₀ a P₂ e recite a propriedade de ortogonalidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de polinômios de Legendre (online ou livro)",
                                    "Planilha Excel para tabulação"
                                  ],
                                  "tips": [
                                    "Memorize os primeiros poucos; o resto vem de recursão Rodrigues.",
                                    "Desenhe os polinômios para ver oscilações."
                                  ],
                                  "learningObjective": "Reconhecer polinômios de Legendre como base ortogonal em [-1,1].",
                                  "commonMistakes": [
                                    "Erros nos coeficientes, ex: P₂ como 3x²-1 sem /2.",
                                    "Confundir com Chebyshev ou outros polinômios."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Produto Interno e Verificar Ortogonalidade",
                                  "subSteps": [
                                    "Calcule <P₀, P₁> = ∫_{-1}^1 x dx = [x²/2]_{-1}^1 = 0",
                                    "Calcule <P₀, P₂> = ∫_{-1}^1 (3x²-1)/2 dx = 0 por simetria",
                                    "Compute <P₁, P₂> explicitamente: integre x*(3x²-1)/2",
                                    "Verifique norma de P₀: ∫ 1 dx = 2",
                                    "Discuta implicações para expansão em série de Legendre"
                                  ],
                                  "verification": "Realize dois cálculos de produto interno diferentes e mostre que são zero quando m≠n.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou SymPy/Mathematica",
                                    "Folha de exercícios com integrais"
                                  ],
                                  "tips": [
                                    "Aproveite funções ímpares/par para zeros automáticos.",
                                    "Verifique limites simétricos."
                                  ],
                                  "learningObjective": "Aplicar cálculos para confirmar ortogonalidade empiricamente.",
                                  "commonMistakes": [
                                    "Erros de integração: esquecer fator 1/2 em P₂.",
                                    "Não normalizar o intervalo corretamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Para verificar ortogonalidade de P₀(x)=1 e P₁(x)=x, calcule <P₀,P₁> = ∫_{-1}^1 1·x dx = [x²/2]_{-1}^1 = (1/2 - 1/2) = 0, confirmando que são ortogonais no L²[-1,1].",
                              "finalVerifications": [
                                "Define corretamente ortogonalidade em L²[-1,1].",
                                "Calcula produto interno de funções simples sem erros.",
                                "Lista fórmulas de P₀, P₁, P₂ corretamente.",
                                "Verifica <P₀,P₁>=0 e <P₀,P₂>=0 com cálculo explícito.",
                                "Explica por que Legendre são úteis em quadratura numérica.",
                                "Identifica simetria par/ímpar em cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição exata de L² e produto interno (30%)",
                                "Correção matemática: integrais computados sem erros algébricos (40%)",
                                "Compreensão aplicada: explica zero em produtos cruzados (20%)",
                                "Clareza na comunicação: fórmulas e passos bem estruturados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Expansões em problemas esféricos (equações de Legendre em potencial eletrostático)",
                                "Engenharia: Quadratura Gauss-Legendre para integração numérica em simulações CFD",
                                "Processamento de Sinais: Bases ortogonais para transformadas em análise espectral",
                                "Estatística: Regressão polinomial ortogonal para evitar multicolinearidade"
                              ],
                              "realWorldApplication": "Em computação científica, polinômios de Legendre são cruciais para a quadratura Gauss-Legendre, permitindo integração numérica exata de alta ordem para funções suaves, usada em simulações físicas, otimização e machine learning para aproximações eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Gerar polinômios de Legendre via recursão",
                            "description": "Implementar a relação de recorrência para polinômios de Legendre Pn(x) = [(2n-1)x Pn-1(x) - (n-1) Pn-2(x)] / n e computar os primeiros polinômios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a fórmula de recorrência e os casos base dos polinômios de Legendre",
                                  "subSteps": [
                                    "Memorize os casos base: P₀(x) = 1 e P₁(x) = x.",
                                    "Estude a fórmula de recorrência: Pₙ(x) = [(2n-1)x Pₙ₋₁(x) - (n-1) Pₙ₋₂(x)] / n, para n ≥ 2.",
                                    "Calcule manualmente P₂(x) e P₃(x) simbolicamente para fixar o padrão.",
                                    "Verifique propriedades básicas, como Pₙ(1) = 1 para todos n.",
                                    "Anote exemplos numéricos para x = 0, 1 e 0.5."
                                  ],
                                  "verification": "Capacidade de derivar P₂(x) = (3x² - 1)/2 e P₃(x) = (5x³ - 3x)/2 sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Comece sempre pelos casos base para evitar erros de propagação na recursão.",
                                  "learningObjective": "Entender a estrutura matemática da recorrência e casos iniciais.",
                                  "commonMistakes": [
                                    "Confundir a divisão por n com n no numerador",
                                    "Esquecer os casos base P₀ e P₁",
                                    "Erro no coeficiente (2n-1)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a estrutura da função recursiva",
                                  "subSteps": [
                                    "Defina os parâmetros da função: n (grau) e x (ponto de avaliação).",
                                    "Esboce o diagrama de chamadas recursivas para n=3, mostrando dependência em P₂ e P₁.",
                                    "Decida sobre o tipo de retorno: valor numérico ou polinômio simbólico.",
                                    "Planeje tratamento de condições base: if n==0 return 1; if n==1 return x.",
                                    "Considere memoização para evitar recomputações em chamadas múltiplas."
                                  ],
                                  "verification": "Desenhe um fluxograma ou pseudocódigo que cubra recursão e bases corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para fluxograma",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Use indentação para visualizar a profundidade recursiva e prever stack overflow para n alto.",
                                  "learningObjective": "Planejar lógica recursiva eficiente antes da codificação.",
                                  "commonMistakes": [
                                    "Não tratar n<0 ou n inválido",
                                    "Recursão infinita por falta de bases",
                                    "Ignorar overflow numérico para n grande"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a função recursiva em Python",
                                  "subSteps": [
                                    "Crie uma função def legendre(n, x): com condições base.",
                                    "Implemente a fórmula recursiva: return ((2*n-1)*x * legendre(n-1, x) - (n-1)*legendre(n-2, x)) / n.",
                                    "Adicione validação: if n < 0: raise ValueError.",
                                    "Teste unitário inline: print(legendre(0, 0.5)), etc.",
                                    "Opcionalmente, adicione cache com @lru_cache para otimização."
                                  ],
                                  "verification": "Execute a função para n=0 a 5 e compare com valores conhecidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python 3+ com functools (para lru_cache)",
                                    "Editor como VS Code ou Jupyter Notebook"
                                  ],
                                  "tips": "Use float64 para precisão; teste com x=1 para verificar Pₙ(1)=1.",
                                  "learningObjective": "Codificar recursão funcional e robusta.",
                                  "commonMistakes": [
                                    "Divisão por zero em n=0 (evite chamando recursão)",
                                    "Erro de parênteses na fórmula",
                                    "Não importar functools"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, computar e validar os primeiros polinômios",
                                  "subSteps": [
                                    "Compute P₀ a P₅ para x=0.5 e liste os valores.",
                                    "Compare com fórmulas explícitas: P₂(0.5) ≈ -0.125, P₃(0.5) ≈ -0.4375.",
                                    "Plote os polinômios usando NumPy/Matplotlib para visualização.",
                                    "Verifique ortogonalidade básica: integral aproximada de P_m P_n ≈ 0 para m≠n.",
                                    "Analise desempenho para n=10-20 com e sem memoização."
                                  ],
                                  "verification": "Todos os valores computados coincidem com referências dentro de 1e-10 de erro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Bibliotecas: numpy, matplotlib",
                                    "Jupyter Notebook para plots"
                                  ],
                                  "tips": "Para plots, use np.linspace(-1,1,100) como domínio, pois Legendre são definidos em [-1,1].",
                                  "learningObjective": "Validar implementação através de testes e visualização.",
                                  "commonMistakes": [
                                    "Erro numérico acumulado sem memoização",
                                    "Domínio errado no plot",
                                    "Confundir ordem dos termos na fórmula"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente a função e compute os primeiros 5 polinômios de Legendre em x=0.5: P0=1.0, P1=0.5, P2=-0.125, P3=-0.4375, P4=0.025390625. Plote-os para observar oscilações crescentes.",
                              "finalVerifications": [
                                "P₀(x) = 1 para qualquer x.",
                                "P₁(x) = x.",
                                "P₂(x) = (3x² - 1)/2.",
                                "Pₙ(1) = 1 para n=0 a 5.",
                                "Pₙ(0) alterna corretamente (P_even(0) ≠ 0 apenas para even>0).",
                                "Erro relativo < 1e-12 para n≤10.",
                                "Gráfico mostra n raízes em [-1,1]."
                              ],
                              "assessmentCriteria": [
                                "Correção da recursão e casos base (100% match com valores conhecidos).",
                                "Robustez: trata n inválido sem crash.",
                                "Eficiência: memoização reduz tempo para múltiplas chamadas.",
                                "Precisão numérica mantida para n≤20.",
                                "Código limpo, comentado e com testes inline.",
                                "Visualização clara dos polinômios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Polinômios Ortogonais.",
                                "Física: Mecânica Quântica (funções de Legendre em harmônicos esféricos).",
                                "Engenharia: Simulações Numéricas e Integração em CFD.",
                                "Estatística: Aproximação de funções via séries de Legendre."
                              ],
                              "realWorldApplication": "Esses polinômios são fundamentais na quadratura de Gauss-Legendre para integração numérica precisa em simulações científicas, como previsão climática, processamento de sinais e resolução de equações diferenciais em física computacional."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Calcular raízes dos polinômios de Legendre",
                            "description": "Usar métodos numéricos como Newton-Raphson para encontrar as raízes (nós de Gauss) de polinômios de Legendre de ordem n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar o polinômio de Legendre de ordem n usando recursão",
                                  "subSteps": [
                                    "Estude a fórmula recursiva para polinômios de Legendre: P0(x)=1, P1(x)=x, Pn(x)=( (2n-1)x Pn-1(x) - (n-1) Pn-2(x) ) / n",
                                    "Implemente uma função recursiva ou iterativa em Python para calcular Pn(x) em um ponto x dado",
                                    "Teste para n=0,1,2,3 comparando com valores conhecidos (ex: P2(x)=(3x²-1)/2)",
                                    "Otimize para evitar recursão profunda usando abordagem iterativa",
                                    "Armazene coeficientes do polinômio para avaliação eficiente"
                                  ],
                                  "verification": "Execute a função para n=3 e x=0, deve retornar aproximadamente 0; compare com fórmula explícita",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python ou MATLAB",
                                    "Editor de código (VS Code)",
                                    "Documentação de polinômios de Legendre"
                                  ],
                                  "tips": "Use iteração bottom-up para eficiência e evite recursão infinita",
                                  "learningObjective": "Dominar a geração precisa de Pn(x) para qualquer ordem n",
                                  "commonMistakes": [
                                    "Índices off-by-one na recursão",
                                    "Não normalizar corretamente",
                                    "Confundir Pn com Pn-1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a derivada do polinômio de Legendre Pn'(x)",
                                  "subSteps": [
                                    "Derive a recursão para a derivada: P'n(x) = n / (x²-1) * (x Pn(x) - n Pn-1(x)) ou use diferenciação numérica como fallback",
                                    "Implemente uma função separada para Pn'(x) usando os mesmos coeficientes de Pn(x)",
                                    "Valide computando P2'(x) = 6x e testando em pontos como x=0 (deve ser 0)",
                                    "Integre com a função Pn(x) para formar f(x)=Pn(x) e f'(x)=Pn'(x)",
                                    "Teste precisão com valores analíticos conhecidos para baixas ordens"
                                  ],
                                  "verification": "Para n=2, Pn'(0.5) deve ser 6*0.5=3; compare resultado numérico",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy para testes",
                                    "Folha de papel para derivação manual"
                                  ],
                                  "tips": "Prefira recursão analítica sobre diferenciação finita para precisão",
                                  "learningObjective": "Capacitar o uso de Newton-Raphson requerendo f e f' exatas",
                                  "commonMistakes": [
                                    "Erro na fórmula recursiva da derivada",
                                    "Usar aproximação numérica prematuramente",
                                    "Não tratar n=0 ou n=1 como casos especiais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método Newton-Raphson para encontrar uma raiz",
                                  "subSteps": [
                                    "Defina o iterativo: x_{k+1} = x_k - Pn(x_k)/Pn'(x_k), com tolerância epsilon=1e-12",
                                    "Escolha chute inicial xi no intervalo [-1,1], ex: cos(π*(i+0.25)/(n+0.5)) para i=1..n",
                                    "Implemente loop de iteração com máximo 100 iterações e cheque convergência |Pn(x)|<epsilon",
                                    "Trate Pn'(x)=0 com ajuste de chute ou passo pequeno",
                                    "Teste convergência para n=3 com chute inicial 0.5"
                                  ],
                                  "verification": "Para n=1, converge para x=0 em poucas iterações; logue iterações",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python",
                                    "NumPy para arrays",
                                    "Gráfico de Pn(x) com Matplotlib"
                                  ],
                                  "tips": "Monitore |f(x)| e |delta x| para debug; use chutes Lobatto para robustez",
                                  "learningObjective": "Aplicar Newton-Raphson de forma estável em funções polinomiais",
                                  "commonMistakes": [
                                    "Chute inicial ruim levando a divergência",
                                    "Divisão por zero em Pn'=0",
                                    "Tolerância muito frouxa causando raízes imprecisas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Encontrar todas as raízes e validar para quadratura de Gauss",
                                  "subSteps": [
                                    "Execute Newton-Raphson para n chutes iniciais simétricos em [-1,1]",
                                    "Ordene as raízes e remova duplicatas (devido a simetria)",
                                    "Calcule pesos wi = 2 / ((1-xi²) [Pn'(xi)]² ) para Gauss-Legendre",
                                    "Valide integrando função teste como ∫_{-1}^1 1 dx = 2 com erro <1e-10",
                                    "Compare raízes com valores tabelados para n=5"
                                  ],
                                  "verification": "Para n=2, raízes ≈ ±0.57735; soma de pesos =2",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python completo",
                                    "Tabelas de nós Gauss-Legendre online"
                                  ],
                                  "tips": "Use simetria: se xi é raiz, -xi também; deflação opcional para polinômios altos",
                                  "learningObjective": "Gerar nós completos para quadratura numérica precisa",
                                  "commonMistakes": [
                                    "Não ordenar raízes",
                                    "Erro em fórmula de pesos",
                                    "Falta de simetria causando raízes espúrias"
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=3, gere P3(x)=(5x³-3x)/2. Chutes iniciais: cos(π*1.25/3.5)≈0.8, cos(π*2.25/3.5)≈0. Na iteração Newton, converge para raízes ≈ ±0.7746, 0. Use para integrar f(x)=x² de -1 a 1, resultado exato=2/3.",
                              "finalVerifications": [
                                "Implementação encontra raízes de P5(x) com erro <1e-12 vs tabelas padrão",
                                "Soma de pesos wi = 2 para qualquer n testado",
                                "Integração de polinômios de grau <2n com precisão máquina",
                                "Código roda para n=10 sem overflow ou lentidão",
                                "Raízes estão todas em (-1,1) e ordenadas crescentemente",
                                "Gráfico de Pn(x) mostra zeros nas raízes encontradas"
                              ],
                              "assessmentCriteria": [
                                "Precisão das raízes: erro relativo <1e-10",
                                "Eficiência: convergência em <20 iterações por raiz",
                                "Robustez: funciona para n=1 a 20 sem falhas",
                                "Correção dos pesos: integral de 1 dx =2 exata",
                                "Clareza do código: bem comentado e modular",
                                "Validação: testes unitários passam para casos conhecidos"
                              ],
                              "crossCurricularConnections": [
                                "Física: Nós de Gauss em soluções de equações diferenciais (ex: oscilador harmônico)",
                                "Engenharia: Integração numérica em simulações CFD e FEM",
                                "Matemática Pura: Teoria de polinômios ortogonais e aproximação",
                                "Machine Learning: Quadratura em perda de energia em redes neurais",
                                "Estatística: Integração de densidades em métodos Monte Carlo"
                              ],
                              "realWorldApplication": "Em simulações científicas, como resolver equações de Schrödinger em mecânica quântica ou otimizar integração em finanças quantitativas (preços de opções), onde Gauss-Legendre acelera computações em 10-100x vs trapezoidal."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Fórmula de Quadratura de Gauss",
                        "description": "Formulação da quadratura de Gauss-Legendre para aproximar integrais definidas no intervalo [-1,1] com precisão elevada.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Derivar a fórmula de quadratura de Gauss",
                            "description": "Demonstrar que a soma ∑ wi f(xi) é exata para polinômios de grau ≤ 2n-1, onde xi são raízes de Pn(x) e wi pesos derivados da derivada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Polinômios Ortogonais de Legendre",
                                  "subSteps": [
                                    "Estude a definição de polinômios ortogonais com peso w(x) = 1/√(1-x²) no intervalo [-1,1].",
                                    "Revise as propriedades dos polinômios de Legendre Pn(x), incluindo sua ortogonalidade: ∫_{-1}^1 Pn(x) Pm(x) dx = 0 para n ≠ m.",
                                    "Derive a relação de recorrência para Pn(x): (n+1) Pn+1(x) = (2n+1) x Pn(x) - n Pn-1(x).",
                                    "Identifique as raízes xi de Pn(x) = 0 como nós simétricos em [-1,1].",
                                    "Calcule os números de Christoffel λi = 1 / [Pn'(xi)]² para uso posterior."
                                  ],
                                  "verification": "Resuma as propriedades chave dos polinômios de Legendre em um documento e verifique com fórmulas padrão.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Software SymPy ou Mathematica para polinômios",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Comece com n=1 e n=2 para visualizar raízes explicitamente.",
                                  "learningObjective": "Compreender as bases ortogonais necessárias para quadratura de Gauss.",
                                  "commonMistakes": [
                                    "Confundir peso ortogonal com gaussiano padrão",
                                    "Esquecer normalização dos polinômios Legendre"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Nós e Pesos na Quadratura de Gauss",
                                  "subSteps": [
                                    "Defina os nós xi como as raízes reais distintas de Pn(x) = 0.",
                                    "Introduza a aproximação de integrais: ∫_{-1}^1 f(x) dx ≈ ∑_{i=1}^n wi f(xi).",
                                    "Expresse wi usando a base de Lagrange: wi = ∫_{-1}^1 li(x) dx, onde li(x) = ∏_{j≠i} (x - xj)/(xi - xj).",
                                    "Simplifique wi = 2 / [(1 - xi²) [Pn'(xi)]²] usando propriedades de Legendre.",
                                    "Verifique simetria: wi = w_{n+1-i} devido à simetria dos nós."
                                  ],
                                  "verification": "Calcule wi explicitamente para n=1 e confirme wi=1 para x1=0.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Calculadora simbólica (SymPy)",
                                    "Tabelas de nós e pesos de Gauss",
                                    "Folhas de cálculo"
                                  ],
                                  "tips": "Use resíduos da interpolação para derivar wi mais rapidamente.",
                                  "learningObjective": "Derivar a expressão exata dos pesos wi a partir dos nós.",
                                  "commonMistakes": [
                                    "Erro no denominador de Lagrange",
                                    "Esquecer fator 2 no intervalo [-1,1]"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar Exatidão para Polinômios de Grau ≤ 2n-1",
                                  "subSteps": [
                                    "Considere f(x) polinômio de grau m ≤ 2n-1; escreva f(x) = Pn(x) q(x) + r(x), com deg(r) < n.",
                                    "Mostre que ∫_{-1}^1 f(x) dx = ∫ r(x) dx, pois Pn ortogonal a q(x).",
                                    "A soma de Gauss Q(f) = ∑ wi f(xi) = ∑ wi r(xi), já que Pn(xi)=0.",
                                    "Prove interpolação exata: r(x) interpolado exatamente nos xi por Lagrange, então Q(r) = ∫ r(x) dx.",
                                    "Conclua |∫ f - Q(f)| = 0 para deg(f) ≤ 2n-1."
                                  ],
                                  "verification": "Aplique a prova para f(x)=x^{2n-1} e confirme igualdade.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Proofs de livros como Atkinson 'Numerical Analysis'",
                                    "SymPy para expansão polinomial",
                                    "Quadro branco para diagramas"
                                  ],
                                  "tips": "Visualize com o osculatório: Gauss toca o erro em 2n pontos.",
                                  "learningObjective": "Estabelecer a precisão de ordem 2n da quadratura.",
                                  "commonMistakes": [
                                    "Confundir grau de r(x) com n ao invés de <n",
                                    "Ignorar ortogonalidade integral"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Implementar Numericamente",
                                  "subSteps": [
                                    "Implemente nós e pesos para n=2 usando raízes de P2(x)= (3x²-1)/2.",
                                    "Teste com polinômios conhecidos: ∫ x^3 dx =0, confirme soma wi xi^3 =0.",
                                    "Compare com trapézio ou Simpson para f(x)=1/(1+25x²).",
                                    "Analise erro para grau >2n-1.",
                                    "Gere tabela de wi e xi para n=3."
                                  ],
                                  "verification": "Código Python/SymPy reproduz tabela padrão com erro <1e-10.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Jupyter Notebook",
                                    "Tabelas padrão de Gauss"
                                  ],
                                  "tips": "Use scipy.special.roots_legendre() para validação.",
                                  "learningObjective": "Validar derivação através de experimentação computacional.",
                                  "commonMistakes": [
                                    "Raízes aproximadas imprecisas",
                                    "Escala errada no intervalo [a,b]"
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=2, Pn(x)=(3x²-1)/2=0 dá xi≈±0.57735. Pesos wi=1. Derivação: w1=w2=∫ l1(x) dx=1. Teste: ∫_{-1}^1 x^3 dx=0 ≈ w1 x1^3 + w2 x2^3=0 (exato, grau 3=2*2-1).",
                              "finalVerifications": [
                                "wi derivados corretamente como 2/[(1-xi²)(Pn'(xi))²].",
                                "Prova de exatidão usa decomposição f=Pn q + r com ∫ Pn q=0.",
                                "Teste numérico para n=2 com polinômio grau 3 exato.",
                                "Tabela de nós/pesos bate com referências padrão.",
                                "Erro zero para grau ≤3, não-zero para grau 4 em exemplo."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação de wi (20%).",
                                "Clareza na prova de exatidão via interpolação/ortogonalidade (30%).",
                                "Precisão numérica em implementações (20%).",
                                "Explicação de propriedades únicas de Gauss vs. Newton-Cotes (15%).",
                                "Uso correto de ferramentas simbólicas (10%).",
                                "Análise de erros comuns e limitações (5%)."
                              ],
                              "crossCurrularConnections": [
                                "Física: Integrais em mecânica quântica (equação de Schrödinger).",
                                "Engenharia: Simulações CFD com integrais de alta precisão.",
                                "Estatística: Amostragem importance em Monte Carlo.",
                                "Análise de Algoritmos: Complexidade O(n) vs. precisão exponencial."
                              ],
                              "realWorldApplication": "Usado em solvers de PDEs (ex: FEM em COMSOL), otimização em machine learning (gradientes), simulações financeiras (opções pricing via Black-Scholes integrais), e astronomia (orbits numéricas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Computar pesos de Gauss",
                            "description": "Calcular os pesos wi = 2 / [(1 - xi²) (Pn'(xi))²] para nós xi obtidos das raízes do polinômio de Legendre.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Obter os Nós xi (Raízes do Polinômio de Legendre Pn(x))",
                                  "subSteps": [
                                    "Revise a definição recursiva dos polinômios de Legendre: P0(x)=1, P1(x)=x, Pn+1(x)=(2n+1)/(n+1) x Pn(x) - n/(n+1) Pn-1(x).",
                                    "Escolha um grau n (ex: n=2 ou 3) e compute Pn(x) explicitamente usando recursão ou fórmula conhecida.",
                                    "Encontre as raízes xi de Pn(x)=0 usando método numérico como Newton-Raphson ou bibliotecas como NumPy (roots).",
                                    "Ordene as raízes em ordem crescente: x1 < x2 < ... < xn.",
                                    "Armazene os xi em uma lista ou array para uso posterior."
                                  ],
                                  "verification": "Confirme que Pn(xi)=0 para cada i dentro de tolerância 1e-10 e que há exatamente n raízes reais distintas no [-1,1].",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de código (Python/Jupyter)",
                                    "Biblioteca NumPy ou SciPy para raízes",
                                    "Tabela de polinômios de Legendre conhecidos"
                                  ],
                                  "tips": [
                                    "Comece com n pequeno (2-3) para validação manual.",
                                    "Use np.roots para polinômios explícitos.",
                                    "Evite divisão por zero nas recursões iniciais."
                                  ],
                                  "learningObjective": "Identificar e extrair com precisão as raízes xi do polinômio de Legendre Pn(x).",
                                  "commonMistakes": [
                                    "Confundir polinômios de Legendre com Chebyshev.",
                                    "Não ordenar raízes corretamente.",
                                    "Usar intervalos errados fora de [-1,1]."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Polinômio de Legendre para Obter Pn'(x)",
                                  "subSteps": [
                                    "Use a fórmula recursiva para derivadas: P'n+1(x) = (2n+1) Pn(x) + x P'n(x) - (n+1) P'n-1(x), com P'0=0, P'1=1.",
                                    "Alternativamente, derive Pn(x) explicitamente: Pn'(x) = n/(x²-1) [x Pn(x) - Pn-1(x)].",
                                    "Implemente uma função computacional para Pn'(x) usando recursão ou expansão de série.",
                                    "Teste a derivada em pontos conhecidos, como Pn'(1)=n(n+1)/2.",
                                    "Valide com Pn(x) conhecido para n=2: P2(x)=(3x²-1)/2, P2'(x)=3x."
                                  ],
                                  "verification": "Verifique Pn'(1) == n(n+1)/2 e Pn'(-1) == (-1)^{n+1} n(n+1)/2 com precisão alta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python com funções recursivas",
                                    "Documentação de polinômios ortogonais",
                                    "Calculadora simbólica como SymPy opcional"
                                  ],
                                  "tips": [
                                    "Implemente recursão memoizada para eficiência.",
                                    "Use SymPy para derivada simbólica inicial.",
                                    "Evite loops infinitos em recursão sem base case."
                                  ],
                                  "learningObjective": "Computar corretamente a derivada Pn'(x) do polinômio de Legendre.",
                                  "commonMistakes": [
                                    "Erros no sinal da recursão derivativa.",
                                    "Confundir Pn com Pn-1 na fórmula.",
                                    "Não lidar com n=0 ou 1 como casos base."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Pn'(xi) nos Nós xi",
                                  "subSteps": [
                                    "Para cada nó xi obtido, compute Pn'(xi) usando a função derivada implementada.",
                                    "Armazene os valores em um array deriv_vals[i] = Pn'(xi).",
                                    "Garanta alta precisão numérica (use float64 ou mpmath para precisão arbitrária).",
                                    "Verifique que Pn'(xi) ≠ 0 para todos i (propriedade dos nós de Gauss).",
                                    "Registre valores intermediários para depuração."
                                  ],
                                  "verification": "Todos Pn'(xi) devem ser não-nulos e alternar sinais; compare com valores tabelados para n baixo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Array de xi do Step 1",
                                    "Função Pn' do Step 2",
                                    "Ambiente numérico Python/MATLAB"
                                  ],
                                  "tips": [
                                    "Vetorize a avaliação para eficiência.",
                                    "Use tolerância para checar não-zero (1e-12).",
                                    "Imprima valores para inspeção visual."
                                  ],
                                  "learningObjective": "Avaliar eficientemente Pn'(xi) com precisão numérica adequada.",
                                  "commonMistakes": [
                                    "Perda de precisão perto de singularidades.",
                                    "Índices errados entre xi e deriv_vals.",
                                    "Não vetorizar levando a lentidão."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular os Pesos wi Usando a Fórmula wi = 2 / [(1 - xi²) (Pn'(xi))²]",
                                  "subSteps": [
                                    "Para cada i, compute denom = (1 - xi**2) * (Pn'(xi))**2.",
                                    "Calcule wi = 2 / denom, garantindo denom > 0.",
                                    "Armazene wi em array weights.",
                                    "Some todos wi e verifique se soma ≈ 2 (erro < 1e-10).",
                                    "Ajuste precisão se necessário com refinamento de xi."
                                  ],
                                  "verification": "Soma de wi deve ser exatamente 2 dentro de tolerância; todos wi > 0 e simétricos wi = w_{n+1-i}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arrays xi e deriv_vals",
                                    "Calculadora ou código vetorizado",
                                    "Tabelas de pesos de Gauss conhecidos"
                                  ],
                                  "tips": [
                                    "Use np.divide para evitar divisão por zero.",
                                    "Compare com pesos exatos de literatura.",
                                    "Aplique clipping se denom muito pequeno."
                                  ],
                                  "learningObjective": "Aplicar a fórmula de pesos de Gauss com precisão e validar soma.",
                                  "commonMistakes": [
                                    "Esquecer o quadrado em (Pn'(xi))².",
                                    "Sinais errados em 1 - xi².",
                                    "Não checar soma total de wi."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Testar a Quadratura Completa",
                                  "subSteps": [
                                    "Implemente a quadratura: ∫f ≈ sum wi f(xi).",
                                    "Teste com f(x)=1 (deve dar 2), f(x)=x (deve dar 0 por simetria).",
                                    "Compare com integral analítica de polinômio de grau <2n.",
                                    "Meça erro para função suave como exp(x) em [-1,1].",
                                    "Documente resultados em tabela."
                                  ],
                                  "verification": "Erro de quadratura < 1e-8 para testes; soma wi=2.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código completo de passos anteriores",
                                    "Funções de teste",
                                    "Biblioteca de integração numérica para referência"
                                  ],
                                  "tips": [
                                    "Use funções pares/ímpares para testes rápidos.",
                                    "Plote wi vs xi para visualização.",
                                    "Aumente n para observar convergência."
                                  ],
                                  "learningObjective": "Validar pesos em contexto de quadratura numérica.",
                                  "commonMistakes": [
                                    "Testar só com f=1 sem simetria.",
                                    "Intervalo errado (Gauss é para [-1,1]).",
                                    "Ignorar erros de arredondamento acumulados."
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=2: P2(x)=(3x²-1)/2, raízes xi ≈ [-0.57735, 0.57735]. Pn'(x)=3x, Pn'(xi)≈[-1.732,1.732]. wi=2/[(1-0.577²)(1.732)²]≈1 para ambos. Soma=2. Teste: ∫_{-1}^1 1 dx = 2.",
                              "finalVerifications": [
                                "Soma de todos wi exatamente igual a 2 (tolerância 1e-12).",
                                "Todos wi positivos e simétricos: wi = w_{n+1-i}.",
                                "Pn'(xi) alterna sinais e não-zero.",
                                "Quadratura exata para polinômios de grau até 2n-1.",
                                "Erro em teste com exp(x): <1e-10.",
                                "Raízes xi em [-1,1] e Pn(xi)=0."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos xi e Pn'(xi) comparada a valores tabelados (erro <1e-10).",
                                "Correção da implementação da derivada (teste em x=1).",
                                "Soma wi =2 e simetria.",
                                "Eficiência computacional (tempo <1s para n=10).",
                                "Validação com pelo menos 3 testes de quadratura.",
                                "Código limpo com comentários e vetoração."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e polinômios ortogonais.",
                                "Física: Integrais em mecânica quântica e eletromagnetismo.",
                                "Engenharia: Simulações CFD e processamento de sinais.",
                                "Estatística: Integração de densidades de probabilidade."
                              ],
                              "realWorldApplication": "Usado em simulações numéricas de alta precisão, como integração em equações diferenciais de engenharia aeroespacial, modelagem financeira de opções (Black-Scholes PDE) e processamento de imagens médicas via transformadas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Transformar integrais para [-1,1]",
                            "description": "Aplicar a mudança de variável para mapear integrais em [a,b] para o intervalo padrão [-1,1] usando t = (b-a)/2 * x + (a+b)/2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Motivação para a Transformação de Intervalo",
                                  "subSteps": [
                                    "Revise integrais definidas em intervalos arbitrários [a, b] e explique por que a quadratura de Gauss usa [-1, 1].",
                                    "Identifique limitações de métodos numéricos padronizados em intervalos não padrão.",
                                    "Discuta vantagens da padronização: simetria, tabelas pré-computadas de nós e pesos.",
                                    "Esboce um integral genérico ∫_a^b f(t) dt e anote o objetivo de mapear para x ∈ [-1, 1].",
                                    "Pesquise brevemente a história da quadratura de Gauss para contextualizar."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que transformar para [-1,1] é essencial na quadratura numérica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno ou editor de texto",
                                    "Referência rápida sobre quadratura de Gauss (PDF ou wiki)"
                                  ],
                                  "tips": "Visualize graficamente o mapeamento linear de [a,b] para [-1,1] para intuitivamente entender a compressão/expansão.",
                                  "learningObjective": "Compreender a necessidade prática da transformação de intervalo em métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir o intervalo de destino [-1,1] com o de origem [a,b]",
                                    "Ignorar o impacto no erro numérico sem padronização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Transformação Linear de Variável",
                                  "subSteps": [
                                    "Defina a transformação afim: t = α x + β, onde x ∈ [-1,1] e t ∈ [a,b].",
                                    "Resolva para α e β impondo condições de fronteira: quando x=-1, t=a; x=1, t=b.",
                                    "Calcule α = (b - a)/2 e β = (a + b)/2.",
                                    "Verifique a transformação invertida: x = (2t - (a+b))/(b-a).",
                                    "Esboce a reta de mapeamento e teste com valores numéricos simples (ex: a=0, b=2)."
                                  ],
                                  "verification": "Derive e escreva a fórmula t = ((b-a)/2) x + (a+b)/2 corretamente, com verificação para x=-1 e x=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Papel para derivação"
                                  ],
                                  "tips": "Lembre-se: é uma homografia linear simples; pense em escalonamento e translação.",
                                  "learningObjective": "Derivar a fórmula de mapeamento linear de [a,b] para [-1,1].",
                                  "commonMistakes": [
                                    "Erro no sinal de α (deve ser positivo para a < b)",
                                    "Confundir α e β na fórmula final"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Jacobiano e Fator de Escala dt",
                                  "subSteps": [
                                    "Compute a derivada dt/dx = α = (b - a)/2.",
                                    "Explique que na mudança de variável, ∫ f(t) dt = ∫ f(t(x)) |dt/dx| dx.",
                                    "Confirme que |dt/dx| é constante e positivo para a < b.",
                                    "Anote a integral transformada: ∫_{-1}^1 f(t(x)) * ((b-a)/2) dx.",
                                    "Teste com função constante para verificar preservação do valor integral."
                                  ],
                                  "verification": "Mostre que dt = ((b-a)/2) dx e aplique em uma integral simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de cálculo diferencial online ou livro de cálculo"
                                  ],
                                  "tips": "O fator ((b-a)/2) é o 'comprimento médio' do intervalo dividido por 2.",
                                  "learningObjective": "Aplicar corretamente o teorema de substituição em integrais definidas.",
                                  "commonMistakes": [
                                    "Esquecer o |dt/dx| ou usar dx em vez de dt",
                                    "Negligenciar o sinal absoluto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Transformação Completa em uma Integral",
                                  "subSteps": [
                                    "Escolha f(t), intervalos [a,b]; substitua t(x) na função.",
                                    "Multiplique pelo fator ((b-a)/2).",
                                    "Reescreva a integral em termos de x: ((b-a)/2) ∫_{-1}^1 f(((b-a)/2)x + (a+b)/2) dx.",
                                    "Implemente em código ou calcule manualmente para verificar.",
                                    "Compare numericamente com integral direta para validar."
                                  ],
                                  "verification": "Transforme ∫_0^1 t^2 dt para [-1,1] e confirme o resultado 1/3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/Jupyter com NumPy/SciPy para verificação numérica"
                                  ],
                                  "tips": "Automatize com função: def transform_integral(a, b, f): ...",
                                  "learningObjective": "Executar a transformação end-to-end para qualquer integral [a,b].",
                                  "commonMistakes": [
                                    "Substituir incorretamente t(x) na função f",
                                    "Esquecer o fator de escala na integral final"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Praticar com Exemplos Numéricos",
                                  "subSteps": [
                                    "Resolva 3 exemplos variados: linear, quadrática, exponencial.",
                                    "Use quadratura de Gauss básica (2-3 pontos) pós-transformação.",
                                    "Compare erro com método trapezoidal no intervalo original.",
                                    "Gere gráfico do mapeamento e função transformada.",
                                    "Documente casos edge: a=b, a> b."
                                  ],
                                  "verification": "Calcule 2 integrais transformadas com erro < 1e-6 vs exato.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python pronto para Gauss-Legendre",
                                    "Gráficos via Matplotlib"
                                  ],
                                  "tips": "Sempre normalize funções para evitar overflow em domínios grandes.",
                                  "learningObjective": "Ganhar proficiência prática na transformação para uso em algoritmos numéricos.",
                                  "commonMistakes": [
                                    "Não testar fronteiras x=±1",
                                    "Ignorar precisão numérica em fatores de escala"
                                  ]
                                }
                              ],
                              "practicalExample": "Para ∫_0^π sin(t) dt = 2, aplique transformação: t = (π/2)x + π/2, dt = (π/2)dx. Torna-se (π/2) ∫_{-1}^1 sin((π/2)x + π/2) dx = (π/2) ∫_{-1}^1 cos((π/2)x) dx, que pode ser aproximada com Gauss em [-1,1].",
                              "finalVerifications": [
                                "Derive corretamente t(x) e dt/dx para qualquer [a,b].",
                                "Transforme uma integral dada sem erros aritméticos.",
                                "Implemente em código e valide contra valor exato.",
                                "Explique o papel na quadratura de Gauss.",
                                "Identifique e corrija erros comuns em exemplos dados.",
                                "Aplique a 3 intervalos diferentes com sucesso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (100% correto).",
                                "Correta inclusão do fator de escala em todas transformações.",
                                "Validação numérica com erro relativo < 0.1%.",
                                "Clareza na explicação escrita/oral da motivação.",
                                "Proficiência em código para automação.",
                                "Tratamento de casos especiais (a=b, funções singulares)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mudanças de coordenadas em mecânica (ex: de laboratório para comóvel).",
                                "Programação: Normalização de dados em ML (min-max scaling para [-1,1]).",
                                "Estatística: Padronização de variáveis em simulações Monte Carlo.",
                                "Engenharia: Integração numérica em simulações CFD/FEM."
                              ],
                              "realWorldApplication": "Em computação científica, essa transformação permite usar tabelas pré-calculadas de nós/pesos de Gauss-Legendre em bibliotecas como SciPy/NumPy para integrais em qualquer [a,b], acelerando simulações em física computacional, finanças (opções pricing) e machine learning (integração em loss functions)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Implementação e Análise de Complexidade",
                        "description": "Implementação computacional da quadratura de Gauss e análise de sua complexidade em termos de precisão e custo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Implementar quadratura de Gauss em código",
                            "description": "Escrever um programa em pseudocódigo ou Python para calcular nós e pesos de Gauss até ordem n e aproximar uma integral numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Quadratura de Gauss",
                                  "subSteps": [
                                    "Estude a definição de quadratura de Gauss e sua base em polinômios ortogonais de Legendre.",
                                    "Revise como os nós são as raízes dos polinômios de Legendre de grau n+1.",
                                    "Entenda o cálculo dos pesos usando derivadas dos polinômios de Legendre.",
                                    "Analise a fórmula de integração: ∫f(x)dx ≈ Σ w_i * f(x_i).",
                                    "Identifique limitações, como precisão exata para polinômios até grau 2n-1."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e liste 3 exemplos de funções integráveis exatamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de quadratura de Gauss (Wikipedia ou livro de análise numérica)",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use visualizações de polinômios de Legendre para melhor compreensão intuitiva.",
                                  "learningObjective": "Compreender a teoria subjacente para implementação precisa.",
                                  "commonMistakes": [
                                    "Confundir nós com coeficientes de Gauss-Legendre pré-computados",
                                    "Ignorar o intervalo padrão [-1,1] e transformações para outros intervalos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Cálculo de Nós (Raízes de Legendre)",
                                  "subSteps": [
                                    "Defina uma função recursiva para gerar polinômios de Legendre: P_0=1, P_1=x, P_{k}=( (2k-1)x P_{k-1} - (k-1) P_{k-2} ) / k.",
                                    "Implemente um método numérico para encontrar raízes, como Newton-Raphson ou bissecção refinada.",
                                    "Inicialize raízes com estimativas equidistantes no [-1,1] e refine iterativamente.",
                                    "Teste para n=2: nós devem ser ≈ ±0.57735.",
                                    "Armazene nós em uma lista ou array ordenado."
                                  ],
                                  "verification": "Execute para n=3 e verifique se nós aproximam √(3/7)±√(6/5)/3 e outros valores conhecidos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy e SciPy para testes",
                                    "Código base de polinômios recursivos"
                                  ],
                                  "tips": "Use tolerância de 1e-12 para convergência em Newton-Raphson para evitar loops infinitos.",
                                  "learningObjective": "Desenvolver algoritmo para computar nós dinamicamente sem tabelas pré-definidas.",
                                  "commonMistakes": [
                                    "Não ordenar nós crescentes",
                                    "Erro na recursão de Legendre levando a instabilidade numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Cálculo de Pesos",
                                  "subSteps": [
                                    "Para cada nó x_i, calcule o peso w_i = 2 / ( (1 - x_i²) * (P'_n(x_i))² ).",
                                    "Implemente derivada do polinômio de Legendre usando recursão diferenciada ou diferenciação numérica.",
                                    "Some todos os pesos e verifique se aproximam 2 (para intervalo [-1,1]).",
                                    "Teste para n=1: peso único ≈ 2.",
                                    "Integre nós e pesos em uma estrutura de dados (dict ou listas paralelas)."
                                  ],
                                  "verification": "Para n=2, pesos devem ser ambos ≈1; soma total=2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 2",
                                    "Função de teste para integral de 1 dx = 2"
                                  ],
                                  "tips": "Evite divisão por zero computando derivada analiticamente para precisão.",
                                  "learningObjective": "Calcular pesos corretamente para garantir precisão da quadratura.",
                                  "commonMistakes": [
                                    "Esquecer o quadrado na derivada",
                                    "Não normalizar para intervalo correto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Função de Integração e Testes",
                                  "subSteps": [
                                    "Crie função gauss_quad(f, a, b, n) que mapeia [a,b] para [-1,1] via t = (b-a)/2 * x + (a+b)/2.",
                                    "Aproxime integral como (b-a)/2 * Σ w_i * f(t_i).",
                                    "Teste com f(x)=1 (integral exata b-a), f(x)=x, f(x)=x².",
                                    "Compare com integral analítica e meça erro relativo.",
                                    "Adicione análise de complexidade: O(n²) devido a raízes."
                                  ],
                                  "verification": "Erro <1e-10 para polinômios de grau <2n em testes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SciPy.integrate.quad para benchmark",
                                    "Funções teste variadas"
                                  ],
                                  "tips": "Vectorize com NumPy para eficiência em alto n.",
                                  "learningObjective": "Aplicar quadratura em intervalos arbitrários com validação.",
                                  "commonMistakes": [
                                    "Erro na transformação linear de intervalo",
                                    "Não escalar pesos corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar, Analisar e Documentar",
                                  "subSteps": [
                                    "Otimize para n até 20, monitorando tempo e precisão.",
                                    "Analise complexidade: tempo O(n²), espaço O(n).",
                                    "Adicione docstrings e comentários explicativos.",
                                    "Crie gráfico de erro vs. n para função não-polinomial como exp(x).",
                                    "Compare com método trapezoidal para demonstrar superioridade."
                                  ],
                                  "verification": "Código documentado roda para n=10 em <1s com erro <1e-12 em testes padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "timeit para profiling"
                                  ],
                                  "tips": "Use caching de nós/pesos para múltiplas integrações.",
                                  "learningObjective": "Garantir código robusto, eficiente e bem documentado.",
                                  "commonMistakes": [
                                    "Instabilidade numérica em alto n sem refinamento",
                                    "Falta de handling de n=0 ou n=1"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente a quadratura para aproximar ∫_0^π sin(x) dx (exata=2). Para n=3, espere erro <1e-8. Código Python: def gauss_quad(f, a, b, n): ... print(gauss_quad(np.sin, 0, np.pi, 3))",
                              "finalVerifications": [
                                "Código computa nós e pesos corretamente para n=1 a 5 comparado a valores tabelados.",
                                "Integração de funções polinomiais tem erro máquina.",
                                "Soma de pesos escalados equals (b-a).",
                                "Executa sem erros para n até 20.",
                                "Documentação cobre uso, limitações e complexidade.",
                                "Testes unitários passam com assert erro <1e-10."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro relativo <1e-10 para testes padrão.",
                                "Eficiência: Tempo O(n²) demonstrado.",
                                "Corretude: Nós/pesos matching literatura.",
                                "Robustez: Trata intervalos [a,b], n>=1, funções suaves.",
                                "Clareza: Código legível com comentários.",
                                "Análise: Inclui complexidade e comparação com outros métodos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Equações Diferenciais (métodos espectrais).",
                                "Física: Simulações em Mecânica Quântica (integrais em Schrödinger).",
                                "Engenharia: Otimização e Controle (integração em simulações dinâmicas).",
                                "Finanças: Precificação de derivativos (integrais de risco)."
                              ],
                              "realWorldApplication": "Usado em simulações científicas como previsão climática (integrais em modelos PDE), processamento de imagens (transformadas), e machine learning (kernel methods com integrais normalizadoras), onde alta precisão com poucos pontos reduz custo computacional."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Analisar erro e precisão da quadratura",
                            "description": "Estimar o erro de truncamento da quadratura de Gauss para funções suaves e comparar com métodos como trapézio ou Simpson.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Erro de Truncamento na Quadratura de Gauss",
                                  "subSteps": [
                                    "Revise a definição da quadratura de Gauss-Legendre e seus nós/pesos para funções suaves em intervalos finitos.",
                                    "Diferencie erro de truncamento (devido à aproximação polinomial) de erro de arredondamento (devido à precisão finita).",
                                    "Estude a fórmula de erro: para n pontos, |E| ≤ (b-a)^{2n+1} (2n)! / ( (2n+1) [(2n)!]^3 ) * max |f^{(2n)}(ξ)|.",
                                    "Identifique condições para funções suaves (analíticas ou C^{2n}).",
                                    "Examine exemplos onde Gauss é exato para polinômios de grau < 2n."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula de erro e dê um exemplo onde ela se aplica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre quadratura",
                                    "Tabela de nós/pesos de Gauss"
                                  ],
                                  "tips": "Sempre transforme o intervalo para [-1,1] para usar Gauss-Legendre padrão.",
                                  "learningObjective": "Dominar a origem e a expressão analítica do erro de truncamento na quadratura de Gauss.",
                                  "commonMistakes": [
                                    "Confundir grau de exatidão (2n-1) com ordem de erro (2n)",
                                    "Ignorar a dependência em derivadas altas da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estimar o Erro Analiticamente para Funções Suaves",
                                  "subSteps": [
                                    "Escolha uma função suave teste, como f(x) = exp(-x^2), e compute suas derivadas até ordem 2n.",
                                    "Aplique a fórmula de erro para estimar o bound superior para um n específico (ex: n=3).",
                                    "Calcule o valor exato da integral (se possível) ou use software simbólico para referência.",
                                    "Compare o bound estimado com o erro real esperado.",
                                    "Analise como o erro diminui com n crescente."
                                  ],
                                  "verification": "Forneça cálculo escrito do bound de erro para f(x) = exp(-x^2) em [-1,1] com n=2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Papel e lápis para derivadas",
                                    "Referência de bounds de derivadas"
                                  ],
                                  "tips": "Use desigualdades como |f^{(k)}(x)| ≤ M para simplificar bounds.",
                                  "learningObjective": "Aplicar fórmulas analíticas para prever precisão sem computação numérica.",
                                  "commonMistakes": [
                                    "Subestimar max |f^{(2n)}| levando a bounds irrealistas",
                                    "Esquecer fator de normalização do intervalo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Computacionalmente a Quadratura e Medir Erros",
                                  "subSteps": [
                                    "Implemente código para quadratura de Gauss (use bibliotecas como numpy/scipy para nós/pesos).",
                                    "Code métodos de trapézio composto e Simpson 3/8 para mesma função e intervalos equivalentes.",
                                    "Execute para vários n/m (número de pontos/subintervalos) e compute erros absolutos vs valor exato.",
                                    "Gere gráficos de log(erros) vs log(n) para visualizar ordens de convergência.",
                                    "Registre tempos de execução para análise de eficiência."
                                  ],
                                  "verification": "Execute código e mostre tabela/gráfico de erros para pelo menos 5 valores de n.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib",
                                    "Jupyter Notebook",
                                    "Função teste pré-definida"
                                  ],
                                  "tips": "Use valor exato conhecido (ex: erf para Gaussian) para benchmark preciso.",
                                  "learningObjective": "Medir empiricamente erros e validar estimativas analíticas via código.",
                                  "commonMistakes": [
                                    "Não equivaler número de avaliações entre métodos",
                                    "Ignorar erros de arredondamento em alta precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Precisão e Analisar Resultados",
                                  "subSteps": [
                                    "Compare erros de Gauss vs trapézio/Simpson em tabelas e gráficos para mesmo custo computacional.",
                                    "Calcule ordens de convergência: slope de log(erros) vs log(1/n).",
                                    "Discuta vantagens de Gauss para funções suaves (ordem 2n vs 2/4).",
                                    "Avalie impacto de suavidade: teste com função não-suave e observe degradação.",
                                    "Conclua sobre quando usar Gauss em aplicações reais."
                                  ],
                                  "verification": "Produza relatório curto com tabelas/gráficos e conclusões comparativas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Resultados do Step 3",
                                    "Ferramentas de plotagem",
                                    "Template de relatório"
                                  ],
                                  "tips": "Normalize por custo: Gauss n pontos ~ trapézio h= (b-a)/n.",
                                  "learningObjective": "Interpretar dados numéricos para justificar escolhas de método.",
                                  "commonMistakes": [
                                    "Comparar inadequadamente (ex: Gauss 3 pts vs trap 3 intervalos)",
                                    "Atribuir tudo a truncamento ignorando arredondamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Integre f(x) = exp(-x^2) de -1 a 1 (valor exato ≈ 1.493648265624854). Use Gauss com n=3 (erro ~1e-7), trapézio com 3 intervalos (erro ~1e-2), Simpson com 3 intervalos (erro ~1e-4). Plote erros vs n para mostrar superioridade de Gauss.",
                              "finalVerifications": [
                                "Estime analiticamente o erro para Gauss n=4 em f(x)=sin(x) [0,π].",
                                "Implemente código que outputa tabela de erros para Gauss, trapézio e Simpson.",
                                "Gere gráfico de convergência confirmando ordem ~2n para Gauss.",
                                "Explique verbalmente por que Gauss supera Simpson para funções suaves.",
                                "Teste com f(x)=1/sqrt(|x|) (não-suave) e discuta falha do bound.",
                                "Compare tempos de execução para n=10 equivalentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa analítica (bound dentro de fator 10 do real).",
                                "Correção da implementação numérica (erros coincidem com literatura).",
                                "Qualidade de gráficos/tabelas (legendas, escalas log, clareza).",
                                "Análise comparativa profunda (ordens, eficiência, limitações).",
                                "Uso correto de conceitos (suavidade, truncamento vs arredondamento).",
                                "Relatório estruturado e conciso."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise real (derivadas de ordem alta, restos de Taylor).",
                                "Física: Integração em simulações de mecânica quântica (orbitais Gaussianos).",
                                "Engenharia: Cálculo de áreas/volumes em CAD/CFD com precisão alta.",
                                "Estatística: Computação de expectativas em distribuições contínuas.",
                                "Machine Learning: Integração em perda de energia ou kernels RBF."
                              ],
                              "realWorldApplication": "Em computação científica para integrar funções sem antiderivada analítica, como em simulações climáticas (fluxos de calor), finanças (opções exóticas) ou ML (normalização de probabilidades), onde Gauss oferece precisão exponencialmente superior com poucos pontos, otimizando tempo em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Avaliar complexidade computacional",
                            "description": "Determinar a complexidade O(n²) para computar nós e pesos via recursão e avaliação da quadratura O(n) por integral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Quadratura Numérica de Gauss",
                                  "subSteps": [
                                    "Estude a definição de quadratura de Gauss e sua fórmula geral para aproximação de integrais.",
                                    "Identifique os componentes chave: nós (roots dos polinômios de Legendre) e pesos (pesos de Gauss).",
                                    "Revise o método recursivo para computar nós e pesos usando polinômios ortogonais.",
                                    "Entenda a avaliação da integral como soma ponderada: ∫f(x)dx ≈ Σ w_i f(x_i).",
                                    "Anote a dependência em n, o número de pontos de Gauss."
                                  ],
                                  "verification": "Resuma em um diagrama os passos para computar nós/pesos e avaliar a integral.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação sobre polinômios de Legendre",
                                    "Notebook Jupyter para anotações",
                                    "Referência: Numerical Recipes ou similar"
                                  ],
                                  "tips": "Comece com n=2 para visualizar nós e pesos manualmente.",
                                  "learningObjective": "Compreender os pré-requisitos algorítmicos da quadratura de Gauss.",
                                  "commonMistakes": "Confundir nós (raízes) com pesos (derivadas ou integrais dos polinômios)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Complexidade da Computação de Nós e Pesos via Recursão",
                                  "subSteps": [
                                    "Descreva o algoritmo recursivo para gerar polinômios de Legendre até grau n.",
                                    "Conte as operações: cada recursão Pn(x) = (2n-1)/n * x * Pn-1(x) - (n-1)/n * Pn-2(x) requer O(1) por grau.",
                                    "Para encontrar raízes, use método numérico como Newton-Raphson para cada uma das n raízes, cada iteração O(1), mas ~n iterações totais.",
                                    "Calcule pesos: w_i = 2 / ((1 - x_i²) [P'n(x_i)]²), envolvendo derivadas também recursivas.",
                                    "Some operações: geração de polinômios O(n), raízes O(n²), pesos O(n²)."
                                  ],
                                  "verification": "Derive e anote que computar nós/pesos requer Θ(n²) operações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para recursão de Legendre",
                                    "Calculadora simbólica como SymPy",
                                    "Papel para contagem de operações"
                                  ],
                                  "tips": "Implemente recursão para n=5 e profile o tempo de execução.",
                                  "learningObjective": "Derivar a complexidade O(n²) para pré-computação de nós e pesos.",
                                  "commonMistakes": "Subestimar iterações em solvers de raízes; assumir O(n) para tudo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Complexidade da Avaliação da Integral",
                                  "subSteps": [
                                    "Descreva o loop de avaliação: para cada um dos n nós, compute f(x_i) e multiplique por w_i.",
                                    "Assuma f(x) é O(1) por avaliação (função black-box).",
                                    "O loop tem n iterações, cada uma O(1), total O(n).",
                                    "Some a soma final: O(1).",
                                    "Confirme independência de pré-computação (nós/pesos fixos por chamada)."
                                  ],
                                  "verification": "Escreva pseudocódigo e anote T(n) = O(n) para avaliação única.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pseudocódigo template",
                                    "Exemplo de função f(x) = sin(x)",
                                    "Relógio para timing empírico"
                                  ],
                                  "tips": "Teste com n=10, 100 para ver linearidade.",
                                  "learningObjective": "Isolar a complexidade O(n) da fase de avaliação.",
                                  "commonMistakes": "Incluir custo de f(x) se for complexa; ignorar pré-computação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Complexidades e Concluir Análise Total",
                                  "subSteps": [
                                    "Identifique fases: pré-computação (nós/pesos) O(n²) uma vez, avaliação O(n) por integral.",
                                    "Para uso único: total O(n²). Para múltiplas avaliações (k vezes): O(n² + k n).",
                                    "No contexto padrão (uma integral por setup): dominante O(n²).",
                                    "Compare com trapezoidal O(n) para justificar precisão vs custo.",
                                    "Documente notação Big-O final."
                                  ],
                                  "verification": "Escreva relatório: 'Complexidade total O(n²)' com justificativa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha para tabelas de complexidade",
                                    "Gráfico n vs tempo",
                                    "Referências teóricas"
                                  ],
                                  "tips": "Use Master Theorem se aplicável, mas foque em contagem direta.",
                                  "learningObjective": "Sintetizar análise para complexidade global O(n²).",
                                  "commonMistakes": "Confundir amortizado com pior-caso; ignorar pré-computação."
                                }
                              ],
                              "practicalExample": "Implemente quadratura de Gauss para ∫_{-1}^1 e^{-x²} dx (erro gaussiano). Compute nós/pesos para n=5 recursivamente (conte ~25 operações para raízes), avalie integral (5 avaliações f(x_i)). Meça tempo: pré-comp. ~0.01s, eval ~0.001s, confirme O(n²) dominante.",
                              "finalVerifications": [
                                "Deriva corretamente O(n²) para nós/pesos via contagem de recursões e raízes.",
                                "Explica O(n) para avaliação com pseudocódigo.",
                                "Conclui complexidade total O(n²) para uso padrão.",
                                "Implementa exemplo numérico com profiling.",
                                "Compara com método O(n) alternativo.",
                                "Documenta em notação assintótica precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de operações recursivas (80%+ acerto).",
                                "Correta identificação de gargalos (raízes O(n²)).",
                                "Clareza no pseudocódigo e análise combinada.",
                                "Uso correto de Big-O sem confusão com Theta/Omega.",
                                "Exemplo prático executável e verificado.",
                                "Ausência de erros comuns como subestimar raízes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Teoria de Aproximação Polinomial.",
                                "Física: Integração em Equações Diferenciais para Simulações (e.g., Mecânica Quântica).",
                                "Engenharia: Otimização em CFD e Processamento de Sinais.",
                                "Estatística: Quadratura em Inferência Bayesiana e MCMC."
                              ],
                              "realWorldApplication": "Em simulações científicas como previsão climática (integração de campos físicos) ou finanças (opções pricing via integrais de risco), onde precisão alta justifica O(n²) pré-computação para acelerar múltiplas avaliações O(n)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Método de Runge-Kutta",
                    "description": "Algoritmos para solução numérica de equações diferenciais ordinárias, com ordens de precisão variadas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Fundamentos do Método de Runge-Kutta",
                        "description": "Introdução aos métodos de Runge-Kutta como extensões do método de Euler para solução numérica de equações diferenciais ordinárias (EDOs) de primeira ordem, focando no problema de valor inicial e na melhoria da precisão através de estágios intermediários.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Compreender o problema de valor inicial em EDOs",
                            "description": "Identificar e formular o problema de valor inicial para EDOs da forma y' = f(t, y), y(t0) = y0, explicando a necessidade de métodos numéricos devido à impossibilidade de solução analítica em casos gerais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito básico de Equações Diferenciais Ordinárias (EDOs)",
                                  "subSteps": [
                                    "Defina uma EDO como uma equação que relaciona uma função desconhecida y(t) com suas derivadas em relação a t.",
                                    "Classifique EDOs como de primeira ordem quando envolvem apenas y'.",
                                    "Explique que EDOs modelam fenômenos dinâmicos contínuos, como crescimento ou decaimento.",
                                    "Diferencie EDOs de equações algébricas comuns.",
                                    "Identifique a forma geral y' = f(t, y)."
                                  ],
                                  "verification": "Escreva a definição de EDO de primeira ordem e dê um exemplo simples como y' = ky.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro de Cálculo Diferencial e Integral",
                                    "Notebook para anotações",
                                    "Vídeo introdutório sobre EDOs (Khan Academy)"
                                  ],
                                  "tips": "Comece com exemplos intuitivos do dia a dia, como velocidade de um carro (dy/dt = aceleração).",
                                  "learningObjective": "Compreender a representação matemática de processos dinâmicos via EDOs de primeira ordem.",
                                  "commonMistakes": [
                                    "Confundir derivada y' com y",
                                    "Achar que toda EDO tem solução explícita",
                                    "Ignorar a dependência de t e y em f(t,y)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o Problema de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Escreva a forma padrão do PVI: y' = f(t, y) com condição inicial y(t0) = y0.",
                                    "Explique o papel da condição inicial: ela torna o problema 'bem posto' e único pela existência e unicidade (Teorema de Picard-Lindelöf).",
                                    "Identifique t0 como o ponto inicial no tempo e y0 como o valor inicial da função.",
                                    "Monte um PVI simples a partir de uma descrição verbal, como 'a taxa de mudança é proporcional ao valor atual'.",
                                    "Verifique se f(t,y) é contínua e Lipschitz para garantir existência e unicidade."
                                  ],
                                  "verification": "Formule o PVI para 'a população cresce proporcionalmente à sua tamanho inicial em 100, com taxa 0.05'.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Software como GeoGebra para visualizar soluções",
                                    "Notas de aula sobre teoremas de existência"
                                  ],
                                  "tips": "Sempre especifique t0 e y0 explicitamente para evitar ambiguidades.",
                                  "learningObjective": "Saber formular matematicamente um PVI completo e entender sua importância para soluções únicas.",
                                  "commonMistakes": [
                                    "Esquecer a condição inicial",
                                    "Confundir y(t0)=y0 com y(0)=y0 sempre",
                                    "Não verificar condições de Lipschitz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer limitações das soluções analíticas",
                                  "subSteps": [
                                    "Discuta casos onde EDOs têm soluções analíticas fechadas (ex: y' = ky, solução y = y0 e^{kt}).",
                                    "Identifique EDOs não lineares ou com f(t,y) complexa sem solução analítica conhecida (ex: y' = y^2 + sin(t)).",
                                    "Explique que a maioria das EDOs reais não admite separação de variáveis ou fatores integrantes.",
                                    "Cite teoremas que garantem existência mas não construtibilidade analítica.",
                                    "Compare precisão analítica vs. aproximações em cenários práticos."
                                  ],
                                  "verification": "Classifique três EDOs como 'solucionável analiticamente' ou 'não', justificando.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Lista de EDOs exemplos",
                                    "Calculadora simbólica como Wolfram Alpha para testes",
                                    "Artigo sobre não-linearidades em EDOs"
                                  ],
                                  "tips": "Teste métodos analíticos básicos primeiro; se falhar, assuma necessidade numérica.",
                                  "learningObjective": "Discernir quando soluções exatas são inviáveis, preparando para métodos numéricos.",
                                  "commonMistakes": [
                                    "Acreditar que todas EDOs lineares têm solução fácil",
                                    "Ignorar não-linearidades sutis",
                                    "Confundir solvibilidade com computabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a necessidade de métodos numéricos",
                                  "subSteps": [
                                    "Descreva métodos numéricos como aproximações iterativas para traçar curvas de solução.",
                                    "Justifique sua uso: precisão controlável, aplicável a qualquer f(t,y) suave, escalável para sistemas.",
                                    "Discuta erros de truncamento e arredondamento, e sua gestão.",
                                    "Introduza o Método de Euler como ponte para Runge-Kutta.",
                                    "Enfatize aplicações computacionais em software como MATLAB ou Python (SciPy)."
                                  ],
                                  "verification": "Explique em 3 frases por que Runge-Kutta é preferido sobre analítico em problemas reais.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy instalado",
                                    "Tutorial básico de solvers ODE",
                                    "Gráficos de soluções numéricas vs. exatas"
                                  ],
                                  "tips": "Implemente um solver simples em código para visualizar a necessidade.",
                                  "learningObjective": "Compreender o papel pivotal dos métodos numéricos na resolução prática de PVIs.",
                                  "commonMistakes": [
                                    "Subestimar erros numéricos",
                                    "Pensar que numérico é sempre menos preciso que analítico",
                                    "Ignorar passos de tamanho h"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelagem de propagação de epidemias: y' = β y (N - y)/N - γ y, y(0) = I0 (equação SIR simplificada). Não possui solução analítica fechada, requer métodos numéricos como Runge-Kutta para simular curvas de infectados ao longo do tempo.",
                              "finalVerifications": [
                                "Defina corretamente o PVI na forma y' = f(t,y), y(t0)=y0.",
                                "Forneça um exemplo de EDO sem solução analítica e justifique.",
                                "Explique o teorema de existência e unicidade brevemente.",
                                "Diferencie solução exata de aproximação numérica com prós/contras.",
                                "Monte um PVI realista e sugira um método numérico inicial.",
                                "Verifique Lipschitz em um exemplo dado."
                              ],
                              "assessmentCriteria": [
                                "Clareza na definição de PVI (20%)",
                                "Precisão na identificação de casos sem solução analítica (25%)",
                                "Explicação convincente da necessidade numérica (25%)",
                                "Uso correto de terminologia matemática (15%)",
                                "Exemplo prático relevante e bem formulado (10%)",
                                "Ausência de erros conceituais comuns (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de movimento oscilatório (ex: pêndulo não linear).",
                                "Biologia: Dinâmica populacional e epidemias (equações Lotka-Volterra).",
                                "Engenharia: Simulação de circuitos RC/RL.",
                                "Economia: Modelos de crescimento com retornos decrescentes."
                              ],
                              "realWorldApplication": "Em previsão meteorológica, simulações de trajetórias espaciais (NASA usa Runge-Kutta para órbitas), controle de qualidade em indústrias químicas e modelagem financeira de derivativos sensíveis ao tempo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Revisar o método de Euler como base",
                            "description": "Derivar e analisar o método de Euler forward, calculando o erro local de truncamento O(h²) e demonstrando sua limitação em precisão para passos h grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação do método de Euler forward",
                                  "subSteps": [
                                    "Lembre-se da equação diferencial ordinária (EDO) y' = f(t, y), y(t0) = y0.",
                                    "Derive a aproximação linear: y_{n+1} = y_n + h * f(t_n, y_n).",
                                    "Escreva a fórmula explícita e identifique os componentes: h (passo), t_n, y_n.",
                                    "Discuta a intuição geométrica: tangente na reta atual.",
                                    "Pratique com uma EDO simples: y' = -y, y(0)=1."
                                  ],
                                  "verification": "Escreva corretamente a fórmula de Euler forward para uma EDO dada e aplique em um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora básica",
                                  "tips": "Visualize a solução exata como uma curva suave e Euler como escadas.",
                                  "learningObjective": "Entender a base iterativa do método de Euler forward.",
                                  "commonMistakes": "Confundir com método backward; esquecer o h multiplicado pela derivada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o erro local de truncamento O(h²)",
                                  "subSteps": [
                                    "Expanda y(t_{n+1}) em série de Taylor ao redor de t_n: y(t_n + h) = y(t_n) + h y'(t_n) + (h²/2) y''(ξ).",
                                    "Substitua y' = f(t,y) e aplique a cadeia para y''.",
                                    "Compare com a iteração de Euler: erro local = y(t_{n+1}) - y_{n+1} ≈ (h²/2) y''(ξ).",
                                    "Conclua que o erro local é O(h²).",
                                    "Verifique com y' = y, onde y'' = y, confirmando o fator h²."
                                  ],
                                  "verification": "Derive a expressão exata do erro local e identifique o termo O(h²).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, caneta, tabela de derivadas",
                                  "tips": "Use a regra da cadeia cuidadosamente para y'' em termos de f.",
                                  "learningObjective": "Derivar analiticamente o erro local de truncamento.",
                                  "commonMistakes": "Parar na expansão de primeira ordem; ignorar o ξ no teorema de Taylor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar limitações para passos h grandes",
                                  "subSteps": [
                                    "Implemente Euler em software para y' = -2y, y(0)=1, solução exata y=e^{-2t}.",
                                    "Teste com h=0.1 (pequeno) vs h=0.5 (grande), compare com exata.",
                                    "Observe divergência e instabilidade para h grande devido a amplificação de erros.",
                                    "Calcule erro global acumulado: ≈ (e^{L b} -1) * (erro local)/L, onde L=1/h.",
                                    "Discuta ordem global O(h)."
                                  ],
                                  "verification": "Gere tabela/plots mostrando erro crescente com h maior.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB/Octave",
                                  "tips": "Use log-plot para erros para visualizar ordem.",
                                  "learningObjective": "Demonstrar numericamente as limitações de precisão e estabilidade.",
                                  "commonMistakes": "Escolher EDO não rígida; não normalizar erros relativos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar análise e preparar para Runge-Kutta",
                                  "subSteps": [
                                    "Resuma: Euler é O(h²) local, O(h) global, instável para h grande/stiff.",
                                    "Compare com solução exata em múltiplos pontos.",
                                    "Identifique necessidade de métodos higher-order como RK.",
                                    "Crie fluxograma: quando usar Euler (rápido, protótipo).",
                                    "Auto-avaliação: explique limitações em 1 parágrafo."
                                  ],
                                  "verification": "Escreva resumo de 200 palavras e fluxograma.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, software de diagrama (opcional)",
                                  "tips": "Ligue ao contexto RK: Euler é base para slopes múltiplos.",
                                  "learningObjective": "Consolidar conhecimentos e transitar para métodos avançados.",
                                  "commonMistakes": "Superestimar precisão de Euler; ignorar custo computacional."
                                }
                              ],
                              "practicalExample": "Resolva y' = y(1 - y), y(0)=0.5 (modelo logístico) com Euler forward, h=0.1 até t=5. Compare com solução exata y=1/(1+e^{-t}) em t=1,2,3,4,5. Calcule erros e note como h=0.5 falha catastroficamente após t=2.",
                              "finalVerifications": [
                                "Deriva corretamente y_{n+1} = y_n + h f(t_n, y_n).",
                                "Mostra expansão de Taylor levando a erro O(h²).",
                                "Implementa numéricamente e compara erros para h pequeno/grande.",
                                "Explica instabilidade e ordem global O(h).",
                                "Resume limitações em contexto de RK.",
                                "Gera plots/tabelas válidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação analítica (80% correto).",
                                "Correção numérica e análise de erros (plots precisos).",
                                "Profundidade na discussão de limitações (cobre estabilidade e ordem).",
                                "Clareza em exemplos e resumo.",
                                "Uso adequado de ferramentas matemáticas (Taylor, cadeia).",
                                "Conexão explícita com fundamentos RK."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Taylor e análise assintótica.",
                                "Física: Modelagem dinâmica (osciladores, decaimento).",
                                "Engenharia: Simulações em controle e circuitos.",
                                "Estatística: Erros de aproximação em Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias de mísseis (NASA), previsão de epidemias (SIR models) ou precificação de opções financeiras, onde Euler é usado para protótipos rápidos, mas substituído por RK para precisão em h adaptativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Entender o conceito de métodos Runge-Kutta",
                            "description": "Explicar os métodos RK como combinação linear de estágios intermediários k_i = f(t_n + c_i h, y_n + h ∑ a_{ij} k_j), destacando o papel dos coeficientes Butcher para diferentes ordens de precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Equações Diferenciais Ordinárias (EDOs) e o Método de Euler como Base",
                                  "subSteps": [
                                    "Revise o conceito de EDOs: y' = f(t, y), com condições iniciais y(t0) = y0.",
                                    "Implemente o método de Euler: y_{n+1} = y_n + h f(t_n, y_n), e observe seu erro de truncamento O(h^2).",
                                    "Compare Euler com métodos exatos para EDOs simples, como y' = -y (decaimento exponencial).",
                                    "Identifique limitações do Euler: precisão baixa para h grande, instabilidade.",
                                    "Calcule manualmente 3 iterações de Euler para y' = y, y(0)=1, h=0.1."
                                  ],
                                  "verification": "Resolva uma EDO simples com Euler e compare com solução exata; erro deve ser <5% em 5 passos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Planilha Excel ou Python (opcional)"
                                  ],
                                  "tips": "Comece com EDOs lineares separáveis para ganhar confiança antes de métodos implícitos.",
                                  "learningObjective": "Entender por que métodos de ordem superior como RK são necessários para melhorar precisão.",
                                  "commonMistakes": [
                                    "Confundir passo h com incremento em t",
                                    "Ignorar dependência de f em t e y",
                                    "Usar h muito grande sem verificar estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir os Estágios Intermediários k_i nos Métodos Runge-Kutta",
                                  "subSteps": [
                                    "Defina k_i = f(t_n + c_i h, y_n + h ∑_{j=1}^{i-1} a_{ij} k_j) para i=1 a s (s estágios).",
                                    "Note que k_1 = f(t_n, y_n) (como Euler), mas k_i subsequentes usam combinações lineares.",
                                    "Aproxime y_{n+1} = y_n + h ∑_{i=1}^s b_i k_i (coeficientes de peso).",
                                    "Calcule k_i manualmente para um RK2 simples: c1=0, c2=1, a21=1, b1=1/2, b2=1/2.",
                                    "Aplique a um exemplo: y' = t + y, y(0)=0, h=0.1."
                                  ],
                                  "verification": "Derive y1 para o exemplo acima e confirme que coincide com fórmula RK2 conhecida.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Software de álgebra simbólica como SymPy"
                                  ],
                                  "tips": "Visualize k_i como 'tentativas' de inclinação em pontos intermediários no intervalo [t_n, t_{n+1}].",
                                  "learningObjective": "Graspar a estrutura recursiva dos k_i como preditores aprimorados.",
                                  "commonMistakes": [
                                    "Esquecer soma em y_n + h ∑ a_{ij} k_j",
                                    "Usar todos k_j incluindo futuros",
                                    "Confundir índices i e j na matriz A"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Tabela Butcher e seus Coeficientes",
                                  "subSteps": [
                                    "Desenhe a tabela Butcher: vetor c (3x1), matriz A (sxs inferior), vetor b (1xs).",
                                    "Explique papéis: c define avanços temporais, A pesos para predição, b pesos finais.",
                                    "Compare tabelas: Euler (s=1, c1=0, a11=0, b1=1), RK4 clássica (s=4, coeficientes simétricos).",
                                    "Preencha uma tabela Butcher vazia para RK3 de Heun e compute y1 para uma EDO teste.",
                                    "Verifique consistência: ∑ b_i =1, ∑_j a_{ij} = c_i para consistência de ordem 1."
                                  ],
                                  "verification": "Construa tabela RK4 e confirme k1=f(tn,yn), k2=f(tn+h/2,yn+h k1/2), etc.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabela Butcher impressa ou digital",
                                    "Python com NumPy para matrizes"
                                  ],
                                  "tips": "Lembre: métodos explícitos têm A estritamente inferior (sem diagonal).",
                                  "learningObjective": "Dominar a notação Butcher como representação compacta e universal de RK.",
                                  "commonMistakes": [
                                    "Colocar valores na diagonal superior de A",
                                    "Ignorar normalização ∑b_i=1",
                                    "Confundir c_i com b_i"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Ordens de Precisão e Exemplos Clássicos",
                                  "subSteps": [
                                    "Defina ordem p: erro local O(h^{p+1}), requer condições em Butcher (ex: ordem 4 precisa 11 condições).",
                                    "Estude RK4: ordem 4, tabela clássica, erro global O(h^4).",
                                    "Implemente RK2, RK4 em código para y'=-y, plote erros vs h.",
                                    "Discuta trade-offs: mais estágios = mais precisão/custo (avaliações de f).",
                                    "Compare numericamente RK4 vs Euler em oscilador harmônico y'' + y=0 (sistema 2D)."
                                  ],
                                  "verification": "Gere gráfico log-log de erro vs h; inclinação deve aproximar ordem p.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python/MATLAB com matplotlib",
                                    "Exemplos de código RK online"
                                  ],
                                  "tips": "Use h decrescente (0.1, 0.05, 0.01) para estimar ordem empiricamente.",
                                  "learningObjective": "Entender como Butcher determina precisão e escolher método por ordem vs custo.",
                                  "commonMistakes": [
                                    "Confundir erro local/global",
                                    "Não reduzir sistemas de EDOs de ordem >1",
                                    "Implementar Butcher incorretamente em loop"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o decaimento radioativo y' = -λ y, y(0)=1, com λ=0.1, usando RK4 com h=0.5 por 10 passos. Compare com exata y(t)=exp(-λ t); erro deve ser <10^{-4}. Código Python: def rk4_step(f, t, y, h): k1=f(t,y); k2=f(t+h/2,y+h*k1/2); ... ynew = y + h*(k1/6 + 2*k2/6 + ...).",
                              "finalVerifications": [
                                "Derive fórmula completa de k_i para RK4 clássico.",
                                "Construa tabela Butcher para RK2 de ponto médio.",
                                "Explique por que RK4 tem ordem 4 sem derivadas de f.",
                                "Identifique condição Butcher para consistência ordem 1.",
                                "Compare custo computacional: Euler (1f) vs RK4 (4f).",
                                "Resolva sistema 2D (pêndulo) com RK4 manualmente 1 passo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de k_i e y_{n+1} (80% correto).",
                                "Correta interpretação da tabela Butcher (todos coeficientes nomeados).",
                                "Explicação clara de ordem p via condições de ordem.",
                                "Exemplo numérico sem erros aritméticos.",
                                "Discussão de limitações (explícito vs implícito).",
                                "Uso correto de notação matemática padrão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica, séries de Taylor para condições de ordem.",
                                "Física: Simulação de dinâmica (órbitas, circuitos RLC).",
                                "Engenharia: Controle de sistemas, modelagem diferencial.",
                                "Ciência de Dados: Integração em ML para ODEs em redes neurais.",
                                "Computação: Otimização de solvers em SciPy/ODEPACK."
                              ],
                              "realWorldApplication": "Métodos RK são usados em simuladores físicos como previsão de trajetórias de foguetes (NASA), modelagem climática (EDOs caóticas), finanças (equações de Black-Scholes estocásticas aproximadas), e jogos/vfx (simulação de partículas e fluidos em Unity/Unreal)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Método de Runge-Kutta de Ordem 2",
                        "description": "Detalhamento do RK2, incluindo variantes como o método de Heun e Ralston, com ordem de precisão 2 e erro local O(h³), adequado para introdução prática.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Derivar a fórmula do RK2 clássico",
                            "description": "Calcular os coeficientes para RK2: k1 = f(t_n, y_n), k2 = f(t_n + h, y_n + h k1), y_{n+1} = y_n + (h/2)(k1 + k2), verificando a ordem de precisão via expansão em série de Taylor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a expansão em série de Taylor da solução exata",
                                  "subSteps": [
                                    "Escreva a solução exata: y(t_{n+1}) = y(t_n + h).",
                                    "Expanda em Taylor: y(t_n + h) = y_n + h y'(t_n) + (h^2/2) y''(t_n) + O(h^3).",
                                    "Expresse as derivadas: y'_n = f(t_n, y_n), y''_n = ∂f/∂t + (∂f/∂y) f (regra da cadeia).",
                                    "Mantenha até o termo de ordem h^2, ignorando O(h^3).",
                                    "Anote os termos parciais: f_t = ∂f/∂t |_{(t_n,y_n)}, f_y = ∂f/∂y |_{(t_n,y_n)}."
                                  ],
                                  "verification": "Escreva corretamente a expansão de Taylor até h^2, incluindo expressões para y'' em termos de f, f_t e f_y.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas sobre EDOs ordinárias",
                                    "Calculadora para derivadas parciais"
                                  ],
                                  "tips": "Use notação consistente para derivadas parciais e lembre-se da regra da cadeia para derivadas totais.",
                                  "learningObjective": "Compreender a estrutura do erro de truncamento local para métodos numéricos de ordem 2.",
                                  "commonMistakes": [
                                    "Confundir derivadas parciais com totais",
                                    "Esquecer o termo (h^2/2) no coeficiente",
                                    "Ignorar a dependência de f em t e y"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a forma geral do método RK2",
                                  "subSteps": [
                                    "Defina k1 = f(t_n, y_n).",
                                    "Defina k2 = f(t_n + c_2 h, y_n + a_{21} h k1).",
                                    "Escreva a aproximação: y_{n+1} = y_n + b_1 h k1 + b_2 h k2.",
                                    "Expanda k2 em Taylor: k2 ≈ f_n + c_2 h f_t + (a_{21} h k1) f_y + O(h^2).",
                                    "Substitua na fórmula de y_{n+1} e expanda até ordem h^2."
                                  ],
                                  "verification": "Expresse y_{n+1} em termos de f_n, f_t, f_y e coeficientes b1, b2, c2, a21 até O(h^2).",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de coeficientes RK genéricos"
                                  ],
                                  "tips": "Expanda f(t_n + c_2 h, y_n + a_{21} h k1) usando Taylor multivariável.",
                                  "learningObjective": "Construir a expansão do método RK2 para matching com a solução exata.",
                                  "commonMistakes": [
                                    "Erro na expansão de k2 (esquecer termos cruzados)",
                                    "Confundir índices nos coeficientes Butcher",
                                    "Parar na ordem h em vez de h^2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Igualar coeficientes para ordem de precisão 2",
                                  "subSteps": [
                                    "Compare o termo h: b1 + b2 = 1.",
                                    "Compare o termo h^2: b2 c_2 = 1/2 e b2 a_{21} = 1/2.",
                                    "Resolva o sistema: b1 + b2 = 1, b2 c_2 = 1/2, b2 a_{21} = 1/2.",
                                    "Escolha valores clássicos: b1 = b2 = 1/2, c_2 = 1, a_{21} = 1.",
                                    "Verifique se satisfaz todas as condições de ordem 2."
                                  ],
                                  "verification": "Mostre que os coeficientes escolhidos igualam os termos até h^2 na expansão de Taylor.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Trate como sistema linear de equações; múltiplas soluções existem, mas foque no clássico.",
                                  "learningObjective": "Derivar condições de ordem para métodos RK via matching de Taylor.",
                                  "commonMistakes": [
                                    "Resolver incorretamente o sistema (ex: b2=1/2 implica c2=1)",
                                    "Ignorar uma das condições h^2",
                                    "Confundir b1 com b2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a ordem de precisão e escrever a fórmula final",
                                  "subSteps": [
                                    "Substitua os coeficientes clássicos: k1 = f(t_n, y_n), k2 = f(t_n + h, y_n + h k1).",
                                    "Escreva y_{n+1} = y_n + (h/2)(k1 + k2).",
                                    "Calcule o erro local: mostre que coincide até h^2 e erro O(h^3).",
                                    "Teste com EDO linear simples y' = λ y para validar.",
                                    "Discuta estabilidade e limitações do RK2 clássico."
                                  ],
                                  "verification": "Derive a fórmula final e confirme erro de truncamento O(h^3) via Taylor.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de EDO y' = y"
                                  ],
                                  "tips": "Para verificação, compute numericamente os termos O(h^3) para um f específico.",
                                  "learningObjective": "Confirmar a precisão de ordem 2 e formular o método RK2 clássico.",
                                  "commonMistakes": [
                                    "Escrever k2 errado (ex: sem h k1)",
                                    "Afirmar ordem superior sem prova",
                                    "Confundir erro global com local"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y (λ=1), Taylor exata: y(t_n + h) = y_n e^h ≈ y_n (1 + h + h^2/2 + h^3/6). RK2: k1 = y_n, k2 = y_n + h k1 = y_n (1 + h), y_{n+1} = y_n + (h/2)(y_n + y_n(1+h)) = y_n (1 + h + h^2/2), matching até h^2.",
                              "finalVerifications": [
                                "Escreve corretamente k1, k2 e y_{n+1} para RK2 clássico.",
                                "Deriva as condições b1 + b2 =1, b2 c2=1/2, b2 a21=1/2.",
                                "Expande y(t_n+h) até h^2 com y'' = f_t + f_y f.",
                                "Confirma erro O(h^3) comparando expansões.",
                                "Aplica a um exemplo simples e verifica numericamente.",
                                "Explica por que é ordem 2 mas não 3."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das expansões de Taylor (sem erros algébricos).",
                                "Correta resolução do sistema de condições de ordem.",
                                "Clareza na expressão da fórmula final RK2.",
                                "Validação via exemplo prático com matching de termos.",
                                "Identificação correta do erro de truncamento.",
                                "Profundidade na discussão de derivadas parciais e cadeia."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial e Integral: Expansões de Taylor e derivadas parciais.",
                                "Equações Diferenciais: Soluções locais e métodos numéricos.",
                                "Programação Computacional: Implementação de solvers ODE em Python/MATLAB.",
                                "Física Computacional: Simulações de trajetórias e osciladores.",
                                "Análise Numérica: Estabilidade e convergência de esquemas."
                              ],
                              "realWorldApplication": "Usado em simulações de trajetórias espaciais (NASA orbitais), modelagem de reações químicas em farmacologia e previsão meteorológica básica, onde precisão quadrática equilibra custo computacional em sistemas dinâmicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Implementar RK2 em pseudocódigo",
                            "description": "Escrever pseudocódigo iterativo para RK2, considerando condições de parada por tolerância ou número de passos, e analisar complexidade O(n) onde n é o número de iterações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos Matemáticos do RK2",
                                  "subSteps": [
                                    "Estude a forma geral de uma EDO: dy/dt = f(t, y), com condição inicial y(t0) = y0.",
                                    "Aprenda o cálculo de k1 = h * f(t_n, y_n).",
                                    "Aprenda o cálculo de k2 = h * f(t_n + h, y_n + k1).",
                                    "Entenda a atualização: y_{n+1} = y_n + (k1 + k2)/2 e t_{n+1} = t_n + h.",
                                    "Revise o conceito de ordem 2: erro local O(h^3)."
                                  ],
                                  "verification": "Explique em suas palavras os cálculos de k1 e k2 e derive y_{n+1} manualmente para um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de referência de métodos Runge-Kutta",
                                    "Exemplo de EDO y' = y, y(0)=1"
                                  ],
                                  "tips": "Desenhe o método de Heun (RK2) no plano t-y para visualizar a aproximação trapezoidal.",
                                  "learningObjective": "Dominar a fórmula exata do RK2 e sua justificativa numérica.",
                                  "commonMistakes": [
                                    "Confundir k2 com h * f(t_n + h/2, y_n + k1/2) (isso é RK3)",
                                    "Esquecer o fator h nos k's",
                                    "Usar média errada além de (k1 + k2)/2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever Pseudocódigo para um Único Passo de RK2",
                                  "subSteps": [
                                    "Defina os parâmetros de entrada: função f(t,y), t0, y0, h.",
                                    "Calcule k1 = h * f(t0, y0).",
                                    "Calcule k2 = h * f(t0 + h, y0 + k1).",
                                    "Atualize y1 = y0 + (k1 + k2)/2 e t1 = t0 + h.",
                                    "Retorne y1 e t1."
                                  ],
                                  "verification": "Teste manualmente com f(t,y)= -y, t0=0, y0=1, h=0.1 e verifique y1 ≈ 0.904837.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Calculadora para validação numérica"
                                  ],
                                  "tips": "Use indentação clara para destacar o fluxo sequencial.",
                                  "learningObjective": "Implementar corretamente um passo isolado de RK2 em pseudocódigo legível.",
                                  "commonMistakes": [
                                    "Atualizar t antes de usar em k2",
                                    "Dividir por 2 incorretamente",
                                    "Não multiplicar k1 por h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Loop Iterativo com Condições de Parada",
                                  "subSteps": [
                                    "Inicialize t = t0, y = y0, passo = 0, max_steps = 1000, tol = 1e-6.",
                                    "Inicie loop while (passo < max_steps e |erro| > tol).",
                                    "Dentro do loop: calcule k1, k2, atualize y e t, avalie erro (ex: |y - y_analitica| ou diferença relativa).",
                                    "Incremente passo e verifique condição de parada.",
                                    "Armazene histórico de y se necessário para análise."
                                  ],
                                  "verification": "Simule 3 iterações manualmente e confirme que para quando tolerância é atingida ou max_steps.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para simulação manual",
                                    "Pseudocódigo de exemplo iterativo"
                                  ],
                                  "tips": "Use uma variável 'erro' calculada após cada iteração para controle preciso.",
                                  "learningObjective": "Criar um algoritmo iterativo robusto com parada adaptativa.",
                                  "commonMistakes": [
                                    "Loop infinito sem max_steps",
                                    "Calcular erro antes da primeira iteração",
                                    "Atualizar y sem verificar bounds"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade Computacional do Algoritmo",
                                  "subSteps": [
                                    "Identifique operações por iteração: 2 avaliações de f (O(1) assumindo f simples), 4 operações aritméticas básicas.",
                                    "Some custo total: O(n) onde n = número de iterações (até max_steps ou 1/tol).",
                                    "Discuta dependência em h: n ≈ T/h para intervalo [0,T].",
                                    "Considere custo de f: se f for O(m), total O(n*m).",
                                    "Compare com Euler: RK2 tem custo 2x mas precisão melhor."
                                  ],
                                  "verification": "Escreva notação Big-O e justifique com contagem de operações para n=10.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de complexidades de métodos numéricos",
                                    "Exemplo com f custosa"
                                  ],
                                  "tips": "Conte flops (floating point operations) para precisão.",
                                  "learningObjective": "Avaliar eficiência assintótica do RK2 iterativo.",
                                  "commonMistakes": [
                                    "Ignorar custo de f",
                                    "Confundir O(n) com O(1/h)",
                                    "Esquecer loop overhead"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=1 até t=1 com h=0.1, tol=1e-4. Pseudocódigo: inicialize t=0,y=1; while t<1 and passo<100: k1=h*f(t,y), k2=h*f(t+h,y+k1), y+= (k1+k2)/2, t+=h, passo+=1. Resultado aproximado y(1)≈0.1353 (exato e^{-2}).",
                              "finalVerifications": [
                                "Pseudocódigo executa sem loops infinitos e para corretamente.",
                                "Para exemplo prático, resultado numérico bate com solução analítica dentro de tol.",
                                "Condições de parada (tol e max_steps) são implementadas e testadas.",
                                "Histórico de iterações mostra convergência.",
                                "Análise de complexidade escrita como O(n) com justificativa.",
                                "Código é legível com comentários em fórmulas chave."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: k1,k2 e atualização exatos.",
                                "Robustez: condições de parada funcionais e seguras.",
                                "Eficiência: complexidade O(n) corretamente identificada.",
                                "Clareza: pseudocódigo indentado e comentado.",
                                "Precisão numérica: erro < tol no exemplo.",
                                "Generalidade: funciona para qualquer f(t,y) escalar."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo Numérico e Análise de Erros.",
                                "Física: Simulação de Sistemas Dinâmicos (ex: osciladores).",
                                "Engenharia: Modelagem em Controle e Aerodinâmica.",
                                "Ciência de Dados: Integração em ML para ODEs em redes neurais."
                              ],
                              "realWorldApplication": "Implementação em simuladores de voo (NASA), previsão de epidemias (SIR models), finanças (modelos Black-Scholes estocásticos), e jogos (física de partículas real-time)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Aplicar RK2 em exemplo numérico",
                            "description": "Resolver numericamente y' = -y, y(0)=1 com h=0.1 em 5 passos, comparando com solução exata e calculando erro global aproximado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fórmula do RK2 e preparar dados iniciais",
                                  "subSteps": [
                                    "Escreva a equação diferencial: y' = -y com y(0) = 1.",
                                    "Recorde a fórmula RK2: k1 = h * f(t_n, y_n), k2 = h * f(t_n + h, y_n + k1), y_{n+1} = y_n + (k1 + k2)/2.",
                                    "Defina h = 0.1 e planeje 5 passos até t = 0.5.",
                                    "Escreva a solução exata: y(t) = e^{-t}.",
                                    "Crie uma tabela com colunas: n, t_n, y_n, k1, k2, y_{n+1}."
                                  ],
                                  "verification": "Tabela inicial preparada corretamente com y0=1 em t=0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use notação clara para evitar confusão entre k1 e k2.",
                                  "learningObjective": "Compreender e formular corretamente o método RK2 para EDOs autônomas.",
                                  "commonMistakes": [
                                    "Confundir f(y) = -y com dependência de t",
                                    "Esquecer que h multiplica f em k1 e k2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o primeiro passo (n=0 para n=1)",
                                  "subSteps": [
                                    "Calcule k1 = 0.1 * f(0, 1) = 0.1 * (-1) = -0.1.",
                                    "Calcule k2 = 0.1 * f(0.1, 1 + (-0.1)) = 0.1 * (-0.9) = -0.09.",
                                    "Calcule y1 = 1 + (-0.1 + -0.09)/2 = 1 - 0.095 = 0.905.",
                                    "Registre t1 = 0.1, y1 = 0.905 na tabela.",
                                    "Verifique arredondamento para 3 casas decimais."
                                  ],
                                  "verification": "y1 ≈ 0.905 calculado corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela do passo 1"
                                  ],
                                  "tips": "Arredonde consistentemente para evitar erros de propagação.",
                                  "learningObjective": "Aplicar fórmula RK2 manualmente em um passo inicial.",
                                  "commonMistakes": [
                                    "Calcular k2 com y_n ao invés de y_n + k1",
                                    "Esquecer dividir por 2 na média"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Iterar RK2 para os passos 2 a 5",
                                  "subSteps": [
                                    "Para n=1: k1 = 0.1 * (-0.905) = -0.0905; k2 = 0.1 * (-0.905 -0.0905) = -0.09955; y2 = 0.905 + (-0.0905 -0.09955)/2 ≈ 0.819525.",
                                    "Repita para n=2: obtenha y3 ≈ 0.740818.",
                                    "Para n=3: y4 ≈ 0.670320.",
                                    "Para n=4: y5 ≈ 0.606531 em t=0.5.",
                                    "Preencha tabela completa e confira cálculos intermediários."
                                  ],
                                  "verification": "Tabela completa com y5 ≈ 0.6065.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela atualizada"
                                  ],
                                  "tips": "Calcule k1 e k2 separadamente e anote antes de somar.",
                                  "learningObjective": "Executar iterações múltiplas do RK2 com precisão.",
                                  "commonMistakes": [
                                    "Erros de arredondamento acumulados",
                                    "Usar valor errado de y_n anterior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com solução exata e calcular erro global",
                                  "subSteps": [
                                    "Calcule y_exata(0.5) = e^{-0.5} ≈ 0.606531.",
                                    "Compute erro em t=0.5: |0.606531 - 0.606531| ≈ 0 (mas verifique todos passos).",
                                    "Calcule erros locais em cada t_n: e.g., em t=0.1, |e^{-0.1} - 0.905| ≈ 0.0043.",
                                    "Determine erro global aproximado: máximo dos erros absolutos ≈ 0.0001 (devido a RK2).",
                                    "Discuta convergência: erro O(h^2)."
                                  ],
                                  "verification": "Erro global reportado corretamente com comparação tabular.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora com exp()",
                                    "Tabela numérica vs exata"
                                  ],
                                  "tips": "Use função exp na calculadora para y_exata.",
                                  "learningObjective": "Avaliar precisão do RK2 comparando com solução analítica.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Calcular e^{-t} errado"
                                  ]
                                }
                              ],
                              "practicalExample": "No primeiro passo: k1 = 0.1 × (-1) = -0.1; k2 = 0.1 × (-(1 - 0.1)) = -0.09; y1 = 1 + (-0.095) = 0.905, enquanto y_exata(0.1) ≈ 0.904837, erro ≈ 0.000163.",
                              "finalVerifications": [
                                "Tabela completa com 5 passos e valores y_n corretos até 4 casas decimais.",
                                "Solução exata em t=0.5 calculada como e^{-0.5} ≈ 0.606531.",
                                "Erros absolutos em cada passo listados.",
                                "Erro global máximo identificado (< 10^{-3}).",
                                "Gráfico manual ou descrição de convergência O(h^2).",
                                "Fórmula RK2 aplicada sem erros em todos k1/k2."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos numéricos (erro < 0.001).",
                                "Correta aplicação da fórmula RK2 em todos passos.",
                                "Comparação adequada com solução exata.",
                                "Cálculo correto de erros locais e global.",
                                "Clareza na tabela e documentação.",
                                "Identificação de ordem de precisão (O(h^2))."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares e análise de erro.",
                                "Física: Modelagem de decaimento exponencial (radioatividade, resfriamento).",
                                "Engenharia: Simulações dinâmicas em controle de sistemas.",
                                "Computação: Implementação em Python/NumPy para automação."
                              ],
                              "realWorldApplication": "Usado em simulações de decaimento radioativo em física nuclear, modelagem de circuitos RC em engenharia elétrica, predição de populações em biologia e simulações climáticas para trajetórias orbitais aproximadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Método de Runge-Kutta de Ordem 4 (RK4)",
                        "description": "O método RK4 clássico, amplamente utilizado por sua precisão elevada (erro local O(h^5)), estabilidade e simplicidade, com tabela de Butcher padrão.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Memorizar e derivar a fórmula do RK4",
                            "description": "Listar os 4 estágios: k1=f(t,y), k2=f(t+h/2,y+(h/2)k1), k3=f(t+h/2,y+(h/2)k2), k4=f(t+h,y+hk3); y_{n+1}=y_n + (h/6)(k1+2k2+2k3+k4), provando ordem 4.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Método de Runge-Kutta de Ordem 4 (RK4)",
                                  "subSteps": [
                                    "Rever o problema de valor inicial (PVI): dy/dt = f(t, y), com y(t₀) = y₀",
                                    "Compreender que o RK4 é um método explícito de Runge-Kutta com ordem de precisão 4",
                                    "Visualizar os quatro estágios k₁, k₂, k₃, k₄ como aproximações da derivada em pontos intermediários no intervalo h",
                                    "Estudar a tabela de Butcher para RK4, notando os coeficientes a_{ij}, b_i e c_i"
                                  ],
                                  "verification": "Explicar em voz alta ou por escrito o propósito de cada k_i e como eles melhoram a precisão sobre o método de Euler",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre métodos numéricos",
                                    "Livro de referência (ex: Numerical Analysis de Burden & Faires)",
                                    "Vídeo introdutório sobre Runge-Kutta"
                                  ],
                                  "tips": "Pense nos k's como 'amostras' da derivada em posições estratégicas ao longo do passo h para capturar curvatura.",
                                  "learningObjective": "Compreender a motivação e a estrutura geral do RK4 como extensão do método de Euler.",
                                  "commonMistakes": [
                                    "Confundir RK4 com métodos implícitos",
                                    "Ignorar a importância da ordem 4 para estabilidade e precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar as Expressões dos Estágios k₁, k₂, k₃ e k₄",
                                  "subSteps": [
                                    "Escrever k₁ = f(tₙ, yₙ)",
                                    "Escrever k₂ = f(tₙ + h/2, yₙ + (h/2) k₁)",
                                    "Escrever k₃ = f(tₙ + h/2, yₙ + (h/2) k₂)",
                                    "Escrever k₄ = f(tₙ + h, yₙ + h k₃)",
                                    "Repetir a listagem completa de memória pelo menos 5 vezes, cobrindo um papel com as fórmulas"
                                  ],
                                  "verification": "Escrever as quatro fórmulas exatas sem consultar notas, verificando com uma referência",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Flashcards com fórmulas",
                                    "Aplicativo de repetição espaçada (ex: Anki)"
                                  ],
                                  "tips": "Mnemônico: 'k1 no início, k2 meio com k1, k3 meio com k2, k4 fim com k3' – simetria em k2/k3.",
                                  "learningObjective": "Memorizar com precisão os argumentos exatos de cada estágio k_i.",
                                  "commonMistakes": [
                                    "Trocar os argumentos de k₂ e k₃",
                                    "Esquecer o fator h em k₄",
                                    "Usar h/2 em k₄ incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Memorizar e Compreender a Fórmula de Atualização y_{n+1}",
                                  "subSteps": [
                                    "Escrever y_{n+1} = yₙ + (h/6) (k₁ + 2 k₂ + 2 k₃ + k₄)",
                                    "Identificar os pesos: 1/6 para k₁ e k₄, 2/6 para k₂ e k₃",
                                    "Verificar que a soma dos pesos é 1: (1+2+2+1)/6 = 1",
                                    "Derivar intuitivamente dos coeficientes b_i da tabela de Butcher para RK4",
                                    "Testar com f(t,y)=0 para verificar consistência"
                                  ],
                                  "verification": "Calcular y_{n+1} simbolicamente para k_i genéricos e confirmar a fórmula",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para cálculos simbólicos",
                                    "Calculadora ou SymPy para verificação"
                                  ],
                                  "tips": "Pesos simétricos 1-2-2-1 lembram uma regra de Simpson para integração numérica.",
                                  "learningObjective": "Aplicar corretamente a combinação ponderada dos k_i para atualizar y.",
                                  "commonMistakes": [
                                    "Esquecer o h/6",
                                    "Usar pesos iguais 1/4",
                                    "Invertar os pesos de k₂ e k₃"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e Provar a Ordem de Precisão 4 do RK4",
                                  "subSteps": [
                                    "Expandir cada k_i em série de Taylor em torno de (tₙ, yₙ) até ordem 4",
                                    "Substituir na expressão de y_{n+1} e expandir y(tₙ + h) em Taylor",
                                    "Mostrar que os termos de erro local até O(h⁴) cancelam exatamente",
                                    "Verificar que o erro local restante é O(h⁵), implicando ordem global 4",
                                    "Comparar numericamente com Euler (ordem 1) em uma EDO simples"
                                  ],
                                  "verification": "Esboçar as expansões de Taylor principais e identificar os coeficientes que zeram os erros baixos",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Referência avançada (ex: Hairer 'Solving ODEs')",
                                    "Software como Mathematica ou SymPy para séries de Taylor"
                                  ],
                                  "tips": "Foque na tabela de Butcher: condições de ordem 4 garantem os cancelamentos necessários.",
                                  "learningObjective": "Compreender matematicamente por que o RK4 atinge precisão ordem 4.",
                                  "commonMistakes": [
                                    "Confundir ordem local (5) com global (4)",
                                    "Erros nos derivados parciais de f",
                                    "Parar na ordem 3 sem verificar ordem 4"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o PVI dy/dt = -2y, y(0)=1 com h=0.1 usando RK4 em um passo: k1 = f(0,1) = -2; k2 = f(0.05, 1 - 0.1) = -1.8182; k3 = f(0.05, 1 - 0.09091) = -1.8364; k4 = f(0.1, 1 - 0.18364) = -1.6732; y1 = 1 + (0.1/6)(-2 + 2*(-1.8182) + 2*(-1.8364) + -1.6732) ≈ 0.8187 (próximo de e^{-0.2} ≈ 0.8187).",
                              "finalVerifications": [
                                "Listar corretamente as fórmulas de k1 a k4 sem erros",
                                "Escrever y_{n+1} com pesos exatos",
                                "Explicar os pesos 1-2-2-1 e sua soma",
                                "Descrever o cancelamento de termos até O(h^4) na prova de ordem",
                                "Implementar RK4 em pseudocódigo ou Python para uma EDO teste",
                                "Comparar resultado numérico com solução exata"
                              ],
                              "assessmentCriteria": [
                                "Memorização precisa das fórmulas (100% exatidão)",
                                "Compreensão conceitual: explicação clara da estrutura e pesos",
                                "Habilidade de aplicação: cálculo correto em exemplo prático",
                                "Profundidade analítica: esboço válido da prova de ordem 4",
                                "Criatividade: extensão para variação como RK45",
                                "Precisão numérica: erro < 10^{-4} em teste"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e séries de Taylor",
                                "Física: Simulações de dinâmica (ex: movimento planetário com gravidade)",
                                "Engenharia: Modelagem de sistemas de controle e circuitos",
                                "Computação: Implementação em bibliotecas como SciPy odeint ou MATLAB ode45"
                              ],
                              "realWorldApplication": "O RK4 é usado em simuladores físicos (jogos como Unity para trajetórias, animações CGI), modelagem climática e previsão meteorológica, finanças para precificação de derivativos, e robótica para controle de trajetórias, oferecendo equilíbrio ideal entre precisão e custo computacional para EDOs não-lineares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Implementar RK4 para sistemas de EDOs",
                            "description": "Estender RK4 para sistemas vetoriais y'=f(t,y) com y em R^m, implementando em pseudocódigo com laços sobre componentes e analisando custo por passo O(m).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a extensão do RK4 escalar para sistemas vetoriais",
                                  "subSteps": [
                                    "Revise a fórmula do RK4 para EDOs escalares: k1 = h*f(t,y), k2 = h*f(t+h/2, y+k1/2), k3 = h*f(t+h/2, y+k2/2), k4 = h*f(t+h, y+k3), y_new = y + (k1 + 2k2 + 2k3 + k4)/6",
                                    "Identifique que para y ∈ R^m, todos os k_i e y tornam-se vetores de dimensão m",
                                    "Note que f(t,y) retorna um vetor em R^m, computado componente-wise ou via equações acopladas",
                                    "Verifique que operações (+, *) são vetoriais, preservando a estrutura do método",
                                    "Confirme que o erro local permanece O(h^5) por componente, global O(h^4)"
                                  ],
                                  "verification": "Escreva as fórmulas vetoriais em papel e compare com a versão escalar para m=1",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência de RK4 escalar",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize y como coluna de m componentes; cada k_i é similar",
                                  "learningObjective": "Entender conceitualmente como o RK4 escalar generaliza para vetores sem perda de precisão",
                                  "commonMistakes": [
                                    "Confundir escalar com vetorial nos k's",
                                    "Ignorar que f é função vetorial",
                                    "Esquecer normalização por 6 no update"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir estruturas de dados e função f(t,y)",
                                  "subSteps": [
                                    "Defina y como vetor de tamanho m (array ou lista)",
                                    "Especifique f(t,y) como função que recebe escalar t e vetor y, retorna vetor f de tamanho m",
                                    "Exemplo: para m=2, f(t,[y1,y2]) = [y2, -y1] para oscilador harmônico",
                                    "Inclua parâmetros: h (passo), t_init, t_final, y_init ∈ R^m",
                                    "Planeje laços sobre i=1 a m para componentes se necessário"
                                  ],
                                  "verification": "Esboce pseudofunção f para um sistema simples como y' = A y (linear)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Exemplos de sistemas EDO"
                                  ],
                                  "tips": "Use notação vetorial; evite loops desnecessários em f se vetorizado",
                                  "learningObjective": "Modelar o problema como função vetorial pronta para RK4",
                                  "commonMistakes": [
                                    "Definir f retornando escalar",
                                    "Ignorar dependência em t",
                                    "Não inicializar y com tamanho m"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo dos incrementos k1, k2, k3, k4 em pseudocódigo",
                                  "subSteps": [
                                    "Calcule k1 = h * f(t, y)",
                                    "Calcule k2 = h * f(t + h/2, y + k1/2)",
                                    "Calcule k3 = h * f(t + h/2, y + k2/2)",
                                    "Calcule k4 = h * f(t + h, y + k3)",
                                    "Use laços explícitos sobre componentes se f não for vetorizada: for i=1 to m: ki[i] = ..."
                                  ],
                                  "verification": "Simule manualmente para m=1 e verifique contra RK4 escalar conhecido",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de pseudocódigo",
                                    "Calculadora para teste manual"
                                  ],
                                  "tips": "Implemente soma vetorial como k1 + k2 elemento-wise",
                                  "learningObjective": "Codificar os quatro estágios do RK4 de forma vetorial precisa",
                                  "commonMistakes": [
                                    "Usar soma escalar em vetores",
                                    "Esquecer /2 nos argumentos médios",
                                    "Ordem errada de k's"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar atualização de y e loop de integração temporal",
                                  "subSteps": [
                                    "Compute peso = (k1 + 2*k2 + 2*k3 + k4) / 6 (vetorial)",
                                    "Atualize y = y + peso",
                                    "Avance t = t + h",
                                    "Envolva em loop while t < t_final: repita passos 3-4",
                                    "Armazene trajetória opcionalmente em lista de vetores"
                                  ],
                                  "verification": "Execute pseudocódigo para sistema linear simples e compare com solução exata",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pseudocódigo completo",
                                    "Exemplo numérico conhecido"
                                  ],
                                  "tips": "Garanta que todas ops sejam vetoriais; teste com h pequeno para estabilidade",
                                  "learningObjective": "Construir integrador completo RK4 para evolução temporal de sistemas",
                                  "commonMistakes": [
                                    "Peso errado (ex: /6 fora do parênteses)",
                                    "Loop infinito sem t += h",
                                    "Não zerar k's por iteração"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar custo computacional por passo",
                                  "subSteps": [
                                    "Identifique 4 chamadas a f(t,y) por passo RK4",
                                    "Assuma custo de f é O(m) (laço sobre m componentes)",
                                    "Total por passo: 4 * O(m) + O(m) para somas/vetores = O(m)",
                                    "Compare com Euler: 1 * O(m) = O(m), mas RK4 mais preciso",
                                    "Note independência de ordem em m para custo por passo"
                                  ],
                                  "verification": "Conte FLOPs: cada f ~ m mults/somas, total ~ 16m ops vetoriais",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha para contagem de operações",
                                    "Big-O cheat sheet"
                                  ],
                                  "tips": "Ignore custo de +/* vetoriais como O(m); foque em f dominante",
                                  "learningObjective": "Quantificar complexidade O(m) por passo em sistemas multidimensionais",
                                  "commonMistakes": [
                                    "Dizer O(1) ignorando m",
                                    "Contar 1 f só",
                                    "Confundir custo total vs por passo"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente RK4 para o sistema Lotka-Volterra (predador-presa): dy1/dt = a y1 - b y1 y2, dy2/dt = -c y2 + d y1 y2 com a=1, b=0.5, c=1.5, d=0.5, y_init=[10,5], h=0.01, t_final=20. Plote ou liste y(t) para verificar oscilações populacionais.",
                              "finalVerifications": [
                                "Pseudocódigo executa sem erros lógicos para m=2",
                                "Recupera RK4 escalar quando m=1",
                                "Trajetória para exemplo prático converge para solução conhecida",
                                "Análise de custo confirma O(m) por passo com laços explícitos",
                                "Todos k_i têm dimensão m e update preserva norma vetorial",
                                "Loop temporal para sem overflow para t_final razoável"
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas vetoriais dos k_i (peso correto 1:2:2:1 normalizado)",
                                "Uso correto de laços sobre m componentes em f e operações",
                                "Implementação completa do loop temporal com t += h",
                                "Análise de complexidade detalhada e precisa O(m) por passo",
                                "Tratamento de vetores em todos estágios sem escalarização",
                                "Verificações internas e testes com m variável"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução numérica de EDOs lineares/não-lineares",
                                "Física: Simulação de sistemas dinâmicos como osciladores acoplados",
                                "Engenharia: Controle de sistemas e trajetórias em robótica",
                                "Biologia: Modelos ecológicos e epidemiológicos (SIR)",
                                "Economia: Dinâmica de mercados com múltiplas variáveis"
                              ],
                              "realWorldApplication": "Simulações de dinâmica orbital em engenharia aeroespacial (NASA trajectories), modelagem climática com variáveis atmosféricas múltiplas, previsão de epidemias (COVID models com compartimentos populacionais), e controle de processos químicos em indústrias."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Analisar precisão e estabilidade do RK4",
                            "description": "Comparar erros local e global do RK4 vs. RK2, discutir regiões de estabilidade absoluta e prática para equações lineares, e condições para escolha de h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Erros Local e Global em Métodos Runge-Kutta",
                                  "subSteps": [
                                    "Defina erro local como o erro introduzido em um único passo de integração.",
                                    "Defina erro global como o erro acumulado ao longo de múltiplos passos até o tempo final.",
                                    "Revise a expansão em série de Taylor para derivar o erro local de ordem p em métodos RK.",
                                    "Compare ordens de precisão: RK2 (ordem 2) vs. RK4 (ordem 4).",
                                    "Estude fórmulas explícitas para truncamento em RK2 e RK4."
                                  ],
                                  "verification": "Escreva as expressões matemáticas para erro local de RK2 e RK4 e explique a diferença em precisão.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Livro 'Numerical Analysis' de Burden & Faires",
                                    "Notas de aula sobre métodos RK",
                                    "Papel e caneta ou software como Jupyter Notebook"
                                  ],
                                  "tips": "Use séries de Taylor para visualizar como termos de ordem superior são cancelados em RK4.",
                                  "learningObjective": "Compreender a distinção e derivação de erros local e global em RK2 e RK4.",
                                  "commonMistakes": [
                                    "Confundir erro local (por passo) com global (acumulado)",
                                    "Esquecer que erro global é aproximadamente erro local vezes número de passos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar Precisão de RK2 e RK4 Através de Análise de Erros",
                                  "subSteps": [
                                    "Derive o erro local para RK2: O(h^3) e para RK4: O(h^5).",
                                    "Calcule erro global: O(h^2) para RK2 e O(h^4) para RK4.",
                                    "Implemente numéricamente RK2 e RK4 para uma EDO teste (ex: y' = y, solução exata conhecida).",
                                    "Plote erros em função de h para ambos métodos.",
                                    "Analise numericamente a convergência e compare taxas esperadas."
                                  ],
                                  "verification": "Gere gráficos mostrando que erro de RK4 diminui 16x quando h é halved (consistente com ordem 4).",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib ou MATLAB",
                                    "Código template para solvers RK"
                                  ],
                                  "tips": "Use solução exata para computar erros absolutos; teste com h variando de 0.1 a 0.01.",
                                  "learningObjective": "Comparar quantitativamente a precisão superior do RK4 sobre RK2.",
                                  "commonMistakes": [
                                    "Não usar escala log-log nos gráficos para visualizar ordens de convergência",
                                    "Escolher EDOs rígidas onde RK4 ainda falha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Regiões de Estabilidade Absoluta",
                                  "subSteps": [
                                    "Defina estabilidade absoluta para o teste modelo y' = λy (λ real negativo).",
                                    "Derive a condição de estabilidade para RK2 e RK4: |R(z)| ≤ 1 onde z = hλ.",
                                    "Plote os polinômios de estabilidade R(z) para RK2 e RK4 no plano complexo.",
                                    "Compare áreas das regiões de estabilidade: RK4 tem região maior no eixo imaginário.",
                                    "Discuta implicações para problemas oscilatórios."
                                  ],
                                  "verification": "Desenhe ou plote as regiões de estabilidade e identifique que RK4 permite |Im(z)| até ~2.8 vs ~1.4 para RK2.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Software de plotagem como Python (Matplotlib) ou MATLAB",
                                    "Tabelas de coeficientes Butcher para RK2/RK4"
                                  ],
                                  "tips": "Foquem em z no semiplano esquerdo; use |R(iy)| para estabilidade em osciladores.",
                                  "learningObjective": "Identificar e comparar regiões de estabilidade absoluta de RK2 e RK4.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com prática",
                                    "Ignorar parte imaginária para EDOs lineares reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Estabilidade Prática para Equações Lineares",
                                  "subSteps": [
                                    "Explique estabilidade prática como comportamento assintótico para passos pequenos.",
                                    "Para y' = λy, derive condições h < 2/|λ| para RK4 em casos reais.",
                                    "Simule EDOs lineares com autovalores complexos e observe damping vs. oscilação.",
                                    "Compare RK2 e RK4 em termos de passos permitidos antes da instabilidade.",
                                    "Analise trade-off precisão vs. estabilidade ao variar h."
                                  ],
                                  "verification": "Simule até t=10 com h grande; RK4 permanece estável enquanto RK2 diverge.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Códigos Python/MATLAB para simulações lineares",
                                    "Exemplos de EDOs como damped harmonic oscillator"
                                  ],
                                  "tips": "Monitore norma da solução numérica vs. analítica para detectar instabilidade precoce.",
                                  "learningObjective": "Avaliar estabilidade prática de RK4 vs. RK2 em equações lineares reais.",
                                  "commonMistakes": [
                                    "Assumir estabilidade absoluta = prática sem simulações",
                                    "Não testar com autovalores próximos à fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Determinar Condições para Escolha do Passo h",
                                  "subSteps": [
                                    "Estabeleça critérios: erro global desejado < ε implica h ~ ε^{1/4} para RK4.",
                                    "Combine com estabilidade: h < min(2/|λ_max|, h_precisão).",
                                    "Desenvolva heurística adaptativa baseada em erros locais estimados.",
                                    "Teste em EDO exemplo: ajuste h para equilíbrio precisão-estabilidade.",
                                    "Discuta quando usar RK4 vs. métodos implícitos para problemas rígidos."
                                  ],
                                  "verification": "Para uma EDO dada, escolha h tal que erro < 10^{-6} e solução estável por t=20.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Solver adaptativo como ode45 em MATLAB ou solve_ivp em SciPy",
                                    "Planilhas para estimar h"
                                  ],
                                  "tips": "Comece com h conservador e refine; monitore ambos erros e estabilidade.",
                                  "learningObjective": "Definir regras práticas para selecionar h otimizado em RK4.",
                                  "commonMistakes": [
                                    "Escolher h só por precisão ignorando estabilidade",
                                    "Não considerar rigidez da EDO"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente RK2 e RK4 em Python para resolver o oscilador harmônico amortecido y'' + 2y' + 2y = 0 (convertido em sistema de primeira ordem). Use h=0.1 e h=0.5, compare soluções com exata, plote erros e observe quando RK2 torna-se instável enquanto RK4 permanece preciso.",
                              "finalVerifications": [
                                "Derivação correta de erros local/global para RK4 vs. RK2.",
                                "Gráficos precisos de regiões de estabilidade.",
                                "Simulações numéricas mostrando superioridade de RK4.",
                                "Heurística explícita para escolha de h baseada em ε e λ.",
                                "Explicação clara de trade-offs em problemas lineares.",
                                "Identificação correta de cenários onde RK4 é preferível."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações de erros (ordens corretas).",
                                "Qualidade dos plots e análises numéricas (escalas adequadas, convergência).",
                                "Compreensão profunda de estabilidade absoluta vs. prática.",
                                "Regras práticas para h bem fundamentadas e testadas.",
                                "Análise comparativa clara RK2 vs. RK4.",
                                "Uso correto de terminologia numérica."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações dinâmicas e oscilações em mecânica.",
                                "Engenharia: Controle de sistemas lineares e estabilidade.",
                                "Matemática Pura: Análise de séries e polinômios de estabilidade.",
                                "Ciência de Dados: Otimização de solvers em machine learning para EDOs.",
                                "Finanças: Modelagem de processos estocásticos aproximados por determinísticos."
                              ],
                              "realWorldApplication": "Na simulação de trajetórias de foguetes da NASA (onde estabilidade permite h maiores, reduzindo tempo computacional), modelagem climática (ODEs rígidas para oceanos), e finanças quantitativas (preços de opções via PDEs reduzidas a ODEs), garantindo previsões precisas sem divergência numérica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.4",
                            "name": "Comparar RK com outros métodos numéricos",
                            "description": "Discutir vantagens do RK4 sobre Euler e RK2 em termos de precisão vs. custo computacional, citando referências como Cormen para análise geral de algoritmos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos dos Métodos Euler, RK2 e RK4",
                                  "subSteps": [
                                    "Estude a fórmula do método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Analise o método RK2 (Heun's method): k1 = f(t_n, y_n), k2 = f(t_n + h, y_n + h k1), y_{n+1} = y_n + (h/2)(k1 + k2).",
                                    "Examine o RK4: k1 = f(t_n, y_n), k2 = f(t_n + h/2, y_n + h/2 k1), k3 = f(t_n + h/2, y_n + h/2 k2), k4 = f(t_n + h, y_n + h k3), y_{n+1} = y_n + (h/6)(k1 + 2k2 + 2k3 + k4).",
                                    "Identifique as ordens de precisão: Euler O(h^2), RK2 O(h^3), RK4 O(h^5).",
                                    "Implemente um exemplo simples em Python para cada método."
                                  ],
                                  "verification": "Implemente e execute códigos para os três métodos em uma EDO teste (ex: dy/dt = -y, y(0)=1) e compare saídas iniciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to Algorithms' de Cormen (Capítulo 29 para análise numérica), Jupyter Notebook, Python com NumPy.",
                                  "tips": "Use h pequeno (0.1) para visualizar diferenças iniciais.",
                                  "learningObjective": "Compreender as fórmulas e implementações básicas dos métodos.",
                                  "commonMistakes": "Confundir os k's no RK4 ou usar passos h inconsistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Precisão de Cada Método",
                                  "subSteps": [
                                    "Calcule o erro local de truncamento: Euler O(h^2), RK2 O(h^3), RK4 O(h^5).",
                                    "Compare erros globais teóricos para intervalos fixos.",
                                    "Execute simulações numéricas variando h e meça erros contra solução exata.",
                                    "Plote gráficos de erro vs. h em escala log-log para confirmar ordens.",
                                    "Discuta como ordem maior implica precisão superior para mesmo h."
                                  ],
                                  "verification": "Gere plots mostrando convergência: inclinação da reta deve matching ordens teóricas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/Matplotlib, solução exata da EDO (ex: y = e^{-t}), Cormen para teoria de erros.",
                                  "tips": "Use solução exata y(t) = exp(-t) para benchmark fácil.",
                                  "learningObjective": "Quantificar precisão através de análise teórica e empírica.",
                                  "commonMistakes": "Ignorar erros de arredondamento em h muito pequenos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar o Custo Computacional",
                                  "subSteps": [
                                    "Conte avaliações de f por passo: Euler=1, RK2=2, RK4=4.",
                                    "Meça tempo de execução para N passos iguais.",
                                    "Calcule custo total: custo_por_passo * N, considerando h fixo.",
                                    "Analise trade-off: para mesma precisão, quantos passos cada método precisa?",
                                    "Cite Cormen (Capítulo 3-4) para análise de complexidade em algoritmos iterativos."
                                  ],
                                  "verification": "Tabela comparativa: custo RK4 vs. Euler para erro < 10^{-4}.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python com timeit, Cormen para Big-O em loops.",
                                  "tips": "Fixe erro alvo e ajuste h/N para fair comparison.",
                                  "learningObjective": "Quantificar custo em termos de operações e tempo.",
                                  "commonMistakes": "Comparar com h diferentes sem normalizar erro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Vantagens do RK4 e Discutir Referências",
                                  "subSteps": [
                                    "Resuma: RK4 tem precisão O(h^5) com custo 4x Euler, mas vale para precisão alta.",
                                    "Discuta cenários: Euler para quick prototypes, RK4 para produção.",
                                    "Cite Cormen para análise geral: trade-offs precisão-complexidade em numéricos.",
                                    "Compare estabilidade: RK4 mais estável que Euler para stiff equations.",
                                    "Escreva um relatório curto com tabela de prós/contras."
                                  ],
                                  "verification": "Relatório de 1 página explicando quando usar cada método.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Cormen (seções relevantes), papel/notas.",
                                  "tips": "Use tabela: Método | Ordem | Avaliações | Uso Ideal.",
                                  "learningObjective": "Sintetizar vantagens RK4 em precisão vs. custo.",
                                  "commonMistakes": "Superestimar custo RK4 sem considerar h menor necessário em outros."
                                }
                              ],
                              "practicalExample": "Resolva dy/dt = y(1-y), y(0)=0.5 (modelo logístico) até t=5 com h=0.1. Compare soluções numéricas de Euler, RK2, RK4 contra exata (aprox. sigmoid). RK4 converge mais rápido, mostrando superioridade em precisão com custo moderado.",
                              "finalVerifications": [
                                "Explicar verbalmente por que RK4 é preferido em simulações precisas.",
                                "Apresentar plots de erro vs. h para os três métodos.",
                                "Citar pelo menos duas referências de Cormen sobre análise numérica.",
                                "Calcular custo relativo para atingir erro 10^{-6}.",
                                "Discutir um caso onde Euler falha (ex: oscilador harmônico).",
                                "Implementar código híbrido adaptativo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ordens de erro (O(h^2), O(h^3), O(h^5)).",
                                "Correta contagem de avaliações de função por passo.",
                                "Uso de evidências empíricas (plots/tempos) além de teoria.",
                                "Referências adequadas a Cormen e análise de trade-offs.",
                                "Clareza na discussão de vantagens/desvantagens contextuais.",
                                "Capacidade de generalizar para outros algoritmos numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Equações Diferenciais.",
                                "Física: Simulações dinâmicas (ex: trajetórias em mecânica).",
                                "Engenharia: Modelagem de sistemas (controle, fluidos).",
                                "Machine Learning: Otimização gradiente descendente como Euler discreto."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias espaciais (NASA usa RK4 para precisão em órbitas), previsão climática (onde custo computacional é alto, mas precisão crítica), e jogos/física engines (Unity/Unreal balanceiam Euler rápido vs. RK4 preciso)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Gradiente Descendente",
                    "description": "Algoritmo de otimização para minimização de funções multivariáveis, incluindo variantes com momento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Fundamentos do Gradiente Descendente",
                        "description": "Conceitos básicos do algoritmo de Gradiente Descendente para minimização de funções contínuas e diferenciáveis multivariáveis, incluindo a intuição geométrica e o processo iterativo de atualização de parâmetros.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Entender o problema de otimização não linear",
                            "description": "Identificar funções de perda multivariáveis convexas e não convexas, e explicar por que o Gradiente Descendente é usado para encontrar mínimos locais através de descidas na direção oposta ao gradiente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Otimização Não Linear",
                                  "subSteps": [
                                    "Defina otimização não linear como a minimização ou maximização de funções onde a relação entre variáveis não é linear.",
                                    "Estude funções multivariáveis, como f(x, y) = x² + y² + sin(xy), e identifique componentes não lineares.",
                                    "Revise conceitos de mínimo global vs. mínimo local em paisagens de funções não lineares.",
                                    "Explore o papel das funções de perda em machine learning como exemplos de otimização não linear.",
                                    "Pratique com gráficos 2D/3D de funções simples não lineares usando ferramentas como Python Matplotlib."
                                  ],
                                  "verification": "Crie um gráfico de uma função não linear multivariável e rotule mínimos locais e globais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notebook Jupyter ou Python IDE",
                                    "Bibliotecas: NumPy, Matplotlib",
                                    "Tutoriais online sobre plotting de superfícies"
                                  ],
                                  "tips": "Comece com funções 2D para visualização intuitiva antes de ir para 3D.",
                                  "learningObjective": "Identificar e descrever problemas de otimização não linear em contextos multivariáveis.",
                                  "commonMistakes": [
                                    "Confundir linear com não linear; assumir que todas as funções de perda são convexas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Funções Convexas e Não Convexas",
                                  "subSteps": [
                                    "Defina convexidade: uma função f é convexa se para qualquer x, y e λ ∈ [0,1], f(λx + (1-λ)y) ≤ λf(x) + (1-λ)f(y).",
                                    "Identifique exemplos: f(x) = x² (convexa), f(x) = sin(x) (não convexa).",
                                    "Para multivariáveis, use a Hessiana: positiva semi-definida para convexidade.",
                                    "Classifique funções de perda comuns: MSE em regressão linear (convexa), perda em redes neurais profundas (não convexa).",
                                    "Plote e compare gráficos de funções convexas (bowl-shaped) vs. não convexas (múltiplos vales)."
                                  ],
                                  "verification": "Classifique 3 funções multivariáveis como convexas ou não convexas e justifique com Hessiana ou gráfico.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "SymPy ou calculadora simbólica para Hessiana",
                                    "Gráficos interativos via Plotly",
                                    "Exercícios de convexidade em Khan Academy"
                                  ],
                                  "tips": "Use a linha reta teste: se a função acima da corda, é convexa.",
                                  "learningObjective": "Distinguir precisamente funções convexas de não convexas em contextos de perda multivariáveis.",
                                  "commonMistakes": [
                                    "Ignorar a Hessiana em dimensões altas; confundir unimodal com convexa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Gradiente em Otimização Não Linear",
                                  "subSteps": [
                                    "Defina o gradiente ∇f como vetor de derivadas parciais, apontando direção de maior aumento.",
                                    "Explique geometricamente: direção oposta ao gradiente é de descida mais íngreme.",
                                    "Calcule gradientes para funções multivariáveis, ex: ∇f(x,y) = (2x, 2y) para f(x,y)=x²+y².",
                                    "Discuta magnitude do gradiente: indica inclinação; zero em pontos críticos (mínimos, máximos, selas).",
                                    "Visualize setas de gradiente em superfícies plotadas para entender fluxo de descida."
                                  ],
                                  "verification": "Compute o gradiente de uma função não linear dada e trace vetores em pontos específicos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com NumPy para gradientes numéricos",
                                    "Quiver plots no Matplotlib",
                                    "Calculadora de derivadas simbólicas"
                                  ],
                                  "tips": "Pense no gradiente como 'subida mais íngreme em uma montanha'; oposto para descida.",
                                  "learningObjective": "Calcular e interpretar o gradiente como direção para mínimos locais.",
                                  "commonMistakes": [
                                    "Confundir gradiente com direção de descida; ignorar sinal negativo na atualização."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o Uso do Gradiente Descendente para Mínimos Locais",
                                  "subSteps": [
                                    "Descreva o algoritmo GD: x_{t+1} = x_t - η ∇f(x_t), onde η é learning rate.",
                                    "Explique convergência para mínimos locais em não convexas (não garante global).",
                                    "Discuta por que GD é prático: iterativo, escalável para altas dimensões.",
                                    "Compare com métodos exatos (impraticáveis em não convexas) e variantes como SGD.",
                                    "Simule iterações GD em uma função não convexa e observe convergência a mínimo local."
                                  ],
                                  "verification": "Implemente GD simples em Python para uma função não convexa e demonstre convergência.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código Python template para GD",
                                    "Função teste: Rosenbrock",
                                    "Jupyter para simulações animadas"
                                  ],
                                  "tips": "Escolha η pequeno inicialmente para evitar overshooting; monitore ||∇f|| para parada.",
                                  "learningObjective": "Justificar GD como método para encontrar mínimos locais via descidas opostas ao gradiente.",
                                  "commonMistakes": [
                                    "Escolher η muito grande causando divergência; assumir convergência global."
                                  ]
                                }
                              ],
                              "practicalExample": "Em treinamento de uma rede neural para classificação de imagens, a função de perda cross-entropy é não convexa multivariável. Use GD para iterativamente ajustar pesos na direção oposta ao gradiente, convergindo a um mínimo local que minimiza erros de predição.",
                              "finalVerifications": [
                                "Classifique corretamente 5 funções de perda como convexas ou não convexas.",
                                "Compute e interprete gradiente em uma função 2D não linear.",
                                "Explique verbalmente por que GD encontra mínimos locais, não globais.",
                                "Implemente GD para otimizar uma função simples e plote trajetória.",
                                "Identifique pontos críticos (gradiente zero) em paisagem não convexa.",
                                "Diferencie GD de métodos como Newton's em contextos não convexos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de convexidade (Hessiana ou teste gráfico).",
                                "Correta interpretação geométrica do gradiente e direção de descida.",
                                "Explicação clara de convergência local do GD com exemplos.",
                                "Implementação funcional de GD com convergência demonstrada.",
                                "Uso apropriado de termos técnicos (ex: gradiente, Hessiana, learning rate).",
                                "Capacidade de relacionar a otimização não linear a ML prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e análise convexa.",
                                "Física: Minimização de energia potencial em sistemas dinâmicos.",
                                "Economia: Otimização de utilidade em modelos não lineares.",
                                "Engenharia: Controle ótimo em sistemas não lineares."
                              ],
                              "realWorldApplication": "No machine learning, GD otimiza redes neurais profundas para tarefas como reconhecimento facial (ex: FaceID), onde perdas não convexas levam a mínimos locais que ainda produzem modelos de alta performance em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Calcular o gradiente de uma função multivariável",
                            "description": "Computar o vetor gradiente ∂J(θ)/∂θ para uma função custo J(θ) com múltiplas variáveis θ, utilizando derivadas parciais e regras de cálculo diferencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de gradiente e derivadas parciais",
                                  "subSteps": [
                                    "Defina o gradiente como o vetor das derivadas parciais de uma função escalar J(θ) em relação a cada variável θ_i.",
                                    "Revise a notação: ∇J(θ) = [∂J/∂θ₁, ∂J/∂θ₂, ..., ∂J/∂θₙ]ᵀ.",
                                    "Explique derivada parcial: trata outras variáveis como constantes.",
                                    "Estude regras básicas: potência, produto, cadeia para multivariáveis.",
                                    "Pratique com função univariável para transição suave."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é o gradiente e dê um exemplo simples de derivada parcial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Calculadora simbólica (opcional)",
                                    "Referência: Khan Academy - Derivadas Parciais"
                                  ],
                                  "tips": "Visualize o gradiente como direção de maior aumento da função usando setas em gráfico 3D.",
                                  "learningObjective": "Compreender a definição e notação do gradiente multivariável.",
                                  "commonMistakes": [
                                    "Confundir derivada total com parcial",
                                    "Esquecer o transposto no vetor coluna"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a função custo e suas variáveis",
                                  "subSteps": [
                                    "Leia a função J(θ) e liste todas as variáveis independentes θ = [θ₁, θ₂, ..., θₙ].",
                                    "Escreva a função explicitamente, destacando termos dependentes de cada θ_i.",
                                    "Verifique se a função é diferenciável (suave, sem quebras).",
                                    "Anote o domínio e possíveis restrições.",
                                    "Desenhe um esboço gráfico se n=2 para intuição visual."
                                  ],
                                  "verification": "Liste corretamente todas as variáveis e reescreva J(θ) de forma clara.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como Desmos ou GeoGebra para plotar (opcional)"
                                  ],
                                  "tips": "Sempre expresse θ como vetor coluna para consistência com ML.",
                                  "learningObjective": "Preparar a função para computação de derivadas parciais.",
                                  "commonMistakes": [
                                    "Ignorar variáveis constantes",
                                    "Confundir parâmetros com dados de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as derivadas parciais individuais",
                                  "subSteps": [
                                    "Para cada θ_i, isole termos que dependem de θ_i e trate outros como constantes.",
                                    "Aplique regras de derivação: ∂/∂θ_i (θ_i^k) = k θ_i^{k-1}, ∂/∂θ_i (f*g) = (∂f/∂θ_i)g + f(∂g/∂θ_i).",
                                    "Use regra da cadeia se houver composição: ∂/∂θ_i (f(g(θ))) = f'(g) * ∂g/∂θ_i.",
                                    "Simplifique a expressão algébrica resultante.",
                                    "Verifique dimensionalidade: cada ∂J/∂θ_i deve ser escalar."
                                  ],
                                  "verification": "Compute ∂J/∂θ_i para cada i e confira com simplificação simbólica (ex: SymPy).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "SymPy ou Wolfram Alpha para verificação",
                                    "Folha de fórmulas de cálculo"
                                  ],
                                  "tips": "Derive uma parcial por vez para evitar confusão; anote 'holding others constant'.",
                                  "learningObjective": "Dominar o cálculo de derivadas parciais em funções multivariáveis.",
                                  "commonMistakes": [
                                    "Derivar em relação à variável errada",
                                    "Esquecer fator na regra da cadeia"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e verificar o vetor gradiente",
                                  "subSteps": [
                                    "Colete todas as ∂J/∂θ_i em um vetor: ∇J(θ) = [...].",
                                    "Escreva na forma matricial ou vetor coluna.",
                                    "Substitua valores numéricos de θ para testar (se aplicável).",
                                    "Verifique propriedades: gradiente linear para funções quadráticas.",
                                    "Compare com gradiente analítico conhecido para funções padrão."
                                  ],
                                  "verification": "O vetor ∇J(θ) tem tamanho n e componentes corretas; teste numérico coincide.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora numérica",
                                    "Exemplo de função quadrática conhecida"
                                  ],
                                  "tips": "Sempre teste com θ=0 ou valores simples para sanity check.",
                                  "learningObjective": "Construir o gradiente completo e validar.",
                                  "commonMistakes": [
                                    "Ordem errada das componentes",
                                    "Confundir linha com coluna"
                                  ]
                                }
                              ],
                              "practicalExample": "Para J(θ₀, θ₁) = θ₀² + θ₁² + 2θ₀θ₁, calcule ∇J(θ) = [2θ₀ + 2θ₁, 2θ₁ + 2θ₀]ᵀ. Em θ=[1,1], ∇J=[4,4]ᵀ, apontando para aumento da função.",
                              "finalVerifications": [
                                "Calcula corretamente ∇J para função quadrática bivariável.",
                                "Identifica e corrige erros em derivadas parciais dadas.",
                                "Explica o significado físico do gradiente em otimização.",
                                "Aplica a um exemplo com 3 variáveis sem hesitação.",
                                "Verifica numericamente com aproximação de diferenças finitas.",
                                "Montar gradiente para função logística multivariável."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivadas parciais (100% correto).",
                                "Simplificação algébrica completa e elegante.",
                                "Uso correto de notação vetorial.",
                                "Validação com testes numéricos ou simbólicos.",
                                "Explicação clara do processo passo a passo.",
                                "Tratamento de regras avançadas (cadeia, produto) sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Física: Gradiente como força em campos escalares (potencial elétrico).",
                                "Machine Learning: Otimização de redes neurais via backpropagation.",
                                "Economia: Gradientes em funções de utilidade multivariável.",
                                "Engenharia: Análise de sensibilidade em simulações.",
                                "Estatística: Maximum likelihood estimation em modelos paramétricos."
                              ],
                              "realWorldApplication": "Em machine learning, calcular o gradiente de funções de custo como MSE ou cross-entropy permite o gradiente descendente otimizar parâmetros de modelos, treinando redes neurais para reconhecimento de imagens ou previsão de séries temporais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Descrever o algoritmo iterativo básico",
                            "description": "Explicar o loop principal do Gradiente Descendente: inicialização de θ, cálculo do gradiente, atualização θ := θ - α * ∇J(θ), onde α é a taxa de aprendizado, e critérios de parada como número de iterações ou tolerância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Descrever a Inicialização dos Parâmetros θ e α",
                                  "subSteps": [
                                    "Defina θ como o vetor de parâmetros do modelo a ser otimizado.",
                                    "Explique métodos comuns de inicialização de θ, como valores zero, aleatórios pequenos ou Xavier/He initialization.",
                                    "Descreva α (taxa de aprendizado) como o passo de atualização e sugira valores iniciais típicos (ex: 0.01).",
                                    "Especifique variáveis de controle como número máximo de iterações (max_iter) e tolerância (tol).",
                                    "Escreva pseudocódigo para a seção de inicialização."
                                  ],
                                  "verification": "Escreva um snippet de pseudocódigo da inicialização e explique verbalmente sua importância.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para pseudocódigo",
                                    "Notebook Jupyter com Python básico",
                                    "Documentação de bibliotecas como NumPy"
                                  ],
                                  "tips": "Use valores pequenos para inicialização aleatória para evitar divergência.",
                                  "learningObjective": "Explicar com precisão a fase de setup do algoritmo GD, incluindo escolhas iniciais críticas.",
                                  "commonMistakes": "Inicializar θ com valores muito grandes, levando a gradientes explosivos; confundir α com o gradiente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Cálculo do Gradiente ∇J(θ)",
                                  "subSteps": [
                                    "Recapitule J(θ) como a função custo (ex: erro quadrático médio).",
                                    "Derive ou lembre a fórmula do gradiente: ∇J(θ) = (1/m) * Σ (hθ(x) - y) * x para regressão linear.",
                                    "Implemente computacionalmente o gradiente usando derivadas parciais.",
                                    "Discuta aproximações como gradiente numérico para funções não diferenciáveis.",
                                    "Teste o cálculo com um exemplo numérico simples (ex: J(θ) = θ², ∇J = 2θ)."
                                  ],
                                  "verification": "Calcule manualmente ∇J para θ=5 em J(θ)=θ² e verifique com código Python.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python com NumPy",
                                    "Função custo de exemplo em Jupyter"
                                  ],
                                  "tips": "Sempre normalize features para gradientes estáveis.",
                                  "learningObjective": "Dominar o conceito e cálculo preciso do gradiente como direção de maior aumento de J(θ).",
                                  "commonMistakes": "Confundir sinal do gradiente (deve apontar para aumento); ignorar fator 1/m em médias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a Atualização Iterativa θ := θ - α * ∇J(θ)",
                                  "subSteps": [
                                    "Explique a regra de atualização como movimento oposto ao gradiente.",
                                    "Implemente a linha de código/pseudocódigo para a atualização.",
                                    "Escolha e justifique α (ex: pequena para precisão, grande para velocidade).",
                                    "Simule 3-5 iterações manualmente em um exemplo 1D.",
                                    "Visualize a convergência com gráfico de θ vs iterações."
                                  ],
                                  "verification": "Execute 10 iterações em código e plote a trajetória de θ.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "Exemplo de dataset simples (ex: housing prices)"
                                  ],
                                  "tips": "Monitore ||∇J|| para ajustar α dinamicamente.",
                                  "learningObjective": "Articular e demonstrar a mecânica central da descida no landscape de J(θ).",
                                  "commonMistakes": "Usar sinal errado (+ em vez de -); α muito alta causando overshooting e divergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever os Critérios de Parada e Estrutura do Loop Principal",
                                  "subSteps": [
                                    "Defina critérios: max_iter atingido ou ||∇J(θ)|| < tol.",
                                    "Estruture o loop while: calcular gradiente, atualizar, checar parada.",
                                    "Adicione logging de J(θ) por iteração para monitoramento.",
                                    "Implemente o loop completo em pseudocódigo e código.",
                                    "Teste com cenários de convergência e não-convergência."
                                  ],
                                  "verification": "Escreva e execute o algoritmo completo, confirmando parada correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Jupyter Notebook completo",
                                    "Gráficos de convergência"
                                  ],
                                  "tips": "Use tol ~1e-6; sempre inclua max_iter para evitar loops infinitos.",
                                  "learningObjective": "Completar a descrição do GD como algoritmo iterativo finito e convergente.",
                                  "commonMistakes": "Esquecer critério de tolerância, levando a iterações desnecessárias; loop sem atualização."
                                }
                              ],
                              "practicalExample": "Para minimizar J(θ) = θ² com θ inicial=10, α=0.1: Inicialize θ=10; it1: ∇J=20, θ=10-0.1*20=8; it2: ∇J=16, θ=8-1.6=6.4; continue até |∇J|<0.01 (~45 iterações). Implemente em Python: def gd(): ... e plote J(θ).",
                              "finalVerifications": [
                                "Liste corretamente os 4 componentes principais do loop GD.",
                                "Descreva a fórmula exata de atualização com notação matemática.",
                                "Explique impacto de α alta/baixa com exemplo numérico.",
                                "Implemente GD em Python para J(θ)=(θ-5)² e atinja erro <1e-3.",
                                "Compare pseudocódigo com implementação real.",
                                "Identifique parada prematura em um log de iterações.",
                                "Desenhe diagrama de fluxo do algoritmo."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas fórmulas (∇J e update).",
                                "Clareza e sequencialidade na descrição do loop.",
                                "Correção na implementação prática (convergência comprovada).",
                                "Explicação de hiperparâmetros (α, tol, max_iter).",
                                "Uso de notação padrão e exemplos concretos.",
                                "Identificação de pitfalls como divergência.",
                                "Visualizações ou simulações incluídas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e otimização convexa.",
                                "Física: Dinâmica de partículas em potenciais (análoga a forças).",
                                "Estatística: Minimização de funções de perda em inferência bayesiana.",
                                "Engenharia de Software: Implementação eficiente de loops numéricos.",
                                "Economia: Otimização de utilidade e custos em modelos econométricos."
                              ],
                              "realWorldApplication": "O GD básico é a base para treinar modelos de IA como o GPT, ajustando milhões de parâmetros em chatbots; usado no Netflix para recomendação de filmes via minimização de erro de predição."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Implementação e Parâmetros do Gradiente Descendente Batch",
                        "description": "Versão batch do algoritmo, onde o gradiente é calculado sobre todo o conjunto de dados, incluindo escolha e impacto de hiperparâmetros como taxa de aprendizado.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Implementar pseudocódigo do GD Batch",
                            "description": "Escrever pseudocódigo completo para Gradiente Descendente Batch, incluindo inicialização aleatória de parâmetros, loop de épocas, computação média do gradiente sobre m exemplos e atualização simultânea.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e Inicializar Componentes Básicos do Pseudocódigo",
                                  "subSteps": [
                                    "Identifique os elementos essenciais: parâmetros θ (vetor de pesos), learning rate α, número de épocas num_epochs, dataset com m exemplos (X, y).",
                                    "Escreva a inicialização de θ com valores aleatórios pequenos (ex: θ = rand(m+1,1) * 0.01).",
                                    "Defina hiperparâmetros: α = 0.01, num_epochs = 1000, custo J para monitoramento opcional.",
                                    "Especifique a função de custo, como J(θ) = (1/(2m)) * sum((hθ(x) - y)^2) para regressão linear.",
                                    "Declare variáveis auxiliares como gradiente_acumulado = zeros(size(θ))."
                                  ],
                                  "verification": "Verifique se todas as variáveis estão declaradas corretamente e θ é inicializado aleatoriamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto simples",
                                    "Referência: Notas sobre Gradiente Descendente"
                                  ],
                                  "tips": "Use inicialização aleatória pequena para evitar problemas de escala; evite zero.",
                                  "learningObjective": "Compreender e codificar a configuração inicial do algoritmo GD Batch.",
                                  "commonMistakes": [
                                    "Inicializar θ com zeros (pode levar a mínimos locais ruins)",
                                    "Esquecer de incluir bias (θ0)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar o Loop Principal de Épocas",
                                  "subSteps": [
                                    "Inicie o loop: for epoch = 1 to num_epochs",
                                    "Dentro do loop, inicialize gradiente_acumulado = zeros(size(θ)) para cada época.",
                                    "Planeje o cálculo do gradiente médio sobre todos os m exemplos dentro deste loop.",
                                    "Adicione uma condição opcional de parada baseada em convergência de J(θ).",
                                    "Feche o loop após todas as épocas ou condição de parada."
                                  ],
                                  "verification": "Confirme que o loop itera num_epochs vezes e reseta acumuladores por época.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo de pseudocódigo de loops simples"
                                  ],
                                  "tips": "Sempre resete o acumulador por época para garantir batch fresco.",
                                  "learningObjective": "Implementar a iteração principal do treinamento em GD Batch.",
                                  "commonMistakes": [
                                    "Não resetar gradiente_acumulado por época (acumula gradientes errados)",
                                    "Confundir loop de épocas com loop de batch"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar Gradientes Individuais e Acumular Média",
                                  "subSteps": [
                                    "Dentro do loop de épocas, inicie um loop interno: for i = 1 to m",
                                    "Para cada exemplo i: calcule predição hθ(xi) = θ^T * xi",
                                    "Calcule erro = hθ(xi) - yi",
                                    "Compute gradiente individual: grad_i = (1/m) * erro * xi",
                                    "Some ao acumulador: gradiente_acumulado += grad_i",
                                    "Após todos os i, o gradiente médio já está em gradiente_acumulado por fator 1/m."
                                  ],
                                  "verification": "Verifique se o loop interno processa todos m exemplos e acumula corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fórmula de gradiente para regressão linear: ∂J/∂θj = (1/m) sum (hθ(x)-y) xj"
                                  ],
                                  "tips": "Garanta que xi inclua o termo 1 para bias; use vetorização conceitual.",
                                  "learningObjective": "Calcular o gradiente médio batch corretamente via acumulação.",
                                  "commonMistakes": [
                                    "Fator 1/m fora do loop (errado, deve ser dentro para cada grad_i)",
                                    "Esquecer de multiplicar por xi no gradiente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Atualizar Parâmetros e Finalizar o Pseudocódigo",
                                  "subSteps": [
                                    "Após o loop interno, atualize simultaneamente: θ = θ - α * gradiente_acumulado",
                                    "Opcionalmente, compute J(θ) para logging ou convergência: if |J_new - J_old| < epsilon, break",
                                    "Após o loop de épocas, retorne θ final",
                                    "Adicione comentários explicando cada seção para clareza.",
                                    "Teste mentalmente com m=1 (deve reduzir a GD Estocástico)."
                                  ],
                                  "verification": "Simule uma iteração manual para confirmar atualização simultânea.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora para simulação manual de 1-2 iterações"
                                  ],
                                  "tips": "Atualização simultânea: use cópia do gradiente, não atualize θ on-the-fly.",
                                  "learningObjective": "Completar o ciclo de otimização com atualização batch.",
                                  "commonMistakes": [
                                    "Atualizar θ dentro do loop de m (torna estocástico)",
                                    "Esquecer fator 1/m na média"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Revisar e Refinar o Pseudocódigo Completo",
                                  "subSteps": [
                                    "Leia o pseudocódigo inteiro e verifique fluxo lógico.",
                                    "Adicione tratamento de edge cases: m=0, α muito grande.",
                                    "Inclua pseudocódigo para função de hipótese hθ(x).",
                                    "Formate com indentação clara e comentários inline.",
                                    "Compare com referência padrão de GD Batch."
                                  ],
                                  "verification": "Pseudocódigo roda logicamente sem erros de sintaxe conceitual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo de referência de GD Batch"
                                  ],
                                  "tips": "Use pseudocódigo legível, não código real ainda.",
                                  "learningObjective": "Garantir completude e robustez do algoritmo.",
                                  "commonMistakes": [
                                    "Falta de indentação confundindo loops aninhados",
                                    "Omitir retorno de θ final"
                                  ]
                                }
                              ],
                              "practicalExample": "Pseudocódigo para Regressão Linear:\nfunction [theta] = GD_Batch(X, y, alpha, num_epochs)\n  m = size(X,1);\n  theta = rand(size(X,2),1) * 0.01;\n  for epoch = 1:num_epochs\n    grad_acum = zeros(size(theta));\n    for i=1:m\n      h = X(i,:) * theta;\n      erro = h - y(i);\n      grad_acum += (1/m) * erro * X(i,:)';  // Nota: vetor coluna\n    end\n    theta = theta - alpha * grad_acum;\n  end\nend",
                              "finalVerifications": [
                                "Inicialização de θ é aleatória e pequena.",
                                "Loop de épocas contém reset de grad_acum.",
                                "Loop interno sobre m exemplos acumula gradientes com 1/m.",
                                "Atualização simultânea de todos θj.",
                                "Retorno explícito de θ final.",
                                "Comentários explicam passos chave.",
                                "Condição de parada opcional presente."
                              ],
                              "assessmentCriteria": [
                                "Corretude matemática: gradiente médio exato para J(θ).",
                                "Clareza: Estrutura legível com indentação e títulos.",
                                "Completude: Todos componentes (inicialização, loops, update) presentes.",
                                "Eficiência conceitual: O( m * d * epochs) onde d=dim(θ).",
                                "Robustez: Trata bias e hiperparâmetros.",
                                "Originalidade: Não copiado verbatim, mas compreendido.",
                                "Testável: Pode ser traduzido para código real facilmente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática - Cálculo: Derivadas parciais e otimização.",
                                "Programação: Loops aninhados e estruturas de dados vetoriais.",
                                "Estatística: Minimização de erro quadrático médio (MSE).",
                                "Física: Analogia com movimento em potencial gravitacional.",
                                "Economia: Otimização de funções de custo em modelos econômicos."
                              ],
                              "realWorldApplication": "Implementado em frameworks como TensorFlow/PyTorch para treinar modelos de ML em larga escala, como regressão em datasets de vendas ou classificação em imagens, otimizando bilhões de parâmetros em produção."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Ajustar a taxa de aprendizado α",
                            "description": "Analisar o impacto de diferentes valores de α (muito pequeno: convergência lenta; muito grande: divergência), e demonstrar visualmente curvas de convergência para funções quadráticas simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Teoria do Gradiente Descendente e Impacto de α",
                                  "subSteps": [
                                    "Estude a fórmula de atualização do gradiente descendente: x_{t+1} = x_t - α * ∇f(x_t).",
                                    "Analise matematicamente o que acontece com α muito pequeno (convergência lenta, muitas iterações).",
                                    "Analise α muito grande (passos overshoot, oscilação ou divergência).",
                                    "Derive condição de estabilidade para funções quadráticas: α < 2 / L, onde L é Lipschitz constante.",
                                    "Discuta trade-offs: precisão vs. velocidade de convergência."
                                  ],
                                  "verification": "Resuma em um parágrafo os impactos de α extremo e cite a condição de estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook com Python/Jupyter",
                                    "Documentação de gradiente descendente (ex: Wikipedia ou notas de aula)"
                                  ],
                                  "tips": "Use analogia de descida de montanha: α pequeno = passos curtos lentos; grande = saltos perigosos.",
                                  "learningObjective": "Compreender teoricamente o papel de α na convergência do GD.",
                                  "commonMistakes": "Confundir α com tamanho do batch; ignorar que α afeta apenas o tamanho do passo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Gradiente Descendente para Função Quadrática Simples",
                                  "subSteps": [
                                    "Defina f(x) = (1/2)x² + x, com ∇f(x) = x + 1.",
                                    "Implemente função iterativa de GD batch com parâmetros: α, iterações máx (ex: 100), tolerância.",
                                    "Registre histórico de loss f(x_t) e x_t por iteração.",
                                    "Teste com α fixo médio (ex: 0.1) e verifique convergência para mínimo x* ≈ -1.",
                                    "Adicione logging para plot posterior."
                                  ],
                                  "verification": "Execute código e confirme que converge para x ≈ -1 com loss < 0.01.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3",
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use listas ou arrays NumPy para históricos para facilitar plotting.",
                                  "learningObjective": "Implementar GD funcional para benchmark.",
                                  "commonMistakes": "Erro no sinal do gradiente (deve ser subtração); não inicializar x0 adequadamente (ex: x0=0)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Experimentar com Diferentes Valores de α",
                                  "subSteps": [
                                    "Selecione grid de α: [0.001, 0.01, 0.1, 0.5, 1.0, 2.0].",
                                    "Para cada α, rode GD com mesmas condições iniciais e registre históricos.",
                                    "Monitore por divergência: pare se |loss| > threshold ou oscilar.",
                                    "Colete métricas: iterações para convergir, loss final, estabilidade.",
                                    "Salve dados em dicionário para análise."
                                  ],
                                  "verification": "Tenha histórico completo para pelo menos 5 valores de α sem erros de código.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do Step 2 estendido",
                                    "NumPy para grid"
                                  ],
                                  "tips": "Use loop for α in alphas; plot inline no Jupyter para debug rápido.",
                                  "learningObjective": "Gerar dados empíricos do impacto de α.",
                                  "commonMistakes": "Não fixar seed/random inicial; α muito grande sem detecção de divergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Analisar Curvas de Convergência",
                                  "subSteps": [
                                    "Plote curvas de loss vs. iterações para todos α (log scale no y se necessário).",
                                    "Plote trajetórias x_t vs. iterações, destacando divergência/estagnação.",
                                    "Identifique α ótimo: menor loss em poucas iterações.",
                                    "Compare com teoria: valide convergência lenta (α=0.001) e divergência (α=2.0).",
                                    "Anote observações qualitativas e quantitativas."
                                  ],
                                  "verification": "Gere plots legíveis com legendas e títulos explicativos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matplotlib/Seaborn",
                                    "Códigos anteriores"
                                  ],
                                  "tips": "Use plt.semilogy() para loss; cores diferentes por α.",
                                  "learningObjective": "Interpretar visualmente efeitos de α.",
                                  "commonMistakes": "Escalas erradas nos plots (linear para loss exponencial); legenda faltando."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Otimizar Ajuste de α",
                                  "subSteps": [
                                    "Calcule métricas agregadas: tempo para loss<ε por α.",
                                    "Proponha método heurístico: line search ou α inicial = 1/L.",
                                    "Teste α adaptativo simples (ex: α *= 1.1 se melhora, /=1.1 senão).",
                                    "Documente melhores práticas para GD batch.",
                                    "Reflita: como generalizar para funções não-quadráticas."
                                  ],
                                  "verification": "Escreva relatório curto (200 palavras) com achados e recomendações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Plots gerados",
                                    "Notebook para relatório"
                                  ],
                                  "tips": "α ótimo ≈ 1/(L+μ) para quadráticas; L≈1, μ≈1 aqui.",
                                  "learningObjective": "Desenvolver intuição para tuning de α.",
                                  "commonMistakes": "Generalizar demais sem contexto quadrático; ignorar custo computacional."
                                }
                              ],
                              "practicalExample": "Para f(x) = 0.5x² + x, teste α=0.1: converge em ~20 iterações para x=-1, loss~0. α=0.001: >100 iterações lentas. α=2.0: diverge para ∞ após 5 passos. Plot mostra curvas suaves vs. explosivas.",
                              "finalVerifications": [
                                "Explicar verbalmente por que α grande causa divergência em funções convexas.",
                                "Identificar α ótimo em plot de curvas de loss.",
                                "Implementar GD que detecta e para divergência.",
                                "Calcular Lipschitz constante para f(x)=(1/2)x² + x.",
                                "Propor α inicial baseado em gradiente máximo.",
                                "Comparar curvas para duas funções quadráticas diferentes."
                              ],
                              "assessmentCriteria": [
                                "Código funcional e reproduzível (20%)",
                                "Plots claros e interpretáveis (25%)",
                                "Análise teórica precisa (20%)",
                                "Métricas quantitativas corretas (15%)",
                                "Relatório com insights acionáveis (10%)",
                                "Tratamento de edge cases (α extremos) (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de estabilidade em EDOs (dx/dt = -∇f).",
                                "Física: Dinâmica de partículas em potencial quadrático.",
                                "Machine Learning: Tuning hiperparâmetros em redes neurais.",
                                "Estatística: Otimização de máxima verossimilhança."
                              ],
                              "realWorldApplication": "Em treinamento de modelos de ML (ex: TensorFlow/PyTorch), ajustar α evita underfitting (lento) ou exploding gradients; essencial em deep learning para convergência eficiente em bilhões de parâmetros."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Definir critérios de convergência",
                            "description": "Implementar e justificar condições de parada: máximo de iterações, mudança no custo < ε, ou norma do gradiente ||∇J|| < ε, com exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos teóricos de critérios de convergência",
                                  "subSteps": [
                                    "Estudar a definição de convergência em métodos iterativos como o Gradiente Descendente (GD).",
                                    "Explicar a necessidade de critérios de parada para evitar loops infinitos ou computação desnecessária.",
                                    "Identificar os três critérios principais: máximo de iterações (max_iter), mudança no custo |J(t) - J(t-1)| < ε, e norma do gradiente ||∇J|| < ε.",
                                    "Analisar o parâmetro ε (tolerância) e seu impacto na precisão e eficiência.",
                                    "Discutir trade-offs: precisão vs. tempo de execução."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando cada critério com uma analogia simples (ex: descida de montanha).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notebook Jupyter ou Python IDE",
                                    "Documentação de otimização numérica (ex: SciPy docs)",
                                    "Gráfico de função quadrática exemplo"
                                  ],
                                  "tips": "Use visualizações gráficas para ilustrar quando cada critério para o algoritmo.",
                                  "learningObjective": "Dominar a teoria por trás dos critérios de convergência no GD.",
                                  "commonMistakes": [
                                    "Confundir mudança no custo com norma do gradiente.",
                                    "Ignorar o impacto de ε muito pequeno levando a overfitting computacional."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o critério de máximo de iterações",
                                  "subSteps": [
                                    "Definir uma variável max_iter (ex: 1000) no código do GD.",
                                    "Estruturar o loop while com contador de iterações.",
                                    "Adicionar break quando iterações >= max_iter.",
                                    "Testar com uma função simples J(θ) = θ²/2, θ0=10, α=0.1.",
                                    "Registrar número de iterações usadas."
                                  ],
                                  "verification": "Executar o código e confirmar que para exatamente em max_iter se outros critérios não ativarem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Código base de GD batch"
                                  ],
                                  "tips": "Comece com max_iter baixo (100) para testes rápidos e aumente gradualmente.",
                                  "learningObjective": "Implementar de forma robusta o critério de segurança contra loops infinitos.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar o contador de iterações.",
                                    "Usar max_iter muito alto sem justificativa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o critério de mudança no custo < ε",
                                  "subSteps": [
                                    "Calcular J_prev = J(θ) antes da atualização.",
                                    "Após iteração, verificar if abs(J(θ) - J_prev) < ε.",
                                    "Escolher ε inicial como 1e-6 e testar sensibilidade.",
                                    "Integrar ao loop existente com os passos anteriores.",
                                    "Plotar evolução de J(θ) para visualizar estabilização."
                                  ],
                                  "verification": "Simular com ruído no custo e confirmar detecção de platô.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "NumPy para cálculos",
                                    "Matplotlib para plots",
                                    "Função de custo não-convexa exemplo"
                                  ],
                                  "tips": "Monitore J em um log para debug visual.",
                                  "learningObjective": "Detectar convergência quando o custo para de diminuir significativamente.",
                                  "commonMistakes": [
                                    "Calcular delta com J futuro em vez de anterior.",
                                    "Escolher ε fixo sem normalizar pela escala de J."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o critério de norma do gradiente ||∇J|| < ε",
                                  "subSteps": [
                                    "Computar gradiente ∇J(θ) usando norma L2 (np.linalg.norm).",
                                    "Verificar if np.linalg.norm(∇J) < ε no loop.",
                                    "Testar com ε_grad = 1e-5, diferente de ε_custo se necessário.",
                                    "Comparar ativação deste critério vs. outros em simulações.",
                                    "Adicionar logs para ||∇J|| por iteração."
                                  ],
                                  "verification": "Confirmar que para quando gradiente é quase zero (ponto crítico).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Código GD atualizado"
                                  ],
                                  "tips": "Use norma L2 para gradientes vetoriais; normalize se multidimensional.",
                                  "learningObjective": "Implementar critério baseado em estacionariedade do gradiente.",
                                  "commonMistakes": [
                                    "Usar norma L1 em vez de L2 para gradientes.",
                                    "Confundir ∇J com delta θ."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar critérios, justificar escolhas e testar numericamente",
                                  "subSteps": [
                                    "Combinar todos critérios em um loop com if/elif prioritário (ex: grad > custo > max_iter).",
                                    "Justificar escolhas de ε e max_iter baseadas em escala do problema.",
                                    "Executar com exemplo numérico: minimizar J(θ)= (θ-2)^2 + sin(θ), θ0=0.",
                                    "Analisar resultados: iterações, θ final, motivo de parada.",
                                    "Documentar em relatório curto."
                                  ],
                                  "verification": "Código converge corretamente em < max_iter e atende pelo menos um critério.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Jupyter Notebook completo",
                                    "Exemplos numéricos variados"
                                  ],
                                  "tips": "Priorize gradiente para precisão, custo para eficiência.",
                                  "learningObjective": "Criar implementação completa e justificada de critérios de convergência.",
                                  "commonMistakes": [
                                    "Falta de prioridade entre critérios.",
                                    "Não testar com funções não-convexas."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente GD batch para minimizar J(θ) = θ²/2 + 0.1*sin(5θ), com θ inicial=4, α=0.01, ε_custo=1e-6, ε_grad=1e-5, max_iter=5000. Registre iterações até parada (ex: para em 245 iterações por ||∇J||<ε_grad, θ_final≈0.02, J_final≈0.0005). Plote J e ∇J vs. iterações.",
                              "finalVerifications": [
                                "O código implementa corretamente os três critérios sem erros de sintaxe.",
                                "Simulações numéricas convergem para valores esperados (erro <1%).",
                                "Logs mostram motivo exato de parada e valores finais.",
                                "Justificativa escrita para parâmetros ε e max_iter.",
                                "Testes com diferentes inicializações confirmam robustez.",
                                "Plots visuais confirmam estabilização de J e ∇J."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação: critérios ativam corretamente (90%).",
                                "Justificativa teórica: explicação clara de trade-offs (80%).",
                                "Exemplos numéricos: resultados precisos e variados (85%).",
                                "Eficiência: convergência em tempo razoável (< max_iter/2).",
                                "Documentação: código comentado e relatório (75%).",
                                "Robustez: lida com casos edge (ex: ε=0, α grande)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica (métodos iterativos, normas vetoriais).",
                                "Estatística: Otimização em MLE (Maximum Likelihood Estimation).",
                                "Inteligência Artificial: Treinamento de redes neurais (early stopping).",
                                "Física: Simulações dinâmicas (condições de equilíbrio).",
                                "Engenharia de Software: Boas práticas em loops iterativos."
                              ],
                              "realWorldApplication": "Em machine learning, define parada no treinamento de modelos como regressão linear ou redes neurais no TensorFlow/PyTorch, evitando overfitting e otimizando tempo de computação em produção (ex: recomendadores da Netflix ou otimização de rotas logísticas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Variantes com Momento",
                        "description": "Extensão do Gradiente Descendente com momentum para acelerar convergência em regiões planas ou ravinas, incorporando velocidade acumulada de atualizações anteriores.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Explicar o conceito de momentum",
                            "description": "Descrever como o momentum β (tipicamente 0.9) adiciona uma fração da atualização anterior à atual: v := β v + (1-β) ∇J, θ := θ - α v, simulando inércia para superar oscilações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Gradiente Descendente Básico e Identificar Limitações",
                                  "subSteps": [
                                    "Relembre a atualização padrão do GD: θ := θ - α ∇J(θ), onde α é a taxa de aprendizado e ∇J é o gradiente.",
                                    "Discuta problemas comuns como oscilações em ravinas estreitas ou lentidão em platôs.",
                                    "Desenhe um gráfico simples de uma função quadrática com ravina para visualizar o problema.",
                                    "Calcule manualmente 3-5 iterações de GD em uma função 1D como J(θ) = θ² para observar lentidão.",
                                    "Compare com cenários onde o gradiente muda de direção abruptamente."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que o GD básico oscila em ravinas e forneça um exemplo numérico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora ou Python/Jupyter para simulação simples",
                                  "tips": "Use funções quadráticas simples para cálculos manuais; visualize com plots para intuição.",
                                  "learningObjective": "Compreender as limitações do GD vanilla que motivam o momentum.",
                                  "commonMistakes": "Confundir taxa de aprendizado com gradiente; ignorar o impacto de geometria da loss surface."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Analogia Física do Momentum",
                                  "subSteps": [
                                    "Explique momentum como inércia de uma bola rolando downhill, mantendo velocidade mesmo se a inclinação muda.",
                                    "Defina termos: velocidade v acumula direção passada; β controla quanto da velocidade anterior é retida (ex: β=0.9 significa 90% anterior + 10% nova).",
                                    "Compare com uma bola sem inércia que para/ziguezagueia em obstáculos.",
                                    "Desenhe diagrama: trajetória suave com momentum vs. oscilante sem.",
                                    "Discuta β alto para aceleração em platôs, β baixo para curvas apertadas."
                                  ],
                                  "verification": "Descreva a analogia em suas próprias palavras e esboce o diagrama comparativo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para desenhos, vídeo curto de bola rolando (opcional, YouTube: 'momentum gradient descent animation')",
                                  "tips": "Pense em esportes: patinação no gelo (alta inércia) vs. atrito alto (baixa).",
                                  "learningObjective": "Internalizar intuição física do momentum como 'memória' das atualizações passadas.",
                                  "commonMistakes": "Interpretar β como taxa de aprendizado; esquecer que momentum acelera na direção média."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Entender as Equações Matemáticas do Momentum",
                                  "subSteps": [
                                    "Apresente as equações: v_t := β v_{t-1} + (1-β) ∇J(θ_{t-1}), então θ_t := θ_{t-1} - α v_t.",
                                    "Inicialize v_0 = 0 e compute 5 iterações manualmente para J(θ) = (1/2)θ² com β=0.9, α=0.1.",
                                    "Mostre como v suaviza o gradiente efetivo: média exponencial ponderada dos gradientes passados.",
                                    "Discuta hiperparâmetros: β típico 0.9, α ajustado para maior que no GD vanilla.",
                                    "Implemente em pseudocódigo ou Python snippet para confirmação numérica."
                                  ],
                                  "verification": "Derive as equações passo a passo e reproduza os cálculos manuais com valores corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Jupyter Notebook ou papel quadriculado, biblioteca NumPy para verificação",
                                  "tips": "Use notação vetorial; teste com ∇J alternando sinal para ver suavização.",
                                  "learningObjective": "Dominar a formulação exata e computar atualizações com momentum.",
                                  "commonMistakes": "Esquecer (1-β) no gradiente atual; confundir ordem de v e θ updates."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar Benefícios e Simular Comparativamente",
                                  "subSteps": [
                                    "Gere plots comparativos: trajetórias de GD vs. Momentum em função com ravina (ex: Rosenbrock).",
                                    "Meça métricas: iterações para convergência, tamanho do passo efetivo.",
                                    "Analise casos: platôs (momentum acelera), ruído no gradiente (suaviza).",
                                    "Ajuste β e α experimentalmente para otimizar.",
                                    "Resuma trade-offs: overshooting se β muito alto."
                                  ],
                                  "verification": "Crie e interprete plots mostrando convergência mais rápida com momentum.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com Matplotlib/NumPy, ou ferramenta online como Desmos para 2D",
                                  "tips": "Comece com 2D para visualização; use loops simples para simulação.",
                                  "learningObjective": "Avaliar empiricamente como momentum supera limitações do GD básico.",
                                  "commonMistakes": "Escala errada nos plots; ignorar inicialização de v=0."
                                }
                              ],
                              "practicalExample": "Em otimização de uma loss quadrática J(θ) = θ²/2 com ravina artificial, GD básico oscila (100+ iterações para erro<0.01), enquanto momentum (β=0.9) converge em 20 iterações, suavizando passos como uma bola ganhando velocidade.",
                              "finalVerifications": [
                                "Derivar corretamente as equações de momentum de memória.",
                                "Explicar intuição física sem hesitação.",
                                "Simular 5 iterações manualmente com valores precisos.",
                                "Identificar quando momentum é superior ao GD vanilla.",
                                "Ajustar β e α para um exemplo dado.",
                                "Plotar trajetórias comparativas em ferramenta de visualização."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (equações corretas, incluindo fatores β e 1-β).",
                                "Profundidade da intuição física (analogia coerente com inércia).",
                                "Qualidade de exemplos/simulações (plots numéricos mostrando aceleração).",
                                "Compreensão de hiperparâmetros (explicação de β=0.9 e trade-offs).",
                                "Aplicação a cenários reais (ex: ravinas em redes neurais).",
                                "Clareza na comunicação (explicação acessível e sem erros conceituais)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Analogia direta com conservação de momento linear (p = mv).",
                                "Matemática: Médias exponenciais móveis e séries geométricas.",
                                "Engenharia: Controle de sistemas dinâmicos com termos de amortecimento.",
                                "Estatística: Suavização de gradientes ruidosos como filtro de Kalman simplificado."
                              ],
                              "realWorldApplication": "Em treinamento de deep learning (ex: CNNs no TensorFlow/PyTorch), momentum acelera convergência em datasets grandes como ImageNet, reduzindo epochs de 100 para 50 ao suavizar oscilações em superfícies de loss complexas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Implementar GD com Momentum em pseudocódigo",
                            "description": "Escrever pseudocódigo da variante com momentum, inicializando velocidade v=0, e comparando curvas de convergência com e sem momentum em funções com ravinas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Gradiente Descendente (GD) Padrão e Introduzir Conceito de Momentum",
                                  "subSteps": [
                                    "Relembre a fórmula do GD padrão: θ ← θ - α * ∇f(θ), onde α é a taxa de aprendizado.",
                                    "Entenda o problema das ravinas em funções de perda: gradientes oscilam em vales estreitos, causando convergência lenta.",
                                    "Introduza momentum: adicione uma 'velocidade' v para suavizar atualizações, simulando inércia física.",
                                    "Defina parâmetros: β (fator de momentum, tipicamente 0.9), v inicializado como 0.",
                                    "Discuta como momentum acelera em ravinas ao manter direção passada."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como momentum resolve oscilações em ravinas, citando a fórmula v ← β*v + (1-β)*∇f(θ).",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Notebook com exemplos de funções como Rosenbrock"
                                  ],
                                  "tips": [
                                    "Visualize momentum como uma bola rolando em um vale estreito.",
                                    "Comece com β=0 para ver GD padrão."
                                  ],
                                  "learningObjective": "Compreender os fundamentos do GD e como o momentum mitiga problemas de convergência em ravinas.",
                                  "commonMistakes": [
                                    "Confundir momentum com taxa de aprendizado adaptativa.",
                                    "Esquecer que v inicia em 0."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Escrever Fórmulas do GD com Momentum",
                                  "subSteps": [
                                    "Escreva a atualização com momentum: v ← β*v + α*∇f(θ); θ ← θ - v.",
                                    "Compare com GD padrão: sem momentum, v é sempre o gradiente atual.",
                                    "Escolha uma função teste com ravina, ex: f(x) = x^4 + 0.01*x^2 (vale estreito).",
                                    "Defina hiperparâmetros: α=0.01, β=0.9, iterações=100.",
                                    "Simule manualmente 3-5 iterações em papel para θ inicial [1,1]."
                                  ],
                                  "verification": "Mostre derivação passo a passo das primeiras 3 iterações, confirmando v acumula direção.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Calculadora ou Python REPL para cálculos rápidos",
                                    "Folha com função de teste"
                                  ],
                                  "tips": [
                                    "Use notação vetorial para generalizar a múltiplas dimensões.",
                                    "Teste β alto (0.99) para mais 'inércia'."
                                  ],
                                  "learningObjective": "Derivar corretamente as equações do GD com momentum e simular iterações iniciais.",
                                  "commonMistakes": [
                                    "Atualizar θ antes de v.",
                                    "Usar β em vez de (1-β) no gradiente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Pseudocódigo Completo para GD com e sem Momentum",
                                  "subSteps": [
                                    "Estruture pseudocódigo: função GD_Momentum(f, ∇f, θ0, α, β, max_iter).",
                                    "Inicialize: v = 0, losses = [].",
                                    "Loop: compute ∇f, update v e θ, append loss = f(θ).",
                                    "Crie versão sem momentum (β=0).",
                                    "Adicione flags para plotar curvas de loss vs iteração."
                                  ],
                                  "verification": "Pseudocódigo roda sem erros lógicos e produz losses decrescentes.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Exemplo de função Rosenbrock: f(x,y)=(1-x)^2 + 100(y-x^2)^2"
                                  ],
                                  "tips": [
                                    "Use pseudocódigo legível com indentação.",
                                    "Inclua early stopping se loss < epsilon."
                                  ],
                                  "learningObjective": "Escrever pseudocódigo funcional e comparável para ambas variantes.",
                                  "commonMistakes": [
                                    "Não inicializar v=0.",
                                    "Esquecer de armazenar losses para plotting."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, Plotar e Comparar Curvas de Convergência em Funções com Ravinas",
                                  "subSteps": [
                                    "Execute pseudocódigo para GD padrão e com momentum na Rosenbrock (θ0=[-1.2,1.0]).",
                                    "Colete losses para 1000 iterações.",
                                    "Gere gráfico: eixo X=iterações, Y=log(loss), duas curvas.",
                                    "Analise: momentum deve convergir mais rápido após oscilações iniciais.",
                                    "Experimente variar β e α para observar impactos."
                                  ],
                                  "verification": "Gráfico mostra convergência superior com momentum em ravina, com loss final menor.",
                                  "estimatedTime": "35-45 minutos",
                                  "materials": [
                                    "Python/Matplotlib para simulação real (opcional, mas recomendado)",
                                    "Papel para esboço de gráfico"
                                  ],
                                  "tips": [
                                    "Use escala log para losses pequenas.",
                                    "Repita com semente fixa para reprodutibilidade."
                                  ],
                                  "learningObjective": "Comparar empiricamente o desempenho, confirmando benefícios em ravinas.",
                                  "commonMistakes": [
                                    "Função errada sem ravina (use quadrática simples).",
                                    "α muito alto causando divergência."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente GD com momentum (β=0.9, α=0.001) para minimizar a função Rosenbrock f(x,y)=(1-x)^2 + 100(y-x^2)^2 a partir de [-1.2, 1.0]. Rode 2000 iterações, plote log(loss) vs iterações comparando com GD padrão (β=0). Observe como momentum escapa da ravina mais rápido.",
                              "finalVerifications": [
                                "Pseudocódigo inicializa v=0 e usa update v ← βv + α∇f(θ); θ ← θ - v.",
                                "Simulação em função com ravina (ex: Rosenbrock) converge com momentum.",
                                "Gráfico mostra curvas: momentum tem menos oscilações e loss menor final.",
                                "Explicação correta de por que momentum acelera em ravinas.",
                                "Hiperparâmetros sensíveis testados (varie β de 0.5 a 0.99).",
                                "Código comparável roda para ambas variantes sem erros."
                              ],
                              "assessmentCriteria": [
                                "Correção do pseudocódigo: fórmulas exatas e inicializações.",
                                "Qualidade da simulação: pelo menos 1000 iterações com losses tracked.",
                                "Análise comparativa: identificação clara de melhorias em ravinas.",
                                "Visualização: gráfico legível com labels e escalas adequadas.",
                                "Generalização: menção a vetores/multi-dimensões.",
                                "Profundidade: discussão de tuning de β e α."
                              ],
                              "crossCurricularConnections": [
                                "Física: Analogia com leis de Newton (massa * aceleração = força acumulada).",
                                "Matemática: Otimização estocástica e análise de convergência.",
                                "Machine Learning: Base para SGD com momentum em TensorFlow/PyTorch.",
                                "Estatística: Suavização de gradientes ruidosos em dados reais."
                              ],
                              "realWorldApplication": "Em treinamento de redes neurais profundas, GD com momentum (ex: em otimizadores como SGD com momentum ou Adam) acelera convergência em paisagens de perda complexas com ravinas, permitindo modelos escaláveis em visão computacional e NLP."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Comparar variantes e analisar complexidade",
                            "description": "Discutir vantagens do momentum (convergência mais rápida, menos oscilações), complexidade O(n d iter) onde n=amostras, d=dimensões, iter=iterações, e limitações em paisagens não convexas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos das Variantes de Gradiente Descendente",
                                  "subSteps": [
                                    "Explique o algoritmo de Gradiente Descendente (GD) padrão: atualização de parâmetros θ ← θ - η ∇J(θ).",
                                    "Descreva a variante com Momentum: introdução do termo de velocidade v ← β v + (1-β) ∇J(θ), θ ← θ - η v.",
                                    "Compare as fórmulas matemáticas lado a lado, destacando a inércia adicionada pelo momentum.",
                                    "Implemente pseudocódigo simples para ambas as variantes.",
                                    "Execute uma simulação visual básica para observar o comportamento em uma função quadrática."
                                  ],
                                  "verification": "Crie um diagrama de fluxo comparativo das duas variantes e simule 10 iterações manualmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; notebook Jupyter com NumPy.",
                                  "tips": "Use β=0.9 como valor padrão para momentum para visualizações iniciais.",
                                  "learningObjective": "Compreender as diferenças algorítmicas fundamentais entre GD padrão e GD com momentum.",
                                  "commonMistakes": "Confundir o fator de momentum β com a taxa de aprendizado η; ignorar a inicialização de v=0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vantagens do Momentum",
                                  "subSteps": [
                                    "Discuta convergência mais rápida: momentum acelera em direções consistentes de gradiente.",
                                    "Explique redução de oscilações: suaviza atualizações em ravinas estreitas.",
                                    "Compare curvas de perda em experimentos: plote loss vs. iterações para GD vs. Momentum em função com ravina.",
                                    "Quantifique vantagens: meça número de iterações para convergência em <1% de erro.",
                                    "Registre observações qualitativas sobre estabilidade."
                                  ],
                                  "verification": "Gere gráficos de convergência mostrando momentum convergindo em menos iterações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com Matplotlib e NumPy; dataset sintético de função Rosenbrock.",
                                  "tips": "Aumente η para GD padrão para destacar oscilações, mantendo-a moderada para momentum.",
                                  "learningObjective": "Identificar e justificar as vantagens empíricas e teóricas do momentum sobre GD padrão.",
                                  "commonMistakes": "Atribuir vantagens apenas a hiperparâmetros sem isolar o efeito do momentum."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Comparar Complexidade Computacional",
                                  "subSteps": [
                                    "Derive complexidade do GD padrão: O(n d iter) por época, onde n=amostras, d=dimensões, iter=iterações totais.",
                                    "Analise GD com Momentum: mesma complexidade O(n d iter), mas iter efetivamente reduzido pela convergência mais rápida.",
                                    "Compare em termos assintóticos e práticos: discuta overhead mínimo do vetor v.",
                                    "Meça empiricamente: implemente ambas e profile tempo de execução em dataset real.",
                                    "Crie tabela comparativa de complexidade em cenários variados (baixo/alto d, n)."
                                  ],
                                  "verification": "Produza uma tabela com Big-O e medições de tempo para n=1000, d=10, iter=1000.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com timeit ou %timeit no Jupyter; dataset Iris ou similar.",
                                  "tips": "Use vetores numpy para simular alta dimensionalidade sem custo excessivo.",
                                  "learningObjective": "Dominar a análise de complexidade temporal das variantes, destacando trade-offs.",
                                  "commonMistakes": "Esquecer custo de computar gradientes (dominante) ou superestimar overhead do momentum."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Limitações em Paisagens Não Convexas",
                                  "subSteps": [
                                    "Descreva paisagens não convexas: múltiplos mínimos locais, saddles em treinamento de redes neurais.",
                                    "Simule limitações do momentum: overshooting em curvas acentuadas ou saddles.",
                                    "Compare com GD: momentum pode escapar saddles mais facilmente, mas risco de divergência.",
                                    "Discuta adaptações: relação com Adam/NAdam para mitigar.",
                                    "Sintetize prós/contras em relatório curto."
                                  ],
                                  "verification": "Execute simulação em função não convexa (ex: perda com mínimos locais) e documente comportamentos.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Python/NumPy; função teste como Himmelblau ou perda de rede simples.",
                                  "tips": "Monitore norma do gradiente para detectar saddles (||∇|| ≈ 0 mas não convergindo).",
                                  "learningObjective": "Avaliar limitações do momentum em cenários reais de otimização não convexa.",
                                  "commonMistakes": "Generalizar vantagens do momentum para todos os casos sem testar não convexidade."
                                }
                              ],
                              "practicalExample": "Implemente GD e GD com Momentum em Python para minimizar a função de perda MSE em um dataset linear com ruído (n=5000, d=5). Plote curvas de convergência, meça iterações até loss<0.01 e tempo total. Observe momentum reduzindo oscilações em features correlacionadas, convergindo em 40% menos iterações.",
                              "finalVerifications": [
                                "Explicar verbalmente as fórmulas de atualização de ambas variantes sem consultar notas.",
                                "Gerar gráfico comparativo de convergência em ravina mostrando menos oscilações no momentum.",
                                "Calcular manualmente complexidade para n=10^4, d=100, iter=500.",
                                "Identificar pelo menos 3 limitações do momentum em não convexidade com exemplos.",
                                "Implementar e profile código rodando <5s para 1000 épocas.",
                                "Criar tabela de prós/contras com justificativas quantitativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de fórmulas e complexidades (O(n d iter)).",
                                "Profundidade na análise de vantagens (evidências empíricas via plots).",
                                "Correta identificação de limitações em não convexidade com simulações.",
                                "Clareza em comparações qualitativas e quantitativas.",
                                "Uso apropriado de hiperparâmetros e interpretação de resultados.",
                                "Capacidade de sintetizar em relatório conciso e acionável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e análise assintótica (Big-O).",
                                "Física: Analogia com inércia e momentum em dinâmica de partículas.",
                                "Estatística: Análise de gradientes estocásticos em grandes datasets.",
                                "Engenharia de Software: Profiling e otimização de código numérico."
                              ],
                              "realWorldApplication": "Em treinamento de redes neurais profundas (ex: CNNs no ImageNet), GD com Momentum acelera convergência em GPUs, reduzindo tempo de treinamento de dias para horas em clusters, essencial para ML em produção como recomendadores da Netflix ou visão computacional autônoma."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.2",
                              "10.1.5.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Codificação de Huffman",
                "description": "Método de compressão de dados baseado em árvores e frequências de símbolos.",
                "totalSkills": 52,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Frequências de Símbolos",
                    "description": "Cálculo e uso das frequências de ocorrência dos símbolos na fonte de dados para priorizar a codificação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Cálculo das Frequências de Símbolos",
                        "description": "Processo de análise da fonte de dados para determinar a frequência absoluta de ocorrência de cada símbolo único, servindo como base para a construção da árvore de Huffman.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Percorrer a fonte de dados",
                            "description": "Implementar um algoritmo que itere sequencialmente sobre todos os símbolos da entrada (ex.: string ou arquivo) para acessar cada caractere individualmente, utilizando estruturas de controle como loops for ou while.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a fonte de dados",
                                  "subSteps": [
                                    "Identificar o tipo de fonte de dados (string, arquivo ou stream)",
                                    "Carregar ou ler a entrada completa em uma variável acessível",
                                    "Verificar se a fonte não está vazia e obter seu tamanho ou comprimento",
                                    "Inicializar estruturas de dados auxiliares, como um dicionário vazio para frequências",
                                    "Definir variáveis de controle inicial, como índice zero ou cursor"
                                  ],
                                  "verification": "Confirme que a variável de entrada contém todos os dados esperados e que seu comprimento é correto (ex: len(input_string) > 0).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Linguagem de programação com suporte a strings (Python, Java ou C++)",
                                    "Documentação da biblioteca padrão para leitura de arquivos"
                                  ],
                                  "tips": "Sempre trate casos de entrada vazia para evitar loops infinitos ou crashes.",
                                  "learningObjective": "Compreender como preparar dados de entrada para iteração segura e eficiente.",
                                  "commonMistakes": [
                                    "Ignorar verificação de entrada vazia",
                                    "Não importar módulos necessários para leitura de arquivos",
                                    "Usar variáveis não inicializadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e configurar o loop de iteração",
                                  "subSteps": [
                                    "Escolher entre loop for (para iteráveis conhecidos) ou while (para condições dinâmicas)",
                                    "Para loop for: usar range(len(fonte)) ou iterador direto sobre a string",
                                    "Para loop while: inicializar índice i = 0 e condição while i < len(fonte)",
                                    "Configurar incremento do índice (i += 1) no final do loop",
                                    "Testar sintaxe do loop em um exemplo mínimo vazio"
                                  ],
                                  "verification": "Execute o loop vazio e verifique se ele roda exatamente o número de iterações igual ao tamanho da fonte.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console ou debugger para testar loops",
                                    "Referência de sintaxe de loops da linguagem"
                                  ],
                                  "tips": "Prefira 'for' para strings simples por ser mais legível e menos propenso a erros de índice.",
                                  "learningObjective": "Dominar a escolha e implementação correta de estruturas de controle para iteração sequencial.",
                                  "commonMistakes": [
                                    "Esquecer o incremento do índice no while",
                                    "Usar range incorreto (ex: range(len+1))",
                                    "Confundir sintaxe de for com while"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Acessar e processar símbolos individuais no loop",
                                  "subSteps": [
                                    "Dentro do loop, acessar o símbolo atual (ex: char = fonte[i])",
                                    "Incrementar o contador ou atualizar estrutura de dados (ex: freq[char] += 1)",
                                    "Tratar caracteres especiais se necessário (ex: ignorar espaços ou normalizar case)",
                                    "Adicionar log ou print para depuração opcional",
                                    "Garantir que o acesso não cause overflow ou erro de índice"
                                  ],
                                  "verification": "Insira prints dentro do loop e confirme que cada símbolo é acessado na ordem correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo de string de teste (ex: 'aabbcc')",
                                    "Dicionário ou mapa para frequências"
                                  ],
                                  "tips": "Use chaves default em dicionários (ex: collections.Counter em Python) para evitar KeyError.",
                                  "learningObjective": "Implementar processamento atômico de cada símbolo durante a iteração.",
                                  "commonMistakes": [
                                    "Acessar índice errado (fonte[i+1])",
                                    "Não tratar caracteres não alfabéticos",
                                    "Incrementar contador fora do contexto do símbolo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar iteração e validar completude",
                                  "subSteps": [
                                    "Encerrar o loop corretamente sem condições extras",
                                    "Verificar se todos os símbolos foram processados (soma de frequências == len(fonte))",
                                    "Retornar ou imprimir o resultado final (ex: dicionário de frequências)",
                                    "Testar com múltiplos casos: string vazia, uma letra, repetições",
                                    "Refatorar código para função reutilizável"
                                  ],
                                  "verification": "Compare o número total de processamentos com o tamanho da fonte e valide saídas esperadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Casos de teste unitários",
                                    "Ferramenta de debugging"
                                  ],
                                  "tips": "Escreva asserts ou testes unitários para automação da verificação.",
                                  "learningObjective": "Garantir que a iteração cubra toda a fonte sem lacunas ou excessos.",
                                  "commonMistakes": [
                                    "Loop não termina (while True)",
                                    "Soma de frequências não bate com len",
                                    "Ignorar casos edge como strings vazias"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma função count_frequencies(texto: str) -> dict que percorre a string 'abracadabra' usando um loop for, acessa cada caractere, e retorna {'a':5, 'b':2, 'r':2, 'c':1, 'd':1}. Teste imprimindo o dicionário e verificando soma das frequências == 11.",
                              "finalVerifications": [
                                "O loop itera exatamente len(fonte) vezes",
                                "Cada símbolo é acessado sequencialmente sem pular ou repetir",
                                "Estrutura de frequências reflete contagens corretas",
                                "Função lida com entrada vazia retornando dict vazio",
                                "Código executa em tempo linear O(n)",
                                "Sem erros de índice ou KeyError"
                              ],
                              "assessmentCriteria": [
                                "Correção: Loop acessa todos os símbolos corretamente",
                                "Eficiência: Tempo O(n) sem operações desnecessárias",
                                "Robustez: Trata entradas vazias e especiais sem crash",
                                "Legibilidade: Código claro com comentários e nomes descritivos",
                                "Testabilidade: Inclui verificações ou testes embutidos",
                                "Reutilização: Encapsulado em função modular"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de somatórios e contagens discretas",
                                "Estatística: Computação de distribuições de frequências",
                                "Linguística: Análise sequencial de textos e padrões",
                                "Engenharia de Software: Processamento eficiente de streams de dados"
                              ],
                              "realWorldApplication": "Na codificação de Huffman para compressão de arquivos de texto, percorrer a fonte calcula frequências de caracteres para construir árvores de codificação ótima, usado em ZIP, JPEG e protocolos de rede para reduzir tamanho de dados transmitidos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Contar ocorrências de símbolos",
                            "description": "Manter uma estrutura de dados associativa (como dicionário em Python ou mapa em C++) para registrar e incrementar o contador de cada símbolo encontrado durante a travessia da fonte.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a estrutura de dados associativa",
                                  "subSteps": [
                                    "Escolha a linguagem de programação (ex: Python com dict ou C++ com std::map<char, int>).",
                                    "Crie uma variável para a estrutura vazia (ex: freq = {} em Python).",
                                    "Defina o escopo da função ou programa onde a contagem será realizada.",
                                    "Considere tipos de chaves (char para símbolos) e valores (int para contadores).",
                                    "Inicialize contadores em zero implicitamente ao usar get ou default em mapas."
                                  ],
                                  "verification": "Verifique se a estrutura está vazia ou com contadores zerados ao imprimir ou inspecionar.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Instalação da linguagem (Python 3+ ou C++ compiler)"
                                  ],
                                  "tips": "Use defaultdict(int) em Python para evitar KeyError ao acessar chaves inexistentes.",
                                  "learningObjective": "Compreender como inicializar e preparar uma estrutura associativa para contagens dinâmicas.",
                                  "commonMistakes": [
                                    "Esquecer de importar bibliotecas necessárias (ex: <map> em C++)",
                                    "Usar array fixo em vez de estrutura dinâmica",
                                    "Inicializar com valores errados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Percorrer a fonte de dados (string ou arquivo)",
                                  "subSteps": [
                                    "Defina a fonte de dados (ex: string s = 'hello world'; ou leia de arquivo).",
                                    "Use um loop for-each ou iterator para acessar cada caractere (ex: for char c : s).",
                                    "Garanta que a travessia seja sequencial e cubra toda a fonte.",
                                    "Ignore ou trate caracteres especiais se necessário (ex: espaços, quebras de linha).",
                                    "Registre o índice atual para depuração se houver erros."
                                  ],
                                  "verification": "Adicione prints para confirmar que todos os caracteres da fonte são acessados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo de string ou arquivo de teste",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Comece com uma string pequena para testar a iteração antes de arquivos grandes.",
                                  "learningObjective": "Dominar iterações eficientes sobre sequências de símbolos para processamento linear.",
                                  "commonMistakes": [
                                    "Pular caracteres (ex: off-by-one em loops)",
                                    "Processar a fonte múltiplas vezes desnecessariamente",
                                    "Não tratar fontes vazias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incrementar o contador para cada símbolo encontrado",
                                  "subSteps": [
                                    "Para cada símbolo c, acesse freq[c] e incremente em 1 (ex: freq[c]++ ou freq[c] += 1).",
                                    "Use operadores de incremento eficientes (ex: freq[c]++ em C++).",
                                    "Trate chaves inexistentes automaticamente com default values.",
                                    "Evite comparações desnecessárias dentro do loop para manter O(n).",
                                    "Teste com símbolos repetidos para validar incrementos múltiplos."
                                  ],
                                  "verification": "Após a travessia, imprima o dicionário e compare com contagem manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Strings de teste com símbolos repetidos",
                                    "Calculadora para contagem manual"
                                  ],
                                  "tips": "Em Python, freq.get(c, 0) + 1 e atribua de volta se não usar defaultdict.",
                                  "learningObjective": "Implementar atualizações atômicas em estruturas associativas durante iterações.",
                                  "commonMistakes": [
                                    "Incrementar antes de inicializar (KeyError)",
                                    "Contar maiúsculas/minúsculas como diferentes sem normalizar",
                                    "Usar soma em vez de incremento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e finalizar a estrutura de contagens",
                                  "subSteps": [
                                    "Percorra o dicionário para somar totais e verificar contra tamanho da fonte.",
                                    "Ordene ou filtre entradas se necessário (ex: apenas símbolos com freq > 0).",
                                    "Retorne ou passe a estrutura para próxima etapa (ex: construção da árvore Huffman).",
                                    "Adicione logs para depuração de discrepâncias.",
                                    "Teste casos edge: fonte vazia, um símbolo, todos iguais."
                                  ],
                                  "verification": "Soma de todos os valores no dicionário deve igualar o comprimento da fonte.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Casos de teste edge (string vazia, 'aaa', '')",
                                    "Função de soma auxiliar"
                                  ],
                                  "tips": "Use assert ou testes unitários para automação da validação.",
                                  "learningObjective": "Garantir integridade e precisão das contagens finais para uso em algoritmos subsequentes.",
                                  "commonMistakes": [
                                    "Ignorar soma total para validação",
                                    "Incluir contadores zero desnecessariamente",
                                    "Não testar edges"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a string fonte 'aabbccdd', após travessia: {'a':2, 'b':2, 'c':2, 'd':2}. Em Python: freq = {}; for c in 'aabbccdd': freq[c] = freq.get(c, 0) + 1. Resultado usado para priorizar nós na árvore Huffman.",
                              "finalVerifications": [
                                "Estrutura associativa contém exatamente os símbolos únicos da fonte com contagens corretas.",
                                "Soma de todos os contadores equals ao tamanho da fonte.",
                                "Funciona corretamente para fontes vazias (dicionário vazio).",
                                "Eficiência mantida em O(n) sem loops aninhados.",
                                "Sem KeyErrors ou crashes em símbolos novos.",
                                "Contagens precisas para casos com símbolos repetidos e únicos."
                              ],
                              "assessmentCriteria": [
                                "Correção: Contagens exatas para 100% dos casos de teste.",
                                "Eficiência: Tempo O(n) com constante baixa, sem acessos extras.",
                                "Robustez: Trata edges (vazio, um char, todos iguais) sem erros.",
                                "Legibilidade: Código claro com comentários e nomes descritivos.",
                                "Extensibilidade: Fácil adaptação para arquivos ou streams.",
                                "Validação interna: Inclui soma total para verificação automática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de contagem e funções de frequência em estatística descritiva.",
                                "Estatística: Cálculo de distribuições de frequências para análise de dados.",
                                "Algoritmos: Preparação para árvores de decisão e grafos em estruturas de dados.",
                                "Linguagens naturais: Análise de frequência de letras em linguística computacional."
                              ],
                              "realWorldApplication": "Essencial na compressão de dados sem perda como Huffman em ZIP/GZIP, análise de logs de sistemas para detecção de padrões, processamento de texto em motores de busca e recomendação de conteúdo baseado em frequência de termos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Identificar símbolos únicos",
                            "description": "Extrair a lista de todos os símbolos distintos presentes na fonte, garantindo que nenhum símbolo seja ignorado, mesmo com frequências baixas, para inclusão completa na codificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Fonte de Dados",
                                  "subSteps": [
                                    "Receba ou carregue a fonte de dados (ex: string, arquivo de texto ou sequência de caracteres).",
                                    "Defina o escopo: identifique o delimitador de fim da fonte (ex: fim da string ou arquivo).",
                                    "Crie uma estrutura vazia para armazenar símbolos únicos (ex: conjunto ou lista inicial).",
                                    "Registre metadados iniciais: tamanho da fonte e tipo de símbolos esperados (alfanuméricos, especiais).",
                                    "Teste a acessibilidade da fonte para leitura sequencial ou aleatória."
                                  ],
                                  "verification": "Confirme que a fonte está carregada corretamente e metadados iniciais estão anotados sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto, ambiente de programação (Python/Jupyter), amostra de dados de teste.",
                                  "tips": "Use uma cópia da fonte para evitar modificações acidentais no original.",
                                  "learningObjective": "Compreender e preparar dados de entrada para processamento de símbolos.",
                                  "commonMistakes": "Ignorar caracteres de controle ou de quebras de linha na fonte."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iterar e Coletar Símbolos Distintos",
                                  "subSteps": [
                                    "Inicie iteração sequencial pela fonte, caractere por caractere.",
                                    "Para cada símbolo encontrado, verifique se já existe na estrutura de símbolos únicos.",
                                    "Se novo, adicione à estrutura (use conjunto para eficiência em buscas).",
                                    "Mantenha um contador de ocorrências iniciais se necessário para depuração.",
                                    "Registre o progresso (ex: posição atual na fonte) para rastreamento."
                                  ],
                                  "verification": "A estrutura de símbolos únicos deve conter apenas itens distintos, sem duplicatas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código de iteração (loop for/while), estrutura de dados como set() em Python.",
                                  "tips": "Prefira estruturas hash-based (sets) para O(1) verificações de existência.",
                                  "learningObjective": "Implementar detecção eficiente de elementos únicos em uma sequência.",
                                  "commonMistakes": "Marcar duplicatas como novas devido a comparações case-sensitive incorretas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar Completude e Precisão da Lista",
                                  "subSteps": [
                                    "Reiterar pela fonte uma segunda vez para confirmar que todos os símbolos foram capturados.",
                                    "Cheque por símbolos raros ou de baixa frequência manualmente na fonte.",
                                    "Compare o tamanho da lista única com expectativas baseadas no domínio da fonte.",
                                    "Elimine falsos positivos (ex: espaços em branco vs. caracteres invisíveis).",
                                    "Ordene alfabeticamente ou por frequência para facilitar inspeção visual."
                                  ],
                                  "verification": "Lista final corresponde 100% à inspeção manual de pelo menos 3 amostras aleatórias da fonte.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Ferramentas de busca/regex para validação, lista impressa da fonte.",
                                  "tips": "Use expressões regulares para detectar padrões de símbolos ignorados.",
                                  "learningObjective": "Garantir exaustividade na extração de elementos distintos.",
                                  "commonMistakes": "Pular símbolos no final ou início da fonte por falha no loop."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar e Preparar para Codificação",
                                  "subSteps": [
                                    "Exporte a lista final em formato legível (JSON, lista numerada).",
                                    "Anote frequência zero ou baixa para cada símbolo único.",
                                    "Crie um mapeamento inicial símbolo -> índice para Huffman.",
                                    "Teste a lista em um mini-algoritmo de contagem de frequências.",
                                    "Salve em arquivo ou variável para uso subsequente."
                                  ],
                                  "verification": "Lista pode ser usada diretamente no próximo passo de cálculo de frequências sem erros.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Arquivo de saída, bloco de notas ou console de debug.",
                                  "tips": "Inclua um hash da lista para verificação de integridade futura.",
                                  "learningObjective": "Finalizar extração de forma reutilizável em pipelines de algoritmos.",
                                  "commonMistakes": "Esquecer de incluir símbolos não-alfanuméricos como pontuação."
                                }
                              ],
                              "practicalExample": "Fonte: 'aaabbcddd eef' → Símbolos únicos: ['a', 'b', 'c', 'd', ' ', 'e', 'f']. Verificação: Iterando, 'a' adicionado primeiro, ignorado nas repetições; espaço e 'e' capturados apesar de baixa frequência.",
                              "finalVerifications": [
                                "Todos os símbolos distintos da fonte estão na lista sem duplicatas.",
                                "Símbolos de baixa frequência (ex: 1 ocorrência) foram incluídos.",
                                "Lista ordenada alfabeticamente para fácil inspeção.",
                                "Tamanho da lista corresponde à contagem manual esperada.",
                                "Nenhum caractere de controle invisível foi omitido.",
                                "Lista é compatível com entrada para cálculo de frequências."
                              ],
                              "assessmentCriteria": [
                                "Completude: 100% dos símbolos únicos capturados.",
                                "Precisão: Zero duplicatas ou falsos positivos.",
                                "Eficiência: Tempo de execução linear na tamanho da fonte.",
                                "Robustez: Funciona com fontes variadas (texto, binário).",
                                "Documentação: Lista final clara e anotada.",
                                "Escalabilidade: Lida com fontes >1MB sem perda."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (união e distinção de elementos).",
                                "Linguística: Análise de corpus textual e tokenização.",
                                "Estatística: Preparação para distribuições de frequência.",
                                "Engenharia de Software: Processamento de dados em pipelines ETL."
                              ],
                              "realWorldApplication": "Em compressão de arquivos ZIP ou JPEG, identificar símbolos únicos em imagens/texto garante árvores de Huffman otimizadas, reduzindo tamanho de arquivos em até 50% sem perda de dados, usado em apps como WhatsApp para envio de mídia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Representação e Armazenamento de Frequências",
                        "description": "Organização das frequências calculadas em estruturas adequadas para facilitar o uso posterior no algoritmo de Huffman, como pares símbolo-frequência ordenáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Criar tabela de frequências",
                            "description": "Construir uma tabela ou mapa que associe cada símbolo único à sua frequência absoluta, permitindo consultas rápidas O(1) em média para símbolos conhecidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a sequência de entrada e identificar símbolos únicos",
                                  "subSteps": [
                                    "Receba a sequência de entrada (ex: string ou array de caracteres).",
                                    "Percorra a sequência uma vez para coletar todos os símbolos únicos sem duplicatas.",
                                    "Armazene temporariamente em um conjunto (set) para eficiência O(1) de verificação de existência.",
                                    "Registre o comprimento total da sequência para validação posterior.",
                                    "Documente quaisquer símbolos especiais ou edge cases (ex: caracteres vazios)."
                                  ],
                                  "verification": "Confirme que o conjunto de símbolos únicos tem tamanho correto e não contém duplicatas.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Linguagem de programação com suporte a sets (ex: Python set(), Java HashSet)",
                                    "Editor de código (VS Code, PyCharm)"
                                  ],
                                  "tips": "Use um set para evitar loops aninhados desnecessários; isso garante eficiência inicial.",
                                  "learningObjective": "Compreender a importância de pré-processamento para otimizar contagens.",
                                  "commonMistakes": [
                                    "Contar duplicatas no conjunto único",
                                    "Ignorar case sensitivity em strings",
                                    "Não lidar com entradas vazias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a estrutura de dados para tabela de frequências",
                                  "subSteps": [
                                    "Escolha uma estrutura hash-based (ex: dict em Python, HashMap em Java) para suporte a O(1) lookups.",
                                    "Inicialize o mapa vazio.",
                                    "Para cada símbolo único identificado no Step 1, inicialize com frequência 0.",
                                    "Defina chaves como símbolos e valores como inteiros para contagens.",
                                    "Considere ordenação se necessário para Huffman (ex: usar TreeMap em Java)."
                                  ],
                                  "verification": "Verifique que o mapa tem entradas para todos símbolos únicos com valor inicial 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação da linguagem para mapas/hash tables",
                                    "Exemplos de código pré-existentes"
                                  ],
                                  "tips": "Prefira estruturas nativas da linguagem para performance otimizada; evite arrays se n for grande.",
                                  "learningObjective": "Selecionar e configurar estruturas de dados adequadas para consultas rápidas.",
                                  "commonMistakes": [
                                    "Usar lista/array em vez de mapa, levando a O(n) lookups",
                                    "Inicializar com valores errados",
                                    "Não considerar tipos de dados imutáveis para chaves"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Popular a tabela contando frequências absolutas",
                                  "subSteps": [
                                    "Itere pela sequência de entrada completa uma única vez (O(n)).",
                                    "Para cada símbolo encontrado, incremente o valor correspondente no mapa.",
                                    "Use busca O(1) no mapa para acessar e atualizar a contagem.",
                                    "Registre o tempo de execução para análise de complexidade.",
                                    "Salve logs de contagem intermediária para depuração."
                                  ],
                                  "verification": "Some todos os valores no mapa e confirme que equals ao comprimento da entrada.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Entrada de teste variada (strings longas, curtas, com repetições)",
                                    "Ferramenta de profiling (timeit em Python)"
                                  ],
                                  "tips": "Evite contagens duplas iterando apenas uma vez; use for-each para clareza.",
                                  "learningObjective": "Implementar contagem eficiente demonstrando complexidade O(n) total.",
                                  "commonMistakes": [
                                    "Iterar múltiplas vezes pela entrada",
                                    "Incrementar chaves erradas",
                                    "Overflow em contagens para entradas muito grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e finalizar a tabela de frequências",
                                  "subSteps": [
                                    "Verifique se todos símbolos têm frequência >0 (remova zeros se aplicável).",
                                    "Teste consultas O(1) com símbolos conhecidos e desconhecidos.",
                                    "Gere uma representação legível (ex: print do mapa).",
                                    "Calcule estatísticas adicionais como soma total e símbolo mais frequente.",
                                    "Exporte a tabela para uso em Huffman (ex: JSON ou arquivo)."
                                  ],
                                  "verification": "Execute testes unitários: soma correta, lookup rápido, ausência de símbolos faltantes.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Framework de testes (unittest em Python, JUnit em Java)",
                                    "Entradas de teste edge-case"
                                  ],
                                  "tips": "Implemente funções de validação automatizadas para reutilização.",
                                  "learningObjective": "Garantir robustez e usabilidade da tabela em pipelines maiores.",
                                  "commonMistakes": [
                                    "Deixar frequências zero",
                                    "Falhar em testes com símbolos não ASCII",
                                    "Ignorar validação de soma"
                                  ]
                                }
                              ],
                              "practicalExample": "Entrada: string 'abracadabra' (comprimento 11). Saída: {'a':5, 'b':2, 'r':2, 'c':1, 'd':1}. Verificação: 5+2+2+1+1=11. Consulta 'a' retorna 5 em O(1).",
                              "finalVerifications": [
                                "Todos símbolos únicos da entrada estão presentes com frequência >=1.",
                                "Soma de todas as frequências equals ao comprimento da entrada.",
                                "Consultas para símbolos conhecidos retornam valor correto em tempo constante O(1).",
                                "Não há entradas com frequência zero ou símbolos irrelevantes.",
                                "A tabela é legível e pode ser serializada (ex: JSON).",
                                "Funciona com entradas vazias (tabela vazia) e de tamanho 1."
                              ],
                              "assessmentCriteria": [
                                "Correção: Contagens exatas para todos casos de teste.",
                                "Eficiência: Complexidade temporal O(n) e espacial O(k) onde k é símbolos únicos.",
                                "Robustez: Lida com edge cases (vazio, unicos, repetidos).",
                                "Clareza: Código comentado e estrutura intuitiva.",
                                "Escalabilidade: Performance estável para entradas grandes (n>10^6).",
                                "Documentação: Explicação de uso e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de contagem, distribuições de frequência e teoria dos conjuntos.",
                                "Estatística: Cálculo de frequências absolutas/relativas para análise descritiva.",
                                "Ciência de Dados: Pré-processamento de texto para ML e análise exploratória.",
                                "Engenharia de Software: Escolha de estruturas de dados para otimização de performance."
                              ],
                              "realWorldApplication": "Na codificação Huffman para compressão de arquivos (ex: ZIP, JPEG), análise de logs de sistemas para detecção de padrões, spell checkers que priorizam palavras frequentes, e processamento de linguagem natural para token frequency em modelos de IA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Ordenar por frequência",
                            "description": "Ordenar a lista de pares (símbolo, frequência) em ordem crescente ou decrescente de frequência para preparar a inserção em filas de prioridade do algoritmo de Huffman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a lista de pares (símbolo, frequência)",
                                  "subSteps": [
                                    "Identifique os símbolos e suas frequências de uma mensagem de exemplo.",
                                    "Crie uma lista de tuplas ou pares contendo cada símbolo e sua frequência correspondente.",
                                    "Garanta que todos os símbolos únicos estejam representados sem duplicatas.",
                                    "Calcule as frequências corretamente contando ocorrências na mensagem.",
                                    "Armazene a lista em uma estrutura de dados ordenável, como uma lista de tuplas."
                                  ],
                                  "verification": "Verifique se a lista contém pares corretos comparando com contagem manual das frequências na mensagem original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de código (ex: VS Code), linguagem de programação (Python recomendado), mensagem de texto de exemplo.",
                                  "tips": "Use um dicionário temporário para contar frequências antes de converter para lista de tuplas.",
                                  "learningObjective": "Compreender como representar dados de frequência de símbolos de forma estruturada para ordenação.",
                                  "commonMistakes": "Esquecer símbolos com frequência zero ou contar incorretamente ocorrências."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o critério de ordenação para o algoritmo de Huffman",
                                  "subSteps": [
                                    "Analise o contexto do Huffman: ordenação crescente por frequência para min-heap.",
                                    "Decida a chave de ordenação: segunda elemento da tupla (frequência).",
                                    "Defina se crescente (menor frequência primeiro) ou decrescente conforme necessidade.",
                                    "Escreva uma função de chave personalizada para ordenar pela frequência.",
                                    "Teste a função de chave com um par de exemplo."
                                  ],
                                  "verification": "Aplique a função de chave manualmente em dois pares e confirme a ordem esperada.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Editor de código, documentação de sorted() em Python.",
                                  "tips": "Em Python, use lambda x: x[1] como key para ordenar pela frequência.",
                                  "learningObjective": "Selecionar e justificar o critério de ordenação apropriado para filas de prioridade no Huffman.",
                                  "commonMistakes": "Ordenar por símbolo em vez de frequência ou escolher ordem decrescente incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a ordenação da lista",
                                  "subSteps": [
                                    "Use a função de ordenação built-in da linguagem (ex: sorted() em Python).",
                                    "Aplique o key function à lista de pares.",
                                    "Especifique ordem crescente com reverse=False.",
                                    "Armazene o resultado em uma nova lista ordenada.",
                                    "Imprima ou visualize a lista antes e depois para inspeção."
                                  ],
                                  "verification": "Compare a lista ordenada com a ordem manual esperada para todos os pares.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Ambiente de programação com suporte a listas e funções sorted.",
                                  "tips": "Sempre crie uma cópia ordenada para preservar a original: sorted_pairs = sorted(pairs, key=lambda x: x[1]).",
                                  "learningObjective": "Implementar ordenação eficiente de pares por frequência usando ferramentas padrão.",
                                  "commonMistakes": "Modificar a lista original acidentalmente ou usar sort() em vez de sorted() quando necessário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e preparar para inserção em fila de prioridade",
                                  "subSteps": [
                                    "Verifique se a lista está estritamente crescente por frequência.",
                                    "Identifique e corrija empates em frequências (use símbolo como tie-breaker se necessário).",
                                    "Confirme que a lista está pronta para iteração na construção da fila de prioridade.",
                                    "Integre com código de fila de prioridade simulando inserção.",
                                    "Documente o resultado para relatório ou próxima etapa do Huffman."
                                  ],
                                  "verification": "Execute um loop para checar se freq[i] <= freq[i+1] para todo i.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Código de teste para validação, debugger.",
                                  "tips": "Para empates, ordene secundariamente por símbolo: key=lambda x: (x[1], x[0]).",
                                  "learningObjective": "Garantir integridade da ordenação e compatibilidade com próximas etapas do algoritmo.",
                                  "commonMistakes": "Ignorar empates em frequência levando a ordem instável."
                                }
                              ],
                              "practicalExample": "Dada a mensagem 'abacate', frequências: [('a',3), ('b',1), ('c',1), ('t',1), ('e',1)]. Após ordenação crescente: [('b',1), ('c',1), ('t',1), ('e',1), ('a',3)]. Em Python: sorted(pairs, key=lambda x: (x[1], x[0])) para tie-breaker por símbolo.",
                              "finalVerifications": [
                                "Lista ordenada em ordem crescente estrita ou não-decrescente por frequência.",
                                "Todos os pares originais preservados sem perda ou duplicação.",
                                "Função de ordenação aplicada corretamente com key pela frequência.",
                                "Validação automatizada confirma ordem para 100% dos pares adjacentes.",
                                "Lista pronta para inserção sequencial em min-heap de prioridade.",
                                "Tratamento de empates resolvido consistentemente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação inicial da lista de pares (sem erros de contagem).",
                                "Correção do critério de ordenação (crescente por frequência).",
                                "Eficiência e correção na implementação da ordenação.",
                                "Validação completa e detecção de anomalias como empates.",
                                "Integração lógica com contexto do algoritmo de Huffman.",
                                "Clareza no código e documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de ordenação e relações de ordem total/parcial.",
                                "Estatística: Análise de distribuições de frequências em dados.",
                                "Análise de Dados: Pré-processamento de dados para algoritmos de ML.",
                                "Lógica e Estruturas de Dados: Filas de prioridade e heaps."
                              ],
                              "realWorldApplication": "Na compressão de arquivos ZIP ou JPEG usando Huffman, ordenar símbolos por frequência permite construir árvores ótimas para codificação eficiente, reduzindo o tamanho de dados em transmissão de rede ou armazenamento de imagens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Converter frequências em probabilidades",
                            "description": "Normalizar as frequências absolutas dividindo pelo total de símbolos para obter probabilidades, útil para análise teórica da entropia e comprimento médio de código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e listar as frequências absolutas dos símbolos",
                                  "subSteps": [
                                    "Identifique todos os símbolos únicos no conjunto de dados de entrada.",
                                    "Conte manualmente ou programe a contagem de ocorrências de cada símbolo para obter frequências absolutas.",
                                    "Organize em uma tabela: coluna para símbolo e coluna para frequência absoluta.",
                                    "Verifique contagens cruzando com o dataset original.",
                                    "Inclua símbolos com frequência zero se relevantes para o contexto."
                                  ],
                                  "verification": "Confirme que cada frequência corresponde à contagem real no dataset e liste sem duplicatas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Dataset de exemplo (texto ou lista de símbolos)",
                                    "Planilha (Excel/Google Sheets) ou papel e caneta"
                                  ],
                                  "tips": "Comece com um dataset pequeno para praticar; use funções COUNTIF em planilhas para automação.",
                                  "learningObjective": "Dominar a extração e organização de frequências absolutas de dados brutos.",
                                  "commonMistakes": [
                                    "Contar símbolos maiúsculos/minúsculos como distintos sem padronizar.",
                                    "Omitir símbolos raros ou com frequência zero."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o total de ocorrências (N)",
                                  "subSteps": [
                                    "Some todas as frequências absolutas listadas.",
                                    "Registre o valor total como N (total de símbolos).",
                                    "Valide somando manualmente um subconjunto para confirmar.",
                                    "Compare N com o comprimento total do dataset original."
                                  ],
                                  "verification": "N deve exatamente igualar o número total de símbolos no dataset.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Lista de frequências do Step 1",
                                    "Calculadora ou planilha"
                                  ],
                                  "tips": "Use a função SUM em planilhas para evitar erros aritméticos.",
                                  "learningObjective": "Compreender o papel do total N como denominador na normalização probabilística.",
                                  "commonMistakes": [
                                    "Erros de soma em datasets grandes.",
                                    "Confundir N com o número de símbolos únicos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular probabilidades individuais para cada símbolo",
                                  "subSteps": [
                                    "Para cada símbolo i, calcule p_i = f_i / N, onde f_i é a frequência absoluta.",
                                    "Realize a divisão em ponto flutuante com pelo menos 4 casas decimais.",
                                    "Adicione uma nova coluna na tabela para as probabilidades.",
                                    "Registre os cálculos passo a passo para rastreabilidade.",
                                    "Arredonde apenas no final, se necessário, mantendo precisão intermediária."
                                  ],
                                  "verification": "Soma preliminar das probabilidades deve ser próxima de 1.0 (tolerância 0.001).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de frequências e N do Step 2",
                                    "Calculadora ou software como Python/Excel"
                                  ],
                                  "tips": "Fórmula: =frequencia_celula / $N$celula para copiar em planilhas.",
                                  "learningObjective": "Aplicar divisão normalizadora para converter frequências em probabilidades.",
                                  "commonMistakes": [
                                    "Inverter numerador e denominador.",
                                    "Arredondar prematuramente causando perda de precisão."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, normalizar e interpretar as probabilidades",
                                  "subSteps": [
                                    "Some todas as probabilidades calculadas.",
                                    "Se a soma != 1 devido a arredondamento, ajuste proporcionalmente.",
                                    "Interprete: probabilidades altas indicam símbolos frequentes para codificação.",
                                    "Conecte ao contexto: use em cálculo de entropia H = -sum(p_i * log2(p_i)).",
                                    "Documente a tabela final de probabilidades."
                                  ],
                                  "verification": "Soma final das probabilidades == 1.0 e interpretações corretas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de probabilidades do Step 3"
                                  ],
                                  "tips": "Para ajuste: p_i_normalized = p_i / sum_all_p.",
                                  "learningObjective": "Validar probabilidades e relacioná-las à análise de entropia em Huffman.",
                                  "commonMistakes": [
                                    "Ignorar discrepâncias de soma por arredondamento.",
                                    "Não conectar probabilidades à teoria da informação."
                                  ]
                                }
                              ],
                              "practicalExample": "Texto: 'hello'. Frequências: h:1, e:1, l:2, o:1. N=5. Probabilidades: h:1/5=0.2, e:0.2, l:2/5=0.4, o:0.2. Soma=1.0. Útil para priorizar 'l' em árvore Huffman.",
                              "finalVerifications": [
                                "Converte corretamente frequências absolutas em probabilidades para um dataset dado.",
                                "Soma das probabilidades é exatamente 1.0 após validação.",
                                "Identifica e corrige erros de arredondamento.",
                                "Explica o impacto em comprimento médio de código Huffman.",
                                "Aplica em exemplo real com precisão decimal.",
                                "Lista probabilidades em tabela organizada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática em todos os cálculos (erro < 0.001).",
                                "Correta soma das probabilidades para 1.0.",
                                "Organização clara em tabelas ou listas.",
                                "Validação explícita e ajustes se necessários.",
                                "Conexão conceitual com entropia e codificação.",
                                "Tratamento adequado de precisão decimal."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade condicional e distribuições discretas.",
                                "Estatística: Normalização de histogramas de frequências.",
                                "Física: Distribuições de Boltzmann em sistemas termodinâmicos.",
                                "Economia: Modelagem de riscos probabilísticos em finanças."
                              ],
                              "realWorldApplication": "Essencial em algoritmos de compressão lossless como Huffman em ZIP, PNG e GZIP; análise de frequências em processamento de linguagem natural (NLP) para modelos de linguagem; previsão probabilística em machine learning para árvores de decisão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Uso das Frequências na Priorização",
                        "description": "Aplicação das frequências para priorizar símbolos na construção da árvore de Huffman, garantindo que símbolos mais frequentes recebam códigos de prefixo mais curtos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Inicializar fila de prioridade",
                            "description": "Criar uma fila de prioridade (min-heap) onde cada nó inicial representa um símbolo com sua frequência como chave de prioridade, permitindo extrações dos menores eficientemente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe Node para nós da árvore de Huffman",
                                  "subSteps": [
                                    "Crie uma classe Node com atributos: frequency (int), symbol (str), left (Node ou None), right (Node ou None)",
                                    "Implemente o método especial __lt__(self, other) para comparação baseada na frequency: return self.frequency < other.frequency",
                                    "Opcionalmente, adicione __repr__ para depuração: return f'Node({self.symbol}:{self.frequency})'",
                                    "Teste a classe instanciando dois nós e verificando se a1 < a2 funciona corretamente",
                                    "Garanta que símbolos únicos sejam suportados via atributo symbol"
                                  ],
                                  "verification": "Instancie dois nós com diferentes frequências e confirme que a comparação __lt__ retorna o esperado sem erros",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código Python",
                                    "Documentação Python sobre classes e dunder methods"
                                  ],
                                  "tips": "Sempre priorize frequency na comparação; se frequências iguais, o heapq gerencia estabilidade",
                                  "learningObjective": "Compreender como personalizar objetos para uso em heaps Python via __lt__",
                                  "commonMistakes": [
                                    "Esquecer de definir __lt__, causando TypeError no heappush",
                                    "Comparar symbols em vez de frequency",
                                    "Não inicializar left/right como None"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar lista de nós folha a partir das frequências dos símbolos",
                                  "subSteps": [
                                    "Assuma um dicionário de frequências fornecido, ex: freqs = {'h':1, 'e':1, 'l':2, 'o':1}",
                                    "Crie uma lista vazia nodes = []",
                                    "Itere sobre freqs.items(): para cada symbol, freq, crie node = Node(freq, symbol)",
                                    "Adicione node à lista nodes",
                                    "Verifique que len(nodes) == len(freqs) e todos symbols estão presentes"
                                  ],
                                  "verification": "Imprima a lista nodes e confirme que cada nó tem frequency e symbol corretos",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Dicionário de frequências exemplo",
                                    "Console Python para testes"
                                  ],
                                  "tips": "Mantenha symbols como strings imutáveis para evitar erros em comparações",
                                  "learningObjective": "Mapear dados de entrada (frequências) para objetos estruturados prontos para o heap",
                                  "commonMistakes": [
                                    "Usar frequency como symbol por engano",
                                    "Não criar nós para todos os símbolos",
                                    "Invertar freq e symbol nos argumentos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar a fila de prioridade vazia como min-heap",
                                  "subSteps": [
                                    "Importe o módulo heapq: from heapq import heappush, heappop, heapify",
                                    "Crie uma lista vazia: pq = []",
                                    "Opcionalmente, aplique heapify(pq), mas desnecessário para vazia",
                                    "Confirme que pq está vazia e pronta para inserções O(log n)",
                                    "Entenda que heapq usa lista como backing store com heap property"
                                  ],
                                  "verification": "Verifique len(pq) == 0 e que heappush/heappop não errem em testes vazios",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação heapq Python",
                                    "REPL Python para testes rápidos"
                                  ],
                                  "tips": "heapq é min-heap por default; sempre heappush para manter invariant",
                                  "learningObjective": "Configurar corretamente uma priority queue usando heapq para eficiência",
                                  "commonMistakes": [
                                    "Usar list.sort() em vez de heapq",
                                    "Esquecer import heapq",
                                    "Confundir max-heap com min-heap"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inserir todos os nós na fila de prioridade e verificar heap property",
                                  "subSteps": [
                                    "Para cada node em nodes: heappush(pq, node)",
                                    "Após todas inserções, verifique len(pq) == len(nodes)",
                                    "Teste heappop(pq) e confirme que retorna o nó com menor frequency",
                                    "Repita heappop até esvaziar e confirme ordem não-decrescente de frequencies",
                                    "Imprima pq[0] para ver raiz do heap (menor freq)"
                                  ],
                                  "verification": "heappop(pq) retorna nó com menor freq; heap permanece válido após múltiplos pops",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de nodes do step 2",
                                    "Funções heapq"
                                  ],
                                  "tips": "Evite acessar pq diretamente por índice; use heappush/pop para manter heap",
                                  "learningObjective": "População eficiente de priority queue e validação da ordenação por prioridade",
                                  "commonMistakes": [
                                    "Usar append em vez de heappush",
                                    "Pop sem push, causando IndexError",
                                    "Ignorar heapify após pushes manuais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para texto 'hello': freqs = {'h':1, 'e':1, 'l':2, 'o':1}. Crie nodes: Node(1,'h'), Node(1,'e'), Node(2,'l'), Node(1,'o'). pq = []; heappush todos. Resultado: pq[0] é um Node(1, 'h' ou 'e' ou 'o'), heappop dá menor freq primeiro. Código: from heapq import *; class Node: ...; pq = []; for sym,f in freqs.items(): heappush(pq, Node(f,sym)); print(heappop(pq))",
                              "finalVerifications": [
                                "A priority queue contém exatamente um nó por símbolo único",
                                "O primeiro elemento (pq[0]) tem a menor frequency",
                                "Múltiplos heappop extraem em ordem não-decrescente de frequency",
                                "Todos os nós retidos têm left=right=None (folhas iniciais)",
                                "Não há erros TypeError em comparações durante push/pop",
                                "len(pq) inicial == número de símbolos distintos"
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de __lt__ baseada apenas em frequency (O(1))",
                                "Eficiência: Inserções totais O(n log n) para n símbolos",
                                "Nós preservam symbol e frequency imutavelmente",
                                "Heap property mantida: parento <= filhos em toda estrutura",
                                "Testes unitários passam para casos edge (1 símbolo, freqs iguais)",
                                "Código limpo, legível com comentários em pontos chave"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de heap binário e propriedades de árvores completas",
                                "Estatística: Uso de frequências empíricas para priorização probabilística",
                                "Engenharia de Software: Abstrações de dados (PriorityQueue) em algoritmos greedy",
                                "Física/Telecomunicações: Compressão de sinal baseada em entropia de Shannon"
                              ],
                              "realWorldApplication": "Inicialização essencial no algoritmo de Huffman para compressão lossless de dados, usada em formatos como ZIP, GZIP, PNG e MP3, reduzindo tamanho de arquivos priorizando símbolos frequentes para códigos mais curtos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Priorizar símbolos frequentes",
                            "description": "Utilizar as frequências para determinar a ordem de fusão de nós na árvore de Huffman, combinando sempre os dois nós de menor frequência para otimizar o comprimento médio do código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e listar as frequências dos símbolos",
                                  "subSteps": [
                                    "Identifique todos os símbolos únicos no conjunto de dados de entrada.",
                                    "Calcule a frequência absoluta de cada símbolo contando suas ocorrências.",
                                    "Registre cada símbolo com sua frequência em uma tabela ou lista ordenada inicialmente por símbolo.",
                                    "Verifique a soma total das frequências para garantir que ela corresponda ao tamanho total dos dados.",
                                    "Normalize as frequências se necessário para probabilidades (divida pela soma total)."
                                  ],
                                  "verification": "Confirme que a lista de símbolos e frequências está completa e soma corretamente o total de ocorrências.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Conjunto de dados de exemplo (texto ou sequência de símbolos)",
                                    "Papel e caneta ou planilha (Excel/Google Sheets)"
                                  ],
                                  "tips": [
                                    "Use uma tabela com colunas: Símbolo, Frequência, Probabilidade para visualização clara.",
                                    "Comece com dados pequenos (5-10 símbolos) para prática inicial."
                                  ],
                                  "learningObjective": "Compreender como quantificar a importância relativa de cada símbolo via frequência.",
                                  "commonMistakes": [
                                    "Esquecer símbolos raros (frequência 1).",
                                    "Calcular frequência errada por contagem dupla.",
                                    "Não verificar soma total das frequências."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ordenar símbolos por frequência crescente",
                                  "subSteps": [
                                    "Ordene a lista de símbolos da menor para a maior frequência.",
                                    "Em caso de empate, priorize alfabeticamente ou por ID do símbolo.",
                                    "Crie uma fila de prioridade (min-heap conceitual) simulada com a lista ordenada.",
                                    "Atualize a lista sempre que novas frequências forem adicionadas.",
                                    "Pratique reordenando após cada fusão futura."
                                  ],
                                  "verification": "A lista deve mostrar o primeiro e segundo itens como os de menor frequência; teste com permutações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de frequências do Step 1",
                                    "Ferramenta de ordenação (papel ou Python sorted() para simulação)"
                                  ],
                                  "tips": [
                                    "Mantenha a lista dinâmica: reordene após cada inserção de novo nó.",
                                    "Visualize com setas apontando para os dois menores."
                                  ],
                                  "learningObjective": "Dominar a priorização baseada em frequência para seleção eficiente.",
                                  "commonMistakes": [
                                    "Ordenar decrescente em vez de crescente.",
                                    "Ignorar empates e combinar aleatoriamente.",
                                    "Não reordenar após fusões."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e fundir os dois nós de menor frequência",
                                  "subSteps": [
                                    "Extraia os dois primeiros da lista ordenada (menores frequências).",
                                    "Crie um novo nó pai com frequência igual à soma das duas filhos.",
                                    "Atribua o novo nó de volta à lista, reordenando se necessário.",
                                    "Registre a fusão: esquerdo/direito como os filhos originais.",
                                    "Repita até restar um nó raiz."
                                  ],
                                  "verification": "Simule uma fusão completa e confirme que cada passo combina os atuais menores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista ordenada do Step 2",
                                    "Diagrama em branco para desenhar árvore"
                                  ],
                                  "tips": [
                                    "Sempre combine esquerda com menor ou igual à direita para consistência.",
                                    "Use uma fila para simular heap: pop dois mins, push soma."
                                  ],
                                  "learningObjective": "Aplicar a regra de priorização para construir iterativamente a árvore de Huffman.",
                                  "commonMistakes": [
                                    "Combinar nós não-minores por distração.",
                                    "Somar frequências incorretamente.",
                                    "Perder a rastreabilidade dos nós filhos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a priorização calculando comprimento médio do código",
                                  "subSteps": [
                                    "Percorra a árvore final atribuindo 0/1 aos ramos (esquerda/direita).",
                                    "Calcule comprimento de código para cada símbolo (profundidade na árvore).",
                                    "Compute o comprimento médio: soma (freq * comprimento) / total_freq.",
                                    "Compare com codificação fixa para provar otimização.",
                                    "Ajuste simulações se o valor não for ótimo."
                                  ],
                                  "verification": "O comprimento médio deve ser menor ou igual ao de uma codificação não-otimizada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Árvore construída dos steps anteriores",
                                    "Calculadora ou script simples"
                                  ],
                                  "tips": [
                                    "Use fórmula: L = Σ (p_i * l_i) onde p_i = freq_i / total.",
                                    "Teste com frequências desiguais para ver benefício maior."
                                  ],
                                  "learningObjective": "Verificar que a priorização de menores frequências otimiza o comprimento médio.",
                                  "commonMistakes": [
                                    "Atribuir códigos errados na árvore.",
                                    "Esquecer de normalizar para probabilidades.",
                                    "Comparar com benchmark incorreto."
                                  ]
                                }
                              ],
                              "practicalExample": "Símbolos: A(5), B(2), C(1), D(3). Lista ordenada: C(1), B(2), D(3), A(5). Fusão 1: C+B → Novo1(3). Nova lista: Novo1(3), D(3), A(5). Fusão 2: Novo1(3)+D(3) → Novo2(6). Lista: Novo2(6), A(5). Fusão 3: A(5)+Novo2(6) → Raiz(11). Comprimento médio: ~2.18 bits/símbolo (otimizado).",
                              "finalVerifications": [
                                "Pode ordenar corretamente uma lista de 8 símbolos por frequência.",
                                "Simula fusões sem erros em um exemplo com 6 símbolos.",
                                "Calcula comprimento médio com precisão de 0.01.",
                                "Identifica violações da regra 'menores primeiro' em uma simulação errada.",
                                "Constrói árvore de Huffman manualmente para dados reais.",
                                "Explica por que priorizar menores otimiza o código."
                              ],
                              "assessmentCriteria": [
                                "Precisão na ordenação e seleção de nós (100% correto).",
                                "Eficiência: tempo de simulação < 5 min para 10 símbolos.",
                                "Compreensão conceitual: explica regra em próprias palavras.",
                                "Cálculo de comprimento médio exato e comparação válida.",
                                "Criatividade: aplica a exemplos personalizados.",
                                "Ausência de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e ponderação por frequência.",
                                "Estruturas de Dados: Árvores binárias e filas de prioridade (heaps).",
                                "Estatística: Distribuições de frequência e entropia de Shannon.",
                                "Telecomunicações: Compressão de dados em redes.",
                                "Física: Codificação em processamento de sinais digitais."
                              ],
                              "realWorldApplication": "Na compressão de arquivos ZIP, GZIP ou JPEG, o algoritmo de Huffman prioriza símbolos frequentes (ex: pixels comuns em imagens) para reduzir tamanho de dados em até 50%, economizando banda em streaming e armazenamento em nuvem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Verificar otimalidade por frequências",
                            "description": "Analisar como variações nas frequências afetam o comprimento médio do código gerado, relacionando com o princípio de codificação ótima de Huffman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Frequências de Símbolos e Construir Árvore de Huffman Inicial",
                                  "subSteps": [
                                    "Liste os símbolos e suas frequências originais de um conjunto de dados exemplo.",
                                    "Construa a árvore de Huffman usando o algoritmo padrão: crie nós folha, ordene por frequência e mescle os menores.",
                                    "Atribua códigos binários aos símbolos percorrendo a árvore (0 para esquerda, 1 para direita).",
                                    "Registre os comprimentos de código para cada símbolo.",
                                    "Calcule a entropia teórica como referência (H = -sum p_i * log2(p_i))."
                                  ],
                                  "verification": "Confirme que a árvore produz códigos prefix-free e que a soma das frequências é 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou planilha Excel",
                                    "Calculadora ou Python com heapq para simular Huffman"
                                  ],
                                  "tips": "Sempre normalize frequências para somar 1; use pilha de menor prioridade para eficiência.",
                                  "learningObjective": "Compreender como frequências determinam a estrutura da árvore de Huffman.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar frequências",
                                    "Atribuir códigos incorretamente na árvore",
                                    "Não verificar prefix-free"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Comprimento Médio do Código na Codificação Atual",
                                  "subSteps": [
                                    "Para cada símbolo, multiplique sua frequência pelo comprimento do código atribuído.",
                                    "Some todos os valores para obter o comprimento médio L = sum (p_i * l_i).",
                                    "Compare L com a entropia H: idealmente L >= H e próximo para otimalidade.",
                                    "Documente o valor exato de L e sua relação com H.",
                                    "Repita para garantir precisão aritmética."
                                  ],
                                  "verification": "L deve satisfazer H <= L < H + 1 para codificação ótima.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou script Python simples para soma ponderada"
                                  ],
                                  "tips": "Use log2 preciso; arredonde apenas no final para evitar erros de propagação.",
                                  "learningObjective": "Dominar o cálculo do comprimento médio e sua interpretação como métrica de eficiência.",
                                  "commonMistakes": [
                                    "Usar log10 em vez de log2 para entropia",
                                    "Confundir frequência com probabilidade",
                                    "Erro em multiplicações ponderadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Variações nas Frequências e Recalcular Comprimentos Médios",
                                  "subSteps": [
                                    "Aumente a frequência de um símbolo raro em 20% e diminua outros proporcionalmente.",
                                    "Reconstrua a árvore de Huffman com as novas frequências.",
                                    "Calcule o novo L' e compare com o original L.",
                                    "Repita para 2-3 variações: uma com símbolo comum mais frequente, outra com distribuição uniforme.",
                                    "Registre como L muda (ex: deve diminuir se otimizar para frequências altas)."
                                  ],
                                  "verification": "Observe que L diminui quando frequências altas ganham códigos mais curtos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha para variações ou código Python iterativo"
                                  ],
                                  "tips": "Mantenha soma de frequências =1 em cada variação; foque em mudanças pequenas para análise sensível.",
                                  "learningObjective": "Analisar sensibilidade do comprimento médio a variações de frequência.",
                                  "commonMistakes": [
                                    "Não renormalizar após variação",
                                    "Reusar árvore antiga sem reconstruir",
                                    "Ignorar efeitos em cadeia"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Otimalidade Relacionando com Princípios de Huffman",
                                  "subSteps": [
                                    "Confirme que para cada símbolo i, l_i <= l_j +1 se p_i > p_j (propriedade de Huffman).",
                                    "Verifique se L está próximo do mínimo possível (H <= L < H+1).",
                                    "Analise se variações confirmam que desvios de frequência aumentam L.",
                                    "Conclua se a codificação é ótima: sim se satisfaz Kraft e minimiza L.",
                                    "Documente insights sobre por que frequências altas priorizam códigos curtos."
                                  ],
                                  "verification": "Codificação é ótima se nenhuma troca de códigos reduz L e propriedades Kraft-McMillan são atendidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência teórica de Huffman (livro ou PDF)",
                                    "Ferramenta de verificação online opcional"
                                  ],
                                  "tips": "Use desigualdade de Kraft: sum 2^{-l_i} <=1 para prefix codes.",
                                  "learningObjective": "Aplicar critérios formais para validar otimalidade via frequências.",
                                  "commonMistakes": [
                                    "Confundir otimalidade com entropia zero",
                                    "Ignorar propriedade de comprimento adjacente",
                                    "Não testar contra alternativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere símbolos A(0.6), B(0.2), C(0.2). Árvore Huffman: A=0 (l=1), B=10 (l=2), C=11 (l=2). L = 0.6*1 + 0.2*2 + 0.2*2 = 1.4. Entropia H≈1.37. Varie para A(0.7), B(0.15), C(0.15): nova árvore A=0, B=10, C=11, L=1.3 (melhor). Varie para uniforme (1/3 cada): L=2.0 (pior), mostrando otimalidade para frequências desbalanceadas.",
                              "finalVerifications": [
                                "Comprimento médio L calculado corretamente para configuração original e variações.",
                                "Entropia H computada e comparada adequadamente com L.",
                                "Impacto de variações nas frequências analisado e documentado.",
                                "Propriedades de otimalidade de Huffman (comprimentos adjacentes, Kraft) verificadas.",
                                "Conclusão explícita sobre otimalidade da codificação.",
                                "Todos cálculos sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção em todos os cálculos de L e H (100% exatidão).",
                                "Profundidade na análise de variações (pelo menos 3 cenários testados).",
                                "Correta aplicação de teoremas de Huffman para verificação.",
                                "Clareza na documentação de árvores, códigos e comparações.",
                                "Interpretação qualitativa: explica por que frequências afetam otimalidade.",
                                "Eficiência no uso de tempo e recursos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Informação e Entropia de Shannon.",
                                "Estatística: Distribuições de Probabilidade e Análise de Sensibilidade.",
                                "Economia: Otimização de Recursos e Alocação sob Restrições.",
                                "Engenharia de Software: Compressão de Dados em Arquivos e Redes."
                              ],
                              "realWorldApplication": "Em compressores como ZIP, GZIP ou JPEG, verificar otimalidade por frequências garante arquivos menores em transmissão de dados, economizando banda em redes e armazenamento em cloud, como no processamento de logs de servidores onde símbolos comuns (ex: espaços) dominam."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Construção da Árvore de Huffman",
                    "description": "Algoritmo guloso para construir uma árvore binária a partir das frequências, combinando nós de menor frequência.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Inicialização dos Nós Folhas",
                        "description": "Definição da estrutura de dados para representar os nós da árvore de Huffman, incluindo folhas com símbolos e frequências, preparando a fila de prioridades inicial.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Definir a estrutura do Nó de Huffman",
                            "description": "Implementar uma classe ou estrutura para nó com campos: símbolo (opcional para folhas), frequência, ponteiros para filhos esquerdo e direito, e flag para identificar se é folha ou nó interno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar os requisitos do nó de Huffman",
                                  "subSteps": [
                                    "Estude a codificação de Huffman e identifique os elementos essenciais de um nó: símbolo (para folhas), frequência, ponteiros esquerdo e direito.",
                                    "Determine que nós internos não têm símbolo, mas todos têm frequência e ponteiros para filhos.",
                                    "Decida sobre uma flag para distinguir folhas de nós internos (ex: booleano is_leaf).",
                                    "Considere tipos de dados: string/char para símbolo, int/float para frequência, ponteiros para outros nós.",
                                    "Anote os casos especiais: folhas têm símbolo e frequência, sem filhos; internos têm frequência somada e dois filhos."
                                  ],
                                  "verification": "Crie um diagrama ou lista anotada confirmando todos os campos necessários sem omissões.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Documentação sobre árvore de Huffman"
                                  ],
                                  "tips": "Comece listando exemplos de folhas e nós internos para visualizar diferenças.",
                                  "learningObjective": "Compreender os componentes fundamentais e suas diferenças entre folhas e nós internos.",
                                  "commonMistakes": "Confundir frequência de folhas com somatória de nós internos ou ignorar ponteiros nulos em folhas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a estrutura da classe ou struct",
                                  "subSteps": [
                                    "Escolha a linguagem de programação (ex: Python para classes simples ou C++ para structs).",
                                    "Defina os atributos: symbol (opcional, None para internos), frequency (int/float), left (Node*), right (Node*), is_leaf (bool).",
                                    "Planeje o construtor para inicializar atributos corretamente.",
                                    "Considere métodos auxiliares como getters para frequency ou is_leaf.",
                                    "Desenhe um esboço UML simples da classe com atributos e relações."
                                  ],
                                  "verification": "Revise o esboço para garantir que todos os 5 campos principais estejam presentes e tipados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE como VS Code",
                                    "Referência de sintaxe da linguagem escolhida"
                                  ],
                                  "tips": "Use nomes descritivos como 'freq' em vez de abreviações obscuras para facilitar leitura.",
                                  "learningObjective": "Projetar uma estrutura de dados que suporte a construção da árvore de Huffman.",
                                  "commonMistakes": "Tornar symbol obrigatório para todos os nós ou esquecer de inicializar ponteiros como None/null."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a classe Node",
                                  "subSteps": [
                                    "Escreva a declaração da classe com todos os atributos.",
                                    "Implemente o construtor: aceite symbol, frequency, left=None, right=None, e defina is_leaf baseado em left/right.",
                                    "Adicione métodos simples como get_frequency() e is_leaf() para encapsulamento.",
                                    "Garanta que folhas tenham symbol != None e left=right=None; internos tenham symbol=None.",
                                    "Teste sintaxe compilando ou executando um script vazio com a classe."
                                  ],
                                  "verification": "Instancie um nó folha e um interno; imprima atributos para confirmar valores corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com suporte a Python/C++ (ex: PyCharm ou Code::Blocks)",
                                    "Terminal para testes"
                                  ],
                                  "tips": "Use __init__ em Python com valores default para flexibilidade no construtor.",
                                  "learningObjective": "Codificar uma estrutura funcional que represente nós de Huffman.",
                                  "commonMistakes": "Erro de digitação em nomes de atributos ou esquecer de importar módulos necessários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar a estrutura",
                                  "subSteps": [
                                    "Crie testes unitários para nós folha e interno: verifique atributos e flag is_leaf.",
                                    "Simule uma mini-árvore conectando dois nós folha a um interno.",
                                    "Verifique se frequência do interno é soma das folhas.",
                                    "Adicione docstrings ou comentários explicando cada campo.",
                                    "Refatore se necessário para otimizar (ex: usar propriedades em Python)."
                                  ],
                                  "verification": "Execute testes e confirme que todas instâncias passam sem erros ou asserções falhas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Framework de testes como unittest (Python) ou Google Test (C++)",
                                    "Exemplos de árvores de Huffman"
                                  ],
                                  "tips": "Priorize testes edge-case como nó com frequência zero.",
                                  "learningObjective": "Garantir robustez e corretude da estrutura para uso em algoritmos de Huffman.",
                                  "commonMistakes": "Não testar nós internos ou assumir que construtor sempre recebe todos os parâmetros."
                                }
                              ],
                              "practicalExample": "Em Python:\nclass HuffmanNode:\n    def __init__(self, symbol=None, freq=0, left=None, right=None):\n        self.symbol = symbol\n        self.freq = freq\n        self.left = left\n        self.right = right\n        self.is_leaf = left is None and right is None\n\n# Exemplo de uso:\nleaf1 = HuffmanNode('A', 5)\nleaf2 = HuffmanNode('B', 3)\ninternal = HuffmanNode(freq=8, left=leaf1, right=leaf2)\nprint(internal.is_leaf)  # False",
                              "finalVerifications": [
                                "Classe possui exatamente os campos: symbol (opcional), freq, left, right, is_leaf.",
                                "Construtor inicializa corretamente folhas (symbol != None, left=right=None, is_leaf=True).",
                                "Nós internos têm symbol=None, is_leaf=False, e freq como soma de filhos.",
                                "Métodos auxiliares (se implementados) retornam valores esperados.",
                                "Código compila/executa sem erros de sintaxe.",
                                "Testes unitários cobrem folhas e nós internos."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos os campos obrigatórios estão presentes e corretamente tipados.",
                                "Corretude: Flag is_leaf é computada logicamente baseada em filhos.",
                                "Encapsulamento: Uso de construtores e métodos para acesso seguro.",
                                "Clareza: Código comentado com nomenclatura intuitiva.",
                                "Robustez: Inicialização padrão evita erros em cenários comuns.",
                                "Eficiência: Estrutura minimalista sem campos desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores binárias e teoria de grafos para estrutura hierárquica.",
                                "Probabilidade: Frequências como probabilidades em entropia de informação.",
                                "Engenharia de Software: Design de classes e padrões como Composite para árvores.",
                                "Física/Química: Compressão de dados em simulações científicas (ex: arquivos de dados experimentais)."
                              ],
                              "realWorldApplication": "Essa estrutura é fundamental para implementar compressão lossless em ferramentas como ZIP, GZIP ou JPEG, reduzindo tamanho de arquivos de texto/imagens ao codificar símbolos frequentes com bits menores, economizando banda em transmissão de dados na web."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Criar lista de nós folhas a partir de frequências",
                            "description": "Dado um array de frequências de símbolos, instanciar nós folhas correspondentes e inseri-los em uma fila de prioridade mínima ordenada pela frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura da classe Node para nós folhas",
                                  "subSteps": [
                                    "Crie uma classe Node com atributos: symbol (símbolo), freq (frequência), left (esquerda, None para folha), right (direita, None para folha).",
                                    "Implemente o método __lt__ para comparação baseada na frequência, permitindo uso em heap (menor frequência primeiro; em caso de empate, use símbolo alfabeticamente).",
                                    "Adicione um método para representação string (__repr__) para depuração.",
                                    "Teste a classe criando um nó manualmente e imprimindo.",
                                    "Garanta que nós folhas tenham left e right como None."
                                  ],
                                  "verification": "Instancie um Node e verifique se __lt__ ordena corretamente dois nós com freq diferentes; imprima repr para confirmar atributos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Documentação Python heapq",
                                    "Exemplo de array de frequências: [('a',5), ('b',9)]"
                                  ],
                                  "tips": "Use freq como chave primária no __lt__, e symbol como desempate para estabilidade.",
                                  "learningObjective": "Compreender como definir objetos comparáveis para priority queues em árvores de Huffman.",
                                  "commonMistakes": "Esquecer de definir __lt__ levando a TypeError no heap; não tratar empates causando ordenação instável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processar array de frequências e instanciar nós folhas",
                                  "subSteps": [
                                    "Receba o input como lista de tuplas: [(symbol, freq), ...].",
                                    "Inicialize uma lista vazia para armazenar os nós folhas.",
                                    "Para cada tupla no array, crie um Node(symbol, freq, left=None, right=None).",
                                    "Adicione o nó à lista de nós.",
                                    "Imprima a lista de nós para inspeção visual."
                                  ],
                                  "verification": "Confira se o número de nós criados equals o tamanho do array de input e se cada nó tem symbol e freq corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python interpreter",
                                    "Lista de exemplo: [('a',5), ('b',9), ('c',12), ('d',13), ('e',16), ('f',45)]"
                                  ],
                                  "tips": "Valide que freq > 0 para evitar nós inválidos; use list comprehension para eficiência.",
                                  "learningObjective": "Mapear dados de entrada diretamente para objetos estruturados representando folhas da árvore.",
                                  "commonMistakes": "Inverter symbol e freq nas tuplas; criar nós com left/right não-None."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar priority queue mínima e inserir nós folhas",
                                  "subSteps": [
                                    "Importe heapq do módulo heapq.",
                                    "Crie uma lista vazia para o heap.",
                                    "Para cada nó na lista de nós folhas, use heappush(heap, node).",
                                    "Use heapify se necessário, mas push é sequencial.",
                                    "Imprima o heap[0] para verificar o nó de menor frequência no topo."
                                  ],
                                  "verification": "Pop o menor nó com heappop e confirme que é o de menor freq; reinsira e verifique ordenação com heapify e sorted.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Módulo heapq Python",
                                    "Lista de nós do step anterior"
                                  ],
                                  "tips": "heapq é min-heap nativo; __lt__ garante ordem correta sem chaves extras.",
                                  "learningObjective": "Implementar fila de prioridade usando heap para ordenação eficiente por frequência.",
                                  "commonMistakes": "Usar lista comum em vez de heapq levando a O(n) inserts; ignorar ordenação decrescente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e validar a fila de prioridade inicializada",
                                  "subSteps": [
                                    "Extraia todos os nós do heap usando loop de heappop e colete em lista.",
                                    "Confirme que a lista extraída está ordenada por freq crescente.",
                                    "Verifique que nenhum nó foi perdido (len == input size).",
                                    "Teste com input de empates de freq para validar desempate por symbol.",
                                    "Documente o estado final da queue como lista ordenada."
                                  ],
                                  "verification": "Compare lista extraída com sorted(nos, key=lambda n: (n.freq, n.symbol)) para igualdade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função sorted Python",
                                    "Exemplos de teste com empates: [('x',10), ('y',10)]"
                                  ],
                                  "tips": "Use copy do heap para testes sem destruir original.",
                                  "learningObjective": "Garantir corretude e ordenação da estrutura de dados inicial para construção da árvore Huffman.",
                                  "commonMistakes": "Destruir heap durante verificação; não testar empates."
                                }
                              ],
                              "practicalExample": "Dado frequencies = [('a', 5), ('b', 9), ('c', 12), ('d', 13), ('e', 16), ('f', 45)]:\n1. Crie nodes: Node('a',5), Node('b',9), etc.\n2. Insira em heap.\n3. Heap topo: Node('a',5); após pops sequenciais: a(5), b(9), c(12), d(13), e(16), f(45). Código Python:\nclass Node:\n    def __init__(self, sym, f): self.symbol=sym; self.freq=f; self.left=self.right=None\n    def __lt__(self, other): return (self.freq, self.symbol) < (other.freq, other.symbol)\nimport heapq\nheap = []\nfor sym, f in frequencies: heapq.heappush(heap, Node(sym, f))\nprint([n.symbol for n in sorted(heap)])  # ['a','b','c','d','e','f']",
                              "finalVerifications": [
                                "Todos os símbolos do input estão presentes como nós folhas na queue.",
                                "A queue retorna nós em ordem crescente de frequência via heappop sequencial.",
                                "Empates de frequência são resolvidos alfabeticamente pelo símbolo.",
                                "Nenhum nó tem left ou right definidos (são folhas puras).",
                                "Tamanho da queue equals número de símbolos de input.",
                                "Frequências nos nós matcham exatamente o array de input."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Nós criados e ordenados precisamente conforme input.",
                                "Eficiência: Uso de heapq garante O(n log n) inserts.",
                                "Robustez: Lida com empates e freq zero/inválidas.",
                                "Clareza: Código legível com Node bem definido e comentários.",
                                "Testabilidade: Verificações implementadas e passam em casos edge.",
                                "Modularidade: Funções separadas para criar nodes e popular heap."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Heaps e ordenação topológica; probabilidades em frequências.",
                                "Estatística: Análise de distribuições de frequências para compressão.",
                                "Engenharia de Software: Design de classes e estruturas de dados orientadas a objetos.",
                                "Algoritmos: Complexidade O(n log n) para inicialização de priority queue."
                              ],
                              "realWorldApplication": "Esta etapa é crucial na codificação Huffman para compressão lossless de dados, usada em ZIP, JPEG e transmissão de rede, onde frequências de caracteres/bytes são coletadas de textos ou imagens para construir árvores ótimas de prefixo, reduzindo tamanho de arquivos em até 50% em dados textuais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Configurar fila de prioridade mínima",
                            "description": "Utilizar uma heap mínima (priority queue) para armazenar os nós, garantindo que o nó com menor frequência sempre seja acessível no topo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura do nó compatível com min-heap",
                                  "subSteps": [
                                    "Crie uma classe Node com atributos: frequency (int), char (str ou None), left (Node ou None), right (Node ou None).",
                                    "Implemente o método especial __lt__(self, other) para comparar frequencies: return self.frequency < other.frequency.",
                                    "Adicione um método __repr__ para facilitar debugging e visualização dos nós.",
                                    "Teste a criação de um nó de exemplo com frequency=5 e char='a'.",
                                    "Verifique se dois nós podem ser comparados corretamente via print(n1 < n2)."
                                  ],
                                  "verification": "Criar dois nós e confirmar que n1 < n2 retorna True se frequency de n1 for menor; sem erros de comparação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Python 3.8+ com módulo heapq"
                                  ],
                                  "tips": "Priorize frequency na comparação; se empatar, compare char para estabilidade.",
                                  "learningObjective": "Compreender como objetos customizados integram com estruturas heap via operador lt.",
                                  "commonMistakes": [
                                    "Esquecer de definir __lt__ levando a TypeError",
                                    "Comparar self.frequency > other.frequency (invertendo min-heap)",
                                    "Não inicializar left/right como None"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a fila de prioridade mínima vazia",
                                  "subSteps": [
                                    "Importe o módulo heapq do Python.",
                                    "Crie uma lista vazia pq = [] para servir como heap.",
                                    "Registre heapq como min-heap chamando heapq.heapify(pq) (embora vazia, prepara a estrutura).",
                                    "Adicione uma função auxiliar para heappush e heappop wrapper se desejar abstração.",
                                    "Teste push/pop com nós dummy para confirmar heapify funciona."
                                  ],
                                  "verification": "pq está vazia (len(pq) == 0) e heapq.heappush/pq funciona sem erros em teste.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Documentação heapq (opcional)"
                                  ],
                                  "tips": "Use lista como backing store; heapq modifica in-place para eficiência O(1) amortizado.",
                                  "learningObjective": "Dominar inicialização de min-heap via heapq para priorização dinâmica.",
                                  "commonMistakes": [
                                    "Usar max-heap inadvertidamente",
                                    "Não importar heapq",
                                    "Tentativa de heapify em lista não-heap"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inserir todos os nós folhas na priority queue",
                                  "subSteps": [
                                    "Crie lista de nós folhas baseados em frequências de exemplo (ex: {'a':5, 'b':9, 'c':12}).",
                                    "Para cada par freq/char, instancie Node e chame heapq.heappush(pq, node).",
                                    "Insira todos os nós, garantindo ordem heap (menor frequency no topo).",
                                    "Imprima o topo: print(pq[0].frequency) para confirmar menor valor.",
                                    "Conte o número de nós: assert len(pq) == número de folhas."
                                  ],
                                  "verification": "heapq.heappop(pq) retorna nó com menor frequency; heap mantém ordem após múltiplos push.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Dicionário de frequências exemplo"
                                  ],
                                  "tips": "heappush auto-rebalanceia em O(log n); evite acessar pq[1:] diretamente.",
                                  "learningObjective": "Aplicar inserções em heap para construir fila inicial de nós Huffman.",
                                  "commonMistakes": [
                                    "Inserir frequencies diretamente em vez de Nodes",
                                    "Push em ordem errada ignorando heap",
                                    "Não tratar empates em frequency"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a configuração da priority queue",
                                  "subSteps": [
                                    "Extraia o topo múltiplas vezes com heappop e verifique sequência crescente de frequencies.",
                                    "Simule remoção dos 2 menores e confirme rebalanceamento.",
                                    "Teste com dataset maior (6-8 caracteres) para escalabilidade.",
                                    "Adicione assertions: pq[0].frequency == min das frequencies originais.",
                                    "Documente o estado final da pq para próxima etapa de Huffman."
                                  ],
                                  "verification": "Todos pops retornam nós em ordem não-decrescente de frequency; heap vazio após esvaziar.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código completo anterior",
                                    "Unittest ou asserts simples"
                                  ],
                                  "tips": "Use heappop em loop para validar heap property completamente.",
                                  "learningObjective": "Verificar propriedades de min-heap para confiabilidade em algoritmos greedy.",
                                  "commonMistakes": [
                                    "Acessar pq como lista ordenada (não é)",
                                    "Ignorar rebalanceamento pós-pop",
                                    "Testar só com 2 nós"
                                  ]
                                }
                              ],
                              "practicalExample": "Dadas frequências {'a':5, 'b':9, 'c':12, 'd':13, 'e':14, 'f':45}, crie nós e insira em pq. Após pushes, pq[0] deve ser nó 'a' (freq=5). Pop retorna 'a', novo topo 'b' (9), confirmando min-heap.",
                              "finalVerifications": [
                                "Priority queue contém exatamente todos os nós folhas inseridos.",
                                "Nó no topo (pq[0]) tem a menor frequency.",
                                "Múltiplos heappop extraem nós em ordem crescente de frequency.",
                                "Nenhum erro TypeError em comparações de nós.",
                                "Len(pq) reflete número correto de inserções.",
                                "Heap property mantida: para qualquer i, pq[i] <= pq[2*i+1] e pq[2*i+2]."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de Node com __lt__ baseado em frequency.",
                                "Uso apropriado de heapq.heappush/heappop sem manipulações manuais.",
                                "Validação empírica da ordem min-heap via pops sequenciais.",
                                "Tratamento de empates (ex: stable sort por char).",
                                "Eficiência: O(n log n) para n inserções.",
                                "Código limpo, legível com comentários em pontos chave."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de heaps como árvores binárias completas e invariantes heap.",
                                "Estatística: Uso de frequências empíricas para priorização probabilística.",
                                "Engenharia de Software: Abstrações de dados (priority queue) em design de algoritmos.",
                                "Análise de Algoritmos: Complexidade O(n log n) na construção inicial."
                              ],
                              "realWorldApplication": "Na codificação Huffman para compressão de dados (ex: arquivos ZIP, MP3, JPEG), a min-heap garante seleção eficiente dos nós menos frequentes para construir árvore ótima, reduzindo tamanho de arquivos em até 50% em textos reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1",
                              "10.1.6.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Combinação Gulosa de Nós",
                        "description": "Processo iterativo do algoritmo guloso que seleciona e combina os dois nós de menor frequência para formar um novo nó interno.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Extrair e combinar os dois menores nós",
                            "description": "Em um loop, extrair o menor nó da fila, extrair o segundo menor, criar um novo nó interno com frequência soma das duas, e inserir o novo nó de volta na fila.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Extrair o menor nó da fila de prioridade",
                                  "subSteps": [
                                    "Identifique a fila de prioridade (min-heap) contendo os nós ordenados por frequência.",
                                    "Aplique a operação extractMin() para remover e retornar o nó com a menor frequência.",
                                    "Armazene o nó extraído em uma variável temporária, como 'menorNo'.",
                                    "Confirme que a fila agora tem um nó a menos e está reordenada.",
                                    "Registre a frequência do nó extraído para verificação posterior."
                                  ],
                                  "verification": "Verifique se o nó extraído tem a menor frequência comparando com os restantes na fila.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Implementação de min-heap ou PriorityQueue em Python/Java, lista de nós iniciais.",
                                  "tips": "Use bibliotecas built-in como heapq em Python para simplicidade inicial.",
                                  "learningObjective": "Dominar a operação de extração mínima em uma fila de prioridade.",
                                  "commonMistakes": "Esquecer de reordenar a heap após extração; extrair o maior em vez do menor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair o segundo menor nó da fila",
                                  "subSteps": [
                                    "Após a primeira extração, aplique novamente extractMin() na fila atualizada.",
                                    "Armazene este nó em uma variável como 'segundoMenorNo'.",
                                    "Valide que este nó tem a próxima menor frequência em relação ao primeiro extraído.",
                                    "Mantenha um log das frequências extraídas para rastreamento.",
                                    "Garanta que a fila permaneça válida como min-heap."
                                  ],
                                  "verification": "Compare as frequências: segundoMenorNo.freq >= menorNo.freq, e não há nós menores restantes.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Mesma fila de prioridade atualizada, debugger ou print statements.",
                                  "tips": "Visualize a heap com diagramas para entender a reordenação.",
                                  "learningObjective": "Entender como extrações sequenciais mantêm a propriedade da heap.",
                                  "commonMistakes": "Extrair o mesmo nó duas vezes; ignorar mudanças na heap após primeira extração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar novo nó interno com soma das frequências",
                                  "subSteps": [
                                    "Crie um novo nó pai com frequência = menorNo.freq + segundoMenorNo.freq.",
                                    "Defina os filhos esquerdo e direito: tipicamente menorNo como esquerdo, segundoMenorNo como direito.",
                                    "Inicialize o novo nó sem caractere (nó interno).",
                                    "Atualize ponteiros: novoNo.esquerdo = menorNo; novoNo.direito = segundoMenorNo.",
                                    "Teste a soma aritmética para precisão."
                                  ],
                                  "verification": "Confirme que novoNo.freq == soma exata e filhos estão corretamente atribuídos.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Classe Nó personalizada com campos freq, esquerdo, direito, char.",
                                  "tips": "Sempre defina esquerda como o menor para consistência na árvore final.",
                                  "learningObjective": "Construir nós internos na árvore binária de Huffman.",
                                  "commonMistakes": "Erro na soma (overflow em linguagens com int); inverter filhos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inserir o novo nó de volta na fila de prioridade",
                                  "subSteps": [
                                    "Aplique insert() ou push() na fila com o novoNo.",
                                    "Verifique se a heap se reordena corretamente, promovendo o novo nó se necessário.",
                                    "Confirme que o topo da fila agora reflete o próximo menor.",
                                    "Atualize contadores de loop se necessário (ex: enquanto fila.size > 1).",
                                    "Repita o processo até restar um nó (raiz da árvore)."
                                  ],
                                  "verification": "NovoNo está na fila e extractMin() subsequente retorna o esperado menor.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Fila de prioridade, nó recém-criado.",
                                  "tips": "Monitore o tamanho da fila: deve diminuir em 1 a cada iteração.",
                                  "learningObjective": "Completar o ciclo guloso da construção de Huffman.",
                                  "commonMistakes": "Inserir sem manter propriedade heap; loop infinito por não checar tamanho."
                                }
                              ],
                              "practicalExample": "Dadas frequências: a:5, b:9, c:12, d:13, e:16. Fila inicial heap: [5(a),9(b),12(c),13(d),16(e)]. Extraia 5(a) e 9(b), crie novoNo:14 (esq:a, dir:b). Insira 14. Nova heap: [12(c),13(d),14(novo),16(e)]. Repita.",
                              "finalVerifications": [
                                "Fila reduzida corretamente em 1 nó por iteração.",
                                "Todos novos nós têm frequência igual à soma dos filhos.",
                                "Nenhum nó tem frequência menor que esperado no topo após inserções.",
                                "Filhos atribuídos consistentemente (menor à esquerda).",
                                "Loop termina quando fila.size == 1.",
                                "Estrutura da árvore parcial é binária válida."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas operações extractMin e insert (100% correto).",
                                "Eficiência: O(log n) por operação em heap de tamanho n.",
                                "Correção da soma de frequências sem erros aritméticos.",
                                "Manutenção da propriedade min-heap em todas as etapas.",
                                "Capacidade de iterar o processo até a raiz única.",
                                "Código limpo com comentários explicativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações de soma e ordenação em conjuntos numéricos.",
                                "Estruturas de Dados: Heaps e árvores binárias.",
                                "Algoritmos: Estratégias gulosas e análise de complexidade O(n log n).",
                                "Programação: Manipulação de objetos e ponteiros/referências."
                              ],
                              "realWorldApplication": "Esse passo é crucial na codificação de Huffman para compressão de arquivos (ex: ZIP, JPEG), reduzindo tamanho de dados ao atribuir códigos mais curtos a símbolos frequentes, economizando largura de banda em streaming e armazenamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Criar nó interno pai",
                            "description": "Instanciar um nó interno definindo seu filho esquerdo como o primeiro extraído, direito como o segundo, e frequência como a soma, preservando a propriedade de árvore binária completa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instanciar o novo nó interno pai",
                                  "subSteps": [
                                    "Declare uma nova variável para representar o nó pai (ex: new_node).",
                                    "Crie uma instância da classe Node ou estrutura equivalente, inicializando-a como nó interno (não folha).",
                                    "Inicialize campos básicos como frequência em 0 e ponteiros de filhos como null temporariamente.",
                                    "Confirme que o nó foi alocado corretamente sem erros de memória."
                                  ],
                                  "verification": "Verifique se a variável new_node aponta para um objeto Node válido e não é null.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Ambiente de programação (Python/Java/C++)",
                                    "Definição da classe Node"
                                  ],
                                  "tips": "Use 'Node* new_node = new Node();' em C++ ou 'new_node = Node()' em Python para instanciação.",
                                  "learningObjective": "Compreender a instanciação de objetos para representar nós em estruturas de árvores.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar como nó interno (marcar como folha)",
                                    "Não alocar memória corretamente levando a ponteiros nulos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os filhos esquerdo e direito do nó pai",
                                  "subSteps": [
                                    "Atribua o primeiro nó extraído da fila (menor frequência) como filho esquerdo (leftChild).",
                                    "Atribua o segundo nó extraído como filho direito (rightChild).",
                                    "Garanta que os ponteiros sejam copiados corretamente sem duplicação de nós.",
                                    "Atualize os pais dos nós filhos para apontarem para o novo nó pai, se aplicável.",
                                    "Verifique se não há referências circulares."
                                  ],
                                  "verification": "Confirme que new_node.leftChild == primeiro_nó_extraído e new_node.rightChild == segundo_nó_extraído.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código da fila de prioridade com nós extraídos",
                                    "Editor de código com depurador"
                                  ],
                                  "tips": "Mantenha a convenção de filho esquerdo com menor ou igual frequência para consistência.",
                                  "learningObjective": "Dominar a ligação hierárquica de nós em árvores binárias.",
                                  "commonMistakes": [
                                    "Inverter a ordem dos filhos",
                                    "Perder referências aos nós filhos ao atribuir"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e atribuir a frequência do nó pai",
                                  "subSteps": [
                                    "Extraia as frequências dos dois nós filhos (freq_left e freq_right).",
                                    "Calcule a soma: freq_pai = freq_left + freq_right.",
                                    "Atribua o valor calculado ao campo frequência do nó pai.",
                                    "Valide numericamente se a soma está correta (ex: assert freq_pai == freq_left + freq_right).",
                                    "Registre o valor para depuração futura."
                                  ],
                                  "verification": "Teste se a frequência do nó pai é exatamente a soma das frequências dos filhos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código de depuração ou print statements",
                                    "Exemplos de frequências numéricas"
                                  ],
                                  "tips": "Use inteiros de 64 bits se frequências forem grandes para evitar overflow.",
                                  "learningObjective": "Aplicar operações aritméticas básicas na construção de árvores de Huffman.",
                                  "commonMistakes": [
                                    "Erro de soma aritmética simples",
                                    "Usar multiplicação em vez de soma"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar preservação da propriedade de árvore binária completa e preparar inserção",
                                  "subSteps": [
                                    "Confirme que o novo nó tem exatamente dois filhos (não é folha).",
                                    "Verifique se a estrutura mantém heap property localmente (frequência pai <= filhos, mas foco em ABC).",
                                    "Prepare o nó para inserção na fila de prioridade (min-heap garante ABC via sift-up).",
                                    "Teste a criação isoladamente antes de inserir.",
                                    "Documente o novo nó com profundidade ou ID para rastreamento."
                                  ],
                                  "verification": "Simule inserção na fila e confirme que a heap permanece completa (todos níveis cheios exceto último, à esquerda).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Implementação de min-heap/fila de prioridade",
                                    "Ferramentas de visualização de árvores (ex: Graphviz)"
                                  ],
                                  "tips": "A propriedade ABC é preservada pela operação insert do heap; foque na estrutura do nó.",
                                  "learningObjective": "Entender como a criação de nós internos mantém invariantes de heaps binários completos.",
                                  "commonMistakes": [
                                    "Criar nó com um só filho, violando completude",
                                    "Ignorar ordem esquerda-direita na heap"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada uma fila de prioridade com nós: A(freq=2), B(freq=3), C(freq=5). Extraia A e B. Crie nó pai P com left=A, right=B, freq=5. Insira P na fila, resultando em P(5), C(5). A árvore mantém propriedade de heap min e binária completa.",
                              "finalVerifications": [
                                "Nó pai tem leftChild e rightChild corretamente atribuídos aos nós extraídos.",
                                "Frequência do pai é exatamente a soma das frequências dos filhos.",
                                "Nó é marcado como interno (não folha).",
                                "Não há vazamentos de memória ou ponteiros nulos.",
                                "Inserção simulada preserva a propriedade de min-heap e árvore binária completa.",
                                "Código executa sem erros e produz árvore válida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na atribuição de filhos (100% correto).",
                                "Correção do cálculo de frequência (sem erros aritméticos).",
                                "Manutenção de invariantes da estrutura de dados (ABC e heap).",
                                "Eficiência temporal (O(1) para criação, O(log n) para insert).",
                                "Clareza e comentação do código.",
                                "Tratamento de casos edge (frequências zero ou iguais)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas e propriedades de somas em árvores.",
                                "Programação Orientada a Objetos: Instanciação e composição de objetos.",
                                "Estruturas de Dados: Heaps e árvores binárias.",
                                "Algoritmos: Estratégias gulosas e invariantes.",
                                "Análise de Complexidade: Impacto na construção O(n log n) do Huffman."
                              ],
                              "realWorldApplication": "Essa operação é o cerne da construção da árvore de Huffman, usada em compressão de dados como arquivos ZIP, formatos de imagem JPEG/PNG e transmissão de rede (ex: protocolos de compressão em telecomunicações), reduzindo tamanho de dados em até 50% em textos comuns."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1",
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Repetir até restar um nó (raiz)",
                            "description": "Continuar o processo de combinação até que apenas um nó permaneça na fila, que será a raiz da árvore de Huffman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e verificar a condição de parada do loop",
                                  "subSteps": [
                                    "Revise a fila de prioridade atual com nós ordenados por frequência.",
                                    "Verifique o número de nós na fila usando len(queue) > 1.",
                                    "Se len(queue) == 1, pare o loop e identifique esse nó como raiz.",
                                    "Documente o estado inicial da fila para rastreamento.",
                                    "Prepare um log de iterações para registrar mudanças."
                                  ],
                                  "verification": "Confirme que o loop só continua se houver mais de um nó; teste com fila de 1 nó para parada imediata.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Fila de prioridade (simulada em papel ou heapq em Python)",
                                    "Lista de nós com frequências"
                                  ],
                                  "tips": "Sempre verifique a condição no início de cada iteração para evitar loops infinitos.",
                                  "learningObjective": "Entender a lógica de parada que garante a formação da árvore completa.",
                                  "commonMistakes": "Ignorar a condição e continuar combinando quando só resta um nó, causando erro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e extrair os dois nós de menor frequência",
                                  "subSteps": [
                                    "Identifique o nó com a menor frequência (topo da min-heap).",
                                    "Extraia-o temporariamente da fila.",
                                    "Identifique e extraia o próximo menor nó da fila atualizada.",
                                    "Registre as frequências extraídas para o novo nó pai.",
                                    "Valide que os dois selecionados são realmente os menores."
                                  ],
                                  "verification": "Os dois nós extraídos têm as menores frequências na fila original; compare manualmente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Implementação de min-heap (Python heapq ou papel com lista ordenada)",
                                    "Calculadora para somas"
                                  ],
                                  "tips": "Use uma priority queue para extração O(log n); simule com lista ordenada para aprendizado.",
                                  "learningObjective": "Dominar a seleção gulosa dos nós de menor prioridade.",
                                  "commonMistakes": "Selecionar nós errados, como o maior em vez do menor, quebrando a optimalidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar o nó interno pai com os dois nós como filhos",
                                  "subSteps": [
                                    "Crie um novo nó com frequência igual à soma das frequências dos dois filhos.",
                                    "Atribua o primeiro nó extraído como filho esquerdo e o segundo como direito (ordem não importa para Huffman).",
                                    "Marque o novo nó como interno (não folha).",
                                    "Atualize ponteiros: novo_nó.left = nó1, novo_nó.right = nó2.",
                                    "Teste a estrutura: novo_nó.freq == nó1.freq + nó2.freq."
                                  ],
                                  "verification": "Novo nó tem frequência correta e aponta corretamente para os filhos; visualize a sub-árvore.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Classe Nó em Python ou diagrama em papel",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Mantenha consistência na convenção left/right para facilitar debug.",
                                  "learningObjective": "Construir nós internos que representem sub-árvores balanceadas por frequência.",
                                  "commonMistakes": "Erro na soma de frequências ou inverter filhos, afetando codificação posterior."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inserir o novo nó de volta na fila de prioridade",
                                  "subSteps": [
                                    "Insira o novo nó na heap mantendo a ordem por frequência.",
                                    "Reordene a fila para que o menor fique no topo.",
                                    "Confirme que a fila agora tem o mesmo número de nós que antes da extração.",
                                    "Atualize o log de iterações com o novo estado da fila.",
                                    "Simule uma iteração completa para validar."
                                  ],
                                  "verification": "Heapify garante ordem; topo da fila é o menor após inserção.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Priority queue",
                                    "Log de iterações em tabela"
                                  ],
                                  "tips": "Em Python, use heappush(heap, (freq, nó)) com tie-breaker se frequências iguais.",
                                  "learningObjective": "Manter a invariante da fila durante iterações gulosa.",
                                  "commonMistakes": "Inserir sem reordenar, levando a seleções incorretas nas próximas iterações."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Iterar o processo até restar apenas um nó e confirmar a raiz",
                                  "subSteps": [
                                    "Repita steps 2-4 enquanto len(queue) > 1.",
                                    "Monitore o número de iterações (deve ser n-1 para n folhas).",
                                    "Ao final, extraia o último nó como raiz.",
                                    "Valide que todas folhas originais estão na árvore via travessia.",
                                    "Desenhe a árvore completa para inspeção visual."
                                  ],
                                  "verification": "Fila tem exatamente 1 nó; árvore conecta todas folhas com profundidades otimizadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo ou simulação manual",
                                    "Ferramenta de visualização de árvores"
                                  ],
                                  "tips": "Implemente em loop while para automação; conte iterações para debug.",
                                  "learningObjective": "Executar o loop guloso completo formando a árvore de Huffman.",
                                  "commonMistakes": "Parar prematuramente ou exceder iterações, resultando em múltiplas raízes."
                                }
                              ],
                              "practicalExample": "Para símbolos A:5, B:1, C:2, D:3. Fila inicial: [B1, C2, D3, A5]. Iteração 1: Combine B1+C2→X3, fila: [D3, X3, A5]. Iteração 2: D3+X3→Y6, fila: [Y6, A5]. Iteração 3: Y6+A5→Raiz11. Raiz é o nó final com todos símbolos como folhas.",
                              "finalVerifications": [
                                "Fila de prioridade contém exatamente um nó após o loop.",
                                "Frequência da raiz equals soma total de frequências das folhas.",
                                "Todos os símbolos originais são folhas na árvore.",
                                "Número de combinações = número inicial de folhas - 1.",
                                "Nenhuma folha foi perdida ou duplicada.",
                                "Estrutura da árvore é binária completa."
                              ],
                              "assessmentCriteria": [
                                "Explicação precisa da condição de parada e loop guloso.",
                                "Simulação correta do exemplo com pelo menos 4 símbolos.",
                                "Implementação funcional em pseudocódigo ou Python sem erros.",
                                "Identificação correta de erros comuns e prevenções.",
                                "Visualização clara da árvore final.",
                                "Tempo de execução respeita complexidade O(n log n)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e árvores binárias.",
                                "Probabilidade: Cálculo de entropia e frequências.",
                                "Física: Compressão de dados em sinais digitais.",
                                "Economia: Otimização de recursos (largura de banda mínima)."
                              ],
                              "realWorldApplication": "Esse processo é o cerne da codificação de Huffman usada em compressão sem perda de arquivos ZIP, PNG, JPEG, protocolos de rede como HTTP/2 e streaming de vídeo para minimizar uso de armazenamento e transmissão de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1",
                              "10.1.6.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Propriedades e Validação da Árvore",
                        "description": "Verificação das propriedades da árvore construída, como prefixo livre e optimalidade gulosa para codificação.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Retornar a raiz da árvore construída",
                            "description": "Ao final do algoritmo, retornar o último nó restante como raiz da árvore binária de Huffman completa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Processo de Construção da Árvore de Huffman",
                                  "subSteps": [
                                    "Relembre as etapas iniciais: criar nós folha com frequências de caracteres e inseri-los em uma fila de prioridades (min-heap).",
                                    "Simule as iterações de merge: extraia os dois nós de menor frequência, crie um nó pai e reinsira-o na fila.",
                                    "Confirme que o loop continua até restar um único nó na fila.",
                                    "Identifique que este nó restante é a raiz da árvore completa.",
                                    "Desenhe manualmente a árvore para um pequeno conjunto de dados para visualizar."
                                  ],
                                  "verification": "A fila de prioridades contém exatamente um nó após todas as merges, representando a raiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Pseudocódigo do algoritmo de Huffman",
                                    "Exemplo de frequências: A:5, B:2, C:1, D:1"
                                  ],
                                  "tips": "Sempre use uma fila de prioridades para garantir que os nós de menor frequência sejam mesclados primeiro.",
                                  "learningObjective": "Compreender como o processo iterativo resulta em um único nó raiz.",
                                  "commonMistakes": [
                                    "Parar o loop prematuramente, deixando múltiplos nós",
                                    "Confundir nós folha com a raiz final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Isolar o Nó Raiz",
                                  "subSteps": [
                                    "Após o loop principal, acesse o primeiro (e único) elemento da fila de prioridades.",
                                    "Verifique se o nó possui exatamente dois filhos (esquerdo e direito).",
                                    "Atribua este nó a uma variável 'root' para clareza no código.",
                                    "Opcionalmente, remova-o da fila para evitar confusões.",
                                    "Registre as frequências e profundidades para validação inicial."
                                  ],
                                  "verification": "Variável 'root' aponta para um nó com frequência total igual à soma de todas as frequências originais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Jupyter)",
                                    "Biblioteca de heap (Python: heapq)"
                                  ],
                                  "tips": "Use print statements ou debuggers para inspecionar o estado da fila no final.",
                                  "learningObjective": "Localizar precisamente o nó raiz após a construção.",
                                  "commonMistakes": [
                                    "Retornar um nó intermediário em vez da raiz final",
                                    "Ignorar verificação de unicidade na fila"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar Propriedades da Raiz e da Árvore",
                                  "subSteps": [
                                    "Confirme que a árvore é binária completa: todo nó não-folha tem dois filhos.",
                                    "Verifique código prefixo livre: nenhum código é prefixo de outro (atravessando da raiz).",
                                    "Calcule a soma de frequências na raiz e compare com o total original.",
                                    "Meça a altura da árvore para eficiência (deve ser próxima a log n).",
                                    "Teste recursivamente se todos os nós folha são alcançáveis da raiz."
                                  ],
                                  "verification": "Todas as propriedades (binária, prefixo livre, soma correta) são satisfeitas sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções auxiliares de validação (ex: is_prefix_free)",
                                    "Ferramentas de visualização de árvores (Graphviz)"
                                  ],
                                  "tips": "Implemente funções helper para validação para reutilização.",
                                  "learningObjective": "Garantir que a raiz representa uma árvore de Huffman válida.",
                                  "commonMistakes": [
                                    "Não verificar código prefixo, levando a decodificação ambígua",
                                    "Erro em soma de frequências por merge incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o Retorno da Raiz e Testar Integração",
                                  "subSteps": [
                                    "No código, adicione 'return root' ao final da função de construção.",
                                    "Use a raiz para gerar códigos Huffman (traversing esquerdo=0, direito=1).",
                                    "Codifique uma string de teste e decodifique para verificar.",
                                    "Meça a taxa de compressão comparada ao original.",
                                    "Documente o retorno com tipo (ex: Node*) e comentários."
                                  ],
                                  "verification": "Função retorna a raiz corretamente e permite codificação/decodificação perfeita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo de Huffman",
                                    "Strings de teste variadas",
                                    "Unit tests framework (ex: pytest)"
                                  ],
                                  "tips": "Sempre teste com casos edge: uma letra, todas iguais, frequências zero.",
                                  "learningObjective": "Integrar o retorno da raiz em um pipeline de compressão funcional.",
                                  "commonMistakes": [
                                    "Retornar None ou ponteiro inválido",
                                    "Não tratar casos onde n=1 (árvore de nó único)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para frequências {'A':5, 'B':2, 'C':1, 'D':1}: Após merges, raiz é nó com freq=9, filho esquerdo 'C'-'D'(2), direito 'B'-'A'(7). Retorne este nó para gerar códigos: A=10, B=11, C=00, D=01.",
                              "finalVerifications": [
                                "Fila de prioridades tem exatamente 1 nó após construção.",
                                "Raiz soma frequências corretamente.",
                                "Árvore satisfaz código prefixo livre.",
                                "Altura da árvore é ótima (mínima possível).",
                                "Codificação e decodificação funcionam perfeitamente.",
                                "Retorno é do tipo nó correto sem vazamentos de memória."
                              ],
                              "assessmentCriteria": [
                                "Correção: Raiz identificada e retornada precisamente.",
                                "Eficiência: Algoritmo O(n log n) mantido.",
                                "Validação: Todas propriedades verificadas.",
                                "Robustez: Trata casos edge sem crashes.",
                                "Clareza: Código comentado e modular.",
                                "Testes: Cobertura de unit tests >80%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e árvores binárias.",
                                "Probabilidade: Cálculo de entropia e frequências.",
                                "Física: Compressão de dados em telecomunicações.",
                                "Engenharia de Software: Estruturas de dados (heaps, árvores)."
                              ],
                              "realWorldApplication": "Em compressão de arquivos como ZIP ou JPEG, a raiz da árvore Huffman é usada para mapear bits eficientes a símbolos frequentes, reduzindo tamanho de dados em transmissão de imagens/vídeos pela internet."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Verificar propriedades da árvore",
                            "description": "Analisar se a árvore satisfaz: ser binária completa, códigos prefixo-livres, e minimizar a soma frequência * profundidade (custo médio).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar se a árvore é binária completa (full binary tree)",
                                  "subSteps": [
                                    "Represente a árvore usando uma estrutura de nós com ponteiros para filhos esquerdo e direito.",
                                    "Percorra a árvore recursivamente ou com BFS/DFS a partir da raiz.",
                                    "Para cada nó interno (não folha), confirme que possui exatamente dois filhos (esquerdo e direito não nulos).",
                                    "Para folhas, confirme que ambos os filhos são nulos.",
                                    "Garanta que não haja nós com apenas um filho."
                                  ],
                                  "verification": "Liste todos os nós e anote o número de filhos; nenhum nó deve ter exatamente um filho.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Diagrama da árvore de Huffman",
                                    "Pseudocódigo para travessia de árvore",
                                    "Ferramenta de desenho como Graphviz ou papel e lápis"
                                  ],
                                  "tips": "Comece pela raiz e use uma pilha para evitar recursão profunda em árvores grandes.",
                                  "learningObjective": "Entender e validar a propriedade de árvore binária completa essencial para Huffman.",
                                  "commonMistakes": [
                                    "Confundir 'completa' com 'perfeita'; Huffman é 'full' (sem nós unários).",
                                    "Ignorar nós profundos na travessia.",
                                    "Não diferenciar nós internos de folhas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Atribuir códigos e calcular profundidades das folhas",
                                  "subSteps": [
                                    "Inicie na raiz com código vazio e profundidade 0.",
                                    "Vá para filho esquerdo: anexe '0' ao código e incremente profundidade em 1.",
                                    "Vá para filho direito: anexe '1' ao código e incremente profundidade em 1.",
                                    "Registre o código e profundidade para cada folha (símbolo).",
                                    "Calcule profundidade média ponderada: soma (frequência * profundidade) para todas folhas."
                                  ],
                                  "verification": "Tabela com símbolo, código, profundidade e freq*profundidade; soma total calculada.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Tabela de frequências",
                                    "Árvore desenhada",
                                    "Planilha ou calculadora para somas"
                                  ],
                                  "tips": "Use travessia pré-ordem para atribuir códigos; valide comprimento dos códigos.",
                                  "learningObjective": "Mapear caminhos da árvore para códigos binários e computar custo de codificação.",
                                  "commonMistakes": [
                                    "Erro na atribuição de 0/1 (esquerda/direita inconsistente).",
                                    "Esquecer de ponderar por frequência.",
                                    "Contar profundidade errada (raiz como 0 ou 1?)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar se os códigos são prefixo-livres",
                                  "subSteps": [
                                    "Liste todos os códigos atribuídos às folhas em ordem alfabética ou de comprimento.",
                                    "Para cada código, cheque se ele é prefixo de qualquer outro código na lista.",
                                    "Use um conjunto (set) de strings para inserção trie-like: tente inserir; falha se prefixo existe.",
                                    "Confirme que nenhuma código é prefixo próprio de outro (propriedade de Kraft ≤1 implicitamente).",
                                    "Valide visualmente em árvore pequena: caminhos para folhas não passam por outras folhas."
                                  ],
                                  "verification": "Relatório: 'Todos códigos prefixo-livres: SIM/NÃO' com contraexemplo se falhar.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Lista de códigos gerados",
                                    "Implementação simples de trie em pseudocódigo ou Python"
                                  ],
                                  "tips": "Ordene códigos por comprimento crescente para checagem eficiente.",
                                  "learningObjective": "Garantir decodificabilidade única via propriedade prefixo-livre.",
                                  "commonMistakes": [
                                    "Permitir código como prefixo (ex: 00 e 001).",
                                    "Confundir com unicidade (prefixo-livre implica único).",
                                    "Não checar todos os pares."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar minimização do custo médio (soma freq * profundidade)",
                                  "subSteps": [
                                    "Calcule o custo total: soma sobre folhas (frequência_i * profundidade_i).",
                                    "Compare com limite inferior: entropia ou soma freq * log2(1/prob).",
                                    "Verifique propriedade Huffman: nós irmãos combinados têm freq soma mínima na fila.",
                                    "Simule construção alternativa (ex: ordem errada) e compare custos.",
                                    "Confirme que árvore satisfaz desigualdade de Huffman (folhas mais frequentes em profundidades menores)."
                                  ],
                                  "verification": "Custo calculado ≤ custo de construção alternativa; relatório de comparação.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Frequências originais",
                                    "Código de Huffman para reconstruir",
                                    "Calculadora para entropia"
                                  ],
                                  "tips": "Frequências mais altas devem ter códigos mais curtos; cheque isso.",
                                  "learningObjective": "Validar optimalidade do algoritmo de Huffman via custo mínimo.",
                                  "commonMistakes": [
                                    "Calcular profundidade errada.",
                                    "Comparar com árvore não-Huffman sem reconstruir.",
                                    "Ignorar que Huffman é ótimo para freq dadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Frequências: A:5, B:3, C:1, D:1. Árvore: Raiz(8) - Esq: A(5) e sub(4: B(3)-D(1)); Dir: C(1). Códigos: A:0 (prof1), B:10 (prof2), D:11 (prof2), C:1 (prof1). Verificações: Full binary (sim), prefix-free (00 não existe, etc.), custo=5*1 +3*2 +1*2 +1*1=5+6+2+1=14 (mínimo).",
                              "finalVerifications": [
                                "Árvore tem apenas nós com 0 ou 2 filhos.",
                                "Nenhum código é prefixo de outro.",
                                "Custo calculado corretamente com soma freq*prof.",
                                "Frequências altas têm profundidades menores.",
                                "Custo ≤ entropia * n +1 (aprox).",
                                "Reconstrução da árvore via fila de prioridades produz mesmo custo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de árvore não-full (ex: nó unário).",
                                "Correção na geração e checagem de códigos prefixo-livres.",
                                "Cálculo exato do custo médio ponderado.",
                                "Identificação de violações de optimalidade (ex: freq alta profunda).",
                                "Eficiência na travessia e verificações (tempo <1h para árvore média).",
                                "Explicação clara de cada propriedade em relatório."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e árvores (DFS/BFS).",
                                "Probabilidade: Entropia de Shannon e pesos probabilísticos.",
                                "Engenharia de Software: Estruturas de dados (priority queue, trie).",
                                "Física/Química: Compressão de dados em simulações científicas.",
                                "Economia: Otimização de custos em alocação de recursos."
                              ],
                              "realWorldApplication": "Em compressão de arquivos (ZIP, GZIP), codificação de imagens (JPEG), transmissão de dados de rede (reduz largura de banda), e machine learning (codificação de features categóricas eficientes)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Implementar algoritmo completo com exemplo",
                            "description": "Codificar o algoritmo inteiro e testá-lo com frequências exemplo (ex: a:5, b:9, c:12, d:13, e:16, f:45), verificando a árvore resultante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir estrutura de dados para nós da árvore e preparar folhas iniciais",
                                  "subSteps": [
                                    "Crie uma classe Node com atributos: frequência (freq), caractere (char, opcional para folhas), esquerda (left), direita (right).",
                                    "Implemente o método __lt__ para comparação baseada em freq (para heap).",
                                    "Crie lista de nós folha com frequências: {'a':5, 'b':9, 'c':12, 'd':13, 'e':16, 'f':45}.",
                                    "Inicialize cada nó com freq e char correspondente.",
                                    "Verifique se todos os nós têm freq correta e None em left/right."
                                  ],
                                  "verification": "Imprima os nós iniciais e confirme que freq e char batem com o exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou Jupyter), Python 3+",
                                  "tips": "Use dataclasses para simplificar a classe Node se disponível.",
                                  "learningObjective": "Entender representação de árvore binária para Huffman.",
                                  "commonMistakes": "Esquecer de definir __lt__ corretamente, causando erros no heap."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar fila de prioridade (min-heap) com os nós iniciais",
                                  "subSteps": [
                                    "Importe heapq do módulo heapq.",
                                    "Crie uma lista heap e insira todos os nós folha usando heappush.",
                                    "Confirme que o heap tem tamanho 6 e o menor freq (a:5) é acessível via heappop.",
                                    "Teste heappush/pop com um nó extra para validar.",
                                    "Imprima o heap para verificar ordem aproximada por freq."
                                  ],
                                  "verification": "Execute heappop() duas vezes e confirme que retorna nós com menor freq (a:5, b:9).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com heapq, console para testes",
                                  "tips": "heapq trabalha com listas; sempre use heappush/heappop para manter propriedades do heap.",
                                  "learningObjective": "Dominar uso de min-heap para seleção eficiente de nós mínimos.",
                                  "commonMistakes": "Usar sort() em vez de heap, perdendo eficiência O(log n)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a árvore de Huffman iterativamente",
                                  "subSteps": [
                                    "Inicie loop while len(heap) > 1.",
                                    "Extraia dois nós mínimos com heappop().",
                                    "Crie novo nó pai com freq = soma das freqs, left=primeiro, right=segundo.",
                                    "heappush(pai) no heap.",
                                    "Continue até heap ter 1 nó (raiz)."
                                  ],
                                  "verification": "Após loop, heap[0] é a raiz com freq total 100 (5+9+12+13+16+45).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código anterior, debugger para rastrear heap",
                                  "tips": "Desenhe a árvore manualmente primeiro para prever estrutura.",
                                  "learningObjective": "Implementar lógica greedy central do algoritmo Huffman.",
                                  "commonMistakes": "Invertendo left/right, afetando códigos gerados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar árvore percorrendo e gerando códigos Huffman",
                                  "subSteps": [
                                    "Implemente função recursiva para gerar códigos: traverse esquerda '0', direita '1'.",
                                    "Colete códigos para cada char na árvore.",
                                    "Para exemplo: confirme códigos como a:11, b:10, etc. (baseado em construção).",
                                    "Calcule comprimento total de bits e compare com entropia.",
                                    "Visualize árvore imprimindo estrutura pré-order."
                                  ],
                                  "verification": "Códigos gerados produzem árvore idêntica à manual e comprimento ótimo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Função de print_tree para visualização",
                                  "tips": "Use dict para mapear char a código durante traverse.",
                                  "learningObjective": "Verificar propriedades da árvore via travessia.",
                                  "commonMistakes": "Erro em recursão base (folha sem char)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar implementação completa com exemplo e depurar",
                                  "subSteps": [
                                    "Execute função huffman_tree(freqs) com exemplo dado.",
                                    "Imprima árvore resultante e códigos.",
                                    "Compare com construção manual: raiz f+e, etc.",
                                    "Teste encode/decode com string exemplo.",
                                    "Meça tempo de execução para n=6."
                                  ],
                                  "verification": "Árvore matches: profundidades refletem freq inversa, freq total 100.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Testes unitários (pytest opcional)",
                                  "tips": "Escreva asserts para automação.",
                                  "learningObjective": "Garantir robustez via testes end-to-end.",
                                  "commonMistakes": "Freqs duplicadas causando heap instável."
                                }
                              ],
                              "practicalExample": "Com frequências a:5, b:9, c:12, d:13, e:16, f:45: Nós iniciais em heap. Pop a+b->n1(14), pop c+d->n2(25), push. Continua até raiz(100). Códigos ex: a:'110', b:'111', c:'00', d:'01', e:'100', f:'10'. Comprimento médio ~2.1 bits/char.",
                              "finalVerifications": [
                                "Raiz tem freq 100 e estrutura binária completa.",
                                "Todos chars folhas presentes com freqs corretas.",
                                "Códigos prefix-free (nenhum é prefixo de outro).",
                                "Comprimento total bits < soma freqs * log2(6).",
                                "Encode/decode preserva string original.",
                                "Execução em O(n log n) para n=6."
                              ],
                              "assessmentCriteria": [
                                "Correção: árvore e códigos idênticos ao manual.",
                                "Eficiência: usa heapq sem loops desnecessários.",
                                "Robustez: lida com freqs zero ou uma só.",
                                "Clareza: código comentado e indentado.",
                                "Validação: funções de print e teste integradas.",
                                "Escalabilidade: funciona para 10+ símbolos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos (árvores mínimas), entropia de Shannon.",
                                "Probabilidade: Frequências como probabilidades, código ótimo.",
                                "Engenharia de Software: Estruturas de dados (heap, árvore).",
                                "Física: Compressão similar a codificação em telecomunicações.",
                                "Economia: Otimização greedy como alocação de recursos."
                              ],
                              "realWorldApplication": "Usado em ZIP, JPEG, MP3 para compressão lossless eficiente, reduzindo tamanho de arquivos em até 50% para dados textuais, economizando banda em streaming e armazenamento em nuvem."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.3",
                              "10.1.6.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Geração de Códigos Prefixo",
                    "description": "Atribuição de códigos binários de comprimento variável aos símbolos, garantindo propriedade de prefixo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Propriedade de Código Prefixo",
                        "description": "Conceito fundamental que garante que nenhum código binário atribuído a um símbolo seja um prefixo de outro código, permitindo decodificação única e sem ambiguidade em codificações de comprimento variável.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Definir e Exemplificar Código Prefixo",
                            "description": "Definir formalmente um conjunto de códigos prefixo, fornecer exemplos de conjuntos válidos (ex: {0,10,11}) e inválidos (ex: {0,01}), e explicar por que a violação causa ambiguidade na decodificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Intuitivo de Códigos Prefixo",
                                  "subSteps": [
                                    "Explique em termos simples o que significa 'prefixo' em sequências binárias: uma string A é prefixo de B se B começa exatamente com A.",
                                    "Descreva por que códigos prefixo evitam ambiguidade na decodificação: sem prefixos, cada sequência de bits corresponde a exatamente um código.",
                                    "Visualize usando uma árvore binária: códigos prefixo correspondem a folhas não sobrepostas.",
                                    "Compare com códigos não-prefixo: ilustre como um receptor ficaria confuso ao decodificar.",
                                    "Pratique identificando prefixos em strings simples como '0' e '01'."
                                  ],
                                  "verification": "Escreva uma explicação de 3 frases sobre o conceito intuitivo e dê um exemplo de ambiguidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhar árvores",
                                    "Vídeo introdutório sobre codificação binária (YouTube: 'Prefix Codes Explained')"
                                  ],
                                  "tips": "Pense em números de telefone: nenhum deve ser prefixo de outro para roteamento único.",
                                  "learningObjective": "Graspar intuitivamente a necessidade de códigos prefixo para decodificação unívoca.",
                                  "commonMistakes": [
                                    "Confundir prefixo com sufixo.",
                                    "Achar que todos os códigos binários são prefixo por padrão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente Conjuntos de Códigos Prefixo",
                                  "subSteps": [
                                    "Estude a definição formal: Um conjunto C de strings binárias é um código prefixo se ∀ c1, c2 ∈ C, c1 ≠ c2, nem c1 é prefixo de c2 nem vice-versa.",
                                    "Aprenda critérios equivalentes: existência de uma árvore de decodificação instantânea onde códigos são folhas.",
                                    "Memorize o Teorema de Kraft-McMillan: Σ |c_i|^{-1} ≤ 1 para códigos prefixo.",
                                    "Escreva a definição em notação matemática e prove um exemplo simples.",
                                    "Diferencie de códigos suffixo ou outros tipos."
                                  ],
                                  "verification": "Escreva a definição formal e aplique o Teorema de Kraft a um conjunto pequeno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Artigo ou PDF sobre Teorema de Kraft (Wikipedia ou textbook digital)"
                                  ],
                                  "tips": "Use notação Σ para somar probabilidades invertidas no Kraft para verificação rápida.",
                                  "learningObjective": "Dominar a definição matemática precisa de códigos prefixo.",
                                  "commonMistakes": [
                                    "Esquecer a simetria (prefixo em ambas direções).",
                                    "Confundir com desigualdade estrita no Kraft."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Exemplificar Conjuntos de Códigos Prefixo Válidos",
                                  "subSteps": [
                                    "Analise o exemplo válido {0, 10, 11}: verifique que nenhum é prefixo de outro.",
                                    "Construa seu próprio conjunto válido com 3-4 códigos para símbolos A, B, C, D.",
                                    "Desenhe a árvore binária correspondente e confirme que todos os códigos terminam em folhas.",
                                    "Aplique o Teorema de Kraft: calcule Σ 2^{-l_i} ≤ 1.",
                                    "Gere variações e valide usando software simples como Python (função de verificação de prefixo)."
                                  ],
                                  "verification": "Liste 2 conjuntos válidos próprios e desenhe suas árvores.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python IDLE ou Jupyter Notebook",
                                    "Papel para árvores binárias"
                                  ],
                                  "tips": "Comece com código mais curto para símbolo mais frequente para eficiência.",
                                  "learningObjective": "Capacitar-se a criar e validar exemplos válidos de códigos prefixo.",
                                  "commonMistakes": [
                                    "Incluir códigos de mesmo comprimento sem verificar árvore.",
                                    "Erro no cálculo de Kraft (usar base errada)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar Conjuntos Inválidos e Explicar Ambiguidade",
                                  "subSteps": [
                                    "Analise {0, 01}: mostre que '0' é prefixo de '01', causando ambiguidade (sequência '01' pode ser '0' + '1' ou '01').",
                                    "Crie 2 exemplos inválidos próprios e demonstre falha no Kraft ou árvore.",
                                    "Simule decodificação passo a passo para sequências ambíguas.",
                                    "Explique impactos: perda de dados, necessidade de delimitadores extras.",
                                    "Compare com Huffman: por que algoritmos geram apenas prefixo."
                                  ],
                                  "verification": "Descreva ambiguidade em 2 exemplos inválidos com simulação de decodificação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador online de codificação (ex: Huffman tool)",
                                    "Papel para simulações de bits"
                                  ],
                                  "tips": "Sempre leia bits da esquerda para direita e pare em match exato.",
                                  "learningObjective": "Identificar violações e quantificar consequências na decodificação.",
                                  "commonMistakes": [
                                    "Não simular decodificação real.",
                                    "Achar ambiguidade só em códigos longos."
                                  ]
                                }
                              ],
                              "practicalExample": "Dado símbolos A (50%), B (30%), C (20%): atribua códigos A=0, B=10, C=11. Verifique: árvore binária com folhas em 0, 10, 11; Kraft: 1/2 + 1/4 + 1/4 = 1. Sequência '1011' decodifica unicamente como B + C.",
                              "finalVerifications": [
                                "Defina formalmente código prefixo sem erros.",
                                "Forneça e valide um conjunto válido com árvore e Kraft.",
                                "Identifique violação em {0,01} e simule ambiguidade.",
                                "Construa um conjunto prefixo para 4 símbolos.",
                                "Explique por que Huffman usa prefixo.",
                                "Aplique Kraft corretamente em exemplo dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% match com padrão).",
                                "Correção em exemplos válidos/inválidos (sem erros lógicos).",
                                "Clareza na explicação de ambiguidade com simulação.",
                                "Uso correto do Teorema de Kraft em cálculos.",
                                "Criatividade e validade em exemplos próprios.",
                                "Visualizações (árvores) completas e precisas.",
                                "Conexão com decodificação unívoca."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Árvores Binárias.",
                                "Engenharia de Telecomunicações: Codificação de Canal sem Erros.",
                                "Ciência de Dados: Compressão Lossless e Entropia.",
                                "Linguística Computacional: Análise de Linguagens Formais.",
                                "Física: Codificação Quântica e Informação."
                              ],
                              "realWorldApplication": "Em compressão de arquivos ZIP/GZIP via Huffman, garantindo decodificação rápida e sem ambiguidade em transmissão de dados de rede, imagens JPEG ou streaming de vídeo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Relacionar com Árvores Binárias",
                            "description": "Explicar a correspondência entre códigos prefixo e árvores binárias de prefixo, onde folhas representam símbolos e caminhos da raiz definem os códigos, garantindo ausência de códigos prefixo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Códigos Prefixo",
                                  "subSteps": [
                                    "Defina código prefixo: um conjunto de códigos onde nenhum é prefixo de outro.",
                                    "Estude exemplos simples: {0, 10, 11} é prefixo; {0, 01} não é.",
                                    "Explique por que a propriedade prefixo evita ambiguidade na decodificação.",
                                    "Compare com códigos não-prefixo e suas falhas na decodificação.",
                                    "Registre definições em um glossário pessoal."
                                  ],
                                  "verification": "Escreva uma definição precisa e identifique corretamente 3 exemplos válidos/inválidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; exemplos de códigos impressos.",
                                  "tips": "Use tabelas para listar códigos e testar prefixos manualmente.",
                                  "learningObjective": "Compreender a definição e importância da propriedade prefixo.",
                                  "commonMistakes": "Confundir prefixo com sufixo ou ignorar a decodificação instantânea."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Árvores Binárias de Prefixo",
                                  "subSteps": [
                                    "Desenhe uma árvore binária vazia com raiz e ramos esquerdo (0) e direito (1).",
                                    "Explique que folhas representam símbolos e ramos internos não.",
                                    "Discuta como caminhos da raiz até folhas codificam sequências binárias.",
                                    "Construa uma árvore simples para {A:0, B:10}.",
                                    "Verifique que não há folhas em ramos internos."
                                  ],
                                  "verification": "Desenhe uma árvore binária básica e label os caminhos corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de desenho como Draw.io ou papel quadriculado.",
                                  "tips": "Sempre label ramos: esquerdo=0, direito=1, para consistência.",
                                  "learningObjective": "Visualizar árvores binárias como estruturas para códigos prefixo.",
                                  "commonMistakes": "Colocar símbolos em nós internos ou inverter ramos 0/1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Códigos Prefixo para Árvores Binárias",
                                  "subSteps": [
                                    "Para cada código, siga o caminho binário da raiz até uma folha.",
                                    "Insira símbolos apenas em folhas correspondentes aos códigos.",
                                    "Para o conjunto {A:00, B:10, C:11}, construa a árvore completa.",
                                    "Identifique como o comprimento variável dos códigos afeta a profundidade.",
                                    "Teste decodificação simulada percorrendo a árvore."
                                  ],
                                  "verification": "Construa árvore para um conjunto dado e extraia códigos dos caminhos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de códigos; software de árvores ou papel.",
                                  "tips": "Comece com códigos mais curtos para folhas mais altas.",
                                  "learningObjective": "Estabelecer correspondência exata entre códigos e caminhos na árvore.",
                                  "commonMistakes": "Permitir códigos que compartilhem prefixo completo com outra folha."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Propriedade Prefixo via Estrutura da Árvore",
                                  "subSteps": [
                                    "Confirme que todos códigos terminam em folhas (não prefixos de outros).",
                                    "Simule decodificação: leia bits e pare apenas em folhas.",
                                    "Teste conjuntos inválidos: tente inserir e veja conflitos em folhas internas.",
                                    "Explique teorema: código prefixo ↔ árvore binária com símbolos só em folhas.",
                                    "Aplique a códigos Huffman gerados anteriormente."
                                  ],
                                  "verification": "Valide 2 conjuntos de códigos usando a árvore e explique falhas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Conjuntos de teste de códigos; calculadora para simulações.",
                                  "tips": "Use cores diferentes para caminhos válidos vs. inválidos.",
                                  "learningObjective": "Garantir ausência de códigos prefixo através da árvore.",
                                  "commonMistakes": "Ignorar que caminhos para folhas não podem ser prefixos de outros caminhos."
                                }
                              ],
                              "practicalExample": "Para símbolos A (prob 0.5, código 0), B (0.3, código 10), C (0.2, código 11): Construa árvore com raiz → esquerda(0):folha A; direita(1) → esquerda(0):folha B, direita(1):folha C. Caminhos: A=0, B=10, C=11. Decodificação de 01011: 0(A),10(B),11(C). Nenhum código é prefixo de outro.",
                              "finalVerifications": [
                                "Construir árvore corretamente para qualquer conjunto prefixo dado.",
                                "Explicar verbalmente a correspondência código-caminho-folha.",
                                "Identificar e corrigir conjuntos não-prefixo via tentativa de árvore.",
                                "Simular decodificação unívoca usando a árvore.",
                                "Relacionar com Huffman: árvores geram códigos prefixo.",
                                "Desenhar árvore invertida (sufixos) e mostrar ambiguidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da árvore (100% caminhos corretos).",
                                "Compreensão conceitual: explicar teorema Kraft-McMillan intuitivamente.",
                                "Habilidade em decodificação simulada sem erros.",
                                "Identificação de violações prefixo em <5 segundos por exemplo.",
                                "Criatividade em exemplos próprios com árvores válidas.",
                                "Integração com contexto Huffman (frequências → árvore → códigos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (árvores como grafos acíclicos).",
                                "Linguística: Códigos univocais em morfologia e sintaxe.",
                                "Física: Representação hierárquica em estruturas de decisão quânticas.",
                                "Engenharia: Redes de decisão em hardware (PLDs, FPGAs)."
                              ],
                              "realWorldApplication": "Na compressão de arquivos ZIP/JPEG via Huffman, árvores binárias garantem códigos prefixo eficientes para decodificação rápida sem delimitadores, otimizando armazenamento e transmissão de dados em apps como WhatsApp ou streaming Netflix."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Importância na Codificação de Huffman",
                            "description": "Demonstrar como a propriedade de prefixo é essencial para a eficiência da codificação de Huffman, permitindo decodificação sequencial sem delimitadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Propriedade de Código Prefixo",
                                  "subSteps": [
                                    "Defina código prefixo: nenhum código é prefixo de outro.",
                                    "Estude exemplos simples: código {0,10,11} é prefixo; {0,01,11} não é.",
                                    "Construa uma árvore binária para visualizar a propriedade.",
                                    "Identifique por que isso evita ambiguidade em códigos variáveis.",
                                    "Compare com códigos de comprimento fixo."
                                  ],
                                  "verification": "Crie um exemplo de código prefixo e um não-prefixo, explicando a diferença.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de árvore binária online"
                                  ],
                                  "tips": "Use desenhos de árvores para visualizar; comece com códigos curtos.",
                                  "learningObjective": "Explicar a definição e importância da propriedade de prefixo.",
                                  "commonMistakes": "Confundir prefixo com sufixo ou ignorar comprimentos variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Problemas na Decodificação Sem Propriedade de Prefixo",
                                  "subSteps": [
                                    "Crie um código não-prefixo simples, ex: {0,01,11}.",
                                    "Tente decodificar uma sequência ambígua como '01'.",
                                    "Demonstre necessidade de delimitadores para resolver ambiguidades.",
                                    "Calcule overhead de delimitadores em mensagens longas.",
                                    "Compare eficiência com códigos prefixo."
                                  ],
                                  "verification": "Decodifique uma sequência ambígua e liste as múltiplas interpretações possíveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Exemplos de códigos impressos"
                                  ],
                                  "tips": "Teste sequências curtas primeiro para ver ambiguidades rapidamente.",
                                  "learningObjective": "Identificar ambiguidades e ineficiências sem prefixo.",
                                  "commonMistakes": "Subestimar impacto de delimitadores em grandes dados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Decodificação Sequencial na Codificação de Huffman",
                                  "subSteps": [
                                    "Gere códigos Huffman para uma mensagem curta com frequências.",
                                    "Verifique que os códigos são prefixo via árvore.",
                                    "Decodifique a sequência binária passo a passo sem delimitadores.",
                                    "Simule com software ou manualmente uma mensagem codificada.",
                                    "Compare tempo e simplicidade com método não-prefixo."
                                  ],
                                  "verification": "Decodifique corretamente uma sequência Huffman sem erros ou ambiguidades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora de Huffman online",
                                    "Papel para árvore"
                                  ],
                                  "tips": "Sempre traverse a árvore da raiz para folhas durante decodificação.",
                                  "learningObjective": "Executar decodificação sequencial eficiente em Huffman.",
                                  "commonMistakes": "Parar prematuramente na árvore, causando erros de prefixo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Eficiência e Benefícios na Codificação de Huffman",
                                  "subSteps": [
                                    "Calcule taxa de compressão com e sem delimitadores.",
                                    "Discuta escalabilidade para arquivos grandes.",
                                    "Explique papel na eficiência geral de Huffman.",
                                    "Relacione com teorema de Shannon para otimalidade.",
                                    "Resuma por que prefixo é essencial para aplicações reais."
                                  ],
                                  "verification": "Escreva um parágrafo explicando a essencialidade do prefixo para Huffman.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha para cálculos de entropia",
                                    "Artigos sobre Huffman"
                                  ],
                                  "tips": "Use números reais de frequências para cálculos concretos.",
                                  "learningObjective": "Quantificar benefícios da propriedade de prefixo.",
                                  "commonMistakes": "Ignorar custos de delimitadores em análises de eficiência."
                                }
                              ],
                              "practicalExample": "Codifique 'hello' com frequências: h:1, e:2, l:2, o:1. Códigos Huffman: h=00, e=01, l=10, o=11. Sequência: 0001101011. Decodifique sequencialmente: 00(h),01(e),10(l),10(l),11(o) – sem delimitadores, instantâneo e único.",
                              "finalVerifications": [
                                "Explica corretamente ambiguidade sem prefixo.",
                                "Decodifica sequência Huffman sem erros.",
                                "Identifica árvore como verificador de prefixo.",
                                "Calcula overhead de delimitadores vs. prefixo.",
                                "Relaciona prefixo à eficiência de Huffman.",
                                "Dá exemplo real de aplicação."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação da propriedade de prefixo (20%)",
                                "Demonstração precisa de decodificação sequencial (25%)",
                                "Análise comparativa de eficiência (20%)",
                                "Uso correto de exemplos e árvores (20%)",
                                "Conexão com benefícios reais de Huffman (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Árvores Binárias",
                                "Probabilidade: Cálculo de Entropia e Frequências",
                                "Física: Compressão de Dados em Transmissões",
                                "Engenharia: Otimização em Sistemas Embarcados"
                              ],
                              "realWorldApplication": "Na compressão de arquivos ZIP, JPEG e MP3, a propriedade de prefixo permite decodificação rápida e eficiente de dados massivos sem overhead de delimitadores, economizando largura de banda em streaming e armazenamento em nuvem."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Traversia da Árvore de Huffman",
                        "description": "Processo de percorrer a árvore de Huffman construída para atribuir códigos binários aos símbolos nas folhas, utilizando convenções de ramos esquerdo (0) e direito (1).",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Descrever Algoritmo Recursivo de Geração",
                            "description": "Descrever o algoritmo recursivo: iniciar na raiz com código vazio; para nó interno, recursar à esquerda com '0' e à direita com '1'; para folha, atribuir o código ao símbolo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura da Árvore de Huffman e Recursão Básica",
                                  "subSteps": [
                                    "Revise a construção da árvore de Huffman, identificando raízes, nós internos e folhas.",
                                    "Estude o conceito de recursão: função que chama a si mesma com parâmetros modificados.",
                                    "Identifique o código inicial vazio na raiz e como ele é prefixado com '0' ou '1'.",
                                    "Desenhe uma árvore de Huffman simples com 4 símbolos para visualizar.",
                                    "Explique verbalmente como a recursão desce pela árvore."
                                  ],
                                  "verification": "Desenhe corretamente uma árvore de Huffman e explique recursão em 2 minutos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, diagrama de árvore de Huffman impresso ou digital.",
                                  "tips": "Use setas para mostrar o fluxo recursivo da raiz às folhas.",
                                  "learningObjective": "Entender os componentes da árvore e o mecanismo recursivo básico.",
                                  "commonMistakes": "Confundir nós internos com folhas ou ignorar o código prefixado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Caso Base: Processamento de Folhas",
                                  "subSteps": [
                                    "Identifique uma folha na árvore: nó sem filhos que representa um símbolo.",
                                    "Descreva: ao alcançar uma folha, atribua o código atual (concatenado) ao símbolo.",
                                    "Escreva pseudocódigo para o caso base: if (é folha) { atribuir código ao símbolo }.",
                                    "Teste com uma árvore de um só símbolo: código vazio ou prefixado.",
                                    "Verifique se o código é único e prefixo-free."
                                  ],
                                  "verification": "Escreva e execute pseudocódigo para uma folha isolada sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto ou papel para pseudocódigo, exemplo de árvore.",
                                  "tips": "Sempre verifique se o código termina exatamente na folha.",
                                  "learningObjective": "Dominar o ponto de parada da recursão nas folhas.",
                                  "commonMistakes": "Atribuir código antes de verificar se é folha ou continuar recursando."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o Caso Recursivo: Nós Internos",
                                  "subSteps": [
                                    "Para nó interno (tem filhos esquerdo e direito), chame recursão no esquerdo com código + '0'.",
                                    "Em seguida, chame recursão no direito com código + '1'.",
                                    "Escreva pseudocódigo: if (não é folha) { recursar(esquerdo, código+'0'); recursar(direito, código+'1'); }.",
                                    "Simule manualmente em uma árvore pequena, rastreando códigos.",
                                    "Confirme que todas as folhas recebem códigos únicos."
                                  ],
                                  "verification": "Simule recursão em árvore com 3 nós e liste códigos corretos das folhas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Árvore de Huffman desenhada, tabela para rastrear chamadas recursivas.",
                                  "tips": "Use pilha de chamadas para visualizar a ordem de execução.",
                                  "learningObjective": "Implementar corretamente a bifurcação recursiva com prefixos.",
                                  "commonMistakes": "Inverter '0' e '1' ou esquecer de concatenar o prefixo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Descrever o Algoritmo Completo",
                                  "subSteps": [
                                    "Combine casos: função recursiva( nó, código ) com if folha e else recursivo.",
                                    "Inicie chamada: recursiva(raiz, '').",
                                    "Escreva descrição textual completa em parágrafos claros.",
                                    "Teste com exemplo real e ajuste descrição para clareza.",
                                    "Compare com implementação iterativa para validar."
                                  ],
                                  "verification": "Forneça descrição escrita que gere códigos corretos em exemplo dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pseudocódigo completo, exemplo de árvore com símbolos A,B,C,D.",
                                  "tips": "Estruture descrição como: introdução, casos, chamada inicial.",
                                  "learningObjective": "Produzir uma descrição precisa e acionável do algoritmo.",
                                  "commonMistakes": "Omitir chamada inicial ou não especificar ordem de recursão."
                                }
                              ],
                              "practicalExample": "Árvore de Huffman para símbolos A(4), B(2), C(1), D(1): Raiz com esquerdo (nó B+C:'00','01'), direito (A:'1' e nó D:'?'). Recursão: raiz('') -> esquerdo('0') -> B('00'), C('01'); direito('1') -> A('1'). Descrição gera: A:'1', B:'00', C:'01'.",
                              "finalVerifications": [
                                "Descrição inicia na raiz com código vazio.",
                                "Caso base atribui código exatamente nas folhas.",
                                "Recursão prefixa '0' à esquerda e '1' à direita.",
                                "Códigos gerados são prefixo-free e únicos.",
                                "Pseudocódigo cobre todos os casos sem ambiguidades.",
                                "Simulação em exemplo pequeno produz códigos corretos."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na descrição textual (nota 1-5).",
                                "Correção do pseudocódigo recursivo (sim/não).",
                                "Tratamento completo de casos base e recursivo.",
                                "Uso correto de prefixos '0' e '1'.",
                                "Validação com exemplo prático sem erros.",
                                "Estrutura lógica da descrição (introdução, corpo, conclusão)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de árvores binárias e recursão.",
                                "Linguagem: Redação técnica clara e estruturada.",
                                "Física/Engenharia: Compressão de dados em telecomunicações.",
                                "Lógica: Raciocínio dedutivo em algoritmos."
                              ],
                              "realWorldApplication": "Usado em compressão de arquivos ZIP/JPEG para gerar códigos eficientes de Huffman, reduzindo tamanho de dados em transmissão de imagens/vídeos pela internet."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Implementar Função de Geração de Códigos",
                            "description": "Implementar em pseudocódigo ou linguagem como Python uma função recursiva que recebe a árvore de Huffman e retorna um mapa {símbolo: código} com códigos binários de comprimento variável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Estrutura do Nó da Árvore de Huffman",
                                  "subSteps": [
                                    "Crie uma classe Node em Python com atributos: symbol (str ou None), frequency (int), left (Node ou None), right (Node ou None).",
                                    "Implemente o método __init__ para inicializar os atributos.",
                                    "Adicione um método is_leaf() que retorna True se symbol não for None.",
                                    "Teste a criação de um nó folha e um nó interno manualmente.",
                                    "Documente a classe com docstring explicando seu propósito na codificação Huffman."
                                  ],
                                  "verification": "Execute código para criar nós e imprima atributos; confirme que is_leaf() funciona corretamente para folhas e internos.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Use typing hints para left e right como Optional[Node] para clareza.",
                                  "learningObjective": "Compreender e representar a estrutura binária da árvore de Huffman em código.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar left/right como None.",
                                    "Confundir symbol com frequency nos nós internos.",
                                    "Não implementar is_leaf() levando a verificações manuais ineficientes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a Assinatura e Lógica Base da Função Recursiva",
                                  "subSteps": [
                                    "Defina a função generate_codes(root: Node, current_code: str = '', code_map: dict = None) -> dict.",
                                    "Inicialize code_map como {} se None.",
                                    "Adicione verificação inicial: se root é None, retorne code_map.",
                                    "Esboce chamadas recursivas: para left com '0' e right com '1'.",
                                    "Retorne code_map no final."
                                  ],
                                  "verification": "Chame a função com uma árvore simples e imprima code_map vazio ou parcial para confirmar estrutura.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo de árvore de Huffman pré-construída"
                                  ],
                                  "tips": "Use dict default como parâmetro mutável com cuidado; considere passá-lo sempre.",
                                  "learningObjective": "Estruturar uma função recursiva que traverse a árvore acumulando caminhos binários.",
                                  "commonMistakes": [
                                    "Não retornar code_map, perdendo o dicionário.",
                                    "Usar current_code como parâmetro mutável incorreto.",
                                    "Esquecer verificação de root None causando recursão infinita."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Tratamento de Folhas e Recursão Completa",
                                  "subSteps": [
                                    "Na função, verifique se root.is_leaf(): se sim, adicione code_map[root.symbol] = current_code.",
                                    "Chame recursivamente generate_codes(root.left, current_code + '0', code_map).",
                                    "Chame recursivamente generate_codes(root.right, current_code + '1', code_map).",
                                    "Garanta que a recursão pare em folhas sem chamar left/right.",
                                    "Adicione print statements temporários para depurar o caminho durante execução."
                                  ],
                                  "verification": "Execute com árvore completa; confirme que todos símbolos recebem códigos únicos e prefix-free.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Código da classe Node",
                                    "Função base do step 2"
                                  ],
                                  "tips": "Teste recursão com árvore desbalanceada para verificar profundidade.",
                                  "learningObjective": "Implementar recursão que atribui códigos binários baseados em travessia pré-ordem modificada.",
                                  "commonMistakes": [
                                    "Adicionar código em nós internos.",
                                    "Concatenar '0'/'1' na ordem errada (direita primeiro).",
                                    "Modificar code_map após recursão desnecessariamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Verificar a Função",
                                  "subSteps": [
                                    "Construa uma árvore de exemplo com símbolos 'A':5, 'B':2, 'C':1, 'D':1.",
                                    "Gere a árvore manualmente ou use função build_huffman_tree prévia.",
                                    "Chame generate_codes(root) e imprima o mapa: espere {'A':'0', 'B':'10', 'C':'110', 'D':'111'}.",
                                    "Verifique comprimentos: mais frequentes têm códigos mais curtos.",
                                    "Teste casos edge: árvore com um nó só, árvore vazia."
                                  ],
                                  "verification": "Compare output com códigos esperados manualmente calculados; sem erros de KeyError ou recursão infinita.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Código completo dos steps anteriores",
                                    "Exemplos de frequências de símbolos"
                                  ],
                                  "tips": "Use assert statements para testes automatizados.",
                                  "learningObjective": "Validar a implementação através de testes unitários e análise de resultados.",
                                  "commonMistakes": [
                                    "Árvore mal construída afetando códigos.",
                                    "Códigos não prefix-free devido a atribuição errada.",
                                    "Ignorar casos edge como árvore degenerada."
                                  ]
                                }
                              ],
                              "practicalExample": "Para frequências {'A':5, 'B':2, 'C':1, 'D':1}, a árvore tem root com left='A', right=internal(B esquerdo, internal(C,D) direito). Chamada: generate_codes(root) retorna {'A':'0', 'B':'10', 'C':'110', 'D':'111'}. Teste em Python: construa nós, chame função e print(result).",
                              "finalVerifications": [
                                "Mapa contém todos os símbolos da árvore com códigos binários únicos.",
                                "Códigos de símbolos mais frequentes são mais curtos.",
                                "Propriedade prefix-free: nenhum código é prefixo de outro.",
                                "Função lida com árvores desbalanceadas sem stack overflow.",
                                "Retorna dicionário vazio para root None.",
                                "Execução sem erros para árvores com 1 ou 2 folhas."
                              ],
                              "assessmentCriteria": [
                                "Correção: Códigos gerados correspondem exatamente à travessia da árvore.",
                                "Eficiência: Recursão O(n) onde n é número de nós.",
                                "Robustez: Trata casos edge sem crashes.",
                                "Clareza: Código legível com comentários e nomes descritivos.",
                                "Prefix-free: Verificado matematicamente nos testes.",
                                "Modularidade: Função reutilizável em codificador Huffman completo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de árvores binárias e travessias recursivas.",
                                "Probabilidade: Uso de frequências para otimização de comprimentos de código.",
                                "Engenharia de Software: Design de classes e recursão em estruturas de dados.",
                                "Física/Quântica: Codificação similar a qubits em computação quântica.",
                                "Economia: Otimização de 'custo' em transmissão de dados."
                              ],
                              "realWorldApplication": "Usado em algoritmos de compressão lossless como ZIP, GZIP, PNG e JPEG (para Huffman em entropia), reduzindo tamanho de arquivos de texto/imagens em até 50-90% ao codificar símbolos frequentes com bits menores, essencial em streaming, armazenamento em nuvem e telecomunicações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Calcular Comprimentos dos Códigos",
                            "description": "Calcular os comprimentos dos códigos para cada símbolo a partir da profundidade das folhas na árvore, relacionando com as frequências para verificar a optimalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as Folhas e Raiz da Árvore de Huffman",
                                  "subSteps": [
                                    "Visualize ou desenhe a árvore de Huffman completa, destacando a raiz.",
                                    "Liste todos os símbolos presentes nas folhas da árvore.",
                                    "Marque cada folha com seu símbolo correspondente e frequência original.",
                                    "Confirme que não há nós internos como folhas.",
                                    "Anote a profundidade inicial da raiz como 0."
                                  ],
                                  "verification": "Liste corretamente todos os símbolos nas folhas e confirme a raiz.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Árvore de Huffman impressa ou desenhada",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Comece sempre pela raiz para evitar confusões na estrutura hierárquica.",
                                  "learningObjective": "Identificar precisamente as folhas e a estrutura básica da árvore de Huffman.",
                                  "commonMistakes": [
                                    "Confundir nós internos com folhas",
                                    "Esquecer frequências associadas aos símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Profundidade de Cada Folha via Travessia",
                                  "subSteps": [
                                    "Inicie uma travessia em largura (BFS) ou recursiva a partir da raiz.",
                                    "Para cada nó, incremente a profundidade ao descer para filhos esquerdo e direito.",
                                    "Registre a profundidade exata quando encontrar uma folha.",
                                    "Repita para todas as folhas, usando uma tabela para anotar símbolo e profundidade.",
                                    "Valide a travessia percorrendo manualmente o caminho de cada folha até a raiz."
                                  ],
                                  "verification": "Crie uma tabela com símbolo, caminho e profundidade calculada para todas as folhas.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Gráfico da árvore",
                                    "Planilha ou tabela em papel/excel"
                                  ],
                                  "tips": "Use BFS para garantir profundidades corretas; evite contagem manual de níveis.",
                                  "learningObjective": "Dominar a travessia da árvore para determinar profundidades precisas das folhas.",
                                  "commonMistakes": [
                                    "Contar profundidade a partir de folhas em vez da raiz",
                                    "Ignorar ramos desbalanceados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atribuir Comprimentos dos Códigos Baseados nas Profundidades",
                                  "subSteps": [
                                    "Defina o comprimento do código de cada símbolo como sua profundidade na árvore.",
                                    "Crie uma tabela final: Símbolo | Frequência | Profundidade (Comprimento do Código).",
                                    "Gere os códigos prefixo reais percorrendo esquerda (0) e direita (1) para verificação.",
                                    "Ordene a tabela por comprimento crescente para visualizar a estrutura.",
                                    "Calcule o comprimento médio ponderado: soma(frequência * comprimento) / total_frequências."
                                  ],
                                  "verification": "Tabela completa com comprimentos atribuídos e comprimento médio calculado.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Tabela do Step 2",
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre-se: comprimento = número de bits no caminho da raiz à folha.",
                                  "learningObjective": "Mapear corretamente profundidades para comprimentos de códigos prefixo.",
                                  "commonMistakes": [
                                    "Atribuir comprimentos iguais a símbolos de frequências diferentes",
                                    "Erro na contagem de bits no caminho"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Comprimentos com Frequências e Verificar Optimalidade",
                                  "subSteps": [
                                    "Compare comprimentos: símbolos mais frequentes devem ter códigos mais curtos.",
                                    "Calcule o custo total: soma(frequência * comprimento) e compare com entropia teórica.",
                                    "Verifique o princípio de Huffman: nenhuma troca de folhas reduziria o custo médio.",
                                    "Identifique desbalanceamentos e justifique por que são ótimos.",
                                    "Documente conclusões em um relatório curto de optimalidade."
                                  ],
                                  "verification": "Relatório confirmando que comprimentos decrescem com frequências e custo é ótimo.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Tabela final do Step 3",
                                    "Fórmula de entropia: -sum(p * log2(p))"
                                  ],
                                  "tips": "Use frequências normalizadas como probabilidades para entropia.",
                                  "learningObjective": "Avaliar a optimalidade dos códigos relacionando comprimentos e frequências.",
                                  "commonMistakes": [
                                    "Ignorar normalização de frequências",
                                    "Confundir custo médio com soma absoluta"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere frequências: A:5, B:3, C:2, D:1. Árvore: Raiz--(esq: A profundidade 1)--(dir: nó interno profundidade 1)--(esq: B profund 2)--(dir: nó profund 2)--(esq: C profund 3)--(dir: D profund 3). Comprimentos: A:1, B:2, C:3, D:3. Custo médio: (5*1 + 3*2 + 2*3 + 1*3)/11 ≈ 1.727 bits, ótimo pois A (mais freq) tem código mais curto.",
                              "finalVerifications": [
                                "Tabela completa de símbolos, frequências e comprimentos corretos.",
                                "Cálculo preciso do comprimento médio ponderado.",
                                "Confirmação visual de códigos mais curtos para símbolos frequentes.",
                                "Verificação de optimalidade via comparação com entropia.",
                                "Ausência de erros na travessia da árvore.",
                                "Relatório escrito justificando a estrutura ótima."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de profundidade e comprimentos.",
                                "Correta ponderação por frequências no custo médio.",
                                "Explicação clara da relação frequência-comprimento.",
                                "Uso adequado de travessia para todos os caminhos.",
                                "Identificação de optimalidade com justificativa.",
                                "Clareza na tabela e documentação.",
                                "Eficiência no tempo estimado sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Travessias em Árvores (BFS/DFS).",
                                "Probabilidade: Cálculo de Entropia de Shannon e probabilidades.",
                                "Física: Compressão de Sinais em Telecomunicações.",
                                "Engenharia de Software: Estruturas de Dados Binárias.",
                                "Estatística: Análise de Distribuições de Frequências."
                              ],
                              "realWorldApplication": "Essencial em algoritmos de compressão sem perda como DEFLATE (usado no ZIP e PNG), permitindo redução eficiente de tamanho de arquivos ao atribuir códigos curtos a dados frequentes, otimizando armazenamento e transmissão de dados em redes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Verificação e Aplicação dos Códigos",
                        "description": "Validação da propriedade de prefixo nos códigos gerados e aplicação prática na codificação e decodificação de mensagens.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Verificar Propriedade de Prefixo",
                            "description": "Desenvolver um algoritmo ou teste para verificar se um conjunto de códigos gerados satisfaz a propriedade de prefixo, usando trie ou comparação direta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Propriedade de Prefixo",
                                  "subSteps": [
                                    "Defina código prefixo: nenhum código no conjunto é um prefixo de outro código no conjunto.",
                                    "Analise exemplos válidos, como {'0', '10', '11'} (nenhum é prefixo).",
                                    "Analise exemplos inválidos, como {'0', '01'} ('0' é prefixo de '01').",
                                    "Explique a importância para decodificação unívoca em fluxos de bits.",
                                    "Discuta relação com árvore de Huffman (folhas como códigos)."
                                  ],
                                  "verification": "Escreva uma definição precisa e forneça um exemplo válido e inválido com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas sobre codificação de Huffman",
                                    "Exemplos de códigos prefixo e não-prefixo",
                                    "Diagrama de árvore binária"
                                  ],
                                  "tips": [
                                    "Pense em prefixo como ancestral em uma árvore: caminhos para folhas não passam por outros folhas."
                                  ],
                                  "learningObjective": "Dominar o conceito teórico da propriedade de prefixo e sua relevância em codificação.",
                                  "commonMistakes": [
                                    "Confundir prefixo com sufixo ou substring arbitrária",
                                    "Ignorar que a verificação é bidirecional (A prefixo de B ou B de A)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Verificação Direta por Comparação de Pares",
                                  "subSteps": [
                                    "Crie uma função que recebe lista de códigos (strings binárias).",
                                    "Use loop duplo: para cada código i, para cada j != i, verifique se código[i] inicia com código[j] ou vice-versa.",
                                    "Use método como str.startswith() em Python para checagem.",
                                    "Retorne True se nenhum par violar, False caso contrário.",
                                    "Otimize evitando comparações desnecessárias (ex: se len(i) >= len(j))."
                                  ],
                                  "verification": "Teste a função com conjuntos válidos e inválidos; imprima pares violadores.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código (Python ou similar)",
                                    "Lista de códigos de teste pré-definidos"
                                  ],
                                  "tips": [
                                    "Comece com códigos curtos para depuração visual; complexidade O(n^2 * L) onde L é comprimento médio."
                                  ],
                                  "learningObjective": "Desenvolver algoritmo simples e correto para verificação prefixo via brute-force.",
                                  "commonMistakes": [
                                    "Esquecer verificação bidirecional",
                                    "Não tratar códigos vazios ou iguais",
                                    "Usar == em vez de prefixo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Verificação Eficiente Usando Estrutura de Trie",
                                  "subSteps": [
                                    "Defina classe TrieNode com dict children e bool isEndOfCode.",
                                    "Crie Trie com root; para cada código, traverse/insira caractere por caractere.",
                                    "Durante inserção: se encontrar nó isEndOfCode antes do fim do código atual, retorne False.",
                                    "Após inserir todos sem violação, retorne True.",
                                    "Implemente método insert_and_check com retorno de violação."
                                  ],
                                  "verification": "Construa Trie para códigos de teste e visualize nós terminais; confirme detecção de prefixos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Diagrama de Trie em papel",
                                    "Implementação base de Trie"
                                  ],
                                  "tips": [
                                    "Use '0' e '1' como chaves em children; complexidade O(total comprimento dos códigos)."
                                  ],
                                  "learningObjective": "Construir e aplicar estrutura de Trie para verificação prefixo eficiente.",
                                  "commonMistakes": [
                                    "Não marcar isEndOfCode corretamente",
                                    "Permitir traversar além do fim sem checagem",
                                    "Erro em recursão ou iteração de inserção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Validar e Comparar Ambos os Métodos",
                                  "subSteps": [
                                    "Gere códigos Huffman para alfabeto pequeno (ex: frequências {a:5, b:2, c:1}).",
                                    "Aplique ambas funções (direta e Trie) nos códigos gerados.",
                                    "Meça tempo de execução para conjuntos grandes (100+ códigos).",
                                    "Crie casos de borda: código vazio, todos códigos iguais comprimento, árvore desbalanceada.",
                                    "Documente resultados em tabela comparativa."
                                  ],
                                  "verification": "Ambos métodos retornam mesmo resultado em 10 conjuntos de teste; Trie mais rápido em grandes inputs.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código de geração Huffman",
                                    "Timer de performance (timeit em Python)",
                                    "Conjuntos de teste variados"
                                  ],
                                  "tips": [
                                    "Use random para gerar frequências; foque em escalabilidade do Trie."
                                  ],
                                  "learningObjective": "Integrar e avaliar métodos em contexto real de Huffman, identificando trade-offs.",
                                  "commonMistakes": [
                                    "Não testar casos de borda",
                                    "Ignorar performance em análise",
                                    "Assumir Huffman sempre gera prefixo sem verificar"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere códigos gerados por Huffman para {a:0.5, b:0.3, c:0.2}: {'a':'0', 'b':'10', 'c':'11'}. Verificação direta: nenhum par viola (ex: '0' não prefixo de '10'). Trie: insere '0' (fim), '10' (passa por '1' novo, fim em '0'), '11' similar, sem passar por fim prematuro. Agora, altere para {'a':'0', 'd':'01'}: Trie detecta violação ao inserir '01' passando por fim de '0'.",
                              "finalVerifications": [
                                "Função direta detecta violações em conjuntos inválidos com precisão 100%.",
                                "Trie verifica prefixo sem falsos positivos/negativos em 20 testes.",
                                "Implementação roda em <1s para 100 códigos de comprimento 20.",
                                "Explicação oral correta de por que Huffman garante prefixo.",
                                "Tabela comparativa mostra Trie O(NL) vs direto O(N^2 L).",
                                "Códigos Huffman reais validados como prefixo."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% acerto em testes padrão e borda (40%).",
                                "Eficiência: Trie otimizado e comparado corretamente (20%).",
                                "Clareza de código: comentários, nomes variáveis intuitivos (15%).",
                                "Documentação: exemplos, diagramas, análise de performance (15%).",
                                "Compreensão conceitual: explicação escrita/teórica (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de árvores e grafos direcionados acíclicos.",
                                "Engenharia de Software: Estruturas de dados para processamento de strings.",
                                "Física/Telecomunicações: Codificação de canais sem ambiguidade.",
                                "Linguística Computacional: Linguagens prefixadas e parsing."
                              ],
                              "realWorldApplication": "Verificação de códigos prefixo é essencial em compressão de dados (ZIP, GZIP usando Huffman), protocolos de rede (para frames sem ambiguidade), e busca em dicionários (autocompletar em motores de busca), garantindo decodificação instantânea e sem erros em fluxos de bits massivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Codificar e Decodificar Mensagem",
                            "description": "Usar os códigos gerados para codificar uma mensagem (substituindo símbolos por códigos binários concatenados) e decodificar uma sequência binária de volta aos símbolos originais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Mensagem e os Códigos de Huffman",
                                  "subSteps": [
                                    "Selecione uma mensagem curta e representativa, como 'ABBA', baseada nas frequências usadas na geração de códigos.",
                                    "Liste todos os símbolos únicos e seus códigos prefixo gerados anteriormente (ex: A: '0', B: '10').",
                                    "Verifique manualmente que os códigos são prefixo-free: nenhum código é prefixo de outro.",
                                    "Crie uma tabela com colunas: Símbolo, Código Binário, Comprimento.",
                                    "Copie a mensagem em uma linha separada para referência rápida."
                                  ],
                                  "verification": "Tabela de códigos completa e verificada como prefixo-free, mensagem anotada corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Códigos de Huffman do passo anterior de geração"
                                  ],
                                  "tips": "Mantenha a tabela visível durante todo o processo para consulta rápida.",
                                  "learningObjective": "Preparar todos os recursos necessários para garantir codificação e decodificação precisas.",
                                  "commonMistakes": [
                                    "Usar códigos incorretos ou não prefixo-free",
                                    "Escolher mensagem muito longa que complique o aprendizado inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Codificar a Mensagem em Sequência Binária",
                                  "subSteps": [
                                    "Identifique cada símbolo na mensagem da esquerda para a direita.",
                                    "Para cada símbolo, substitua pelo seu código binário correspondente.",
                                    "Concatene todos os códigos em uma única string binária sem espaços ou separadores.",
                                    "Conte o número total de bits na sequência resultante.",
                                    "Anote a sequência em negrito ou caixa para destaque."
                                  ],
                                  "verification": "Sequência binária gerada é a concatenação exata dos códigos dos símbolos da mensagem original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de códigos preparada",
                                    "Papel ou editor de texto para anotar a sequência"
                                  ],
                                  "tips": "Processe um símbolo por vez e verifique após cada concatenação para evitar erros cumulativos.",
                                  "learningObjective": "Executar a codificação por substituição e concatenação de códigos variáveis.",
                                  "commonMistakes": [
                                    "Inserir separadores entre códigos",
                                    "Invertir bits ou errar a ordem de concatenação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decodificar a Sequência Binária de Volta aos Símbolos",
                                  "subSteps": [
                                    "Inicie no primeiro bit da sequência binária.",
                                    "Compare o prefixo atual com todos os códigos até encontrar uma correspondência exata.",
                                    "Anote o símbolo decodificado e avance o ponteiro para o bit seguinte após o código.",
                                    "Repita o processo até consumir todos os bits da sequência.",
                                    "Compare a mensagem decodificada com a original."
                                  ],
                                  "verification": "Mensagem decodificada é idêntica à mensagem original sem ambiguidades ou sobras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Sequência binária codificada",
                                    "Tabela de códigos invertida (código -> símbolo) para agilizar"
                                  ],
                                  "tips": "Lembre-se: prefixo-free garante match único sem backtracking.",
                                  "learningObjective": "Aplicar decodificação sequencial usando propriedade prefixo-free de Huffman.",
                                  "commonMistakes": [
                                    "Parar prematuramente no meio de um código",
                                    "Confundir códigos com prefixos compartilhados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Integridade e Testar com Nova Mensagem",
                                  "subSteps": [
                                    "Re-codifique e re-decodifique a mensagem original para confirmação.",
                                    "Escolha uma nova mensagem (ex: 'BABA') e repita codificação completa.",
                                    "Calcule e compare o comprimento binário vs. representação fixa (ex: 2 bits/símbolo).",
                                    "Identifique qualquer discrepância e corrija.",
                                    "Registre observações sobre eficiência de compressão."
                                  ],
                                  "verification": "Codificação/decodificação bem-sucedida em pelo menos duas mensagens, com comprimentos calculados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Múltiplas mensagens de teste",
                                    "Calculadora para comprimentos opcionais"
                                  ],
                                  "tips": "Use mensagens com frequências desbalanceadas para observar ganhos de compressão reais.",
                                  "learningObjective": "Validar o processo completo e compreender benefícios práticos da codificação Huffman.",
                                  "commonMistakes": [
                                    "Ignorar verificação de comprimento",
                                    "Não testar com variações de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Documentar o Processo",
                                  "subSteps": [
                                    "Descreva em palavras o fluxo de codificação e decodificação.",
                                    "Calcule taxa de compressão: (bits originais - bits Huffman) / bits originais.",
                                    "Discuta cenários onde falharia (ex: códigos não prefixo-free).",
                                    "Crie um fluxograma simples do processo.",
                                    "Salve todos os exemplos para revisão futura."
                                  ],
                                  "verification": "Documentação completa com cálculos, fluxograma e análise de eficiência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para fluxograma",
                                    "Ferramentas de desenho digital opcionais"
                                  ],
                                  "tips": "Use setas para mostrar concatenação e matching de prefixos no fluxograma.",
                                  "learningObjective": "Refletir sobre o algoritmo para retenção profunda e aplicação futura.",
                                  "commonMistakes": [
                                    "Pular análise quantitativa de compressão",
                                    "Documentar sem exemplos concretos"
                                  ]
                                }
                              ],
                              "practicalExample": "Mensagem: 'AAB'. Códigos: A:'0' (1 bit), B:'11' (2 bits). Codificação: A(0) + A(0) + B(11) = '0011' (4 bits). Decodificação: '00..' -> '0'=A, próximo '0'=A, '11'=B → 'AAB'. Nota: fixa 2 bits/símbolo seria 6 bits, Huffman economiza 33%.",
                              "finalVerifications": [
                                "Sequência codificada corresponde exatamente à concatenação dos códigos.",
                                "Decodificação recupera 100% da mensagem original.",
                                "Propriedade prefixo-free evita ambiguidades comprovada.",
                                "Comprimento total da sequência é soma exata dos comprimentos dos códigos.",
                                "Processo funciona sem sobras ou faltas de bits.",
                                "Eficiência de compressão calculada corretamente para pelo menos uma mensagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão absoluta na codificação e decodificação (zero erros).",
                                "Explicação clara e passo-a-passo do processo.",
                                "Correta identificação e uso de prefixo-free.",
                                "Cálculo preciso de comprimentos e taxa de compressão.",
                                "Aplicação bem-sucedida a mensagens novas e variadas.",
                                "Documentação completa com exemplos e análise.",
                                "Tempo de execução dentro dos estimados com qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações com binários, árvores e probabilidades.",
                                "Linguística: Codificação simbólica e semântica de mensagens.",
                                "Física: Transmissão de sinais digitais e eficiência de banda.",
                                "Engenharia: Compressão em redes e armazenamento de dados."
                              ],
                              "realWorldApplication": "Essencial em compressão de dados como ZIP/GZIP, codificação de vídeo (H.264), transmissão HTTP eficiente e redução de custos em telecomunicações, permitindo enviar mais dados com menos bits."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Analisar Eficiência dos Códigos",
                            "description": "Calcular o comprimento médio da codificação ponderado pelas frequências e comparar com a entropia, demonstrando a near-optimalidade da geração de Huffman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Dados de Frequência e Calcular Entropia da Fonte",
                                  "subSteps": [
                                    "Liste todos os símbolos e suas frequências absolutas de um conjunto de dados de exemplo.",
                                    "Calcule o total de ocorrências e as probabilidades p_i = frequência_i / total.",
                                    "Compute a entropia H usando a fórmula H = -∑(p_i * log₂(p_i)) para todos os símbolos.",
                                    "Registre o valor da entropia em bits por símbolo.",
                                    "Verifique se as probabilidades somam 1.0."
                                  ],
                                  "verification": "Confirme que o valor da entropia está correto comparando com uma calculadora ou script Python simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de cálculo ou Excel",
                                    "Calculadora científica com log₂",
                                    "Exemplo de frequências: A:40%, B:30%, C:20%, D:10%"
                                  ],
                                  "tips": "Use log₂(x) = ln(x)/ln(2) se a calculadora não tiver log₂ nativo; ignore termos com p_i=0.",
                                  "learningObjective": "Compreender o conceito de entropia como limite inferior teórico para codificação eficiente.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na fórmula",
                                    "Usar log10 em vez de log₂",
                                    "Não normalizar probabilidades corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e Listar os Códigos Huffman com Seus Comprimentos",
                                  "subSteps": [
                                    "Construa a árvore de Huffman a partir das frequências para obter os códigos prefixo.",
                                    "Atribua códigos binários aos símbolos percorrendo a árvore (0 para esquerda, 1 para direita).",
                                    "Meça o comprimento de cada código (número de bits).",
                                    "Crie uma tabela com símbolo, código e comprimento.",
                                    "Valide que nenhum código é prefixo de outro."
                                  ],
                                  "verification": "Os códigos formam um conjunto prefixo-livre e a árvore foi construída corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para desenhar árvore",
                                    "Ferramenta online de Huffman ou Python com heapq"
                                  ],
                                  "tips": "Sempre ordene nós por frequência crescente ao construir a árvore; priorize combinações de menor frequência.",
                                  "learningObjective": "Aplicar o algoritmo de Huffman para gerar códigos de comprimentos variáveis.",
                                  "commonMistakes": [
                                    "Erro na ordenação de nós durante merges",
                                    "Atribuição incorreta de 0/1 nas ramificações",
                                    "Códigos com prefixos comuns"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Comprimento Médio Ponderado da Codificação",
                                  "subSteps": [
                                    "Para cada símbolo, multiplique seu comprimento de código pelo p_i: custo_i = l_i * p_i.",
                                    "Some todos os custo_i para obter o comprimento médio L = ∑(l_i * p_i).",
                                    "Registre L em bits por símbolo.",
                                    "Compare L com H visualmente (L deve ser próximo de H).",
                                    "Calcule a diferença L - H para quantificar eficiência."
                                  ],
                                  "verification": "O valor de L é menor ou igual a H + 1, conforme teorema de Huffman.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de resultados do Step 1 e 2",
                                    "Calculadora"
                                  ],
                                  "tips": "Use probabilidades decimais precisas para evitar erros de arredondamento.",
                                  "learningObjective": "Calcular a eficiência média da codificação ponderada por frequências.",
                                  "commonMistakes": [
                                    "Usar frequências absolutas em vez de probabilidades",
                                    "Arredondar prematuramente nos cálculos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Demonstrar Near-Optimalidade",
                                  "subSteps": [
                                    "Compare L com H: verifique se L ≤ H + 1.",
                                    "Calcule a eficiência relativa: (H / L) * 100%.",
                                    "Interprete resultados: discuta por que Huffman é near-ótimo.",
                                    "Teste com variação de frequências para observar impacto.",
                                    "Documente conclusões em um relatório curto."
                                  ],
                                  "verification": "Relatório mostra L próximo de H e explica near-optimalidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados anteriores",
                                    "Gráfico comparativo L vs H"
                                  ],
                                  "tips": "Eficiência >95% indica bom desempenho; teste com dados reais como texto.",
                                  "learningObjective": "Demonstrar matematicamente a optimalidade aproximada do Huffman.",
                                  "commonMistakes": [
                                    "Ignorar o limite H+1",
                                    "Não contextualizar a diferença como aceitável"
                                  ]
                                }
                              ],
                              "practicalExample": "Para símbolos A(0.4), B(0.3), C(0.2), D(0.1): Entropia H ≈ 1.846 bits. Códigos: A=0 (1 bit), B=10 (2), C=110 (3), D=111 (3). L = (1*0.4) + (2*0.3) + (3*0.2) + (3*0.1) = 1.9 bits. Diferença: 1.9 - 1.846 = 0.054 (near-ótimo, eficiência ~97%).",
                              "finalVerifications": [
                                "Entropia H calculada corretamente para dados de entrada.",
                                "Comprimento médio L ≤ H + 1.",
                                "Eficiência relativa (H/L * 100%) ≥ 90%.",
                                "Códigos são prefixo-livres.",
                                "Análise escrita explica near-optimalidade.",
                                "Teste com segundo conjunto de dados confirma consistência."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de entropia e L (erro <0.01).",
                                "Correta construção da árvore e códigos Huffman.",
                                "Interpretação qualitativa e quantitativa da eficiência.",
                                "Uso apropriado de probabilidades e log₂.",
                                "Clareza na tabela e relatório final.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Cálculo de entropia como medida de incerteza.",
                                "Matemática Discreta: Árvores binárias e propriedades prefixo-livres.",
                                "Teoria da Informação: Limites de Shannon para compressão.",
                                "Engenharia de Software: Otimização em algoritmos de compressão."
                              ],
                              "realWorldApplication": "Em compressão de arquivos (ZIP, GZIP), transmissão de dados em redes (reduzindo largura de banda), codificação de imagens (JPEG) e áudio (MP3), onde Huffman minimiza bits transmitidos para dados com frequências desiguais, economizando armazenamento e tempo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Processo de Codificação",
                    "description": "Transformação da mensagem original em sequência binária compacta usando os códigos da árvore de Huffman.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Derivação dos Códigos dos Símbolos",
                        "description": "Processo de percorrer a árvore de Huffman para atribuir códigos binários prefixos aos símbolos folha, utilizando convenção de 0 para ramo esquerdo e 1 para ramo direito.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Explicar o percurso na árvore para geração de códigos",
                            "description": "Descrever o algoritmo recursivo ou iterativo para percorrer a árvore de Huffman a partir da raiz, registrando '0' ao ir para a esquerda e '1' para a direita, até alcançar folhas e associar o caminho ao símbolo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da árvore de Huffman",
                                  "subSteps": [
                                    "Revise a construção da árvore de Huffman a partir das frequências dos símbolos.",
                                    "Identifique a raiz, nós internos e folhas (que representam os símbolos).",
                                    "Note que a árvore é binária completa e otimizada para comprimento médio mínimo.",
                                    "Desenhe ou visualize uma árvore de exemplo simples com 4 símbolos.",
                                    "Explique que o caminho da raiz à folha define o código binário."
                                  ],
                                  "verification": "Desenhe corretamente a árvore de Huffman para um conjunto dado de frequências e identifique raiz e folhas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou software de desenho como Draw.io; tabela de frequências exemplo.",
                                  "tips": "Sempre priorize nós de menor frequência na construção para entender a profundidade.",
                                  "learningObjective": "Entender como a árvore de Huffman é estruturada para codificação ótima.",
                                  "commonMistakes": "Confundir árvore de Huffman com árvore binária de busca; ignorar que é prefixo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iniciar o percurso da raiz e registrar direções",
                                  "subSteps": [
                                    "Comece na raiz com um código vazio (string vazia).",
                                    "Ao mover para o filho esquerdo, anexe '0' ao código atual.",
                                    "Ao mover para o filho direito, anexe '1' ao código atual.",
                                    "Continue recursivamente ou iterativamente até atingir uma folha.",
                                    "Registre o código acumulado ao chegar na folha."
                                  ],
                                  "verification": "Simule o percurso manualmente para uma árvore simples e liste os códigos parciais em cada nó.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Árvore de Huffman desenhada; quadro branco ou editor de texto para simular caminhos.",
                                  "tips": "Use uma pilha para simulação iterativa se preferir evitar recursão profunda.",
                                  "learningObjective": "Dominar o mapeamento de direções (esquerda=0, direita=1) durante a travessia.",
                                  "commonMistakes": "Inverter esquerda/direita; começar com código não vazio na raiz."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Completar a geração de códigos para todos os símbolos",
                                  "subSteps": [
                                    "Aplique o percurso a todas as folhas usando DFS (Depth-First Search).",
                                    "Associe cada código final ao símbolo correspondente na folha.",
                                    "Liste todos os pares símbolo-código em ordem alfabética ou de frequência.",
                                    "Verifique se nenhum código é prefixo de outro (propriedade essencial).",
                                    "Compare comprimento dos códigos com frequências (mais curtos para frequentes)."
                                  ],
                                  "verification": "Gere a tabela completa de códigos para uma árvore exemplo e confirme prefixo-free.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplo de árvore; planilha ou código Python simples para validação.",
                                  "tips": "Implemente em pseudocódigo primeiro para clareza antes de código real.",
                                  "learningObjective": "Gerar e associar códigos corretamente via travessia completa da árvore.",
                                  "commonMistakes": "Parar prematuramente; gerar códigos duplicados ou com prefixos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar variações recursiva e iterativa do algoritmo",
                                  "subSteps": [
                                    "Descreva a versão recursiva: função que recebe nó atual e código atual.",
                                    "Descreva a versão iterativa: use pilha com pares (nó, código).",
                                    "Compare eficiência e casos de uso (recursão para árvores rasas).",
                                    "Implemente uma das versões em pseudocódigo ou código simples.",
                                    "Teste com exemplo para validar saída."
                                  ],
                                  "verification": "Escreva pseudocódigo para ambas versões e execute mentalmente em uma árvore.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código como VS Code; exemplos de árvores variadas.",
                                  "tips": "Recursão é mais intuitiva para árvores; iterativa evita estouro de pilha.",
                                  "learningObjective": "Diferenciar e implementar travessias recursiva e iterativa para geração de códigos.",
                                  "commonMistakes": "Confundir pilha recursiva com iterativa; esquecer backtracking nos bits."
                                }
                              ],
                              "practicalExample": "Considere símbolos A(5), B(2), C(1), D(1). Árvore: Raiz divide em A(esquerda, código '0') e subárvore direita (B'10', C'110', D'111'). Percurso: Raiz -> esquerda ('0') = A; Raiz -> direita ('1') -> esquerda ('10') = B; etc. Tabela final: A:0, B:10, C:110, D:111.",
                              "finalVerifications": [
                                "Pode desenhar o percurso exato da raiz a uma folha específica?",
                                "Explica corretamente '0' esquerda e '1' direita?",
                                "Gera tabela de códigos prefixo-free para novo exemplo?",
                                "Diferencia recursivo vs iterativo com pseudocódigo?",
                                "Calcula comprimento médio e compara com frequências?",
                                "Identifica erros em códigos gerados incorretamente?"
                              ],
                              "assessmentCriteria": [
                                "Clareza na descrição do percurso (direções e registro de bits).",
                                "Correção na associação de caminhos a símbolos.",
                                "Compreensão de propriedades (prefixo-free, otimalidade).",
                                "Uso de exemplos concretos para ilustração.",
                                "Capacidade de implementar em pseudocódigo ou código.",
                                "Identificação de erros comuns em travessias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de árvores binárias e grafos.",
                                "Probabilidade: Uso de frequências para otimização.",
                                "Linguagens: Estruturas de dados (árvores, pilhas).",
                                "Física: Codificação em sinais digitais (telecomunicações)."
                              ],
                              "realWorldApplication": "Usado em compressão de arquivos (ZIP, GZIP), formatos de imagem (JPEG), vídeo (MP4) e transmissão de dados para reduzir largura de banda, economizando armazenamento e tempo de download."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Construir manualmente a tabela de códigos",
                            "description": "Dado uma árvore de Huffman desenhada, percorrer manualmente cada ramo para listar os códigos binários de todos os símbolos e verificar a propriedade de prefixo (nenhum código é prefixo de outro).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Examinar a árvore de Huffman e identificar os símbolos nas folhas",
                                  "subSteps": [
                                    "Visualize ou desenhe a árvore de Huffman fornecida, identificando a raiz e todos os nós internos e folhas.",
                                    "Liste todos os símbolos presentes nas folhas da árvore, anotando suas posições relativas à raiz.",
                                    "Marque os ramos: convenção padrão de ramo esquerdo como '0' e ramo direito como '1'.",
                                    "Confirme que não há símbolos em nós internos, apenas nas folhas.",
                                    "Anote a profundidade aproximada de cada folha para antecipar o comprimento dos códigos."
                                  ],
                                  "verification": "Lista completa de símbolos nas folhas com marcações de ramos esquerdo/direito confirmada visualmente na árvore.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Árvore de Huffman desenhada em papel ou software (ex: draw.io)",
                                    "Papel e caneta para anotações",
                                    "Folha para tabela inicial"
                                  ],
                                  "tips": "Comece sempre da raiz e trace caminhos para cada folha para evitar confusão com subárvores.",
                                  "learningObjective": "Identificar corretamente todos os símbolos e convenções de ramos na árvore de Huffman.",
                                  "commonMistakes": [
                                    "Confundir ramos esquerdo/direito",
                                    "Ignorar símbolos em folhas profundas",
                                    "Listar nós internos como símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Percorrer a árvore da raiz para atribuir códigos binários aos símbolos",
                                  "subSteps": [
                                    "Inicie na raiz e para cada caminho até uma folha, anote '0' para cada ramo esquerdo e '1' para cada ramo direito.",
                                    "Siga um caminho por vez: por exemplo, raiz -> esquerda ('0') -> direita ('1') resulta em '01'.",
                                    "Repita para todos os caminhos até folhas, registrando o código binário completo para cada símbolo.",
                                    "Evite parar em nós internos; continue até as folhas.",
                                    "Ordene os códigos por símbolo alfabeticamente para facilitar a tabela."
                                  ],
                                  "verification": "Cada símbolo tem um código binário único derivado do caminho exato da raiz à folha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Árvore de Huffman",
                                    "Papel quadriculado para traçar caminhos",
                                    "Marcadores coloridos para ramos (azul para 0, vermelho para 1)"
                                  ],
                                  "tips": "Use setas para traçar caminhos e verbalize o código em voz alta para reforçar (ex: 'esquerda-zero, direita-um').",
                                  "learningObjective": "Atribuir códigos binários precisos baseados na travessia da árvore de Huffman.",
                                  "commonMistakes": [
                                    "Parar em nós internos",
                                    "Inverter convenção 0/1",
                                    "Duplicar códigos por erro de percurso"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a tabela de códigos com símbolos e códigos atribuídos",
                                  "subSteps": [
                                    "Crie uma tabela com colunas: Símbolo, Código Binário, Comprimento do Código.",
                                    "Preencha linha por linha: símbolo na ordem alfabética ou de frequência, seguido de seu código.",
                                    "Calcule o comprimento de cada código (número de bits).",
                                    "Revise a tabela para garantir que todos os símbolos da árvore estejam incluídos.",
                                    "Formate códigos sem espaços ou separadores para clareza."
                                  ],
                                  "verification": "Tabela completa com todos símbolos, códigos corretos e comprimentos calculados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela (ex: Google Sheets ou Excel)",
                                    "Lista de símbolos do Step 1"
                                  ],
                                  "tips": "Use negrito ou cores para destacar códigos mais curtos (frequentes).",
                                  "learningObjective": "Organizar códigos em uma tabela estruturada para referência rápida.",
                                  "commonMistakes": [
                                    "Omitir símbolos",
                                    "Erros de transcrição de códigos",
                                    "Esquecer comprimento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a propriedade de prefixo na tabela de códigos",
                                  "subSteps": [
                                    "Para cada código, cheque se ele é prefixo de outro: compare bit a bit com todos os demais.",
                                    "Use método de árvore mental: nenhum código deve terminar onde outro continua.",
                                    "Teste pares: pegue código mais curto e veja se qualquer outro começa exatamente com ele.",
                                    "Confirme que todos códigos são distintos e sem prefixos mútuos.",
                                    "Documente qualquer violação encontrada (deve ser zero em Huffman válida)."
                                  ],
                                  "verification": "Declaração assinada: 'Propriedade de prefixo confirmada: nenhum código é prefixo de outro.'",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de códigos do Step 3",
                                    "Papel para comparações bit a bit"
                                  ],
                                  "tips": "Ordene códigos por comprimento crescente para verificação eficiente.",
                                  "learningObjective": "Validar a propriedade essencial de códigos de Huffman para decodificação sem ambiguidade.",
                                  "commonMistakes": [
                                    "Ignorar comparações com códigos de mesmo comprimento",
                                    "Confundir sufixo com prefixo",
                                    "Não checar todos os pares"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a completude e otimização da tabela",
                                  "subSteps": [
                                    "Conte o número de símbolos e confirme igual ao da árvore.",
                                    "Verifique se comprimentos refletem frequências (códigos mais curtos para frequentes).",
                                    "Simule codificação de uma sequência curta para testar.",
                                    "Compare com código de Huffman esperado se disponível.",
                                    "Salve ou imprima a tabela final.",
                                    ""
                                  ],
                                  "verification": "Tabela validada com contagem, simulação e assinatura de completude.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela final",
                                    "Sequência de teste exemplo (ex: AAABBCD)"
                                  ],
                                  "tips": "Para otimização, some frequências * comprimento para custo total.",
                                  "learningObjective": "Garantir que a tabela é completa, correta e otimizada.",
                                  "commonMistakes": [
                                    "Não testar com sequência",
                                    "Assumir sem validação de frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Árvore exemplo: Raiz | Esquerda(0): Nó AB (A freq5 folha esquerda0='0', B freq2 folha direita1='01') | Direita(1): Nó CD (C freq1 folha esquerda0='10', D freq1 folha direita1='11'). Tabela: A:'0', B:'01', C:'10', D:'11'. Verificação: '0' não prefixo de outros (01 continua mas B tem 01 completo); '01' não prefixo, etc.",
                              "finalVerifications": [
                                "Todos símbolos da árvore têm códigos únicos na tabela.",
                                "Propriedade de prefixo confirmada sem exceções.",
                                "Códigos correspondem exatamente aos caminhos da raiz às folhas.",
                                "Comprimentos dos códigos variam corretamente com profundidades.",
                                "Tabela pode decodificar uma sequência de teste sem ambiguidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos códigos binários atribuídos.",
                                "Verificação de prefixo documentada e correta.",
                                "Tabela completa, organizada e com comprimentos.",
                                "Eficiência na travessia (tempo dentro do estimado).",
                                "Explicação clara de pelo menos um caminho exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de árvores e travessia de grafos.",
                                "Estatística: Códigos otimizados baseados em probabilidades/frequências.",
                                "Linguagens: Representação binária e sistemas de numeração.",
                                "Engenharia: Aplicações em compressão de dados e telecomunicações."
                              ],
                              "realWorldApplication": "Em compressão de arquivos ZIP ou PNG, onde tabelas de Huffman reduzem tamanho de dados de texto/imagens; em telecomunicações para codificação eficiente de sinais de voz (ex: MP3)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Implementar função para gerar tabela de códigos",
                            "description": "Escrever pseudocódigo ou código em linguagem de programação para uma função que recebe a raiz da árvore de Huffman e retorna um dicionário mapeando símbolos para suas strings binárias de código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura de dados para o nó da árvore de Huffman",
                                  "subSteps": [
                                    "Analise a estrutura típica de um nó: atributos 'left', 'right' (filhos), e 'symbol' (None para nós internos, símbolo para folhas).",
                                    "Crie uma classe Node em Python com inicializador (__init__) para left, right e symbol.",
                                    "Instancie manualmente uma pequena árvore de Huffman de exemplo com 3-4 símbolos para testar a estrutura.",
                                    "Desenhe a árvore no papel e valide se o código a representa corretamente.",
                                    "Adicione um método str ou repr para visualização fácil dos nós."
                                  ],
                                  "verification": "Classe Node definida, árvore de exemplo criada e impressa sem erros, estrutura visualmente confirmada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VSCode ou Jupyter Notebook)",
                                    "Papel e caneta para esboçar a árvore",
                                    "Documentação básica de classes Python"
                                  ],
                                  "tips": "Sempre inicialize left e right como None para evitar recursões infinitas prematuras.",
                                  "learningObjective": "Representar corretamente a árvore binária de Huffman em código orientado a objetos.",
                                  "commonMistakes": [
                                    "Esquecer de tratar nós internos (symbol=None)",
                                    "Não inicializar atributos opcionais",
                                    "Confundir ordem de left/right na construção manual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a lógica recursiva da função em pseudocódigo",
                                  "subSteps": [
                                    "Defina a assinatura da função: def generate_huffman_codes(root: Node) -> dict[str, str].",
                                    "Identifique o caso base: se root.symbol não é None, retorne {root.symbol: ''}.",
                                    "Para nós internos: recursivamente obtenha códigos da subárvore esquerda (prefix '0') e direita (prefix '1'), e mescle os dicionários.",
                                    "Escreva pseudocódigo detalhado cobrindo recursão e mesclagem de dicionários.",
                                    "Simule manualmente a execução com a árvore de exemplo do Step 1."
                                  ],
                                  "verification": "Pseudocódigo escrito, simulação manual produz dicionário correto para o exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para pseudocódigo e simulação",
                                    "Árvore de exemplo do Step 1"
                                  ],
                                  "tips": "Use um dicionário vazio como resultado inicial e atualize com códigos prefixados.",
                                  "learningObjective": "Dominar o raciocínio recursivo para travessia de árvore e construção de códigos prefixados.",
                                  "commonMistakes": [
                                    "Esquecer de prefixar códigos nas subchamadas recursivas",
                                    "Não tratar caso base corretamente",
                                    "Mesclar dicionários sem copiar para evitar mutações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a função em código Python real",
                                  "subSteps": [
                                    "Traduza o pseudocódigo diretamente para Python, usando recursão em generate_huffman_codes.",
                                    "Implemente mesclagem de dicionários: para esquerda, prefix '0'; para direita, '1'.",
                                    "Adicione tratamento de erro se root for None.",
                                    "Teste sintaxe executando a função com a árvore de exemplo (imprima o dicionário).",
                                    "Otimize para eficiência, garantindo O(n) onde n é número de folhas."
                                  ],
                                  "verification": "Função executa sem erros de runtime e retorna dicionário correto para árvore de exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código com Python interpreter",
                                    "Árvore de exemplo pronta"
                                  ],
                                  "tips": "Use dict comprehension ou update() para mesclar: codes_left = {k: '0' + v for k,v in left_codes.items()}.",
                                  "learningObjective": "Converter lógica recursiva em código funcional e eficiente.",
                                  "commonMistakes": [
                                    "Stack overflow em árvores profundas (monitore recursão)",
                                    "Prefixos invertidos (esquerda '1', direita '0')",
                                    "Modificar dicionários recursivos in-place"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e validar a implementação completa",
                                  "subSteps": [
                                    "Crie 2-3 árvores de teste variadas (pequena, desbalanceada, com símbolo único).",
                                    "Execute a função e compare saídas com códigos esperados calculados manualmente.",
                                    "Adicione asserts ou testes unitários simples para verificar prefix-free e completude.",
                                    "Meça performance em árvore maior (ex: 20 símbolos) e depure erros comuns.",
                                    "Documente a função com docstring explicando parâmetros e retorno."
                                  ],
                                  "verification": "Todos testes passam, códigos são prefix-free e cobrem todos símbolos sem duplicatas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com unittest ou pytest opcional",
                                    "Gerador de árvores Huffman simples para testes extras"
                                  ],
                                  "tips": "Verifique propriedade prefix: nenhum código é prefixo de outro.",
                                  "learningObjective": "Garantir robustez da implementação através de testes sistemáticos.",
                                  "commonMistakes": [
                                    "Não testar casos edge como árvore com uma folha",
                                    "Ignorar verificação de prefix-free",
                                    "Erros em mesclagem levando a códigos errados"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma árvore de Huffman com símbolos 'a'(freq=5), 'b'(3), 'c'(1), 'd'(1): raiz -> esquerda: nó('b' esquerda, 'c' direita) -> direita: nó('a' esquerda, 'd' direita). A função retorna {'a': '10', 'b': '00', 'c': '01', 'd': '11'} (códigos binários corretos baseados em travessia esquerda=0, direita=1).",
                              "finalVerifications": [
                                "Dicionário retornado contém exatamente todos os símbolos das folhas.",
                                "Todos códigos são strings binárias únicas e prefix-free (nenhum é prefixo de outro).",
                                "Códigos correspondem à profundidade e caminho na árvore (esquerda '0', direita '1').",
                                "Função lida com árvore de uma única folha (retorna {symbol: ''}).",
                                "Sem erros de recursão ou stack overflow em árvores razoáveis (até 100 folhas).",
                                "Performance é linear no número de símbolos."
                              ],
                              "assessmentCriteria": [
                                "Código é correto, recursivo e produz dicionários exatos para múltiplos testes.",
                                "Implementação eficiente O(n) sem loops desnecessários.",
                                "Estrutura de código limpa, com docstrings e tratamento de None.",
                                "Testes unitários ou manuais cobrem casos base, edge e normais.",
                                "Comentários explicam lógica recursiva claramente.",
                                "Propriedade de Huffman preservada: códigos canônicos e ótimos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de árvores binárias e travessia recursiva (pré-ordem modificada).",
                                "Probabilidade: Cálculo de entropia e comprimento médio de código.",
                                "Engenharia de Software: Padrões recursivos e estruturas de dados imutáveis.",
                                "Física/Engenharia: Compressão de sinais em telecomunicações."
                              ],
                              "realWorldApplication": "Implementado em algoritmos de compressão lossless como DEFLATE (usado em ZIP, PNG), codificação de vídeo (H.264), e transmissão eficiente de dados em redes, reduzindo largura de banda em até 50% para textos e imagens."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Mapeamento da Mensagem Original",
                        "description": "Associação de cada caractere da mensagem de entrada com seu código binário correspondente na tabela de Huffman, considerando a frequência implícita na árvore.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Consultar código de um símbolo específico",
                            "description": "Dado uma tabela de códigos e um símbolo, recuperar eficientemente o código binário associado, simulando uma busca em hash ou dicionário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Tabela de Códigos de Huffman",
                                  "subSteps": [
                                    "Liste todos os símbolos e seus códigos binários correspondentes da árvore de Huffman gerada.",
                                    "Estruture a tabela como um dicionário ou hash map, onde a chave é o símbolo e o valor é o código binário.",
                                    "Inicialize a estrutura de dados em uma linguagem de programação como Python (ex: dict) ou simule manualmente.",
                                    "Valide que todos os símbolos da mensagem original estão mapeados.",
                                    "Ordene ou indexe a tabela para acesso rápido, se aplicável."
                                  ],
                                  "verification": "Confira se a tabela contém pares chave-valor corretos para pelo menos 5 símbolos de exemplo e sem duplicatas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de código (Python/Jupyter Notebook), tabela de Huffman pré-gerada.",
                                  "tips": "Use chaves de string para símbolos e strings para códigos binários para facilitar depuração.",
                                  "learningObjective": "Compreender como representar eficientemente um mapeamento de símbolos para códigos em uma estrutura de dados acessível por hash.",
                                  "commonMistakes": "Confundir símbolos com códigos ou inverter pares chave-valor; esquecer símbolos de baixa frequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Receber e Validar o Símbolo de Entrada",
                                  "subSteps": [
                                    "Colete o símbolo de entrada da mensagem original ou simule uma entrada única.",
                                    "Verifique se o símbolo existe na tabela de códigos (chave válida).",
                                    "Trate casos de símbolo inválido com uma mensagem de erro ou código padrão.",
                                    "Converta o símbolo para o formato da chave (ex: minúscula se necessário).",
                                    "Registre o símbolo para fins de log ou depuração."
                                  ],
                                  "verification": "Teste com símbolos válidos e inválidos; confirme que validação retorna erro apropriado para ausentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Entrada de teste (string com símbolo), código da tabela do Step 1.",
                                  "tips": "Sempre sanitize a entrada para evitar erros de case sensitivity ou espaços extras.",
                                  "learningObjective": "Aprender a validar entradas contra uma estrutura de dados para prevenir falhas em runtime.",
                                  "commonMistakes": "Ignorar validação, levando a KeyError; não tratar símbolos não mapeados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a Consulta Eficiente no Hash Map",
                                  "subSteps": [
                                    "Acesse a tabela usando o símbolo como chave (ex: codigo = tabela[símbolo]).",
                                    "Simule ou execute a operação de hash lookup em O(1) tempo médio.",
                                    "Capture o código binário retornado.",
                                    "Meça o tempo de execução para múltiplas consultas.",
                                    "Repita para uma sequência de símbolos se simulando codificação completa."
                                  ],
                                  "verification": "Execute lookup e confirme que o código binário exato é retornado instantaneamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código implementado dos steps anteriores, timer para benchmark.",
                                  "tips": "Em Python, use dict.get() para evitar exceções; teste com 100 consultas para eficiência.",
                                  "learningObjective": "Dominar buscas em hash tables, destacando eficiência sobre buscas lineares.",
                                  "commonMistakes": "Usar loop linear em vez de hash lookup; overhead desnecessário em chaves compostas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Retornar e Verificar o Código Binário",
                                  "subSteps": [
                                    "Formate o código binário como string (ex: '00' para 'a').",
                                    "Compare com a tabela original para acurácia.",
                                    "Concatene se parte de uma mensagem maior.",
                                    "Gere um output legível (ex: 'Símbolo: a -> Código: 00').",
                                    "Salve ou exiba o resultado para inspeção."
                                  ],
                                  "verification": "O código retornado deve matching 100% com a tabela para o símbolo dado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Output da consulta do Step 3, tabela de referência.",
                                  "tips": "Use asserts ou testes unitários para automação da verificação.",
                                  "learningObjective": "Garantir integridade dos dados ao final do mapeamento.",
                                  "commonMistakes": "Bits invertidos ou prefixos errados; não decodificar para verificação cruzada."
                                }
                              ],
                              "practicalExample": "Dada a tabela de Huffman: {'a': '00', 'b': '10', 'c': '11', 'd': '01'}. Para o símbolo 'b', a consulta retorna '10' eficientemente via dict['b'], simulando compressão onde 'b' é substituído por sua representação compacta.",
                              "finalVerifications": [
                                "Código binário retornado matches exatamente o da tabela para o símbolo dado.",
                                "Tempo de consulta < 1ms para 1000 lookups simulados.",
                                "Nenhum erro para símbolos válidos; erro gracioso para inválidos.",
                                "Mapeamento funciona para todos símbolos da mensagem original.",
                                "Verificação cruzada: decodificar o código volta ao símbolo original.",
                                "Eficiência demonstrada vs. busca linear (benchmark)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% de acertos em consultas de teste.",
                                "Eficiência: O(1) tempo médio comprovado.",
                                "Robustez: Lida com entradas inválidas sem crash.",
                                "Clareza: Código bem documentado e legível.",
                                "Escalabilidade: Funciona para tabelas com 20+ símbolos.",
                                "Testes: Pelo menos 5 casos de teste automatizados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e árvores binárias para construção da tabela.",
                                "Linguagens: Estruturas de dados em programação (dicts em Python/JS).",
                                "Probabilidade: Frequências de símbolos influenciam códigos prefixos.",
                                "Engenharia: Otimização de storage em compressão de dados."
                              ],
                              "realWorldApplication": "Em compressores de arquivos como ZIP ou JPEG, consultar códigos Huffman acelera a codificação de textos/imagens, reduzindo tamanho em até 50% sem perda, usado em transmissão de dados na web e storage em cloud."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Mapear todos os caracteres de uma mensagem",
                            "description": "Para uma mensagem dada (ex: 'abacate'), listar sequencialmente o código binário de cada caractere usando a tabela, identificando repetições e comprimento parcial por símbolo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a mensagem e a tabela de códigos Huffman",
                                  "subSteps": [
                                    "Escreva a mensagem original em uma linha, destacando cada caractere (ex: 'a b a c a t e').",
                                    "Liste a tabela de códigos Huffman pronta, com frequência, caractere e código binário correspondente.",
                                    "Verifique se todos os caracteres da mensagem estão presentes na tabela.",
                                    "Anote o comprimento (número de bits) de cada código na tabela.",
                                    "Crie colunas para registro: Caractere | Código | Comprimento."
                                  ],
                                  "verification": "Confirme que a mensagem está escrita corretamente sem erros de digitação e que a tabela inclui todos os caracteres necessários.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, caneta, tabela de códigos Huffman impressa ou digital, mensagem de exemplo ('abacate').",
                                  "tips": "Use uma tabela organizada para facilitar a consulta rápida durante o mapeamento.",
                                  "learningObjective": "Entender a importância da preparação para garantir precisão no mapeamento.",
                                  "commonMistakes": "Ignorar caracteres maiúsculos/minúsculos ou espaços; assumir tabela incompleta sem verificar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear o código binário de cada caractere sequencialmente",
                                  "subSteps": [
                                    "Comece pelo primeiro caractere: localize na tabela e copie o código binário exatamente.",
                                    "Registre o código ao lado do caractere na linha da mensagem.",
                                    "Repita para o próximo caractere, mantendo a ordem sequencial.",
                                    "Anote o comprimento parcial do código para cada caractere.",
                                    "Marque visualmente caracteres repetidos (ex: sublinhe 'a' nas posições 1,3,5)."
                                  ],
                                  "verification": "Cada caractere tem seu código binário correto e comprimento anotado, sem pular nenhum.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela preparada do step 1, régua para alinhamento.",
                                  "tips": "Copie os códigos bit a bit para evitar erros de transcrição.",
                                  "learningObjective": "Desenvolver precisão na correspondência entre caracteres e códigos Huffman.",
                                  "commonMistakes": "Confundir códigos de caracteres semelhantes (ex: 't' e 'e'); inverter bits (0 por 1)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar repetições e analisar comprimentos parciais",
                                  "subSteps": [
                                    "Percorra a lista mapeada e destaque padrões de repetição (ex: código '0' para 'a' aparece 3 vezes).",
                                    "Some os comprimentos parciais de cada código para obter o comprimento total da mensagem codificada.",
                                    "Calcule a taxa de compressão comparando comprimento original (em caracteres) vs. codificado (em bits).",
                                    "Liste todas as repetições encontradas, com contagem e posições.",
                                    "Verifique se códigos prefixos não conflitam (propriedade de Huffman)."
                                  ],
                                  "verification": "Relatório de repetições completo e soma de comprimentos correta.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Lista mapeada do step 2, calculadora simples.",
                                  "tips": "Use cores diferentes para marcar repetições para visualização rápida.",
                                  "learningObjective": "Reconhecer benefícios da codificação Huffman via padrões e eficiência.",
                                  "commonMistakes": "Contar comprimentos errados; ignorar que Huffman otimiza repetições frequentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concatenar códigos e validar o mapeamento final",
                                  "subSteps": [
                                    "Junte todos os códigos binários em uma única string contínua (ex: 011001110100101).",
                                    "Conte o comprimento total da string binária e compare com a soma dos parciais.",
                                    "Simule decodificação: divida a string pelos comprimentos para recuperar a mensagem original.",
                                    "Documente o processo completo em um resumo: mensagem original, mapeamento, string final.",
                                    "Registre insights sobre eficiência (bits economizados)."
                                  ],
                                  "verification": "String binária concatenada permite recuperar a mensagem original sem ambiguidades.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Lista do step 3, software de texto para concatenação longa (opcional).",
                                  "tips": "Mantenha espaços entre códigos durante concatenação inicial para facilitar verificação.",
                                  "learningObjective": "Compreender o fluxo completo de codificação e sua reversibilidade.",
                                  "commonMistakes": "Erros de concatenação em sequências longas; não validar decodificação."
                                }
                              ],
                              "practicalExample": "Mensagem: 'abacate' (a:3x '0', b:1x '110', c:1x '111', t:1x '100', e:1x '101'). Mapeamento: a=0 (1bit), b=110 (3bits), a=0 (1bit), c=111 (3bits), a=0 (1bit), t=100 (3bits), e=101 (3bits). Repetições: '0' (3x), comprimentos parciais listados, total: 15 bits (vs. 7 chars x 8bits=56bits em ASCII). String final: '011001110100101'.",
                              "finalVerifications": [
                                "Todos os caracteres da mensagem foram mapeados com códigos corretos da tabela?",
                                "Repetições foram identificadas e contadas precisamente?",
                                "Comprimentos parciais e total batem com a soma?",
                                "Concatenação da string binária é exata sem bits extras ou faltantes?",
                                "Decodificação simulada recupera a mensagem original?",
                                "Eficiência de compressão foi calculada corretamente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na cópia de códigos binários (sem erros de bits).",
                                "Identificação completa de repetições e padrões.",
                                "Cálculo correto de comprimentos parciais e total.",
                                "Concatenação válida e verificável por decodificação.",
                                "Análise de eficiência com números exatos.",
                                "Documentação clara e organizada do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Construção de árvores binárias e cálculo de comprimentos.",
                                "Língua Portuguesa: Análise de frequência de letras em textos.",
                                "Probabilidade: Uso de frequências para otimização de códigos.",
                                "Física: Analogia com transmissão de sinais digitais em redes."
                              ],
                              "realWorldApplication": "Aplicado em compressão de dados sem perdas, como em arquivos ZIP, formatos de imagem JPEG (componente Huffman), transmissão de dados em redes (reduzindo largura de banda) e armazenamento eficiente em dispositivos móveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Implementar mapeamento em pseudocódigo",
                            "description": "Criar pseudocódigo para uma função que recebe uma mensagem e a tabela de códigos, retornando uma lista de códigos binários para cada posição da mensagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar requisitos e planejar estrutura da função",
                                  "subSteps": [
                                    "Identifique os parâmetros de entrada: mensagem (string) e tabela de códigos (dicionário char -> string binária).",
                                    "Defina o output: lista de strings binárias correspondentes a cada caractere da mensagem.",
                                    "Esboce o fluxo alto nível: inicializar lista vazia, iterar pela mensagem, consultar tabela e coletar códigos.",
                                    "Considere casos edge: mensagem vazia, caracteres não mapeados.",
                                    "Anote pseudocódigo skeleton em papel ou editor."
                                  ],
                                  "verification": "Verifique se o esboço cobre inputs, loop e output sem lacunas lógicas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples (ex: Notepad++).",
                                  "tips": "Use fluxogramas simples para visualizar o fluxo antes de codificar.",
                                  "learningObjective": "Compreender os requisitos funcionais e planejar logicamente a implementação.",
                                  "commonMistakes": "Ignorar casos edge como mensagem vazia ou chaves ausentes na tabela."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir assinatura da função e inicializar variáveis",
                                  "subSteps": [
                                    "Escreva a declaração da função: função mapearMensagem(mensagem, tabelaCodigos) retorna listaCódigos.",
                                    "Inicialize listaCódigos como array vazio.",
                                    "Adicione comentário explicando propósito da função.",
                                    "Verifique sintaxe básica do pseudocódigo (indentação consistente).",
                                    "Teste mentalmente com mensagem vazia: deve retornar lista vazia."
                                  ],
                                  "verification": "Execute simulação manual: para mensagem vazia, listaCódigos == [].",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de pseudocódigo ou bloco de notas.",
                                  "tips": "Use convenções claras como 'FUNÇÃO nome(parametros) RETORNA tipo'.",
                                  "learningObjective": "Dominar declaração de funções e inicialização em pseudocódigo.",
                                  "commonMistakes": "Esquecer de declarar o tipo de retorno ou inicializar a lista."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar loop de iteração e mapeamento",
                                  "subSteps": [
                                    "Inicie loop FOR cada caractere em mensagem (índice i de 0 a comprimento(mensagem)-1).",
                                    "Dentro do loop: código = tabelaCodigos[caractere].",
                                    "Adicione código à listaCódigos (append ou listaCódigos[i] = código).",
                                    "Adicione tratamento de erro: SE caractere NÃO em tabela, registre erro ou use código default.",
                                    "Feche o loop e adicione comentários inline."
                                  ],
                                  "verification": "Simule com mensagem 'AB': listaCódigos deve ter 2 elementos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto com numeração de linhas.",
                                  "tips": "Use pseudocódigo legível, evitando sintaxe de linguagem específica.",
                                  "learningObjective": "Implementar iterações e consultas em estruturas de dados.",
                                  "commonMistakes": "Usar índice errado no loop ou não tratar chaves inexistentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar função, retornar resultado e validar estrutura",
                                  "subSteps": [
                                    "Adicione RETORNA listaCódigos após o loop.",
                                    "Revise indentação e consistência em todo pseudocódigo.",
                                    "Adicione seção de testes inline com exemplo simples.",
                                    "Verifique comprimento da lista final == comprimento da mensagem.",
                                    "Limpe comentários desnecessários."
                                  ],
                                  "verification": "Pseudocódigo completo compila mentalmente sem erros lógicos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto.",
                                  "tips": "Leia o código em voz alta para detectar falhas lógicas.",
                                  "learningObjective": "Garantir completude e legibilidade do pseudocódigo.",
                                  "commonMistakes": "Esquecer o RETURN ou mismatch no tamanho da lista."
                                }
                              ],
                              "practicalExample": "Para mensagem 'ABAC' e tabela {A: '0', B: '10', C: '11'}, o pseudocódigo produz ['0', '10', '0', '11']. Teste: comprimento da lista = 4, todos códigos válidos da tabela.",
                              "finalVerifications": [
                                "Lista retornada tem exatamente o mesmo comprimento da mensagem de entrada.",
                                "Cada código na lista corresponde corretamente ao caractere na posição equivalente.",
                                "Função lida graciosamente com mensagem vazia (retorna []).",
                                "Pseudocódigo é legível com comentários e indentação adequada.",
                                "Casos edge como caractere ausente na tabela são tratados (ex: erro ou skip).",
                                "Simulação manual com exemplo confirma output correto."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: mapeamento exato sem erros de indexação.",
                                "Completude: todos elementos (inputs, loop, output) presentes.",
                                "Legibilidade: títulos, comentários e estrutura clara.",
                                "Tratamento de erros: considera casos inválidos.",
                                "Eficiência: O(n) onde n é comprimento da mensagem.",
                                "Conformidade com pseudocódigo padrão (sem sintaxe de PL específica)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Mapeamentos de funções e relações binárias.",
                                "Linguagens: Estruturas de controle em programação geral.",
                                "Algoritmos: Pré-processamento em compressão de dados."
                              ],
                              "realWorldApplication": "Em compressão de arquivos (ZIP, JPEG), onde mensagens são mapeadas para códigos Huffman eficientes antes da codificação final, reduzindo tamanho de dados em transmissão de rede ou armazenamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Concatenação para Sequência Binária Compacta",
                        "description": "Junção dos códigos binários individuais em uma única sequência contínua sem separadores, resultando na representação compacta da mensagem original.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Concatenar códigos em sequência única",
                            "description": "Dadas as listas de códigos de uma mensagem mapeada, unir todas as strings binárias em uma só, calculando o comprimento total em bits e comparando com codificação fixa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar os códigos Huffman para cada símbolo da mensagem",
                                  "subSteps": [
                                    "Escreva a mensagem original em uma linha.",
                                    "Consulte a tabela de códigos Huffman gerada anteriormente para cada símbolo único.",
                                    "Crie uma lista sequencial: para cada caractere da mensagem, anote seu código binário correspondente.",
                                    "Verifique se todos os símbolos da mensagem possuem códigos definidos.",
                                    "Ordene a lista exatamente na ordem de aparição na mensagem."
                                  ],
                                  "verification": "A lista de pares (símbolo, código binário) está completa, correta e na ordem exata da mensagem.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de códigos Huffman da mensagem"
                                  ],
                                  "tips": "Mantenha a ordem estrita da mensagem para evitar erros de sequência.",
                                  "learningObjective": "Mapear com precisão cada símbolo da mensagem aos seus códigos binários Huffman.",
                                  "commonMistakes": [
                                    "Confundir códigos de símbolos semelhantes",
                                    "Usar código errado para um símbolo",
                                    "Alterar a ordem da mensagem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Concatenar os códigos binários em uma única sequência",
                                  "subSteps": [
                                    "Inicie com uma string binária vazia.",
                                    "Para o primeiro símbolo, adicione seu código binário à string.",
                                    "Repita para cada símbolo subsequente, adicionando diretamente o código sem separadores ou espaços.",
                                    "Escreva a sequência final completa em uma linha contínua.",
                                    "Revise visualmente para garantir fluidez na junção."
                                  ],
                                  "verification": "A string resultante é uma sequência binária única e contínua, sem espaços, quebras ou separadores extras.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Lista de códigos do passo 1"
                                  ],
                                  "tips": "Pense como um fluxo de bits: cada código segue imediatamente o anterior.",
                                  "learningObjective": "Construir a representação binária compacta unificando todos os códigos.",
                                  "commonMistakes": [
                                    "Inserir espaços ou zeros extras entre códigos",
                                    "Invertir a ordem de concatenação",
                                    "Omitir um código"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o comprimento total da sequência binária em bits",
                                  "subSteps": [
                                    "Conte o número total de caracteres '0' e '1' na sequência concatenada.",
                                    "Some as contagens para obter o comprimento total em bits.",
                                    "Anote o valor exato e compare com a soma dos comprimentos individuais dos códigos.",
                                    "Confirme contando duas vezes para precisão.",
                                    "Registre o resultado em bits (não bytes)."
                                  ],
                                  "verification": "O comprimento calculado é igual ao tamanho da string binária e bate com a soma dos lengths dos códigos originais.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional",
                                    "Sequência binária do passo 2"
                                  ],
                                  "tips": "Use a função len() em Python ou similar para automação futura.",
                                  "learningObjective": "Determinar precisamente o tamanho em bits da codificação variável.",
                                  "commonMistakes": [
                                    "Contar bytes em vez de bits",
                                    "Incluir espaços na contagem",
                                    "Arredondar incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar o comprimento com codificação de comprimento fixo",
                                  "subSteps": [
                                    "Calcule o comprimento fixo: multiplique o número de símbolos da mensagem por 8 bits (ASCII padrão).",
                                    "Subtraia o comprimento Huffman do comprimento fixo para encontrar a economia em bits.",
                                    "Calcule a taxa de compressão: (comprimento Huffman / comprimento fixo) * 100%.",
                                    "Interprete o resultado: note se houve compressão e por quanto.",
                                    "Documente a comparação em uma tabela simples."
                                  ],
                                  "verification": "Os cálculos de fixed-length, diferença e taxa estão matematicamente corretos e bem documentados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Comprimento Huffman do passo 3",
                                    "Mensagem original"
                                  ],
                                  "tips": "Sempre use 8 bits por caractere para fixed-length em comparações padrão.",
                                  "learningObjective": "Avaliar quantitativamente a eficiência da codificação Huffman versus fixa.",
                                  "commonMistakes": [
                                    "Usar bits errados para fixed-length (ex: 7 em vez de 8)",
                                    "Esquecer de multiplicar pelo número de caracteres",
                                    "Calcular porcentagem invertida"
                                  ]
                                }
                              ],
                              "practicalExample": "Mensagem: 'abbc'. Códigos: a='0' (1 bit), b='10' (2 bits), c='11' (2 bits). Lista: a=0, b=10, b=10, c=11. Concatenada: '0101011' (7 bits). Fixed: 4 chars * 8 = 32 bits. Economia: 25 bits (78% compressão).",
                              "finalVerifications": [
                                "A sequência binária concatenada é contínua e corresponde à ordem da mensagem.",
                                "Comprimento total em bits é exato e igual à soma dos códigos individuais.",
                                "Cálculo de fixed-length usa corretamente 8 bits por símbolo.",
                                "Comparação mostra economia clara e cálculos precisos.",
                                "Nenhum código foi omitido ou adicionado indevidamente.",
                                "Sequência pode ser decodificada de volta à mensagem original."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% na concatenação dos códigos (sem erros de digitação ou ordem).",
                                "Cálculo correto do comprimento total em bits.",
                                "Comparação precisa com fixed-length, incluindo taxa de compressão.",
                                "Documentação clara com listas, sequência e cálculos mostrados.",
                                "Interpretação correta da eficiência da codificação.",
                                "Ausência de erros comuns identificados nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Contagem de elementos, soma de comprimentos e cálculo de porcentagens.",
                                "Redes de Computadores: Representação binária em transmissão de dados.",
                                "Teoria da Informação: Medição de entropia e eficiência de codificação.",
                                "Física: Transmissão de sinais digitais e otimização de largura de banda."
                              ],
                              "realWorldApplication": "Na compressão de arquivos (ex: ZIP, JPEG) e transmissão de dados em redes (ex: HTTP, streaming), onde sequências binárias compactas reduzem o uso de armazenamento e banda, economizando custos e acelerando transferências."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Verificar compacidade da codificação",
                            "description": "Calcular o comprimento da sequência binária Huffman e compará-lo com o comprimento usando codificação de comprimento fixo (ex: 8 bits por char ASCII), demonstrando a redução de tamanho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados da codificação de comprimento fixo",
                                  "subSteps": [
                                    "Identifique o número total de símbolos na mensagem original.",
                                    "Defina o comprimento fixo por símbolo (ex: 8 bits para ASCII).",
                                    "Calcule o comprimento total fixo: número de símbolos × bits por símbolo.",
                                    "Registre o resultado em bits.",
                                    "Verifique se todos os símbolos estão representados."
                                  ],
                                  "verification": "Confirme que o cálculo fixo é número de símbolos × 8 (ou bits definidos) sem erros aritméticos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, mensagem de exemplo, calculadora",
                                  "tips": "Use uma tabela para listar símbolos e contagens para evitar contagem dupla.",
                                  "learningObjective": "Entender e calcular o tamanho de dados com codificação uniforme.",
                                  "commonMistakes": "Esquecer símbolos não repetidos ou usar bits errados (ex: 7 em vez de 8 para ASCII)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e concatenar a sequência binária Huffman",
                                  "subSteps": [
                                    "Liste os códigos Huffman para cada símbolo na mensagem.",
                                    "Escreva a sequência binária concatenando os códigos na ordem da mensagem.",
                                    "Conte o número total de bits na sequência resultante.",
                                    "Marque divisões entre códigos para facilitar contagem.",
                                    "Confirme que a concatenação não tem espaços ou quebras."
                                  ],
                                  "verification": "A sequência binária decodifica de volta à mensagem original usando a tabela de códigos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de códigos Huffman prévia, papel quadriculado para binário, calculadora",
                                  "tips": "Escreva binários em grupos de 4 ou 8 bits para facilitar a contagem.",
                                  "learningObjective": "Construir e medir a representação compacta de uma mensagem com Huffman.",
                                  "commonMistakes": "Concatenar códigos fora de ordem ou contar bits com overlaps incorretos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular comprimentos individuais e totais",
                                  "subSteps": [
                                    "Some os comprimentos de código de cada ocorrência na mensagem para total Huffman.",
                                    "Compare com o total fixo calculado no passo 1.",
                                    "Calcule a taxa de compressão: (bits Huffman / bits fixos) × 100%.",
                                    "Calcule a economia: 100% - taxa de compressão.",
                                    "Registre ambos os valores com precisão decimal."
                                  ],
                                  "verification": "Os totais batem com contagem manual da sequência binária.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Resultados dos passos anteriores, calculadora",
                                  "tips": "Use fórmula: soma (frequência × comprimento de código) para eficiência.",
                                  "learningObjective": "Quantificar ganhos de eficiência da codificação variável.",
                                  "commonMistakes": "Confundir soma de comprimentos com contagem da sequência ou erros em percentuais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e demonstrar a compacidade",
                                  "subSteps": [
                                    "Compare numericamente os dois comprimentos e destaque a redução.",
                                    "Crie um gráfico ou tabela visual comparativa.",
                                    "Discuta por que a redução ocorre (símbolos frequentes com códigos curtos).",
                                    "Teste com variação na mensagem para observar mudanças.",
                                    "Conclua se a codificação é compacta (redução >20% geralmente)."
                                  ],
                                  "verification": "A análise mostra redução positiva e explica o motivo com base em frequências.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Resultados numéricos, software de planilha opcional (ex: Excel para gráfico)",
                                  "tips": "Sempre relacione redução às frequências para reforçar o conceito.",
                                  "learningObjective": "Interpretar resultados para validar eficiência algorítmica.",
                                  "commonMistakes": "Ignorar overheads como cabeçalho da árvore ou afirmar compressão sem dados."
                                }
                              ],
                              "practicalExample": "Mensagem: 'aabc' (frequências: a:2, b:1, c:1). Códigos Huffman: a=0 (1 bit), b=10 (2 bits), c=11 (2 bits). Sequência: 00 10 11 (6 bits total). Fixo: 4 símbolos × 8 bits = 32 bits. Redução: (6/32)=18.75% do tamanho original (81.25% economia).",
                              "finalVerifications": [
                                "Comprimento Huffman é menor ou igual ao fixo.",
                                "Cálculo da sequência binária é exato e decodificável.",
                                "Taxa de compressão calculada corretamente com percentual.",
                                "Economia demonstrada numericamente.",
                                "Explicação liga redução às frequências de símbolos.",
                                "Teste com mensagem alternativa confirma consistência."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de bits (erro <1%).",
                                "Sequência binária concatenada corretamente.",
                                "Comparação quantitativa clara com fórmulas.",
                                "Análise qualitativa menciona frequências.",
                                "Visualização (tabela/gráfico) incluída.",
                                "Conclusão reflete compacidade adequadamente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de percentuais e somas ponderadas.",
                                "Estatística: Análise de distribuições de frequências.",
                                "Física: Eficiência em transmissão de sinais digitais.",
                                "Economia: Otimização de recursos (espaço de armazenamento)."
                              ],
                              "realWorldApplication": "Usado em compressores como ZIP, GZIP e PNG para reduzir tamanho de arquivos de texto e dados, economizando banda em transmissões web e armazenamento em nuvem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Implementar função de codificação completa",
                            "description": "Desenvolver pseudocódigo para função que integra derivação de códigos, mapeamento e concatenação, recebendo mensagem e árvore, retornando a sequência binária compacta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar códigos binários a partir da árvore de Huffman",
                                  "subSteps": [
                                    "Implemente uma função recursiva para percorrer a árvore de Huffman, atribuindo '0' ao ramo esquerdo e '1' ao ramo direito.",
                                    "Inicie a derivação no nó raiz com código vazio, acumulando códigos nos nós folha (símbolos).",
                                    "Armazene os códigos em um dicionário ou mapa {símbolo: código_binário}.",
                                    "Trate casos de árvore vazia ou mensagem vazia retornando código vazio.",
                                    "Garanta que os códigos sejam prefix-free (sem prefixo de outro código)."
                                  ],
                                  "verification": "Execute a função de derivação em uma árvore de exemplo e verifique se os códigos atribuídos correspondem à travessia esperada (ex: 'a': '0', 'b': '10').",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Árvore de Huffman de exemplo em pseudocódigo",
                                    "Editor de texto ou IDE para pseudocódigo",
                                    "Diagrama da árvore impresso"
                                  ],
                                  "tips": "Use recursão para simplicidade; teste com árvores desbalanceadas para cobrir ramos profundos.",
                                  "learningObjective": "Compreender e implementar a atribuição de códigos prefix-free via travessia de árvore binária.",
                                  "commonMistakes": [
                                    "Atribuir códigos invertidos (esquerda '1', direita '0')",
                                    "Não tratar nós internos corretamente na recursão",
                                    "Gerar códigos não prefix-free"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear símbolos da mensagem para códigos derivados",
                                  "subSteps": [
                                    "Para cada símbolo na mensagem de entrada, busque seu código no mapa derivado.",
                                    "Crie uma lista ou string intermediária com os códigos binários correspondentes.",
                                    "Trate símbolos ausentes na árvore lançando erro ou ignorando (conforme especificação).",
                                    "Otimize a busca usando hashmap para O(1) acesso.",
                                    "Registre o mapeamento em log para depuração."
                                  ],
                                  "verification": "Para mensagem 'abbc', verifique se o mapeamento gera ['10','10','11','0'] assumindo códigos padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mapa de códigos do Step 1",
                                    "Mensagem de teste com frequências variadas",
                                    "Pseudocódigo de loop de iteração"
                                  ],
                                  "tips": "Use um loop for simples; valide comprimento da lista mapeada contra tamanho da mensagem.",
                                  "learningObjective": "Aplicar mapeamento eficiente de símbolos para sequências binárias usando estruturas de dados.",
                                  "commonMistakes": [
                                    "Índice off-by-one em strings",
                                    "Não converter símbolos para minúsculas se case-sensitive",
                                    "Ignorar símbolos não mapeados sem aviso"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Concatenar códigos mapeados em sequência binária compacta",
                                  "subSteps": [
                                    "Inicialize uma string vazia para a sequência final.",
                                    "Para cada código na lista mapeada, anexe-o à sequência sem separadores.",
                                    "Garanta que a concatenação preserve a ordem original da mensagem.",
                                    "Opcionalmente, adicione metadados como comprimento da mensagem para decodificação futura.",
                                    "Compacte removendo espaços ou quebras desnecessárias."
                                  ],
                                  "verification": "Para mapeamento ['0','10','11'], confirme saída '01011' sem gaps ou padding extra.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de códigos do Step 2",
                                    "Função de concatenação em pseudocódigo",
                                    "Exemplos de sequências compactas"
                                  ],
                                  "tips": "Use concatenação de strings eficiente (evite += em loops grandes); teste com mensagens longas.",
                                  "learningObjective": "Construir representação binária compacta otimizada para transmissão ou armazenamento.",
                                  "commonMistakes": [
                                    "Adicionar separadores entre códigos",
                                    "Invertendo ordem de concatenação",
                                    "Exceder comprimento esperado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar componentes em função completa e testar",
                                  "subSteps": [
                                    "Defina a função principal: encode(mensagem, arvore) chamando derivação, mapeamento e concatenação.",
                                    "Adicione tratamento de erros (ex: árvore inválida, mensagem nula).",
                                    "Implemente testes unitários para casos edge (mensagem vazia, árvore única folha).",
                                    "Meça eficiência: comprimento da saída vs. mensagem original.",
                                    "Documente a função com pseudocódigo comentado."
                                  ],
                                  "verification": "Chame encode('abbc', arvore) e confirme saída binária correta com comprimento reduzido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo completo dos steps anteriores",
                                    "Suite de testes com mensagens variadas",
                                    "Calculadora de entropia para validação"
                                  ],
                                  "tips": "Modularize funções auxiliares; use asserts para verificações automáticas.",
                                  "learningObjective": "Integrar subsistemas em uma função coesa com testes robustos.",
                                  "commonMistakes": [
                                    "Não propagar erros de steps anteriores",
                                    "Esquecer validação de entrada",
                                    "Testes insuficientes para edge cases"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada mensagem 'aabbcc' e árvore Huffman com códigos {'a':'0', 'b':'10', 'c':'11'}: 1. Derivação gera mapa correto. 2. Mapeamento: ['0','0','10','10','11','11']. 3. Concatenação: '0010101111'. Função retorna essa string binária compacta de 10 bits (vs 18 bits raw).",
                              "finalVerifications": [
                                "Códigos derivados são prefix-free e correspondem à árvore.",
                                "Sequência binária tem comprimento igual à soma dos códigos mapeados.",
                                "Decodificação reversa da saída recupera mensagem original.",
                                "Função lida com mensagem vazia retornando string vazia.",
                                "Eficiência: comprimento de saída ≤ entropia * len(mensagem).",
                                "Nenhum erro em símbolos não mapeados (lança exceção clara)."
                              ],
                              "assessmentCriteria": [
                                "Pseudocódigo claro, modular e bem comentado (20%)",
                                "Correção na derivação de códigos prefix-free (25%)",
                                "Eficiência no mapeamento e concatenação O(n) (20%)",
                                "Tratamento robusto de edge cases e erros (15%)",
                                "Testes unitários abrangentes com exemplos (10%)",
                                "Documentação de entrada/saída e complexidade (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Travessia de Árvores Binárias",
                                "Probabilidade: Cálculo de Entropia e Frequências para Otimização",
                                "Física: Compressão de Sinais em Telecomunicações Digitais",
                                "Engenharia: Algoritmos de Compressão em Sistemas Embarcados"
                              ],
                              "realWorldApplication": "Implementada em ferramentas de compressão como ZIP, GZIP ou bibliotecas de imagem (JPEG), reduzindo tamanho de arquivos para transmissão eficiente em redes, economizando banda e armazenamento em aplicações como streaming de vídeo ou backups em nuvem."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Processo de Decodificação",
                    "description": "Reconstrução da mensagem original a partir da sequência binária, percorrendo a árvore de Huffman.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Estrutura da Árvore de Huffman para Decodificação",
                        "description": "Compreender a árvore de Huffman como uma estrutura binária onde nós internos possuem filhos esquerdo (bit 0) e direito (bit 1), e folhas representam símbolos da mensagem original.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar nós raiz, internos e folhas",
                            "description": "Diferenciar o nó raiz (ponto de partida), nós internos (com dois filhos) e folhas (sem filhos, contendo símbolos) na árvore de Huffman construída para codificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de nós em árvores binárias",
                                  "subSteps": [
                                    "Defina nó raiz como o nó no topo da árvore, sem pai.",
                                    "Defina nós internos como nós que possuem exatamente dois filhos.",
                                    "Defina folhas como nós sem filhos, contendo os símbolos originais.",
                                    "Revise que a árvore de Huffman é binária e completa.",
                                    "Anote as diferenças entre cada tipo de nó em suas próprias palavras."
                                  ],
                                  "verification": "Escreva definições curtas para cada tipo de nó e compare com referências padrão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama genérico de árvore binária",
                                    "Folha de papel e caneta"
                                  ],
                                  "tips": "Use desenhos simples para visualizar; comece sempre pelo topo.",
                                  "learningObjective": "Diferenciar conceitualmente raiz, internos e folhas.",
                                  "commonMistakes": [
                                    "Confundir nós internos com folhas que têm um filho só (Huffman é estritamente binária)",
                                    "Ignorar que folhas têm símbolos e frequência zero nos nós internos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar e desenhar uma árvore de Huffman de exemplo",
                                  "subSteps": [
                                    "Escolha ou desenhe uma árvore de Huffman simples com 4 símbolos (ex: A, B, C, D).",
                                    "Marque o topo como raiz provisoriamente.",
                                    "Trace os ramos para identificar nós com dois filhos (internos).",
                                    "Circule os nós terminais sem filhos (folhas).",
                                    "Rotule cada nó com seu tipo."
                                  ],
                                  "verification": "Mostre o diagrama rotulado a um colega ou verifique se todos os nós estão classificados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel, caneta, exemplo de árvore de Huffman impressa ou digital"
                                  ],
                                  "tips": "Desenhe a árvore de cima para baixo para simular a hierarquia natural.",
                                  "learningObjective": "Visualizar a estrutura completa da árvore.",
                                  "commonMistakes": [
                                    "Desenhar árvores desbalanceadas incorretamente",
                                    "Esquecer de contar filhos precisamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o nó raiz e nós internos sistematicamente",
                                  "subSteps": [
                                    "Comece pelo nó superior: confirme que não tem pai → raiz.",
                                    "Navegue para baixo: para cada nó com dois filhos → interno.",
                                    "Ignore folhas durante esta contagem.",
                                    "Liste todos os nós internos por nível ou caminho.",
                                    "Conte o total e verifique se soma com a estrutura."
                                  ],
                                  "verification": "Crie uma tabela: nó ID, tipo, filhos (esquerda/direita).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama da árvore",
                                    "Planilha ou tabela em papel"
                                  ],
                                  "tips": "Use setas para rastrear pais e filhos; raiz é sempre única.",
                                  "learningObjective": "Localizar e classificar raiz e internos com precisão.",
                                  "commonMistakes": [
                                    "Confundir raiz com o primeiro interno",
                                    "Contar um filho como dois em ramificações erradas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar folhas e validar a árvore completa",
                                  "subSteps": [
                                    "Localize nós sem filhos: esses são folhas com símbolos.",
                                    "Confirme que cada folha tem um símbolo único.",
                                    "Verifique se todos os símbolos originais estão nas folhas.",
                                    "Conte folhas e confirme que correspondem ao número de símbolos.",
                                    "Revise toda a árvore para garantir classificação 100%."
                                  ],
                                  "verification": "Liste todas as folhas e seus símbolos; compare com input original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama rotulado",
                                    "Lista de símbolos originais"
                                  ],
                                  "tips": "Folhas estão sempre no final dos caminhos; símbolos só nelas.",
                                  "learningObjective": "Classificar folhas e validar a estrutura inteira.",
                                  "commonMistakes": [
                                    "Marcar interno como folha se tiver um filho invisível",
                                    "Perder folhas em ramos profundos."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma árvore de Huffman para símbolos A(4), B(3), C(2), D(1): Raiz (7) tem esquerda interno(5) [esq A(4), dir B(3)? Espera, construção padrão: folhas D(1),C(2),B(3),A(4). Nós: Raiz une (3+4=7), interno une C+D=3. Raiz: interno; Internos: nó(3); Folhas: A,B,C,D. Identifique: Raiz=nó7, Interno=nó3, Folhas=A,B,C,D.",
                              "finalVerifications": [
                                "Corretamente aponta o nó único no topo como raiz.",
                                "Lista todos os nós com exatamente dois filhos como internos.",
                                "Identifica todas as folhas pelos símbolos sem filhos.",
                                "Valida que número de folhas = número de símbolos originais.",
                                "Explica diferenças em uma árvore exemplo sem erros.",
                                "Navega pela árvore verbalmente classificando cada nó."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da raiz (100% obrigatório).",
                                "Correta contagem e listagem de nós internos (sem omissões).",
                                "Identificação completa de folhas com símbolos associados.",
                                "Uso correto de terminologia em explicações.",
                                "Aplicação em pelo menos duas árvores diferentes.",
                                "Ausência de confusão entre tipos de nós."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e árvores binárias.",
                                "Biologia: Árvores filogenéticas para classificação de espécies.",
                                "Linguística: Árvores sintáticas para análise de frases.",
                                "Engenharia: Estruturas hierárquicas em redes de computadores."
                              ],
                              "realWorldApplication": "Na compressão de dados como ZIP ou JPEG, identificar folhas na árvore de Huffman permite mapear códigos para símbolos originais durante a decodificação, essencial para recuperar arquivos compactados sem perda."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Mapear bits para direções na árvore",
                            "description": "Associar bit 0 ao filho esquerdo e bit 1 ao filho direito de um nó, simulando o percurso inicial da decodificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Convenção de Mapeamento de Bits",
                                  "subSteps": [
                                    "Revise a estrutura básica de uma árvore binária de Huffman, identificando nós internos e folhas.",
                                    "Memorize a convenção padrão: bit 0 direciona para o filho esquerdo, bit 1 para o filho direito.",
                                    "Explique em suas palavras por que essa convenção é arbitrária mas consistente para decodificação.",
                                    "Compare com convenções alternativas (ex: 1=esquerda) e discuta impactos na implementação.",
                                    "Anote exemplos de bits simples: '0' → esquerda, '1' → direita."
                                  ],
                                  "verification": "Escreva um resumo de 3 frases confirmando a convenção e dê um exemplo correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama de árvore binária simples, papel e caneta ou editor de texto.",
                                  "tips": "Use setas para visualizar: ← para 0, → para 1.",
                                  "learningObjective": "Compreender e internalizar a convenção de mapeamento bit-para-direção.",
                                  "commonMistakes": "Confundir 0 com direita ou inverter a convenção durante a prática."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir ou Visualizar a Árvore de Huffman",
                                  "subSteps": [
                                    "Obtenha ou construa uma árvore de Huffman de exemplo com 4-5 folhas (ex: símbolos A:0.4, B:0.3, C:0.2, D:0.1).",
                                    "Desenhe a árvore destacando rótulos de nós e folhas.",
                                    "Marque explicitamente os filhos esquerdo e direito de cada nó interno.",
                                    "Valide a árvore: verifique se é completa, prefix-free e reflete frequências.",
                                    "Rotule caminhos de raiz para folhas com sequências de 0s e 1s."
                                  ],
                                  "verification": "Desenhe a árvore e liste caminhos corretos para pelo menos 3 folhas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta de desenho (ex: Draw.io, papel), código de Huffman se disponível.",
                                  "tips": "Comece com frequências simples para evitar erros de construção.",
                                  "learningObjective": "Preparar uma representação visual precisa da árvore para navegação.",
                                  "commonMistakes": "Construir árvore desbalanceada ou ignorar propriedades de prefixo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Mapeamento de Bits Iniciais",
                                  "subSteps": [
                                    "Selecione um bitstream de exemplo (ex: 1010).",
                                    "Comece na raiz e aplique o primeiro bit: 1 → direita.",
                                    "Aplique o segundo bit do nó atual: 0 → esquerda.",
                                    "Continue para 3-4 bits, registrando o percurso e nó atual.",
                                    "Pare se atingir uma folha ou complete o bitstream."
                                  ],
                                  "verification": "Registre o percurso passo-a-passo e o nó final para o bitstream dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Bitstream impresso ou digital, árvore desenhada do Step 2.",
                                  "tips": "Use uma tabela: Coluna 1=Bit, Coluna 2=Nó atual, Coluna 3=Direção, Coluna 4=Nó próximo.",
                                  "learningObjective": "Executar mapeamento sequencial de bits para navegação na árvore.",
                                  "commonMistakes": "Pular nós ou aplicar bit errado ao nó incorreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Iterar o Percurso Completo",
                                  "subSteps": [
                                    "Continue a simulação até decodificar um símbolo (folha).",
                                    "Reset para raiz e teste múltiplos bitstreams (2-3 exemplos).",
                                    "Identifique quando o percurso falha (bitstream inválido).",
                                    "Compare decodificação manual com código de Huffman se disponível.",
                                    "Documente padrões observados no mapeamento."
                                  ],
                                  "verification": "Decodifique corretamente 3 bitstreams e explique um erro simulado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Múltiplos bitstreams de teste, simulador online de Huffman opcional.",
                                  "tips": "Teste edge cases: bitstream levando a folha rápida vs. longa.",
                                  "learningObjective": "Aplicar mapeamento iterativamente para decodificação inicial.",
                                  "commonMistakes": "Não resetar para raiz após decodificar um símbolo."
                                }
                              ],
                              "practicalExample": "Árvore de Huffman para 'A'(0.4), 'B'(0.3), 'C'(0.2), 'D'(0.1): Raiz → Esq:'AB'(0.7)/Dir:'CD'(0.3). Para bitstream '10': 1→'CD', 0→'C' (decodifica 'C').",
                              "finalVerifications": [
                                "Pode mapear qualquer sequência de 3 bits corretamente em uma árvore dada.",
                                "Explica a convenção 0/1 sem hesitação.",
                                "Identifica folhas corretamente em 100% dos testes.",
                                "Simula percurso sem inverter direções.",
                                "Valida prefix-free em exemplos simples.",
                                "Documenta percursos em tabela legível."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento: 0 erros em 5 testes.",
                                "Compreensão conceitual: explica convenção e propósito.",
                                "Detalhe nos substeps: todos substeps completos e lógicos.",
                                "Uso de verificações: aplica verificação em cada step.",
                                "Criatividade em exemplos: adapta a árvores próprias.",
                                "Tempo de execução: dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores binárias e grafos direcionados.",
                                "Probabilidade: Frequências guiam construção da árvore.",
                                "Algoritmos: Similar a traversais DFS/BFS.",
                                "Engenharia de Software: Compressão lossless em arquivos ZIP/JPEG."
                              ],
                              "realWorldApplication": "Em compressão de dados como arquivos ZIP ou transmissão de vídeo (H.264), onde bitstreams codificados com Huffman são decodificados mapeando bits para árvores, economizando banda e armazenamento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Construir árvore de exemplo manualmente",
                            "description": "Dado um conjunto de frequências de símbolos, montar a árvore de Huffman e rotulá-la com bits de navegação para preparar a decodificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e ordenar as frequências dos símbolos",
                                  "subSteps": [
                                    "Liste todos os símbolos e suas frequências em uma tabela.",
                                    "Ordene os símbolos em ordem crescente de frequência (menor para maior).",
                                    "Se houver empates, ordene alfabeticamente ou arbitrariamente, mas consistentemente.",
                                    "Registre a soma total das frequências para verificação futura."
                                  ],
                                  "verification": "Confirme que a lista está ordenada corretamente e a soma total bate com o dado inicial.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Folha de cálculo ou tabela impressa"
                                  ],
                                  "tips": "Use uma fila de prioridade mental ou liste em colunas para facilitar a ordenação dinâmica.",
                                  "learningObjective": "Entender a importância da ordenação por frequência na construção eficiente da árvore de Huffman.",
                                  "commonMistakes": [
                                    "Esquecer de ordenar após novas inserções",
                                    "Ignorar empates e causar inconsistências"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar os nós folha iniciais",
                                  "subSteps": [
                                    "Para cada símbolo, crie um nó folha com o símbolo e sua frequência.",
                                    "Desenhe cada nó como um círculo com o símbolo dentro e a frequência abaixo.",
                                    "Posicione os nós em uma fila horizontal, ordenados por frequência crescente."
                                  ],
                                  "verification": "Todos os símbolos têm nós folha criados e estão na fila ordenada.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel quadriculado para desenhar nós",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Use símbolos claros e escreva frequências legivelmente para evitar confusões posteriores.",
                                  "learningObjective": "Representar dados de entrada como nós folha prontos para combinação.",
                                  "commonMistakes": [
                                    "Confundir símbolos ou frequências nos nós",
                                    "Não alinhar corretamente para visualização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Combinar iterativamente os dois nós de menor frequência",
                                  "subSteps": [
                                    "Selecione os dois primeiros nós da fila (menores frequências).",
                                    "Crie um novo nó pai com frequência igual à soma das duas crianças.",
                                    "Desenhe linhas conectando as crianças ao pai (esquerda e direita arbitrariamente por enquanto).",
                                    "Insira o novo nó pai de volta na fila, mantendo a ordenação.",
                                    "Repita até restar apenas um nó."
                                  ],
                                  "verification": "A cada iteração, verifique se a soma da frequência do pai está correta e a fila permanece ordenada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Régua para linhas retas"
                                  ],
                                  "tips": "Mantenha espaço em branco ao redor para expandir a árvore; use setas para mostrar iterações.",
                                  "learningObjective": "Dominar o algoritmo bottom-up de construção da árvore de Huffman.",
                                  "commonMistakes": [
                                    "Combinar nós errados (não os menores)",
                                    "Erro na soma de frequências",
                                    "Perder a ordenação ao inserir o pai"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar a raiz e validar a estrutura da árvore",
                                  "subSteps": [
                                    "Confirme que resta apenas um nó: essa é a raiz.",
                                    "Verifique que todos os símbolos folhas estão conectados à raiz via caminhos únicos.",
                                    "Calcule a soma total na raiz e compare com a soma inicial.",
                                    "Desenhe a árvore completa de forma hierárquica.",
                                    "Conta o número de folhas e confirme igual ao número de símbolos."
                                  ],
                                  "verification": "A árvore tem uma única raiz com soma total correta e todos símbolos presentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel grande para árvore final"
                                  ],
                                  "tips": "Use cores diferentes para folhas e nós internos para clareza visual.",
                                  "learningObjective": "Reconhecer uma árvore de Huffman válida e completa.",
                                  "commonMistakes": [
                                    "Não conectar corretamente durante iterações",
                                    "Soma incorreta na raiz"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Rotular a árvore com bits de navegação para decodificação",
                                  "subSteps": [
                                    "Atribua '0' ao ramo esquerdo e '1' ao ramo direito de cada nó pai.",
                                    "Comece da raiz e propague os bits recursivamente para baixo até as folhas.",
                                    "Anote o código de cada folha (sequência de bits do caminho raiz-folha).",
                                    "Verifique que os códigos são prefix-free (nenhum é prefixo de outro)."
                                  ],
                                  "verification": "Todos os ramos têm bits rotulados e códigos das folhas são únicos e prefix-free.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Marcadores coloridos para bits (preto para 0, vermelho para 1)"
                                  ],
                                  "tips": "Navegue da raiz para cada folha verbalizando os bits para reforçar.",
                                  "learningObjective": "Preparar a árvore para navegação em decodificação usando bits como direções.",
                                  "commonMistakes": [
                                    "Inverter esquerda/direita inconsistentemente",
                                    "Códigos com prefixos comuns"
                                  ]
                                },
                                {
                                  "practicalExample": "Exemplo: Símbolos e frequências: a:5, b:2, c:1, d:1, e:1. 1. Ordenar: c1,d1,e1,b2,a5. 2. Nós folha criados. 3. Combinar c+d=X2; fila: e1,X2,b2,a5. Combinar e+X=Y3; fila: b2,Y3,a5. Combinar b+Y=Z5; fila: Z5,a5. Combinar Z+a=Raiz10. 4. Raiz válida, soma 10. 5. Rotular: assumindo esquerda=0,direita=1: c=00, d=01, e=10, b=11?, etc. (códigos exatos dependem da estrutura exata). Use para decodificar stream como 00 -> c."
                                },
                                "finalVerifications=[",
                                "A árvore possui exatamente uma raiz com soma total das frequências.",
                                "Todos os símbolos originais estão presentes como folhas.",
                                "Cada nó interno tem exatamente dois filhos.",
                                "Os caminhos da raiz às folhas têm comprimentos variados otimizados por frequência.",
                                "A estrutura permite navegação única por bits (prefix-free).",
                                "Somas de frequências propagam corretamente para cima."
                              ],
                              "assessmentCriteria": [
                                "Correção na ordenação e seleções de nós mínimos (100% preciso).",
                                "Cálculos de frequências somadas sem erros.",
                                "Estrutura da árvore binária completa e balanceada por frequência.",
                                "Rotulagem de bits consistente (0 esquerda, 1 direita).",
                                "Códigos resultantes prefix-free e eficientes.",
                                "Apresentação visual clara e legível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores binárias e grafos direcionados.",
                                "Estatística: Distribuições de frequências e entropia.",
                                "Física: Codificação de sinais em telecomunicações.",
                                "Lógica: Algoritmos greedy e prova de otimalidade."
                              ],
                              "realWorldApplication": "Em compressores de arquivos como ZIP ou GZIP, a árvore de Huffman decodifica streams de bits compactados em dados originais, economizando largura de banda em transmissões de internet e armazenamento de imagens/vídeos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Algoritmo de Percurso e Reconhecimento de Folhas",
                        "description": "Executar o percurso pela árvore seguindo a sequência binária, reconhecendo folhas para extrair símbolos e reiniciando da raiz após cada símbolo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Simular percurso bit a bit",
                            "description": "Dada uma sequência binária curta e a árvore, percorrer manualmente do nó raiz, avançando conforme os bits até alcançar uma folha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a árvore de Huffman e a sequência binária",
                                  "subSteps": [
                                    "Desenhe ou liste a árvore de Huffman completa, identificando nós internos, folhas e rótulos de bits (0 para esquerda, 1 para direita).",
                                    "Escreva a sequência binária curta fornecida (ex: 101).",
                                    "Marque o nó raiz claramente.",
                                    "Liste os símbolos associados às folhas para referência rápida.",
                                    "Verifique se a árvore está balanceada conforme o código Huffman."
                                  ],
                                  "verification": "Confirme que a árvore está desenhada corretamente e a sequência binária está anotada sem erros.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama da árvore de Huffman impresso ou digital",
                                    "Sequência binária fornecida"
                                  ],
                                  "tips": "Use cores diferentes para ramos 0 e 1 para visualização clara.",
                                  "learningObjective": "Entender a estrutura da árvore de Huffman e preparar inputs para decodificação.",
                                  "commonMistakes": [
                                    "Confundir esquerda/direita com 0/1",
                                    "Esquecer símbolos nas folhas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iniciar o percurso no nó raiz com o primeiro bit",
                                  "subSteps": [
                                    "Posicione um marcador (ex: dedo ou seta) no nó raiz.",
                                    "Leia o primeiro bit da sequência.",
                                    "Se bit = 0, mova para o filho esquerdo; se 1, para o direito.",
                                    "Anote o caminho atual (ex: Raiz -> Direita).",
                                    "Confirme se o nó atual é uma folha; se sim, pare; senão, continue."
                                  ],
                                  "verification": "O marcador está no nó correto após o primeiro bit, e o caminho está documentado.",
                                  "estimatedTime": "3 minutos",
                                  "materials": [
                                    "Árvore preparada",
                                    "Sequência binária",
                                    "Marcador visual"
                                  ],
                                  "tips": "Fale em voz alta o bit e a direção para reforçar o aprendizado.",
                                  "learningObjective": "Dominar o movimento inicial baseado no primeiro bit.",
                                  "commonMistakes": [
                                    "Inverter 0/esquerda e 1/direita",
                                    "Pular verificação de folha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar bits subsequentes até alcançar uma folha",
                                  "subSteps": [
                                    "Leia o próximo bit da sequência.",
                                    "Do nó atual, avance esquerda (0) ou direita (1).",
                                    "Atualize o caminho anotado.",
                                    "Repita até que o nó atual seja uma folha (sem filhos).",
                                    "Registre o número de bits consumidos."
                                  ],
                                  "verification": "Todos os bits foram processados corretamente e parou exatamente em uma folha.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Árvore e sequência do Step 1",
                                    "Anotações de caminho"
                                  ],
                                  "tips": "Cubra os bits restantes com a mão para focar no bit atual.",
                                  "learningObjective": "Executar percursos sequenciais precisos na árvore.",
                                  "commonMistakes": [
                                    "Continuar após folha",
                                    "Perder o nó atual no caminho"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar o símbolo decodificado e validar o percurso",
                                  "subSteps": [
                                    "Leia o símbolo no nó folha alcançado.",
                                    "Compare o caminho percorrido com o código prefixo da folha.",
                                    "Confirme que nenhum bit sobrou na sequência.",
                                    "Anote o resultado final: 'Sequência 101 decodifica para D'.",
                                    "Teste com um bit extra para ver erro de decodificação."
                                  ],
                                  "verification": "Símbolo correto identificado e percurso validado sem sobras.",
                                  "estimatedTime": "4 minutos",
                                  "materials": [
                                    "Resultado dos steps anteriores",
                                    "Tabela de códigos Huffman"
                                  ],
                                  "tips": "Sempre valide prefixo para garantir unicidade.",
                                  "learningObjective": "Concluir decodificação e validar completude.",
                                  "commonMistakes": [
                                    "Ignorar sobras de bits",
                                    "Confundir símbolos semelhantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Árvore Huffman: Raiz --0--> A (folha), --1--> NóX; NóX --0--> B (folha), --1--> NóY; NóY --0--> C (folha), --1--> D (folha). Sequência: 101. Percurso: Raiz -1> NóX -0> B? Não: 1 (direita NóX), 0 (esquerda B? Espera: para 101: 1->NóX, 0->B (mas sequência 101 tem 3 bits: 1->NóX, 0->B folha? B é 10, mas 101: após 10 em B, sobra 1 inválido? Exemplo correto: Sequência 110: 1->NóX, 1->NóY, 0->C. Resultado: C.",
                              "finalVerifications": [
                                "Percurso para todos os bits sem sobras ou faltas.",
                                "Parada exata em uma folha com símbolo correto.",
                                "Caminho anotado corresponde ao código prefixo da folha.",
                                "Nenhuma inversão de 0/1 durante o percurso.",
                                "Validação manual do percurso reproduz o mesmo resultado."
                              ],
                              "assessmentCriteria": [
                                "Precisão no percurso bit a bit (100% correto).",
                                "Identificação correta do símbolo final.",
                                "Documentação clara do caminho e decisões.",
                                "Tempo de execução dentro do estimado.",
                                "Explicação verbal do processo sem hesitações.",
                                "Detecção de erros em sequências inválidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores binárias e grafos direcionados.",
                                "Probabilidade: Frequências em códigos Huffman.",
                                "Física: Representação binária em sinais digitais.",
                                "Lógica: Raciocínio sequencial e decisões condicionais."
                              ],
                              "realWorldApplication": "Em compressão de arquivos ZIP ou JPEG, decodifica símbolos de texto/imagem percorrendo árvores Huffman bit a bit para reconstruir dados originais eficientemente, economizando banda em streaming e armazenamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Detectar e extrair símbolo em folha",
                            "description": "Ao atingir um nó folha durante o percurso, registrar o símbolo associado e retornar ao nó raiz para continuar com o próximo bit.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Nós Folhas na Árvore de Huffman",
                                  "subSteps": [
                                    "Revise a estrutura da árvore de Huffman: raiz no topo, nós internos com ramos 0 (esquerda) e 1 (direita), folhas no final.",
                                    "Identifique características de nós folhas: não possuem filhos, associadas diretamente a um símbolo (ex: caractere ou token).",
                                    "Compare com nós internos: possuem dois filhos e representam pontos de decisão baseados em bits.",
                                    "Desenhe uma árvore de Huffman simples com 3-4 folhas e rotule cada nó.",
                                    "Liste símbolos associados apenas às folhas, confirmando ausência em nós internos."
                                  ],
                                  "verification": "Desenhe uma árvore de Huffman e circule corretamente todos os nós folhas, listando seus símbolos.",
                                  "estimatedTime": "20 minutes",
                                  "materials": "Papel, lápis, exemplo de árvore de Huffman impressa ou digital.",
                                  "tips": "Lembre-se: folhas são os 'fins da linha' onde os símbolos residem.",
                                  "learningObjective": "Diferenciar precisamente nós folhas de nós internos na árvore de Huffman.",
                                  "commonMistakes": "Confundir nós de profundidade variável como folhas sem verificar ausência de filhos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Percurso e Detectar Chegada a Nó Folha",
                                  "subSteps": [
                                    "Inicie no nó raiz com o primeiro bit da sequência de entrada.",
                                    "Siga o ramo: vá à esquerda para bit 0, direita para bit 1, atualizando posição atual.",
                                    "Em cada passo, verifique se o nó atual é folha (sem filhos).",
                                    "Pare o percurso quando detectar folha e anote o bit atual usado.",
                                    "Repita com sequência de bits de teste curta (ex: 010)."
                                  ],
                                  "verification": "Simule percurso em uma árvore dada e identifique o passo exato de detecção da folha.",
                                  "estimatedTime": "25 minutes",
                                  "materials": "Árvore de Huffman diagramada, sequência de bits de teste, simulador online opcional.",
                                  "tips": "Mantenha um 'ponteiro' mental ou desenhado rastreando o caminho do raiz à folha.",
                                  "learningObjective": "Detectar chegada a nó folha durante percurso bit-a-bit a partir da raiz.",
                                  "commonMistakes": "Continuar percorrendo após folha ou iniciar percurso sem resetar para raiz."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair Símbolo da Folha e Registrar",
                                  "subSteps": [
                                    "Ao detectar folha, acesse o símbolo armazenado nela (ex: caractere 'A').",
                                    "Registre o símbolo em uma lista ou string de saída decodificada.",
                                    "Anote o número de bits consumidos até essa folha.",
                                    "Confirme que o símbolo corresponde ao código prefixo correto.",
                                    "Teste com múltiplas folhas em sequência curta."
                                  ],
                                  "verification": "Extraia e liste símbolos de uma sequência de 8-10 bits, matching saída esperada.",
                                  "estimatedTime": "20 minutes",
                                  "materials": "Mesma árvore e bits, papel para registrar saída.",
                                  "tips": "Pense no símbolo como 'prêmio' ao final do caminho válido.",
                                  "learningObjective": "Extrair e registrar corretamente o símbolo de uma folha detectada.",
                                  "commonMistakes": "Extrair símbolo de nó interno ou ignorar registro após detecção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Retornar ao Nó Raiz para Próximo Bit",
                                  "subSteps": [
                                    "Após registrar símbolo, reset o ponteiro para o nó raiz imediatamente.",
                                    "Avance para o próximo bit não consumido na sequência de entrada.",
                                    "Inicie novo percurso do raiz com esse bit.",
                                    "Repita ciclo até fim da sequência de bits.",
                                    "Valide decodificação completa comparando com texto original."
                                  ],
                                  "verification": "Decodifique sequência completa (ex: 0110) produzindo saída correta com resets.",
                                  "estimatedTime": "25 minutes",
                                  "materials": "Árvore, sequência longa de bits, calculadora para contar bits.",
                                  "tips": "Sempre reset: cada símbolo é independente, raiz é o 'home base'.",
                                  "learningObjective": "Implementar reset ao raiz para processar bits subsequentes corretamente.",
                                  "commonMistakes": "Permanecer na folha ou ramificar incorretamente sem reset."
                                }
                              ],
                              "practicalExample": "Árvore de Huffman: Raiz --0--> A (folha), --1--> Interno --0--> B (folha), --1--> C (folha). Sequência de bits: 0 1 0. Percurso: Bit0: raiz->A (folha), extrair 'A', reset raiz. Bit1: raiz->interno. Bit0: interno->B (folha), extrair 'B'. Saída: 'AB'.",
                              "finalVerifications": [
                                "Identifica corretamente todas as folhas em uma árvore dada.",
                                "Simula percurso bit-a-bit até detecção de folha sem erros.",
                                "Extrai e registra símbolos matching códigos prefixo.",
                                "Reseta ao raiz após cada extração para próximo bit.",
                                "Decodifica sequência completa de 16 bits com 100% acurácia.",
                                "Explica verbalmente o ciclo de detecção-extração-reset."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de folhas: 100% em 5 árvores teste.",
                                "Correta extração de símbolos em simulações manuais.",
                                "Implementação correta de reset ao raiz em pseudocódigo.",
                                "Tempo de decodificação manual < 2 min para 20 bits.",
                                "Ausência de erros comuns como overflow de percurso.",
                                "Capacidade de debugar falhas em decodificações erradas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de árvores binárias e grafos.",
                                "Probabilidade: Códigos prefixo e frequências de símbolos.",
                                "Engenharia de Software: Algoritmos recursivos e iteração.",
                                "Física: Transmissão de dados em canais binários."
                              ],
                              "realWorldApplication": "Em compressão de dados lossless como GZIP ou JPEG, onde árvores de Huffman decodificam streams de bits compactados em texto ou imagem original, economizando banda em redes e armazenamento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Tratar reinício após cada símbolo",
                            "description": "Garantir que após extrair um símbolo de uma folha, o ponteiro retorne à raiz para processar o bit subsequente da sequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Ciclo Básico de Decodificação de Huffman",
                                  "subSteps": [
                                    "Revise a estrutura da árvore de Huffman: raiz, nós internos e folhas com símbolos.",
                                    "Simule o percurso de bits da raiz até uma folha usando uma sequência de bits curta (ex: 01).",
                                    "Identifique que cada símbolo completo termina em uma folha.",
                                    "Anote que o próximo bit deve iniciar novamente da raiz, não da folha anterior.",
                                    "Desenhe um diagrama mostrando raiz -> folha1 -> reset raiz -> folha2."
                                  ],
                                  "verification": "Explique verbalmente ou desenhe o ciclo raiz-folha-raiz para uma sequência de 4 bits.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de árvore Huffman impresso ou digital",
                                    "Papel e caneta para desenhos",
                                    "Sequência de bits de exemplo"
                                  ],
                                  "tips": "Pense no ponteiro como um 'GPS' que sempre volta ao ponto de partida após entregar um pacote.",
                                  "learningObjective": "Entender que a decodificação é um processo cíclico que requer reinício na raiz após cada símbolo.",
                                  "commonMistakes": [
                                    "Assumir percurso contínuo sem reset",
                                    "Confundir nós internos com folhas",
                                    "Ignorar o fim do percurso atual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Chegada à Folha e Extrair o Símbolo",
                                  "subSteps": [
                                    "Implemente uma condição no código para verificar se o nó atual é uma folha (ex: nó tem símbolo associado).",
                                    "Ao detectar folha, extraia o símbolo e adicione à saída decodificada.",
                                    "Registre o índice do último bit usado no percurso atual.",
                                    "Pausar o percurso atual antes de qualquer reinício.",
                                    "Teste com um percurso único: raiz -> bits -> folha, confirmando extração correta."
                                  ],
                                  "verification": "Execute código ou simulação para um bitstream simples e confirme que o símbolo é extraído corretamente na folha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (Python/JS)",
                                    "Árvore Huffman codificada como estrutura de dados",
                                    "Bitstream de teste: '0110'"
                                  ],
                                  "tips": "Use um flag booleano 'isLeaf' no nó para detecção rápida.",
                                  "learningObjective": "Implementar detecção precisa de folhas e extração de símbolos sem avançar bits extras.",
                                  "commonMistakes": [
                                    "Extrair símbolo de nó interno",
                                    "Avançar bit extra após folha",
                                    "Não pausar percurso atual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Reinício Explícito do Ponteiro para a Raiz",
                                  "subSteps": [
                                    "Após extração, defina o ponteiro atual explicitamente como a raiz da árvore.",
                                    "Atualize o índice do bit para o próximo bit não processado na sequência.",
                                    "Inclua isso em um loop while que verifica se há bits restantes.",
                                    "Adicione log ou print para rastrear: 'Símbolo X extraído, reset para raiz, próximo bit Y'.",
                                    "Teste reinício com sequência que requer múltiplos símbolos."
                                  ],
                                  "verification": "Simule ou rode código com sequência multi-símbolo e verifique logs mostrando reset após cada folha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código base do decodificador parcial",
                                    "Bitstream longo: '010110'",
                                    "Debugger ou console para logs"
                                  ],
                                  "tips": "Sempre reset ponteiro = root; bitIndex += comprimento_percurso; em uma linha atômica.",
                                  "learningObjective": "Garantir reinício correto do ponteiro raiz e avanço preciso do índice de bits.",
                                  "commonMistakes": [
                                    "Resetar para nó errado",
                                    "Não avançar índice de bits",
                                    "Loop infinito sem verificação de fim"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Testar o Loop Completo de Decodificação",
                                  "subSteps": [
                                    "Coloque detecção, extração e reinício dentro de um loop while (bits restantes > 0).",
                                    "Adicione condição de parada: fim da sequência ou símbolo especial de padding.",
                                    "Teste com sequência completa que produz múltiplos símbolos.",
                                    "Compare saída decodificada com original.",
                                    "Debugue casos edge: sequência exata, com padding, vazia."
                                  ],
                                  "verification": "Decodifique uma sequência completa e confirme 100% match com string original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código completo do decodificador",
                                    "Ferramenta de teste unitário",
                                    "Pares sequência-saída esperada"
                                  ],
                                  "tips": "Use assert ou testes automatizados para validar resets em cada iteração.",
                                  "learningObjective": "Construir um decodificador funcional que trata reinícios corretamente em loops.",
                                  "commonMistakes": [
                                    "Não lidar com fim prematuro",
                                    "Reset incorreto em último símbolo",
                                    "Overflow de índice de bits"
                                  ]
                                }
                              ],
                              "practicalExample": "Árvore Huffman: Raiz --0--> A (folha), --1--> Nó --0--> B (folha), --1--> C (folha). Bitstream: '010110' (B A C). Passos: 1. 01 -> B (folha, output 'B', reset raiz). 2. 0 -> A (folha, output 'BA', reset raiz). 3. 11 -> C (folha, output 'BAC', fim). Sem reset, erro: continuaria de C para bits inexistentes.",
                              "finalVerifications": [
                                "Simulação manual mostra reset raiz após cada folha.",
                                "Código logs reset corretamente para 3+ símbolos.",
                                "Decodificação de bitstream de 10+ bits matches 100%.",
                                "Índice de bits nunca excede comprimento da sequência.",
                                "Loop para sem erros em casos edge (padding, fim exato)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no reset: ponteiro sempre volta à raiz pós-folha (100%).",
                                "Gerenciamento de índice de bits: avanço exato por percurso.",
                                "Robustez do loop: lida com 0-N símbolos sem crash.",
                                "Eficiência: O(1) reset por símbolo.",
                                "Clareza do código: comentários explicam reinício."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (percursos em árvores binárias).",
                                "Programação: Estruturas de Controle (loops while com condições).",
                                "Engenharia de Software: Tratamento de Estados em Autômatos Finitos.",
                                "Física: Modelagem de Sinais Digitais (transmissão de bits)."
                              ],
                              "realWorldApplication": "Em compressores como ZIP ou PNG, garante decodificação precisa de arquivos compactos sem perda de dados durante transmissão de rede ou armazenamento, evitando corrupção de arquivos multimídia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.4",
                            "name": "Validar decodificação com exemplo completo",
                            "description": "Aplicar o percurso completo em uma sequência binária exemplo, verificando se a mensagem reconstruída corresponde à original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o exemplo de mensagem original e a árvore de Huffman correspondente",
                                  "subSteps": [
                                    "Escolha uma mensagem curta e representativa, como 'aab' (frequências: a=2, b=1).",
                                    "Construa a árvore de Huffman: combine os nós de menor frequência primeiro (b e um 'a' implícito, mas para 'aab': raiz divide em 'a' (esquerda, código 0) e subárvore direita (a=1 e b=1, código 10 para a, 11 para b).",
                                    "Desenhe a árvore claramente rotulando nós internos, folhas com símbolos e ramos com 0/1.",
                                    "Anote os códigos de Huffman para cada símbolo: a=0, a=10 (segundo a), b=11."
                                  ],
                                  "verification": "Verifique se a árvore está balanceada corretamente e os códigos prefix-free (nenhum é prefixo de outro).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis ou software de desenho como draw.io",
                                    "Tabela de frequências pré-calculada"
                                  ],
                                  "tips": "Use cores diferentes para ramos 0 e 1 para visualização clara.",
                                  "learningObjective": "Entender a relação entre frequências, árvore e códigos prefix-free.",
                                  "commonMistakes": "Esquecer de combinar nós de menor frequência primeiro ou criar códigos não prefix-free."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar a sequência binária codificada da mensagem original",
                                  "subSteps": [
                                    "Identifique a sequência de símbolos na mensagem 'aab'.",
                                    "Para cada símbolo, percorra da raiz à folha correspondente, registrando o caminho binário: primeiro 'a' = 0, segundo 'a' = 10, terceiro 'b' = 11.",
                                    "Concatene os códigos: 0 + 10 + 11 = 01011.",
                                    "Anote a mensagem original ao lado da binária para referência futura."
                                  ],
                                  "verification": "Confirme que a concatenação resulta em uma string binária exata sem ambiguidades.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Árvore de Huffman desenhada",
                                    "Papel para anotar binário"
                                  ],
                                  "tips": "Escreva os códigos lado a lado para evitar erros de transcrição.",
                                  "learningObjective": "Aplicar codificação para gerar bitstream compacto.",
                                  "commonMistakes": "Usar código errado para símbolos repetidos ou inverter ramos 0/1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a decodificação completa da sequência binária",
                                  "subSteps": [
                                    "Inicie na raiz da árvore com o primeiro bit da sequência '01011'.",
                                    "Percorra: bit 0 -> esquerda ('a'), reset para raiz; próximo bit 1 -> direita, próximo 0 -> esquerda ('a'), reset; próximo 1 -> direita, próximo 1 -> direita ('b').",
                                    "Registre cada símbolo reconhecido em uma folha: 'a' + 'a' + 'b'.",
                                    "Continue até consumir toda a sequência binária."
                                  ],
                                  "verification": "Garanta que todos os bits foram consumidos e nenhum sobrou ou faltou.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Sequência binária anotada",
                                    "Árvore de Huffman"
                                  ],
                                  "tips": "Use um marcador para riscar bits consumidos a cada símbolo.",
                                  "learningObjective": "Dominar o percurso raiz-folha e reset para decodificação lossless.",
                                  "commonMistakes": "Não resetar para raiz após folha ou parar prematuramente na sequência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a decodificação comparando mensagens",
                                  "subSteps": [
                                    "Escreva a mensagem reconstruída: 'aab'.",
                                    "Compare caractere por caractere com a original 'aab'.",
                                    "Verifique se há correspondência 100%: comprimento igual e símbolos idênticos.",
                                    "Se discrepância, identifique o bit ou percurso problemático e corrija."
                                  ],
                                  "verification": "Afirmação explícita: 'Mensagem reconstruída corresponde à original: Sim/Não'.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Mensagens original e reconstruída anotadas"
                                  ],
                                  "tips": "Use tabela de comparação para alinhar símbolos e binários.",
                                  "learningObjective": "Confirmar a propriedade lossless da codificação Huffman.",
                                  "commonMistakes": "Ignorar diferenças sutis como ordem de símbolos ou comprimento."
                                }
                              ],
                              "practicalExample": "Mensagem original: 'aab' (frequências a=2, b=1). Códigos: a=0 (primeiro), mas ajustado: na árvore padrão para 'aab', código a=0, b=11 (assumindo árvore esquerda a=0, direita sub a=10 b=11, mas para validação: binário 01011 decodifica como a (0), a (10), b (11). Reconstruída: 'aab' == original.",
                              "finalVerifications": [
                                "Sequência binária foi totalmente consumida sem sobras.",
                                "Cada percurso terminou em folha com símbolo correto.",
                                "Mensagem reconstruída tem mesmo comprimento da original.",
                                "Símbolos em posições idênticas.",
                                "Propriedade prefix-free preservada (sem ambiguidades).",
                                "Nenhum erro de percurso em ramos 0/1.",
                                "Validação lossless confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da árvore (códigos prefix-free).",
                                "Correção na geração da sequência binária.",
                                "Execução fiel do algoritmo de decodificação.",
                                "Análise comparativa completa e sem erros.",
                                "Clareza nas anotações e verificações.",
                                "Identificação de potenciais erros simulados.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de árvores binárias e grafos.",
                                "Estatística: Cálculo de frequências e entropia.",
                                "Lógica: Algoritmos de decisão e percursos recursivos.",
                                "Física: Transmissão de sinais digitais (bits 0/1).",
                                "Engenharia: Compressão de dados em sistemas embarcados."
                              ],
                              "realWorldApplication": "Em compressores de arquivos como ZIP ou JPEG, validar decodificação garante integridade de dados transmitidos em redes, evitando corrupção em streaming de vídeo ou armazenamento em nuvem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Implementação e Análise do Processo",
                        "description": "Implementar o algoritmo de decodificação de forma iterativa ou recursiva, analisando sua eficiência em relação à codificação.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Esboçar pseudocódigo iterativo",
                            "description": "Escrever pseudocódigo para decodificação usando um loop que processa bits, atualiza ponteiro na árvore e constrói a mensagem até o fim da sequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir variáveis iniciais e estrutura da árvore",
                                  "subSteps": [
                                    "Identifique os componentes necessários: árvore de Huffman (com nós internos e folhas contendo símbolos), sequência de bits como string ou array.",
                                    "Declare variáveis: currentNode inicializado como raiz da árvore, message como string vazia, bitIndex como 0.",
                                    "Especifique tipos: nó atual é um ponteiro para o nó da árvore, message é acumulador de caracteres decodificados.",
                                    "Desenhe um diagrama simples da árvore para visualização.",
                                    "Anote a condição de parada: bitIndex < comprimento da sequência de bits."
                                  ],
                                  "verification": "Verifique se todas as variáveis estão declaradas corretamente e se há um diagrama da árvore associado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta para diagrama, editor de texto para pseudocódigo inicial.",
                                  "tips": "Use nomes de variáveis descritivos como 'currentNode' e 'decodedMessage' para clareza.",
                                  "learningObjective": "Compreender e declarar o estado inicial necessário para a decodificação iterativa.",
                                  "commonMistakes": "Esquecer de inicializar currentNode na raiz ou confundir bits com caracteres."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar o loop principal iterativo",
                                  "subSteps": [
                                    "Inicie o loop com 'WHILE bitIndex < length(bits)' para processar até o fim da sequência.",
                                    "Dentro do loop, extraia o bit atual: bit = bits[bitIndex].",
                                    "Atualize o ponteiro: se bit == '0', currentNode = currentNode.leftChild; senão, currentNode = currentNode.rightChild.",
                                    "Adicione indentação para mostrar escopo do loop.",
                                    "Planeje o incremento: bitIndex = bitIndex + 1 no final do loop."
                                  ],
                                  "verification": "Simule o loop com 2-3 bits manualmente para garantir que o ponteiro se move corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de pseudocódigo, sequência de bits de exemplo curta.",
                                  "tips": "Teste o loop com papel antes de codificar para evitar loops infinitos.",
                                  "learningObjective": "Construir a lógica iterativa principal para navegação na árvore bit a bit.",
                                  "commonMistakes": "Incrementar bitIndex antes de processar o bit ou usar loop for em vez de while para flexibilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar detecção de folha e construção da mensagem",
                                  "subSteps": [
                                    "Após mover o ponteiro, verifique 'IF currentNode é folha (ou isLeaf == true)'.",
                                    "Se verdadeiro, anexe o símbolo: decodedMessage = decodedMessage + currentNode.symbol.",
                                    "Reset o ponteiro: currentNode = root.",
                                    "Integre isso logo após a atualização do ponteiro no loop.",
                                    "Considere tratamento de erros: se nó nulo, pare ou reporte."
                                  ],
                                  "verification": "Execute simulação passo a passo com uma árvore completa e bits correspondentes; verifique se mensagem é construída corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama da árvore de exemplo, calculadora para rastrear bitIndex.",
                                  "tips": "Sempre reset para raiz após folha para reiniciar a decodificação do próximo símbolo.",
                                  "learningObjective": "Gerenciar detecção de símbolos e acumulação da mensagem decodificada.",
                                  "commonMistakes": "Não resetar para raiz, causando decodificação incorreta, ou append sem verificar se é folha."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar o pseudocódigo com saída e validações",
                                  "subSteps": [
                                    "Adicione incremento de bitIndex após todas as operações internas.",
                                    "Fora do loop, retorne ou imprima decodedMessage.",
                                    "Adicione comentários explicando cada seção.",
                                    "Teste edge cases: sequência vazia, árvore com um nó, bits exatos para múltiplos símbolos.",
                                    "Formate o pseudocódigo com blocos claros (BEGIN/END ou indentação)."
                                  ],
                                  "verification": "Pseudocódigo completo simula decodificação perfeita de um exemplo conhecido sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ferramenta de simulação manual ou debugger simples.",
                                  "tips": "Use pseudocódigo padronizado (ex: Pascal-like) para portabilidade.",
                                  "learningObjective": "Completar e validar o pseudocódigo iterativo funcional.",
                                  "commonMistakes": "Loop não termina (faltar incremento), ou mensagem não é retornada."
                                }
                              ],
                              "practicalExample": "Árvore: Raiz com esquerda='A' (folha), direita=nó com esquerda='B' (folha), direita='C' (folha). Bits: '010101'. Decodificação iterativa: bit0='0'->A (reset), bit1='1'->direita, bit2='0'->B (reset), bit3='1'->direita, bit4='0'->B (reset), bit5='1'->direita (fim). Mensagem: 'ABB'. Pseudocódigo produz 'ABB'.",
                              "finalVerifications": [
                                "Todas as variáveis são inicializadas corretamente antes do loop.",
                                "O loop processa cada bit exatamente uma vez até o fim da sequência.",
                                "Ponteiro reseta para raiz após cada símbolo decodificado.",
                                "Mensagem é construída appendando símbolos de folhas apenas.",
                                "Simulação com exemplo prático produz mensagem correta.",
                                "Pseudocódigo lida com edge case de sequência vazia (mensagem vazia)."
                              ],
                              "assessmentCriteria": [
                                "Clareza e legibilidade do pseudocódigo (indentação, comentários).",
                                "Correção lógica: navegação bit a bit e detecção de folhas.",
                                "Manipulação correta de ponteiro (movimento e reset).",
                                "Acumulação precisa da mensagem sem sobras ou faltas.",
                                "Tratamento implícito de fim de sequência sem erros.",
                                "Uso apropriado de estruturas de controle (while, if)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores binárias e travessia (pré-order similar).",
                                "Lógica e Filosofia: Raciocínio sequencial e estados finitos.",
                                "Inglês: Redação técnica clara em pseudocódigo padronizado.",
                                "Engenharia: Otimização de espaço em algoritmos iterativos vs recursivos."
                              ],
                              "realWorldApplication": "Usado em descompressão de arquivos ZIP, JPEG e MP3, onde árvores de Huffman decodificam bits compactados em dados originais de forma eficiente, economizando banda e armazenamento em streaming e backups."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Comparar abordagens recursiva e iterativa",
                            "description": "Analisar recursão (chamada para subpercurso) versus iteração (loop com ponteiro), destacando pilha de chamadas e eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Decodificação de Huffman",
                                  "subSteps": [
                                    "Construa ou carregue uma árvore de Huffman de exemplo com 4-6 símbolos e códigos binários associados.",
                                    "Explique o processo de decodificação: iniciar na raiz e seguir bits (0=esquerda, 1=direita) até uma folha.",
                                    "Identifique pontos onde recursão ou iteração podem ser aplicadas: chamadas em subárvores vs loop no caminho.",
                                    "Anote a sequência de bits de uma string codificada exemplo, como '101100' para uma árvore simples.",
                                    "Desenhe a pilha de execução manual para um percurso simples."
                                  ],
                                  "verification": "Crie um diagrama da árvore e simule decodificação manual de uma string de 10 bits, listando símbolos decodificados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta de desenho (Draw.io), código fonte de árvore Huffman em Python/Java.",
                                  "tips": "Use uma árvore balanceada inicialmente para simplicidade; foque em folhas como terminais.",
                                  "learningObjective": "Compreender o fluxo básico de decodificação para preparar comparação de abordagens.",
                                  "commonMistakes": "Confundir codificação com decodificação; ignorar que decodificação consome bits sequencialmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Analisar Abordagem Recursiva",
                                  "subSteps": [
                                    "Escreva função recursiva: recebe nó atual e string de bits restante; se folha, output símbolo e recursa no resto.",
                                    "Se nó interno, consuma primeiro bit: recursa esquerda se '0', direita se '1'.",
                                    "Teste com string exemplo, imprimindo pilha de chamadas usando print/debug.",
                                    "Meça profundidade máxima da recursão (altura da árvore) e conte chamadas.",
                                    "Observe estouro de pilha em árvores profundas (teste com profundidade 20+)."
                                  ],
                                  "verification": "Execute código recursivo em string de 20 bits; liste símbolos e profundidade máxima da pilha.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de código (VS Code), Python/Java, árvore Huffman serializada (JSON ou classe Node).",
                                  "tips": "Use parâmetros mutáveis para bits restantes (fatiar string); adicione logs para visualizar pilha.",
                                  "learningObjective": "Dominar recursão como chamadas em subpercursos, visualizando pilha de execução.",
                                  "commonMistakes": "Não avançar índice de bits corretamente; recursão infinita sem base case em folhas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Analisar Abordagem Iterativa",
                                  "subSteps": [
                                    "Use loop com ponteiro atual (nó raiz) e índice de bits i=0.",
                                    "Enquanto não folha e i < len(bits): avance ponteiro baseado em bits[i] (esquerda/direita), i++.",
                                    "Quando folha, output símbolo e reset ponteiro para raiz, continue até i == len(bits).",
                                    "Otimize com stack para simular recursão, empilhando nós e bits.",
                                    "Meça iterações e compare com recursão em termos de memória."
                                  ],
                                  "verification": "Execute código iterativo na mesma string; confirme saída idêntica à recursiva sem recursão profunda.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Mesmo editor e árvore; profiler simples para contar loops.",
                                  "tips": "Prefira versão com ponteiro simples para eficiência; stack para debug visual.",
                                  "learningObjective": "Implementar iteração com loop e ponteiro, evitando pilha de chamadas.",
                                  "commonMistakes": "Não resetar ponteiro após folha; off-by-one em índice de bits."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Abordagens: Pilha, Eficiência e Casos de Uso",
                                  "subSteps": [
                                    "Compare pilha: recursiva usa stack implícito (até altura árvore), iterativa usa stack explícito ou constante.",
                                    "Meça tempo/memória: teste com árvores profundas (1000 nós) e strings longas (10k bits).",
                                    "Analise Big-O: ambas O(n) tempo, recursiva O(h) espaço extra (h=altura).",
                                    "Discuta trade-offs: recursão elegante para árvores balanceadas, iteração para profundas/evitar stack overflow.",
                                    "Crie tabela comparativa: prós/contras, eficiência em cenários reais."
                                  ],
                                  "verification": "Gere relatório com métricas (tempo, memória) para 3 tamanhos de input; explique quando usar cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código das Steps 2-3, ferramenta de profiling (timeit em Python), planilha para tabela.",
                                  "tips": "Use sys.setrecursionlimit() para testes recursivos; foque em worst-case (árvores desbalanceadas).",
                                  "learningObjective": "Analisar diferenças em pilha de chamadas, eficiência e aplicabilidade.",
                                  "commonMistakes": "Ignorar overhead de chamadas de função na recursão; assumir sempre iterativa melhor."
                                }
                              ],
                              "practicalExample": "Árvore Huffman: símbolos A(0), B(10), C(11). String codificada '101100' decodifica para B C A. Recursiva: chama raiz->direita(B)->resto('1100')... Iterativa: loop raiz (1=direita=B), reset, raiz(1=direita=C), reset, raiz(0=esquerda=A).",
                              "finalVerifications": [
                                "Explicar verbalmente pilha de chamadas recursiva vs loop iterativo.",
                                "Implementar ambas e decodificar string de 50 bits corretamente.",
                                "Identificar stack overflow em recursão profunda e corrigi-lo com iteração.",
                                "Criar tabela comparativa com prós/contras precisos.",
                                "Medir e discutir eficiência em árvore desbalanceada de altura 15."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação: saída correta para inputs variados (90%+).",
                                "Análise de pilha: descrição correta de uso de memória recursiva vs iterativa.",
                                "Eficiência quantificada: métricas de tempo/espaço com pelo menos 3 testes.",
                                "Trade-offs identificados: casos onde uma supera a outra.",
                                "Clareza na comparação: tabela ou relatório estruturado e completo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de árvores binárias e complexidade O(h).",
                                "Física: Compressão de dados em sinais digitais (telecomunicações).",
                                "Engenharia de Software: Escolha de algoritmos por restrições de hardware (stack size).",
                                "Estatística: Entropia e probabilidades em codificação Huffman."
                              ],
                              "realWorldApplication": "Em compressores como ZIP, GZIP ou JPEG, decodificação iterativa é preferida para eficiência em arquivos grandes, evitando stack overflow em árvores profundas de símbolos frequentes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.6",
                    "name": "Análise de Complexidade",
                    "description": "Avaliação do tempo e espaço computacional do algoritmo de Huffman, O(n log n) para n símbolos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.6.1",
                        "name": "Análise de Complexidade Temporal",
                        "description": "Avaliação detalhada do tempo computacional gasto em cada fase do algoritmo de codificação de Huffman, incluindo inicialização, construção da fila de prioridade e iterações de merge, resultando na complexidade total O(n log n) para n símbolos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.1.1",
                            "name": "Determinar a complexidade da inicialização dos nós folha",
                            "description": "Identificar e calcular o custo temporal para criar os n nós folha, cada um com sua frequência, resultando em complexidade O(n), considerando alocação de memória e atribuições básicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura do algoritmo de Huffman e identificar os nós folha",
                                  "subSteps": [
                                    "Estude o pseudocódigo do algoritmo de Huffman, focando na fase de inicialização.",
                                    "Identifique que os nós folha representam os símbolos com suas frequências.",
                                    "Liste os n símbolos e suas frequências de entrada.",
                                    "Desenhe um diagrama simples mostrando os n nós folha iniciais.",
                                    "Confirme que há exatamente n nós folha no início."
                                  ],
                                  "verification": "Crie um diagrama ou lista confirmando n nós folha com frequências corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo de Huffman",
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Comece sempre pelo input: frequência de cada símbolo.",
                                  "learningObjective": "Compreender o papel dos nós folha na inicialização do Huffman.",
                                  "commonMistakes": [
                                    "Confundir nós folha com nós internos",
                                    "Ignorar que n é o número de símbolos distintos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar as operações básicas para criar um único nó folha",
                                  "subSteps": [
                                    "Identifique as operações: alocação de memória para o nó (new Node()), atribuição de frequência, atribuição de símbolo.",
                                    "Classifique cada operação como O(1): alocação é constante, atribuições são constantes.",
                                    "Escreva pseudocódigo para criar um nó: Node* leaf = new Node(); leaf->freq = f; leaf->symbol = s;",
                                    "Conte o número exato de operações primitivas (atribuições, chamadas de função).",
                                    "Repita para um exemplo concreto com 2-3 símbolos."
                                  ],
                                  "verification": "Escreva e execute pseudocódigo criando um nó folha, medindo operações manuais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE simples",
                                    "Documentação de estruturas de nós em árvores"
                                  ],
                                  "tips": "Considere apenas operações de tempo constante; ignore cache ou otimizações.",
                                  "learningObjective": "Decompor a criação de um nó folha em operações O(1).",
                                  "commonMistakes": [
                                    "Contar alocação como O(n)",
                                    "Esquecer atribuições de ponteiros ou campos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o custo temporal para criar todos os n nós folha",
                                  "subSteps": [
                                    "Some o custo por nó: se cada nó custa c operações O(1), total por nó é O(1).",
                                    "Multiplique por n: custo total = n * O(1) = O(n).",
                                    "Crie uma tabela: colunas para nó i, operações, custo acumulado.",
                                    "Verifique dependências: criação é sequencial ou paralela? (Sequencial, mas ainda O(n)).",
                                    "Compare com outras inicializações em algoritmos semelhantes."
                                  ],
                                  "verification": "Preencha tabela para n=5 símbolos e confirme soma linear em n.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Exemplos de frequências de símbolos"
                                  ],
                                  "tips": "Use somatório: Σ_{i=1 to n} O(1) = O(n).",
                                  "learningObjective": "Derivar complexidade O(n) pela multiplicação de loops implícitos.",
                                  "commonMistakes": [
                                    "Assumir loop explícito como O(n log n)",
                                    "Ignorar que n é fixo no input"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e contextualizar a complexidade da inicialização",
                                  "subSteps": [
                                    "Afirme: inicialização de nós folha é O(n), dominante para inputs pequenos.",
                                    "Discuta impacto no algoritmo total: Huffman é O(n log n), inicialização é menor.",
                                    "Teste com código real: implemente e profile tempo para n variando.",
                                    "Documente assunções: modelo RAM, operações primitivas O(1).",
                                    "Resuma em notação Big O formal."
                                  ],
                                  "verification": "Escreva parágrafo explicando O(n) com justificativa e exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código de Huffman simples em C/Python",
                                    "Ferramenta de profiling como timeit"
                                  ],
                                  "tips": "Profile para n=10^3 vs 10^6 para ver linearidade.",
                                  "learningObjective": "Integrar análise de inicialização no todo do algoritmo.",
                                  "commonMistakes": [
                                    "Superestimar como O(n^2)",
                                    "Não considerar alocação dinâmica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para codificar 'hello' (h:1, e:1, l:2, o:1; n=4), crie 4 nós folha: aloque Node para 'h' freq=1 (3 ops), repita para outros; total 12 ops = O(4).",
                              "finalVerifications": [
                                "Explica corretamente que criação de cada nó é O(1).",
                                "Calcula total como O(n) para n nós.",
                                "Lista operações: new, freq=, symbol=.",
                                "Distingue de fases posteriores do Huffman.",
                                "Aplica a exemplo com n=10 símbolos.",
                                "Identifica O(n) como menor que O(n log n) total."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de operações por nó (deve ser constante).",
                                "Correta derivação de O(n) via multiplicação por n.",
                                "Inclusão de alocação de memória e atribuições.",
                                "Uso correto de notação Big O sem termos extras.",
                                "Exemplo prático com cálculo numérico.",
                                "Consideração de assunções do modelo computacional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Somatórios e funções lineares (O(n)).",
                                "Programação: Gerenciamento de memória dinâmica (new/malloc).",
                                "Engenharia de Software: Análise de performance em inicializações.",
                                "Probabilidade: Frequências como distribuições empíricas."
                              ],
                              "realWorldApplication": "Em compressores de arquivos como ZIP ou JPEG, a inicialização O(n) de folhas garante eficiência inicial em dicionários grandes, permitindo foco em merges O(n log n) para dados reais como textos ou imagens."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.1.2",
                            "name": "Analisar a construção inicial da fila de prioridade (min-heap)",
                            "description": "Calcular o custo de inserir os n nós iniciais no min-heap, comparando o método de inserções sequenciais O(n log n) com a construção otimizada do heap O(n), conforme descrito em Cormen et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de min-heap e inserção sequencial",
                                  "subSteps": [
                                    "Defina min-heap: estrutura onde o pai é menor ou igual aos filhos.",
                                    "Explique a operação INSERT: adicionar no final e subir (bubble up) até a propriedade heap ser restaurada.",
                                    "Descreva o processo para n inserções sequenciais: cada inserção custa O(log n) no pior caso.",
                                    "Liste as alturas da árvore heap: da raiz (altura 0) até folhas.",
                                    "Calcule o custo médio aproximado para inserções iniciais."
                                  ],
                                  "verification": "O aluno explica verbalmente ou por escrito o processo de inserção sequencial e calcula o custo para n=4.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo de INSERT-HEAP (Cormen)",
                                    "Diagrama de min-heap com 7 nós",
                                    "Papel e caneta para desenhar"
                                  ],
                                  "tips": [
                                    "Visualize a árvore heap para entender o bubble up.",
                                    "Comece com heaps pequenos (n=3,7) para praticar."
                                  ],
                                  "learningObjective": "Compreender o mecanismo de inserção sequencial em min-heap e seu custo logarítmico.",
                                  "commonMistakes": [
                                    "Confundir min-heap com max-heap.",
                                    "Ignorar que o custo varia com a altura da inserção.",
                                    "Assumir custo fixo O(log n) sem somatório."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a complexidade das inserções sequenciais O(n log n)",
                                  "subSteps": [
                                    "Some os custos: 1ª inserção O(1), 2ª O(2), até n-ésima O(log n).",
                                    "Use a fórmula: custo total ≈ Σ_{h=0}^{log n} (n_h * h), onde n_h é número de nós na altura h.",
                                    "Aproxime: cerca de n/2 nós custam O(1), n/4 custam O(2), etc.",
                                    "Derive: total = O(n log n) pois somatório harmônico é Θ(n log n).",
                                    "Implemente um exemplo numérico para n=8."
                                  ],
                                  "verification": "O aluno deriva a fórmula O(n log n) e calcula para um n dado com erro <10%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fórmulas de somatórios (Cormen 6.3)",
                                    "Calculadora ou Python para somar",
                                    "Tabela de alturas heap"
                                  ],
                                  "tips": [
                                    "Use notação big-O para abstrair constantes.",
                                    "Desenhe a árvore completa para contar nós por altura."
                                  ],
                                  "learningObjective": "Derivar analiticamente o custo O(n log n) das inserções sequenciais.",
                                  "commonMistakes": [
                                    "Contar log n fixo para todas inserções.",
                                    "Esquecer somatório e assumir apenas último log n.",
                                    "Confundir com build-heap prematuramente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o algoritmo de construção otimizada (BUILD-MIN-HEAP)",
                                  "subSteps": [
                                    "Descreva BUILD-MIN-HEAP: assume array de n elementos desordenado, chama MAX-HEAPIFY de baixo para cima.",
                                    "Explique MAX-HEAPIFY (adaptado para min): corrige subárvore em O(h), h=altura.",
                                    "Comece chamando em i = floor(n/2) até n-1 (folhas não precisam).",
                                    "Mostre pseudocódigo: for i = floor(n/2) downto 1: MIN-HEAPIFY(A, i).",
                                    "Exemplo: construa heap para array [4,1,3,2,16,9,10,14,8,7]."
                                  ],
                                  "verification": "O aluno executa BUILD-MIN-HEAP manualmente em um array de 8 elementos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo BUILD-MIN-HEAP (Cormen 6.3)",
                                    "Array de exemplo impresso",
                                    "Simulador online de heaps (opcional)"
                                  ],
                                  "tips": [
                                    "Folhas (i >= n/2) já são heaps.",
                                    "Pratique MIN-HEAPIFY primeiro isoladamente."
                                  ],
                                  "learningObjective": "Dominar o algoritmo bottom-up de construção de min-heap.",
                                  "commonMistakes": [
                                    "Chamar HEAPIFY na ordem errada (top-down).",
                                    "Esquecer de começar em floor(n/2).",
                                    "Confundir min com max-heapify."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a complexidade O(n) da construção otimizada",
                                  "subSteps": [
                                    "Calcule custo por chamada: nó na altura h custa O(h).",
                                    "Some por alturas: folhas (n/2 nós) O(1), próxima camada (n/4) O(2), até raiz O(log n).",
                                    "Fórmula: Σ_{h=1}^{log n} (n / 2^h * h) ≤ Σ_{h=1}^∞ n h / 2^h = O(n).",
                                    "Prove o limite superior: somatório harmônico geométrico é 2n.",
                                    "Compare numericamente com O(n log n) para n=1024."
                                  ],
                                  "verification": "O aluno prova O(n) via somatório e compara tempos para n grande.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Prova Cormen Teorema 6.4",
                                    "Planilha Excel para somatórios",
                                    "Gráfico O(n) vs O(n log n)"
                                  ],
                                  "tips": [
                                    "Lembre: Σ h r^h = r/(1-r)^2 para |r|<1 (r=1/2).",
                                    "Teste com código para validar."
                                  ],
                                  "learningObjective": "Provar matematicamente a linearidade O(n) da build-heap.",
                                  "commonMistakes": [
                                    "Assumir O(n log n) por ter log n níveis.",
                                    "Errar contagem de nós por altura.",
                                    "Ignorar prova formal do somatório."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar métodos e contextualizar em Huffman",
                                  "subSteps": [
                                    "Tabule valores: sequencial Θ(n log n), build O(n).",
                                    "Ganho: fator log n, crítico para n grande em Huffman.",
                                    "Em Huffman: n símbolos, build min-heap inicial para fila de prioridade.",
                                    "Discuta impacto na complexidade total de Huffman O(n log n).",
                                    "Implemente ambos em pseudocódigo e compare."
                                  ],
                                  "verification": "O aluno cria tabela comparativa e explica vantagem em Huffman.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Capítulo Cormen 16.3 Huffman",
                                    "Pseudocódigos lado a lado",
                                    "Gráfico de performance"
                                  ],
                                  "tips": [
                                    "Foco no fator assintótico para grandes n.",
                                    "Relacione com fila de prioridade em algoritmos gulosos."
                                  ],
                                  "learningObjective": "Comparar custos e justificar uso de build-heap em cenários reais.",
                                  "commonMistakes": [
                                    "Subestimar ganho para n pequeno.",
                                    "Confundir com complexidade de EXTRACT-MIN.",
                                    "Esquecer contexto de priority queue."
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=8 símbolos em Huffman (frequências [4,1,3,2,16,9,10,14]), construa min-heap sequencialmente (custo ~ 8*log8=24 ops) vs build-heap (custo ~16 ops reais), simulando inserções e heapify.",
                              "finalVerifications": [
                                "Calcula corretamente custo sequencial para n arbitrário.",
                                "Executa BUILD-MIN-HEAP em array de 16 elementos sem erros.",
                                "Deriva somatório O(n) com prova.",
                                "Compara tempos e identifica quando build é superior.",
                                "Aplica em exemplo de Huffman com frequências dadas.",
                                "Explica verbalmente vantagens em priority queues."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de complexidades (90% correto).",
                                "Correção na execução manual de algoritmos.",
                                "Profundidade da prova matemática (inclui somatórios).",
                                "Clareza na comparação e exemplos numéricos.",
                                "Conexão com aplicações reais como Huffman.",
                                "Identificação de erros comuns e evitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries harmônicas e somatórios geométricos.",
                                "Estatística: Análise de custos médios em árvores balanceadas.",
                                "Física: Analogia com pilhas de areia (heapify como estabilização).",
                                "Economia: Otimização de custos em processos sequenciais vs paralelos.",
                                "Engenharia de Software: Escolha de estruturas de dados eficientes."
                              ],
                              "realWorldApplication": "Em compressão de dados via Huffman (zip, JPEG), onde construir priority queue inicial com milhares de símbolos usa build-heap O(n) para eficiência, reduzindo tempo de codificação em fator log n; similar em Dijkstra para rotas GPS ou A* em jogos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.1.3",
                            "name": "Avaliar a complexidade de uma iteração do loop principal",
                            "description": "Analisar o custo de extrair os dois nós de menor prioridade (2 operações extract-min, cada O(log n)), criar o nó pai e inserir de volta (O(log n)), totalizando O(log n) por iteração para n-1 merges.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o loop principal do algoritmo de Codificação de Huffman",
                                  "subSteps": [
                                    "Relembre o pseudocódigo do algoritmo de Huffman: inicializar uma fila de prioridade com nós folha baseados em frequências.",
                                    "Identifique o loop principal: enquanto houver mais de um nó na fila, extraia os dois de menor prioridade.",
                                    "Crie um nó pai com frequência soma das duas menores e insira-o de volta na fila.",
                                    "Note que o loop roda n-1 vezes para n folhas.",
                                    "Desenhe um diagrama simples de uma iteração para visualização."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o que acontece em uma iteração do loop principal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo do algoritmo de Huffman",
                                    "Papel e caneta para diagrama",
                                    "Exemplo de frequências de caracteres"
                                  ],
                                  "tips": [
                                    "Foque apenas no loop principal, ignorando inicialização por agora.",
                                    "Use um exemplo pequeno com 4 caracteres para praticar."
                                  ],
                                  "learningObjective": "Compreender a estrutura e o fluxo de uma única iteração do loop de merge no Huffman.",
                                  "commonMistakes": [
                                    "Confundir com o loop de construção da árvore final.",
                                    "Esquecer que o loop para quando resta um nó raiz."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as operações principais em uma iteração",
                                  "subSteps": [
                                    "Liste as operações: extract-min() duas vezes para obter os dois nós de menor prioridade.",
                                    "Crie um novo nó interno com frequência igual à soma das frequências dos dois extraídos.",
                                    "Defina os filhos esquerdo e direito do novo nó.",
                                    "Execute insert() ou decrease-key para inserir o novo nó de volta na fila de prioridade.",
                                    "Confirme que não há outras operações dominantes na iteração."
                                  ],
                                  "verification": "Escreva a sequência exata de 3 operações principais e seus parâmetros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama da iteração do Step 1",
                                    "Implementação conceitual de fila de prioridade (min-heap)"
                                  ],
                                  "tips": [
                                    "Pense na fila como um min-heap binário.",
                                    "Anote os símbolos: 2 × extract-min + 1 × insert."
                                  ],
                                  "learningObjective": "Mapear precisamente as operações de fila de prioridade executadas por iteração.",
                                  "commonMistakes": [
                                    "Incluir operações de construção da árvore final no custo da iteração.",
                                    "Contar criação do nó como operação custosa (é O(1))."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a complexidade assintótica de cada operação",
                                  "subSteps": [
                                    "Revise que extract-min em um heap binário é O(log n), onde n é o número atual de nós na fila.",
                                    "Confirme que insert (ou push) também é O(log n).",
                                    "Note que criação do nó pai é O(1), pois é alocação simples e soma de frequências.",
                                    "Para uma iteração: 2 × O(log n) + O(log n) + O(1) = 3 × O(log n) = O(log n).",
                                    "Justifique por que usamos notação big-O, descartando constantes."
                                  ],
                                  "verification": "Calcule e justifique o custo de cada operação em notação O.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referência rápida de complexidades de heaps",
                                    "Folha de cálculo para anotações de custos"
                                  ],
                                  "tips": [
                                    "Lembre: n diminui ligeiramente a cada iteração, mas usamos n aproximado para análise.",
                                    "Pratique com tamanhos de heap: 4, 8, 16 nós."
                                  ],
                                  "learningObjective": "Dominar o custo de operações fundamentais em filas de prioridade baseadas em heaps.",
                                  "commonMistakes": [
                                    "Assumir extract-min como O(1).",
                                    "Esquecer que n é o tamanho atual da fila (~n no início)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e verificar a complexidade total por iteração",
                                  "subSteps": [
                                    "Some os custos: 2 extract-min (2 log n) + 1 insert (log n) = O(log n).",
                                    "Considere que o loop tem n-1 iterações, mas foque apenas nesta iteração.",
                                    "Compare com alternativas: por que heap é eficiente vs. lista ordenada (O(n))? ",
                                    "Teste com um exemplo numérico: conte comparações em heaps pequenos.",
                                    "Documente a conclusão: O(log n) por iteração."
                                  ],
                                  "verification": "Escreva a equação final de complexidade e explique em 2-3 frases.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo prático com frequências",
                                    "Calculadora para log n aproximado"
                                  ],
                                  "tips": [
                                    "Amortize: constantes como 3 são absorvidas no O(log n).",
                                    "Pense em n como tamanho inicial para simplicidade."
                                  ],
                                  "learningObjective": "Sintetizar custos operacionais em complexidade por iteração do algoritmo.",
                                  "commonMistakes": [
                                    "Somar como O(3 log n) sem simplificar para O(log n).",
                                    "Confundir complexidade por iteração com total do algoritmo."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere frequências: A:5, B:9, C:12, D:13, E:16. Na fila inicial (heap): [A5, B9, C12, D13, E16]. Iteração 1: extract-min A5 e B9 (2 log 5 ~ 2*2.3=4.6 ops), crie pai AB:14 (O(1)), insert AB14 (log 4 ~2 ops). Total ~7 ops = O(log 5).",
                              "finalVerifications": [
                                "Explicar corretamente as 3 operações principais e seus custos O(log n).",
                                "Demonstrar soma de custos resultando em O(log n) por iteração.",
                                "Identificar que criação de nó é O(1) e não afeta o total.",
                                "Justificar uso de heap para eficiência em extract-min e insert.",
                                "Aplicar análise a um exemplo concreto sem erros aritméticos.",
                                "Diferenciar complexidade por iteração da complexidade total O(n log n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de operações (2 extract-min + 1 insert).",
                                "Correta atribuição de O(log n) a cada operação heap-based.",
                                "Simplificação assintótica adequada (ignorar constantes).",
                                "Clareza na justificativa escrita ou verbal.",
                                "Uso correto de n como tamanho da fila.",
                                "Ausência de confusão com complexidade total do algoritmo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e logaritmos em base 2.",
                                "Estruturas de Dados: Filas de prioridade e heaps binários.",
                                "Teoria da Computação: Classes de complexidade e notação Big-O.",
                                "Engenharia de Software: Otimização de algoritmos de compressão."
                              ],
                              "realWorldApplication": "Em compressão de arquivos ZIP ou JPEG, o algoritmo de Huffman usa esta análise para garantir eficiência O(n log n) total, permitindo compressão rápida de dados massivos como vídeos ou logs de rede em sistemas reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.1.4",
                            "name": "Calcular a complexidade total temporal",
                            "description": "Somar os custos das fases: O(n) inicialização + O(n) build-heap + O(n log n) para (n-1) iterações, dominado por O(n log n), justificando a complexidade assintótica do algoritmo de Huffman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a complexidade da fase de inicialização",
                                  "subSteps": [
                                    "Identifique a fase de inicialização no algoritmo de Huffman: criação da priority queue com n elementos e suas frequências.",
                                    "Determine o custo de inserir cada um dos n elementos na priority queue vazia: cada inserção é O(log n).",
                                    "Calcule o custo total para n inserções sequenciais: soma de O(log 1) + O(log 2) + ... + O(log n), que é O(n).",
                                    "Registre a complexidade como O(n) para inicialização.",
                                    "Verifique com um exemplo pequeno: n=3, calcule logs aproximados."
                                  ],
                                  "verification": "Escreva a equação da soma de log k de 1 a n e confirme que é O(n).",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Pseudocódigo do algoritmo de Huffman",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Lembre-se que somas harmônicas de logaritmos crescem linearmente.",
                                  "learningObjective": "Compreender e calcular o custo assintótico da inicialização da priority queue.",
                                  "commonMistakes": [
                                    "Confundir inserções sequenciais com build-heap eficiente",
                                    "Ignorar que priority queue começa vazia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a complexidade da construção do heap (build-heap)",
                                  "subSteps": [
                                    "Explique o build-heap: rearranjar os n elementos na priority queue para formar um min-heap válido.",
                                    "Lembre o teorema: build-heap em um array de n elementos custa O(n), não O(n log n).",
                                    "Derivação breve: custo é proporcional à altura da árvore, soma O(h) + 2O(h-1) + ... = O(n).",
                                    "No contexto de Huffman, confirme que após inserções iniciais, um build-heap O(n) pode ser usado.",
                                    "Anote O(n) para build-heap."
                                  ],
                                  "verification": "Prove que build-heap é O(n) citando a soma geométrica das alturas.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Diagrama de heap",
                                    "Referência teórica de heaps"
                                  ],
                                  "tips": "Use a fórmula padrão: custo < 2n para n elementos.",
                                  "learningObjective": "Dominar a análise do build-heap e sua eficiência linear.",
                                  "commonMistakes": [
                                    "Assumir O(n log n) como em inserções individuais",
                                    "Confundir com heapify-up vs heapify-down"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a complexidade das (n-1) iterações de merge",
                                  "subSteps": [
                                    "Descreva as iterações: para i de 1 a n-1, extraia 2 mins (2 extract-min O(log n)), crie novo nó e insira (O(log n)).",
                                    "Custo por iteração: 2 O(log n) + O(log n) = O(log n).",
                                    "Total para n-1 iterações: (n-1) * O(log n) = O(n log n).",
                                    "Confirme que log n é baseado no tamanho atual do heap, mas assintoticamente O(log n).",
                                    "Some com exemplo: para n=4, 3 iterações, cada ~log4=2."
                                  ],
                                  "verification": "Escreva T(n) = (n-1) log n e simplifique para O(n log n).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Exemplo numérico de Huffman com 5 símbolos",
                                    "Gráfico de execuções"
                                  ],
                                  "tips": "Conte extract-min e insert separadamente para clareza.",
                                  "learningObjective": "Calcular precisamente o custo das operações repetidas no loop principal.",
                                  "commonMistakes": [
                                    "Esquecer os dois extract-min por iteração",
                                    "Usar log(n-1) em vez de log n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar complexidades e determinar a assintótica total",
                                  "subSteps": [
                                    "Liste todos os custos: O(n) init + O(n) build + O(n log n) loops.",
                                    "Some: O(n + n + n log n) = O(n log n).",
                                    "Justifique dominância: termo n log n cresce mais rápido que O(n).",
                                    "Escreva a notação big-O final: O(n log n).",
                                    "Compare com alternativas como ordenação O(n log n)."
                                  ],
                                  "verification": "Mostre que para grandes n, n log n >> 2n, confirmando dominância.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Tabela de somas",
                                    "Gráfico assintótico"
                                  ],
                                  "tips": "Sempre pegue o termo dominante na notação Θ ou big-O.",
                                  "learningObjective": "Integrar análises parciais em complexidade total e justificá-la.",
                                  "commonMistakes": [
                                    "Adicionar incorretamente como O(n + n log n + n log n)",
                                    "Ignorar constantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para símbolos com frequências [5,9,12,13,16,45] (n=6): Init O(6), build O(6), 5 merges cada O(log6≈3) total ~15 ops → O(6*3)=O(18)=O(n log n). Simule: extraia 5+9=14 insert, etc., some custos reais e assintóticos.",
                              "finalVerifications": [
                                "Liste corretamente as 3 fases principais e seus custos O(n), O(n), O(n log n).",
                                "Some os custos e identifique O(n log n) como total.",
                                "Justifique por que O(n log n) domina com limite n→∞.",
                                "Aplique a um exemplo com n=8, calculando manualmente.",
                                "Explique diferença entre build-heap O(n) e n inserts O(n log n).",
                                "Compare complexidade de Huffman vs Shannon-Fano."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de custos por fase (100% correto).",
                                "Correta derivação matemática das somas e produtos.",
                                "Justificativa clara da dominância assintótica.",
                                "Uso apropriado de notação big-O sem erros.",
                                "Exemplo prático completo e verificável.",
                                "Ausência de confusão entre operações heap (extract vs insert)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de somas harmônicas e séries (log n).",
                                "Física: Otimização de energia em sistemas de codificação (entropia).",
                                "Economia: Minimização de custos em alocação de recursos variáveis.",
                                "Engenharia de Software: Trade-offs tempo/espaço em compressão."
                              ],
                              "realWorldApplication": "Em compressão de arquivos como ZIP ou vídeos MP4, calcular O(n log n) do Huffman garante eficiência para gigabytes de dados, permitindo streaming rápido em apps como Netflix sem sobrecarga computacional."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.6.2",
                        "name": "Análise de Complexidade Espacial",
                        "description": "Avaliação do espaço de memória utilizado pelo algoritmo de Huffman, considerando nós da árvore, fila de prioridade e estruturas auxiliares, resultando em O(n) para n símbolos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.2.1",
                            "name": "Calcular o espaço ocupado pelos nós da árvore de Huffman",
                            "description": "Determinar que a árvore final possui n folhas e n-1 nós internos, totalizando 2n-1 nós, cada com frequência, ponteiros para filhos e possivelmente códigos, resultando em O(n) espaço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura da árvore de Huffman",
                                  "subSteps": [
                                    "Identifique as folhas como os nós terminais representando símbolos com suas frequências.",
                                    "Lembre que nós internos são criados pela combinação dos dois nós de menor frequência.",
                                    "Desenhe um exemplo simples de árvore de Huffman para uma string curta, como 'aab'.",
                                    "Anote que cada nó possui frequência e ponteiros para filhos esquerdo e direito.",
                                    "Confirme que a árvore é binária completa com altura variável."
                                  ],
                                  "verification": "Desenhe corretamente a árvore para um exemplo dado e label os nós internos e folhas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de frequências de símbolos (e.g., a:2, b:1)"
                                  ],
                                  "tips": [
                                    "Comece sempre pelas folhas e construa bottom-up para visualizar melhor."
                                  ],
                                  "learningObjective": "Compreender os componentes básicos da árvore de Huffman e sua construção.",
                                  "commonMistakes": [
                                    "Confundir folhas com nós internos",
                                    "Ignorar que ponteiros são para filhos, não pais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contar o número total de nós na árvore",
                                  "subSteps": [
                                    "Determine o número de folhas (n) como o número de símbolos distintos.",
                                    "Calcule o número de nós internos como n-1, pois cada merge reduz um nó.",
                                    "Some folhas + internos para obter total de 2n-1 nós.",
                                    "Verifique com um exemplo: para 4 símbolos, folhas=4, internos=3, total=7.",
                                    "Prove matematicamente que em uma árvore binária de Huffman, total é sempre 2n-1."
                                  ],
                                  "verification": "Calcule corretamente o total de nós para 2-3 exemplos variados de n.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora simples",
                                    "Tabela de exemplos com diferentes n"
                                  ],
                                  "tips": [
                                    "Use indução: base n=1 (1 nó), cada adição cria 1 interno e 1 folha efetiva."
                                  ],
                                  "learningObjective": "Dominar a fórmula para o número total de nós em função de n folhas.",
                                  "commonMistakes": [
                                    "Contar 2n em vez de 2n-1",
                                    "Confundir n com comprimento total da string"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar os dados armazenados em cada nó",
                                  "subSteps": [
                                    "Liste atributos por nó: frequência (inteiro, 4-8 bytes), ponteiro esquerdo (ref, 4-8 bytes), ponteiro direito (ref, 4-8 bytes).",
                                    "Note que folhas podem ter símbolo extra (1 byte), mas para espaço geral ignore.",
                                    "Considere códigos opcionais (string variável), mas foque em árvore básica sem eles.",
                                    "Estime tamanho por nó: ~16-24 bytes em implementações típicas.",
                                    "Compare com array de frequências iniciais para contexto."
                                  ],
                                  "verification": "Escreva uma tabela com atributos e tamanhos estimados para cada tipo de nó.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagem de programação (e.g., C++ struct para nó)"
                                  ],
                                  "tips": [
                                    "Assuma tamanhos fixos de ponteiros para simplificar cálculos."
                                  ],
                                  "learningObjective": "Listar e quantificar precisamente os campos de memória por nó.",
                                  "commonMistakes": [
                                    "Esquecer ponteiros em nós internos",
                                    "Incluir códigos prefixos na árvore"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o espaço total e analisar complexidade",
                                  "subSteps": [
                                    "Multiplique total de nós (2n-1) pelo tamanho médio por nó (e.g., 24 bytes).",
                                    "Some overheads fixos se aplicável, mas destaque dominância linear.",
                                    "Expresse como O(n) espaço, pois constante por nó × 2n-1 é linear em n.",
                                    "Compare com O(n) para tabela de frequências inicial.",
                                    "Teste com exemplo numérico: n=4, total nós=7, espaço ~168 bytes."
                                  ],
                                  "verification": "Forneça cálculo exato de espaço para um exemplo e justifique O(n).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou código simples para simular tamanhos"
                                  ],
                                  "tips": [
                                    "Ignore constantes para Big O, foque no termo dominante."
                                  ],
                                  "learningObjective": "Calcular espaço total e derivar notação assintótica corretamente.",
                                  "commonMistakes": [
                                    "Chamar O(1) por confundir com altura",
                                    "Usar n como tamanho input total"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a string 'aabc' (frequências: a:2, b:1, c:1), n=3 folhas. Nós internos: 2. Total: 5 nós. Cada nó: freq (4 bytes) + 2 ponteiros (8 bytes cada) = 20 bytes/nó. Espaço total: 5 × 20 = 100 bytes, O(n) com n=3.",
                              "finalVerifications": [
                                "Calcule corretamente total de nós para n=5 e n=10.",
                                "Liste todos atributos de um nó típico e estime seu tamanho.",
                                "Derive fórmula 2n-1 e prove para um caso.",
                                "Explique por que espaço é O(n) não O(n log n).",
                                "Compare espaço da árvore vs. array de frequências.",
                                "Aplique a um exemplo real de Huffman construído."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de folhas e nós internos (2n-1).",
                                "Correta identificação de atributos por nó (freq + ponteiros).",
                                "Cálculo numérico exato de espaço total.",
                                "Justificativa assintótica O(n) com eliminação de constantes.",
                                "Uso consistente de n como número de folhas.",
                                "Integração com exemplo prático sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de árvores binárias e contagem de nós.",
                                "Programação: Implementação de estruturas de dados (structs/classes para nós).",
                                "Engenharia de Software: Análise de uso de memória em algoritmos.",
                                "Física/Química: Compressão de dados em simulações científicas."
                              ],
                              "realWorldApplication": "Em compressores de arquivos como gzip ou ZIP, a árvore de Huffman consome O(n) espaço adicional, crucial para dispositivos com memória limitada como IoT ou streaming de vídeo, otimizando armazenamento sem overhead excessivo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.2.2",
                            "name": "Analisar o espaço da fila de prioridade (min-heap)",
                            "description": "Verificar que o heap armazena no máximo n elementos simultaneamente (inicialmente n, reduzindo para 1), com cada entrada ocupando O(1) espaço adicional, total O(n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o algoritmo de Huffman e o uso do min-heap",
                                  "subSteps": [
                                    "Relembre os passos do algoritmo de Huffman: construir árvore de frequências usando min-heap.",
                                    "Identifique onde o min-heap é inicializado: com n folhas (frequências dos símbolos).",
                                    "Descreva como o heap é usado: extrair dois mínimos, combinar em nó pai, inserir de volta.",
                                    "Note que o heap começa com n elementos e cada iteração reduz em 1 (remove 2, adiciona 1).",
                                    "Registre que o processo repete n-1 vezes até restar 1 elemento (raiz)."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando o fluxo do heap no Huffman.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Pseudocódigo do algoritmo de Huffman",
                                    "Diagrama de min-heap",
                                    "Exemplo com 4 símbolos"
                                  ],
                                  "tips": "Desenhe o heap inicial e simule 2 iterações para visualizar mudanças de tamanho.",
                                  "learningObjective": "Compreender o papel dinâmico do min-heap na construção da árvore de Huffman.",
                                  "commonMistakes": [
                                    "Confundir min-heap com max-heap",
                                    "Ignorar que o heap muda de tamanho a cada iteração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o número máximo de elementos no heap",
                                  "subSteps": [
                                    "Inicialize o heap com n elementos (um por símbolo de frequência).",
                                    "Simule iterações: em cada uma, heap size -= 1 (remove 2, insere 1).",
                                    "Observe que o tamanho máximo ocorre no início: n elementos.",
                                    "Confirme que nunca excede n, pois só diminui após inicialização.",
                                    "Prove matematicamente: size_inicial = n, size_final = 1, decremento de 1 por iteração."
                                  ],
                                  "verification": "Crie uma tabela mostrando tamanho do heap por iteração para n=5.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Folha de cálculo ou papel para tabela",
                                    "Exemplo pequeno de frequências"
                                  ],
                                  "tips": "Use n pequeno (4-6) para simulação manual; generalize para qualquer n.",
                                  "learningObjective": "Estabelecer que o heap armazena no máximo n elementos simultaneamente.",
                                  "commonMistakes": [
                                    "Achar que heap cresce além de n",
                                    "Esquecer inserção do nó pai após extrações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o espaço ocupado por cada elemento no heap",
                                  "subSteps": [
                                    "Defina a estrutura de um nó no heap: valor (frequência), ponteiros para filhos (esquerda/direita).",
                                    "Conte campos fixos: frequência (O(1)), ponteiros (2, O(1)), metadados heap (posição, O(1)).",
                                    "Ignore árvore completa por agora; foque só no heap como array ou estrutura.",
                                    "Em implementação array-based: cada nó usa índice + valor + freq, total O(1) por entrada.",
                                    "Confirme: sem referências extras variáveis, cada entrada é constante espaço."
                                  ],
                                  "verification": "Liste os campos de um nó e some seu tamanho em bytes (assuma int=4B, pointer=8B).",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Diagrama de nó heap",
                                    "Código modelo de min-heap em pseudocódigo"
                                  ],
                                  "tips": "Pense em implementação padrão (array de 2n-1 tamanho, mas só n usados max).",
                                  "learningObjective": "Verificar que cada entrada no heap ocupa O(1) espaço adicional.",
                                  "commonMistakes": [
                                    "Incluir espaço da árvore final no heap",
                                    "Contar ponteiros recursivos como O(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e justificar a complexidade espacial total O(n)",
                                  "subSteps": [
                                    "Multiplique: max elementos (n) × espaço por elemento (O(1)) = O(n).",
                                    "Some overhead: array heap reserva ~2n slots, ainda O(n).",
                                    "Compare com input: frequências n itens O(n), heap O(n), total dominado por O(n).",
                                    "Discuta assintótico: para grandes n, constante por nó torna irrelevante.",
                                    "Escreva notação formal: Espaço = Θ(n) no pior caso."
                                  ],
                                  "verification": "Escreva prova curta: 'Heap max n nós × O(1)/nó = O(n)'.",
                                  "estimatedTime": "15 min",
                                  "materials": [
                                    "Tabela de análise espacial",
                                    "Referência Big O espacial"
                                  ],
                                  "tips": "Use notação Θ para tight bound se possível.",
                                  "learningObjective": "Concluir análise espacial completa como O(n) para fila de prioridade.",
                                  "commonMistakes": [
                                    "Confundir com tempo O(n log n)",
                                    "Ignorar que heap encolhe mas max é n"
                                  ]
                                }
                              ],
                              "practicalExample": "Para string 'ABRACADABRA' (frequências: A:5, B:2, R:2, C:1, D:1; n=5), heap inicia com 5 nós. Iteração 1: extrai C/D (menores), insere pai (2), size=4. Continua até size=1. Max size=5=n, cada nó ~24B (freq+2ptrs), total ~120B = O(n).",
                              "finalVerifications": [
                                "Explica corretamente max n elementos no heap?",
                                "Identifica O(1) por entrada (campos fixos)?",
                                "Justifica total O(n) com multiplicação?",
                                "Simula exemplo pequeno sem erros de tamanho?",
                                "Distingue espaço heap de árvore final?",
                                "Usa notação Big O corretamente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do tamanho máximo do heap (n elementos).",
                                "Correta contagem de espaço por nó (O(1) campos fixos).",
                                "Lógica de multiplicação para total O(n) clara e concisa.",
                                "Uso de simulação ou prova matemática para suporte.",
                                "Ausência de confusão com complexidade temporal.",
                                "Generalização assintótica para qualquer n."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Notação Big O e análise assintótica.",
                                "Estruturas de Dados: Heaps e árvores binárias.",
                                "Compressão de Dados: Aplicações em algoritmos de codificação.",
                                "Programação: Implementação eficiente de memória."
                              ],
                              "realWorldApplication": "Em compressores como ZIP ou JPEG, análise espacial O(n) garante escalabilidade para arquivos grandes sem explosão de memória, permitindo compressão eficiente em dispositivos limitados como smartphones."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.2.3",
                            "name": "Identificar o espaço auxiliar e total",
                            "description": "Considerar variáveis locais, arrays de frequências O(n) e pilha de recursão se usada (O(log n) ou O(1)), confirmando que o espaço total é O(n), linear no número de símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o algoritmo de Codificação de Huffman e listar estruturas de dados principais",
                                  "subSteps": [
                                    "Examine o pseudocódigo ou implementação do algoritmo de Huffman.",
                                    "Identifique todas as estruturas de dados usadas: array de frequências, fila de prioridade (min-heap), nós da árvore.",
                                    "Anote o tamanho de cada estrutura em termos de n (número de símbolos únicos).",
                                    "Registre variáveis locais como contadores ou ponteiros temporários.",
                                    "Desenhe um diagrama simples das estruturas principais."
                                  ],
                                  "verification": "Lista completa de estruturas de dados com tamanhos aproximados em O(n) confirmada por auto-revisão ou peer review.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo de Huffman",
                                    "Papel e caneta para diagrama",
                                    "Editor de código com exemplo de Huffman"
                                  ],
                                  "tips": "Comece pelo array de frequências, pois é o mais óbvio O(n).",
                                  "learningObjective": "Compreender as componentes espaciais fundamentais do algoritmo.",
                                  "commonMistakes": [
                                    "Ignorar variáveis locais",
                                    "Confundir n com tamanho da string de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o espaço auxiliar para estruturas não-recursivas",
                                  "subSteps": [
                                    "Calcule espaço do array de frequências: O(n) para n símbolos.",
                                    "Analise a fila de prioridade: inicialmente n folhas, cresce para 2n-1 nós na árvore, total O(n).",
                                    "Some variáveis locais: O(1) cada, como contadores ou temporários.",
                                    "Ignore entrada original se não modificada.",
                                    "Registre todos em uma tabela: estrutura | tamanho | justificativa."
                                  ],
                                  "verification": "Tabela preenchida mostrando pelo menos O(n) para array e heap.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em planilha ou papel",
                                    "Exemplo de código Huffman comentado"
                                  ],
                                  "tips": "Use heapq em Python como referência para fila de prioridade.",
                                  "learningObjective": "Quantificar espaço auxiliar dominante como O(n).",
                                  "commonMistakes": [
                                    "Contar apenas array, esquecendo heap",
                                    "Assumir heap como O(1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar espaço de pilha de recursão e overheads",
                                  "subSteps": [
                                    "Verifique se o algoritmo usa recursão (ex: construção de códigos).",
                                    "Estime profundidade da recursão: O(log n) para árvore balanceada de Huffman.",
                                    "Calcule frames de pilha: O(log n) * tamanho por frame (O(1) variáveis locais).",
                                    "Compare com implementação iterativa: geralmente O(1) extra.",
                                    "Confirme que recursão não domina: O(log n) << O(n)."
                                  ],
                                  "verification": "Cálculo escrito mostrando O(log n) ou O(1) para recursão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de chamadas recursivas",
                                    "Ferramenta de profiling como Python's sys.getrecursionlimit"
                                  ],
                                  "tips": "Teste com input pequeno para observar pilha via debugger.",
                                  "learningObjective": "Diferenciar espaço recursivo de auxiliar dominante.",
                                  "commonMistakes": [
                                    "Superestimar recursão como O(n)",
                                    "Ignorar se for iterativo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar componentes para determinar espaço total",
                                  "subSteps": [
                                    "Some espaços: array O(n) + heap O(n) + recursão O(log n) + locals O(1).",
                                    "Identifique termo dominante: O(n) linear no número de símbolos.",
                                    "Escreva notação assintótica: Espaço auxiliar O(n), total O(n).",
                                    "Valide com exemplo numérico: n=26 letras, conte bytes aproximados.",
                                    "Documente suposições (ex: tamanho fixo de nó)."
                                  ],
                                  "verification": "Equação final: Espaço total = O(n), com breakdown detalhado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela do Step 2",
                                    "Calculadora ou Python para somas"
                                  ],
                                  "tips": "Sempre pegue o maior termo no Big O.",
                                  "learningObjective": "Sintetizar análise para complexidade espacial total.",
                                  "commonMistakes": [
                                    "Adicionar log n ao total como O(n log n)",
                                    "Esquecer de linearizar"
                                  ]
                                }
                              ],
                              "practicalExample": "Para string 'aabbccd' (n=4 símbolos: a:2, b:2, c:2, d:1). Array freq: O(4). Heap: constrói 7 nós O(4). Recursão códigos: O(log 4)=O(2). Locais: O(1). Total auxiliar O(4)=O(n), ~100 bytes em prática.",
                              "finalVerifications": [
                                "Lista identifica array de frequências como O(n).",
                                "Heap/priority queue reconhecido como O(n).",
                                "Recursão avaliada corretamente como O(log n) ou O(1).",
                                "Espaço total concluído como O(n) linear.",
                                "Exemplo numérico valida cálculos.",
                                "Sem erros em suposições de tamanho de estruturas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todas estruturas O(n).",
                                "Correta análise de recursão vs. iterativo.",
                                "Notação Big O assintótica precisa (O(n), não Theta).",
                                "Breakdown tabular ou diagrama claro.",
                                "Validação com exemplo prático.",
                                "Ausência de erros comuns como ignorar heap."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Notação Big O e análise assintótica.",
                                "Engenharia de Software: Otimização de memória em sistemas embarcados.",
                                "Probabilidade: Frequências em entropia de informação.",
                                "Física: Compressão de dados em transmissão de sinais."
                              ],
                              "realWorldApplication": "Em compressores de arquivos como ZIP ou GZIP, análise espacial O(n) garante viabilidade em dispositivos com memória limitada, como smartphones comprimindo logs de apps sem crash por overflow."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Problemas Clássicos de Otimização",
                "description": "Análise de problemas como mochila, caixeiro viajante, clique e coloração de grafos.",
                "totalSkills": 43,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Problema da Mochila",
                    "description": "Definição formal, variantes (0-1 e fracionária) e análise de complexidade do problema clássico de otimização combinatória.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Definição Formal do Problema da Mochila",
                        "description": "Apresentação da notação matemática e conceitual do problema clássico da mochila como um problema de otimização combinatória, incluindo entradas, saídas e objetivo de maximização de valor sob restrição de capacidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Identificar os parâmetros de entrada",
                            "description": "Reconhecer e descrever os elementos de entrada do problema: número de itens n, capacidade da mochila W, vetores de pesos wi e valores vi para i=1 até n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto geral do Problema da Mochila",
                                  "subSteps": [
                                    "Leia a definição formal do Problema da Mochila: dado um conjunto de itens com pesos e valores, e uma mochila com capacidade limitada, selecionar itens para maximizar o valor sem exceder o peso.",
                                    "Identifique que os parâmetros de entrada definem o problema antes de qualquer solução.",
                                    "Anote os componentes principais mencionados na descrição: itens, capacidade, pesos e valores.",
                                    "Compare com problemas semelhantes, como seleção de projetos com orçamento limitado.",
                                    "Resuma em suas palavras o propósito dos parâmetros de entrada."
                                  ],
                                  "verification": "Você pode explicar verbalmente ou por escrito o que o Problema da Mochila representa e por que precisa de parâmetros de entrada claros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Definição formal do problema (impressa ou digital)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Sempre comece pelo 'big picture' para contextualizar os detalhes técnicos.",
                                  "learningObjective": "Entender o papel dos parâmetros de entrada na definição formal do problema.",
                                  "commonMistakes": "Confundir parâmetros de entrada com a solução ou algoritmo de otimização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o número de itens (n)",
                                  "subSteps": [
                                    "Localize na descrição onde n é definido como o número total de itens disponíveis (i=1 até n).",
                                    "Explique que n representa a quantidade de itens candidatos à seleção.",
                                    "Diferencie n de outros números, como o número de itens selecionados (que é variável).",
                                    "Pratique identificando n em uma instância de exemplo simples.",
                                    "Registre a notação padrão: n ∈ ℕ."
                                  ],
                                  "verification": "Corretamente isole e descreva n de uma declaração do problema, confirmando seu tipo e papel.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo de instância do problema da mochila",
                                    "Quadro ou editor de texto"
                                  ],
                                  "tips": "Pense em n como o 'tamanho do universo' de itens disponíveis.",
                                  "learningObjective": "Reconhecer e descrever precisamente o parâmetro n.",
                                  "commonMistakes": "Confundir n com W ou assumir que n é o número de itens na mochila final."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a capacidade da mochila (W) e os vetores de pesos (wi)",
                                  "subSteps": [
                                    "Identifique W como a capacidade máxima de peso da mochila (W ≥ 0).",
                                    "Localize o vetor de pesos wi, onde wi é o peso do i-ésimo item (wi > 0 para i=1 a n).",
                                    "Descreva a relação: soma dos wi selecionados ≤ W.",
                                    "Diferencie W (escalar) de wi (vetor).",
                                    "Anote exemplos numéricos para clareza."
                                  ],
                                  "verification": "Liste W e wi de um exemplo e explique suas restrições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de exemplo com pesos",
                                    "Calculadora para somas"
                                  ],
                                  "tips": "Visualize a mochila como um balde com limite de volume (W).",
                                  "learningObjective": "Dominar a identificação de W e wi, incluindo suas propriedades.",
                                  "commonMistakes": "Ignorar restrições como wi > 0 ou confundir wi com valores vi."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar o vetor de valores (vi) e sintetizar todos os parâmetros",
                                  "subSteps": [
                                    "Localize vi como o valor ou utilidade do i-ésimo item (vi > 0 para i=1 a n).",
                                    "Liste todos os parâmetros: n, W, {wi}, {vi}.",
                                    "Verifique se a descrição cobre entrada completa para instâncias do problema.",
                                    "Crie uma tabela resumindo cada parâmetro, tipo e exemplo.",
                                    "Teste com uma instância: confirme todos os parâmetros estão presentes."
                                  ],
                                  "verification": "Produza uma lista completa e precisa dos quatro parâmetros com descrições.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Exemplo completo de problema"
                                  ],
                                  "tips": "Use tabelas para organizar vetores wi e vi lado a lado.",
                                  "learningObjective": "Sintetizar todos os parâmetros de entrada de forma integrada.",
                                  "commonMistakes": "Omitir vi ou tratar vetores como escalares."
                                }
                              ],
                              "practicalExample": "Exemplo: n=3 itens, W=5 (capacidade), wi=[2, 3, 4], vi=[4, 5, 6]. Identifique: n=3 (número de itens), W=5 (limite de peso), pesos wi=[2,3,4], valores vi=[4,5,6].",
                              "finalVerifications": [
                                "Liste corretamente os quatro parâmetros principais: n, W, wi, vi.",
                                "Descreva o tipo e restrições de cada um (ex: n inteiro positivo, wi > 0).",
                                "Identifique todos em uma instância de exemplo sem erros.",
                                "Explique a relação entre parâmetros (soma wi ≤ W).",
                                "Diferencie parâmetros de entrada de saída ou solução.",
                                "Crie uma instância simples com parâmetros corretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na nomenclatura e notação padrão (100% match).",
                                "Completude: todos os quatro parâmetros identificados.",
                                "Correção das descrições e restrições matemáticas.",
                                "Capacidade de aplicar em exemplos concretos.",
                                "Clareza na explicação verbal ou escrita.",
                                "Ausência de confusões entre parâmetros relacionados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores, conjuntos e desigualdades lineares.",
                                "Economia: Otimização de recursos limitados (knapsack como alocação orçamentária).",
                                "Física: Restrições de peso e volume em embalagens.",
                                "Gestão de Projetos: Seleção de tarefas com recursos finitos."
                              ],
                              "realWorldApplication": "Em logística de e-commerce, identificar parâmetros como número de produtos (n), limite de peso do caminhão (W), pesos e valores (preços) de itens para otimizar carregamentos e maximizar lucros em entregas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Formular a função objetivo e restrição",
                            "description": "Escrever a formulação matemática: maximizar ∑ vi * xi sujeito a ∑ wi * xi ≤ W, onde xi ∈ {0,1} ou [0,1] dependendo da variante, explicando o significado de cada termo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Elementos de Entrada do Problema",
                                  "subSteps": [
                                    "Identifique os itens disponíveis, cada um com um peso wi (peso do item i) e um valor vi (benefício ou valor do item i).",
                                    "Determine a capacidade máxima da mochila W (peso total permitido).",
                                    "Explique o objetivo geral: selecionar uma subconjunto de itens que maximize o valor total sem exceder W.",
                                    "Diferencie entre variantes: 0-1 (itens indivisíveis) e fracionária (itens divisíveis).",
                                    "Crie um exemplo simples com 3 itens para praticar."
                                  ],
                                  "verification": "Liste todos os parâmetros (n itens, wi, vi, W) com valores numéricos de um exemplo e explique cada um em uma frase.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Definição formal do problema da mochila (artigo ou página web)",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Sempre associe wi ao peso físico e vi ao valor econômico para evitar confusão.",
                                  "learningObjective": "Dominar os parâmetros de entrada e seu significado no contexto do problema.",
                                  "commonMistakes": "Confundir wi (peso) com vi (valor); ignorar a variante do problema (0-1 vs. fracionária)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir as Variáveis de Decisão",
                                  "subSteps": [
                                    "Introduza xi como a variável de decisão para o item i, onde i = 1 a n.",
                                    "Especifique o domínio: xi ∈ {0,1} para variante 0-1 (levar ou não o item inteiro).",
                                    "Para variante fracionária: xi ∈ [0,1] (fração do item i a levar).",
                                    "Justifique: xi=1 significa incluir o item, xi=0 excluir.",
                                    "Escreva a notação matemática para um exemplo com n=3."
                                  ],
                                  "verification": "Escreva a definição de xi com seu domínio para ambas as variantes e aplique a um exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Exemplo de problema da mochila"
                                  ],
                                  "tips": "Use subscritos (xi) para clareza e especifique sempre o domínio após a definição.",
                                  "learningObjective": "Saber representar matematicamente a escolha de cada item.",
                                  "commonMistakes": "Esquecer de especificar o domínio de xi; usar xi contínuo na variante 0-1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Função Objetivo",
                                  "subSteps": [
                                    "Escreva a função: maximizar Z = ∑_{i=1}^n vi * xi.",
                                    "Explique cada termo: vi é o valor do item i, xi indica se/quanto é incluído, soma totaliza o valor bruto.",
                                    "Adapte para variantes: mesma forma para 0-1 e fracionária.",
                                    "Teste com exemplo: calcule Z para uma seleção específica.",
                                    "Coloque em notação padrão de otimização: max Z = ... s.a. ..."
                                  ],
                                  "verification": "Escreva a função objetivo completa e compute Z para uma solução viável de exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/Jupyter",
                                    "Exemplo numérico"
                                  ],
                                  "tips": "Sempre use soma de i=1 a n e multiplique vi*xi explicitamente.",
                                  "learningObjective": "Construir e interpretar a expressão que quantifica o objetivo de maximização.",
                                  "commonMistakes": "Usar minimizar em vez de maximizar; inverter vi e wi na função."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular as Restrições e o Domínio Completo",
                                  "subSteps": [
                                    "Escreva a restrição de capacidade: ∑_{i=1}^n wi * xi ≤ W.",
                                    "Explique: soma dos pesos selecionados não excede a capacidade.",
                                    "Reafirme o domínio das variáveis: xi ∈ {0,1} ou [0,1} conforme variante.",
                                    "Combine tudo: max ∑ vi xi s.a. ∑ wi xi ≤ W e domínio de xi.",
                                    "Valide com exemplo: verifique se uma solução satisfaz a restrição."
                                  ],
                                  "verification": "Escreva o modelo completo e teste uma solução factível/infactível.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor LaTeX ou MathJax para fórmulas",
                                    "Exemplo numérico expandido"
                                  ],
                                  "tips": "Use ≤ para a restrição (não =, pois pode ser menor); inclua domínio explicitamente.",
                                  "learningObjective": "Completar a formulação matemática integral do problema.",
                                  "commonMistakes": "Esquecer a restrição ou usar > em vez de ≤; omitir domínio das xi."
                                }
                              ],
                              "practicalExample": "Considere 3 itens: item1 (w1=2kg, v1=3), item2 (w2=3kg, v2=4), item3 (w3=4kg, v3=5), W=5kg (variante 0-1). Formulação: max 3x1 + 4x2 + 5x3 s.a. 2x1 + 3x2 + 4x3 ≤ 5, xi ∈ {0,1}. Explicação: maximiza valor total sujeito a peso ≤5kg, itens inteiros.",
                              "finalVerifications": [
                                "Escreve corretamente a função objetivo com soma e multiplicação vi*xi.",
                                "Inclui a restrição de capacidade com wi*xi ≤ W.",
                                "Especifica o domínio de xi para a variante correta ({0,1} ou [0,1}).",
                                "Explica o significado de cada termo (vi, wi, xi, W).",
                                "Valida a formulação com um exemplo numérico simples.",
                                "Apresenta em notação padrão de otimização."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática da função objetivo e restrição (100% correto).",
                                "Clareza na explicação de cada símbolo e termo (detalhada e sem ambiguidades).",
                                "Correta distinção entre variantes 0-1 e fracionária.",
                                "Validação prática com exemplo (cálculo correto de viabilidade).",
                                "Uso de notação padrão e legível (somas, subscritos).",
                                "Completude: todos elementos (objetivo, restrição, domínio) presentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Programação Linear Inteira e Otimização Combinatória.",
                                "Economia: Alocação ótima de recursos limitados (orçamento).",
                                "Engenharia de Software: Modelagem de problemas NP-difíceis em algoritmos.",
                                "Gestão de Projetos: Restrições de tempo/recursos em planejamento."
                              ],
                              "realWorldApplication": "Em logística para otimizar carga em veículos com limite de peso (ex: aviões ou caminhões); em finanças para seleção de investimentos com orçamento fixo; em programação de jogos para inventários limitados por peso."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Classificar como problema NP-difícil",
                            "description": "Explicar por que o problema da mochila é um problema clássico de otimização combinatória e sua relação com classes de complexidade como NP-completo na versão de decisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal do Problema da Mochila",
                                  "subSteps": [
                                    "Relembre a versão de decisão do problema: dado um conjunto de itens com pesos e valores, capacidade W da mochila e alvo V, existe uma subseleção com peso ≤ W e valor ≥ V?",
                                    "Diferencie da versão de otimização: maximizar valor sujeito a peso ≤ W.",
                                    "Identifique entradas: n itens, arrays de pesos w_i, valores v_i, capacidade W, alvo V (para decisão).",
                                    "Escreva a formalização matemática: ∃ S ⊆ {1..n} tal que ∑_{i∈S} w_i ≤ W e ∑_{i∈S} v_i ≥ V?",
                                    "Discuta por que é combinatório: 2^n subconjuntos possíveis."
                                  ],
                                  "verification": "Escreva a definição formal em suas próprias palavras e liste 3 exemplos de instâncias válidas e inválidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência: Wikipedia 'Knapsack problem'",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use notação matemática clara para evitar ambiguidades.",
                                    "Desenhe uma mochila visual para ilustrar."
                                  ],
                                  "learningObjective": "Compreender precisamente o problema da mochila em suas variantes decisão e otimização.",
                                  "commonMistakes": [
                                    "Confundir versão de decisão com otimização.",
                                    "Ignorar restrições de peso exata vs. ≤ W.",
                                    "Esquecer que itens são indivisíveis (0-1 Knapsack)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar como Problema de Otimização Combinatória",
                                  "subSteps": [
                                    "Defina otimização combinatória: buscar solução ótima em espaço discreto finito.",
                                    "Explique por que Knapsack se encaixa: soluções são subconjuntos (discretos), objetivo maximizar valor.",
                                    "Compare com problemas enumerativos: tempo exponencial sem heurísticas.",
                                    "Discuta brute-force: testar todos 2^n subconjuntos, O(2^n * n).",
                                    "Relacione com P vs. NP: otimização difícil implica decisão difícil."
                                  ],
                                  "verification": "Classifique Knapsack em uma tabela comparando com Travelling Salesman e Subset Sum.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Quadro branco ou software de desenho",
                                    "Livro 'Computers and Intractability' de Garey & Johnson (cap. 10)",
                                    "Calculadora para complexidades"
                                  ],
                                  "tips": [
                                    "Pense em termos de enumeração exaustiva para intuitividade.",
                                    "Use analogias como 'escolher itens para mala'."
                                  ],
                                  "learningObjective": "Reconhecer Knapsack como clássico de otimização combinatória e suas implicações.",
                                  "commonMistakes": [
                                    "Confundir com problemas lineares contínuos.",
                                    "Subestimar o tamanho exponencial de 2^n.",
                                    "Ignorar que é pseudo-polinomial via DP."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Pertinência à Classe NP",
                                  "subSteps": [
                                    "Defina NP: problemas cujas soluções 'sim' podem ser verificadas em tempo polinomial.",
                                    "Para Knapsack decisão: dada uma subseleção S, verifique ∑ w_i ≤ W e ∑ v_i ≥ V em O(n).",
                                    "Escreva o verificador: algoritmo que soma pesos/valores da solução proposta.",
                                    "Confirme não-trivial: problema em NP (verificação fácil, mas encontrar solução difícil).",
                                    "Compare com P: Knapsack não conhecido em P, suspeita não estar."
                                  ],
                                  "verification": "Implemente um verificador pseudocódigo e teste com uma instância de 5 itens.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Exemplos de instâncias Knapsack online",
                                    "Compilador Python opcional"
                                  ],
                                  "tips": [
                                    "Foque na verificação, não resolução.",
                                    "Sempre inclua 'não' instâncias para testar."
                                  ],
                                  "learningObjective": "Provar que Knapsack-decisão está em NP via certificador polinomial.",
                                  "commonMistakes": [
                                    "Confundir verificação com resolução.",
                                    "Achar que soma é O(1), ignore O(n).",
                                    "Esquecer casos 'não'."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar NP-Dificuldade via Redução",
                                  "subSteps": [
                                    "Defina NP-difícil: todo problema em NP reduz polinomialmente a ele.",
                                    "Lembre redução padrão: de Subset Sum (NP-completo) para Knapsack.",
                                    "Construa redução: dado Subset Sum (pesos w_i, alvo T), crie Knapsack com v_i = w_i, V=T, W grande o suficiente.",
                                    "Prove polinomial: O(n) tempo para instância Knapsack.",
                                    "Conclua NP-completo: em NP + NP-difícil."
                                  ],
                                  "verification": "Escreva a redução formal para uma instância Subset Sum específica e verifique correção.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel para prova de redução",
                                    "Referência: CLRS 'Introduction to Algorithms' cap. 34",
                                    "Ferramenta LaTeX para fórmulas"
                                  ],
                                  "tips": [
                                    "Desenhe setas na redução: sim -> sim, não -> não.",
                                    "Escolha W = soma todos w_i para simplicidade."
                                  ],
                                  "learningObjective": "Estabelecer NP-completude de Knapsack-decisão via redução canônica.",
                                  "commonMistakes": [
                                    "Redução não polinomial.",
                                    "Falhar em preservar 'sim/não'.",
                                    "Confundir direção da redução."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere 3 itens: (peso 2, valor 3), (3,4), (4,5); W=5, V=7. Solução proposta: itens 1 e 3 (peso 6>5 inválido). Verificador rejeita. Solução válida: itens 2 e 3 (peso 7>5 inválido? Ajuste: itens 1 e 2 peso 5=5, valor 7>=7). Explique por que brute-force testa 8 subconjuntos, mas verificação é O(1) por subconjunto.",
                              "finalVerifications": [
                                "Defina formalmente Knapsack-decisão e prove verificador em O(n).",
                                "Classifique como otimização combinatória com análise de complexidade.",
                                "Construa redução de Subset Sum para Knapsack em pseudocódigo.",
                                "Diferencie NP, NP-completo e relação com otimização.",
                                "Resolva manualmente instância pequena e verifique NP-pertinência.",
                                "Explique por que não em P (ausência de algoritmo polinomial conhecido)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal e distinção decisão-otimização (30%).",
                                "Correta demonstração de pertinência a NP via verificador (25%).",
                                "Validade da redução polinomial para NP-dificuldade (25%).",
                                "Clareza em explicações combinatórias e complexidade (10%).",
                                "Uso de exemplos concretos e ausência de erros comuns (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Combinatória e Contagem (2^n subconjuntos).",
                                "Matemática: Programação Linear Inteira (relaxação LP para bounds).",
                                "Economia: Otimização de Recursos Limitados (alocação orçamentária).",
                                "Física: Problemas de Empacotamento (carga em veículos espaciais)."
                              ],
                              "realWorldApplication": "Em logística, otimizar carga de caminhões (peso W, valor=prioridade itens); em finanças, seleção de investimentos com risco limitado; criptografia (Subset Sum base para esquemas); bioinformática, seleção de genes com constraints."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Variante 0-1 do Problema da Mochila",
                        "description": "Características específicas da versão inteira (0-1), onde cada item pode ser selecionado no máximo uma vez, sem frações, e exemplos de aplicação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Descrever restrições da variante 0-1",
                            "description": "Definir xi ∈ {0,1} para cada item, destacando que itens não podem ser fracionados, e contrastar com outras variantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema da Mochila Geral",
                                  "subSteps": [
                                    "Ler a definição básica do problema da mochila: dado um conjunto de n itens com pesos w_i e valores v_i, e capacidade W da mochila, maximizar o valor total sem exceder W.",
                                    "Identificar os parâmetros principais: n, W, vetores w e v.",
                                    "Explicar o objetivo de otimização combinatória.",
                                    "Diferenciar de problemas triviais como soma simples.",
                                    "Visualizar com um diagrama simples de mochila e itens."
                                  ],
                                  "verification": "Escrever um resumo de 3-5 frases descrevendo o problema geral em suas próprias palavras.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Texto introdutório sobre Problema da Mochila; diagrama ilustrativo.",
                                  "tips": "Use analogias cotidianas como encher uma mala de viagem para fixar conceitos.",
                                  "learningObjective": "Dominar os fundamentos do problema da mochila antes de especializar em variantes.",
                                  "commonMistakes": "Ignorar a natureza NP-difícil do problema ou confundir com particionamento de soma."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir as Variáveis e Restrições da Variante 0-1",
                                  "subSteps": [
                                    "Introduzir a notação: para cada item i, definir variável binária x_i ∈ {0,1}, onde x_i=1 significa incluir o item inteiro.",
                                    "Escrever a função objetivo: maximizar ∑ v_i * x_i.",
                                    "Especificar a restrição de capacidade: ∑ w_i * x_i ≤ W.",
                                    "Enfatizar que x_i não pode ser fracionado: todo ou nada.",
                                    "Listar domínios: x_i binário para todo i=1 a n."
                                  ],
                                  "verification": "Escrever a formulação matemática completa da variante 0-1 em papel ou editor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel ou editor de texto; tabela de símbolos matemáticos.",
                                  "tips": "Use LaTeX ou ferramentas como Overleaf para praticar notação formal.",
                                  "learningObjective": "Formalizar matematicamente as restrições xi ∈ {0,1}.",
                                  "commonMistakes": "Escrever x_i ∈ [0,1] por engano, confundindo com variante fracionária."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Destacar Características Únicas das Restrições 0-1",
                                  "subSteps": [
                                    "Explicar impossibilidade de fracionamento: itens indivisíveis, justificando x_i binário.",
                                    "Discutir implicações: soluções exatas via programação dinâmica, mas exponencial em pior caso.",
                                    "Comparar informalmente com relaxação linear (permitir frações).",
                                    "Identificar restrições adicionais implícitas: w_i > 0, v_i ≥ 0, W ≥ 0.",
                                    "Verificar consistência: todos x_i independentes exceto pela soma de pesos."
                                  ],
                                  "verification": "Listar 4-6 restrições chave e justificar cada uma verbalmente ou por escrito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplos numéricos simples de instâncias 0-1.",
                                  "tips": "Pense em objetos reais como livros ou frutas que não se dividem.",
                                  "learningObjective": "Internalizar por que '0-1' implica indivisibilidade.",
                                  "commonMistakes": "Assumir que v_i podem ser negativos ou ignorar não-negatividade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com Outras Variantes do Problema da Mochila",
                                  "subSteps": [
                                    "Descrever variante fracionária: x_i ∈ [0,1], permitindo frações, resolvível por guloso.",
                                    "Explicar variante ilimitada (unbounded): x_i ∈ ℕ₀, múltiplas cópias permitidas.",
                                    "Comparar complexidades: 0-1 é NP-difícil, fracionária polinomial.",
                                    "Destacar diferenças nas restrições: binário vs contínuo vs inteiro não-negativo.",
                                    "Criar tabela comparativa com exemplos numéricos para cada."
                                  ],
                                  "verification": "Preencher tabela comparativa corretamente e explicar uma diferença chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela modelo em Excel ou papel; exemplos de cada variante.",
                                  "tips": "Use cores para destacar diferenças nas tabelas.",
                                  "learningObjective": "Diferenciar claramente a 0-1 de outras para reforçar suas restrições únicas.",
                                  "commonMistakes": "Confundir unbounded com 0-1 ou ignorar diferenças de solucionabilidade."
                                }
                              ],
                              "practicalExample": "Considere 3 itens: Item1 (peso 2, valor 3), Item2 (peso 3, valor 4), Item3 (peso 4, valor 5), W=5. Descreva restrições 0-1: x1,x2,x3 ∈ {0,1}; maximizar 3x1+4x2+5x3 s.a. 2x1+3x2+4x3 ≤5. Não fracionar: ex., não pegar 0.5 de Item3.",
                              "finalVerifications": [
                                "Definir corretamente x_i ∈ {0,1} para todos itens.",
                                "Escrever função objetivo e restrição de capacidade sem erros.",
                                "Explicar indivisibilidade em contexto prático.",
                                "Contrastar com fracionária (x_i∈[0,1]) e ilimitada (x_i∈ℕ).",
                                "Identificar pelo menos 3 implicações das restrições 0-1.",
                                "Aplicar a um exemplo numérico pequeno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (x_i binário, somatórios corretos).",
                                "Clareza na explicação de indivisibilidade vs fracionamento.",
                                "Correção no contraste com outras variantes.",
                                "Uso de exemplos concretos para ilustrar restrições.",
                                "Completude: cobrir objetivo, restrições e domínios.",
                                "Profundidade: mencionar complexidade ou solucionadores."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Programação Linear Inteira e Otimização Combinatória.",
                                "Economia: Alocação ótima de recursos limitados em orçamentos.",
                                "Gestão de Projetos: Seleção de tarefas indivisíveis com restrições de tempo.",
                                "Logística: Planejamento de cargas sem divisão de pacotes."
                              ],
                              "realWorldApplication": "Em e-commerce, selecionar produtos inteiros para uma entrega com limite de peso (ex.: Amazon otimizar frete); em finanças, escolher investimentos indivisíveis (ações) dentro de um portfólio com restrição de capital."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Resolver instância pequena manualmente",
                            "description": "Calcular a solução ótima para uma instância com n=3 itens, capacidade W=5, demonstrando enumeração exaustiva e seleção de subconjunto ótimo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a instância do problema da mochila 0-1",
                                  "subSteps": [
                                    "Especifique n=3 itens com pesos e valores: Item A (peso=2, valor=3), Item B (peso=3, valor=4), Item C (peso=1, valor=2).",
                                    "Defina a capacidade da mochila W=5.",
                                    "Crie uma tabela com colunas: Item, Peso, Valor.",
                                    "Registre a restrição: soma de pesos ≤ W, maximizar soma de valores.",
                                    "Desenhe uma representação visual da mochila com capacidade 5."
                                  ],
                                  "verification": "Tabela preenchida corretamente com itens, pesos e valores exatos, e W=5 anotado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Planilha ou tabela impressa"
                                  ],
                                  "tips": "Use abreviações como A, B, C para simplificar anotações.",
                                  "learningObjective": "Compreender e formalizar uma instância pequena do problema da mochila 0-1.",
                                  "commonMistakes": [
                                    "Confundir pesos com valores",
                                    "Esquecer a capacidade W=5"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enumerar todos os subconjuntos possíveis exaustivamente",
                                  "subSteps": [
                                    "Liste todos os 2^3 = 8 subconjuntos: {}, {A}, {B}, {C}, {A,B}, {A,C}, {B,C}, {A,B,C}.",
                                    "Represente cada subconjunto usando notação de conjunto ou binário (000 a 111).",
                                    "Crie uma tabela com colunas: Subconjunto, Itens Selecionados.",
                                    "Verifique se todos os 8 subconjuntos foram gerados sem duplicatas ou omissões.",
                                    "Ordene os subconjuntos logicamente, como por tamanho crescente."
                                  ],
                                  "verification": "Lista completa de 8 subconjuntos únicos listados corretamente na tabela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de subconjuntos pré-formatada"
                                  ],
                                  "tips": "Use representação binária: bit 1 para A, bit 2 para B, bit 3 para C, para sistematizar.",
                                  "learningObjective": "Dominar a enumeração exaustiva de subconjuntos para n pequeno.",
                                  "commonMistakes": [
                                    "Omitir subconjunto vazio",
                                    "Duplicar subconjuntos",
                                    "Confundir ordem dos itens"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular pesos e valores para cada subconjunto e filtrar viáveis",
                                  "subSteps": [
                                    "Para cada subconjunto, some os pesos e valores dos itens selecionados.",
                                    "Adicione colunas à tabela: Peso Total, Valor Total, Viável (Sim se ≤5, Não caso contrário).",
                                    "Exemplo: {A,B} → Peso=5, Valor=7, Viável=Sim; {A,B,C} → Peso=6, Valor=9, Viável=Não.",
                                    "Preencha a tabela completamente para todos os 8 subconjuntos.",
                                    "Destaque os subconjuntos viáveis em negrito ou cor."
                                  ],
                                  "verification": "Tabela atualizada com cálculos corretos de peso e valor para todos subconjuntos, e filtro viável preciso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora simples (opcional)"
                                  ],
                                  "tips": "Some passo a passo: confirme 2+3=5 para {A,B}, evite erros aritméticos.",
                                  "learningObjective": "Avaliar viabilidade e computar métricas de cada subconjunto.",
                                  "commonMistakes": [
                                    "Erros de soma em pesos/valores",
                                    "Marcar viável incorretamente para W=5"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar o subconjunto ótimo e justificar",
                                  "subSteps": [
                                    "Entre os subconjuntos viáveis, identifique o de maior valor total.",
                                    "Exemplo: Viáveis - {}:0, {A}:3, {B}:4, {C}:2, {A,B}:7, {A,C}:5, {B,C}:6 → Ótimo: {A,B} com 7.",
                                    "Registre o subconjunto ótimo, seu peso, valor e por que é superior aos outros.",
                                    "Verifique se há empates e como resolvê-los (ex: preferir menor peso).",
                                    "Escreva uma justificativa em 2-3 frases."
                                  ],
                                  "verification": "Subconjunto ótimo {A,B} selecionado corretamente com valor 7, tabela final completa e justificativa clara.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela completa dos passos anteriores"
                                  ],
                                  "tips": "Compare apenas viáveis; ignore inválidos após filtro.",
                                  "learningObjective": "Identificar e justificar a solução ótima via enumeração exaustiva.",
                                  "commonMistakes": [
                                    "Escolher inválido como ótimo",
                                    "Ignorar subconjunto com maior valor"
                                  ]
                                }
                              ],
                              "practicalExample": "Para itens A(p=2,v=3), B(p=3,v=4), C(p=1,v=2) e W=5: Subconjuntos viáveis incluem {A,B} (p=5,v=7) como ótimo, superando {B,C}(p=4,v=6). Tabela final confirma enumeração exaustiva.",
                              "finalVerifications": [
                                "Todos os 8 subconjuntos enumerados corretamente.",
                                "Cálculos de peso e valor precisos para cada subconjunto.",
                                "Filtro viável correto (apenas ≤W=5).",
                                "Subconjunto ótimo {A,B} com valor 7 identificado.",
                                "Justificativa escrita explicando por que é ótimo.",
                                "Tabela completa sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na enumeração (100% dos subconjuntos).",
                                "Correção nos cálculos de soma (zero erros).",
                                "Identificação correta do ótimo e viáveis.",
                                "Clareza na tabela e organização visual.",
                                "Justificativa lógica e concisa.",
                                "Compreensão demonstrada em verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e potências de conjuntos (2^n subconjuntos).",
                                "Economia: Otimização de recursos limitados e alocação eficiente.",
                                "Programação: Base para implementação de brute-force em algoritmos.",
                                "Estatística: Análise de todos os cenários possíveis em amostras pequenas."
                              ],
                              "realWorldApplication": "Em logística, selecionar itens de carga máxima valor dentro de limite de peso de um veículo; em finanças, escolher investimentos com retorno máximo sob restrição de capital."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.2.3",
                            "name": "Identificar propriedades de NP-completude",
                            "description": "Reconhecer que a variante 0-1 é NP-completa via redução polinomial do problema de partição ou subconjunto soma.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de NP e NP-completude",
                                  "subSteps": [
                                    "Defina formalmente as classes P, NP e NP-completo.",
                                    "Explique a diferença entre problemas de decisão e otimização.",
                                    "Liste as propriedades que todos os problemas NP-completos compartilham.",
                                    "Revise o teorema de Cook-Levin e seu significado.",
                                    "Identifique exemplos clássicos de problemas NP-completos."
                                  ],
                                  "verification": "Resuma em suas palavras o que significa um problema ser NP-completo e liste 3 exemplos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to Algorithms' (Cormen et al.), Capítulo 34",
                                    "Notas de aula sobre teoria da complexidade",
                                    "Vídeo Khan Academy sobre P vs NP"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar as relações entre P, NP e NPC.",
                                  "learningObjective": "Dominar as definições básicas para contextualizar reduções.",
                                  "commonMistakes": [
                                    "Confundir NP-completo com intratável",
                                    "Ignorar que NPC estão em NP",
                                    "Achar que todos os problemas NP são NPC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar os problemas Subset Sum e Partition como conhecidos NP-completos",
                                  "subSteps": [
                                    "Defina formalmente o problema Subset Sum: dada uma instância com inteiros positivos e alvo B, existe subconjunto que soma exatamente B?",
                                    "Defina o problema Partition: dado conjunto de inteiros, existe bipartição com somas iguais?",
                                    "Prove ou revise por que Partition reduz para Subset Sum em tempo polinomial.",
                                    "Confirme via referências que ambos são NP-completos.",
                                    "Pratique com exemplos pequenos para intuitivamente entender sua dureza."
                                  ],
                                  "verification": "Resolva manualmente 2 instâncias de Subset Sum e explique por que brute-force é exponencial.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos ou slides sobre problemas NP-completos clássicos",
                                    "Ferramenta online para verificação de Subset Sum",
                                    "Papel e caneta para exemplos"
                                  ],
                                  "tips": "Comece com instâncias pequenas (n=3-5 itens) para ver o crescimento exponencial.",
                                  "learningObjective": "Reconhecer problemas base para reduções.",
                                  "commonMistakes": [
                                    "Confundir Subset Sum com Knapsack diretamente",
                                    "Esquecer que Partition é uma especialização",
                                    "Não notar o tempo polinomial da redução Partition -> Subset Sum"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender o conceito de redução polinomial",
                                  "subSteps": [
                                    "Defina redução polinomial: transforme instância de A para B em tempo polinomial, preservando sim/não.",
                                    "Explique por que se A é NP-completo e A reduz para B, então B é NP-duro.",
                                    "Discuta como mostrar que B está em NP (certificado polinomial).",
                                    "Estude exemplos simples como SAT -> Clique.",
                                    "Pratique esboçando uma redução fictícia."
                                  ],
                                  "verification": "Descreva os 3 requisitos para uma redução polinomial válida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Capítulo sobre reduções em 'Computers and Intractability' (Garey & Johnson)",
                                    "Vídeos MIT OCW sobre teoria da computação"
                                  ],
                                  "tips": "Pense na redução como uma 'tradução' que preserva a resposta.",
                                  "learningObjective": "Entender o mecanismo chave para provar NP-completude.",
                                  "commonMistakes": [
                                    "Reduções não-polinomiais",
                                    "Não preservar a resposta sim/não",
                                    "Confundir dureza com membership em NP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a redução polinomial de Subset Sum para 0-1 Knapsack",
                                  "subSteps": [
                                    "Dada instância Subset Sum: itens a1..an >0, alvo B.",
                                    "Crie instância Knapsack: pesos wi=ai, valores vi=ai, capacidade W=B.",
                                    "Argumente: existe subconjunto soma=B iff OPT(Knapsack)=B.",
                                    "Mostre que a transformação é O(n) tempo (polinomial).",
                                    "Confirme que 0-1 Knapsack decisão está em NP (certificado: subconjunto selecionado)."
                                  ],
                                  "verification": "Aplique a redução a uma instância específica e verifique manualmente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos numéricos em papel",
                                    "Pseudocódigo da redução",
                                    "Referência: prova em Sipser 'Introduction to the Theory of Computation'"
                                  ],
                                  "tips": "Use vi=wi para alinhar valor e peso perfeitamente.",
                                  "learningObjective": "Executar a prova de NP-completude para 0-1 Knapsack.",
                                  "commonMistakes": [
                                    "Usar capacidades ou valores errados",
                                    "Esquecer mostrar polinomialidade",
                                    "Não provar ambas as direções da iff"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e praticar a identificação de propriedades NP-completas",
                                  "subSteps": [
                                    "Resuma a prova completa: Subset Sum NPC -> reduz para Knapsack -> Knapsack NPC.",
                                    "Identifique por que Knapsack otimização implica decisão NP-completa.",
                                    "Pratique invertendo: dada Knapsack, reconstrua Subset Sum.",
                                    "Discuta implicações: sem P=NP, sem poly-time exato.",
                                    "Teste com variações (ex: unbounded Knapsack)."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que 0-1 Knapsack é NP-completo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exercícios de livros texto",
                                    "Quiz online sobre complexidade"
                                  ],
                                  "tips": "Memorize a redução chave: pesos=valores=ai, W=B.",
                                  "learningObjective": "Aplicar independentemente a identificação.",
                                  "commonMistakes": [
                                    "Confundir 0-1 com fractional",
                                    "Ignorar que decisão basta para NPC",
                                    "Achar redução não-polinomial"
                                  ]
                                }
                              ],
                              "practicalExample": "Instância Subset Sum: {3,5,2,6}, B=8. Redução: Knapsack wi=vi=[3,5,2,6], W=8. OPT=8? Sim (3+5). Verifique: subconjunto {3,5} soma 8.",
                              "finalVerifications": [
                                "Explique corretamente a redução Subset Sum -> 0-1 Knapsack.",
                                "Identifique que a transformação é O(n) e preserva resposta.",
                                "Confirme que 0-1 Knapsack está em NP.",
                                "Distinga de variantes não-NP-completas como fractional Knapsack.",
                                "Aplique redução a nova instância sem erros.",
                                "Discuta implicações para algoritmos aproximados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da redução (correta iff e polinomialidade).",
                                "Compreensão de NP-membership para Knapsack.",
                                "Capacidade de reproduzir prova passo-a-passo.",
                                "Identificação correta de erros comuns em reduções.",
                                "Aplicação prática em exemplos numéricos.",
                                "Conexão com problemas relacionados como Partition."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e somas de subconjuntos.",
                                "Lógica: Provas por contradição e reduções em lógica computacional.",
                                "Economia: Modelagem de otimização de recursos limitados.",
                                "Física: Problemas de empacotamento em simulações.",
                                "Engenharia de Software: Análise de viabilidade de algoritmos."
                              ],
                              "realWorldApplication": "Em logística para otimização de cargas (ex: aviões), onde decisões exatas são intratáveis, levando ao uso de heurísticas ou aproximações em sistemas de roteirização e alocação de recursos em empresas como Amazon ou UPS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.3",
                        "name": "Variante Fracionária do Problema da Mochila",
                        "description": "Características da versão relaxada, permitindo frações de itens, e sua relação com programação linear e algoritmos gulosos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.3.1",
                            "name": "Descrever restrições da variante fracionária",
                            "description": "Definir xi ∈ [0,1], permitindo frações, e explicar que é solucionável em tempo polinomial via ordenação por densidade vi/wi.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema da Mochila 0/1 para Contextualizar",
                                  "subSteps": [
                                    "Lembre-se das restrições do problema 0/1: cada item i tem valor vi e peso wi, xi ∈ {0,1} (todo ou nada).",
                                    "Capacidade da mochila W: soma(wi * xi) ≤ W.",
                                    "Objetivo: maximizar soma(vi * xi).",
                                    "Discuta por que é NP-difícil.",
                                    "Anote as diferenças chave para a variante fracionária."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases comparando com a variante fracionária.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência ao problema 0/1 knapsack (livro ou online)"
                                  ],
                                  "tips": "Use um diagrama simples para visualizar itens inteiros vs. fracionados.",
                                  "learningObjective": "Compreender o contexto base para destacar diferenças na variante fracionária.",
                                  "commonMistakes": [
                                    "Confundir xi como fracionário no 0/1",
                                    "Ignorar a NP-dificuldade do 0/1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Variante Fracionária do Problema da Mochila",
                                  "subSteps": [
                                    "Introduza a permissão para frações: cada item pode ser dividido.",
                                    "Defina formalmente: xi ∈ [0,1], onde xi=1 é item inteiro, xi<1 é fração.",
                                    "Escreva a restrição de capacidade: ∑(wi * xi) ≤ W.",
                                    "Objetivo permanece: maximizar ∑(vi * xi).",
                                    "Compare com 0/1: agora relaxação linear."
                                  ],
                                  "verification": "Formule as equações matemáticas em um papel ou ferramenta LaTeX.",
                                  "estimatedTime": "20-25 minutes",
                                  "materials": [
                                    "Calculadora ou software matemático (ex: GeoGebra, Python)",
                                    "Templates de fórmulas"
                                  ],
                                  "tips": "Use notação ∑ para somas e destaque o intervalo [0,1] visualmente.",
                                  "learningObjective": "Definir precisamente a variante permitindo divisão de itens.",
                                  "commonMistakes": [
                                    "Permitir xi >1",
                                    "Confundir com múltiplos itens idênticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar Todas as Restrições e Propriedades",
                                  "subSteps": [
                                    "Liste restrições: wi >0, vi >0 para todo i; W >0; n itens.",
                                    "Enfatize xi ∈ [0,1] como relaxação contínua.",
                                    "Discuta viabilidade: soluções fracionárias sempre possíveis.",
                                    "Mencione solucionabilidade em tempo polinomial.",
                                    "Escreva pseudocódigo básico da ordenação por densidade vi/wi."
                                  ],
                                  "verification": "Crie uma tabela listando todas as restrições com exemplos numéricos.",
                                  "estimatedTime": "25-30 minutes",
                                  "materials": [
                                    "Planilha (Excel/Google Sheets)",
                                    "Exemplos de dados de knapsack"
                                  ],
                                  "tips": "Ordene itens por densidade descendente: vi/wi alto primeiro.",
                                  "learningObjective": "Listar e explicar todas as restrições formais da variante.",
                                  "commonMistakes": [
                                    "Esquecer wi,vi >0",
                                    "Achar que é NP-difícil como 0/1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Solução Polinomial via Greedy",
                                  "subSteps": [
                                    "Algoritmo: Ordene itens por densidade δi = vi/wi decrescente.",
                                    "Preencha mochila: tome frações até W esgotar.",
                                    "Prove otimalidade: greedy choice property para densidade.",
                                    "Calcule tempo: O(n log n) por ordenação.",
                                    "Compare complexidade com 0/1 (exponencial vs. polinomial)."
                                  ],
                                  "verification": "Aplique o algoritmo manualmente a um exemplo pequeno e verifique otimalidade.",
                                  "estimatedTime": "20-30 minutes",
                                  "materials": [
                                    "Papel para cálculos",
                                    "Ferramenta de programação (Python para simular)"
                                  ],
                                  "tips": "Sempre normalize densidades para evitar erros de escala.",
                                  "learningObjective": "Descrever por que e como resolver em tempo polinomial.",
                                  "commonMistakes": [
                                    "Ordenar por vi ou wi sozinho",
                                    "Ignorar prova de otimalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Mochila W=10. Itens: (v1=60,w1=10, δ=6), (v2=100,w2=20, δ=5), (v3=120,w3=30, δ=4). Ordenar:1,2,3. Tome item1 inteiro (10), fração 0/10 de item2 (W cheio). Valor=60 (ótimo).",
                              "finalVerifications": [
                                "Pode definir xi ∈ [0,1] corretamente?",
                                "Lista todas restrições (capacidade, não-negatividade)?",
                                "Explica ordenação por vi/wi?",
                                "Distingue de 0/1 knapsack?",
                                "Menciona tempo O(n log n)?",
                                "Aplica a um exemplo numérico?"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas restrições (xi intervalo correto).",
                                "Clareza na descrição de diferenças vs. 0/1.",
                                "Explicação completa da solução greedy.",
                                "Uso correto de terminologia (densidade, relaxação).",
                                "Exemplo prático com cálculos exatos.",
                                "Conexão com complexidade polinomial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Programação Linear e Relaxações.",
                                "Economia: Alocação ótima de recursos limitados.",
                                "Física: Otimização em misturas (ex: ligas metálicas).",
                                "Engenharia: Gerenciamento de carga em projetos.",
                                "Estatística: Seleção de features em ML."
                              ],
                              "realWorldApplication": "Em logística, otimizar carga fracionada em aviões (peso vs. valor de carga); em finanças, alocar portfólios fracionários de ativos por retorno/risco; em dietética, misturar alimentos por nutrientes/calorias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.3.2",
                            "name": "Aplicar algoritmo guloso",
                            "description": "Implementar mentalmente o algoritmo guloso: ordenar itens por vi/wi decrescente, preencher mochila sequencialmente até W, calculando valor ótimo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados da instância do problema",
                                  "subSteps": [
                                    "Liste todos os itens com seus valores (vi) e pesos (wi).",
                                    "Identifique a capacidade total da mochila (W).",
                                    "Calcule a razão vi/wi para cada item individualmente.",
                                    "Registre as razões com pelo menos duas casas decimais para precisão.",
                                    "Verifique se todos os pesos wi são positivos e vi >= 0."
                                  ],
                                  "verification": "Confira se as razões foram calculadas corretamente comparando com um cálculo manual duplo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Folha com dados da instância (itens, vi, wi, W)"
                                  ],
                                  "tips": [
                                    "Use uma tabela para organizar: colunas para item, vi, wi, vi/wi.",
                                    "Arredonde ratios apenas no final para evitar erros de propagação."
                                  ],
                                  "learningObjective": "Compreender e extrair os parâmetros essenciais do problema da mochila fracionária.",
                                  "commonMistakes": [
                                    "Esquecer de dividir vi por wi corretamente.",
                                    "Usar wi/vi em vez de vi/wi.",
                                    "Ignorar itens com wi=0."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ordenar os itens por razão vi/wi em ordem decrescente",
                                  "subSteps": [
                                    "Compare as razões calculadas pairwise para determinar a ordem.",
                                    "Coloque o item com maior vi/wi no topo da lista.",
                                    "Continue comparando e rearranjando até que a lista esteja totalmente ordenada.",
                                    "Anote a lista ordenada com itens, vi, wi e ratios.",
                                    "Confirme que não há inversões: todo item anterior tem ratio >= posterior."
                                  ],
                                  "verification": "Teste a ordenação verificando se ratio[i] >= ratio[i+1] para todos i.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel com tabela do Step 1",
                                    "Caneta para riscar e reorganizar"
                                  ],
                                  "tips": [
                                    "Para poucos itens, use ordenação por inserção manual; visualize como pilha.",
                                    "Em caso de empate em ratio, priorize itens com menor wi."
                                  ],
                                  "learningObjective": "Dominar a ordenação decrescente baseada na densidade de valor (vi/wi).",
                                  "commonMistakes": [
                                    "Ordenar por vi ou wi absoluto em vez de ratio.",
                                    "Ordenar crescente em vez de decrescente.",
                                    "Trocar vi e wi durante comparações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher a mochila sequencialmente com itens ordenados",
                                  "subSteps": [
                                    "Inicialize peso atual (currentW) = 0 e valor total (totalV) = 0.",
                                    "Para cada item na ordem: se wi <= W - currentW, adicione inteiro (totalV += vi, currentW += wi).",
                                    "Se wi > W - currentW, adicione fração: fração = (W - currentW)/wi, totalV += fração * vi, pare.",
                                    "Registre o que foi adicionado para cada item (inteiro ou fração).",
                                    "Pare quando a mochila estiver cheia ou todos itens processados."
                                  ],
                                  "verification": "Verifique se currentW <= W e não há espaço para mais valor sem exceder.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista ordenada do Step 2",
                                    "Calculadora simples para frações"
                                  ],
                                  "tips": [
                                    "Sempre subtraia currentW de W antes de decidir fração.",
                                    "Anote frações como decimais para facilitar cálculos."
                                  ],
                                  "learningObjective": "Aplicar a seleção gulosa permitindo fracionamento para maximizar valor.",
                                  "commonMistakes": [
                                    "Adicionar itens fora de ordem.",
                                    "Esquecer de fracionar o último item.",
                                    "Exceder W por erro aritmético."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e validar o valor ótimo obtido",
                                  "subSteps": [
                                    "Some todos os valores parciais (vi inteiros + vi fracionados).",
                                    "Confirme que currentW == W ou todos itens foram considerados.",
                                    "Compare com uma solução alternativa simples (ex: melhor item único) para validar superioridade.",
                                    "Documente a solução: itens selecionados, frações, totalV.",
                                    "Explique por que é ótimo: guloso por densidade garante no fracionário."
                                  ],
                                  "verification": "O totalV deve ser máximo possível sem exceder W; teste com permutações pequenas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Resultados dos Steps anteriores",
                                    "Papel para somas finais"
                                  ],
                                  "tips": [
                                    "Use soma progressiva para evitar erros de acúmulo.",
                                    "Lembre: no fracionário, guloso é ótimo por prova de troca."
                                  ],
                                  "learningObjective": "Verificar e justificar a otimalidade da solução gulosa.",
                                  "commonMistakes": [
                                    "Arredondar frações prematuramente.",
                                    "Confundir com mochila 0/1 (não fracionária).",
                                    "Subestimar valor por erro na fração."
                                  ]
                                }
                              ],
                              "practicalExample": "Itens: A (v=60, w=10, ratio=6), B (v=100, w=20, ratio=5), C (v=120, w=30, ratio=4). W=50. Ordenado: A,B,C. Adicione A (currentW=10, totalV=60), B (currentW=30, totalV=160), fração C=20/30=2/3, totalV=160+80=240. Solução ótima.",
                              "finalVerifications": [
                                "Ordena corretamente itens por vi/wi decrescente.",
                                "Seleciona itens sequencialmente sem exceder W.",
                                "Calcula frações precisamente quando necessário.",
                                "Soma valores corretamente para totalV.",
                                "Justifica por que a solução é ótima no caso fracionário.",
                                "Aplica a múltiplas instâncias sem erros repetidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ratios (erro < 0.01).",
                                "Ordenação 100% correta.",
                                "Seleção gulosa sem violações de capacidade.",
                                "Cálculo de valor total exato.",
                                "Explicação clara da heurística e otimalidade.",
                                "Tempo de execução mental eficiente (<45 min total)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de razões, frações e ordenação.",
                                "Economia: Otimização de recursos limitados (orçamento knapsack).",
                                "Física: Alocação de carga em veículos com limite de peso.",
                                "Gestão: Priorização de tarefas por 'valor por esforço'.",
                                "Estatística: Seleção de features por densidade de informação."
                              ],
                              "realWorldApplication": "Em logística, um entregador maximiza lucro carregando produtos em uma van com limite de peso 50kg, priorizando itens de alto valor por kg (ex: eletrônicos vs perecíveis), fracionando volumes se necessário."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.4",
                        "name": "Análise de Complexidade",
                        "description": "Comparação das complexidades das variantes, incluindo tempo pseudo-polinomial para 0-1 via PD e polinomial para fracionária.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.4.1",
                            "name": "Analisar complexidade da variante 0-1",
                            "description": "Derivar O(nW) para solução exata via programação dinâmica e explicar por que é pseudo-polinomial, exponencial em casos gerais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Formulação da Programação Dinâmica para 0-1 Knapsack",
                                  "subSteps": [
                                    "Relembre o problema: dado n itens com pesos w_i e valores v_i, e capacidade W, maximize valor sem exceder W, cada item 0 ou 1 vez.",
                                    "Estude a recursão padrão: dp[i][w] = max(dp[i-1][w], dp[i-1][w - w_i] + v_i) se w >= w_i, senão dp[i-1][w].",
                                    "Implemente mentalmente ou no papel a tabela DP de tamanho (n+1) x (W+1).",
                                    "Preencha uma tabela pequena (n=2, W=5) para visualizar preenchimento bottom-up.",
                                    "Identifique os loops: for i=1 to n, for w=0 to W."
                                  ],
                                  "verification": "Construa e preencha corretamente uma tabela DP para um exemplo pequeno e confirme o valor ótimo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, pseudocódigo de DP para 0-1 Knapsack, calculadora opcional.",
                                  "tips": "Sempre inicialize dp[0][w] = 0 e dp[i][0] = 0 para casos base.",
                                  "learningObjective": "Compreender a estrutura da tabela DP e o processo de preenchimento iterativo.",
                                  "commonMistakes": "Confundir com unbounded knapsack (permitir múltiplas instâncias); ignorar ordem bottom-up."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Complexidade Temporal da Solução DP",
                                  "subSteps": [
                                    "Conte as dimensões da tabela: (n+1) linhas por (W+1) colunas, total O(nW) células.",
                                    "Analise os loops aninhados: loop externo sobre i (n iterações), interno sobre w (W+1 iterações).",
                                    "Por célula, o tempo é O(1): uma comparação max e uma subtração condicional.",
                                    "Some inicializações: O(nW) para zerar tabela, mas dominante é preenchimento.",
                                    "Conclua tempo total Θ(nW), onde n é número de itens, W capacidade."
                                  ],
                                  "verification": "Escreva a análise big-O passo a passo e confirme com contagem manual em exemplo pequeno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para análise assintótica, tabela de exemplo preenchida do step 1.",
                                  "tips": "Use notação Θ para tight bound; foque em operações dominantes nos loops.",
                                  "learningObjective": "Calcular precisamente a complexidade temporal a partir da estrutura algorítmica.",
                                  "commonMistakes": "Contar apenas uma dimensão (ex: O(n) ou O(W)); esquecer loops aninhados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Complexidade Espacial e Inicializações",
                                  "subSteps": [
                                    "Discuta espaço: tabela completa O(nW), mas otimizável para O(W) com array 1D.",
                                    "Verifique inicializações: duas linhas/colunas zeradas em O(n + W), negligible.",
                                    "Compare com recursão pura: exponencial sem memoização.",
                                    "Meça operações reais: cada célula ~2 acessos array + 1 max + 1 if.",
                                    "Confirme que tempo é pseudo-polinomial pois depende de W numérico."
                                  ],
                                  "verification": "Otimize código mental para O(W) espaço e rederive tempo como O(nW).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Pseudocódigo otimizado, quadro branco para diagramas de memória.",
                                  "tips": "Otimização espacial não afeta tempo; use backward fill para 1D array.",
                                  "learningObjective": "Entender trade-offs espaço-tempo e otimizações práticas.",
                                  "commonMistakes": "Afirmar O(W) tempo após otimização espacial; ignorar dependência em W."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar como Pseudo-Polinomial e Explicar Comportamento Exponencial",
                                  "subSteps": [
                                    "Defina pseudo-polinomial: polinomial em valor numérico de input (W), mas exponencial em bits log W.",
                                    "Exemplo: W=10^6 é polinomial, mas input binário tem 20 bits, exponencial em tamanho input.",
                                    "Discuta NP-completo: sem poly-time em n + log W a menos que P=NP.",
                                    "Casos gerais: W exponencial em n leva a tempo exponencial prático.",
                                    "Compare com unbounded knapsack: verdadeiramente polinomial O(nW)."
                                  ],
                                  "verification": "Escreva parágrafo explicando por que O(nW) é pseudo-polinomial com exemplo numérico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Referências teóricas (ex: CLRS capítulo NP), exemplos com W grande vs log W.",
                                  "tips": "Lembre: tamanho input é O(n log (max w_i, v_i, W)); poly em valores ≠ poly em input size.",
                                  "learningObjective": "Diferenciar polynomial, pseudo-polynomial e exponential em teoria da complexidade.",
                                  "commonMistakes": "Confundir com polinomial verdadeiro; achar que DP resolve em poly-time sempre."
                                }
                              ],
                              "practicalExample": "Para n=3 itens (w=[1,3,4], v=[1,4,5]), W=7: tabela DP 4x8 tem 32 células, loops fazem ~3*8=24 iterações principais, cada O(1), total ~O(24)=O(nW). Preencha: dp[3][7]=9. Conte operações manualmente para validar O(nW).",
                              "finalVerifications": [
                                "Deriva corretamente O(nW) temporal e O(W) espacial otimizado.",
                                "Explica com precisão o que é pseudo-polinomialidade usando tamanho do input.",
                                "Identifica quando solução é impraticável (W >> n).",
                                "Compara corretamente com variantes como unbounded knapsack.",
                                "Aplica análise a exemplo concreto sem erros aritméticos.",
                                "Discute implicações para NP-completude."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação assintótica (loops, operações por célula).",
                                "Clareza na distinção pseudo-polinomial vs polinomial/exponencial.",
                                "Uso correto de notação big-O/Θ e exemplos numéricos.",
                                "Profundidade na análise de otimizações e casos extremos.",
                                "Capacidade de verbalizar explicações teóricas coerentemente.",
                                "Ausência de confusões com outras variantes de knapsack."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e contagem combinatoria em loops.",
                                "Economia: Otimização de recursos limitados em alocação de portfólio.",
                                "Física: Problemas de empacotamento em logística de cargas.",
                                "Estatística: Trade-offs em modelos de otimização probabilística."
                              ],
                              "realWorldApplication": "Em logística, otimizar carga de aviões (itens únicos, peso limite W); em finanças, selecionar investimentos mutuamente exclusivos maximizando retorno sob orçamento; soluções DP usadas quando W gerenciável (~10^5), aproximando para W grande."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.1.4.2",
                            "name": "Comparar complexidades das variantes",
                            "description": "Contrastar O(n log n) guloso para fracionária vs. O(nW) PD para 0-1, e discutir aproximações e heurísticas para 0-1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Variantes do Problema da Mochila",
                                  "subSteps": [
                                    "Defina o problema da mochila 0-1: itens indivisíveis, maximizar valor sem exceder peso W.",
                                    "Defina o problema fracionário: itens podem ser fracionados.",
                                    "Liste diferenças chave: restrições de integridade e soluções ótimas.",
                                    "Revise algoritmo guloso para fracionário: ordenar por densidade valor/peso.",
                                    "Revise programação dinâmica (PD) para 0-1: preencher tabela de estados."
                                  ],
                                  "verification": "Escreva um resumo de 1 parágrafo diferenciando as variantes e seus algoritmos principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre Knapsack",
                                    "Pseudocódigo das variantes",
                                    "Exemplos numéricos simples"
                                  ],
                                  "tips": "Use diagramas visuais para representar itens e mochila para fixar conceitos.",
                                  "learningObjective": "Distinguir claramente as variantes do problema da mochila e seus algoritmos associados.",
                                  "commonMistakes": [
                                    "Confundir mochila 0-1 com fracionária; ignorar restrições de integridade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Complexidade do Algoritmo Guloso para Fracionário",
                                  "subSteps": [
                                    "Explique o algoritmo: ordenar itens por razão valor/peso (densidade) em O(n log n).",
                                    "Descreva execução: preencher mochila com itens ordenados até W.",
                                    "Prove otimalidade: guloso é ótimo para fracionário devido à propriedade de troca.",
                                    "Calcule complexidade: dominada por ordenação O(n log n).",
                                    "Teste com exemplo: n=5 itens, compute tempo assintótico."
                                  ],
                                  "verification": "Implemente o algoritmo em pseudocódigo e anote a notação Big-O para cada operação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para ordenação",
                                    "Exemplos de itens com valores/pesos"
                                  ],
                                  "tips": "Sempre priorize densidade alta; visualize ordenação com gráfico de barras.",
                                  "learningObjective": "Compreender por que O(n log n) é polinomial e ótimo para a variante fracionária.",
                                  "commonMistakes": [
                                    "Subestimar custo de ordenação; achar que guloso funciona para 0-1."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Complexidade da Programação Dinâmica para 0-1",
                                  "subSteps": [
                                    "Descreva tabela DP: dp[i][w] = valor máximo com i itens e peso w.",
                                    "Explique recursão: dp[i][w] = max(dp[i-1][w], dp[i-1][w - peso_i] + valor_i).",
                                    "Calcule dimensões: O(n * W) tempo e espaço, pseudo-polinomial.",
                                    "Discuta limitações: exponencial em bits de W se W grande.",
                                    "Implemente para pequeno exemplo: n=3, W=5."
                                  ],
                                  "verification": "Construa manualmente a tabela DP para um exemplo e confirme valor ótimo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado para tabela",
                                    "Ferramenta online de DP como Python REPL"
                                  ],
                                  "tips": "Preencha tabela linha por linha, item por item, para evitar erros de índice.",
                                  "learningObjective": "Dominar a análise de O(nW) como pseudo-polinomial e suas implicações.",
                                  "commonMistakes": [
                                    "Confundir O(nW) com polinomial verdadeiro; erros em índices off-by-one na tabela."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Complexidades e Discutir Aproximações/Heurísticas para 0-1",
                                  "subSteps": [
                                    "Compare: O(n log n) guloso fracionário vs. O(nW) PD 0-1; discuta NP-difícil de 0-1.",
                                    "Explique por que PD não escala: W grande torna impraticável.",
                                    "Descreva heurísticas para 0-1: guloso por densidade, branch-and-bound.",
                                    "Discuta aproximações: PTAS ou FPTAS não existem para 0-1 exato, mas heurísticas práticas.",
                                    "Avalie trade-offs: precisão vs. tempo em cenários reais."
                                  ],
                                  "verification": "Crie uma tabela comparativa de complexidades, garantias e usos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa em Excel ou papel",
                                    "Artigos curtos sobre heurísticas Knapsack"
                                  ],
                                  "tips": "Use notação assintótica Θ para precisão; pense em escalabilidade prática.",
                                  "learningObjective": "Contrastar variantes e justificar uso de aproximações em problemas reais.",
                                  "commonMistakes": [
                                    "Achar PD polinomial; superestimar heurísticas como ótimas."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma agência de viagens com orçamento W=1000kg para bagagem, 20 pacotes (itens) com valores (lucro) e pesos. Para fracionário, use guloso O(n log n) para solução rápida ótima. Para 0-1, compare PD O(nW) (lento se W grande) vs. heurística gulosa (rápida, ~90% ótima).",
                              "finalVerifications": [
                                "Explique verbalmente por que guloso é O(n log n) e ótimo para fracionário.",
                                "Desenhe tabela DP para 0-1 e calcule complexidade para n=100, W=10^6.",
                                "Liste 3 heurísticas para 0-1 e suas limitações.",
                                "Compare tempos práticos: execute simulações simples.",
                                "Discuta quando usar cada abordagem.",
                                "Resolva um problema misto: adapte guloso para 0-1 aproximado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação Big-O e justificativas assintóticas (30%).",
                                "Correta distinção entre variantes e otimalidade (25%).",
                                "Profundidade na análise de PD pseudo-polinomial vs. polinomial (20%).",
                                "Criatividade e relevância em heurísticas/aproximações (15%).",
                                "Clareza na tabela comparativa e exemplos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e recursões (Big-O, recorrências).",
                                "Economia: Otimização de recursos limitados e trade-offs custo-benefício.",
                                "Engenharia de Software: Escolha de algoritmos por escalabilidade prática.",
                                "Estatística: Análise empírica de heurísticas vs. exatas."
                              ],
                              "realWorldApplication": "Em logística (ex: FedEx otimizando cargas de caminhões como 0-1), finanças (seleção de portfólio de investimentos com restrições de risco), ou programação de satélites (alocação de instrumentos com peso limitado), onde heurísticas O(n log n) substituem PD O(nW) para grandes W."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.3.2",
                              "10.1.7.1.4.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.4.3",
                            "name": "Relacionar com teoria da complexidade",
                            "description": "Explicar status NP-completo da 0-1 e P da fracionária, citando referências como Garey & Johnson.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições dos Problemas da Mochila 0-1 e Fracionário",
                                  "subSteps": [
                                    "Defina o Problema da Mochila 0-1: itens indivisíveis com peso e valor, capacidade limitada da mochila.",
                                    "Defina o Problema da Mochila Fracionário: itens podem ser fracionados.",
                                    "Compare as restrições: indivisibilidade vs. divisibilidade.",
                                    "Estude exemplos numéricos simples para cada variante.",
                                    "Identifique a função objetivo: maximizar valor sem exceder peso."
                                  ],
                                  "verification": "Resuma as diferenças em um parágrafo e resolva um exemplo pequeno manualmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre Problema da Mochila; calculadora.",
                                  "tips": "Use diagramas visuais para representar a mochila e itens.",
                                  "learningObjective": "Diferenciar precisamente as duas variantes do problema.",
                                  "commonMistakes": "Confundir 0-1 com fracionário, ignorando a indivisibilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Classes de Complexidade P e NP",
                                  "subSteps": [
                                    "Defina classe P: problemas resolvíveis em tempo polinomial.",
                                    "Defina classe NP: soluções verificáveis em tempo polinomial.",
                                    "Explique NP-completo: problemas NP mais 'difíceis', redutíveis uns aos outros.",
                                    "Discuta implicações da hipótese P ≠ NP.",
                                    "Estude redutibilidade polinomial com exemplo simples (ex: SAT para 3-SAT)."
                                  ],
                                  "verification": "Explique P vs NP em suas próprias palavras e dê um exemplo de problema NP-completo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro 'Introduction to Algorithms' (Cormen); vídeo Khan Academy sobre P vs NP.",
                                  "tips": "Associe P a 'fácil' e NP a 'verificável rápido, mas resolver pode ser duro'.",
                                  "learningObjective": "Dominar terminologia e conceitos fundamentais de teoria da complexidade.",
                                  "commonMistakes": "Confundir NP com 'não polinomial'; achar que NP-completo significa intratável."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Complexidade do Knapsack 0-1 como NP-completo",
                                  "subSteps": [
                                    "Revise algoritmo dinâmico para 0-1: O(nW) pseudo-polinomial.",
                                    "Explique por que é NP-completo: redução de Subset Sum ou Partição.",
                                    "Descreva prova de NP: certificado é a seleção de itens.",
                                    "Discuta heurísticas e aproximações (ex: FFD).",
                                    "Compare com problemas NP-completos semelhantes como TSP."
                                  ],
                                  "verification": "Descreva a redução de Subset Sum para Knapsack 0-1 em passos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Capítulo relevante de Garey & Johnson 'Computers and Intractability'; pseudocódigo de DP.",
                                  "tips": "Implemente um solver simples em Python para visualizar exponencialidade.",
                                  "learningObjective": "Justificar o status NP-completo do Knapsack 0-1.",
                                  "commonMistakes": "Achar que DP torna polinomial; ignorar dependência em W."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Knapsack Fracionário em P e Integrar Referências",
                                  "subSteps": [
                                    "Explique algoritmo guloso: ordene por valor/peso, pegue frações.",
                                    "Prove otimalidade: exchange argument.",
                                    "Cite Garey & Johnson (páginas específicas sobre NP-completo para 0-1).",
                                    "Compare tempos: O(n log n) para fracionário vs. exponencial para 0-1.",
                                    "Resuma diferenças e implicações para otimização prática."
                                  ],
                                  "verification": "Cite a referência exata e explique por que fracionário é P.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Garey & Johnson (capítulo 30); implementações em código.",
                                  "tips": "Leia seções originais para citações precisas.",
                                  "learningObjective": "Relacionar status em P e citar fontes autorizadas.",
                                  "commonMistakes": "Aplicar guloso a 0-1 sem notar subotimalidade."
                                }
                              ],
                              "practicalExample": "Em uma agência de viagens, use Knapsack 0-1 para selecionar itens indivisíveis (ex: souvenirs caros) em bagagem limitada (NP-completo, use DP); para fracionário, divida suprimentos de comida por valor nutricional/peso (P, guloso otimizado).",
                              "finalVerifications": [
                                "Explicar corretamente P vs NP e status dos problemas.",
                                "Descrever redução para provar NP-completo de 0-1.",
                                "Provar otimalidade gulosa para fracionário.",
                                "Citar Garey & Johnson com página ou teorema específico.",
                                "Resolver exemplo numérico para ambos.",
                                "Discutir implicações práticas de cada complexidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (P/NP/NP-completo): 25%.",
                                "Correção das provas/reduções: 25%.",
                                "Citações e referências adequadas: 15%.",
                                "Exemplos práticos claros: 15%.",
                                "Comparação entre variantes: 10%.",
                                "Clareza e estrutura da explicação: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Programação Linear e Otimização.",
                                "Economia: Alocação de Recursos Escassos.",
                                "Física: Otimização de Cargas em Engenharia.",
                                "Gestão: Planejamento de Portfólios de Investimentos."
                              ],
                              "realWorldApplication": "Na logística, Knapsack 0-1 modela carregamento de caminhões com caixas indivisíveis (exigindo heurísticas por NP-completo); fracionário aplica a distribuição de combustível ou cargas líquidas, resolvido eficientemente por algoritmos gulosos em aviões ou tanques."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Problema do Caixeiro Viajante",
                    "description": "Formulação do problema TSP, propriedades e discussão sobre sua NP-dificuldade e heurísticas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Formulação do Problema TSP",
                        "description": "Definição formal do Problema do Caixeiro Viajante (TSP), incluindo suas variantes simétricas e assimétricas, representação como grafo completo ponderado e objetivo de encontrar o ciclo hamiltoniano de custo mínimo.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Definir o TSP clássico",
                            "description": "Explicar o TSP como o problema de encontrar o menor tour que visita cada cidade exatamente uma vez e retorna à origem, diferenciando versões simétrica (custo bidirecional igual) e assimétrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introduzir o Conceito Intuitivo do TSP",
                                  "subSteps": [
                                    "Imagine um caixeiro viajante que precisa visitar várias cidades exatamente uma vez cada.",
                                    "O objetivo é encontrar a rota mais curta que passa por todas as cidades e retorna à cidade de origem.",
                                    "Desenhe um mapa simples com 3-4 cidades e marque possíveis rotas.",
                                    "Identifique que o problema envolve ciclos fechados, não caminhos abertos.",
                                    "Pesquise brevemente exemplos reais como entregas postais."
                                  ],
                                  "verification": "Descreva o TSP em uma frase simples e desenhe um exemplo com 3 cidades.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhos",
                                    "Acesso à internet para imagens de mapas"
                                  ],
                                  "tips": [
                                    "Visualize como um jogo de conectar pontos com a menor linha total.",
                                    "Comece com poucas cidades para não se sobrecarregar."
                                  ],
                                  "learningObjective": "Compreender o problema TSP de forma intuitiva e visual.",
                                  "commonMistakes": [
                                    "Confundir com o menor caminho sem retorno à origem.",
                                    "Permitir visitas múltiplas a cidades.",
                                    "Ignorar o aspecto cíclico do tour."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formalizar a Definição Matemática do TSP Clássico",
                                  "subSteps": [
                                    "Defina o TSP como: dado um grafo completo K_n com n vértices (cidades) e pesos nas arestas (custos/distancias).",
                                    "O tour ótimo é o ciclo hamiltoniano de custo mínimo que visita cada vértice exatamente uma vez e retorna ao início.",
                                    "Escreva a notação: minimizar soma de c_{i,j} sobre o ciclo (i1 -> i2 -> ... -> in -> i1).",
                                    "Explique que é um problema de otimização combinatorial.",
                                    "Pratique escrevendo a definição em pseudocódigo ou equação."
                                  ],
                                  "verification": "Escreva a definição formal em uma nota e confira com uma fonte confiável como Wikipedia.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Bloco de notas",
                                    "Calculadora para simular custos",
                                    "Referência online sobre grafos"
                                  ],
                                  "tips": [
                                    "Use notação simples como c(i,j) para custo de i para j.",
                                    "Lembre-se: grafo completo significa aresta entre toda par de cidades."
                                  ],
                                  "learningObjective": "Dominar a formulação precisa e matemática do TSP clássico.",
                                  "commonMistakes": [
                                    "Esquecer que é um ciclo fechado (Hamiltonian Cycle).",
                                    "Confundir com caminhos hamiltonianos abertos.",
                                    "Não especificar 'exatamente uma vez' por cidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Versões Simétrica e Assimétrica do TSP",
                                  "subSteps": [
                                    "Defina TSP Simétrico: matriz de custos simétrica, c(i,j) = c(j,i) para todo i ≠ j (ex: distâncias euclidianas).",
                                    "Defina TSP Assimétrico: c(i,j) ≠ c(j,i) possível (ex: ventos em rotas aéreas ou tráfego unidirecional).",
                                    "Crie uma tabela 3x3 comparando custos simétricos vs assimétricos para 3 cidades.",
                                    "Discuta quando usar cada: simétrico para estradas bidirecionais, assimétrico para contextos direcionais.",
                                    "Verifique exemplos: simétrico em mapas de rua, assimétrico em logística com restrições."
                                  ],
                                  "verification": "Construa uma tabela de custos e identifique se é simétrica ou assimétrica.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Exemplos de matrizes de custos online"
                                  ],
                                  "tips": [
                                    "Teste simetria somando c(i,j) e c(j,i).",
                                    "Pense em direção: ida e volta iguais? Simétrico."
                                  ],
                                  "learningObjective": "Distinguir claramente as variantes simétrica e assimétrica do TSP.",
                                  "commonMistakes": [
                                    "Assumir sempre simetria sem verificar.",
                                    "Confundir assimétrico com grafos não-completos.",
                                    "Ignorar impactos na solução ótima."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Aplicar a Definição com um Exemplo Prático",
                                  "subSteps": [
                                    "Escolha 4 cidades A,B,C,D com custos simétricos: A-B=5, A-C=9, A-D=10, B-C=6, B-D=8, C-D=4.",
                                    "Liste todos os tours possíveis e calcule seus custos.",
                                    "Identifique o tour mínimo e classifique como simétrico.",
                                    "Modifique um custo para assimétrico (ex: B-A=7) e recalcule.",
                                    "Resuma diferenças observadas."
                                  ],
                                  "verification": "Calcule e justifique o tour ótimo para ambos os casos.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para listar permutações"
                                  ],
                                  "tips": [
                                    "Para n=4, há (4-1)!/2 = 3 tours únicos em simétrico.",
                                    "Use enumeração exaustiva para pequenos n."
                                  ],
                                  "learningObjective": "Aplicar a definição do TSP em um exemplo concreto.",
                                  "commonMistakes": [
                                    "Contar tours duplicados em simétrico.",
                                    "Esquecer de retornar à origem nos cálculos.",
                                    "Não normalizar tours (A-B-C-D-A é mesmo que B-C-D-A-B)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para 4 cidades A, B, C, D com distâncias simétricas (A-B=10, A-C=15, A-D=20, B-C=35, B-D=25, C-D=30), o tour ótimo A-B-D-C-A tem custo 10+25+30+15=80, menor que alternativas como A-B-C-D-A=10+35+30+20=95.",
                              "finalVerifications": [
                                "Explicar o TSP clássico em palavras próprias sem consultar notas.",
                                "Diferenciar corretamente simétrico de assimétrico com exemplo.",
                                "Formalizar a definição matemática usando notação padrão.",
                                "Identificar o tour ótimo em um grafo pequeno de 4 cidades.",
                                "Discutir por que o TSP é NP-difícil intuitivamente.",
                                "Criar uma matriz de custos assimétrica válida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: menciona ciclo hamiltoniano mínimo e visita única.",
                                "Clareza na distinção simétrica/ assimétrica com justificativa.",
                                "Uso correto de terminologia (grafo completo, custos, tour).",
                                "Capacidade de aplicar em exemplo numérico com cálculo exato.",
                                "Compreensão contextual: relaciona a otimização e complexidade.",
                                "Criatividade em exemplos reais ou variações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Ciclos Hamiltonianos.",
                                "Logística e Operações: Otimização de Rotas e Veículos.",
                                "Inteligência Artificial: Heurísticas e Algoritmos Genéticos para NP-hard.",
                                "Geografia: Modelagem de Distâncias Espaciais e Mapas.",
                                "Economia: Minimização de Custos em Cadeias de Suprimento."
                              ],
                              "realWorldApplication": "O TSP é usado em sistemas de roteirização para entregas da Amazon ou UPS, otimizando rotas de caminhões para reduzir combustível, tempo e emissões de CO2, economizando milhões anualmente em logística global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Representar TSP graficamente",
                            "description": "Modelar o TSP como um grafo completo K_n com pesos nas arestas representando distâncias entre cidades, e ilustrar instâncias pequenas com 3-5 nós.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de TSP e Grafos",
                                  "subSteps": [
                                    "Leia a definição do Problema do Caixeiro Viajante (TSP): visitar n cidades exatamente uma vez e retornar à origem, minimizando distância total.",
                                    "Revise o conceito de grafo não dirigido: vértices (cidades) e arestas (conexões).",
                                    "Entenda grafo completo K_n: todo par de vértices conectado por uma aresta única.",
                                    "Identifique que pesos nas arestas representam distâncias entre cidades.",
                                    "Confirme que TSP é modelado como encontrar ciclo hamiltoniano de custo mínimo em K_n."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando como TSP se relaciona com grafos completos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso online a definições de TSP e teoria dos grafos (ex: Wikipedia ou Khan Academy)"
                                  ],
                                  "tips": "Use diagramas simples para visualizar K_3 e K_4 antes de prosseguir.",
                                  "learningObjective": "Dominar a modelagem conceitual do TSP como grafo completo ponderado.",
                                  "commonMistakes": [
                                    "Confundir grafo dirigido com não dirigido",
                                    "Ignorar que K_n tem n(n-1)/2 arestas",
                                    "Esquecer o retorno à origem no TSP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Definir Instância Pequena de TSP",
                                  "subSteps": [
                                    "Escolha 3-5 cidades e atribua coordenadas 2D simples (ex: A(0,0), B(3,0), C(0,4)).",
                                    "Calcule distâncias euclidianas entre todos os pares: distância = sqrt((x2-x1)^2 + (y2-y1)^2).",
                                    "Crie uma matriz de distâncias simétrica (ex: linha/coluna para cada cidade).",
                                    "Arredonde distâncias para inteiros se necessário, garantindo simetria (d(i,j) = d(j,i)).",
                                    "Liste todos os nós e confirme n entre 3-5 para simplicidade."
                                  ],
                                  "verification": "Construa e verifique a matriz de distâncias: todos os valores são positivos e simétricos?",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como GeoGebra",
                                    "Planilha Excel/Google Sheets para matriz"
                                  ],
                                  "tips": "Comece com 4 cidades para equilibrar simplicidade e completude.",
                                  "learningObjective": "Preparar dados reais para representação gráfica do TSP.",
                                  "commonMistakes": [
                                    "Erro em cálculo de distância euclidiana",
                                    "Matriz assimétrica",
                                    "Incluir distância zero na diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Desenhar o Grafo Completo K_n",
                                  "subSteps": [
                                    "Desenhe os n vértices em posições circulares ou baseadas em coordenadas para refletir distâncias.",
                                    "Adicione arestas entre todos os pares de vértices (grafo completo).",
                                    "Rotule cada aresta com o peso correspondente da matriz de distâncias.",
                                    "Use convenções: círculos para vértices, linhas retas para arestas, números ao lado das arestas.",
                                    "Garanta legibilidade: evite sobreposições e use setas ou notas para clareza."
                                  ],
                                  "verification": "Conte as arestas: deve haver exatamente n(n-1)/2 arestas com pesos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de desenho (Draw.io, Graphviz, TikZ)"
                                  ],
                                  "tips": "Desenhe vértices em um círculo para minimizar cruzamentos de arestas.",
                                  "learningObjective": "Criar representação visual precisa de K_n ponderado para TSP.",
                                  "commonMistakes": [
                                    "Arestas faltantes (não completo)",
                                    "Pesos incorretos ou não rotulados",
                                    "Vértices mal posicionados distorcendo visualização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Refinar a Representação Gráfica",
                                  "subSteps": [
                                    "Confirme completude: todo nó conectado a todos os outros.",
                                    "Valide pesos contra matriz original.",
                                    "Simule um ciclo TSP manualmente (ex: A-B-C-D-A) e anote custo total aproximado.",
                                    "Adicione legenda: explique símbolos, escalas e suposições (ex: distâncias euclidianas).",
                                    "Compare com exemplos online de TSP gráfico para autoavaliação."
                                  ],
                                  "verification": "Mostre o grafo a alguém e pergunte se compreende o modelo TSP instantaneamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de grafos TSP online",
                                    "Ferramenta de compartilhamento de imagens"
                                  ],
                                  "tips": "Use cores diferentes para arestas curtas vs. longas para insight visual.",
                                  "learningObjective": "Garantir precisão e comunicabilidade da representação gráfica.",
                                  "commonMistakes": [
                                    "Ignorar simetria nos pesos",
                                    "Falta de legenda",
                                    "Não testar completude"
                                  ]
                                }
                              ],
                              "practicalExample": "Para 4 cidades: A(0,0), B(5,0), C(0,3), D(4,4). Distâncias: A-B=5, A-C=3, A-D≈6.4, B-C≈5.8, B-D≈4.5, C-D≈4.1. Desenhe K_4 com vértices em posições reais, arestas rotuladas (arredondado: A-B:5, etc.). Isso modela TSP: encontre ciclo mínimo como A-B-D-C-A (total≈19.8).",
                              "finalVerifications": [
                                "O grafo tem exatamente n vértices e n(n-1)/2 arestas ponderadas?",
                                "Todos os pesos correspondem à matriz de distâncias calculada?",
                                "Representação é legível, com rótulos claros em vértices e arestas?",
                                "Posições dos vértices refletem aproximadamente as coordenadas reais?",
                                "É possível identificar ciclos hamiltonianos visualmente?",
                                "Legenda explica convenções usadas (ex: unidades de distância)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: TSP corretamente modelado como K_n ponderado (30%)",
                                "Correção matemática: Pesos exatos e simétricos (25%)",
                                "Qualidade visual: Clareza, sem sobreposições, bem rotulado (20%)",
                                "Completude: Todas arestas presentes e propriedades verificadas (15%)",
                                "Criatividade: Posicionamento intuitivo e insights adicionais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Geometria Euclidiana",
                                "Física: Cálculo de distâncias em planos cartesianos",
                                "Geografia: Modelagem de rotas em mapas e logística espacial",
                                "Economia: Otimização de custos em cadeias de suprimentos"
                              ],
                              "realWorldApplication": "Na logística de empresas como UPS ou Amazon, grafos TSP modelam rotas de entregas diárias, economizando milhões em combustível ao visualizar e otimizar caminhos entre centros de distribuição e clientes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Formular TSP matematicamente",
                            "description": "Escrever a formulação de programação inteira mista (IP) para TSP, incluindo variáveis binárias x_{ij} para arestas e restrições de grau de entrada/saída igual a 1 por nó.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a instância do problema TSP",
                                  "subSteps": [
                                    "Identifique o conjunto de nós V = {1, 2, ..., n}, onde n é o número de cidades.",
                                    "Crie a matriz de custos c_{ij} para i ≠ j, representando a distância ou custo de ir de i para j.",
                                    "Especifique que o grafo é completo e simétrico se aplicável, e defina c_{ii} = ∞ ou ignore loops.",
                                    "Escolha um nó inicial arbitrário, como o nó 1, para o caixeiro viajante.",
                                    "Desenhe o grafo completo para visualização."
                                  ],
                                  "verification": "Confirme que todos os n nós estão listados e a matriz c_{ij} está completa sem valores indefinidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Planilha ou software como Excel para matriz de distâncias",
                                    "Exemplo de TSP com 4-5 nós"
                                  ],
                                  "tips": "Comece com n pequeno (3-5) para facilitar a compreensão antes de generalizar.",
                                  "learningObjective": "Modelar a entrada do problema TSP como um grafo completo ponderado.",
                                  "commonMistakes": [
                                    "Definir c_{ij} assimétrico sem justificativa",
                                    "Incluir loops (c_{ii})",
                                    "Esquecer nós isolados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar as variáveis de decisão",
                                  "subSteps": [
                                    "Defina x_{ij} ∈ {0,1} para todo i,j ∈ V, i ≠ j, onde x_{ij}=1 se a aresta (i,j) é usada no tour.",
                                    "Explique o significado: x_{ij} indica se o caixeiro vai diretamente de i para j.",
                                    "Liste todas as possíveis variáveis (n(n-1) binárias).",
                                    "Anote o domínio: x_{ij} binário.",
                                    "Verifique simetria se o problema for simétrico (x_{ij} = x_{ji})."
                                  ],
                                  "verification": "Verifique se todas as variáveis x_{ij} para i≠j estão declaradas como binárias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Exemplo de notação LaTeX ou MathJax para fórmulas"
                                  ],
                                  "tips": "Use índices duplos claros i,j para evitar confusão com outros problemas.",
                                  "learningObjective": "Entender variáveis binárias de seleção de arestas em grafos.",
                                  "commonMistakes": [
                                    "Permitir x_{ii}=1",
                                    "Esquecer i≠j",
                                    "Definir como contínuas em vez de binárias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a função objetivo",
                                  "subSteps": [
                                    "Escreva a função objetivo: minimizar ∑_{i∈V} ∑_{j∈V, j≠i} c_{ij} x_{ij}.",
                                    "Explique que isso soma o custo total do tour selecionado.",
                                    "Confirme que é uma minimização para otimização de custo.",
                                    "Teste com um exemplo pequeno: substitua valores numéricos.",
                                    "Anote como 'min' ou use notação padrão de IP."
                                  ],
                                  "verification": "Substitua valores de um exemplo pequeno e veja se o custo total é calculado corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz de custos do Step 1",
                                    "Calculadora"
                                  ],
                                  "tips": "Garanta que a soma seja sobre todas arestas possíveis, mas só as selecionadas contam.",
                                  "learningObjective": "Construir a função objetivo linear para minimizar o comprimento do tour.",
                                  "commonMistakes": [
                                    "Maximizar em vez de minimizar",
                                    "Incluir termos c_{ii}",
                                    "Soma errada nos índices"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever as restrições de grau e eliminar subtours",
                                  "subSteps": [
                                    "Adicione restrições de saída: ∀i∈V, ∑_{j≠i} x_{ij} = 1 (exatamente uma saída por nó).",
                                    "Adicione restrições de entrada: ∀j∈V, ∑_{i≠j} x_{ij} = 1 (exatamente uma entrada por nó).",
                                    "Inclua restrições MTZ para eliminar subtours: introduza u_i variáveis contínuas (u_1=1), e ∀i≠j, u_i - u_j + n x_{ij} ≤ n-1.",
                                    "Verifique conectividade: as restrições garantem um ciclo hamiltoniano.",
                                    "Liste todas as restrições em formato padrão."
                                  ],
                                  "verification": "Conte o número de restrições: 2n para graus + n(n-1) para MTZ, e teste se satisfaz um tour conhecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas anteriores",
                                    "Referência de formulação MTZ",
                                    "Solver IP online como PuLP ou NEOS para teste"
                                  ],
                                  "tips": "MTZ previne subtours; sem ela, soluções inválidas surgem.",
                                  "learningObjective": "Implementar restrições que garantem um tour único e conectado.",
                                  "commonMistakes": [
                                    "Esquecer =1 nas somas de grau",
                                    "Índices trocados em entrada/saída",
                                    "Não incluir anti-subtour"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Finalizar a formulação completa e validar",
                                  "subSteps": [
                                    "Compile tudo: parâmetros, variáveis, objetivo, restrições, domínio.",
                                    "Escreva em notação matemática formal.",
                                    "Valide com um solver IP se possível.",
                                    "Discuta relaxações ou extensões (ex: assimétrico).",
                                    "Documente suposições (ex: grafo completo)."
                                  ],
                                  "verification": "A formulação resolve corretamente um TSP pequeno conhecido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Todas as notas",
                                    "Software de otimização como Python PuLP ou Gurobi trial"
                                  ],
                                  "tips": "Sempre teste com n=3 ou 4 para debug.",
                                  "learningObjective": "Integrar todos elementos em uma IP válida e testável.",
                                  "commonMistakes": [
                                    "Faltar domínio binário",
                                    "Restrições incompletas",
                                    "Notação inconsistente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para TSP com 3 cidades {1,2,3}, c12=10, c13=15, c21=10, c23=35, c31=15, c32=35. Formulação: min 10x12 +15x13 +10x21 +35x23 +15x31 +35x32 s.t. x12+x13=1, x21+x23=1, x31+x32=1 (saídas); x12+x21+x31=1? Wait, entradas: para j=1: x21+x31=1; j=2: x12+x32=1; j=3: x13+x23=1. MTZ: u1=1, u2-u1 +3x12<=2, etc. Solução ótima: 1-2-3-1 custo 10+35+15=60.",
                              "finalVerifications": [
                                "Todas variáveis x_ij declaradas como binárias para i≠j.",
                                "Função objetivo minimiza soma correta de c_ij x_ij.",
                                "Restrições de grau de entrada e saída =1 para cada nó.",
                                "Restrições anti-subtour (ex: MTZ) incluídas.",
                                "Formulação testada em instância pequena resolve corretamente.",
                                "Notação consistente e sem erros tipográficos."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das equações e restrições.",
                                "Completude: todos componentes da IP presentes.",
                                "Clareza e precisão na notação (índices, símbolos).",
                                "Validação prática com exemplo numérico.",
                                "Explicação de cada parte (objetivo, restrições).",
                                "Tratamento adequado de subtours."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: modelagem como ciclo hamiltoniano.",
                                "Pesquisa Operacional: Programação Linear Inteira Mista.",
                                "Matemática Discreta: Otimização combinatória.",
                                "Ciência de Dados: Heurísticas e solvers IP.",
                                "Logística: Aplicações em roteirização."
                              ],
                              "realWorldApplication": "Otimizar rotas de entrega para empresas de logística como Amazon ou UPS, reduzindo custos de combustível e tempo em visitas a múltiplos clientes, economizando milhões anualmente em frotas de veículos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Propriedades do TSP",
                        "description": "Características fundamentais do TSP, como propriedades de simetria, desigualdade triangular, optimalidade de subestruturas e implicações para algoritmos exatos e aproximados.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Identificar propriedades básicas",
                            "description": "Listar e exemplificar propriedades como simetria (c_{ij}=c_{ji}), completude do grafo e unicidade do tour ótimo em instâncias genéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de propriedades básicas no TSP",
                                  "subSteps": [
                                    "Revise a definição do Problema do Caixeiro Viajante (TSP): encontrar o ciclo hamiltoniano de custo mínimo em um grafo completo.",
                                    "Identifique que propriedades básicas são características fundamentais que definem o problema, como simetria, completude e unicidade.",
                                    "Estude exemplos iniciais de grafos TSP simétricos e assimétricos para diferenciar.",
                                    "Anote as três propriedades principais: simetria (c_ij = c_ji), completude (todas as arestas existem) e unicidade do tour ótimo em casos genéricos.",
                                    "Crie um mapa mental ligando cada propriedade ao impacto na solução do problema."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo explicando cada propriedade básica e confirme com uma autoavaliação comparando com definições padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro ou notas sobre TSP",
                                    "Papel e caneta para mapa mental",
                                    "Acesso a Wikipedia ou Khan Academy sobre grafos"
                                  ],
                                  "tips": [
                                    "Comece com definições formais antes de exemplos para construir base sólida.",
                                    "Use diagramas visuais para grafos para facilitar compreensão."
                                  ],
                                  "learningObjective": "Compreender o papel das propriedades básicas na definição e análise do TSP.",
                                  "commonMistakes": [
                                    "Confundir simetria com completude.",
                                    "Ignorar que unicidade não é garantida em todas as instâncias."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a propriedade de simetria",
                                  "subSteps": [
                                    "Defina simetria: c_ij = c_ji para todo par i,j de cidades.",
                                    "Construa um grafo de 4 vértices com matriz de custos simétrica (ex: [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]).",
                                    "Calcule tours manuais e observe que arestas são bidirecionais.",
                                    "Compare com um grafo assimétrico alterando um custo (ex: c_12=10, c_21=12) e note impactos em algoritmos.",
                                    "Liste 3 exemplos reais onde simetria se aplica (ex: distâncias euclidianas)."
                                  ],
                                  "verification": "Gere uma matriz simétrica válida e verifique se todos c_ij = c_ji; teste com tour calculado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para matrizes",
                                    "Ferramenta de desenho de grafos como Draw.io",
                                    "Exemplos de TSP online"
                                  ],
                                  "tips": [
                                    "Sempre teste simetria verificando a matriz transposta.",
                                    "Visualize o grafo para intuitivamente entender simetria."
                                  ],
                                  "learningObjective": "Identificar e exemplificar simetria em instâncias TSP.",
                                  "commonMistakes": [
                                    "Assumir simetria em problemas de transporte aéreo (geralmente assimétricos).",
                                    "Esquecer de verificar todos os pares na matriz."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a completude do grafo",
                                  "subSteps": [
                                    "Defina completude: grafo K_n com aresta entre todo par de vértices distintos.",
                                    "Desenhe um grafo completo K_5 e liste todas as arestas (10 arestas).",
                                    "Discuta o que acontece se uma aresta faltar: TSP torna-se problema de caminho hamiltoniano, mais difícil.",
                                    "Crie uma instância incompleta removendo uma aresta e tente resolver TSP nela.",
                                    "Explique por que completude garante existência de tours hamiltonianos."
                                  ],
                                  "verification": "Construa K_4 e confirme n(n-1)/2 = 6 arestas; remova uma e discuta impossibilidade de tour completo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software de grafos como Graphviz ou yEd",
                                    "Papel quadriculado para desenhos manuais"
                                  ],
                                  "tips": [
                                    "Conte as arestas para verificar completude: deve ser exatamente n(n-1)/2.",
                                    "Pense em termos de 'todas as cidades conectadas diretamente'."
                                  ],
                                  "learningObjective": "Reconhecer completude como pré-requisito para TSP padrão.",
                                  "commonMistakes": [
                                    "Confundir completude com conectividade (grafo pode ser conectado sem ser completo).",
                                    "Ignorar que TSP permite pesos zero ou infinitos em alguns contextos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar unicidade do tour ótimo",
                                  "subSteps": [
                                    "Defina unicidade: em instâncias genéricas, múltiplos tours ótimos podem existir se custos permitirem empates.",
                                    "Crie exemplo com tour único: matriz com custos distintos garantindo um mínimo claro.",
                                    "Crie contraexemplo: 4 cidades em quadrado perfeito, todos tours têm mesmo custo.",
                                    "Discuta heurísticas que assumem unicidade vs. exatas que encontram todos.",
                                    "Analise impacto em instâncias genéricas (pesos aleatórios geralmente levam a unicidade probabilística)."
                                  ],
                                  "verification": "Forneça dois exemplos: um com tour único e um com múltiplos; prove calculando custos.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Calculadora ou Python para calcular tours exaustivos em grafos pequenos",
                                    "Matrizes de exemplo impressas"
                                  ],
                                  "tips": [
                                    "Use pesos ligeiramente perturbados para quebrar empates e testar unicidade.",
                                    "Sempre enumere todos os tours possíveis em n<=5 para verificação exata."
                                  ],
                                  "learningObjective": "Exemplificar quando o tour ótimo é único ou não em TSP genérico.",
                                  "commonMistakes": [
                                    "Assumir unicidade sempre (falso em simétricos regulares).",
                                    "Confundir com optimalidade em aproximações."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere 4 cidades A,B,C,D com matriz simétrica e completa: [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]. Verifique simetria (sim), completude (6 arestas), e calcule tours: ótimo A-B-D-C-A custo 85, único pois outros têm custos maiores (ex: A-B-C-D-A=95).",
                              "finalVerifications": [
                                "Liste corretamente as 3 propriedades com definições precisas.",
                                "Construa uma matriz simétrica completa de 5x5 válida.",
                                "Identifique unicidade em um exemplo dado resolvendo todos os tours.",
                                "Explique impacto de violar completude no TSP.",
                                "Diferencie TSP simétrico de assimétrico com exemplo.",
                                "Crie mapa mental conectando propriedades."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% correto).",
                                "Qualidade dos exemplos: concretos e verificáveis.",
                                "Profundidade na análise de unicidade (inclui contraexemplos).",
                                "Correta verificação de simetria e completude em matrizes.",
                                "Clareza na explicação de impactos nas soluções.",
                                "Criatividade em conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e ciclos hamiltonianos.",
                                "Logística: Otimização de rotas em supply chain.",
                                "Física: Problemas de caminho mínimo em redes de partículas.",
                                "Economia: Modelagem de custos em cadeias de produção."
                              ],
                              "realWorldApplication": "Em empresas de delivery como Uber Eats ou Amazon, identificar simetria em distâncias rodoviárias permite usar algoritmos TSP eficientes para roteirização de entregas, reduzindo custos em até 20% em rotas urbanas completas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Aplicar desigualdade triangular",
                            "description": "Verificar e usar a desigualdade triangular (c_{ik} ≤ c_{ij} + c_{jk}) em TSP métrico para justificar aproximações e podas em buscas exaustivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição da Desigualdade Triangular",
                                  "subSteps": [
                                    "Ler e memorizar a fórmula: para todos i, j, k distintos, c_{ik} ≤ c_{ij} + c_{jk}, onde c é a matriz de custos.",
                                    "Interpretar geometricamente: a distância direta entre i e k não excede a soma de distâncias via j.",
                                    "Relacionar com propriedades de métricas: não-negatividade, simetria e reflexividade.",
                                    "Analisar exemplos simples com 3 pontos para visualizar violações.",
                                    "Diferenciar de desigualdades em grafos não métricos."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a desigualdade com um exemplo numérico simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz de custos 3x3 exemplo",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Visualize pontos em um plano euclidiano para intuição geométrica.",
                                  "learningObjective": "Dominar o conceito matemático e suas implicações em TSP métrico.",
                                  "commonMistakes": [
                                    "Confundir com igualdade triangular",
                                    "Esquecer de checar para todos os trios i,j,k",
                                    "Ignorar simetria da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar se uma Instância de TSP é Métrica",
                                  "subSteps": [
                                    "Obter ou criar uma matriz de custos simétrica C[n][n].",
                                    "Implementar verificação: para cada trio (i,j,k) com i ≠ j ≠ k, checar se c[i][k] ≤ c[i][j] + c[j][k].",
                                    "Otimizar o loop triplo usando programação (ex: Python) para n até 10.",
                                    "Identificar e registrar violações, se houver.",
                                    "Concluir se a instância satisfaz a propriedade métrica."
                                  ],
                                  "verification": "Executar código ou cálculo manual em matriz 4x4 e listar resultados (métrica ou não).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python/Jupyter)",
                                    "Matriz de custos exemplo não-métrica"
                                  ],
                                  "tips": "Comece com n pequeno para depuração; use assert para automação.",
                                  "learningObjective": "Capacitar a validação prática de instâncias métricas.",
                                  "commonMistakes": [
                                    "Loop incompleto (ex: pular i==j)",
                                    "Não tratar diagonal zero",
                                    "Confundir assimetria com violação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar em Aproximações de TSP",
                                  "subSteps": [
                                    "Construir uma aproximação como MST (Árvore Geradora Mínima) e duplicar arestas para Euleriano.",
                                    "Usar desigualdade para provar que o tour resultante tem custo ≤ 2 * OPT (como em Christofides).",
                                    "Calcular explicitamente: mostrar c(tour) ≤ soma c(MST) * 2 ≤ 2 * OPT via desigualdade.",
                                    "Comparar com tour ótimo em exemplo pequeno.",
                                    "Justificar viabilidade em algoritmos de aproximação."
                                  ],
                                  "verification": "Derivar prova escrita para uma instância 4x4, mostrando bound de 1.5-approximation.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Biblioteca NetworkX para MST",
                                    "Matriz TSP métrica exemplo"
                                  ],
                                  "tips": "Lembre: em métrico, MST cobre todas cidades com custo baixo.",
                                  "learningObjective": "Justificar garantias de performance em heurísticas.",
                                  "commonMistakes": [
                                    "Esquecer fator 1.5 do Christofides",
                                    "Não ligar MST à desigualdade",
                                    "Usar instância não-métrica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Usar para Podas em Buscas Exaustivas",
                                  "subSteps": [
                                    "Em branch-and-bound para TSP, calcular lower bound parcial usando desigualdade.",
                                    "Para caminho parcial S → i, bound = custo(S,i) + min_j≠i (c[i][j] + dist(j, resto)) via triangular.",
                                    "Implementar poda: descartar ramo se bound > upper bound atual.",
                                    "Executar em instância pequena e registrar podas ativadas.",
                                    "Analisar redução no espaço de busca."
                                  ],
                                  "verification": "Resolver TSP 5x5 manualmente com podas e comparar com exaustivo sem poda.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código branch-and-bound simples",
                                    "Matriz TSP 5x5 métrica"
                                  ],
                                  "tips": "Mantenha upper bound atualizado com heurística 2-opt.",
                                  "learningObjective": "Aplicar podas para eficiência computacional.",
                                  "commonMistakes": [
                                    "Bound frouxo sem triangular",
                                    "Não relaxar distâncias restantes",
                                    "Poda prematura sem bound válido"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere TSP com 4 cidades A,B,C,D e matriz métrica: c(A,B)=1, c(A,C)=3, c(A,D)=4, c(B,C)=2, c(B,D)=3, c(C,D)=2. Verifique triangular: c(A,C)=3 ≤ c(A,B)+c(B,C)=1+2=3 (ok). Use para podar: em busca, caminho A-B-D bound ≥1+3 + min(c(D,C)+0)=6, se upper=7, continue; prove approx MST A-B-C-D custo 1+2+2=5 ≤1.5*OPT.",
                              "finalVerifications": [
                                "Verificar corretamente matriz 5x5 como métrica.",
                                "Provar bound de aproximação em exemplo dado.",
                                "Implementar poda triangular em código TSP pequeno.",
                                "Identificar erro em prova inválida fornecida.",
                                "Explicar impacto em espaço de busca (redução %).",
                                "Aplicar em instância real (ex: distâncias euclidianas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de desigualdade (100% trios corretos).",
                                "Clareza na justificativa de aproximações (prova completa).",
                                "Eficiência de podas demonstrada (redução >50% nós explorados).",
                                "Correção no código de verificação/poda (testes passam).",
                                "Profundidade de análise de erros comuns evitados.",
                                "Criatividade em exemplos personalizados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Espaços métricos e geometria euclidiana.",
                                "Logística: Otimização de rotas em veículos de entrega.",
                                "Teoria dos Grafos: Distâncias e árvores geradoras.",
                                "Análise de Algoritmos: Branch-and-bound e relaxações.",
                                "Inteligência Artificial: Heurísticas em problemas NP-difíceis."
                              ],
                              "realWorldApplication": "Em roteirização de entregas (ex: Amazon, Uber Eats), a desigualdade triangular permite podar buscas exaustivas em software de otimização, acelerando soluções para centenas de paradas e economizando combustível/milhas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Analisar subestruturas ótimas",
                            "description": "Discutir se caminhos ótimos em subgrafos implicam tours ótimos no grafo completo, relacionando com programação dinâmica de Held-Karp.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema do Caixeiro Viajante (TSP) e Conceitos de Subgrafos",
                                  "subSteps": [
                                    "Defina formalmente o TSP como encontrar o ciclo hamiltoniano de custo mínimo em um grafo completo ponderado.",
                                    "Explique subgrafos induzidos por subconjuntos de vértices (cidades).",
                                    "Discuta caminhos ótimos em subgrafos: menor custo para visitar todas as cidades de um subconjunto começando e terminando em uma cidade fixa.",
                                    "Identifique por que soluções ingênuas falham: combinações exponenciais.",
                                    "Desenhe um grafo pequeno (3-4 cidades) para ilustrar subgrafos."
                                  ],
                                  "verification": "Crie um diagrama de um grafo TSP com 4 cidades e liste todos os subgrafos de tamanho 2 e 3 com seus caminhos ótimos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou software de grafos como Graphviz; notas sobre TSP.",
                                  "tips": "Use notação padrão: G=(V,E) com pesos c(u,v).",
                                  "learningObjective": "Compreender a estrutura do TSP e o papel de subgrafos na análise de otimalidade.",
                                  "commonMistakes": "Confundir subgrafos com subconjuntos arbitrários de arestas; ignorar completude do grafo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Recursão da Programação Dinâmica de Held-Karp",
                                  "subSteps": [
                                    "Defina o estado DP: C(S, k) = custo mínimo para visitar subconjunto S começando em 1 e terminando em k ∈ S.",
                                    "Escreva a recursão: C(S, k) = min_{m ∈ S, m≠k} [C(S-{k}, m) + c(m,k)].",
                                    "Explique a base: C({1},1) = 0; infinito caso contrário.",
                                    "Discuta o tour completo: min_k [C(V-{1}, k) + c(k,1)].",
                                    "Implemente pseudocódigo para um grafo pequeno."
                                  ],
                                  "verification": "Calcule manualmente C(S,k) para todos subconjuntos S de um grafo com 4 cidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha ou Python/Jupyter para tabelas DP; matriz de distâncias.",
                                  "tips": "Use bitmasks para representar subconjuntos S em implementações.",
                                  "learningObjective": "Dominar a formulação exata da DP Held-Karp e sua dependência em subproblemas.",
                                  "commonMistakes": "Esquecer de excluir k no min; não tratar base corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar se Caminhos Ótimos em Subgrafos Implicam Tour Ótimo no Grafo Completo",
                                  "subSteps": [
                                    "Argumente que sim: pela construção da recursão, C(S,k) é ótimo assumindo otimalidade em subproblemas menores.",
                                    "Prove por indução: base trivial; passo indutivo usa mínimo sobre soluções ótimas de subgrafos.",
                                    "Discuta otimalidade global: tour ótimo é combinação de caminhos ótimos via recursão.",
                                    "Relacione com princípio de otimalidade de Bellman.",
                                    "Considere contraexemplos: mostre que heurísticas como MST não preservam otimalidade."
                                  ],
                                  "verification": "Escreva uma prova por indução de 200 palavras confirmando a propriedade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Livro de algoritmos (ex: CLRS) ou artigo Held-Karp; editor de texto.",
                                  "tips": "Estruture prova: hipótese indutiva forte sobre todos |S| <= n.",
                                  "learningObjective": "Demonstrar matematicamente a validade da subestrutura ótima no TSP via Held-Karp.",
                                  "commonMistakes": "Confundir com problemas sem subestrutura ótima (ex: alguns NP-difíceis); ignorar ciclo fechado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar com Exemplo Prático e Discutir Limitações",
                                  "subSteps": [
                                    "Construa grafo com 4 cidades: distâncias assimétricas para complexidade.",
                                    "Calcule todos C(S,k) e reconstrua tour ótimo.",
                                    "Verifique se alterar um subpath ótimo quebra o tour global.",
                                    "Discuta complexidade O(2^n n^2) e por que é pseudo-polinomial.",
                                    "Compare com aproximações (ex: Christofides)."
                                  ],
                                  "verification": "Implemente Held-Karp em código e rode no exemplo; confirme tour ótimo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com NumPy; grafo exemplo salvo como JSON.",
                                  "tips": "Teste com n=5 para ver exponencialidade.",
                                  "learningObjective": "Aplicar análise em exemplo concreto e reconhecer limites práticos.",
                                  "commonMistakes": "Erros de indexação em bitmasks; assumir simetria desnecessária."
                                }
                              ],
                              "practicalExample": "Considere 4 cidades A,B,C,D com distâncias: A-B=1, A-C=4, A-D=5, B-C=2, B-D=3, C-D=1, e simétrico. Subgrafo {A,B,C}: caminho ótimo A-B-C custo 3. Held-Karp combina com D para tour A-B-C-D-A custo 8, provando otimalidade global.",
                              "finalVerifications": [
                                "Calcule Held-Karp para grafo n=4 e liste todos C(S,k).",
                                "Prove por indução a subestrutura ótima em parágrafo escrito.",
                                "Identifique 3 subgrafos e seus caminhos ótimos manualmente.",
                                "Discuta por que TSP tem subestrutura ótima unlike Subset Sum.",
                                "Implemente código funcional que retorna tour ótimo.",
                                "Compare custo ótimo com heurística greedy."
                              ],
                              "assessmentCriteria": [
                                "Precisão na recursão Held-Karp (100% correta).",
                                "Prova indutiva lógica e completa.",
                                "Cálculos manuais sem erros aritméticos.",
                                "Explicação clara da implicação subgrafo -> grafo completo.",
                                "Código executável e comentado.",
                                "Análise de limitações (ex: escalabilidade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Indução Matemática.",
                                "Otimização: Princípio de Otimalidade de Bellman em OR.",
                                "Inteligência Artificial: Busca Exaustiva vs Heurísticas.",
                                "Economia: Problemas de Roteirização em Logística."
                              ],
                              "realWorldApplication": "Em logística, Held-Karp resolve roteiros ótimos para frotas pequenas de entregas (ex: Amazon last-mile), garantindo que sub-rotas ótimas em bairros levem a tour global ótimo, economizando combustível e tempo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "NP-Dificuldade do TSP",
                        "description": "Demonstração da NP-completude do TSP via reduções polinomiais e membership na classe NP, com referências a teoremas clássicos de Garey e Johnson.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Provar membership em NP",
                            "description": "Mostrar que TSP está em NP verificando um certificado (tour candidato) em tempo polinomial via soma de pesos das arestas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição Formal de Problemas em NP",
                                  "subSteps": [
                                    "Relembrar que um problema de decisão L está em NP se existe um verificador polinomial V tal que para toda instância x e certificado y (|y| ≤ poly(|x|)), V(x,y)=1 iff x ∈ L.",
                                    "Estudar exemplos clássicos como SAT ou Hamiltoniano para contextualizar.",
                                    "Diferenciar NP de P: verificação vs. solução.",
                                    "Explicar o papel do certificado (witness) na classe NP.",
                                    "Discutir por que a verificação é mais fácil que a busca."
                                  ],
                                  "verification": "Escreva a definição formal de NP e dê um exemplo simples de certificado para um problema conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Complexidade Computacional (ex: Sipser)",
                                    "Notas de aula sobre classes P e NP"
                                  ],
                                  "tips": "Foque na distinção entre gerador e verificador; memorize a fórmula ∀x ∃y V(x,y).",
                                  "learningObjective": "Compreender os requisitos exatos para provar que um problema pertence a NP.",
                                  "commonMistakes": [
                                    "Confundir NP com NP-completo",
                                    "Achar que todo problema em NP é difícil de resolver"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Certificado Adequado para o TSP",
                                  "subSteps": [
                                    "Definir TSP como problema de decisão: dado grafo G=(V,E) com pesos w, e inteiro K, existe tour de custo ≤ K?",
                                    "Propor o certificado y como uma permutação π de V (sequência de vértices visitados).",
                                    "Garantir que |y| = O(n) onde n=|V|, polinomial na entrada.",
                                    "Explicar que π representa um ciclo Hamiltoniano candidato.",
                                    "Verificar pré-condições: π deve incluir todos os vértices exatamente uma vez."
                                  ],
                                  "verification": "Descreva o certificado para TSP e justifique por que seu tamanho é polinomial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo de grafo TSP com 4-5 cidades",
                                    "Papel e lápis para desenhar"
                                  ],
                                  "tips": "Pense no certificado como 'prova' que você entrega ao juiz para checar rapidamente.",
                                  "learningObjective": "Selecionar um certificado válido e eficiente para membership em NP do TSP.",
                                  "commonMistakes": [
                                    "Usar o tour ótimo como certificado (inválido)",
                                    "Ignorar o retorno ao início"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Algoritmo de Verificação Polinomial",
                                  "subSteps": [
                                    "Verificar validade do tour: para i=1 a n-1, checar se (π(i),π(i+1)) ∈ E e π(n) para π(1).",
                                    "Garantir unicidade: todos π(i) distintos usando tabela hash ou array.",
                                    "Calcular custo total: soma w(π(i),π(i+1)) para i=1 a n (ciclo).",
                                    "Comparar soma ≤ K? Se sim e válido, aceitar.",
                                    "Implementar pseudocódigo simples."
                                  ],
                                  "verification": "Escreva pseudocódigo do verificador e teste com um tour inválido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo editor (ex: Notepad++)",
                                    "Grafo de exemplo"
                                  ],
                                  "tips": "Use laços O(n) para tudo; evite recursão desnecessária.",
                                  "learningObjective": "Desenvolver um verificador determinístico em tempo polinomial.",
                                  "commonMistakes": [
                                    "Verificar existência de arestas em O(1) sem adjacência",
                                    "Esquecer soma do ciclo fechado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a Complexidade Temporal e Concluir a Prova",
                                  "subSteps": [
                                    "Analisar verificação de arestas: O(n) com matriz de adjacência.",
                                    "Unicidade: O(n) com array booleano.",
                                    "Soma de pesos: O(n) soma direta.",
                                    "Total: O(n) = O(|V|), polinomial em |G|.",
                                    "Concluir: como V roda em poly-time e reconhece L_TSP, TSP ∈ NP."
                                  ],
                                  "verification": "Calcule big-O exato e prove que poly(|x|).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de análise de complexidade",
                                    "Referência de notação assintótica"
                                  ],
                                  "tips": "Assuma representação padrão de grafo (matriz O(n²)).",
                                  "learningObjective": "Demonstrar formalmente que o verificador é eficiente.",
                                  "commonMistakes": [
                                    "Contar |E| em vez de |V|",
                                    "Ignorar pré-processamento da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar a Prova Completa",
                                  "subSteps": [
                                    "Reunir: certificado π, verificador V descrito.",
                                    "Afirmar teorema: TSP ∈ NP.",
                                    "Discutir implicações para NP-completude.",
                                    "Comparar com problemas em P (ex: MST).",
                                    "Preparar para prova de NP-hardness futura."
                                  ],
                                  "verification": "Escreva prova completa em 1 parágrafo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Template de prova formal"
                                  ],
                                  "tips": "Estruture como: Definição → Certificado → Verificador → Complexidade → QED.",
                                  "learningObjective": "Articular a prova de membership de forma concisa e rigorosa.",
                                  "commonMistakes": [
                                    "Pular análise temporal",
                                    "Confundir decisão com otimização"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere TSP com 4 cidades A,B,C,D, pesos: A-B=1, B-C=2, C-D=3, D-A=4, K=10. Certificado: π=[A,B,C,D]. Verifique: arestas existem? Unicidade? Soma=1+2+3+4=10 ≤10? Aceitar. Tour inválido [A,B,A,D]: falha unicidade.",
                              "finalVerifications": [
                                "Explica corretamente o certificado para TSP?",
                                "Descreve verificador em O(n)?",
                                "Calcula complexidade corretamente?",
                                "Distingue verificação de solução?",
                                "Aplica a exemplo concreto?",
                                "Conclui prova formalmente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de NP (20%)",
                                "Qualidade do certificado proposto (20%)",
                                "Correção do algoritmo de verificação (25%)",
                                "Análise assintótica rigorosa (20%)",
                                "Clareza na prova final (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos (verificação de ciclos)",
                                "Análise de Algoritmos (complexidade temporal)",
                                "Lógica Matemática (verificadores não-determinísticos)",
                                "Otimização Combinatória (contextualização TSP)",
                                "Probabilidade (aproximações para TSP)"
                              ],
                              "realWorldApplication": "Em logística e roteirização de veículos, provar TSP em NP justifica uso de heurísticas e aproximações em software como Google OR-Tools, pois solução exata é intratável para n grande."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Explicar redução para NP-completude",
                            "description": "Descrever a redução polinomial do Problema do Ciclo Hamiltoniano para TSP, adicionando arestas de custo zero ou unitário para preservar completude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Problemas HCP e TSP",
                                  "subSteps": [
                                    "Defina o Problema do Ciclo Hamiltoniano (HCP): dado um grafo não-direcionado G=(V,E), existe um ciclo que visita cada vértice exatamente uma vez?",
                                    "Defina o Problema do Caixeiro Viajante (TSP): dado um grafo completo ponderado, existe um ciclo de custo no máximo K que visita cada vértice exatamente uma vez?",
                                    "Explique por que HCP é NP-completo e como isso motiva a redução para TSP",
                                    "Diferencie decisão TSP de otimização TSP",
                                    "Revise conceitos de redução polinomial: transformação em tempo polinomial preservando sim/não"
                                  ],
                                  "verification": "Escreva definições precisas de HCP e TSP e liste 3 propriedades NP-completas do HCP",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, lápis, acesso a Wikipedia ou livro de teoria da complexidade (ex: Sipser)",
                                  "tips": "Use diagramas simples para visualizar HCP vs TSP",
                                  "learningObjective": "Entender as diferenças e semelhanças entre HCP e TSP para preparar a redução",
                                  "commonMistakes": "Confundir HCP (sem pesos) com TSP (com pesos); ignorar versão de decisão do TSP"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Instância TSP a partir de HCP",
                                  "subSteps": [
                                    "Dado grafo G=(V,E) de HCP com n vértices, crie grafo completo G' com todos os pares de vértices conectados",
                                    "Atribua custo 1 às arestas (u,v) se {u,v} ∈ E (arestas originais de G)",
                                    "Atribua custo 2 às arestas {u,v} ∉ E (arestas adicionadas para completar o grafo)",
                                    "Defina K = n como limite de custo para a instância de decisão TSP",
                                    "Verifique que a construção leva O(n²) tempo (polinomial)"
                                  ],
                                  "verification": "Desenhe G' para um grafo HCP exemplo com 4 vértices e confirme custos corretos",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, software de grafos (ex: Graphviz ou Draw.io)",
                                  "tips": "Comece com grafos pequenos (n=3-4) para testar a construção manualmente",
                                  "learningObjective": "Dominar a transformação polinomial de HCP para TSP preservando estrutura",
                                  "commonMistakes": "Usar custo 0 em vez de 1/2; esquecer de tornar o grafo completo"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Equivalência da Redução",
                                  "subSteps": [
                                    "Mostre ⇒: Se G tem ciclo Hamiltoniano, então G' tem tour TSP de custo exatamente n (todas arestas custo 1)",
                                    "Mostre ⇐: Se G' tem tour de custo ≤ n, então deve usar apenas arestas de custo 1, formando ciclo Hamiltoniano em G",
                                    "Argumente que custo > n implica pelo menos uma aresta de custo 2, impossibilitando ciclo em G",
                                    "Confirme que o tour em G' é um ciclo fechado visitando todos vértices exatamente uma vez",
                                    "Teste com contraexemplos: grafo sem HCP deve ter TSP custo > n"
                                  ],
                                  "verification": "Escreva prova formal em duas direções e valide com grafo exemplo",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno para anotações lógicas, exemplos impressos de grafos",
                                  "tips": "Use seta ⇒ e ⇐ para clareza; prove por contradição na direção ⇐",
                                  "learningObjective": "Compreender como a redução preserva a resposta sim/não",
                                  "commonMistakes": "Ignorar que tour pode repetir arestas; confundir tour aberto com ciclo"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir NP-Completude e Verificações",
                                  "subSteps": [
                                    "Relembre: HCP NP-completo, redução polinomial para TSP, TSP em NP (verificação de tour em tempo polinomial)",
                                    "Conclua: TSP é NP-completo por teorema de Cook-Levin/Karp",
                                    "Discuta variações: custo 0/unitário em contextos métricos, mas 1/2 padrão para completude",
                                    "Liste implicações: TSP não tem algoritmo polinomial (a menos P=NP)",
                                    "Pratique explicando a redução oralmente em 2 minutos"
                                  ],
                                  "verification": "Explique a redução completa para um par (aluno/parceiro) e responda perguntas",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gravador de voz ou parceiro para feedback",
                                  "tips": "Resuma em bullet points antes de verbalizar",
                                  "learningObjective": "Sintetizar a prova de NP-completude do TSP via redução",
                                  "commonMistakes": "Esquecer que TSP está em NP; alegar primalidade sem redução"
                                }
                              ],
                              "practicalExample": "Grafo HCP: vértices A,B,C,D; arestas AB,BC,CD,DA (tem ciclo). G': todas arestas, custo 1 nas existentes, 2 nas outras (AC,AD,BD,etc.). Tour AB-BC-CD-DA custo 4=n. Sem ciclo (remova DA): mínimo tour usa custo 2, total >4.",
                              "finalVerifications": [
                                "Pode construir G' corretamente para grafo n=5?",
                                "Prova ⇒ e ⇐ sem falhas lógicas?",
                                "Explica tempo polinomial da redução?",
                                "Identifica por que TSP em NP?",
                                "Aplica redução a exemplo sem HCP?",
                                "Verbaliza redução em <3 minutos?"
                              ],
                              "assessmentCriteria": [
                                "Correção da construção (custos 1/2 exatos): 25%",
                                "Prova de equivalência completa e rigorosa: 30%",
                                "Clareza na explicação e uso de exemplos: 20%",
                                "Compreensão de conceitos NP (tempo poly, verificador): 15%",
                                "Aplicação a variações e contraexemplos: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos Grafos e ciclos",
                                "Lógica e Proofs: Raciocínio por contradição e bicondicionais",
                                "Análise de Algoritmos: Classes P, NP e reduções",
                                "Física Computacional: Modelagem de problemas de otimização"
                              ],
                              "realWorldApplication": "Em logística (roteirização de entregas), entender NP-completude do TSP justifica uso de heurísticas como Christofides em vez de exaustão, economizando tempo em empresas como Amazon ou Uber."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Discutir implicações da NP-dificuldade",
                            "description": "Analisar ausência de algoritmos polinomiais determinísticos (assumindo P≠NP) e motivação para heurísticas e aproximações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de P, NP e NP-dificuldade",
                                  "subSteps": [
                                    "Revise a definição de problemas em P: decidíveis em tempo polinomial por máquina determinística.",
                                    "Estude problemas em NP: soluções verificáveis em tempo polinomial.",
                                    "Analise o conceito de NP-completo: problemas em NP tão difíceis quanto os mais difíceis de NP.",
                                    "Discuta a hipótese P ≠ NP e evidências indiretas (como a maioria dos pesquisadores acredita nisso).",
                                    "Identifique o TSP como NP-completo via redução de problemas conhecidos."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando P vs NP e por quê TSP é NP-difícil.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (ex: Sipser), slides sobre complexidade, acesso à Wikipedia para referências rápidas.",
                                  "tips": "Use analogias como 'P é como resolver um cubo rubik rápido, NP é verificar se está resolvido'.",
                                  "learningObjective": "Dominar as bases teóricas para discutir implicações sem confusões conceituais.",
                                  "commonMistakes": "Confundir NP com 'não polinomial' em vez de 'verificável polinomialmente'; ignorar que P ⊆ NP."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a ausência de algoritmos polinomiais determinísticos para TSP",
                                  "subSteps": [
                                    "Assuma P ≠ NP e explique por quê não existe algoritmo exato polinomial para TSP.",
                                    "Discuta o crescimento exponencial do tempo de soluções exatas (ex: 2^n para branch-and-bound).",
                                    "Calcule exemplos: tempo para n=20, 50 cidades em computadores reais.",
                                    "Compare com problemas em P, como Dijkstra para caminhos mais curtos.",
                                    "Liste consequências: inviabilidade para instâncias grandes (n > 100)."
                                  ],
                                  "verification": "Crie uma tabela comparando tempo de execução exato vs polinomial para tamanhos de TSP variados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Python para simulações de tempo, grafo de exemplo do TSP.",
                                  "tips": "Visualize com gráficos logarítmicos para enfatizar o 'muro exponencial'.",
                                  "learningObjective": "Entender quantitativamente por quê soluções exatas falham na prática.",
                                  "commonMistakes": "Acreditar que 'NP-difícil significa impossível'; esquecer que assumimos P ≠ NP."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a motivação para heurísticas em problemas NP-difíceis",
                                  "subSteps": [
                                    "Defina heurística: método que encontra soluções boas rapidamente, sem garantia ótima.",
                                    "Explique trade-offs: velocidade vs qualidade (aproximação vs exatidão).",
                                    "Descreva heurísticas para TSP: nearest neighbor, greedy, 2-opt.",
                                    "Simule uma heurística simples em um grafo pequeno de 10 cidades.",
                                    "Discuta quando usar: instâncias grandes onde exato é impossível."
                                  ],
                                  "verification": "Implemente nearest neighbor em pseudocódigo e teste em exemplo TSP.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (Python ou papel), mapa ou grafo de cidades exemplo.",
                                  "tips": "Comece com heurísticas locais para ver melhorias iterativas.",
                                  "learningObjective": "Reconhecer heurísticas como ponte prática entre teoria e aplicação.",
                                  "commonMistakes": "Confundir heurística com aleatoriedade; esperar garantias de otimalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar esquemas de aproximação e suas limitações",
                                  "subSteps": [
                                    "Defina algoritmo de aproximação: garante solução dentro de fator ρ do ótimo.",
                                    "Estude aproximação para métrica TSP: Christofides (ρ=1.5).",
                                    "Compare com heurísticas sem garantia (ex: pode ser 50% pior).",
                                    "Discuta inaproximabilidade: alguns problemas sem aproximação polinomial boa.",
                                    "Sintetize: aproximações quando possível, heurísticas como fallback."
                                  ],
                                  "verification": "Escreva parágrafo comparando Christofides vs nearest neighbor em métrica TSP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos ou vídeos sobre Christofides, calculadora para fatores de aproximação.",
                                  "tips": "Lembre: ρ=1.5 significa no pior caso 50% pior que ótimo.",
                                  "learningObjective": "Diferenciar aproximações teoricamente fundamentadas de heurísticas empíricas.",
                                  "commonMistakes": "Ignorar que nem todos NP-difícil têm boas aproximações."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar implicações gerais e discutir no contexto do TSP",
                                  "subSteps": [
                                    "Resuma implicações: foco em prático sobre exato para otimização real.",
                                    "Discuta avanços: meta-heurísticas (genético, simulated annealing).",
                                    "Aborde pesquisas abertas: se P=NP muda tudo; quantum computing.",
                                    "Relacione com outros NP-completos (SAT, knapsack).",
                                    "Prepare argumentos para debate: 'Vale investir em exatos?'"
                                  ],
                                  "verification": "Crie apresentação de 5 slides resumindo toda a discussão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramenta de slides (PowerPoint/Google Slides), notas dos steps anteriores.",
                                  "tips": "Use bullet points claros; inclua um contra-argumento para robustez.",
                                  "learningObjective": "Integrar conhecimentos em visão holística das implicações.",
                                  "commonMistakes": "Superestimar heurísticas como 'sempre boas o suficiente'; negligenciar progresso teórico."
                                }
                              ],
                              "practicalExample": "Em uma empresa de entregas com 50 cidades, um algoritmo exato demoraria dias (exponencial), mas heurística nearest neighbor encontra rota viável em segundos, 10-20% pior que ótima, permitindo entregas diárias.",
                              "finalVerifications": [
                                "Explicar corretamente por quê TSP não tem algoritmo polinomial assumindo P≠NP.",
                                "Listar 3 heurísticas para TSP com prós/contras.",
                                "Calcular fator de aproximação de Christofides.",
                                "Discutir trade-off tempo vs qualidade em exemplo real.",
                                "Identificar 2 limitações de heurísticas.",
                                "Relacionar com outro problema NP-completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (P/NP correto: 30%)",
                                "Profundidade de análise de implicações (25%)",
                                "Exemplos práticos e cálculos quantitativos (20%)",
                                "Clareza na distinção heurística vs aproximação (15%)",
                                "Síntese e conexões interdisciplinares (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização Combinatória.",
                                "Economia: Modelos de Otimização em Logística e Cadeia de Suprimentos.",
                                "Filosofia: Discussões sobre Limites do Conhecimento e Indecidibilidade.",
                                "Engenharia: Design de Algoritmos em Sistemas Embarcados."
                              ],
                              "realWorldApplication": "Na roteirização de veículos (UPS/FedEx economizam milhões com heurísticas TSP), planejamento de circuitos VLSI, sequenciamento genômico e otimização de redes de telecomunicações, onde instâncias grandes exigem soluções práticas rápidas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.4",
                        "name": "Heurísticas para TSP",
                        "description": "Algoritmos aproximados e meta-heurísticas para TSP, incluindo nearest neighbor, inserção e Christofides, com análise de garantias de aproximação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.4.1",
                            "name": "Implementar heurística nearest neighbor",
                            "description": "Descrever e aplicar o algoritmo guloso que inicia em uma cidade e sempre escolhe a mais próxima não visitada, calculando tours em instâncias pequenas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a instância do problema TSP",
                                  "subSteps": [
                                    "Defina o número de cidades (n) para uma instância pequena, como 4-6 cidades.",
                                    "Crie uma matriz de distâncias simétrica n x n, com diagonal zero e valores positivos off-diagonal representando distâncias euclidianas ou reais.",
                                    "Implemente uma função para imprimir a matriz e validar simetria (dist[i][j] == dist[j][i]).",
                                    "Escolha coordenadas 2D opcionais para cidades e calcule distâncias euclidianas usando sqrt((x2-x1)^2 + (y2-y1)^2).",
                                    "Teste a matriz com uma impressão para confirmar valores corretos."
                                  ],
                                  "verification": "Matriz impressa corretamente, simétrica, diagonal zero e sem valores negativos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Biblioteca math para sqrt (import math)"
                                  ],
                                  "tips": "Use listas de listas para a matriz em Python; comece com n=4 para simplicidade.",
                                  "learningObjective": "Representar grafos completos do TSP como matriz de adjacência para acesso O(1) a distâncias.",
                                  "commonMistakes": [
                                    "Diagonal não zero",
                                    "Matriz assimétrica",
                                    "Valores negativos ou zero off-diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar estruturas de dados do algoritmo",
                                  "subSteps": [
                                    "Selecione uma cidade inicial arbitrária (ex: índice 0).",
                                    "Crie uma lista 'tour' vazia e adicione a cidade inicial.",
                                    "Inicialize um array 'visited' de tamanho n com False, marcando a inicial como True.",
                                    "Defina 'current_city' como a cidade inicial.",
                                    "Prepare uma variável para acumular o custo total, iniciando em zero."
                                  ],
                                  "verification": "Estruturas impressas: tour=[0], visited=[True, False, ...], current_city=0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Listas e arrays Python nativos"
                                  ],
                                  "tips": "Use índices de 0 a n-1 para cidades; evite strings para eficiência.",
                                  "learningObjective": "Configurar estados iniciais para rastrear progresso no algoritmo guloso.",
                                  "commonMistakes": [
                                    "Não marcar inicial como visitada",
                                    "tour inicia vazio",
                                    "Índices off-by-one"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop principal da heurística nearest neighbor",
                                  "subSteps": [
                                    "While len(tour) < n: encontre a cidade não visitada com menor distância da current_city.",
                                    "Itere sobre todas cidades j != current_city e !visited[j], rastreie min_dist e next_city.",
                                    "Adicione next_city ao tour, marque visited[next_city]=True, atualize current_city=next_city.",
                                    "Acumule custo_total += dist[current_city][next_city] no loop.",
                                    "Saia do loop quando todas cidades visitadas."
                                  ],
                                  "verification": "Após loop, len(tour)==n, todas visited=True, tour impresso sem repetições.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Loops for/while Python"
                                  ],
                                  "tips": "O(n^2) é aceitável para instâncias pequenas; otimize rastreando min_dist=inf inicialmente.",
                                  "learningObjective": "Aplicar escolha gulosa local (nearest unvisited) em cada iteração.",
                                  "commonMistakes": [
                                    "Escolher cidade já visitada",
                                    "Não atualizar current_city",
                                    "Índice incorreto em dist[][]"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Fechar o tour e calcular custo final",
                                  "subSteps": [
                                    "Adicione a cidade inicial ao final do tour para fechá-lo.",
                                    "Acumule o custo de retorno: custo_total += dist[tour[-1]][tour[0]].",
                                    "Implemente função para imprimir o tour completo e custo total.",
                                    "Adicione comentários explicando cada linha do algoritmo.",
                                    "Execute com a instância de teste e valide saída."
                                  ],
                                  "verification": "Tour fecha corretamente (primeira==última implicitamente), custo_total >0 e finito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código completo anterior"
                                  ],
                                  "tips": "Salve o código em função nearest_neighbor_tsp(dist_matrix) para reutilização.",
                                  "learningObjective": "Completar o ciclo Hamiltoniano aproximado e quantificar qualidade da solução.",
                                  "commonMistakes": [
                                    "Esquecer custo de retorno",
                                    "tour[-1] != última antes de fechar",
                                    "Divisão por zero em distâncias"
                                  ]
                                }
                              ],
                              "practicalExample": "Para 4 cidades A(0), B(1), C(2), D(3) com distâncias [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]:\n- Inicie em 0 (A).\n- Nearest de A: B(10).\n- Nearest de B: D(25).\n- Nearest de D: C(30).\n- Retorno C->A(15).\nTour: [0,1,3,2,0], Custo: 10+25+30+15=80.",
                              "finalVerifications": [
                                "Código executa sem erros para n<=10.",
                                "Todas cidades visitadas exatamente uma vez no tour.",
                                "Custo total calculado corretamente somando distâncias consecutivas.",
                                "Tour inicia e termina na mesma cidade.",
                                "Solução é válida (caminho fechado sem self-loops).",
                                "Impressão clara do tour e custo."
                              ],
                              "assessmentCriteria": [
                                "Correção: Algoritmo segue exatamente nearest neighbor (escolha gulosa local).",
                                "Eficiência: Tempo O(n^2) com loops simples, sem otimizações desnecessárias.",
                                "Clareza: Código legível, indentado, com comentários em cada step.",
                                "Robustez: Trata n=1 ou n=2 corretamente; matriz válida.",
                                "Testabilidade: Função modular aceita dist_matrix como input.",
                                "Documentação: Explica por que é heurística (não ótima)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Matrizes de Adjacência.",
                                "Geografia: Otimização de Rotas de Viagem e Logística Espacial.",
                                "Economia: Redução de Custos em Problemas de Otimização Combinatória.",
                                "Física: Trajetórias Mínimas em Sistemas Dinâmicos."
                              ],
                              "realWorldApplication": "Aplicada em softwares de roteirização veicular (ex: Google Maps para entregas múltiplas, otimização de rotas de drones ou caminhões em e-commerce como Amazon, reduzindo tempo e combustível em até 20-30% em cenários reais de TSP aproximado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.4.2",
                            "name": "Explicar heurística de inserção",
                            "description": "Detalhar métodos de inserção (mais barata, mais distante) que constroem tours adicionando cidades ao ciclo atual com menor aumento de custo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do TSP e Tours Iniciais",
                                  "subSteps": [
                                    "Revise o Problema do Caixeiro Viajante (TSP): encontrar o ciclo hamiltoniano de menor custo total.",
                                    "Aprenda sobre tours parciais: comece com um ciclo inicial mínimo (ex: 3 cidades formando um triângulo).",
                                    "Identifique o conjunto de cidades não visitadas (U) e o tour atual (T).",
                                    "Calcule distâncias entre todas as cidades usando uma matriz de custos.",
                                    "Desenhe um grafo simples com 4-5 cidades para visualização."
                                  ],
                                  "verification": "Desenhe um tour inicial com 3 cidades e liste as cidades restantes em U.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Matriz de distâncias de exemplo (ex: cidades A,B,C,D,E)"
                                  ],
                                  "tips": "Use cores diferentes para tour atual (azul) e não visitadas (vermelho) para facilitar visualização.",
                                  "learningObjective": "Compreender o estado inicial das heurísticas de inserção no TSP.",
                                  "commonMistakes": [
                                    "Confundir tour hamiltoniano com caminho simples",
                                    "Ignorar que o tour deve ser um ciclo fechado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conceituar o Processo de Inserção Genérico",
                                  "subSteps": [
                                    "Para cada cidade k em U, encontre a aresta (i,j) no tour T que minimiza o custo de inserção: c(i,k) + c(k,j) - c(i,j).",
                                    "O aumento de custo é delta = c(i,k) + c(k,j) - c(i,j); escolha o menor delta.",
                                    "Insira k entre i e j no tour, atualizando T e removendo k de U.",
                                    "Repita até U estar vazio.",
                                    "Registre o tour e custo total após cada inserção."
                                  ],
                                  "verification": "Calcule manualmente o delta para uma cidade k e uma aresta (i,j) específica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz de distâncias",
                                    "Planilha ou calculadora para somas"
                                  ],
                                  "tips": "Sempre subtraia c(i,j) para capturar o 'aumento líquido' no custo do tour.",
                                  "learningObjective": "Dominar a fórmula e lógica de inserção mais barata (cheapest insertion).",
                                  "commonMistakes": [
                                    "Esquecer de subtrair c(i,j)",
                                    "Não considerar todas as arestas do tour atual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Variantes: Inserção Mais Distante e Outras",
                                  "subSteps": [
                                    "Heurística Mais Distante (Farthest Insertion): Escolha primeiro a k em U mais distante de todo o tour T (max min dist a pontos em T).",
                                    "Em seguida, insira essa k na posição de menor delta, como no genérico.",
                                    "Compare com Nearest Insertion: Escolha k mais próxima do tour.",
                                    "Simule uma iteração completa para cada variante em um exemplo pequeno.",
                                    "Discuta trade-offs: mais distante tende a tours mais equilibrados."
                                  ],
                                  "verification": "Identifique a cidade mais distante em um exemplo e calcule sua inserção.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplo impresso com distâncias",
                                    "Ferramenta online como TSP solver para verificação"
                                  ],
                                  "tips": "Farthest prioriza cobertura espacial; cheapest foca em custo imediato.",
                                  "learningObjective": "Diferenciar e aplicar variantes da heurística de inserção.",
                                  "commonMistakes": [
                                    "Confundir seleção de k com seleção de posição",
                                    "Não atualizar distâncias mínimas após inserções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Analisar um Tour Completo",
                                  "subSteps": [
                                    "Comece com tour {A-B-C-A}, U={D,E}.",
                                    "Aplique cheapest insertion passo a passo até o tour final.",
                                    "Repita com farthest insertion e compare custos e tours.",
                                    "Meça qualidade: custo total vs. ótimo conhecido.",
                                    "Registre lições sobre aproximação e limitações (não garante ótimo)."
                                  ],
                                  "verification": "Construa dois tours finais e calcule seus custos totais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz de exemplo fixa",
                                    "Gráfico para plotar tours"
                                  ],
                                  "tips": "Use pseudocódigo para automatizar cálculos mentais.",
                                  "learningObjective": "Executar a heurística end-to-end e avaliar resultados.",
                                  "commonMistakes": [
                                    "Parar com tour aberto",
                                    "Erros aritméticos em deltas cumulativos"
                                  ]
                                }
                              ],
                              "practicalExample": "Cidades: A(0,0), B(1,0), C(1,1), D(0,1), E(2,0.5). Distâncias euclidianas. Início: T={A-B-C-A}, U={D,E}. Cheapest: Insira D entre A-C (delta=1.41), novo T={A-D-C-B-A}, custo+1.41. Depois E entre B-C (delta≈1.12), tour final custo≈6.83. Farthest: E é mais distante, insira entre B-C (delta=1.12), etc.",
                              "finalVerifications": [
                                "Explicar a fórmula de delta de inserção sem hesitação.",
                                "Simular inserção de uma cidade em um tour dado em <2 min.",
                                "Diferenciar cheapest vs. farthest insertion com exemplos.",
                                "Calcular custo total de um tour construído corretamente.",
                                "Identificar quando uma heurística pode falhar (ex: clusters)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula de custo de inserção (100% correto).",
                                "Correta identificação de cidade e posição de inserção em simulações.",
                                "Comparação qualitativa de variantes (trade-offs claros).",
                                "Cálculos aritméticos sem erros em exemplos numéricos.",
                                "Explicação fluida dos passos em pseudocódigo ou verbal.",
                                "Reconhecimento de garantias de aproximação (ex: O(log n) para algumas)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Ciclos hamiltonianos e distâncias em grafos completos.",
                                "Matemática: Otimização combinatória e análise de custos.",
                                "Logística: Planejamento de rotas em supply chain.",
                                "Inteligência Artificial: Heurísticas em busca local e meta-heurísticas."
                              ],
                              "realWorldApplication": "Otimização de rotas de entrega para empresas como Amazon ou Uber Eats, reduzindo custos de combustível em 10-20% em cenários com 50-100 pontos de entrega, integrando com GPS e algoritmos híbridos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.4.3",
                            "name": "Analisar aproximação Christofides",
                            "description": "Apresentar o algoritmo de Christofides para TSP métrico, garantindo tour de custo no máximo 1.5 vezes o ótimo, via MST e emparelhamento mínimo de custo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema do Caixeiro Viajante (TSP) Métrico e Conceitos Básicos",
                                  "subSteps": [
                                    "Defina formalmente o TSP métrico e suas propriedades (triângulo da desigualdade).",
                                    "Explique a diferença entre tours ótimos, aproximações e heurísticas.",
                                    "Revise Minimum Spanning Tree (MST) e seu algoritmo (ex: Kruskal ou Prim).",
                                    "Discuta tours Eulerianos e Hamiltonianos em grafos.",
                                    "Entenda o conceito de emparelhamento mínimo de custo (Minimum Cost Perfect Matching - MCPM)."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre TSP métrico, MST e tours Eulerianos; desenhe um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Artigo original de Christofides (opcional)",
                                    "Ferramenta online de grafos como Graphviz"
                                  ],
                                  "tips": "Use exemplos pequenos (4-5 vértices) para visualizar; foque na métrica para desigualdades.",
                                  "learningObjective": "Compreender os pré-requisitos teóricos para o algoritmo de Christofides.",
                                  "commonMistakes": [
                                    "Confundir TSP geral com métrico",
                                    "Ignorar a propriedade de triângulo",
                                    "Misturar Euleriano com Hamiltoniano"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Árvore Geradora Mínima (MST) do Grafo Completo Métrico",
                                  "subSteps": [
                                    "Aplique Kruskal ou Prim no grafo completo das distâncias métricas.",
                                    "Verifique que o custo da MST é ≤ OPT (tour ótimo).",
                                    "Identifique os vértices de grau ímpar na MST.",
                                    "Explique por que apenas vértices ímpares precisam de matching.",
                                    "Calcule o custo da MST em um exemplo numérico."
                                  ],
                                  "verification": "Construa MST para um grafo de 5 cidades e liste graus dos vértices; comprove custo ≤ OPT.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou Python com NetworkX",
                                    "Exemplo de grafo TSP pronto"
                                  ],
                                  "tips": "Ordene arestas por peso em Kruskal; visualize o grafo para evitar ciclos.",
                                  "learningObjective": "Dominar a construção de MST e sua relação com o tour ótimo.",
                                  "commonMistakes": [
                                    "Incluir ciclos na MST",
                                    "Usar algoritmo errado para grafos densos",
                                    "Esquecer de ordenar arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encontrar Emparelhamento Mínimo de Custo para Vértices de Grau Ímpar",
                                  "subSteps": [
                                    "Crie o grafo completo apenas entre vértices de grau ímpar da MST.",
                                    "Calcule o MCPM nesse subgrafo (use algoritmo de blossom ou biblioteca).",
                                    "Prove que custo do MCPM ≤ 0.5 OPT.",
                                    "Adicione as arestas do matching à MST, formando multigrafo.",
                                    "Verifique que todos os graus agora são pares."
                                  ],
                                  "verification": "Implemente ou calcule MCPM manualmente para 4 vértices ímpares e adicione à MST.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca Python NetworkX ou SciPy para matching",
                                    "Papel para cálculo manual"
                                  ],
                                  "tips": "Para pares ímpares, matching é trivial; use desigualdade de triângulo para prova.",
                                  "learningObjective": "Aprender a resolver MCPM e integrar à MST para Eulerianidade.",
                                  "commonMistakes": [
                                    "Matching em todos vértices, não só ímpares",
                                    "Não usar métrica para bound",
                                    "Erros em blossom algorithm"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir Tour Euleriano e Converter para Tour Hamiltoniano via Shortcut",
                                  "subSteps": [
                                    "Encontre um tour Euleriano no multigrafo (Hierholzer's algorithm).",
                                    "Aplique shortcutting: pule vértices visitados múltiplas vezes usando triângulo.",
                                    "Prove que o tour resultante é Hamiltoniano e válido para TSP.",
                                    "Calcule o custo: custo(Euler) ≤ MST + 0.5 OPT, e shortcut não aumenta.",
                                    "Implemente em código ou simule manualmente."
                                  ],
                                  "verification": "Desenhe o tour Euleriano, aplique shortcut e confirme que visita cada vértice exatamente uma vez.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NetworkX para Eulerian tour",
                                    "Gráfico impresso do multigrafo"
                                  ],
                                  "tips": "Shortcut preserva ordem; simule passo a passo em grafos pequenos.",
                                  "learningObjective": "Executar a construção do tour aproximado.",
                                  "commonMistakes": [
                                    "Não shortcut corretamente",
                                    "Aumentar custo no shortcut",
                                    "Perder conectividade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar a Garantia de Aproximação de 1.5 OPT",
                                  "subSteps": [
                                    "Some custos: MST ≤ OPT, MCPM ≤ 0.5 OPT, tour Euleriano ≤ 1.5 OPT.",
                                    "Prove que shortcut não excede devido à métrica.",
                                    "Compare com OPT em exemplos numéricos.",
                                    "Discuta por que é 3/2-aproximação e se é tight.",
                                    "Resuma forças e limitações do algoritmo."
                                  ],
                                  "verification": "Escreva a prova formal e teste em instância onde approx = 1.5 OPT.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre provas de aproximação",
                                    "Exemplos de TSP com known OPT"
                                  ],
                                  "tips": "Use desigualdades: custo(tour) ≤ custo(Euler) ≤ MST + MCPM.",
                                  "learningObjective": "Provar a ratio de aproximação teórica.",
                                  "commonMistakes": [
                                    "Erros na soma de bounds",
                                    "Ignorar shortcut bound",
                                    "Confundir com outras heurísticas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere 4 cidades A,B,C,D com distâncias métricas: AB=1, AC=2, AD=3, BC=1, BD=4, CD=2. Construa MST (custo 4), vértices ímpares B,D; matching BD=4 (mas otimize); forme multigrafo, Euler tour A-B-C-A-D-B, shortcut A-B-C-D-A (custo 6), OPT=6, approx=1.0.",
                              "finalVerifications": [
                                "Construir Christofides em grafo de 6 vértices e calcular custo approx.",
                                "Provar verbalmente os bounds MST ≤ OPT e MCPM ≤ 0.5 OPT.",
                                "Explicar shortcut sem aumentar custo.",
                                "Comparar com MST tour simples (2-approx).",
                                "Identificar quando a approx é tight (ex: instância específica)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de MST e MCPM (custos corretos).",
                                "Correta aplicação de shortcut para tour válido.",
                                "Prova completa da ratio 1.5 com desigualdades.",
                                "Uso apropriado de propriedades métricas.",
                                "Análise de exemplo prático com cálculos numéricos.",
                                "Identificação de erros comuns e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Otimização Combinatória.",
                                "Operações Research: Planejamento de Rotas e Logística.",
                                "Engenharia de Software: Algoritmos em Bibliotecas como NetworkX.",
                                "Economia: Modelagem de Custos em Redes de Suprimento."
                              ],
                              "realWorldApplication": "Otimização de rotas de entrega para empresas como Amazon ou UPS, reduzindo custos de combustível em até 33% comparado a tours piores; usado em GPS e planejamento de circuitos de visitas em telecomunicações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Problema do Clique",
                    "description": "Definição do problema de encontrar o maior clique em um grafo e sua completude em NP.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Definição de Clique em Grafos",
                        "description": "Conceito fundamental de um clique como um subconjunto de vértices totalmente conectados em um grafo não direcionado e simples.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Identificar um clique em um grafo",
                            "description": "Dado um grafo, reconhecer e listar subconjuntos de vértices onde todo par é adjacente, diferenciando cliques de outros subgrafos como caminhos ou ciclos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Grafos",
                                  "subSteps": [
                                    "Defina um grafo como um par (V, E), onde V é o conjunto de vértices e E o conjunto de arestas.",
                                    "Diferencie grafos direcionados de não-direcionados e simples de multigrafos.",
                                    "Aprenda a representar grafos usando listas de adjacência ou matriz de adjacência.",
                                    "Desenhe um grafo simples com 4-5 vértices e rotule as arestas.",
                                    "Identifique graus de vértices e vizinhos de um vértice dado."
                                  ],
                                  "verification": "Desenhe corretamente um grafo representado por uma lista de adjacência e liste os vizinhos de cada vértice.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta online como Graphviz ou draw.io"
                                  ],
                                  "tips": "Sempre comece com representações visuais para grafos pequenos para evitar confusões.",
                                  "learningObjective": "Compreender a estrutura fundamental de grafos para basear a identificação de cliques.",
                                  "commonMistakes": [
                                    "Confundir arestas com vértices",
                                    "Ignorar autoloops ou arestas múltiplas em grafos simples"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Definição de Clique",
                                  "subSteps": [
                                    "Defina um clique como um subconjunto de vértices onde todo par de vértices distintos é adjacente.",
                                    "Note que um clique de tamanho k é um K_k completo (subgrafo completo).",
                                    "Exemplifique com cliques de tamanho 1 (trivial), 2 (aresta) e 3 (triângulo).",
                                    "Diferencie clique de subgrafo induzido completo.",
                                    "Verifique a definição em um grafo pequeno manualmente."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição e dê exemplos de cliques de tamanhos variados.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Exemplos de grafos impressos ou digitais",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Lembre-se: em um clique, a subgrafo induzido deve ser completo, sem arestas faltantes.",
                                  "learningObjective": "Dominar a definição precisa de clique para aplicação posterior.",
                                  "commonMistakes": [
                                    "Confundir clique com conjunto independente (sem arestas)",
                                    "Esquecer que deve ser todo par adjacente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar se um Subconjunto é um Clique",
                                  "subSteps": [
                                    "Para um subconjunto S de vértices, liste todos os pares possíveis em S.",
                                    "Verifique se cada par em S tem uma aresta conectando-os usando matriz ou lista de adjacência.",
                                    "Use a matriz de adjacência: para todo i ≠ j em S, A[i][j] = 1.",
                                    "Pratique com subconjuntos candidatos em um grafo de 5 vértices.",
                                    "Registre contadores de arestas faltantes para falhas."
                                  ],
                                  "verification": "Corretamente valide 3 subconjuntos diferentes como cliques ou não-cliques em um grafo dado.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Matriz de adjacência de um grafo exemplo",
                                    "Calculadora ou Python simples para verificação"
                                  ],
                                  "tips": "Comece com subconjuntos pequenos (tamanho 3) para construir confiança antes de maiores.",
                                  "learningObjective": "Desenvolver método sistemático para verificar cliques.",
                                  "commonMistakes": [
                                    "Verificar apenas alguns pares em vez de todos",
                                    "Confundir adjacência com caminho"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Cliques e Diferenciar de Outros Subgrafos",
                                  "subSteps": [
                                    "Em um grafo dado, liste todos os subconjuntos de tamanho até 4 e verifique cliques.",
                                    "Diferencie cliques de caminhos (sequência sem repetição de arestas) e ciclos (caminho fechado).",
                                    "Identifique cliques máximos (não extensíveis).",
                                    "Pratique em 2-3 grafos variados, incluindo um sem cliques grandes.",
                                    "Compare com ciclos: ciclo C_4 não é clique pois faltam diagonais."
                                  ],
                                  "verification": "Liste todos os cliques de tamanho ≥3 em um grafo e explique por que um ciclo não é clique.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Grafos de exemplo variados (com cliques, caminhos, ciclos)",
                                    "Software como NetworkX para validação opcional"
                                  ],
                                  "tips": "Use enumeração exaustiva para grafos pequenos; foque em densidade local.",
                                  "learningObjective": "Aplicar conhecimento para encontrar cliques reais e distinguir de estruturas semelhantes.",
                                  "commonMistakes": [
                                    "Chamar um ciclo de clique",
                                    "Ignorar cliques triviais ou de tamanho 2"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo G com vértices {A, B, C, D, E} e arestas: A-B, A-C, B-C, C-D, D-E, E-A. O subconjunto {A, B, C} é um clique de tamanho 3 (todos os pares adjacentes: A-B, A-C, B-C). {A, C, D} não é, pois falta A-D. Um ciclo A-E-D-C não é clique devido a arestas faltantes como A-D.",
                              "finalVerifications": [
                                "Defina corretamente um clique e dê um exemplo não-clique.",
                                "Identifique todos os cliques de tamanho ≥3 em um grafo de 6 vértices.",
                                "Explique a diferença entre clique, caminho e ciclo com contraexemplos.",
                                "Verifique manualmente se um subconjunto dado é clique usando matriz de adjacência.",
                                "Encontre um clique máximo em um grafo simples fornecido.",
                                "Diferencie subgrafo induzido de subgrafo arbitrário em contexto de cliques."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e verificação de cliques (100% dos pares checados).",
                                "Correta identificação de cliques em grafos de tamanho pequeno-médio.",
                                "Clara diferenciação de cliques de caminhos, ciclos e outros subgrafos.",
                                "Uso eficiente de representações de grafos (matriz/lista).",
                                "Capacidade de encontrar cliques máximos ou listar todos os relevantes.",
                                "Explicações claras e exemplos práticos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Combinatória (subgrafos completos K_n).",
                                "Ciência da Computação: Algoritmos NP-difíceis como Clique Máximo.",
                                "Redes e Sistemas: Análise de comunidades densas em grafos sociais.",
                                "Bioinformática: Identificação de módulos densos em redes de interação proteica.",
                                "Otimização: Base para problemas de coloração de grafos e coberturas."
                              ],
                              "realWorldApplication": "Em redes sociais, identificar cliques significa encontrar grupos onde todos os membros são amigos mútuos (comunidades densas), útil para detecção de cliques sociais, recomendação de amigos ou análise de coalizões em redes políticas/organizacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Diferenciar clique máximo e máximo clique",
                            "description": "Explicar a diferença entre um clique que não pode ser estendido (clique máximo) e o maior possível em termos de tamanho (clique máximo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de clique em grafos",
                                  "subSteps": [
                                    "Estude a definição formal de um clique: um subconjunto de vértices onde todo par é adjacente.",
                                    "Desenhe um grafo simples não direcionado e identifique subgrafos completos (cliques).",
                                    "Classifique cliques por tamanho: K1 (vértice isolado), K2 (aresta), K3 (triângulo), etc.",
                                    "Pratique identificando todos os cliques em um grafo pequeno com 5 vértices.",
                                    "Explique verbalmente o que torna um subgrafo um clique."
                                  ],
                                  "verification": "Liste todos os cliques em um grafo exemplo fornecido e confirme que cada um é completo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou software de grafos como Graphviz ou Draw.io",
                                  "tips": "Comece com grafos pequenos para evitar confusão; visualize as arestas ausentes.",
                                  "learningObjective": "Compreender o conceito fundamental de clique como base para distinções avançadas.",
                                  "commonMistakes": "Confundir clique com caminho ou ciclo; ignorar que deve ser completo (todas as arestas presentes)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender e exemplificar clique maximal (clique máximo)",
                                  "subSteps": [
                                    "Defina clique maximal: um clique que não pode ser estendido adicionando outro vértice adjacente a todos.",
                                    "Em um grafo exemplo, marque cliques que são maximais por inclusão.",
                                    "Identifique por que um clique maximal não aceita expansão: verifique vizinhança comum.",
                                    "Compare com cliques não maximais que podem ser expandidos.",
                                    "Crie um grafo onde múltiplos cliques maximais coexistam."
                                  ],
                                  "verification": "Para um clique selecionado, prove que nenhum vértice externo é adjacente a todos os seus membros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Grafo exemplo impresso ou digital; calculadora para vizinhanças.",
                                  "tips": "Use a matriz de adjacência para checar vizinhanças comuns rapidamente.",
                                  "learningObjective": "Dominar a noção de maximalidade por inclusão, independentemente do tamanho.",
                                  "commonMistakes": "Confundir maximal com maximum; achar que todo clique singleton é maximal (verificar contexto)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender e exemplificar clique maximum (máximo clique)",
                                  "subSteps": [
                                    "Defina clique maximum: o clique de maior cardinalidade (tamanho) no grafo.",
                                    "Em grafos exemplo, encontre o clique de maior tamanho e compare com maximais menores.",
                                    "Discuta que pode haver múltiplos maximum cliques, mas todos têm o mesmo tamanho.",
                                    "Use algoritmo guloso ou exaustivo para localizar em grafos pequenos.",
                                    "Meça o tamanho ω(G), a clique number do grafo."
                                  ],
                                  "verification": "Confirme que nenhum outro clique tem tamanho maior e prove completude.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software como NetworkX (Python) para enumeração de cliques.",
                                  "tips": "Procure triângulos e expanda; evite grafos densos inicialmente.",
                                  "learningObjective": "Diferenciar otimização de tamanho de propriedade local de extensibilidade.",
                                  "commonMistakes": "Assumir que todo maximal é maximum; ignorar múltiplos maximum cliques."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e aplicar as distinções em exemplos",
                                  "subSteps": [
                                    "Compare definições: maximal (não extensível) vs. maximum (maior tamanho).",
                                    "Analise grafo onde maximais ≠ maximum (ex: grafo com triângulo e arestas isoladas).",
                                    "Resolva exercícios: identifique todos maximais e o(s) maximum.",
                                    "Explique implicações para problemas NP-difíceis como Maximum Clique Problem.",
                                    "Crie seu próprio grafo e rotule cliques corretamente."
                                  ],
                                  "verification": "Em um grafo teste, liste maximais e maximum com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Grafos de teste variados; quadro para anotações.",
                                  "tips": "Lembre: todo maximum é maximal, mas nem todo maximal é maximum.",
                                  "learningObjective": "Aplicar distinção conceitual em contextos práticos de análise de grafos.",
                                  "commonMistakes": "Inverter termos; esquecer que maximum implica maximalidade."
                                }
                              ],
                              "practicalExample": "Considere o grafo com vértices A,B,C,D,E onde arestas: AB,AC,BC (triângulo ABC), DE. Aqui, {A,B,C} é maximum clique (tamanho 3) e maximal; {D,E} é maximal (tamanho 2, não extensível); {A} é clique mas não maximal (extensível para ABC).",
                              "finalVerifications": [
                                "Identificar corretamente todos os cliques maximais em um grafo dado.",
                                "Localizar o clique maximum e seu tamanho ω(G).",
                                "Explicar por que um clique específico é maximal mas não maximum.",
                                "Provar que todo maximum clique é maximal.",
                                "Analisar um grafo onde maximais têm tamanhos variados.",
                                "Diferenciar verbalmente os conceitos sem confusão de termos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais de ambos os conceitos.",
                                "Correta identificação em exemplos com múltiplos cliques.",
                                "Justificativas lógicas baseadas em adjacências e extensibilidade.",
                                "Compreensão de implicações para complexidade computacional.",
                                "Criatividade em exemplos personalizados sem erros.",
                                "Clareza na distinção: maximal por inclusão vs. maximum por tamanho."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e inclusão (subconjuntos maximais).",
                                "Otimização: Problema NP-completo de Maximum Clique em análise de algoritmos.",
                                "Redes: Modelagem de comunidades em grafos sociais (ciências sociais).",
                                "Bioinformática: Cliques em grafos de interação proteica."
                              ],
                              "realWorldApplication": "Em redes sociais, cliques maximais representam grupos fechados não expansíveis (comunidades locais), enquanto maximum clique identifica o maior grupo totalmente conectado, útil para detecção de cliques em análise de amigos no Facebook ou clusters em bioinformática para módulos genéticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Representar grafos para cliques",
                            "description": "Usar matriz de adjacência ou listas de adjacência para visualizar e verificar a existência de cliques em grafos de exemplo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de grafos e cliques",
                                  "subSteps": [
                                    "Defina um grafo como um par (V, E), onde V é o conjunto de vértices e E o conjunto de arestas.",
                                    "Explique que um clique é um subconjunto de vértices onde todo par é conectado por uma aresta.",
                                    "Identifique exemplos simples: um clique de tamanho 1 (vértice isolado), tamanho 2 (aresta), tamanho 3 (triângulo).",
                                    "Diferencie cliques máximos (não extensíveis) de cliques máximos em tamanho.",
                                    "Estude propriedades: em um clique K_r, há exatamente r(r-1)/2 arestas."
                                  ],
                                  "verification": "Resuma em suas palavras a definição de clique e dê um exemplo com 3 vértices.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta para esboços",
                                    "Documentação de teoria dos grafos (ex: Wikipedia: Clique (graph theory))"
                                  ],
                                  "tips": [
                                    "Use diagramas visuais para fixar conceitos.",
                                    "Comece com grafos pequenos para intuição."
                                  ],
                                  "learningObjective": "Compreender precisamente o que é um clique em um grafo.",
                                  "commonMistakes": [
                                    "Confundir clique com conjunto independente.",
                                    "Ignorar que cliques requerem todas as arestas possíveis entre vértices."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir representação por matriz de adjacência",
                                  "subSteps": [
                                    "Numere os vértices de 1 a n para um grafo G com n vértices.",
                                    "Crie uma matriz n x n inicializada com zeros.",
                                    "Para cada aresta {u,v}, defina M[u][v] = 1 e M[v][u] = 1 (grafo não-direcionado).",
                                    "Verifique simetria da matriz (M[i][j] = M[j][i]).",
                                    "Identifique submatrizes 1's para potenciais cliques."
                                  ],
                                  "verification": "Construa a matriz para um grafo com 4 vértices e arestas {1-2,1-3,2-3,3-4} e confirme simetria.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Papel quadriculado"
                                  ],
                                  "tips": [
                                    "Mantenha vértices ordenados numericamente para facilitar.",
                                    "Use 1 para adjacentes, 0 para não."
                                  ],
                                  "learningObjective": "Representar grafos de forma matricial para análise visual de cliques.",
                                  "commonMistakes": [
                                    "Esquecer simetria em grafos não-direcionados.",
                                    "Usar índices errados (começar de 0 vs 1)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir representação por listas de adjacência",
                                  "subSteps": [
                                    "Crie um array ou dicionário com chaves como vértices.",
                                    "Para cada vértice u, liste todos v adjacentes a u, ordenados.",
                                    "Garanta que listas sejam simétricas: se v em lista(u), então u em lista(v).",
                                    "Compare com matriz: listas são mais eficientes para grafos esparsos.",
                                    "Use listas para visualizar vizinhanças completas em cliques."
                                  ],
                                  "verification": "Construa listas para o mesmo grafo do passo 2 e compare com matriz.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor de texto ou Python/Jupyter para listas",
                                    "Papel para rascunho"
                                  ],
                                  "tips": [
                                    "Ordene listas alfabeticamente ou numericamente para padronização.",
                                    "Evite duplicatas nas listas."
                                  ],
                                  "learningObjective": "Representar grafos listando vizinhos para detecção rápida de cliques.",
                                  "commonMistakes": [
                                    "Incluir auto-aresta (u em lista(u)).",
                                    "Listas assimétricas por esquecimento."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar existência de cliques usando representações",
                                  "subSteps": [
                                    "Escolha um subconjunto S de vértices candidato a clique.",
                                    "Na matriz: verifique se submatriz S x S é toda 1's (exceto diagonal).",
                                    "Nas listas: para todo par u,v em S, verifique se v em lista(u).",
                                    "Teste exemplos: encontre clique máximo em grafos pequenos.",
                                    "Documente achados: tamanho do clique, vértices envolvidos."
                                  ],
                                  "verification": "Para um grafo exemplo, identifique e prove um clique de tamanho 3.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "As representações dos passos anteriores",
                                    "Ferramenta de grafos como Graphviz ou NetworkX (opcional)"
                                  ],
                                  "tips": [
                                    "Comece verificando pares, depois trios.",
                                    "Automatize mentalmente: 'todos conectados a todos?'"
                                  ],
                                  "learningObjective": "Usar representações para confirmar cliques em grafos de exemplo.",
                                  "commonMistakes": [
                                    "Verificar apenas uma direção nas listas.",
                                    "Ignorar diagonal na matriz (deve ser 0)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar com grafos variados e sintetizar",
                                  "subSteps": [
                                    "Gere ou pegue 3 grafos exemplo: completo, vazio, com cliques óbvios/escondidos.",
                                    "Represente cada um em ambas formas e encontre cliques.",
                                    "Compare eficiência: matriz para densos, listas para esparsos.",
                                    "Registre tempo e erros por representação.",
                                    "Conclua vantagens/desvantagens para detecção de cliques."
                                  ],
                                  "verification": "Crie relatório curto com cliques encontrados em cada grafo.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Grafos impressos ou digitais",
                                    "Cronômetro para timing"
                                  ],
                                  "tips": [
                                    "Varie tamanhos: 4-6 vértices para praticidade.",
                                    "Desenhe grafos primeiro para visual."
                                  ],
                                  "learningObjective": "Aplicar representações fluentemente em múltiplos cenários.",
                                  "commonMistakes": [
                                    "Escolher grafos muito grandes inicialmente.",
                                    "Não comparar representações."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo com vértices {A,B,C,D} e arestas {A-B, A-C, B-C, C-D}. Matriz de adjacência: [[0,1,1,0],[1,0,1,0],[1,1,0,1],[0,0,1,0]]. Listas: A:[B,C], B:[A,C], C:[A,B,D], D:[C]. Clique: {A,B,C} (submatriz toda 1's; cada par nas listas mútuas). Não-clique: {A,B,D} (A não conectado a D).",
                              "finalVerifications": [
                                "Construa corretamente matriz e listas para um grafo novo.",
                                "Identifique um clique de tamanho >=3 em grafo exemplo.",
                                "Prove que um subconjunto NÃO é clique usando representações.",
                                "Explique diferença entre representações para cliques.",
                                "Encontre clique máximo em grafo com 5 vértices.",
                                "Compare tempo de verificação matriz vs listas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas representações (sem erros de adjacência).",
                                "Correta identificação e prova de cliques.",
                                "Uso eficiente de ambas representações.",
                                "Clareza em verificações e exemplos.",
                                "Compreensão de limitações (ex: escalabilidade).",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (propriedades de matrizes).",
                                "Redes sociais: Análise de comunidades densas.",
                                "Biologia: Redes de interação proteica (cliques como complexos).",
                                "Otimização: Base para algoritmos NP-difíceis como clique máximo.",
                                "Programação: Implementação em linguagens como Python (NetworkX)."
                              ],
                              "realWorldApplication": "Em redes sociais, cliques representam grupos totalmente conectados (amigos mútuos), úteis para detecção de comunidades ou fraudes; em bioinformática, cliques em redes genéticas indicam módulos funcionais; em logística, subgrafos densos otimizam rotas de entrega em clusters."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Formulação do Problema do Clique",
                        "description": "Definição formal dos problemas de decisão e otimização associados ao clique, incluindo entradas, saídas e parametrização pelo tamanho k.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Formalizar o problema de decisão CLIQUE",
                            "description": "Dado um grafo G=(V,E) e inteiro k, decidir se existe um clique de tamanho pelo menos k, especificando a linguagem {⟨G,k⟩ | G tem clique ≥k}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição formal de grafo e clique",
                                  "subSteps": [
                                    "Defina um grafo não-direcionado G = (V, E), onde V é o conjunto de vértices e E ⊆ V × V é o conjunto de arestas.",
                                    "Explique que um clique é um subconjunto C ⊆ V tal que todo par de vértices em C está conectado por uma aresta.",
                                    "Dê exemplos simples: em um grafo completo K_n, todo subconjunto é um clique.",
                                    "Diferencie clique máximo de clique máximo em tamanho.",
                                    "Verifique com um grafo pequeno se identifica cliques corretamente."
                                  ],
                                  "verification": "Liste todos os cliques de um grafo exemplo com 4 vértices.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para desenhar grafos",
                                    "Software de grafos como Graphviz ou Draw.io"
                                  ],
                                  "tips": [
                                    "Sempre verifique simetria nas arestas para grafos não-direcionados.",
                                    "Use notação padrão: pares ordenados para arestas."
                                  ],
                                  "learningObjective": "Compreender os conceitos fundamentais de grafo e clique para basear a formalização.",
                                  "commonMistakes": [
                                    "Confundir grafo direcionado com não-direcionado.",
                                    "Esquecer que cliques requerem todas as arestas possíveis entre vértices."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o problema de decisão",
                                  "subSteps": [
                                    "Defina o problema: dado G = (V, E) e inteiro k ≥ 1, decidir se existe um clique de tamanho pelo menos k.",
                                    "Especifique que é um problema de decisão: resposta sim/não.",
                                    "Discuta o que significa 'tamanho pelo menos k': |C| ≥ k para algum clique C.",
                                    "Compare com versão de otimização (encontrar clique máximo).",
                                    "Escreva a pergunta formal: 'G tem um clique de cardinalidade ≥ k?'."
                                  ],
                                  "verification": "Escreva a formulação em linguagem natural e matemática para um exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou caderno",
                                    "Referência de teoria dos grafos (livro ou PDF)"
                                  ],
                                  "tips": [
                                    "Use 'decidir' para enfatizar sim/não, não encontrar o clique.",
                                    "k deve ser positivo inteiro."
                                  ],
                                  "learningObjective": "Capacitar a formulação precisa do problema de decisão CLIQUE.",
                                  "commonMistakes": [
                                    "Confundir com problema de busca (encontrar o clique).",
                                    "Ignorar restrições em k (ex: k > |V| é trivial não)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar a codificação da instância ⟨G, k⟩",
                                  "subSteps": [
                                    "Defina a codificação: representação binária ou textual de G (lista de adjacência ou matriz) e k em binário.",
                                    "Garanta que ⟨G, k⟩ seja uma string única representando a instância.",
                                    "Exemplo: matriz de adjacência para G e string binária para k.",
                                    "Discuta unicidade e legibilidade da codificação.",
                                    "Verifique se diferentes grafos têm codificações distintas."
                                  ],
                                  "verification": "Codifique um grafo específico com k=3 e valide a representação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora para conversão binária",
                                    "Ferramenta online de codificação de grafos"
                                  ],
                                  "tips": [
                                    "Padronize a codificação para consistência em teoria da computação.",
                                    "Inclua separadores claros entre G e k."
                                  ],
                                  "learningObjective": "Dominar a representação formal das entradas para problemas NP.",
                                  "commonMistakes": [
                                    "Usar representação ambígua (ex: lista sem ordenação).",
                                    "Esquecer de codificar k corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir a linguagem formal CLIQUE",
                                  "subSteps": [
                                    "Defina a linguagem L_CLIQUE = { ⟨G, k⟩ | G tem um clique de tamanho ≥ k }.",
                                    "Especifique que é um subconjunto de {0,1}* (todas strings binárias).",
                                    "Verifique propriedades: L é decidível? Não, mas reconhecível.",
                                    "Dê exemplo de instância em L e fora de L.",
                                    "Conclua ligando à classe NP."
                                  ],
                                  "verification": "Escreva a definição exata da linguagem e classifique duas instâncias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios com grafos",
                                    "Livro de complexidade computacional (cap. NP)"
                                  ],
                                  "tips": [
                                    "Use chaves { } para definir linguagens formais.",
                                    "Lembre: linguagem é conjunto de instâncias 'sim'."
                                  ],
                                  "learningObjective": "Formalizar completamente o problema como linguagem em teoria da computação.",
                                  "commonMistakes": [
                                    "Definir como instâncias 'não'.",
                                    "Omitir a codificação ⟨G,k⟩ na definição."
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo G com V={a,b,c,d}, E={(a,b),(b,c),(c,a),(a,d)}. k=3. Instância ⟨G,3⟩ ∈ L_CLIQUE porque {a,b,c} é um clique de tamanho 3. Para k=4, não.",
                              "finalVerifications": [
                                "Pode definir corretamente um clique em qualquer grafo dado.",
                                "Formula o problema de decisão sem ambiguidades.",
                                "Codifica ⟨G,k⟩ de forma padrão e única.",
                                "Escreve a linguagem L_CLIQUE com notação precisa.",
                                "Classifica corretamente instâncias em L ou não.",
                                "Explica a diferença entre decisão e otimização."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de grafo e clique (100% correto).",
                                "Clareza na formulação do problema de decisão.",
                                "Corretude na codificação da instância.",
                                "Uso correto de notação formal para linguagens.",
                                "Capacidade de exemplos válidos e contraexemplos.",
                                "Compreensão de contexto NP-completo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Conjuntos.",
                                "Lógica: Linguagens Formais e Autômatos.",
                                "Física: Modelagem de Redes Complexas.",
                                "Economia: Otimização em Mercados e Redes Sociais."
                              ],
                              "realWorldApplication": "Em redes sociais, detectar comunidades densas (cliques) para recomendações de amigos ou análise de influência; em bioinformática, encontrar subgrafos densos em redes de proteínas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Formalizar o problema de otimização Clique Máximo",
                            "description": "Definir o problema de encontrar o tamanho ω(G) do maior clique e o subconjunto correspondente, destacando sua relação com o problema de decisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Grafos e Cliques",
                                  "subSteps": [
                                    "Defina formalmente um grafo não-direcionado simples G = (V, E), onde V é o conjunto de vértices e E o conjunto de arestas.",
                                    "Explique o conceito de subgrafo induzido por um subconjunto S ⊆ V.",
                                    "Defina um clique em G como um subconjunto S ⊆ V tal que para todo par u, v ∈ S, (u, v) ∈ E.",
                                    "Dê um exemplo simples de clique em um grafo pequeno.",
                                    "Diferencie clique de conjunto independente."
                                  ],
                                  "verification": "Escreva as definições em um documento e valide com um diagrama de grafo contendo um clique.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Referência de teoria dos grafos (livro ou online)"
                                  ],
                                  "tips": [
                                    "Desenhe grafos pequenos para visualizar cliques; comece com triângulos (cliques de tamanho 3)."
                                  ],
                                  "learningObjective": "Dominar a definição precisa de clique como base para problemas de otimização.",
                                  "commonMistakes": [
                                    "Confundir cliques com caminhos ou ciclos.",
                                    "Permitir grafos com laços ou múltiplas arestas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formalizar o Problema de Decisão Clique",
                                  "subSteps": [
                                    "Descreva a entrada: um grafo G = (V, E) e um inteiro k ≥ 1.",
                                    "Defina a pergunta de decisão: existe um clique S ⊆ V com |S| ≥ k?",
                                    "Especifique a saída: 'SIM' se existir, 'NÃO' caso contrário.",
                                    "Escreva a formulação em notação formal: CLIQUE = {<G, k> | G tem um clique de tamanho pelo menos k}.",
                                    "Mencione brevemente sua NP-completude para contextualizar."
                                  ],
                                  "verification": "Redija uma declaração formal do problema e teste com um grafo exemplo onde a resposta é 'SIM'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Ferramenta de grafos como Graphviz ou Draw.io"
                                  ],
                                  "tips": [
                                    "Use pseudocódigo para clareza: function hasClique(G, k) -> bool."
                                  ],
                                  "learningObjective": "Entender o problema de decisão como bloco de construção para otimização.",
                                  "commonMistakes": [
                                    "Esquecer restrições como k ≤ |V|.",
                                    "Confundir com problema de coloração de grafos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o Problema de Otimização Clique Máximo",
                                  "subSteps": [
                                    "Defina ω(G) como o tamanho do maior clique em G, i.e., max{|S| | S é clique em G}.",
                                    "Formalize o problema: dada entrada G, produzir saída ω(G) e um conjunto S ⊆ V com |S| = ω(G) e S clique.",
                                    "Especifique entradas/saídas: Input: G = (V, E); Output: par (ω(G), S).",
                                    "Discuta que encontrar ω(G) requer resolver múltiplas instâncias de decisão.",
                                    "Escreva em termos de busca: encontre o maior k tal que <G, k> ∈ CLIQUE."
                                  ],
                                  "verification": "Formule o problema em texto formal e compute ω(G) manualmente para um grafo pequeno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Exemplos de grafos impressos ou digitais"
                                  ],
                                  "tips": [
                                    "Pense em busca binária sobre k de 1 a |V| para relacionar com decisão."
                                  ],
                                  "learningObjective": "Formalizar precisamente o objetivo de otimização e sua saída.",
                                  "commonMistakes": [
                                    "Ignorar a necessidade de retornar o conjunto S, não só o tamanho.",
                                    "Confundir ω(G) com α(G), o número de independência."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer a Relação entre Problemas de Decisão e Otimização",
                                  "subSteps": [
                                    "Explique como reduzir otimização a decisão via busca binária em k.",
                                    "Descreva o algoritmo: low = 1, high = |V|; enquanto low ≤ high, teste mid; ajuste bounds.",
                                    "Discuta implicações de complexidade: se decisão é NP-completa, otimização é NP-difícil.",
                                    "Formalize: ω(G) = max{k | <G, k> é instância positiva de CLIQUE}.",
                                    "Verifique com exemplo: trace a busca binária em um grafo conhecido."
                                  ],
                                  "verification": "Implemente pseudocódigo da redução e aplique a um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo editor",
                                    "Calculadora para bounds"
                                  ],
                                  "tips": [
                                    "Registre cada iteração da busca binária em uma tabela para clareza."
                                  ],
                                  "learningObjective": "Conectar decisão e otimização, destacando reduções.",
                                  "commonMistakes": [
                                    "Assumir que otimização é polinomial se decisão for.",
                                    "Erros em bounds da busca binária."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G com V = {1,2,3,4,5}, E = {(1,2),(1,3),(2,3),(3,4),(4,5)}. Cliques incluem {1,2,3} (tamanho 3). Problema de decisão: <G,4>? NÃO. Otimização: ω(G)=3, S={1,2,3}. Use busca binária: teste k=3 → SIM, k=4 → NÃO.",
                              "finalVerifications": [
                                "Pode definir formalmente um clique?",
                                "Consegue distinguir entrada/saída de decisão vs. otimização?",
                                "Computa corretamente ω(G) para um grafo exemplo?",
                                "Descreve a redução otimização → decisão?",
                                "Identifica ω(G) e um S correspondente em exemplo prático?",
                                "Explica por que otimização é mais difícil que decisão?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de clique e ω(G) (exata, sem ambiguidades).",
                                "Clareza na formulação de entradas/saídas para ambos problemas.",
                                "Correta relação entre decisão e otimização via redução.",
                                "Uso apropriado de notação matemática (ω(G), S ⊆ V).",
                                "Exemplos concretos com grafos pequenos e computações manuais.",
                                "Compreensão de implicações de complexidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória.",
                                "Ciência da Computação: Complexidade Computacional e NP-completude.",
                                "Engenharia de Software: Modelagem de problemas em grafos para redes.",
                                "Estatística: Análise de cliques em redes sociais ou biológicas."
                              ],
                              "realWorldApplication": "Em redes sociais, encontrar o maior grupo de usuários onde todos são amigos mútuos (clique máximo) para análise de comunidades densas; em bioinformática, identificar sub-redes proteicas totalmente interconectadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Analisar complexidade conhecida",
                            "description": "Discutir que não existe algoritmo polinomial conhecido para CLIQUE, citando referências como Garey & Johnson.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Complexidade Computacional",
                                  "subSteps": [
                                    "Defina P vs NP e explique a diferença entre problemas em P e NP-completos.",
                                    "Discuta o que significa 'não existe algoritmo polinomial conhecido' para um problema.",
                                    "Identifique exemplos clássicos de problemas NP-completos, como SAT e 3-COLORING.",
                                    "Explique a implicação da hipótese P ≠ NP.",
                                    "Resuma o papel das reduções na prova de NP-dureza."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando P vs NP e liste 3 problemas NP-completos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Algorithms' de Cormen et al. (capítulos sobre complexidade)",
                                    "Notas de aula sobre teoria da complexidade"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar P, NP e NP-completos.",
                                  "learningObjective": "Compreender os fundamentos teóricos que justificam a complexidade do CLIQUE.",
                                  "commonMistakes": "Confundir 'NP-completo' com 'não solucionável em tempo polinomial' sem menção à hipótese P≠NP."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Formulação e NP-Completude do Problema CLIQUE",
                                  "subSteps": [
                                    "Descreva formalmente o problema CLIQUE: dado um grafo G e inteiro k, existe um clique de tamanho k?",
                                    "Revise a redução de 3-SAT para CLIQUE.",
                                    "Analise por que a redução polinomial prova NP-dureza.",
                                    "Verifique que CLIQUE está em NP (certificado: o subgrafo clique).",
                                    "Discuta instâncias pequenas de CLIQUE para intuição."
                                  ],
                                  "verification": "Construa manualmente a redução de uma instância 3-SAT simples para CLIQUE.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Artigo original de Karp (1972) sobre 21 problemas NP-completos",
                                    "Ferramenta de grafos online como Graphviz ou yEd"
                                  ],
                                  "tips": "Comece com grafos pequenos (n=5) para visualizar cliques.",
                                  "learningObjective": "Dominar a prova de NP-completude específica para CLIQUE.",
                                  "commonMistakes": "Ignorar o tempo da redução; ela deve ser polinomial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Consultar Referências Clássicas sobre Complexidade de CLIQUE",
                                  "subSteps": [
                                    "Localize e leia a seção sobre CLIQUE em 'Computers and Intractability' de Garey & Johnson.",
                                    "Anote teoremas chave: CLIQUE é NP-completo (Teorema 25.4).",
                                    "Compare com outras referências como Papadimitriou's 'Computational Complexity'.",
                                    "Extraia citações diretas sobre ausência de algoritmos polinomiais conhecidos.",
                                    "Pesquise atualizações recentes (ex: sem avanços polinomiais em 50 anos)."
                                  ],
                                  "verification": "Cite 3 trechos exatos de Garey & Johnson e explique seu significado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Livro 'Computers and Intractability: A Guide to the Theory of NP-Completeness' de Garey & Johnson (páginas 190-192)",
                                    "PDFs acadêmicos via Google Scholar"
                                  ],
                                  "tips": "Use Ctrl+F para buscar 'CLIQUE' no PDF do livro.",
                                  "learningObjective": "Aprender a usar fontes autoritativas para embasar discussões técnicas.",
                                  "commonMistakes": "Citar incorretamente autores ou páginas, enfraquecendo credibilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular Discussão Crítica sobre Complexidade Conhecida",
                                  "subSteps": [
                                    "Escreva um parágrafo discutindo: 'Não existe algoritmo polinomial conhecido para CLIQUE'.",
                                    "Inclua citações de Garey & Johnson e razões (NP-completo + P≠NP conjecturado).",
                                    "Discuta heurísticas existentes (ex: branch-and-bound) e seus limites.",
                                    "Aborde implicações: importância em otimização combinatória.",
                                    "Prepare contra-argumentos comuns (ex: 'Talvez exista, mas não achamos')."
                                  ],
                                  "verification": "Grave um vídeo de 2 minutos ou escreva ensaio de 300 palavras apresentando a discussão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto ou ferramenta de gravação como Loom",
                                    "Referências dos passos anteriores"
                                  ],
                                  "tips": "Estruture como: fato + evidência + implicação.",
                                  "learningObjective": "Capacitar-se a discutir rigorosamente a complexidade sem algoritmo polinomial.",
                                  "commonMistakes": "Afirmar categoricamente 'impossível' em vez de 'não conhecido'."
                                }
                              ],
                              "practicalExample": "Em uma rede social modelada como grafo (usuários=nós, amizades=arestas), encontrar o maior grupo de amigos mútuos (clique máximo) é CLIQUE; sem algoritmo polinomial, usamos aproximações para recomendações.",
                              "finalVerifications": [
                                "Pode definir corretamente CLIQUE e sua classe de complexidade?",
                                "Cita precisamente Garey & Johnson (edição, páginas)?",
                                "Explica por que 'não conhecido' vs 'improvável'?",
                                "Discute reduções ou certificados adequadamente?",
                                "Identifica limitações de algoritmos existentes?",
                                "Menciona hipótese P≠NP com precisão?"
                              ],
                              "assessmentCriteria": [
                                "Precisão factual (citações corretas): 30%",
                                "Profundidade da análise (implicações): 25%",
                                "Clareza na comunicação (linguagem acessível): 20%",
                                "Uso de evidências (reduções/referências): 15%",
                                "Originalidade na discussão: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória.",
                                "Filosofia: Lógica e Fundamentos da Computação.",
                                "Estatística: Análise de Heurísticas e Aproximações.",
                                "Engenharia: Otimização em Sistemas Reais."
                              ],
                              "realWorldApplication": "Em bioinformática, encontrar módulos densos em redes de interação proteica (cliques) para descoberta de drogas; ausência de polinomial força uso de meta-heurísticas em escala genômica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Completude em NP do Problema do Clique",
                        "description": "Demonstração de que CLIQUE pertence à classe NP e é NP-completo via reduções polinomiais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Provar que CLIQUE está em NP",
                            "description": "Construir uma máquina de Turing não-determinística ou certificado polinomial (o clique candidato) verificável em tempo polinomial O(n^2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de NP e Problema CLIQUE",
                                  "subSteps": [
                                    "Defina formalmente o problema de decisão CLIQUE: dado um grafo G=(V,E) e inteiro k, existe um subconjunto S ⊆ V com |S|=k tal que todo par em S é adjacente?",
                                    "Recapitule a classe NP: conjunto de problemas de decisão onde 'sim' tem um certificado polinomial verificável em tempo polinomial por uma máquina de Turing determinística.",
                                    "Explique o papel do certificado (witness) e do verificador V(x, w) onde |w| ≤ poly(|x|).",
                                    "Estude um exemplo simples de grafo com clique para ilustrar.",
                                    "Anote as propriedades necessárias para CLIQUE ∈ NP."
                                  ],
                                  "verification": "Escreva definições precisas e identifique corretamente o que precisa ser provado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre teoria da complexidade",
                                    "Exemplos de grafos (desenhe um grafo K3 e K4)",
                                    "Pseudocódigo editor (como Overleaf ou notebook)"
                                  ],
                                  "tips": "Use diagramas de grafos para visualização; foque na instância 'sim' apenas.",
                                  "learningObjective": "Compreender os pré-requisitos teóricos para provar membership em NP.",
                                  "commonMistakes": [
                                    "Confundir NP com P",
                                    "Ignorar que só instâncias 'sim' precisam de certificado",
                                    "Esquecer que verificador é determinístico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Certificado Polinomial para Instâncias 'Sim'",
                                  "subSteps": [
                                    "Proponha o certificado w: um subconjunto S de vértices com exatamente k elementos (representado como lista ou bitvector de tamanho n).",
                                    "Justifique por que |w| = O(n): k ≤ n, logo polinomial no tamanho da entrada |x| ≈ n^2 para grafo por adjacência.",
                                    "Para uma instância 'sim', prove que existe tal w onde G[S] é clique completo.",
                                    "Represente formalmente: w = {v_{i1}, v_{i2}, ..., v_{ik}} com índices ordenados.",
                                    "Teste com exemplo: grafo com n=5, k=3, certificado [1,2,4]."
                                  ],
                                  "verification": "Descreva w explicitamente e confirme |w| ≤ poly(n).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Grafo de exemplo representado como matriz de adjacência",
                                    "Ferramenta de desenho de grafos (Graphviz ou papel)",
                                    "Referência: Sipser 'Introduction to the Theory of Computation' cap. 7"
                                  ],
                                  "tips": "Sempre ordene os vértices no certificado para facilitar verificação.",
                                  "learningObjective": "Dominar a construção de um certificado curto e correto.",
                                  "commonMistakes": [
                                    "Certificado maior que polinomial",
                                    "Não especificar representação exata",
                                    "Incluir arestas no certificado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver o Algoritmo de Verificação Polinomial",
                                  "subSteps": [
                                    "Defina o verificador V(G, k, w): rejeite se |w| ≠ k ou w não ⊆ V.",
                                    "Cheque se todo par u,v em w tem aresta (u,v) ∈ E: para cada par (O(k^2) pares), consulte matriz de adjacência em O(1).",
                                    "Escreva pseudocódigo: for i=1 to k-1, for j=i+1 to k, if not adj[w[i]][w[j]] reject.",
                                    "Confirme que V aceita iff w é clique válido.",
                                    "Simule em exemplo: input grafo, k=3, w=[1,2,4], verifique todas 3 pares."
                                  ],
                                  "verification": "Implemente e teste pseudocódigo em um exemplo 'sim' e 'não'.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matriz de adjacência de exemplo 5x5",
                                    "Python ou pseudocódigo para simular verificador",
                                    "Exercícios de grafos NP-completos"
                                  ],
                                  "tips": "Use matriz de adjacência para O(1) consultas; evite listas de adjacência para simplicidade.",
                                  "learningObjective": "Projetar um verificador determinístico correto e eficiente.",
                                  "commonMistakes": [
                                    "Verificador não-determinístico",
                                    "Checagem incompleta de pares",
                                    "Tempo superpolinomial por par"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade e Concluir a Prova",
                                  "subSteps": [
                                    "Calcule tempo de V: checagem |w| = O(k) = O(n), pares O(k^2) = O(n^2), total O(n^2).",
                                    "Prove polinomial: O(n^2) onde n = |V|, |x| = O(n^2), logo poly(|x|).",
                                    "Escreva a prova formal: CLIQUE ∈ NP pois existe V decidindo em tempo polinomial com certificados de tamanho poly.",
                                    "Discuta contrapositivo: se não em NP, sem tal verificador.",
                                    "Teste prova com contraexemplo falho (ex: k=n+1 rejeita rápido)."
                                  ],
                                  "verification": "Escreva análise de complexidade com big-O exato e declaração final da prova.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha para análise assintótica",
                                    "Referência: Arora-Barak 'Computational Complexity' seção NP",
                                    "Timer para simular execuções"
                                  ],
                                  "tips": "Conte operações básicas: acessos à matriz são O(1).",
                                  "learningObjective": "Analisar e formalizar a prova de membership em NP.",
                                  "commonMistakes": [
                                    "Complexidade O(n^3) por confusão",
                                    "Ignorar tamanho da entrada",
                                    "Prova sem menção ao verificador determinístico"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo G com V={1,2,3,4,5}, E={(1,2),(1,4),(2,4),(3,5)}; k=3. Certificado w=[1,2,4]. Verificador: pares (1,2),(1,4),(2,4) todos em E → aceita. Se w=[1,2,3], falta (2,3) → rejeita. Tempo: 3 pares, O(1) cada.",
                              "finalVerifications": [
                                "Descreva corretamente o certificado para CLIQUE.",
                                "Escreva pseudocódigo funcional do verificador.",
                                "Calcule complexidade exata O(n^2).",
                                "Explique por que só instâncias 'sim' importam.",
                                "Aplique a prova a um grafo de exemplo.",
                                "Diferencie de problemas fora de NP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de certificado (tamanho e validade).",
                                "Corretude do algoritmo de verificação (todas pares checadas).",
                                "Análise de complexidade polinomial rigorosa.",
                                "Clareza e formalidade da prova escrita.",
                                "Uso correto de notação teórica (big-O, TM).",
                                "Tratamento de casos edge (k=0, k=1)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória (cliques como subgrafos completos).",
                                "Lógica: Verificação como predicado existencial ∃w V(x,w).",
                                "Análise de Algoritmos: Análise assintótica de loops duplos O(k^2).",
                                "Filosofia da Ciência: Conceitos de provabilidade e decidibilidade."
                              ],
                              "realWorldApplication": "Em redes sociais, detectar 'comunidades densas' (cliques) para análise de influência; verificadores NP usados em otimização de redes de telecomunicações para sub-redes totalmente conectadas, garantindo escalabilidade polinomial na verificação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Explicar NP-completude via redução",
                            "description": "Descrever a redução polinomial de 3-SAT para CLIQUE, transformando fórmulas booleanas em grafos onde cliques correspondem a atribuições satisfatórias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de 3-SAT e Problema do Clique",
                                  "subSteps": [
                                    "Defina 3-SAT: Uma fórmula booleana em forma normal conjuntiva com cláusulas de exatamente 3 literais.",
                                    "Explique satisfatibilidade: Atribuição de valores verdadeiros/falsos às variáveis que torna a fórmula verdadeira.",
                                    "Defina o Problema do Clique: Dado um grafo não-direcionado G e inteiro k, existe um clique (subgrafo completo) de tamanho pelo menos k?",
                                    "Liste propriedades NP de ambos: Verificação em tempo polinomial.",
                                    "Compare: 3-SAT é NP-completo conhecido; provar CLIQUE NP-completo via redução."
                                  ],
                                  "verification": "Escreva definições precisas e exemplos simples para 3-SAT e Clique sem erros conceituais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência: Livro 'Introduction to Algorithms' de Cormen et al., Capítulo 34"
                                  ],
                                  "tips": "Use diagramas para visualizar cláusulas de 3-SAT e cliques em grafos.",
                                  "learningObjective": "Compreender as entradas e saídas exatas dos problemas para preparar a redução.",
                                  "commonMistakes": "Confundir 3-SAT com SAT geral; ignorar que cliques são subgrafos completos (todas arestas presentes)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Conceito de Redução Polinomial",
                                  "subSteps": [
                                    "Defina redução polinomial: Função f que transforma instância de L1 em L2 em tempo polinomial, tal que x em L1 iff f(x) em L2.",
                                    "Explique por que polinomial: Preserva complexidade computacional.",
                                    "Discuta direção: Reduzir problema conhecido NP-completo (3-SAT) para o alvo (CLIQUE).",
                                    "Liste requisitos: Computável em tempo polinomial; preservação de 'sim/não'.",
                                    "Exemplo simples: Redução de problema trivial para ilustrar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição e por que ela prova NP-dureza.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou ferramenta de desenho online como Draw.io",
                                    "Vídeo tutorial sobre reduções NP (ex: YouTube canal 'Computer Science Lessons')"
                                  ],
                                  "tips": "Pense em 'tradução' entre problemas: entrada de um vira entrada do outro de forma eficiente.",
                                  "learningObjective": "Dominar o que constitui uma redução válida para argumentar completude.",
                                  "commonMistakes": "Confundir redução com aproximação; ignorar tempo polinomial na construção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Redução: Transformar Fórmula 3-SAT em Grafo Clique",
                                  "subSteps": [
                                    "Para fórmula φ com m cláusulas e n variáveis, crie vértices: Para cada literal em cada cláusula (3 por cláusula, total 3m vértices).",
                                    "Nomeie vértices: Para cláusula i com literais x_{i1}, x_{i2}, x_{i3}, vértices v_{i1}, v_{i2}, v_{i3}.",
                                    "Adicione arestas: Entre vértices da mesma cláusula (triângulo por cláusula); entre literais consistentes (não negação um do outro) de cláusulas diferentes.",
                                    "Defina k = m: Buscar clique de tamanho m (um vértice por cláusula).",
                                    "Verifique tempo: Construção O(1) por possível aresta, polinomial em m+n."
                                  ],
                                  "verification": "Desenhe o grafo para uma fórmula pequena e liste todas as arestas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de grafos como Graphviz ou Gephi",
                                    "Papel para esboços",
                                    "Exemplo de fórmula 3-SAT impressa"
                                  ],
                                  "tips": "Rotule vértices claramente como 'cláusula1_literal1' para evitar confusão.",
                                  "learningObjective": "Implementar a construção exata da redução passo a passo.",
                                  "commonMistakes": "Esquecer arestas dentro da cláusula; conectar literais inconsistentes (ex: x e ¬x)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Correção da Redução",
                                  "subSteps": [
                                    "Direção =>: Se φ satisfatível, construa clique: Escolha um literal verdadeiro por cláusula; são conectados (consistentes e intra-cláusula).",
                                    "Direção <=: Se existe clique de tamanho m, atribua valores: Para cada vértice no clique, valor que satisfaz seu literal; consistência garante sem contradição.",
                                    "Argumente polinomial: Construção e verificação em tempo polinomial.",
                                    "Conclua: CLIQUE é NP-duro pois 3-SAT reduz a ele; já em NP, logo NP-completo.",
                                    "Teste com exemplo: Verifique ambas direções."
                                  ],
                                  "verification": "Escreva prova formal bidirecional sem lacunas lógicas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor LaTeX ou Word para prova",
                                    "Referência: Artigo original de Karp 'Reducibility Among Combinatorial Problems'"
                                  ],
                                  "tips": "Use setas para mapear 'satisfação → clique' e vice-versa.",
                                  "learningObjective": "Validar que a redução preserva satisfatibilidade exatamente.",
                                  "commonMistakes": "Falhar em provar uma direção; assumir sem provar consistência de literais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Discutir Implicações e Generalizações",
                                  "subSteps": [
                                    "Explique NP-completude: Todo problema em NP reduz polinomialmente a CLIQUE.",
                                    "Compare com outras reduções (ex: VERTEX COVER).",
                                    "Discuta heurísticas práticas apesar de NP-completo.",
                                    "Relacione a outros problemas NP-completos.",
                                    "Resuma passos da redução em um fluxograma."
                                  ],
                                  "verification": "Crie um resumo de 1 página explicando toda a prova.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma como Lucidchart",
                                    "Lista de problemas NP-completos"
                                  ],
                                  "tips": "Conecte a aplicações para motivar: 'Isso explica por que scheduling é duro'.",
                                  "learningObjective": "Sintetizar o argumento para ensino ou exame.",
                                  "commonMistakes": "Ignorar que NP-completude é para decisão, não otimização."
                                }
                              ],
                              "practicalExample": "Considere φ = (x1 ∨ ¬x2 ∨ x3) ∧ (¬x1 ∨ x2 ∨ ¬x3). Crie 6 vértices: v11=x1, v12=¬x2, v13=x3; v21=¬x1, v22=x2, v23=¬x3. Arestas intra: todas em cláusula1 e 2. Inter: v11-¬v21 (x1 e ¬x1? Não!); v11-v22 (x1,x2 ok), etc. Clique exemplo: v12, v22, v23 → atribuição x1=qualquer, x2=false, x3=false satisfaz.",
                              "finalVerifications": [
                                "Pode construir grafo corretamente para fórmula 3-SAT com 3 cláusulas?",
                                "Explica bidirecionalmente por que satisfatibilidade ↔ clique de tamanho m?",
                                "Identifica tempo polinomial da redução?",
                                "Descreve por que isso prova NP-dureza de CLIQUE?",
                                "Aplica redução a uma instância não-trivial sem erros?",
                                "Discute limitações ou extensões?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do grafo (arestas corretas: 100%)",
                                "Prova bidirecional completa e lógica (sem falácias)",
                                "Compreensão de tempo polinomial (análise O(n^2) ou similar)",
                                "Uso de terminologia correta (redução, NP-completo, etc.)",
                                "Capacidade de generalizar a outros problemas",
                                "Clareza na explicação oral/escrita para leigos",
                                "Exemplo prático funcional"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Lógica Proposicional",
                                "Filosofia: Raciocínio deductivo e provas formais",
                                "Engenharia de Software: Análise de complexidade em algoritmos de otimização",
                                "Economia: Modelagem de problemas de alocação NP-completos",
                                "Inteligência Artificial: Impacto em busca e planejamento"
                              ],
                              "realWorldApplication": "Essa redução fundamenta a prova de NP-completude do Clique, usada em bioinformática (clusterização de proteínas), redes sociais (grupos densos), VLSI design (colocação de circuitos) e otimização de rotas, onde heurísticas aproximadas são empregadas pois soluções exatas são intratáveis para instâncias grandes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Aplicar Teorema de Cook-Levin",
                            "description": "Usar o teorema para justificar a completude inicial de SAT e a propagação via reduções para CLIQUE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de NP-Completude e SAT",
                                  "subSteps": [
                                    "Defina formalmente as classes P, NP e NP-completo.",
                                    "Explique o problema SAT (Satisfiability) e por que ele está em NP.",
                                    "Descreva o que significa um problema ser NP-duro e NP-completo.",
                                    "Identifique os requisitos para provar NP-completude via teorema de Cook-Levin.",
                                    "Estude exemplos simples de fórmulas SAT satisfatíveis e insatisfatíveis."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e resolva um SAT simples manualmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to Algorithms' (CLRS), Capítulo 34",
                                    "Wikipedia: NP-completeness",
                                    "Notas de aula sobre complexidade"
                                  ],
                                  "tips": "Use tabelas verdade para fórmulas pequenas para visualizar SAT.",
                                  "learningObjective": "Compreender os pré-requisitos para aplicar o Teorema de Cook-Levin.",
                                  "commonMistakes": [
                                    "Confundir NP com P",
                                    "Ignorar que SAT deve estar em NP primeiro",
                                    "Não diferenciar NP-duro de NP-completo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Prova do Teorema de Cook-Levin",
                                  "subSteps": [
                                    "Analise a redução polinomial de verificadores de máquina de Turing (TM) para SAT.",
                                    "Construa variáveis booleanas para cada configuração da fita da TM em passos discretos.",
                                    "Defina cláusulas para regras de transição da TM (movimento da cabeça, escrita, estados).",
                                    "Verifique que a fórmula SAT é satisfatível iff a TM aceita a entrada.",
                                    "Implemente um esboço da construção para uma TM simples."
                                  ],
                                  "verification": "Construa a fórmula SAT para uma TM que reconhece uma linguagem trivial, como {ε}.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Paper original de Cook (1971): 'The complexity of theorem-proving procedures'",
                                    "Sipser 'Introduction to the Theory of Computation', Capítulo 7",
                                    "Ferramentas online como SAT solvers para testar"
                                  ],
                                  "tips": "Comece com TM de 2 estados; foque em cláusulas para 'head position' e 'tape symbols'.",
                                  "learningObjective": "Dominar a construção da redução no Teorema de Cook-Levin.",
                                  "commonMistakes": [
                                    "Esquecer cláusulas para rejeição da TM",
                                    "Não garantir tempo polinomial na construção",
                                    "Variáveis insuficientes para todas as configurações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Teorema para Estabelecer Completude de SAT",
                                  "subSteps": [
                                    "Argumente que todo problema em NP pode ser reduzido a SAT via Cook-Levin.",
                                    "Prove que SAT está em NP (verificador não-determinístico).",
                                    "Conclua que SAT é NP-completo como o primeiro problema.",
                                    "Discuta implicações: todo problema em NP reduz polinomialmente a SAT.",
                                    "Resolva exercícios de aplicação em problemas genéricos em NP."
                                  ],
                                  "verification": "Escreva uma prova curta (200 palavras) da NP-completude de SAT.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Arora & Barak 'Computational Complexity', Capítulo 2",
                                    "Exercícios de Sipser",
                                    "Quadro branco para diagramas"
                                  ],
                                  "tips": "Use diagrama: Problema em NP → Verificador TM → SAT.",
                                  "learningObjective": "Justificar formalmente a completude inicial de SAT.",
                                  "commonMistakes": [
                                    "Pular prova de SAT em NP",
                                    "Confundir redução com simulação direta",
                                    "Ignorar universalidade da TM"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propagar Completude via Reduções para o Problema CLIQUE",
                                  "subSteps": [
                                    "Revise a redução padrão de 3-SAT para CLIQUE (construa grafo onde vértices são literais).",
                                    "Mostre que 3-SAT reduz de SAT via partição em cláusulas de 3 literais.",
                                    "Argumente transitividade: se A reduz a B e B é NP-completo, A é NP-duro.",
                                    "Aplique em exemplo: reduza SAT → 3-SAT → CLIQUE.",
                                    "Verifique que a redução preserva satisfatibilidade (k-clique size = #cláusulas)."
                                  ],
                                  "verification": "Construa redução completa para uma instância SAT pequena para CLIQUE e verifique.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "CLRS Capítulo 35.3",
                                    "Garey & Johnson 'Computers and Intractability'",
                                    "Software como GraphViz para visualizar grafos"
                                  ],
                                  "tips": "Para cada cláusula, crie 3 vértices (um por literal) e arestas para não-contradição.",
                                  "learningObjective": "Demonstrar propagação de NP-completude de SAT para CLIQUE.",
                                  "commonMistakes": [
                                    "Erro em arestas entre literais contraditórios",
                                    "Não ajustar tamanho do clique",
                                    "Esquecer polinomialidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere verificar se uma TM simples aceita '101'. Use Cook-Levin para criar fórmula SAT com variáveis para posições da fita em t=0..p(n). Cláusulas garantem transição válida. Se SAT satisfatível, TM aceita. Reduza essa SAT para CLIQUE: construa grafo com vértices por literais por cláusula, arestas se compatíveis, clique de tamanho #cláusulas iff satisfatível.",
                              "finalVerifications": [
                                "Explique o Teorema de Cook-Levin em suas próprias palavras.",
                                "Construa SAT para uma TM de 3 estados.",
                                "Prove NP-completude de SAT formalmente.",
                                "Descreva redução SAT → CLIQUE passo a passo.",
                                "Identifique erro em uma redução incompleta fornecida.",
                                "Resolva se CLIQUE é NP-completo via propagação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de cláusulas Cook-Levin (90% correto).",
                                "Correção da redução polinomial para CLIQUE.",
                                "Compreensão de transitividade de reduções.",
                                "Capacidade de debugar erros em provas de NP-completude.",
                                "Clareza em exemplos práticos e verificações.",
                                "Uso correto de terminologia (NP-duro vs completo)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (CLIQUE como subgrafo máximo).",
                                "Lógica: Lógica Proposicional e Resolução (SAT solvers).",
                                "Filosofia: Decidibilidade e Limites da Computação (Gödel/Turing).",
                                "Engenharia de Software: Verificação Automática e Model Checking.",
                                "Economia: Otimização Combinatória em Alocação de Recursos."
                              ],
                              "realWorldApplication": "Em verificação de hardware/software (model checking usa SAT para provar propriedades), otimização de redes (CLIQUE para alocação de canais), e criptografia (provar hardness de problemas NP-completos para segurança)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.3.4",
                            "name": "Discutir implicações da NP-completude",
                            "description": "Explicar que, se P=NP, CLIQUE seria solucionável em tempo polinomial; caso contrário, requer tempo superpolinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de NP-Completude e Problema Clique",
                                  "subSteps": [
                                    "Defina NP-completude: problemas em NP que são tão difíceis quanto os mais difíceis em NP.",
                                    "Recapitule o problema Clique: encontrar um subconjunto máximo de vértices totalmente conectados em um grafo.",
                                    "Explique por que Clique é NP-completo via redução de 3-SAT ou outro problema conhecido.",
                                    "Discuta as classes P e NP em termos de tempo polinomial vs. não-determinístico polinomial.",
                                    "Identifique que soluções exatas para Clique não são conhecidas em tempo polinomial."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando NP-completude do Clique e confirme com um colega ou autoavaliação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de teoria da computação (ex: Sipser), notas de aula, grafo de exemplo desenhado.",
                                  "tips": "Use diagramas de grafos para visualizar Cliques e reduções.",
                                  "learningObjective": "Compreender a base teórica da NP-completude aplicada ao Clique.",
                                  "commonMistakes": "Confundir NP-completo com indecidível; lembrar que são decidíveis mas potencialmente caros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Implicações se P=NP",
                                  "subSteps": [
                                    "Descreva que se P=NP, existe algoritmo polinomial para Clique.",
                                    "Discuta impactos: resolução eficiente de todos problemas NP-completos, incluindo Clique.",
                                    "Exemplifique aplicações: otimização em redes sociais (grupos densos), bioinformática (clusters genéticos).",
                                    "Analise consequências práticas: criptografia quebrada, planejamento otimizado em logística.",
                                    "Debata implicações filosóficas: colapso da hierarquia de complexidade."
                                  ],
                                  "verification": "Crie um fluxograma mostrando algoritmo hipotético polinomial para Clique e liste 3 aplicações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e caneta para fluxogramas, artigos sobre P vs NP (ex: Wikipedia, Scott Aaronson blog).",
                                  "tips": "Pense em heurísticas atuais como base para o 'milagre' P=NP.",
                                  "learningObjective": "Articular cenários otimistas onde Clique se torna tratável.",
                                  "commonMistakes": "Ignorar que P=NP implicaria eficiência para todos NP, não só Clique."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Implicações se P≠NP",
                                  "subSteps": [
                                    "Afirme que sem P=NP, Clique requer tempo superpolinomial (exponencial na pior caso).",
                                    "Explique heurísticas e aproximações: algoritmos como Bron-Kerbosch para enumeração.",
                                    "Discuta limites teóricos: ausência de algoritmos polinomiais sob conjectura P≠NP.",
                                    "Liste evidências empíricas: falhas em encontrar algoritmos rápidos apesar de décadas de pesquisa.",
                                    "Considere ramificações: necessidade de algoritmos aproximados ou paramétricos em prática."
                                  ],
                                  "verification": "Resolva um grafo pequeno de Clique manualmente e compare tempo com algoritmo polinomial hipotético.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software como NetworkX (Python) para grafos, exemplos de grafos NP-completos.",
                                  "tips": "Teste grafos reais para sentir a explosão exponencial.",
                                  "learningObjective": "Entender realismo prático e limitações computacionais.",
                                  "commonMistakes": "Subestimar heurísticas; elas não provam P≠NP mas suportam."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Discussão e Implicações Amplas",
                                  "subSteps": [
                                    "Compare os dois mundos: P=NP vs P≠NP em tabela de prós/contras para Clique.",
                                    "Discuta status atual: maioria acredita P≠NP, sem prova.",
                                    "Relacione com outros problemas: impacto em SAT, TSP, etc.",
                                    "Prepare argumentos para debate: defenda uma posição com evidências.",
                                    "Reflita sobre avanços futuros: computação quântica ou novas paradigmas."
                                  ],
                                  "verification": "Grave um vídeo de 3 minutos discutindo implicações e autoavalie clareza.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Gravador de vídeo ou app de notas, tabela comparativa em spreadsheet.",
                                  "tips": "Use analogias cotidianas, como 'busca exaustiva vs. atalho mágico'.",
                                  "learningObjective": "Integrar conhecimentos em discussão coerente e crítica.",
                                  "commonMistakes": "Ser dogmático; enfatize que é conjectura aberta."
                                }
                              ],
                              "practicalExample": "Em uma rede social como Facebook, identifique o maior 'clique' (grupo onde todos são amigos). Se P=NP, encontre em segundos para milhões de usuários; caso contrário, use aproximações para sugestões de amigos, evitando tempo exponencial.",
                              "finalVerifications": [
                                "Explica corretamente que P=NP implica solução polinomial para Clique.",
                                "Descreve tempo superpolinomial se P≠NP com exemplos de complexidade.",
                                "Lista pelo menos 2 aplicações reais afetadas pela NP-completude do Clique.",
                                "Discute evidências atuais favorecendo P≠NP.",
                                "Diferencia Clique de problemas em P ou NP-intermediários.",
                                "Apresenta argumentos sem erros conceituais em resumo escrito."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: uso correto de termos como polinomial, superpolinomial, NP-completo.",
                                "Clareza na explicação: estrutura lógica com exemplos concretos.",
                                "Profundidade: cobre ambos cenários P=NP e P≠NP equilibradamente.",
                                "Criatividade: inclui conexões reais ou analogias inovadoras.",
                                "Completude: aborda implicações práticas e teóricas.",
                                "Comunicação: linguagem acessível, sem jargões desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória (cliques máximos).",
                                "Filosofia: Epistemologia da prova e limites do conhecimento humano.",
                                "Economia: Otimização em mercados e alocação de recursos.",
                                "Engenharia de Software: Design de algoritmos eficientes e trade-offs."
                              ],
                              "realWorldApplication": "Na cibersegurança, detectar cliques densos em redes modeladas como grafos ajuda a identificar comunidades maliciosas; NP-completude explica por que usamos heurísticas em ferramentas como Neo4j ou GraphDB para análise em tempo real, impactando detecção de fraudes em bancos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Problema de Coloração de Grafos",
                    "description": "Análise do problema de colorir grafos com o mínimo de cores e sua relação com NP-completude.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Definição e Formulação do Problema de Coloração de Grafos",
                        "description": "Apresenta os conceitos fundamentais do problema de coloração de grafos, incluindo definições de coloração válida, número cromático e variantes do problema (como k-coloração).",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Definir uma coloração válida de um grafo",
                            "description": "Explicar o que constitui uma coloração própria de um grafo, identificando arestas adjacentes e garantindo que vértices conectados tenham cores diferentes, com exemplos em grafos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes básicos de um grafo",
                                  "subSteps": [
                                    "Defina vértice como um ponto ou nó no grafo.",
                                    "Defina aresta como uma conexão entre dois vértices.",
                                    "Identifique grafos simples: sem laços ou arestas múltiplas.",
                                    "Desenhe um grafo simples com 4 vértices e 3 arestas.",
                                    "Liste os vizinhos (vértices adjacentes) de cada vértice."
                                  ],
                                  "verification": "Desenhe um grafo simples e liste corretamente todos os pares de vértices adjacentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta online como draw.io ou Graphviz"
                                  ],
                                  "tips": "Sempre rotule vértices claramente para evitar confusão.",
                                  "learningObjective": "Identificar e representar corretamente vértices, arestas e adjacências em um grafo simples.",
                                  "commonMistakes": [
                                    "Confundir vértices adjacentes com não conectados",
                                    "Ignorar a direção em grafos não direcionados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de coloração de vértices",
                                  "subSteps": [
                                    "Atribua uma cor a cada vértice do grafo.",
                                    "Use um conjunto finito de cores (ex: vermelho, azul, verde).",
                                    "Desenhe um grafo e aplique cores arbitrariamente aos vértices.",
                                    "Registre o número de cores usadas na coloração.",
                                    "Explique que a coloração é uma função f: V → C, onde V é o conjunto de vértices e C o de cores."
                                  ],
                                  "verification": "Crie uma coloração arbitrária em um grafo com 5 vértices e descreva a função de coloração.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel colorido ou marcadores",
                                    "Software de grafos como yEd"
                                  ],
                                  "tips": "Comece com poucas cores para visualizar melhor as restrições futuras.",
                                  "learningObjective": "Entender a coloração como uma atribuição de cores aos vértices sem restrições iniciais.",
                                  "commonMistakes": [
                                    "Usar infinitas cores sem limitação",
                                    "Confundir coloração de vértices com coloração de arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir as regras de uma coloração própria",
                                  "subSteps": [
                                    "Estabeleça a regra: vértices adjacentes devem ter cores diferentes.",
                                    "Identifique arestas adjacentes como conexões diretas entre vértices.",
                                    "Verifique manualmente se toda aresta conecta vértices de cores iguais (inválido) ou diferentes (válido).",
                                    "Formalize: uma coloração é própria se para toda aresta (u,v), f(u) ≠ f(v).",
                                    "Ajuste uma coloração inválida até torná-la própria."
                                  ],
                                  "verification": "Pegue um grafo colorido arbitrariamente e identifique violações, corrigindo-as.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Marcadores de cores diferentes",
                                    "Lista de grafos de exemplo impressos"
                                  ],
                                  "tips": "Verifique cada aresta individualmente para garantir a regra.",
                                  "learningObjective": "Definir precisamente o que constitui uma coloração válida ou própria de um grafo.",
                                  "commonMistakes": [
                                    "Permitir cores iguais em vértices não adjacentes (isso é ok)",
                                    "Esquecer de verificar todas as arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar colorações em exemplos simples",
                                  "subSteps": [
                                    "Escolha um grafo ciclo C4 (quadrado) e tente colorir com 2 cores.",
                                    "Verifique se é própria: confirme que adjacentes diferem.",
                                    "Tente com grafo K3 (triângulo): prove necessidade de 3 cores.",
                                    "Compare colorações mínimas (cromático).",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Forneça uma coloração própria para C4 com 2 cores e para K3 com 3 cores, sem violações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de grafos pré-desenhados",
                                    "Calculadora para contar cores"
                                  ],
                                  "tips": "Use o menor número de cores possível para praticar otimização básica.",
                                  "learningObjective": "Aplicar a definição em grafos concretos e validar colorações.",
                                  "commonMistakes": [
                                    "Usar mais cores do que necessário em grafos bipartidos",
                                    "Confundir bipartido (2-colorível) com completo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo representando uma rede social com 4 usuários (A,B,C,D), onde A conecta a B e D, B conecta a C, C conecta a D: uma coloração válida é A=vermelho, B=azul, C=vermelho, D=verde. Verifique: A-B (vermelho-azul), A-D (vermelho-verde), B-C (azul-vermelho), C-D (vermelho-verde) — todas diferentes.",
                              "finalVerifications": [
                                "Defina corretamente coloração própria usando a regra de adjacentes.",
                                "Identifique violações em uma coloração dada.",
                                "Forneça exemplo de grafo 2-colorível e justifique.",
                                "Explique por que K3 requer 3 cores.",
                                "Desenhe e valide uma coloração para um grafo novo.",
                                "Diferencie coloração válida de mínima."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de adjacência e regra de cores diferentes.",
                                "Capacidade de verificar manualmente colorações em grafos pequenos.",
                                "Uso correto de terminologia (própria, vértice, aresta).",
                                "Identificação de erros comuns em exemplos práticos.",
                                "Criatividade em exemplos reais e conexões.",
                                "Completude dos passos com substeps executados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de Grafos e conjuntos.",
                                "Programação: Implementação em Python com NetworkX para coloração.",
                                "Física: Modelagem de redes cristalinas ou spins em magnetismo.",
                                "Geografia: Coloração de mapas (Quatro Corações de Guthrie).",
                                "Design: Alocação de recursos em layouts gráficos."
                              ],
                              "realWorldApplication": "No agendamento de salas de aula, vértices são salas, arestas são conflitos de horários; coloração válida atribui horários (cores) sem sobreposições, minimizando o número de períodos necessários."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Calcular o número cromático para grafos pequenos",
                            "description": "Determinar o número cromático χ(G) para grafos com até 10 vértices, testando colorações mínimas e identificando bipartidos ou grafos planares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o Grafo e Verificar Propriedades Básicas",
                                  "subSteps": [
                                    "Desenhe o grafo visualmente, marcando vértices e arestas claramente.",
                                    "Crie uma lista de adjacência para cada vértice.",
                                    "Conte o número de vértices (n ≤ 10) e arestas.",
                                    "Verifique se o grafo é simples (sem laços ou múltiplas arestas).",
                                    "Identifique graus máximos e possíveis cliques (subgrafos completos)."
                                  ],
                                  "verification": "Lista de adjacência completa e desenho sem erros; graus calculados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta gráfica como Draw.io ou Python com NetworkX"
                                  ],
                                  "tips": "Sempre rotule vértices de 1 a n para evitar confusão.",
                                  "learningObjective": "Dominar a representação precisa de grafos pequenos para análise cromática.",
                                  "commonMistakes": [
                                    "Esquecer arestas",
                                    "Confundir vértices não adjacentes",
                                    "Ignorar subgrafos densos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar Colorabilidade com 1 e 2 Cores",
                                  "subSteps": [
                                    "Verifique se há arestas: se não, χ(G)=1.",
                                    "Teste bipartição: atribua cores A e B alternadamente a partir de um vértice.",
                                    "Use BFS ou DFS para colorir com 2 cores e detecte conflitos.",
                                    "Se conflito, prove que não é bipartido mostrando ciclo ímpar.",
                                    "Registre se χ(G)=2 ou prossiga."
                                  ],
                                  "verification": "Coloração válida com 2 cores ou prova de ciclo ímpar documentada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para rascunho",
                                    "Algoritmo de coloração bipartida em pseudocódigo"
                                  ],
                                  "tips": "Comece por vértices de grau baixo para simplificar.",
                                  "learningObjective": "Identificar grafos 1- ou 2-coloríveis e reconhecer bipartidos.",
                                  "commonMistakes": [
                                    "Ignorar ciclos pares vs ímpares",
                                    "Parar em coloração parcial sem verificar todos vértices"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar Colorabilidade com 3 Cores e Identificar χ=3",
                                  "subSteps": [
                                    "Atribua 3 cores tentando minimizar conflitos, priorizando cliques K3.",
                                    "Use backtracking manual: teste combinações sistematicamente.",
                                    "Para cada tentativa falha, ajuste cores em vértices adjacentes.",
                                    "Verifique propriedades: se planar, espere χ≤4, mas foque em 3.",
                                    "Documente a coloração válida encontrada."
                                  ],
                                  "verification": "Coloração própria com 3 cores sem adjacentes iguais; todos vértices coloridos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de tentativas (cores por vértice)",
                                    "Software como Graph Coloring tool online"
                                  ],
                                  "tips": "Fixe cores em um clique máximo primeiro.",
                                  "learningObjective": "Aplicar busca exaustiva para colorações com poucas cores em grafos pequenos.",
                                  "commonMistakes": [
                                    "Reutilizar cores em adjacentes",
                                    "Não explorar backtracking completo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar χ(G) Mínimo e Propriedades Avançadas",
                                  "subSteps": [
                                    "Se 3 cores falharam, teste 4 cores (raro para n≤10, mas sistemático).",
                                    "Confirme minimalidade: prove que k-1 cores falham para k=χ(G).",
                                    "Identifique se bipartido (χ=2), planar (χ≤4) ou contém K5 (χ=5).",
                                    "Registre χ(G) e uma coloração ótima.",
                                    "Compare com teoremas conhecidos (Brooks, etc.)."
                                  ],
                                  "verification": "χ(G) declarado com coloração ótima e prova de não menor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo de algoritmo guloso para upper bound",
                                    "Tabela de teoremas de grafos"
                                  ],
                                  "tips": "Use algoritmo guloso para bound superior rápido.",
                                  "learningObjective": "Calcular precisamente χ(G) e conectar com propriedades teóricas.",
                                  "commonMistakes": [
                                    "Aceitar coloração não mínima sem prova",
                                    "Ignorar exceções como K_n"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo C5 (ciclo de 5 vértices: 1-2-3-4-5-1). Não é bipartido (ciclo ímpar). Teste 2 cores falha. Com 3 cores: cora 1=vermelho, 2=azul, 3=verde, 4=azul, 5=vermelho. χ(C5)=3, comprovado pois 2 falha.",
                              "finalVerifications": [
                                "χ(G) calculado corretamente com coloração válida.",
                                "Prova de minimalidade (falha com χ-1 cores).",
                                "Identificação correta de bipartido ou planar.",
                                "Lista de adjacência e desenho precisos.",
                                "Todos conflitos resolvidos na coloração final.",
                                "Tempo de cálculo razoável para n≤10."
                              ],
                              "assessmentCriteria": [
                                "Precisão na determinação de χ(G) (100% correto).",
                                "Eficiência na busca (mínimo de tentativas backtracking).",
                                "Documentação clara de provas e colorações.",
                                "Reconhecimento de propriedades (bipartido, cliques).",
                                "Ausência de erros em representação do grafo.",
                                "Aplicação de teoremas relevantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos Grafos e Combinatória.",
                                "Algoritmos e Programação: Implementação de backtracking em CS.",
                                "Otimização: Problemas NP-completos e heurísticas.",
                                "Física: Modelagem de redes cristalinas ou spins.",
                                "Design: Coloração em layouts gráficos."
                              ],
                              "realWorldApplication": "Usado em alocação de registradores em compiladores (evitar conflitos), coloração de mapas geográficos, escalonamento de tarefas em redes sem conflitos de frequência, e otimização de redes sociais para clustering."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Identificar variantes do problema de coloração",
                            "description": "Diferenciar o problema de coloração geral do k-coloração (decisão: colorível com no máximo k cores) e listar propriedades como o teorema de Brooks.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema de Coloração Geral de Grafos",
                                  "subSteps": [
                                    "Defina o problema de coloração de grafos: atribuir cores a vértices adjacentes não compartilham a mesma cor.",
                                    "Explique o objetivo: encontrar a menor quantidade de cores (número cromático χ(G)).",
                                    "Discuta a formulação como problema de otimização NP-difícil.",
                                    "Identifique exemplos simples como grafos bipartidos (2-coloráveis).",
                                    "Pratique com um grafo pequeno para visualizar."
                                  ],
                                  "verification": "Desenhe um grafo simples e colora-o corretamente, explicando o número cromático.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de grafos como Graphviz ou yEd"
                                  ],
                                  "tips": "Comece com grafos pequenos para construir intuição visual.",
                                  "learningObjective": "Compreender a definição fundamental do problema de coloração geral.",
                                  "commonMistakes": [
                                    "Confundir coloração com particionamento de arestas",
                                    "Ignorar adjacências em ciclos ímpares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Variante k-Coloração (Versão de Decisão)",
                                  "subSteps": [
                                    "Defina k-coloração: dado G e k, existe uma coloração própria com ≤ k cores?",
                                    "Compare com a coloração geral: decisão vs. otimização.",
                                    "Discuta complexidade: NP-completo para k ≥ 3.",
                                    "Exemplifique com k=2 (bipartido) e k=3 (testar grafos não-bipartidos).",
                                    "Pratique formulando instâncias de decisão para grafos dados."
                                  ],
                                  "verification": "Para um grafo dado e k=3, decida corretamente se é 3-colorível e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de grafos impressos",
                                    "Ferramenta online como Graph Coloring Simulator"
                                  ],
                                  "tips": "Use contrapositivos: se χ(G) > k, então não é k-colorível.",
                                  "learningObjective": "Diferenciar precisamente a k-coloração da coloração geral.",
                                  "commonMistakes": [
                                    "Confundir k-colorável com usar exatamente k cores",
                                    "Esquecer que k=1 é trivial (grafo sem arestas)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Propriedades e Diferenças Chave",
                                  "subSteps": [
                                    "Liste propriedades: χ(G) ≥ Δ(G)+1 em alguns casos, mas geralmente ≤ Δ(G)+1 por Brooks.",
                                    "Compare limites: coloração geral busca mínimo exato; k-coloração testa viabilidade.",
                                    "Discuta reduções: k-coloração reduz para coloração geral.",
                                    "Analise impactos na complexidade prática (heurísticas para k-coloração).",
                                    "Crie uma tabela comparativa entre as variantes."
                                  ],
                                  "verification": "Crie e preencha uma tabela comparando coloração geral e k-coloração em 5 critérios.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou documento para tabela",
                                    "Referências teóricas (livro de teoria dos grafos)"
                                  ],
                                  "tips": "Use bornas Δ(G) para estimar bounds iniciais.",
                                  "learningObjective": "Identificar e listar propriedades diferenciais das variantes.",
                                  "commonMistakes": [
                                    "Achar que k-coloração é polinomial para todo k",
                                    "Ignorar que para k fixo pequeno, algoritmos existem mas são exponenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar o Teorema de Brooks e Outras Propriedades Avançadas",
                                  "subSteps": [
                                    "Enuncie o Teorema de Brooks: χ(G) ≤ Δ(G) exceto para cliques completos e ciclos ímpares.",
                                    "Prove intuitivamente para grafos regulares.",
                                    "Aplique a variantes: implica bounds para k-coloração.",
                                    "Liste outras propriedades: Vizing para arestas, mas foque em vértices.",
                                    "Teste em exemplos: grafo ciclo C5 (χ=3=Δ+1, exceção Brooks)."
                                  ],
                                  "verification": "Aplique Brooks a 3 grafos diferentes, justificando exceções.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de grafos excepcionais",
                                    "Vídeo ou prova anotada de Brooks"
                                  ],
                                  "tips": "Memorize exceções: K_n e ciclos ímpares.",
                                  "learningObjective": "Listar e aplicar propriedades como Brooks às variantes.",
                                  "commonMistakes": [
                                    "Aplicar Brooks a grafos com Δ=0 incorretamente",
                                    "Confundir Brooks (vértices) com Vizing (arestas)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo representando regiões de um mapa (ex: mapa do Brasil simplificado), diferencie: coloração geral encontra o mínimo de cores para impressão; 3-coloração decide se é possível com 3 cores sem adjacentes iguais. Aplique Brooks: se grau máximo Δ=4, mas não clique/ciclo, então ≤4 cores.",
                              "finalVerifications": [
                                "Defina corretamente coloração geral vs. k-coloração.",
                                "Liste 3 diferenças chave entre as variantes.",
                                "Enuncie o Teorema de Brooks com exceções.",
                                "Aplique Brooks a um grafo exemplo.",
                                "Identifique quando k-coloração é trivial (k=1,2).",
                                "Explique por que k-coloração é NP-completa para k≥3."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% correto).",
                                "Capacidade de diferenciar variantes com exemplos.",
                                "Correta enunciação e aplicação de propriedades como Brooks.",
                                "Uso de terminologia técnica apropriada.",
                                "Profundidade na tabela comparativa ou lista de propriedades.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória.",
                                "Algoritmos: Reduções NP e Heurísticas de Coloração.",
                                "Física: Modelagem de spins em magnetismo (Ising model similar).",
                                "Geografia: Coloração de mapas (Quatro Teorema das Cores).",
                                "Engenharia: Alocação de frequências em redes."
                              ],
                              "realWorldApplication": "Em telecomunicações, k-coloração aloca canais de frequência a torres (vértices) sem interferência (arestas adjacentes); coloração geral otimiza o espectro mínimo. Brooks guia bounds rápidos para redes reais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Algoritmos para Coloração de Grafos",
                        "description": "Explora algoritmos exatos e aproximados para resolver o problema de coloração, incluindo heurísticas gulosas e backtracking, com análise de complexidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Implementar o algoritmo guloso de coloração",
                            "description": "Desenvolver e aplicar o algoritmo greedy coloring em ordem arbitrária ou por grau decrescente, calculando o número de cores usadas e bounds como Δ+1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o grafo e calcular graus dos vértices",
                                  "subSteps": [
                                    "Escolha uma linguagem de programação como Python para implementação.",
                                    "Defina o grafo usando dicionário de listas de adjacência (ex: graph = {0: [1,4], 1: [0,2], ...}).",
                                    "Implemente uma função para calcular o grau de cada vértice (len(graph[v]) para cada v).",
                                    "Crie uma lista de vértices com seus graus para uso posterior.",
                                    "Teste a representação com um grafo pequeno como ciclo C4."
                                  ],
                                  "verification": "Execute print do grafo e graus; confirme que adjacências e graus estão corretos sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3+",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Biblioteca padrão (collections para default_dict)"
                                  ],
                                  "tips": "Use collections.defaultdict(list) para facilitar adição de arestas; sempre valide entrada para evitar self-loops.",
                                  "learningObjective": "Dominar representação eficiente de grafos não direcionados via listas de adjacência e cálculo de graus.",
                                  "commonMistakes": [
                                    "Índices de vértices começando em 1 em vez de 0",
                                    "Não tratar grafos desconexos",
                                    "Confundir arestas direcionadas com não direcionadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar coloração gulosa em ordem arbitrária",
                                  "subSteps": [
                                    "Inicialize um array ou dicionário de cores com -1 para todos vértices (cores[v] = -1).",
                                    "Percorra vértices em ordem natural (0 a n-1).",
                                    "Para cada vértice v, crie um conjunto de cores usadas por vizinhos já coloridos.",
                                    "Atribua a menor cor não usada (iniciando de 0) ao vértice v.",
                                    "Registre o número máximo de cores usadas."
                                  ],
                                  "verification": "Teste em grafo bipartido (deve usar 2 cores) e confirme que vizinhos têm cores diferentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Função de teste para verificar conflitos de cor"
                                  ],
                                  "tips": "Use um set para cores de vizinhos para eficiência O(Δ); evite loops desnecessários.",
                                  "learningObjective": "Implementar corretamente o algoritmo greedy coloring básico e verificar sua corretude.",
                                  "commonMistakes": [
                                    "Atribuir cor usada por vizinho",
                                    "Não inicializar cores adequadamente",
                                    "Ignorar vértices isolados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar ordenação por grau decrescente",
                                  "subSteps": [
                                    "Crie uma lista de tuplas (grau, vértice) para todos vértices.",
                                    "Ordene essa lista em ordem decrescente de grau (sorted com key=lambda x: -x[0]).",
                                    "Se graus iguais, ordene por ID crescente para determinismo.",
                                    "Crie uma nova ordem de vértices baseada nessa lista.",
                                    "Integre com a função de coloração do Step 2, percorrendo nessa ordem."
                                  ],
                                  "verification": "Print da ordem gerada; confirme que vértices de maior grau vêm primeiro em um grafo de teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "sorted() built-in do Python"
                                  ],
                                  "tips": "Use stable sort com grau descendente e ID ascendente para reprodutibilidade.",
                                  "learningObjective": "Otimizar a heurística greedy via ordenação por grau para potencialmente reduzir cores.",
                                  "commonMistakes": [
                                    "Ordenação crescente em vez de decrescente",
                                    "Esquecer de quebrar empates por ID",
                                    "Não atualizar ordem dinamicamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados: calcular número de cores e bound Δ+1",
                                  "subSteps": [
                                    "Execute ambas as colorações (arbitrária e por grau) em um grafo de teste.",
                                    "Encontre Δ (grau máximo) e compute bound Δ+1.",
                                    "Compare número de cores usadas com o bound.",
                                    "Implemente verificação de corretude: nenhum vizinho com mesma cor.",
                                    "Gere relatório com métricas para múltiplos grafos."
                                  ],
                                  "verification": "Confirme que cores usadas ≤ Δ+1 e sem conflitos em pelo menos 3 grafos variados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Todos códigos anteriores",
                                    "Grafos de teste: ciclo C5, grafo completo K3, árvore"
                                  ],
                                  "tips": "Sempre teste com Δ conhecido; use max(cores.values()) +1 para num_cores.",
                                  "learningObjective": "Avaliar performance do algoritmo greedy e entender seu bound teórico.",
                                  "commonMistakes": [
                                    "Calcular Δ errado (máx grau)",
                                    "Comparar incorretamente com bound",
                                    "Ignorar que greedy pode exceder χ(G) mas ≤ Δ+1"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e refatorar o algoritmo completo",
                                  "subSteps": [
                                    "Crie uma função unificada greedy_coloring(graph, order=None) que aceita ordem opcional.",
                                    "Teste com ordem None (arbitrária) e ordem por grau.",
                                    "Valide em grafos aleatórios gerados via networkx (opcional).",
                                    "Meça tempo de execução para grafos grandes (n=100).",
                                    "Documente código com docstrings e comentários."
                                  ],
                                  "verification": "Código roda sem erros, passa testes unitários para corretude e bound.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca networkx (opcional para testes)",
                                    "timeit para performance"
                                  ],
                                  "tips": "Modularize em funções separadas para reutilização; adicione asserts para verificações.",
                                  "learningObjective": "Criar implementação robusta, testável e eficiente do algoritmo completo.",
                                  "commonMistakes": [
                                    "Falta de modularidade",
                                    "Não testar casos extremos (grafo vazio, vértice isolado)",
                                    "Sobrecarga temporal em O(V^2) sem otimização"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o grafo ciclo C5 (v0-v1-v2-v3-v4-v0, Δ=2): ordem arbitrária pode usar 3 cores (0:0,1:1,2:2,3:0,4:1); por grau decrescente usa 3 cores também, bound Δ+1=3. Verifique sem conflitos.",
                              "finalVerifications": [
                                "Implementação atribui cores ≤ Δ+1 em todos testes.",
                                "Nenhum par de vizinhos tem mesma cor.",
                                "Função funciona com ordem arbitrária e por grau decrescente.",
                                "Código é eficiente para n≤1000 (O(n^2) aceitável).",
                                "Relatório compara num_cores vs bound em ≥3 grafos.",
                                "Verificação automática de corretude implementada."
                              ],
                              "assessmentCriteria": [
                                "Corretude: 100% sem conflitos de cor.",
                                "Eficiência: tempo <1s para n=500, usa sets para vizinhos.",
                                "Robustez: lida com grafos desconexos/isolados.",
                                "Análise: corretamente identifica Δ e compara com bound.",
                                "Código limpo: modular, comentado, com testes.",
                                "Otimização: ordenação por grau reduz cores em ≥20% de casos testados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e números cromáticos.",
                                "Otimização: Heurísticas para problemas NP-difíceis.",
                                "Inteligência Artificial: Algoritmos de busca local e greedy.",
                                "Redes: Alocação de canais em redes sem fio.",
                                "Estatística: Análise de performance empírica em grafos aleatórios."
                              ],
                              "realWorldApplication": "Alocação de frequências em redes Wi-Fi para evitar interferências (vértices=canais, arestas=interferência); coloração de mapas para imprensa/cartografia; escalonamento de salas/exames em universidades para evitar conflitos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Analisar garantias de aproximação do algoritmo guloso",
                            "description": "Avaliar a razão de aproximação do greedy coloring (χ(G) ≤ Δ(G) + 1) e testar em exemplos onde usa mais cores que o ótimo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Coloração de Grafos",
                                  "subSteps": [
                                    "Defina o número cromático χ(G) como o menor número de cores necessário para colorir G sem cores adjacentes iguais.",
                                    "Defina o grau máximo Δ(G) como o maior grau de qualquer vértice em G.",
                                    "Descreva o algoritmo guloso de coloração: ordene vértices arbitrariamente e atribua a menor cor possível sem conflito.",
                                    "Explique por que o guloso é uma heurística para o problema NP-difícil de coloração.",
                                    "Implemente mentalmente o guloso em um grafo simples como K3 (triângulo)."
                                  ],
                                  "verification": "Liste definições corretas de χ(G) e Δ(G) e simule coloração gulosa em K3 usando exatamente 3 cores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Editor de grafos online (ex: draw.io)"
                                  ],
                                  "tips": [
                                    "Sempre comece com definições precisas para evitar confusões na prova posterior.",
                                    "Visualize grafos pequenos para intuitar."
                                  ],
                                  "learningObjective": "Compreender os termos χ(G), Δ(G) e funcionamento básico do algoritmo guloso.",
                                  "commonMistakes": [
                                    "Confundir χ(G) com o número de cores usado pelo guloso.",
                                    "Ignorar a ordem dos vértices na heurística gulosa."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Prova da Garantia de Aproximação χ(G) ≤ Δ(G) + 1",
                                  "subSteps": [
                                    "Prove por indução: para |V|=1, trivial (1 ≤ Δ+1).",
                                    "Assuma para G-v (v último vértice); v tem no máximo Δ vizinhos, logo ≤ Δ cores usadas, então v recebe cor ≤ Δ+1.",
                                    "Conclua que o número de cores do guloso ≤ Δ(G) + 1.",
                                    "Discuta independência da ordem: prova vale para qualquer ordem.",
                                    "Verifique a prova em um grafo com Δ=2 (ciclo par: usa 2 ≤ 3)."
                                  ],
                                  "verification": "Escreva a prova por indução completa e valide em um grafo com Δ conhecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel para anotações",
                                    "Livro ou PDF de Teoria dos Grafos (ex: Diestel)"
                                  ],
                                  "tips": [
                                    "Use indução forte sobre o número de vértices; foque no pior caso dos vizinhos de v.",
                                    "Desenhe o grafo indutivo para visualizar."
                                  ],
                                  "learningObjective": "Dominar a prova formal da upper bound do guloso.",
                                  "commonMistakes": [
                                    "Esquecer que vizinhos podem usar até Δ cores distintas.",
                                    "Confundir com lower bound χ(G) ≥ Δ+1 para alguns grafos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Onde o Guloso Usa Mais Cores que o Ótimo",
                                  "subSteps": [
                                    "Considere o grafo Mycielski para Δ=3 mas χ=4; simule guloso usando 4 cores.",
                                    "Teste ciclo ímpar C5: Δ=2, χ=3; guloso pode usar 3 cores dependendo da ordem.",
                                    "Compare com bipartido (χ=2=Δ); guloso usa ≤3 mas ótimo 2.",
                                    "Calcule razão: para C5, guloso/ótimo = 3/3=1; para Mycielski, 4/4=1 mas explore variações.",
                                    "Gere ordens diferentes e observe variação no número de cores."
                                  ],
                                  "verification": "Desenhe C5 e Mycielski, cole os resultados do guloso vs. ótimo para cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software Graphviz ou Python com NetworkX",
                                    "Papel para desenhos manuais"
                                  ],
                                  "tips": [
                                    "Teste múltiplas ordens para ver o pior caso (Δ+1).",
                                    "Use cores 1,2,3... para simular."
                                  ],
                                  "learningObjective": "Identificar casos onde a garantia é tight (guloso usa Δ+1 > χ).",
                                  "commonMistakes": [
                                    "Assumir guloso sempre ótimo; ignorar ordem afeta performance.",
                                    "Confundir Δ com χ em grafos completos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a Razão de Aproximação e Limitações",
                                  "subSteps": [
                                    "Defina razão de aproximação ρ = (cores guloso)/χ(G) ≤ (Δ+1)/χ(G) ≤ Δ+1 (pior caso).",
                                    "Discuta que não há α < 4/3 conhecido constante para coloração (problema aberto).",
                                    "Compare com algoritmos melhores (ex: Welsh-Powell ordena por grau).",
                                    "Conclua quando guloso é bom (grafos de baixa arboricidade).",
                                    "Resuma: garantia Δ+1 é simples mas não tight em geral."
                                  ],
                                  "verification": "Calcule ρ para 3 exemplos e explique por que Δ+1 é a melhor conhecida para guloso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para simulações",
                                    "Artigos sobre aproximação em grafos"
                                  ],
                                  "tips": [
                                    "Lembre: ρ é worst-case sobre instâncias; foque em upper bound teórico.",
                                    "Relacione com NP-hardness."
                                  ],
                                  "learningObjective": "Avaliar qualidade aproximada do guloso e suas limitações teóricas.",
                                  "commonMistakes": [
                                    "Pensar que guloso é (Δ/χ)-aproximado; é só upper bound Δ+1.",
                                    "Ignorar resultados mais avançados como Δ/lnΔ."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo de mapa (coloração de países), aplique guloso ordenando por população: para um mapa com Δ=5 (país fronteira com 5 vizinhos), guloso usa ≤6 cores, mas ótimo pode ser 4 (Quatro-Cores Teorema); teste em mapa da América do Sul simulando fronteiras.",
                              "finalVerifications": [
                                "Prova correta de χ(G) ≤ Δ(G) + 1 por indução.",
                                "Exemplo de grafo onde guloso usa Δ+1 > χ(G) (ex: C5).",
                                "Cálculo da razão ρ em pelo menos dois grafos.",
                                "Explicação de por que a garantia é tight.",
                                "Comparação com ordem por grau decrescente.",
                                "Identificação de limitações do guloso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na prova indutiva (sem lacunas).",
                                "Correção nos exemplos e cálculos de χ e Δ.",
                                "Análise qualitativa da razão de aproximação.",
                                "Uso de múltiplas ordens para demonstrar variabilidade.",
                                "Conexão com teoria de aproximação (worst-case).",
                                "Clareza em desenhos e simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Indução Matemática.",
                                "Otimização: Heurísticas vs. Exatas em Problemas NP-difíceis.",
                                "Probabilidade: Análise de performance média do guloso aleatório.",
                                "Ciência de Dados: Coloração em clustering de grafos sociais."
                              ],
                              "realWorldApplication": "Em agendamento de tarefas (alocação de 'cores' = salas/frequências), o guloso garante uso de no máximo Δ+1 recursos, útil em redes sem fio (alocação de canais) ou registro escolar (salas sem conflitos), evitando soluções exatas caras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Descrever backtracking para coloração exata",
                            "description": "Explicar o algoritmo de backtracking para encontrar colorações ótimas, analisando sua complexidade exponencial O(k^n) onde k é o número de cores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Problema de Coloração de Grafos",
                                  "subSteps": [
                                    "Defina um grafo G = (V, E) e explique o que é uma coloração válida: vértices adjacentes não compartilham a mesma cor.",
                                    "Discuta o número cromático χ(G), que é o menor número de cores necessário para uma coloração própria.",
                                    "Diferencie coloração ótima (χ(G) cores) de colorações aproximadas ou guloso.",
                                    "Identifique por que encontrar a coloração exata é NP-difícil.",
                                    "Desenhe um grafo simples (ex: triângulo) e tente colorir manualmente com 2 e 3 cores."
                                  ],
                                  "verification": "Desenhe um grafo K3 (clique completo) e prove que requer 3 cores, explicando por quê.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para desenhar grafos",
                                    "Ferramenta online como Graphviz ou draw.io"
                                  ],
                                  "tips": [
                                    "Comece com grafos pequenos para visualizar; foque em adjacências, não em vértices isolados."
                                  ],
                                  "learningObjective": "Compreender precisamente o problema de coloração exata e sua importância em otimização.",
                                  "commonMistakes": [
                                    "Confundir coloração válida com ótima",
                                    "Ignorar vértices isolados que podem reutilizar cores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Conceito de Backtracking",
                                  "subSteps": [
                                    "Explique backtracking como busca exaustiva recursiva com poda (pruning): tenta soluções parciais e retrocede se falhar.",
                                    "Descreva a estrutura geral: escolha uma variável, tente valores do domínio, recursão, backtrack se inconsistente.",
                                    "Compare com brute force: backtracking é mais eficiente por poda precoce.",
                                    "Ilustre com exemplo simples: resolver N-Queens, destacando tentativa de colocar rainha e retrocesso.",
                                    "Discuta árvore de decisão: cada nível é uma escolha de cor para um vértice."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito os 4 passos principais do backtracking em um problema genérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo curto sobre backtracking (ex: YouTube 'Backtracking Explained')",
                                    "Papel para esboçar árvore de recursão"
                                  ],
                                  "tips": [
                                    "Pense em backtracking como 'provar por exaustão inteligente'; visualize a pilha de recursão."
                                  ],
                                  "learningObjective": "Dominar os princípios fundamentais do backtracking aplicados a problemas combinatórios.",
                                  "commonMistakes": [
                                    "Não podar ramos inválidos cedo",
                                    "Confundir recursão com iteração simples"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Algoritmo de Backtracking para Coloração Exata",
                                  "subSteps": [
                                    "Ordene os vértices (ex: em ordem arbitrária ou heurística como maior grau primeiro).",
                                    "Para cada vértice i: tente cada cor k de 1 a χ; verifique se não conflita com vizinhos já coloridos.",
                                    "Se cor válida, atribua e recursa para próximo vértice; se sucesso, retorne solução.",
                                    "Se nenhuma cor funciona ou recursão falha, backtrack: remova cor e tente próxima.",
                                    "Pare ao encontrar coloração com χ cores ou esgotar possibilidades."
                                  ],
                                  "verification": "Escreva pseudocódigo básico da função recursiva colorir(vértice_atual, colorações_atuais).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Grafo exemplo impresso ou digital"
                                  ],
                                  "tips": [
                                    "Implemente uma função isSafe(v, cor) para checar conflitos rapidamente."
                                  ],
                                  "learningObjective": "Articular o fluxo exato do algoritmo de backtracking para coloração ótima.",
                                  "commonMistakes": [
                                    "Esquecer de checar todos vizinhos",
                                    "Não ordenar vértices para otimização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Testar o Algoritmo",
                                  "subSteps": [
                                    "Escreva pseudocódigo completo: função principal que chama recursão com k=χ(G) tentado.",
                                    "Teste em grafo pequeno: ciclo C4 (χ=2) e mostre árvore de busca com podas.",
                                    "Implemente em Python ou pseudocódigo representando grafo como lista de adjacências.",
                                    "Execute e observe chamadas recursivas para colorações falhas e sucesso.",
                                    "Registre o número de tentativas para medir eficiência."
                                  ],
                                  "verification": "Rode o algoritmo em um grafo bipartite (ex: árvore) e confirme coloração com 2 cores.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python ou Jupyter Notebook",
                                    "Biblioteca NetworkX para grafos (opcional)"
                                  ],
                                  "tips": [
                                    "Use print statements para rastrear recursão; limite k inicialmente para testes."
                                  ],
                                  "learningObjective": "Aplicar o algoritmo na prática e depurar implementações.",
                                  "commonMistakes": [
                                    "Índices off-by-one em listas de cores",
                                    "Representação errada de adjacências"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Complexidade e Limitações",
                                  "subSteps": [
                                    "Conte a árvore de recursão: para n vértices e k cores, até k^n folhas na pior caso.",
                                    "Explique por quê O(k^n): cada vértice tem até k escolhas, profundidade n.",
                                    "Discuta poda: reduz na prática, mas pior caso exponencial persiste (ex: grafos densos).",
                                    "Compare com heurísticas: backtracking garante ótimo, mas lento para n>20.",
                                    "Sugira melhorias: ordenação DSATUR, branching bounded."
                                  ],
                                  "verification": "Calcule complexidade para n=5, k=3: máximo 3^5 = 243 tentativas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou papel para contagem de nós na árvore"
                                  ],
                                  "tips": [
                                    "Desenhe árvore para n=3 para visualizar exponencialidade."
                                  ],
                                  "learningObjective": "Explicar rigorosamente a complexidade O(k^n) e implicações teóricas.",
                                  "commonMistakes": [
                                    "Subestimar pior caso",
                                    "Confundir tempo médio com pior caso"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo ciclo C5 (pentágono: v0-v1-v2-v3-v4-v0). Para k=2, backtracking tenta cor 1 em v0, cor 1 em v1 (conflito), backtrack; tenta cor 2 em v1, prossegue até v4 conflito, backtrack total. Para k=3, encontra solução: v0:1, v1:2, v2:3, v3:1, v4:2.",
                              "finalVerifications": [
                                "Explique o pseudocódigo completo verbalmente sem olhar notas.",
                                "Aplique backtracking manualmente em um grafo de 4 vértices e encontre coloração ótima.",
                                "Calcule e justifique O(k^n) com diagrama de árvore.",
                                "Identifique por que falha com k insuficiente em grafo específico.",
                                "Compare backtracking com algoritmo guloso em exemplo.",
                                "Discuta uma limitação prática para grafos grandes."
                              ],
                              "assessmentCriteria": [
                                "Pseudocódigo correto com verificação de conflitos e recursão.",
                                "Explicação clara de poda e backtrack com exemplo.",
                                "Análise precisa de complexidade exponencial.",
                                "Uso correto de termos: coloração válida, ótima, número cromático.",
                                "Demonstração prática em grafo pequeno sem erros.",
                                "Identificação de otimizações básicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria dos grafos (número cromático).",
                                "Inteligência Artificial: Algoritmos de busca exaustiva e heurísticas.",
                                "Otimização: Problemas NP-completos e aproximações.",
                                "Engenharia de Software: Alocação de registradores em compiladores.",
                                "Geografia: Coloração de mapas (problema dos quatro cores)."
                              ],
                              "realWorldApplication": "Aplicado em alocação de registradores em compiladores (grafos de interferência), escalonamento de espectro de rádio (evitar interferências), planejamento de horários escolares (salas como cores), e design de circuitos VLSI para minimizar pinos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "NP-Completude do Problema de Coloração",
                        "description": "Analisa a relação do problema de coloração com a classe NP, provando sua NP-completude via reduções polinomiais e teorema de Cook.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Verificar que o problema está na classe NP",
                            "description": "Construir um certificado polinomial para uma instância de 3-coloração (atribuição de 3 cores válida) e descrever a máquina de Turing verificadora em tempo polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Certificado Polinomial para 3-Coloring",
                                  "subSteps": [
                                    "Revise a definição formal do problema 3-COLORING: dado um grafo G=(V,E), decidir se existe uma função c: V → {1,2,3} tal que para toda aresta (u,v) ∈ E, c(u) ≠ c(v).",
                                    "Identifique o certificado como uma atribuição de cores: uma lista ou array C de tamanho |V|, onde C[i] ∈ {1,2,3} para o vértice i.",
                                    "Confirme que o tamanho do certificado é O(|V|), que é polinomial em n = |V|.",
                                    "Escreva um exemplo simbólico: para grafo G com vértices 1 a n, certificado σ = (σ_1, σ_2, ..., σ_n) com σ_i ∈ {1,2,3}.",
                                    "Discuta por que esse certificado é 'curto': bounded por 2 log n bits (já que 3 opções por vértice)."
                                  ],
                                  "verification": "Escreva a definição formal do certificado e calcule seu tamanho em bits para um grafo com n=100 vértices.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Definição de 3-COLORING",
                                    "Papel e caneta ou editor de texto",
                                    "Exemplo de grafo simples"
                                  ],
                                  "tips": "Sempre relacione o certificado à solução 'sim' do problema de decisão.",
                                  "learningObjective": "Compreender e formalizar o conceito de certificado polinomial para problemas em NP.",
                                  "commonMistakes": "Confundir certificado com solução do problema de otimização; esquecer que deve ser polinomial em tamanho."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver a Máquina de Turing Verificadora",
                                  "subSteps": [
                                    "Descreva a entrada da TM: <G, σ>, onde G é o grafo codificado (lista de adjacência ou matriz), σ é o certificado.",
                                    "Defina os passos da TM: (1) Verificar se σ tem tamanho |V| e valores em {1,2,3}; (2) Para cada aresta (u,v), checar se σ_u ≠ σ_v.",
                                    "Especifique o algoritmo: iterar sobre todas as arestas, acessar σ_u e σ_v, comparar.",
                                    "Implemente pseudocódigo: for each edge in E: if C[u] == C[v] reject; else accept.",
                                    "Considere codificação: TM lê fita com G e σ separados por símbolos especiais."
                                  ],
                                  "verification": "Escreva pseudocódigo completo da verificadora e teste manualmente em um grafo pequeno.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pseudocódigo template",
                                    "Ferramenta de desenho de grafos (ex: Graphviz online)",
                                    "Exemplos de grafos coloríveis"
                                  ],
                                  "tips": "Pense na TM como um algoritmo determinístico simples; foque em eficiência.",
                                  "learningObjective": "Construir uma descrição precisa de um verificador polinomial para o certificado.",
                                  "commonMistakes": "Esquecer verificação de formato do certificado; assumir conhecimento de índices sem definir."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que o Certificado Tem Tamanho Polinomial",
                                  "subSteps": [
                                    "Calcule o tamanho de G: O(|V| + |E|) bits, polinomial em n.",
                                    "Tamanho de σ: |V| * log(3) ≈ 2|V| bits, claramente O(n).",
                                    "Tamanho total da entrada para TM: O(n + m), onde m=|E| ≤ n²/2.",
                                    "Argumente: para qualquer 'sim' instance, existe certificado ≤ p(n) bits para polinômio p.",
                                    "Compare com problemas fora de NP: certificados exponenciais não qualificam."
                                  ],
                                  "verification": "Forneça prova formal: |σ| ≤ 2n bits, e cite teorema de NP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas sobre codificação de grafos",
                                    "Calculadora para log(3)"
                                  ],
                                  "tips": "Use notação big-O rigorosa; lembre que NP requer ∃ certificado curto.",
                                  "learningObjective": "Demonstrar matematicamente que o certificado é polinomial.",
                                  "commonMistakes": "Ignorar overhead de codificação binária; confundir com tempo de verificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar que a Verificação é em Tempo Polinomial",
                                  "subSteps": [
                                    "Analise complexidade: checar formato de σ: O(n) tempo.",
                                    "Iterar sobre |E| arestas: para cada, acessar σ_u e σ_v em O(1) se array, total O(m).",
                                    "TM overhead: em modelo multi-fita, ainda polinomial (O((n+m)^k) para k constante).",
                                    "Conclua: verificador roda em O(n + m) ≤ O(n²), polinomial.",
                                    "Discuta generalização: qualquer problema com verificador P está em NP."
                                  ],
                                  "verification": "Escreva análise de complexidade com justificativa para cada operação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de análise de TM",
                                    "Grafo com m≈n² para teste"
                                  ],
                                  "tips": "Conte operações na fita da TM; use fato que acesso a posições é polinomial.",
                                  "learningObjective": "Estabelecer que a TM verificadora é eficiente (P-time).",
                                  "commonMistakes": "Subestimar tempo de TM (esquecer movimentos de fita); confundir com solver do problema."
                                }
                              ],
                              "practicalExample": "Considere o grafo ciclo C_5 (vértices 1-5, arestas (1,2),(2,3),(3,4),(4,5),(5,1)). Certificado inválido: σ=(1,1,2,3,1) – rejeita em (1,2). Válido: σ=(1,2,3,1,2) – TM checa todas arestas, aceita em O(5) tempo.",
                              "finalVerifications": [
                                "O certificado σ tem tamanho O(n)? Justifique.",
                                "A TM rejeita certificados malformados (ex: σ_i=4)?",
                                "Para grafo completo K_4, existe σ válido? Descreva TM rejeitando inválido.",
                                "Tempo total da TM é O(n²)? Prove com m=n(n-1)/2.",
                                "Explique por que isso coloca 3-COLORING em NP, não em P.",
                                "Diferencie de 3-SAT: certificado similar (atribuição verdadeiros/falsos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição do certificado (tamanho e formato).",
                                "Correção e completude do pseudocódigo da TM verificadora.",
                                "Análise rigorosa de complexidade temporal e espacial.",
                                "Uso correto de terminologia NP (certificado, verificador polinomial).",
                                "Exemplos concretos testados e explicados.",
                                "Ausência de erros comuns como confusão com NP-hard."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (coloração, adjacência).",
                                "Lógica: Provas existenciais e máquinas formais (TM).",
                                "Física/Química: Modelagem de interações (ex: spins em Ising model).",
                                "Engenharia: Verificação de schedules (alocação de recursos com conflitos)."
                              ],
                              "realWorldApplication": "Em redes wireless, alocar 3 canais sem interferência (arestas=conflitos); verificadores rápidos confirmam soluções candidatas em otimização de telecomunicações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Explicar a redução de 3-SAT para 3-COLOR",
                            "description": "Descrever a redução polinomial de 3-SAT para 3-COLOR, construindo gadgets para variáveis, cláusulas e garantindo preservação de satisfatibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Problemas 3-SAT e 3-COLOR",
                                  "subSteps": [
                                    "Defina formalmente 3-SAT: uma fórmula booleana em Forma Normal Conjuntiva (CNF) onde cada cláusula tem exatamente 3 literais, e o problema é decidir se há uma atribuição de verdades que a satisfaz.",
                                    "Defina formalmente 3-COLOR: dado um grafo G=(V,E), decidir se existe uma coloração dos vértices com exatamente 3 cores tal que vértices adjacentes tenham cores diferentes.",
                                    "Explique o objetivo da redução: construir em tempo polinomial um grafo G a partir de uma fórmula φ de 3-SAT tal que φ é satisfatível se e só se G é 3-colorível.",
                                    "Revise conceitos chave: NP-completude de 3-SAT (conhecida) e como redução polinomial preserva NP-dureza.",
                                    "Desenhe diagramas simples de uma instância de 3-SAT e um grafo 3-colorível."
                                  ],
                                  "verification": "Escreva definições precisas em um papel e verifique se pode explicar a relação 'sim' para 'sim' e 'não' para 'não' em 2 minutos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Referência: Capítulo de Complexidade em Sipser ou Arora-Barak"
                                  ],
                                  "tips": "Use notação padrão: φ para fórmula, G para grafo; memorize 'iff' (if and only if) para preservação.",
                                  "learningObjective": "Dominar as entradas/saídas e motivação da redução polinomial.",
                                  "commonMistakes": [
                                    "Confundir 3-SAT com k-SAT geral (k>3 ainda NP-completo, mas redução específica para 3)",
                                    "Esquecer que 3-COLOR é problema de decisão, não otimização."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Gadget para Variáveis Booleanas",
                                  "subSteps": [
                                    "Para cada variável xi, crie 6 vértices: Ti (True i), Fi (False i), e quatro auxiliares A, B, C, D formando um ciclo ou triângulo para forçar escolhas mutuamente exclusivas.",
                                    "Conecte Ti e Fi a um triângulo base com cores 1,2,3; adicione arestas para que Ti e Fi não possam ter a mesma cor que seus 'opostos'.",
                                    "Garanta que exatamente uma de Ti ou Fi recebe cor 1 (representando True/False), e as outras cores são forçadas nas auxiliares.",
                                    "Desenhe o gadget: tipicamente, um triângulo T-F-X com X auxiliar, mais palmeiras para exclusividade.",
                                    "Teste: liste todas colorações possíveis e veja que correspondem a atribuições xi=True ou False."
                                  ],
                                  "verification": "Desenhe o gadget para x1 e liste as 2 colorações válidas correspondentes a True/False, sem colorações extras.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel quadriculado para grafos",
                                    "Software de desenho de grafos como Graphviz ou draw.io"
                                  ],
                                  "tips": "Pense em termos de 'forçar cor 1 em exatamente um de T ou F'; use triângulos para proibir cores iguais.",
                                  "learningObjective": "Construir e validar gadget que modela escolha booleana com 3 cores.",
                                  "commonMistakes": [
                                    "Permitir colorações onde ambos T e F têm cor 1",
                                    "Esquecer arestas que propagam forças de cor para cláusulas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Gadget para Cláusulas",
                                  "subSteps": [
                                    "Para cada cláusula C = (l1 ∨ l2 ∨ l3), onde lj é literal (xi ou ¬xi), crie um gadget com 7-10 vértices: um 'cláusula-nó' conectado aos nós lj dos gadgets de variáveis.",
                                    "Use estrutura em árvore ou palmeira: nó C conectado a três 'ramificações' para l1,l2,l3, com auxiliares que forçam pelo menos uma lj a ter cor específica (ex: cor 1 para True).",
                                    "Conecte: se lj=xi, conecte C a Ti; se ¬xi, a Fi; adicione triângulos para que se todas lj falsas (cores erradas), C não colorível.",
                                    "Desenhe para uma cláusula exemplo: mostre como uma cor válida 'escapa' se pelo menos um literal True.",
                                    "Valide: em colorações onde cláusula insatisfeita, gadget cria conflito de cor."
                                  ],
                                  "verification": "Para cláusula (x1 ∨ ¬x2 ∨ x3), desenhe conexões e simule coloração com todos falsos (conflito) vs. um True (colorível).",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": [
                                    "Papel e lápis coloridos para simular 3 cores",
                                    "Referência: prova padrão em Garey-Johnson ou online lecture notes"
                                  ],
                                  "tips": "O truque é assimetria: True literal permite cor 'livre', False força conflito propagado.",
                                  "learningObjective": "Modelar 'OR de 3 literais' via conflitos de coloração.",
                                  "commonMistakes": [
                                    "Conectar errado literal positivo/negativo",
                                    "Gadget permitir satisfação espúria sem literal True."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o Grafo Completo e Conectar Gadgets",
                                  "subSteps": [
                                    "Una todos gadgets de variáveis e cláusulas: adicione 'base' ou triângulo global com cores 1,2,3 fixas para ancorar.",
                                    "Para cada cláusula, conecte seu gadget aos literais apropriados dos gadgets variáveis sem introduzir novos conflitos.",
                                    "Garanta polinomial: número de vértices O(n + m), onde n=vars, m=cláusulas; arestas similares.",
                                    "Desenhe grafo inteiro para fórmula pequena.",
                                    "Implemente em código simples para gerar grafo (opcional, Python com NetworkX)."
                                  ],
                                  "verification": "Conte vértices/arestas e confirme O(poly) size; sem conexões cruzadas erradas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "draw.io ou TikZ para grafo completo",
                                    "Python + NetworkX para automação"
                                  ],
                                  "tips": "Mantenha gadgets modulares; rotule vértices claramente como T1, F1, C1 etc.",
                                  "learningObjective": "Construir instância reduzida completa em tempo polinomial.",
                                  "commonMistakes": [
                                    "Conexões que criam conflitos entre variáveis independentes",
                                    "Exceder tempo polinomial por gadgets exponenciais."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Provar a Corretude da Redução",
                                  "subSteps": [
                                    "Direção →: Se φ satisfatível, atribuição True/False → coloração: cor 1 para True-nós, propague para cláusulas (pelo menos um por cláusula).",
                                    "Direção ←: Se G 3-colorível, extraia atribuição: cor 1 em Ti significa xi=True, Fi=False; verifique cláusulas sem conflitos.",
                                    "Prove exaustividade: gadgets forçam interpretações únicas; sem colorações 'malucas'.",
                                    "Discuta Karp-redução: polinomial e preservadora.",
                                    "Teste com exemplo: satisfatível → colorível, insatisfatível → não."
                                  ],
                                  "verification": "Escreva prova bidirecional em parágrafos curtos; simule ambos sentidos no exemplo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel para prova formal",
                                    "Exemplo impresso do step anterior"
                                  ],
                                  "tips": "Use 'suponha coloração válida, então...' para extração; foque em 'pelo menos um' para OR.",
                                  "learningObjective": "Demonstrar equivalência via iff polinomial.",
                                  "commonMistakes": [
                                    "Falhar em provar direção ← (coloração implica satisfação)",
                                    "Ignorar colorações parciais nos gadgets."
                                  ]
                                }
                              ],
                              "practicalExample": "Para φ = (x1 ∨ ¬x2 ∨ x3) ∧ (¬x1 ∨ x2 ∨ ¬x3): Construa gadgets para x1,x2,x3 (18 vértices vars), dois gadgets cláusulas (16 vértices), triângulo base (3). Total ~37 vértices. Atribuição x1=F, x2=T, x3=F satisfaz ambas; colora T2 cor1, etc., sem conflitos. Inverter para insatisfatível gera conflito em cláusulas.",
                              "finalVerifications": [
                                "Desenhe gadget variável e explique suas 2 colorações válidas.",
                                "Construa gadget cláusula para (x∨y∨¬z) e mostre conflito se todos falsos.",
                                "Monte grafo para fórmula com 2 vars/2 cláusulas.",
                                "Prove → e ← para exemplo pequeno.",
                                "Explique por que redução é polinomial (O(n+m) vértices).",
                                "Identifique erro comum em prova de corretude."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de gadgets (sem conflitos espúrios).",
                                "Corretude da prova bidirecional (iff preservada).",
                                "Eficiência polinomial demonstrada (contagem de vértices/arestas).",
                                "Clareza em diagramas e explicações.",
                                "Capacidade de aplicar a exemplo concreto.",
                                "Identificação de erros comuns e tips."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Colorabilidade e cliques independentes.",
                                "Lógica Matemática: Satisfatibilidade booleana e tautologias.",
                                "Matemática Discreta: Reduções e funções polinomiais.",
                                "Filosofia da Computação: Limites da decidibilidade.",
                                "Algoritmos: Heurísticas para NP-difíceis como graph coloring."
                              ],
                              "realWorldApplication": "Essa redução prova NP-dureza de 3-COLOR, essencial para otimização em alocação de espectro rádio (cores=frequências), coloração de mapas geográficos, escalonamento de tarefas em logística e detecção de conflitos em redes sociais/IA, guiando uso de heurísticas aproximadas em software real como SAT-solvers e graph partitioners."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1",
                              "10.1.7.4.2"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Discutir implicações da NP-completude",
                            "description": "Analisar consequências práticas, como ausência de algoritmos polinomiais (assumindo P ≠ NP) e uso de heurísticas para instâncias grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de NP-Completude",
                                  "subSteps": [
                                    "Defina NP-completude usando a definição formal de Karp.",
                                    "Explique a relação entre problemas NP e NP-completos via reduções polinomiais.",
                                    "Liste exemplos clássicos, focando no Problema de Coloração de Grafos.",
                                    "Discuta por que a coloração de grafos é NP-completo.",
                                    "Resuma teoremas chave como Cook-Levin."
                                  ],
                                  "verification": "Crie um resumo de 1 página explicando NP-completude e verifique com uma fonte confiável como CLRS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to Algorithms' (CLRS), Wikipedia página NP-completo, video Khan Academy sobre complexidade.",
                                  "tips": "Use diagramas de Venn para visualizar classes P, NP e NPC.",
                                  "learningObjective": "Compreender os fundamentos teóricos da NP-completude para basear discussões implicações.",
                                  "commonMistakes": "Confundir NP-completo com intratável; lembre que são polinomiais em teoria, mas exponenciais na prática."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Hipótese P vs NP e Suas Implicações Teóricas",
                                  "subSteps": [
                                    "Explique a hipótese P ≠ NP e seu status como problema milênio.",
                                    "Discuta consequências se P = NP (criptografia quebrada, otimização fácil).",
                                    "Explore implicações se P ≠ NP (limites inerentes da computação).",
                                    "Relacione com coloração de grafos: por que não esperamos algoritmo polinomial.",
                                    "Debata argumentos heurísticos pela separação P ≠ NP."
                                  ],
                                  "verification": "Escreva um parágrafo argumentando por P ≠ NP e cite 2 referências acadêmicas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Clay Mathematics Institute página P vs NP, artigo de Scott Aaronson sobre complexidade.",
                                  "tips": "Pense em analogias cotidianas: resolver Sudoku grande é factível, mas generalizar não.",
                                  "learningObjective": "Dominar as implicações teóricas da NP-completude sob P ≠ NP.",
                                  "commonMistakes": "Ignorar que P = NP implicaria colapso de classes de complexidade; sempre mencione impactos amplos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Implicações Práticas e Abordagens Alternativas",
                                  "subSteps": [
                                    "Descreva desafios para instâncias grandes de problemas NP-completos.",
                                    "Explique uso de heurísticas e algoritmos de aproximação para coloração.",
                                    "Compare exatidão vs. eficiência em cenários reais.",
                                    "Discuta branch-and-bound e programação dinâmica para casos pequenos.",
                                    "Avalie trade-offs: tempo vs. qualidade da solução."
                                  ],
                                  "verification": "Implemente uma heurística simples de coloração em Python e teste em grafo de 50 vértices.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NetworkX, tutoriais GeeksforGeeks sobre heurísticas NP-completos.",
                                  "tips": "Sempre quantifique: 'heurística falha em <5% dos casos testados'.",
                                  "learningObjective": "Identificar e justificar soluções práticas para problemas NP-completos.",
                                  "commonMistakes": "Achar que heurísticas são 'soluções ruins'; enfatize seu valor em escala real."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Discussão Integrada das Implicações",
                                  "subSteps": [
                                    "Estruture um ensaio curto: intro, teoria, prática, conclusão.",
                                    "Use exemplo de coloração para ilustrar todas implicações.",
                                    "Prepare contra-argumentos para cenários P = NP.",
                                    "Grave uma apresentação de 5 minutos discutindo o tópico.",
                                    "Receba feedback de pares ou auto-avaliação."
                                  ],
                                  "verification": "Apresente discussão para um colega e refine baseado em feedback.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramenta de gravação (Zoom), modelo de ensaio sobre NP-completude.",
                                  "tips": "Comece com pergunta provocativa: 'E se P=NP?' para engajar.",
                                  "learningObjective": "Sintetizar e comunicar fluentemente as implicações da NP-completude.",
                                  "commonMistakes": "Focar só teoria; sempre ligue a aplicações concretas."
                                }
                              ],
                              "practicalExample": "Ao colorir um mapa de países (problema de coloração de grafos), para mapas pequenos use exato (3 cores?), mas para redes sociais grandes (milhões de nós), use heurística como DSATUR, aceitando 5-10% mais cores para solução em minutos vs. anos.",
                              "finalVerifications": [
                                "Explicar corretamente ausência de algoritmos polinomiais sob P ≠ NP.",
                                "Listar 3 heurísticas para coloração e seus trade-offs.",
                                "Discutir impacto em criptografia se P=NP.",
                                "Aplicar implicações a um problema real como scheduling de tarefas.",
                                "Defender uso de aproximações em escala industrial.",
                                "Identificar reduções que provam NP-completude da coloração."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas de NP-completo).",
                                "Profundidade de análise (implicações teóricas e práticas equilibradas).",
                                "Clareza na comunicação (linguagem acessível, exemplos concretos).",
                                "Uso de evidências (citações, experimentos simples).",
                                "Criatividade em conexões (aplicações interdisciplinares).",
                                "Estrutura lógica da discussão (intro-corpo-conclusão)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória.",
                                "Filosofia: Limites do Conhecimento e Indecidibilidade.",
                                "Economia: Otimização de Recursos e Modelagem de Problemas.",
                                "Engenharia: Design de Algoritmos em Software de Otimização."
                              ],
                              "realWorldApplication": "Em telecomunicações, coloração de grafos aloca frequências a torres sem interferência; NP-completude força heurísticas, permitindo redes nacionais viáveis em tempo real, equilibrando cobertura ótima com viabilidade computacional."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.2"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.4",
                            "name": "Relacionar coloração com outros problemas NP-completos",
                            "description": "Explicar reduções entre COLOR e problemas como CLIQUE ou INDEPENDENT SET, destacando sua centralidade em problemas clássicos de otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições formais dos problemas GRAPH COLORING, CLIQUE e INDEPENDENT SET",
                                  "subSteps": [
                                    "Ler e anotar a definição precisa do problema de k-GRAPH COLORING: dado G e k, existe coloração com k cores sem cores adjacentes iguais?",
                                    "Definir k-CLIQUE: dado G e k, existe subgrafo completo com k vértices?",
                                    "Definir k-INDEPENDENT SET: dado G e k, existe conjunto de k vértices sem arestas entre eles?",
                                    "Formalizar cada um como linguagem de decisão em {0,1}*",
                                    "Verificar que cada um está em NP (certificados polinomiais: coloração válida, lista de vértices clique, lista IS)"
                                  ],
                                  "verification": "Escrever definições formais em um documento e conferir com referência padrão como Garey & Johnson",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Computers and Intractability' de Garey & Johnson (cap. grafos)",
                                    "Notas de aula sobre complexidade",
                                    "Ferramenta de grafos online como Graphviz ou yEd"
                                  ],
                                  "tips": [
                                    "Use notação Σ* para instâncias; foque em versões de decisão, não otimização",
                                    "Desenhe exemplos pequenos para cada problema"
                                  ],
                                  "learningObjective": "Dominar as definições exatas e certificados NP para os três problemas",
                                  "commonMistakes": [
                                    "Confundir GRAPH COLORING com edge coloring",
                                    "Esquecer que k é parte da entrada em binário",
                                    "Ignorar que problemas são para grafos simples não-direcionados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de redução polinomial muitos-um (Karp reduction)",
                                  "subSteps": [
                                    "Estudar definição: f: Σ* -> Σ* computável em tempo polinomial tal que x ∈ A iff f(x) ∈ B",
                                    "Explicar implicações para NP-completude: se A NP-completo e A <=p B então B NP-duro",
                                    "Revisar exemplos básicos como CIRCUIT-SAT <=p 3-SAT",
                                    "Discutir por que reduções preservam 'dificuldade' e centralidade",
                                    "Praticar identificando reduções em problemas conhecidos"
                                  ],
                                  "verification": "Explicar em 3-5 frases próprias o que é uma Karp reduction e dar um exemplo simples",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Sipser 'Introduction to the Theory of Computation' (cap. NP)",
                                    "Vídeos Khan Academy ou YouTube sobre reduções NP",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Pense em 'tradução polinomial' de instância; sempre prove if e only if",
                                    "Use setas para visualizar A -> B"
                                  ],
                                  "learningObjective": "Aplicar corretamente o conceito de redução polinomial para relacionar problemas",
                                  "commonMistakes": [
                                    "Confundir com reduções Cook-Turing (máquinas)",
                                    "Esquecer a direção: reduz de conhecido duro para novo",
                                    "Não provar ambas direções (x em A => f(x) em B e converse)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar a redução direta entre k-CLIQUE e k-INDEPENDENT SET",
                                  "subSteps": [
                                    "Construir o grafo complemento \bar{G} de G em tempo O(n^2)",
                                    "Provar: G tem k-CLIQUE iff \bar{G} tem k-INDEPENDENT SET (vértices adjacentes em G são não-adjacentes em \bar{G})",
                                    "Implementar em pseudocódigo a função de redução f(G,k) = (\bar{G}, k)",
                                    "Verificar tempo polinomial e corretude com prova formal",
                                    "Testar com exemplo: grafo com triângulo (clique 3) -> complemento tem IS 3"
                                  ],
                                  "verification": "Construir e desenhar \bar{G} para um grafo de 5 vértices com clique conhecido e verificar IS",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software Python com NetworkX para grafos e complementos",
                                    "Papel para desenhar grafos",
                                    "Referência: Arora & Barak 'Computational Complexity'"
                                  ],
                                  "tips": [
                                    "Sempre desenhe pequenos grafos primeiro; lembre que complemento inverte arestas",
                                    "Pseudocódigo deve ser claro e O(n^2)"
                                  ],
                                  "learningObjective": "Executar e provar uma redução clássica entre dois problemas NP-completos",
                                  "commonMistakes": [
                                    "Erro no complemento: adicionar aresta onde não há em G",
                                    "Esquecer que k permanece o mesmo",
                                    "Não testar com grafo vazio ou completo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar GRAPH COLORING com CLIQUE e INDEPENDENT SET via propriedades e reduções compostas",
                                  "subSteps": [
                                    "Explicar relação algébrica: classes de cor são conjuntos independentes (cada cor é IS)",
                                    "Discutir bounds: χ(G) >= ω(G) (tamanho clique máx), χ(G) >= n / α(G) (α = max IS)",
                                    "Mostrar redução composta: como 3-SAT <=p CLIQUE e 3-SAT <=p 3-COLOR implica CLIQUE <=p 3-COLOR (compor funções)",
                                    "Destacar centralidade: todos capturam otimização combinatória clássica via reduções mútuas em NP-complete core",
                                    "Explorar implicações para aproximação (ex: coloring hard mesmo com bounds de clique/IS)",
                                    "Praticar: dado G, use bounds para estimar χ e relacionar com clique/IS"
                                  ],
                                  "verification": "Escrever prova curta da relação color classes = IS e explicar uma redução composta para um problema",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "NetworkX ou SageMath para computar ω, α, χ aproximado",
                                    "Papel para bounds",
                                    "Artigos ou wiki sobre NP-completude proofs"
                                  ],
                                  "tips": [
                                    "Lembre: partição em k IS <=> k-colorable",
                                    "Para composição, verifique tempo polinomial soma",
                                    "Use exemplos onde ω=2 mas χ=3 (C5)"
                                  ],
                                  "learningObjective": "Demonstrar como COLORING é central conectando via reduções e propriedades a CLIQUE/IS",
                                  "commonMistakes": [
                                    "Confundir χ(G) com χ(\bar{G}) (clique cover)",
                                    "Achar que bounds dão algoritmo exato (só lower bounds)",
                                    "Ignorar que reduções compostas ainda são polinomiais"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G = ciclo ímpar C5 (5 vértices, 5 arestas). ω(G)=2 (no triângulo), α(G)=2 (max IS=2 vértices não-adj.). χ(G)=3. Redução CLIQUE-IS: \bar{C5} é também C5, tem IS=2. Para relacionar COLOR: Como χ=3 > ω=2, mostra que clique não basta para coloring. Composição: Se soubéssemos colorir rápido, poderíamos aproximar cliques via bounds repetidos.",
                              "finalVerifications": [
                                "Define corretamente os três problemas e seus certificados NP",
                                "Prova a redução CLIQUE <=p INDEPENDENT SET via complemento",
                                "Explica como classes de cor são IS e bounds χ >= ω, χ >= n/α",
                                "Descreve redução composta mostrando COLOR conectada a CLIQUE",
                                "Identifica centralidade em otimização NP-completa",
                                "Aplica a um grafo exemplo com cálculos corretos"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e formalizações (20%)",
                                "Compreensão e prova correta de reduções (30%)",
                                "Explicação clara de relações algébricas e bounds (20%)",
                                "Uso de exemplos práticos e verificações (15%)",
                                "Insight sobre centralidade em problemas clássicos (10%)",
                                "Clareza e estrutura na exposição escrita (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos e Combinatória (Matemática Discreta)",
                                "Lógica e Teoria da Computação",
                                "Inteligência Artificial e Busca Heurística",
                                "Pesquisa Operacional e Otimização Combinatória",
                                "Ciência de Dados (análise de redes sociais)"
                              ],
                              "realWorldApplication": "Em telecomunicações, coloração de grafos aloca canais de frequência sem interferência (evita adjacentes); cliques modelam grupos de usuários com alta conectividade em redes sociais para detecção de comunidades; independent sets otimizam schedules de tarefas não-conflictantes em manufatura ou aviação, todos interconectados via reduções para provar dureza e guiar heurísticas aproximadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.8",
                "name": "Complexidade Computacional",
                "description": "Máquina de Turing, algoritmos não-determinísticos, classe NP, Teorema de Cook e reduções polinomiais.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.8.1",
                    "name": "Máquina de Turing",
                    "description": "Modelo formal de computação que define o que é computável e serve de base para análise de complexidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.1.1",
                        "name": "Componentes da Máquina de Turing",
                        "description": "Elementos fundamentais que compõem o modelo formal da Máquina de Turing, incluindo fita, estados, alfabeto e função de transição.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.1.1",
                            "name": "Descrever a estrutura da fita infinita",
                            "description": "Explicar a fita como uma sequência infinita de células em ambas as direções, capaz de armazenar símbolos de um alfabeto finito, com a cabeça de leitura/escrita posicionada em uma célula específica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de fita infinita como armazenamento",
                                  "subSteps": [
                                    "Defina a fita como uma estrutura linear de armazenamento em uma Máquina de Turing.",
                                    "Explique que ela é composta por uma sequência ilimitada de células.",
                                    "Discuta o propósito: armazenar símbolos durante o processamento computacional.",
                                    "Compare com fitas de fita cassete, mas infinita.",
                                    "Visualize mentalmente a fita se estendendo para sempre."
                                  ],
                                  "verification": "Escreva uma definição de 1 parágrafo descrevendo a fita como armazenamento infinito.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta para anotações; vídeo introdutório sobre Máquinas de Turing (ex: YouTube).",
                                  "tips": "Use analogias cotidianas como uma estrada infinita para fixar o conceito.",
                                  "learningObjective": "Entender a fita como mecanismo primitivo de memória ilimitada.",
                                  "commonMistakes": "Confundir com memória finita de computadores reais; lembrar que é teórica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever as células individuais e o alfabeto finito de símbolos",
                                  "subSteps": [
                                    "Identifique cada posição na fita como uma 'célula' discreta.",
                                    "Explique que cada célula armazena exatamente um símbolo de um alfabeto finito (ex: {0,1, branco}).",
                                    "Defina alfabeto: conjunto finito de símbolos permitidos, incluindo um 'branco' ou vazio.",
                                    "Esboce 5-10 células com símbolos exemplo.",
                                    "Note que símbolos são fixos e não podem ser alterados para fora do alfabeto."
                                  ],
                                  "verification": "Desenhe uma representação de 10 células com símbolos variados e rotule o alfabeto usado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis coloridos; simulador online de Máquina de Turing.",
                                  "tips": "Use símbolos simples como □ para branco e números para diferenciar.",
                                  "learningObjective": "Dominar a granularidade das células e restrições do alfabeto.",
                                  "commonMistakes": "Pensar que células podem armazenar strings inteiras; cada uma só um símbolo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a infinitude em ambas as direções",
                                  "subSteps": [
                                    "Descreva a fita como bi-infinita: estende-se infinitamente para esquerda (negativos) e direita (positivos).",
                                    "Use notação matemática: células indexadas por ℤ (inteiros).",
                                    "Discuta implicações: sem bordas, sempre possível mover e escrever.",
                                    "Compare com lista ligada infinita vs. array finito.",
                                    "Simule movimento: marque posição atual e imagine expansão."
                                  ],
                                  "verification": "Crie um diagrama mostrando fita com setas para ∞ esquerda e direita, indexando células de -5 a +5.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel longo ou software de desenho (ex: Draw.io); calculadora para índices.",
                                  "tips": "Represente finitamente no papel, mas anote 'continua infinitamente'.",
                                  "learningObjective": "Graspar a propriedade matemática de infinitude bidirecional.",
                                  "commonMistakes": "Assumir unidirecional como rolo de papel; enfatize ambas direções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar a posição e interação da cabeça de leitura/escrita",
                                  "subSteps": [
                                    "Defina a 'cabeça' como ponteiro posicionado em uma célula específica inicialmente.",
                                    "Explique funções: ler símbolo atual, escrever novo símbolo, mover L/R/PARAR.",
                                    "Descreva como a fita permanece estática; só cabeça se move.",
                                    "Simule uma transição: leia, escreva, mova.",
                                    "Note que fita infinita garante que cabeça nunca 'caia'."
                                  ],
                                  "verification": "Simule 3 transições em um diagrama: mostre cabeça movendo e alterando símbolos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Simulador de Turing Machine (ex: Turing Machine Simulator online).",
                                  "tips": "Pense na cabeça como cursor de texto editável.",
                                  "learningObjective": "Integrar fita com cabeça para compreensão dinâmica da estrutura.",
                                  "commonMistakes": "Confundir cabeça com fita móvel; cabeça move sobre fita fixa."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar a estrutura completa da fita infinita",
                                  "subSteps": [
                                    "Resuma todos elementos: células infinitas, símbolos finitos, cabeça posicionada.",
                                    "Escreva uma descrição formal: 'A fita é (ℤ, Γ), onde Γ é alfabeto finito'.",
                                    "Crie um glossário de termos chave.",
                                    "Compare com implementações reais (limitadas).",
                                    "Teste compreensão respondendo perguntas auto-impostas."
                                  ],
                                  "verification": "Redija uma explicação completa de 200 palavras e autoavalie contra definição padrão.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Documento de texto; referência: Sipser 'Introduction to Theory of Computation'.",
                                  "tips": "Use bullet points para síntese rápida.",
                                  "learningObjective": "Articular a estrutura integral de forma coesa.",
                                  "commonMistakes": "Omitir infinitude ou alfabeto; cheque completude."
                                }
                              ],
                              "practicalExample": "Desenhe uma fita representando cálculo de soma binária: células ... □ 1 0 1 □ ... com cabeça em '1' inicial, simulando adição movendo e escrevendo carry.",
                              "finalVerifications": [
                                "Desenhe e label fita bi-infinita com 10 células, símbolos e cabeça.",
                                "Explique verbalmente para um par ou grave áudio descrevendo estrutura.",
                                "Simule 5 passos de uma MT simples usando papel.",
                                "Responda quiz: 'O que acontece se cabeça vai para ∞ esquerda?'",
                                "Compare sua descrição com definição de Wikipedia/Turing original.",
                                "Implemente fita infinita básica em pseudocódigo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na infinitude bidirecional e alfabeto finito (sem erros conceituais).",
                                "Detalhe nas células, símbolos e interação com cabeça.",
                                "Uso correto de terminologia (ex: Γ para alfabeto, ℤ para índices).",
                                "Clareza em diagramas e explicações escritas.",
                                "Demonstração de compreensão via simulação prática.",
                                "Identificação de implicações computacionais (universalidade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conjuntos infinitos (ℤ) e funções sobre alfabeto finito.",
                                "Física: Analogia com linha do tempo infinita ou espaço-tempo.",
                                "Engenharia de Software: Modelos de memória em simuladores e VMs.",
                                "Lógica: Proposições sobre estados infinitos vs. finitos."
                              ],
                              "realWorldApplication": "Modela armazenamento ilimitado em computação teórica; inspira cloud storage escalável (ex: AWS S3 com 'infinitude' prática) e análise de algoritmos onde limites de memória são abstraídos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.1.2",
                            "name": "Identificar os conjuntos de estados e símbolos",
                            "description": "Definir o conjunto finito de estados Q, o alfabeto de entrada Σ, o alfabeto da fita Γ (com blank symbol ⊢), o estado inicial q0, os estados de aceitação F e rejeição (opcional).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições formais dos componentes da Máquina de Turing",
                                  "subSteps": [
                                    "Leia a definição formal de uma MT: M = (Q, Σ, Γ, δ, q0, qaccept, qreject).",
                                    "Estude cada componente: Q (conjunto finito de estados), Σ (alfabeto de entrada), Γ (alfabeto da fita, Γ ⊇ Σ ∪ {⊢}).",
                                    "Anote exemplos simples: Q = {q0, q1}, Σ = {0,1}, Γ = {0,1,⊢}.",
                                    "Identifique o blank symbol ⊢ como obrigatório em Γ.",
                                    "Diferencie estados de aceitação F (ou qaccept) e rejeição (opcional)."
                                  ],
                                  "verification": "Crie um glossário pessoal com definições e exemplos; confira com referência padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta",
                                    "Notas de aula sobre MT"
                                  ],
                                  "tips": "Use notação matemática precisa: |Q| finito, ⊢ ∈ Γ \\ Σ.",
                                  "learningObjective": "Compreender os papéis exatos de Q, Σ, Γ, q0 e F em uma MT.",
                                  "commonMistakes": [
                                    "Confundir Σ (entrada) com Γ (fita completa)",
                                    "Esquecer que ⊢ é obrigatório em Γ",
                                    "Achar que F inclui todos os estados de parada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar componentes em uma descrição ou diagrama de MT dada",
                                  "subSteps": [
                                    "Escolha uma MT exemplo simples (ex: reconhece strings vazias).",
                                    "Extraia Q dos estados listados ou diagramados.",
                                    "Liste Σ do alfabeto de entrada mencionado.",
                                    "Determine Γ incluindo Σ e ⊢, mais símbolos da fita se houver.",
                                    "Marque q0 (inicial, geralmente seta inicial), F (duplo círculo) e rejeição se presente."
                                  ],
                                  "verification": "Escreva os conjuntos extraídos e compare com a descrição original da MT.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de MT impresso ou digital",
                                    "Editor de texto para anotar conjuntos"
                                  ],
                                  "tips": "No diagrama, estados são círculos; transições mostram símbolos de Γ.",
                                  "learningObjective": "Extrair Q, Σ, Γ, q0 e F de representações visuais ou textuais.",
                                  "commonMistakes": [
                                    "Incluir símbolos de transição em Σ",
                                    "Omitir ⊢ de Γ",
                                    "Confundir qaccept com qreject"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir componentes para uma MT nova ou incompleta",
                                  "subSteps": [
                                    "Defina um problema simples (ex: contar a's pares).",
                                    "Especifique Q com estados necessários (q0, qeven, qodd, qaccept).",
                                    "Defina Σ = {a,b}, Γ = {a,b,⊢}.",
                                    "Escolha q0 e F ⊆ Q.",
                                    "Verifique se rejeição é necessária ou implícita."
                                  ],
                                  "verification": "Escreva a tupla formal M = (Q, Σ, Γ, ..., q0, F) e valide consistência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado para esboçar diagrama",
                                    "Simulador online de MT (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": "Mantenha |Q| pequeno inicialmente; garanta q0 ∈ Q e F ⊆ Q.",
                                  "learningObjective": "Construir definições precisas de componentes para uma MT funcional.",
                                  "commonMistakes": [
                                    "Definir Γ sem ⊢",
                                    "Q infinito ou não finito",
                                    "q0 não em Q"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e praticar identificação em múltiplos exemplos",
                                  "subSteps": [
                                    "Analise 3 MTs diferentes (paridade, palíndromos, soma).",
                                    "Liste todos componentes para cada uma.",
                                    "Simule uma transição para confirmar símbolos em Γ.",
                                    "Compare suas listas com soluções modelo.",
                                    "Ajuste erros e reescreva."
                                  ],
                                  "verification": "Resolva um quiz autoavaliativo com 5 MTs; acerte 90%.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios de MT online",
                                    "Folha de respostas modelo"
                                  ],
                                  "tips": "Sempre pergunte: 'Qual símbolo está na fita além de entrada?' para Γ.",
                                  "learningObjective": "Aplicar identificação de forma consistente e detectar inconsistências.",
                                  "commonMistakes": [
                                    "Ignorar rejeição opcional",
                                    "Misturar alfabeto de entrada com fita",
                                    "Estados duplicados em Q"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma MT que aceita strings com número par de 'a's sobre Σ={a,b}: Q={q0,q1,qaccept}, Σ={a,b}, Γ={a,b,⊢}, q0=q0, F={qaccept}. Inicie em q0 lendo 'a' (mover para q1), etc. Simule: entrada 'aa' → aceita.",
                              "finalVerifications": [
                                "Liste corretamente Q, Σ, Γ (com ⊢), q0 e F para uma MT dada.",
                                "Explique por que ⊢ ∈ Γ mas não em Σ.",
                                "Identifique inconsistências como q0 ∉ Q.",
                                "Construa componentes para um novo problema simples.",
                                "Diferencie aceitação F de rejeição.",
                                "Valide tupla formal M sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação de conjuntos (ex: Q={q0,q1}).",
                                "Inclusão obrigatória de ⊢ em Γ.",
                                "Correta distinção entre Σ e Γ.",
                                "Identificação exata de q0 e F.",
                                "Consistência lógica (q0 ∈ Q, F ⊆ Q).",
                                "Completude: todos componentes definidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (finito, subconjuntos).",
                                "Lógica: Estados como proposições booleanas.",
                                "Análise de Algoritmos: Estados representam configurações.",
                                "Física: Autômatos como modelos de sistemas discretos."
                              ],
                              "realWorldApplication": "Em compiladores, parsers usam MT-like para análise léxica (estados para tokens); em protocolos de rede, estados finitos modelam handshakes (TCP)."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.1.3",
                            "name": "Explicar a função de transição δ",
                            "description": "Descrever δ: Q × Γ → Q × Γ × {L, R} como a regra que, dado estado atual e símbolo lido, define novo estado, símbolo a escrever e direção de movimento da cabeça (esquerda L ou direita R).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conjuntos de Entrada da Função δ (Q e Γ)",
                                  "subSteps": [
                                    "Defina Q como o conjunto finito de estados da máquina de Turing, incluindo o estado inicial q0 e estados de aceitação/rejeição.",
                                    "Defina Γ como o conjunto finito de símbolos da fita, incluindo o símbolo em branco ⊢.",
                                    "Explique que a entrada de δ é um par ordenado (q, γ), onde q pertence a Q e γ pertence a Γ.",
                                    "Liste exemplos: Q = {q0, q1, q_accept, q_reject}, Γ = {0, 1, ⊢}.",
                                    "Desenhe um diagrama simples mostrando a cabeça de leitura lendo γ no estado q."
                                  ],
                                  "verification": "Escreva definições precisas de Q e Γ e forneça um exemplo de par de entrada (q, γ).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas sobre componentes de Máquina de Turing"
                                  ],
                                  "tips": "Sempre inclua o símbolo em branco ⊢ em Γ, pois é essencial para o funcionamento.",
                                  "learningObjective": "Identificar e descrever corretamente os conjuntos de entrada da função δ.",
                                  "commonMistakes": [
                                    "Confundir Q (estados) com Γ (símbolos)",
                                    "Omitir o símbolo em branco de Γ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Assinatura e Propósito da Função δ",
                                  "subSteps": [
                                    "Escreva a assinatura formal: δ: Q × Γ → Q × Γ × {L, R}.",
                                    "Explique que δ define o comportamento determinístico da MT para cada combinação possível de estado e símbolo lido.",
                                    "Descreva o mapeamento: de (estado atual, símbolo lido) para (novo estado, símbolo a escrever, direção de movimento).",
                                    "Compare com funções parciais: δ pode ser parcial se não definida para todos os pares.",
                                    "Crie uma tabela vazia com colunas: Estado Atual, Símbolo Lido, Novo Estado, Símbolo Escrito, Direção."
                                  ],
                                  "verification": "Escreva a assinatura de δ e preencha a tabela com pelo menos duas entradas fictícias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou papel quadriculado",
                                    "Exemplos de tabelas de transição"
                                  ],
                                  "tips": "Pense em δ como uma 'regra de decisão' que dita o próximo passo exato da MT.",
                                  "learningObjective": "Explicar a notação formal e o papel determinístico de δ.",
                                  "commonMistakes": [
                                    "Escrever {L,R} como saída sem associar a novo estado e símbolo",
                                    "Confundir δ com função total (sempre definida)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os Componentes de Saída de δ",
                                  "subSteps": [
                                    "Descreva o primeiro componente de saída: novo estado q' ∈ Q.",
                                    "Descreva o segundo: símbolo a escrever γ' ∈ Γ na posição atual da cabeça.",
                                    "Descreva o terceiro: direção {L para mover cabeça à esquerda, R para direita}.",
                                    "Explique o processo sequencial: ler → aplicar δ → escrever → mover → repetir.",
                                    "Simule uma transição: dado (q0, 1), δ(q0,1) = (q1, 0, R) → estado q1, escreve 0, move direita.",
                                    "Diferencie de autômatos finitos: MT tem escrita e movimento na fita."
                                  ],
                                  "verification": "Para um par de entrada dado, liste os três componentes de saída e descreva o que acontece.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de fita de MT",
                                    "Simulador online de MT opcional"
                                  ],
                                  "tips": "Visualize a cabeça como um ponteiro: L move para trás, R para frente na fita infinita.",
                                  "learningObjective": "Detalhar o significado prático de cada saída de δ.",
                                  "commonMistakes": [
                                    "Ignorar que o símbolo escrito substitui o lido",
                                    "Confundir L/R com estados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar δ em uma Transição Completa",
                                  "subSteps": [
                                    "Escolha uma MT simples, como reconhecimento de strings pares de 1's.",
                                    "Defina δ para casos base: δ(q0,1)=(q1,1,R), δ(q0,⊢)=(q_accept,⊢,N) – note que N não é padrão, use R ou L.",
                                    "Simule duas transições passo a passo na fita: ...⊢ 1 1 ⊢... em q0.",
                                    "Construa tabela de δ completa para 3 estados e 2 símbolos.",
                                    "Teste se δ leva a aceitação ou rejeição corretamente.",
                                    "Explique como δ garante computabilidade universal."
                                  ],
                                  "verification": "Simule uma computação com 3 transições usando δ e verifique o resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fita simulada em papel",
                                    "Tabela de transição exemplo"
                                  ],
                                  "tips": "Comece com MTs mínimas para evitar confusão; expanda depois.",
                                  "learningObjective": "Demonstrar o uso de δ em uma simulação real de MT.",
                                  "commonMistakes": [
                                    "Não atualizar a fita corretamente após escrita",
                                    "Esquecer de mover a cabeça"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma MT que reconhece se o número de 1's é par: δ(q0, 1) = (q1, 1, R) [troca paridade], δ(q0, ⊢) = (q_accept, ⊢, R), δ(q1, 1) = (q0, 1, R), δ(q1, ⊢) = (q_reject, ⊢, R). Simulação: fita '11⊢', q0 lê 1 → escreve 1, R para q1; q1 lê 1 → escreve 1, R para q0; q0 lê ⊢ → aceita.",
                              "finalVerifications": [
                                "Explicar verbalmente a assinatura δ: Q × Γ → Q × Γ × {L, R}.",
                                "Definir corretamente entradas e saídas com exemplos.",
                                "Simular uma transição completa em uma fita de exemplo.",
                                "Construir tabela de δ para uma MT simples com 3 estados.",
                                "Diferenciar δ de transições em autômatos finitos.",
                                "Identificar erros comuns em definições de δ."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal de δ (100% correto).",
                                "Clareza na distinção entre entradas (Q, Γ) e saídas (Q, Γ, {L,R}).",
                                "Capacidade de simular transições passo a passo sem erros.",
                                "Uso de exemplos concretos e tabelas para ilustrar δ.",
                                "Compreensão do papel determinístico de δ na computação.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções de múltiplos valores e relações cartesianas (Q × Γ).",
                                "Lógica: Tabelas de verdade semelhantes a tabelas de transição.",
                                "Física: Modelos de partículas com estados discretos e transições.",
                                "Engenharia de Software: Máquinas de estados finitos em controladores.",
                                "Filosofia: Decidibilidade e limites da computação (Teorema de Rice)."
                              ],
                              "realWorldApplication": "A função δ modela o controle de fluxo em compiladores (parsers LL/LR), robótica (autômatos reativos com sensores e ações), e protocolos de rede (máquinas de estados para FSM em TCP/IP), permitindo simulações de qualquer algoritmo em hardware simples."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.2",
                        "name": "Funcionamento e Configurações",
                        "description": "Processo de execução passo a passo da Máquina de Turing, incluindo configurações iniciais, transições e condições de parada.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.2.1",
                            "name": "Representar uma configuração da MT",
                            "description": "Escrever uma configuração como u q v, onde u é o conteúdo à esquerda da cabeça (invertido), q o estado atual e v o conteúdo à direita incluindo o símbolo sob a cabeça.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes da configuração da Máquina de Turing",
                                  "subSteps": [
                                    "Leia a definição: configuração é u q v, onde u é o conteúdo à esquerda da cabeça invertido (reverso), q é o estado atual e v é o conteúdo à direita incluindo o símbolo sob a cabeça.",
                                    "Desenhe uma fita de MT com símbolos, marque a posição da cabeça e identifique visualmente esquerda, cabeça e direita.",
                                    "Explique em voz alta o que cada parte representa, usando um exemplo simples como fita vazia.",
                                    "Compare com notação alternativa (sem inversão) para destacar a importância da inversão em u.",
                                    "Anote as regras em um quadro de referência pessoal."
                                  ],
                                  "verification": "Pode descrever corretamente u, q e v para uma fita ilustrada sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta, diagrama de fita de MT impresso ou digital.",
                                  "tips": "Sempre visualize a fita como infinita para ambos os lados, com blanks (_) como padrão.",
                                  "learningObjective": "Identificar e definir precisamente os três componentes de uma configuração de MT.",
                                  "commonMistakes": "Esquecer que u é invertido; confundir v como excluindo o símbolo sob a cabeça."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar a configuração inicial de uma MT",
                                  "subSteps": [
                                    "Dado o input na fita (ex: 1101) e posição inicial da cabeça no primeiro símbolo, escreva a fita completa com blanks.",
                                    "Identifique u (esquerda vazia: ε), q (estado inicial q0) e v (todo o input + blanks necessários).",
                                    "Inverta u (se vazio, permanece ε) e concatene: ε q0 1101.",
                                    "Verifique escrevendo duas vezes e comparando com um exemplo resolvido.",
                                    "Repita com input diferente, como _011_, cabeça no primeiro _."
                                  ],
                                  "verification": "Configuração escrita bate com a visualização da fita inicial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado para simular fita, exemplos de inputs.",
                                  "tips": "Comece sempre com u=ε para configs iniciais, a menos que especificado.",
                                  "learningObjective": "Construir corretamente a configuração inicial a partir de input e posição da cabeça.",
                                  "commonMistakes": "Incluir blanks desnecessários em v; não inverter u quando há símbolos à esquerda."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar configurações intermediárias após transições",
                                  "subSteps": [
                                    "Dado uma configuração atual (ex: 1 q1 101) e regra δ(q1,1)=(q2,0,R), aplique a transição.",
                                    "Escreva novo símbolo (0 no lugar de 1 sob cabeça), mova cabeça direita, mude estado para q2.",
                                    "Atualize u: adicione o antigo símbolo sob cabeça à esquerda e inverta (agora u=1 invertido=1).",
                                    "Atualize v: resto à direita (01). Resultado: 1 q2 01.",
                                    "Simule passo a passo verbalmente antes de escrever."
                                  ],
                                  "verification": "Nova configuração reflete exatamente a transição aplicada na fita visual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama de transição de MT simples, simulador online opcional.",
                                  "tips": "Desenhe setas na fita para rastrear movimentos da cabeça.",
                                  "learningObjective": "Transformar uma configuração em outra via regra de transição, mantendo notação correta.",
                                  "commonMistakes": "Errar a inversão ao adicionar a esquerda; mover cabeça errado em v."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar sequências completas de configurações",
                                  "subSteps": [
                                    "Escolha uma MT simples (ex: reconhece '11'), liste 3-5 configurações sequenciais.",
                                    "Simule toda a computação, escrevendo cada config após cada passo.",
                                    "Compare sua sequência com uma solução modelo.",
                                    "Identifique e corrija erros em configs anteriores.",
                                    "Crie sua própria fita curta e simule manualmente."
                                  ],
                                  "verification": "Sequência de 5 configs é consistente e leva a aceitação/rejeição correta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Folha de exercícios com MTs, solução modelo.",
                                  "tips": "Use cores diferentes para u, q e v ao escrever.",
                                  "learningObjective": "Gerar e validar sequências de configurações em uma simulação completa.",
                                  "commonMistakes": "Inconsistência cumulativa de inversões; pular blanks na extremidade."
                                }
                              ],
                              "practicalExample": "Para MT com fita inicial _110_, cabeça em primeiro 1, q0. Config inicial: ε q0 110. Regra δ(q0,1)=(q1,1,R). Nova config: 1 q1 10 (u=1 invertido=1, v=10). Próxima δ(q1,1)=(q2,0,R): 1 1 q2 0 (u=11 invertido=11, v=0).",
                              "finalVerifications": [
                                "Escreve config inicial corretamente para qualquer input curto.",
                                "Aplica transição única sem erros em u, q, v.",
                                "Gera sequência de 4 configs consistentes.",
                                "Identifica erros comuns como inversão faltante.",
                                "Explica verbalmente uma config para um par.",
                                "Simula config final de halting state."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inversão de u (100% correto).",
                                "Inclusão correta do símbolo sob cabeça em v.",
                                "Consistência de q com transições.",
                                "Tratamento adequado de blanks infinitos.",
                                "Clareza e legibilidade da notação escrita.",
                                "Capacidade de validar configs via simulação visual."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Notação formal e funções de transição como relações.",
                                "Lógica: Estados e transições semelhantes a autômatos finitos.",
                                "Programação: Modelagem de estados em simuladores ou código FSM.",
                                "Física: Analogia com partículas em trilhos (cabeça movendo)."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, representa estados internos de execução; modela fluxos em algoritmos de parsing e análise de complexidade; base para simuladores de computação em ferramentas como JFLAP ou design de hardware FSM."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.2.2",
                            "name": "Simular uma execução passo a passo",
                            "description": "Dado uma MT e entrada, aplicar sequencialmente a função δ para gerar a sequência de configurações até aceitação, rejeição ou loop infinito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Máquina de Turing e preparar a entrada inicial",
                                  "subSteps": [
                                    "Especificar os componentes da MT: conjunto de estados Q, alfabeto de entrada Σ, alfabeto da fita Γ (incluindo blank B), função de transição δ: Q × Γ → Q × Γ × {L, R}, estado inicial q0 e estados finais F.",
                                    "Escrever a string de entrada w ∈ Σ* na fita, preenchendo o resto com blanks B.",
                                    "Posicionar a cabeça de leitura/escrita na primeira célula da esquerda de w.",
                                    "Representar graficamente ou tabularmente a fita inicial e os estados."
                                  ],
                                  "verification": "Conferir se todos os 7 componentes da MT estão listados corretamente e a fita inicial reflete w com cabeça em posição inicial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Definição formal da MT",
                                    "Papel quadriculado ou simulador de MT online (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": "Use notação δ(q, σ) = (p, τ, D) onde D é L (esquerda) ou R (direita). Sempre inclua B em Γ.",
                                  "learningObjective": "Identificar e configurar corretamente todos os elementos constitutivos de uma Máquina de Turing.",
                                  "commonMistakes": [
                                    "Omitir o blank B em Γ",
                                    "Confundir Σ (entrada) com Γ (fita)",
                                    "Posicionar cabeça incorretamente na fita inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer e registrar a configuração inicial",
                                  "subSteps": [
                                    "Definir a configuração inicial como (q0, w # B B ..., 1), onde # indica posição da cabeça.",
                                    "Ler o símbolo atual sob a cabeça (primeiro símbolo de w).",
                                    "Consultar δ(q0, símbolo_atual) para prever a próxima ação.",
                                    "Documentar a configuração inicial em uma tabela ou diagrama sequencial."
                                  ],
                                  "verification": "A configuração inicial está anotada corretamente com estado, conteúdo da fita e posição da cabeça.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de transições δ",
                                    "Folha para diagramas de fita"
                                  ],
                                  "tips": "Use underlining ou seta para marcar posição da cabeça: q0: _a_ b B ...",
                                  "learningObjective": "Representar formalmente uma configuração de MT e prepará-la para simulação.",
                                  "commonMistakes": [
                                    "Iniciar em estado errado (não q0)",
                                    "Não marcar posição exata da cabeça",
                                    "Ignorar blanks à direita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar transições sequencialmente usando δ",
                                  "subSteps": [
                                    "Ler estado atual q e símbolo σ sob a cabeça.",
                                    "Aplicar δ(q, σ) = (p, τ, D): escrever τ na fita, mover para p, deslocar cabeça por D.",
                                    "Atualizar a configuração: novo estado p, fita modificada, nova posição da cabeça.",
                                    "Repetir até detectar condição de parada, registrando cada configuração intermediária.",
                                    "Manter histórico numerado de todas configurações."
                                  ],
                                  "verification": "Cada transição segue exatamente δ, com fita, estado e posição atualizados corretamente em todas as etapas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela δ completa",
                                    "Simulador ou papel para múltiplas fitas simuladas"
                                  ],
                                  "tips": "Simule fitas infinitas limitando a células usadas. Copie fita anterior para evitar erros.",
                                  "learningObjective": "Executar a função de transição δ de forma precisa e sequencial.",
                                  "commonMistakes": [
                                    "Aplicar δ com símbolo errado",
                                    "Mover cabeça na direção incorreta",
                                    "Perder track da posição da cabeça"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar e concluir a execução",
                                  "subSteps": [
                                    "Verificar se estado atual ∈ F (aceitação) ou estado de rejeição.",
                                    "Detectar loop infinito comparando configurações anteriores (mesmo estado + fita à esquerda/direita + posição relativa).",
                                    "Se não parar, declarar 'não halts' ou loop detectado após limite de passos (ex: 2x comprimento de w).",
                                    "Anotar resultado final: aceita, rejeita ou loop."
                                  ],
                                  "verification": "Resultado final justificado com configuração terminal ou evidência de loop (duas configs idênticas).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de configurações anteriores",
                                    "Critério de detecção de loop"
                                  ],
                                  "tips": "Para loops, cheque 'perfil' da fita: símbolos à esquerda da cabeça + estado + posição + símbolos à direita.",
                                  "learningObjective": "Identificar condições de parada em simulações de MT.",
                                  "commonMistakes": [
                                    "Declarar aceitação sem estado final",
                                    "Não detectar loops óbvios",
                                    "Continuar simulação indefinidamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e validar a sequência completa",
                                  "subSteps": [
                                    "Listar todas configurações em sequência numerada.",
                                    "Verificar consistência entre configs consecutivas via δ.",
                                    "Resumir o traço de execução e resultado.",
                                    "Testar com variação da entrada para validação."
                                  ],
                                  "verification": "Sequência inteira reproduzível e correta ao reexecutar manualmente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Sequência anotada",
                                    "Ferramenta de verificação online"
                                  ],
                                  "tips": "Use formato: Config k: q | fita com _símbolo_ | posição.",
                                  "learningObjective": "Compilar e validar uma simulação completa de MT.",
                                  "commonMistakes": [
                                    "Erros de transcrição na fita",
                                    "Pular verificação de consistência",
                                    "Omitir configs intermediárias"
                                  ]
                                }
                              ],
                              "practicalExample": "MT M para {a^n b^n | n≥0}: Q={q0,q1,qf,qr}, Σ={a,b}, Γ={a,b,B}, δ(q0,a)=(q0,a,R); δ(q0,b)=(q1,b,R); δ(q1,b)=(q1,b,R); δ(q1,B)=(qf,B,N); etc. Entrada: aabb. Sequência: Config1: q0 | _a_a b b #B... (aceita em qf após cruzar a's e b's).",
                              "finalVerifications": [
                                "Lista todas configurações corretamente até parada.",
                                "Cada transição obedece δ sem discrepâncias.",
                                "Detecta corretamente aceitação/rejeição/loop.",
                                "Representa fitas e posições com precisão.",
                                "Justifica resultado com evidências formais.",
                                "Reexecução manual confirma a simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de δ (100% das transições corretas).",
                                "Completude da sequência de configurações.",
                                "Correta detecção de condições de parada.",
                                "Clareza na representação visual/tabular.",
                                "Tratamento adequado de loops infinitos.",
                                "Validação cruzada com exemplo alternativo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Relações de transição como funções parciais.",
                                "Programação: Estados e loops semelhantes a máquinas de estados finitos/debuggers.",
                                "Lógica Computacional: Simulação de provas por casos em autômatos.",
                                "Análise de Algoritmos: Traços de execução para bounding de tempo/espaço."
                              ],
                              "realWorldApplication": "Debug de compiladores e interpretadores (ex: simular execução de código assembly); modelagem de protocolos de rede com estados finitos estendidos; verificação de algoritmos em ferramentas como JFLAP ou Tarski's World."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.1.1",
                              "10.1.8.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.8.1.2.3",
                            "name": "Diferenciar halting de loop infinito",
                            "description": "Identificar quando a MT para (halts) em estado de aceitação ou rejeição, versus quando entra em loop sem parar, e explicar implicações para decidibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Halting e Loop Infinito",
                                  "subSteps": [
                                    "Defina halting como o estado em que a Máquina de Turing (MT) entra em um estado de aceitação (q_accept) ou rejeição (q_reject) e para.",
                                    "Defina loop infinito como uma configuração onde a MT repete transições indefinidamente sem alcançar estados finais.",
                                    "Explique a diferença: halting resolve a computação, loop infinito não resolve.",
                                    "Revise a estrutura básica de uma MT: estados, alfabeto, fita, cabeça de leitura/escrita, função de transição.",
                                    "Estude exemplos diagramáticos de MTs que halts e que loopam."
                                  ],
                                  "verification": "Resuma em suas palavras as diferenças entre halting e loop infinito, com um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama de MT básico",
                                    "Vídeo tutorial sobre MT (ex: YouTube - Turing Machines Basics)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Use analogias como 'semáforo verde/vermelho' para halting e 'roda girando sem parar' para loop.",
                                  "learningObjective": "Distinguir conceitualmente halting de loop infinito em MTs.",
                                  "commonMistakes": [
                                    "Confundir loop com rejeição",
                                    "Ignorar que halting pode ser em aceitação ou rejeição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Função de Transição para Detectar Padrões de Loop",
                                  "subSteps": [
                                    "Liste todos os estados e transições da função δ(q, símbolo) → (novo_estado, novo_símbolo, direção).",
                                    "Identifique ciclos: estados que se repetem em uma cadeia de transições sem saída para q_accept/q_reject.",
                                    "Marque estados 'mortos' (sem transição) vs. estados em loop.",
                                    "Use grafos de estados para visualizar caminhos possíveis.",
                                    "Classifique transições como 'progressivas' (rumo a halting) ou 'cíclicas' (loop)."
                                  ],
                                  "verification": "Desenhe o grafo de estados de uma MT dada e circule ciclos potenciais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta de desenho de grafos (ex: Draw.io ou papel)",
                                    "Exemplos de MTs com transições conhecidas",
                                    "Tabela de transição em PDF"
                                  ],
                                  "tips": "Comece pelos estados iniciais e trace todos os caminhos possíveis até detectar repetições.",
                                  "learningObjective": "Detectar padrões de loop na função de transição de uma MT.",
                                  "commonMistakes": [
                                    "Não considerar todas as direções da cabeça (L/R)",
                                    "Assumir loop sem verificar todas as fitas possíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Execuções Passo a Passo de MTs",
                                  "subSteps": [
                                    "Configure a fita inicial, estado q0 e posição da cabeça.",
                                    "Execute transições manualmente, registrando configuração a cada passo (estado, fita, posição).",
                                    "Pare se alcançar q_accept/q_reject (halting) ou detectar repetição de configuração (loop pelo Princípio de Pompa).",
                                    "Simule 3 MTs: uma que aceita, uma que rejeita, uma que loopa.",
                                    "Registre o número de passos até halting ou detecção de loop."
                                  ],
                                  "verification": "Grave uma simulação completa de uma MT que loopa, mostrando a configuração repetida.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Simulador online de MT (ex: Turing Machine Simulator)",
                                    "Fichas ou planilha Excel para rastrear passos",
                                    "Exemplos de configurações de fita"
                                  ],
                                  "tips": "Use o Princípio de Pompa: se configuração se repetir, há loop.",
                                  "learningObjective": "Executar simulações para diferenciar comportamentos em prática.",
                                  "commonMistakes": [
                                    "Erros de transcrição na fita",
                                    "Parar simulação prematuramente sem detectar loop"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Implicações para Decidibilidade",
                                  "subSteps": [
                                    "Explique que halting é indecidível (Problema da Parada de Turing).",
                                    "Discuta como loops infinitos tornam problemas indecidíveis (ex: não há algoritmo geral para prever halting).",
                                    "Compare com problemas decidíveis (ex: aceitação de linguagens regulares).",
                                    "Analise exemplos: MT que halts sempre vs. MT que pode loopar em algumas entradas.",
                                    "Debata impactos: limites da computação, busy beaver, colossus halting."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que distinguir halting/loop afeta decidibilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo sobre Problema da Parada (Wikipedia ou livro Sipser)",
                                    "Vídeos sobre undecidability",
                                    "Notas de aula sobre teoria da computação"
                                  ],
                                  "tips": "Ligue ao diagonalization argument de Turing para reforçar.",
                                  "learningObjective": "Compreender implicações teóricas para complexidade e decidibilidade.",
                                  "commonMistakes": [
                                    "Confundir undecidível com 'difícil'",
                                    "Ignorar que algumas MTs são decidíveis em casos específicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma MT que reconhece {a^n b^n}: Inicia lendo a's, move para direita contando; ao encontrar b, volta contando b's. Se contadores batem, halts em aceitação; se não, entra em loop alternando entre fitas desbalanceadas sem parar. Simule entrada 'aabbb': loop detectado após repetição de configuração (q_count_a, fita parcial).",
                              "finalVerifications": [
                                "Simule corretamente 3 MTs diferentes, identificando halting ou loop em cada.",
                                "Desenhe grafo de estados destacando ciclos e caminhos para halting.",
                                "Explique o Princípio de Pompa para detecção de loops.",
                                "Discuta um exemplo onde loop implica indecidibilidade.",
                                "Resolva um quiz com 5 configurações de MT, prevendo comportamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de halting vs. loop (90% acerto em simulações).",
                                "Uso correto do Princípio de Pompa e análise de ciclos.",
                                "Explicação clara das implicações para decidibilidade.",
                                "Qualidade dos diagramas e rastreamentos de execução.",
                                "Capacidade de generalizar para novas MTs sem erros comuns.",
                                "Profundidade nas discussões teóricas e exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (ciclos e caminhos).",
                                "Programação: Debugging de loops infinitos em código.",
                                "Filosofia: Limites do conhecimento e computação (Gödel/Turing).",
                                "Lógica: Argumentos de diagonalização e indecidibilidade."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, detectar loops infinitos previne travamentos; em análise de algoritmos, entender halting ajuda a provar limites de eficiência (ex: sem algoritmo universal para prever se um programa para); usado em verificadores de código estático e simuladores de hardware."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.3",
                        "name": "Poder Computacional e Complexidade",
                        "description": "Capacidades da Máquina de Turing como modelo universal de computação e sua relação com análise de complexidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.3.1",
                            "name": "Reconhecer linguagens decidíveis e reconhecíveis",
                            "description": "Explicar que MT decididoras (deciders) halitam sempre (linguagens recursivas), enquanto reconhecidoras (acceptors) halitam só em aceitação (linguagens recursivamente enumeráveis).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Definições Básicas de Decisores e Reconhecedores",
                                  "subSteps": [
                                    "Estude a definição formal de uma Máquina de Turing decididora (decider): uma MT que sempre halta em strings da linguagem (aceita) ou não (rejeita).",
                                    "Analise a definição de uma Máquina de Turing reconhecidora (acceptor): uma MT que halta e aceita strings na linguagem, mas pode loopar infinitamente em strings fora dela.",
                                    "Compare as linguagens geradas: decidíveis (recursivas) vs. reconhecíveis (recursivamente enumeráveis - RE).",
                                    "Revise o conceito de halting: decididores sempre halta, reconhecidores só em aceitação.",
                                    "Desenhe diagramas de fluxo para ilustrar os comportamentos de halting."
                                  ],
                                  "verification": "Resuma as definições em suas próprias palavras e desenhe diagramas corretos sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Notas de aula sobre MT",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use tabelas para comparar halting behaviors em aceitação/rejeição/loop.",
                                  "learningObjective": "Definir precisamente decididores e reconhecidores e suas linguagens associadas.",
                                  "commonMistakes": [
                                    "Confundir halting em rejeição com loop infinito",
                                    "Achar que todas RE são decidíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Comportamento de Halting e suas Implicações",
                                  "subSteps": [
                                    "Simule execuções de MT decididoras em exemplos simples (ex: linguagem de palíndromos).",
                                    "Simule MT reconhecidoras que loopam em rejeição (ex: simulador universal de MT).",
                                    "Discuta o Problema da Parada (Halting Problem): não decidível, mas RE.",
                                    "Prove que toda linguagem decidível é RE, mas nem toda RE é decidível.",
                                    "Crie uma tabela de inclusão: decidíveis ⊂ RE."
                                  ],
                                  "verification": "Explique por que o Halting Problem é RE mas não decidível, com argumento diagonal.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulador de Máquina de Turing online (ex: Turing Machine Simulator)",
                                    "Exemplos de linguagens do livro Sipser"
                                  ],
                                  "tips": "Sempre pergunte: 'A MT halta em TODOS os inputs?' para decidibilidade.",
                                  "learningObjective": "Diferenciar halting behaviors e entender hierarquia de linguagens.",
                                  "commonMistakes": [
                                    "Ignorar loops infinitos em reconhecidores",
                                    "Confundir RE com co-RE"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Clássicos de Linguagens Decidíveis e RE",
                                  "subSteps": [
                                    "Classifique linguagens regulares e context-free como decidíveis (com MT decididora).",
                                    "Estude ALL (todas strings): decidível; EMPTY (linguagem vazia): decidível.",
                                    "Exemplo RE não decidível: { <M,w> | M halta em w }.",
                                    "Construa MT reconhecidora para uma linguagem RE simples.",
                                    "Debata por que A^TM (aceptação de MT) é RE mas não decidível."
                                  ],
                                  "verification": "Liste 3 decidíveis e 2 RE-não-decidíveis com justificativa de MT.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Lista de linguagens padrão em teoria da computação",
                                    "Ferramenta JFLAP para simulações"
                                  ],
                                  "tips": "Memorize: propriedades semânticas como halting são tipicamente não-decidíveis.",
                                  "learningObjective": "Identificar e justificar classificações de linguagens.",
                                  "commonMistakes": [
                                    "Classificar halting como decidível",
                                    "Esquecer que finitas são decidíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos em Provas e Contraexemplos",
                                  "subSteps": [
                                    "Prove que se L e complement(L) são RE, então L é decidível.",
                                    "Use redução para mostrar não-decidibilidade (reduza de Halting Problem).",
                                    "Crie contraexemplo: MT que loopa em rejeição para RE-não-decidível.",
                                    "Discuta Rice's Theorem: propriedades não-triviais de RE são não-decidíveis.",
                                    "Resolva exercícios: classifique novas linguagens propostas."
                                  ],
                                  "verification": "Resolva 2 provas curtas corretamente e explique raciocínio.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exercícios de Sipser capítulos 4-5",
                                    "Folhas de prova em LaTeX ou papel"
                                  ],
                                  "tips": "Estruture provas: assuma decididor, derive contradição via simulador.",
                                  "learningObjective": "Aplicar teoremas para reconhecer decidibilidade/RE.",
                                  "commonMistakes": [
                                    "Reduções erradas (direção invertida)",
                                    "Confundir decidível com RE"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado uma linguagem L = { <M> | M é uma MT que aceita a string 0 }, construa uma MT reconhecidora que simule M em 0 e aceite se halta; prove que é RE mas não decidível reduzindo do Halting Problem.",
                              "finalVerifications": [
                                "Explique a diferença de halting entre decididores e reconhecidores.",
                                "Classifique corretamente 5 linguagens como decidível ou RE.",
                                "Descreva por que Halting Problem é RE-não-decidível.",
                                "Prove que decidíveis são RE.",
                                "Identifique uma propriedade não-decidível via Rice.",
                                "Desenhe diagrama de hierarquia Chomsky com decid/RE."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de halting (100% correto).",
                                "Correta classificação de exemplos (sem erros em 5+ casos).",
                                "Profundidade em provas/reduções (lógica irrefutável).",
                                "Uso apropriado de terminologia (decidível vs RE).",
                                "Criatividade em exemplos práticos e contraexemplos.",
                                "Compreensão de implicações (ex: undecidability em programação)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (enumerabilidade), Lógica (Gödel incompleto).",
                                "Filosofia: Limites do conhecimento computacional (epistemologia).",
                                "Engenharia de Software: Verificação de programas e undecidability em tools.",
                                "Lógica Matemática: Provas por contradição e reduções.",
                                "Inteligência Artificial: Limites de aprendizado de máquina em problemas undecidíveis."
                              ],
                              "realWorldApplication": "Em compiladores e verificadores de software, testar decidibilidade de propriedades como 'este programa halta?' guia o design de análises estáticas aproximadas; em IA, entender RE explica por que alguns problemas de aprendizado são intratáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.2.3"
                            ]
                          },
                          {
                            "id": "10.1.8.1.3.2",
                            "name": "Calcular complexidade de tempo em MT",
                            "description": "Definir T(n) como o número máximo de passos em uma MT determinística para entradas de tamanho n, e relacionar com classes como P via simulação de algoritmos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Máquinas de Turing e Tempo de Execução",
                                  "subSteps": [
                                    "Revise a definição formal de uma Máquina de Turing determinística (MTD): estados, alfabeto, fita, cabeçote e função de transição.",
                                    "Identifique os componentes que afetam o tempo de execução: loops, transições e halt.",
                                    "Diferencie tempo de execução em entradas de tamanho n versus casos específicos.",
                                    "Estude exemplos simples de MTD que param em tempo linear ou quadrático.",
                                    "Pratique traçando execuções manuais de MTD em entradas pequenas."
                                  ],
                                  "verification": "Traçar corretamente a execução de uma MTD simples em uma entrada de tamanho 3, contando o número de passos até halt.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Simulador online de Máquina de Turing (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": "Comece com MTDs mínimas para evitar sobrecarga; foque em contar transições como passos.",
                                  "learningObjective": "Compreender como o tempo de execução é medido em MTDs por meio de contagem de transições.",
                                  "commonMistakes": [
                                    "Confundir passos com mudanças de estado em vez de transições",
                                    "Ignorar loops infinitos em análise inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente T(n) para Máquinas de Turing Determinísticas",
                                  "subSteps": [
                                    "Defina T(n) como o número máximo de passos que uma MTD toma sobre qualquer entrada de tamanho n antes de halting ou looping.",
                                    "Discuta o papel da função de tempo T:MT → ℕ, onde T(M,n) é o pior caso.",
                                    "Aprenda a notação assintótica: O(T(n)), Θ(T(n)) para limites superior e apertado.",
                                    "Estude como T(n) é independente da codificação da entrada, focando no comprimento n.",
                                    "Pratique escrevendo definições formais para MTDs dadas."
                                  ],
                                  "verification": "Escrever a definição formal de T(n) e calcular T(1), T(2) para uma MTD fornecida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Notas de aula sobre Complexidade Computacional",
                                    "Papel e lápis para diagramas de MT"
                                  ],
                                  "tips": "Use notação matemática precisa: T_M(n) = max{|<M,w>| : |w|=n, M halts on w}.",
                                  "learningObjective": "Dominar a definição precisa de complexidade de tempo T(n) em MTDs.",
                                  "commonMistakes": [
                                    "Confundir T(n) com tempo médio em vez de pior caso",
                                    "Não considerar entradas que causam loop"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular T(n) em Exemplos Práticos de Máquinas de Turing",
                                  "subSteps": [
                                    "Escolha uma MTD simples, como reconhecedora de {0^n 1^n}, e trace execuções para n=1 a 5.",
                                    "Conte passos: cada transição de configuração é um passo.",
                                    "Determine o padrão: encontre uma fórmula fechada para T(n), ex: O(n^2).",
                                    "Analise uma MTD para linguagem regular e compare com linear time.",
                                    "Use simulador para validar contagens em entradas maiores."
                                  ],
                                  "verification": "Calcular T(n) = Θ(n^2) para uma MTD de palíndromos pares e justificar com traçado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Simulador de MT online",
                                    "Exemplos de MTDs de livros texto"
                                  ],
                                  "tips": "Registre configurações em tabela: estado, fita, posição do cabeçote por passo.",
                                  "learningObjective": "Aplicar cálculo de T(n) em MTDs concretas, identificando padrões assintóticos.",
                                  "commonMistakes": [
                                    "Contar apenas mudanças de estado, ignorando movimentos de fita",
                                    "Não maximizar sobre todas entradas de tamanho n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar T(n) com Classes de Complexidade como P via Simulação",
                                  "subSteps": [
                                    "Revise definição de P: linguagens decididas por MTD em tempo polinomial O(n^k).",
                                    "Aprenda simulação de RAM/algoritmos em MTD: multi-tape para eficiência.",
                                    "Mostre que algoritmo em O(n^2) RAM simula em MTD com T(n) = O(n^4).",
                                    "Discuta como T(n) ≤ p(n) implica na classe TIME(p(n)).",
                                    "Pratique provando que uma linguagem está em P via construção de MTD polinomial."
                                  ],
                                  "verification": "Construir esboço de MTD que simula busca binária e calcular T(n) = O(n log n).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Capítulo sobre Classes de Complexidade (Arora-Barak)",
                                    "Pseudocódigo de algoritmos comuns"
                                  ],
                                  "tips": "Lembre: simulação multi-tape em single-tape custa fator quadrático no tempo.",
                                  "learningObjective": "Conectar T(n) de MTDs com hierarquia de complexidade temporal como P.",
                                  "commonMistakes": [
                                    "Ignorar overhead de simulação ao relacionar com P",
                                    "Confundir DTIME com P diretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma MTD que verifica se uma string é um palíndromo par (ex: 010010 sobre {0,1}), trace: em n=4 (|w|=4), máximo 16 passos (ida/volta na fita). T(n) = Θ(n^2) pois cabeçote varre fita n/2 vezes em cada direção.",
                              "finalVerifications": [
                                "Definir corretamente T(n) para qualquer MTD dada.",
                                "Calcular T(n) exato para entradas n≤5 em MTD simples.",
                                "Identificar classe temporal (ex: TIME(n^3)) de uma MTD.",
                                "Explicar simulação de algoritmo polinomial em MTD.",
                                "Provar que L em P implica decidível por MTD com T(n)=O(n^k).",
                                "Detectar erros em cálculos de T(n) de pares aluno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de T(n) e notação assintótica (30%).",
                                "Correção em cálculos de T(n) para exemplos (25%).",
                                "Profundidade na análise de simulações e relações com P (20%).",
                                "Clareza em traçados e justificativas (15%).",
                                "Identificação de erros comuns e conexões interdisciplinares (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e funções de crescimento (Big-O).",
                                "Lógica: Estados e transições como autômatos finitos estendidos.",
                                "Física: Modelos computacionais análogos a processos dinâmicos.",
                                "Engenharia de Software: Análise de performance em algoritmos reais."
                              ],
                              "realWorldApplication": "Analisar eficiência de algoritmos em sistemas embarcados ou criptografia, onde limites de tempo em hardware simulam MTDs, otimizando para polinomial time em problemas NP para viabilidade prática."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.8.1.3.3",
                            "name": "Comparar MT determinística e não-determinística",
                            "description": "Descrever MT não-determinística (δ: Q × Γ → pot(Q × Γ × {L,R})), seu poder equivalente para reconhecimento, e base para classe NP em complexidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Máquina de Turing Determinística (DTM)",
                                  "subSteps": [
                                    "Defina os componentes formais de uma DTM: Q (estados), Γ (alfabeto da fita), δ: Q × Γ → Q × Γ × {L,R,N}",
                                    "Explique o funcionamento passo a passo: leitura, escrita, movimento determinístico",
                                    "Simule uma DTM simples para reconhecer {a^n b^n | n ≥ 0}",
                                    "Discuta linguagens reconhecíveis por DTM (REC)"
                                  ],
                                  "verification": "Construa e execute manualmente uma DTM para uma linguagem simples, confirmando aceitação/rejeição correta",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta para simulação",
                                    "Referência: Livro Sipser 'Introduction to the Theory of Computation' Capítulo 3"
                                  ],
                                  "tips": "Sempre anote o estado atual, símbolo lido e configuração da fita em cada transição",
                                  "learningObjective": "Compreender os fundamentos da DTM e sua transição determinística única",
                                  "commonMistakes": [
                                    "Ignorar o estado de halt",
                                    "Confundir movimento N (não mover) com L/R",
                                    "Não tratar rejeição explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Máquina de Turing Não-Determinística (NTM)",
                                  "subSteps": [
                                    "Defina NTM: Similar à DTM, mas δ: Q × Γ → P(Q × Γ × {L,R}) onde P é o conjunto potências",
                                    "Explique não-determinismo: Em cada passo, múltiplas transições possíveis; máquina 'ramifica'",
                                    "Descreva aceitação: Existe pelo menos um caminho que aceita a entrada",
                                    "Compare conceitualmente com adivinhação: NTM pode 'adivinhar' o caminho certo",
                                    "Simule uma NTM simples para linguagem {ww^R | w ∈ {0,1}*}"
                                  ],
                                  "verification": "Desenhe o grafo de transição de uma NTM mostrando ramificações e identifique um caminho aceitador",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta online como JFLAP para simular NTM",
                                    "Papel para diagramas de transição"
                                  ],
                                  "tips": "Pense na NTM como um and-or tree: OR para não-determinismo, AND para sequencial",
                                  "learningObjective": "Dominar a definição formal e o comportamento de uma NTM",
                                  "commonMistakes": [
                                    "Confundir aceitação (existe caminho) com rejeição universal",
                                    "Esquecer que fita é infinita em ambas",
                                    "Misturar alfabeto de entrada com fita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar DTM e NTM em Termos de Poder Computacional",
                                  "subSteps": [
                                    "Prove que toda NTM pode ser simulada por DTM (construção padrão: BFS no espaço de configurações)",
                                    "Discuta tempo de simulação: O(n^k) para NTM vira O(2^{n^k}) para DTM",
                                    "Analise linguagens reconhecíveis: REC_DTM = REC_NTM",
                                    "Compare decidibilidade: Ambas decidem linguagens recursivas",
                                    "Exemplo: NTM para SAT é mais intuitiva que DTM equivalente"
                                  ],
                                  "verification": "Esboce a construção da simulação DTM de NTM e calcule blow-up exponencial para k=2",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pseudocódigo para simulador",
                                    "Exemplos de provas de Sipser ou Arora-Barak"
                                  ],
                                  "tips": "Use tabela de configurações para rastrear ramificações na simulação",
                                  "learningObjective": "Estabelecer equivalência de poder de reconhecimento entre DTM e NTM",
                                  "commonMistakes": [
                                    "Achar NTM mais poderosa que DTM",
                                    "Ignorar overhead exponencial na simulação",
                                    "Confundir reconhecimento com decisão em tempo polinomial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar NTM com Classes de Complexidade NP",
                                  "subSteps": [
                                    "Defina NP: Linguagens reconhecíveis por NTM em tempo polinomial",
                                    "Explique verificador: Para x ∈ L, existe certificado c (|c| poly(|x|)) verificável em poly tempo por DTM",
                                    "Mostre equivalência: NTM poly-time ↔ NP",
                                    "Exemplo: 3-SAT como NTM que adivinha atribuição e verifica",
                                    "Discuta implicações: P = NP? se DTM poly simula NTM poly eficientemente"
                                  ],
                                  "verification": "Construa uma NTM polinomial para um problema NP-completo como Clique e descreva seu verificador DTM",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Lista de problemas NP-completos",
                                    "Ferramenta para gerar instâncias como SAT solvers"
                                  ],
                                  "tips": "Lembre: NP é sobre verificação rápida, não solução rápida",
                                  "learningObjective": "Compreender NTM como base formal para NP e suas implicações",
                                  "commonMistakes": [
                                    "Confundir NP com 'não-polinomial'",
                                    "Achar todo problema NP difícil de resolver",
                                    "Esquecer que P ⊆ NP"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma NTM para reconhecer se uma fórmula 3-SAT é satisfatível: não-determinísticamente adivinhe uma atribuição de variáveis (ramificação 2^|vars|), então verifique cláusulas em tempo linear. Simule com DTM expandindo todas as ramificações para comparar eficiência.",
                              "finalVerifications": [
                                "Explique verbalmente a função δ de NTM e dê um exemplo com múltiplas imagens",
                                "Prove informalmente que REC_NTM ⊆ REC_DTM via simulação",
                                "Classifique corretamente 3 exemplos de linguagens em P vs NP",
                                "Desenhe diagramas de transição para DTM e NTM equivalentes",
                                "Discuta por que P=NP implicaria colapso de hierarquia de complexidade",
                                "Simule manualmente uma NTM com 3 passos e identifique caminhos aceitadores"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de δ para NTM (múltiplas transições corretas)",
                                "Correta demonstração de simulação DTM de NTM com análise de tempo",
                                "Compreensão clara da equivalência REC_DTM = REC_NTM",
                                "Explicação precisa da relação NTM polinomial com NP e verificadores",
                                "Uso correto de exemplos concretos sem erros conceituais",
                                "Capacidade de identificar erros comuns em comparações"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos (potência) e grafos (árvores de computação)",
                                "Lógica: Não-determinismo similar a busca em árvores de prova",
                                "Filosofia: Questão P=NP e limites da computação",
                                "Engenharia de Software: Verificadores em testes unitários e CI/CD",
                                "Probabilidade: Simulações probabilísticas (BPP) estendem NTM"
                              ],
                              "realWorldApplication": "Em otimização e IA, problemas NP como TSP usam heurísticas baseadas em NTM (busca local não-determinística); verificadores NP aceleram criptografia (ex: primality testing em RSA) e scheduling em logística."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.1.3",
                              "10.1.8.1.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.2",
                    "name": "Algoritmos Não-Determinísticos",
                    "description": "Algoritmos que permitem múltiplas transições simultâneas, resolvendo problemas em tempo polinomial não-determinístico.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.2.1",
                        "name": "Máquina de Turing Não-Determinística (MTND)",
                        "description": "Modelo computacional que estende a Máquina de Turing determinística permitindo múltiplas transições simultâneas a partir de um estado e símbolo lido, simulando computação paralela em ramificações.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.1.1",
                            "name": "Definir formalmente uma MTND",
                            "description": "Descrever os componentes de uma MTND, incluindo conjunto de estados, alfabeto de fita, função de transição não-determinística (que mapeia para múltiplos pares (estado, símbolo, direção)), estado inicial, estados de aceitação e rejeição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e descrever o conjunto de estados e o estado inicial",
                                  "subSteps": [
                                    "Liste os elementos básicos de uma Máquina de Turing (MT): estados, alfabeto, transição, inicial e finais.",
                                    "Defina Q como o conjunto finito de estados, ex: Q = {q0, q1, q2, q_accept, q_reject}.",
                                    "Especifique q0 ∈ Q como o estado inicial.",
                                    "Diferencie estados de aceitação (F ⊆ Q) e rejeição (opcional, mas halting states não em F).",
                                    "Desenhe um diagrama simples dos estados."
                                  ],
                                  "verification": "Verifique se Q é finito, q0 está em Q e F ⊆ Q; confira diagrama sem erros de notação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência: Sipser 'Introduction to the Theory of Computation' capítulo 7"
                                  ],
                                  "tips": "Use notação matemática padrão: Q, q₀, F. Evite estados infinitos.",
                                  "learningObjective": "Compreender a estrutura de controle de uma MTND através dos estados.",
                                  "commonMistakes": [
                                    "Confundir Q com alfabeto",
                                    "Esquecer q0 ou torná-lo ambíguo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os alfabetos: entrada Σ e fita Γ",
                                  "subSteps": [
                                    "Defina Σ como alfabeto de entrada finito, ex: Σ = {0,1} para linguagens binárias.",
                                    "Defina Γ ⊇ Σ como alfabeto da fita, incluindo símbolo em branco B ∉ Σ.",
                                    "Explique que a fita é infinita em ambas direções, inicializada com entrada em Σ e B elsewhere.",
                                    "Escreva Γ = Σ ∪ {B}, com B o blank symbol.",
                                    "Verifique inclusão: Σ ⊆ Γ."
                                  ],
                                  "verification": "Confirme Σ finito, Γ ⊇ Σ, B ∈ Γ \\ Σ; teste com exemplo como Σ={a,b}, Γ={a,b,B}.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para diagramas de fita",
                                    "Exemplos de linguagens regulares/não-regulares"
                                  ],
                                  "tips": "Sempre inclua B explicitamente; visualize fita como ...BBBwBBB... onde w é entrada.",
                                  "learningObjective": "Dominar os símbolos manipulados pela MTND.",
                                  "commonMistakes": [
                                    "Confundir Σ com Γ",
                                    "Esquecer B ou permitir B em Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar a função de transição não-determinística δ",
                                  "subSteps": [
                                    "Recapitule δ determinística: δ: Q × Γ → Q × Γ × {L,R}.",
                                    "Defina δ não-determinística: δ: Q × Γ → P(Q × Γ × {L,R}), onde P é o conjunto de subconjuntos finitos.",
                                    "Escreva exemplo: δ(q0, a) = {(q1, X, R), (q2, Y, L)} – múltiplas opções.",
                                    "Explique não-determinismo: máquina 'ramifica' em todas transições simultaneamente.",
                                    "Garanta δ(q, B) definido para todos q para evitar loops indefinidos."
                                  ],
                                  "verification": "Teste δ em inputs: deve retornar subconjunto finito não-vazio; simule uma transição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de transição em papel",
                                    "Software como JFLAP para simulação"
                                  ],
                                  "tips": "Use tabelas para listar δ; limite ramificações a 2-3 por célula para simplicidade.",
                                  "learningObjective": "Entender o cerne do não-determinismo na transição.",
                                  "commonMistakes": [
                                    "Definir δ como função única em vez de multivaluada",
                                    "Subconjuntos infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir a tupla formal completa e estados de aceitação/rejeição",
                                  "subSteps": [
                                    "Monte a tupla: MTND = (Q, Σ, Γ, δ, q0, B, F).",
                                    "Defina F ⊆ Q como estados de aceitação; rejeição por halting em q ∉ F ou loop.",
                                    "Escreva configuração formal: aceita se alguma computação atinge F com fita vazia (apenas B).",
                                    "Diferencie de MTD: poder equivalente, mas MTND resolve em 'tempo paralelo'.",
                                    "Valide tupla com todos componentes não-vazios e consistentes."
                                  ],
                                  "verification": "Escreva tupla completa; cheque se atende definição padrão (ex: compare com livro-texto).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha para tupla final",
                                    "Livro ou PDF de teoria da computação"
                                  ],
                                  "tips": "Sempre liste em ordem: Q, Σ, Γ, δ, q0, B, F. Teste consistência de δ com Q e Γ.",
                                  "learningObjective": "Sintetizar todos componentes em definição formal precisa.",
                                  "commonMistakes": [
                                    "Ordem errada na tupla",
                                    "Incluir rejeição explícita quando não padrão"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina MTND para {a^n b^n | n≥0}: Q={q0,q1,q2,qf,qr}, Σ={a,b}, Γ={a,b,X,B}, q0 inicial, F={qf}, δ(q0,a)={(q1,X,R)}, δ(q1,a)={(q1,X,R)}, δ(q1,b)={(q2,X,L)}, etc., aceita balanceando a's e b's via não-determinismo guiado.",
                              "finalVerifications": [
                                "Escreva tupla MTND correta para linguagem simples.",
                                "Simule 2 transições não-determinísticas sem erros.",
                                "Diferencie δ de MTD verbalmente.",
                                "Identifique todos 7 componentes sem omissões.",
                                "Explique aceitação via ramificação.",
                                "Desenhe diagrama de estados/transições."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (δ como função para potências).",
                                "Completude: todos componentes definidos corretamente.",
                                "Entendimento de não-determinismo vs. determinístico.",
                                "Capacidade de montar tupla coesa.",
                                "Correção em exemplos/simulações.",
                                "Clareza em descrições e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos (subconjuntos finitos em δ).",
                                "Lógica: Não-determinismo como busca em árvore (IA/Algoritmos).",
                                "Física: Paralelismo quântico (análoga a superposição).",
                                "Filosofia: Determinismo vs. livre-arbítrio computacional."
                              ],
                              "realWorldApplication": "Modela algoritmos de busca paralela em IA (ex: A* não-determinístico), otimização combinatória (ramificação em NP-completo), e simulações quânticas em computação quântica onde QMA usa não-determinismo probabilístico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.1.2",
                            "name": "Diferenciar MTND de MTD",
                            "description": "Comparar Máquinas de Turing Determinísticas (MTD) e Não-Determinísticas (MTND), explicando como a não-determinística explora todas as transições possíveis em paralelo, enquanto a determinística segue uma única.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Máquinas de Turing Determinísticas (MTD)",
                                  "subSteps": [
                                    "Defina os componentes básicos de uma MTD: fita infinita, cabeçote de leitura/escrita, estados finitos, função de transição única.",
                                    "Descreva o processo de computação: em cada passo, dada a configuração atual (estado + símbolo na fita), há exatamente uma transição possível.",
                                    "Trace um exemplo simples de execução de uma MTD que reconhece uma string binária par (ex: conta o número de 1s).",
                                    "Identifique que a MTD segue um caminho único e sequencial, sem ramificações.",
                                    "Anote as limitações: tempo de execução é linear no comprimento da entrada."
                                  ],
                                  "verification": "Construa e simule manualmente uma MTD simples em papel, confirmando que segue um único caminho sem ambiguidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama de estados",
                                    "Referência: Livro 'Introduction to the Theory of Computation' de Sipser (capítulo 3)",
                                    "Simulador online de Turing Machine como Turing Machine Simulator"
                                  ],
                                  "tips": "Desenhe o diagrama de transição como um grafo direcionado sem ramificações para visualizar a determinística.",
                                  "learningObjective": "Compreender os componentes e o comportamento sequencial único de uma MTD.",
                                  "commonMistakes": [
                                    "Confundir função de transição com múltiplas saídas",
                                    "Ignorar o estado de rejeição ou aceitação",
                                    "Assumir fita finita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Máquinas de Turing Não-Determinísticas (MTND)",
                                  "subSteps": [
                                    "Defina MTND: similar à MTD, mas a função de transição pode mapear para múltiplas transições possíveis para o mesmo estado e símbolo.",
                                    "Explique o conceito de 'não-determinismo': a máquina 'ramifica' em todas as transições possíveis simultaneamente.",
                                    "Descreva a aceitação: a MTND aceita se pelo menos um caminho leva ao estado de aceitação; rejeita só se todos rejeitam.",
                                    "Compare formalmente: δ(q, a) em MTD retorna (q', b, D); em MTND retorna conjunto de (q', b, D).",
                                    "Trace um exemplo: MTND para verificar palíndromos, ramificando em possibilidades."
                                  ],
                                  "verification": "Escreva a função de transição de uma MTND simples com pelo menos duas ramificações e liste todos os caminhos possíveis.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Papel para árvores de computação",
                                    "Simulador de NTM online",
                                    "Notas de aula sobre teoria da computação"
                                  ],
                                  "tips": "Pense na MTND como tendo 'fantasmas' explorando caminhos paralelos para evitar confusão com simulação sequencial.",
                                  "learningObjective": "Dominar a definição e o mecanismo de ramificação da MTND.",
                                  "commonMistakes": [
                                    "Confundir aceitação com todos os caminhos aceitarem",
                                    "Pensar que MTND executa sequencialmente",
                                    "Ignorar o poder de 'adivinhação' conceitual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Execução e Comportamento de MTD vs MTND",
                                  "subSteps": [
                                    "Simule a mesma tarefa (ex: verificar se string é palíndromo) em MTD e MTND lado a lado.",
                                    "Destaque diferenças: MTD testa uma hipótese por vez (sequencial); MTND testa todas em paralelo (conceitual).",
                                    "Discuta simulação: MTND pode ser simulada por MTD, mas com overhead exponencial (árvore de busca).",
                                    "Crie uma tabela comparativa: determinismo, número de transições, tempo de aceitação, poder computacional.",
                                    "Analise um exemplo onde MTND é mais eficiente conceitualmente (ex: problema de satisfação booleana)."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 diferenças chave e simule uma entrada em ambas as máquinas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela comparativa",
                                    "Exemplos de linguagens regulares/context-free",
                                    "Ferramenta JFLAP para visualização de autômatos"
                                  ],
                                  "tips": "Use diagramas de árvore para MTND vs linha reta para MTD para visualizar o paralelismo.",
                                  "learningObjective": "Identificar e explicar diferenças práticas no comportamento de execução.",
                                  "commonMistakes": [
                                    "Achar que MTND é mais poderosa computacionalmente",
                                    "Subestimar o custo de simulação da MTND por MTD",
                                    "Confundir não-determinismo com aleatoriedade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Equivalência e Implicações Teóricas",
                                  "subSteps": [
                                    "Prove a equivalência: toda MTND é simulada por MTD (classe RE é a mesma).",
                                    "Discuta classes de complexidade: NP usa não-determinismo polinomial (análoga a MTND em tempo polinomial).",
                                    "Analise implicações: MTND modela 'adivinhação' para problemas difíceis.",
                                    "Relacione com autômatos: NFA vs DFA (similaridade).",
                                    "Resuma diferenças em um parágrafo conciso."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras diferenciando MTND de MTD, incluindo equivalência, e responda a 3 perguntas de auto-teste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigo sobre P vs NP",
                                    "Livro de teoria da computação",
                                    "Quiz online sobre máquinas de Turing"
                                  ],
                                  "tips": "Lembre: equivalência em poder, mas diferença em eficiência simulada.",
                                  "learningObjective": "Compreender por que MTND e MTD decidem as mesmas linguagens, apesar das diferenças.",
                                  "commonMistakes": [
                                    "Concluir que MTND resolve problemas indecidíveis",
                                    "Ignorar que simulação é exponencial",
                                    "Confundir com máquinas probabilísticas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere verificar se uma string binária é um palíndromo. Uma MTD faria isso sequencialmente comparando símbolos da esquerda e direita, movendo o cabeçote de ida e volta (O(n^2) tempo). Uma MTND 'adivinha' o ponto médio, copia a metade esquerda para a direita em paralelo, verificando em O(n) conceitual, ramificando nas posições possíveis.",
                              "finalVerifications": [
                                "Explique verbalmente as diferenças em execução sem consultar notas.",
                                "Simule uma MTND com ramificações em papel para uma entrada dada.",
                                "Diferencie corretamente aceitação em MTND vs MTD.",
                                "Identifique quando uma MTD simula MTND e o custo associado.",
                                "Crie um exemplo personalizado de linguagem reconhecida por ambas.",
                                "Responda: 'MTND explora caminhos em paralelo?' com justificativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de componentes e função de transição (MTD única vs MTND múltipla).",
                                "Correta descrição do paralelismo conceitual na MTND.",
                                "Compreensão da equivalência computacional (mesmas linguagens RE).",
                                "Uso correto de exemplos e simulações sem erros lógicos.",
                                "Capacidade de tabela comparativa abrangente e clara.",
                                "Identificação de implicações para complexidade (ex: NP)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos grafos (diagrama de estados como grafo não-determinístico).",
                                "Física: Analogia com computação quântica (superposição como não-determinismo).",
                                "Lógica: Relação com satisfatibilidade booleana e teorema de Cook-Levin.",
                                "Engenharia de Software: Busca exaustiva vs heurísticas em algoritmos.",
                                "Filosofia: Debate sobre livre-arbítrio vs determinismo."
                              ],
                              "realWorldApplication": "Em algoritmos de busca e otimização, como em IA (A* com heurísticas simulando não-determinismo) ou verificação de software (model checking com exploração paralela de estados), onde conceitos de MTND inspiram soluções eficientes para problemas NP-completos em hardware paralelo moderno."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.1.3",
                            "name": "Simular execução de uma MTND",
                            "description": "Executar uma simulação passo a passo de uma MTND em uma entrada específica, ilustrando o árvore de computação com ramificações e identificando caminhos de aceitação ou rejeição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a configuração da MTND e preparar a entrada",
                                  "subSteps": [
                                    "Especificar os componentes formais: conjunto de estados Q, alfabeto de entrada Σ, alfabeto da fita Γ, função de transição δ (não-determinística), estado inicial q0, estados finais F e símbolo em branco □.",
                                    "Listar todas as transições possíveis, destacando aquelas não-determinísticas (mais de uma opção para (estado, símbolo)).",
                                    "Preparar a fita inicial: posicionar a cabeça na primeira célula da entrada, com o restante preenchido por □.",
                                    "Definir convenções de simulação: largura máxima da fita, limite de passos para evitar loops infinitos.",
                                    "Desenhar um diagrama ou tabela de transições para referência visual."
                                  ],
                                  "verification": "Verificar se todos os componentes estão definidos corretamente e a fita inicial está representada graficamente sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha ou software como JFLAP/Turing Machine Simulator.",
                                  "tips": "Use cores diferentes para transições determinísticas e não-determinísticas para facilitar a visualização.",
                                  "learningObjective": "Compreender e formalizar os elementos constitutivos de uma MTND.",
                                  "commonMistakes": "Omitir símbolos em branco nas extremidades da fita ou confundir Σ com Γ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iniciar a simulação na configuração inicial e identificar a primeira ramificação",
                                  "subSteps": [
                                    "Posicionar a configuração inicial: (q0, entrada na fita, cabeça no início).",
                                    "Aplicar δ na configuração inicial e registrar todas as configurações sucessoras (ramificações não-determinísticas).",
                                    "Desenhar o nó raiz da árvore de computação, com setas para cada sucessor.",
                                    "Para cada sucessor, anotar a configuração completa: estado, fita atual, posição da cabeça.",
                                    "Verificar se há halting imediato (aceitação ou rejeição)."
                                  ],
                                  "verification": "Árvore com nó raiz e suas ramificações iniciais corretamente ramificadas conforme δ.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado ou editor gráfico para árvores.",
                                  "tips": "Numere as ramificações sequencialmente para rastreamento fácil.",
                                  "learningObjective": "Executar o primeiro passo não-determinístico e visualizar a ramificação inicial.",
                                  "commonMistakes": "Ignorar múltiplas transições possíveis ou mover a cabeça incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir recursivamente todas as ramificações da árvore de computação",
                                  "subSteps": [
                                    "Para cada nó folha atual, aplicar δ e gerar sucessores, adicionando-os como filhos na árvore.",
                                    "Continuar até que todos os caminhos atinjam halting (aceitação em F com fita em □*, rejeição em estado rejeita ou limite de profundidade).",
                                    "Registrar configurações em cada nó: estado, fita, posição da cabeça, número de passo.",
                                    "Detectar e marcar loops ou rejeições explícitas.",
                                    "Garantir exploração em largura ou profundidade para cobertura completa."
                                  ],
                                  "verification": "Todos os nós terminais estão marcados como halting, sem ramificações pendentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel grande ou ferramenta digital como Draw.io para árvores complexas.",
                                  "tips": "Use abreviações para fitas longas, mas mantenha precisão nas mudanças.",
                                  "learningObjective": "Explorar o espaço de computação não-determinístico através de ramificações múltiplas.",
                                  "commonMistakes": "Parar prematuramente em uma ramificação ou duplicar configurações idênticas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar caminhos de aceitação/rejeição e finalizar a árvore",
                                  "subSteps": [
                                    "Percorrer todos os caminhos da raiz às folhas, identificando aqueles que terminam em aceitação.",
                                    "Destacar caminhos de aceitação (em negrito ou verde) e rejeição (vermelho).",
                                    "Verificar se a linguagem é aceita pela existência de pelo menos um caminho de aceitação.",
                                    "Desenhar a árvore completa com legendas para símbolos e halting.",
                                    "Resumir: número de caminhos, profundidade máxima, complexidade observada."
                                  ],
                                  "verification": "Árvore final rotulada corretamente com todos os caminhos classificados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Marcadores coloridos ou software de diagramação.",
                                  "tips": "Inclua uma legenda para halting: aceitação (✓), rejeição (✗), loop (∞).",
                                  "learningObjective": "Interpretar o resultado da simulação e concluir sobre aceitação da entrada.",
                                  "commonMistakes": "Classificar erroneamente halting ou ignorar caminhos não-explorados."
                                }
                              ],
                              "practicalExample": "Considere uma MTND M que aceita {a^n b^n | n ≥ 0}. Estados: q0 (inicial), q1 (lê a's), q2 (lê b's), qf (final), qr (rejeita). Transições não-determinísticas em q0: em 'a' → q1 ou qr; em q1 'a' → q1 R; em q1 'b' → q2 L; etc. Entrada: 'aab'. Simule: raiz (q0,aab,0) ramifica para q1 (move R) e qr (rejeita). Expanda até folhas: um caminho aceita após matching, outros rejeitam por mismatch. Árvores mostra ramificações em guesses de n.",
                              "finalVerifications": [
                                "Árvore de computação inclui todas as ramificações não-determinísticas corretas.",
                                "Todos os caminhos terminais estão corretamente classificados como aceitação ou rejeição.",
                                "Configurações de fita e posições da cabeça são precisas em cada nó.",
                                "Existe pelo menos um caminho de aceitação se a entrada pertence à linguagem.",
                                "Nenhum loop infinito é deixado sem detecção ou limite.",
                                "Legenda e rótulos facilitam a compreensão da simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação da função de transição δ em todos os nós (100% correto).",
                                "Cobertura completa de todas as ramificações sem omissões (sem caminhos pendentes).",
                                "Correta representação gráfica da árvore com nós e arestas claras.",
                                "Identificação precisa de halting states e condições de aceitação/rejeição.",
                                "Análise qualitativa do não-determinismo (ex: número de ramificações).",
                                "Clareza e organização do diagrama final."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: árvore de computação como grafo de busca em largura/profundidade.",
                                "Lógica e Prova: ramificações como disjunção não-determinística em provas.",
                                "Matemática Discreta: modelagem de conjuntos finitos e relações em autômatos.",
                                "Algoritmos: similaridade com backtracking e busca exaustiva."
                              ],
                              "realWorldApplication": "Simulações de MTND modelam paralelismo em hardware quântico (como qubits superpostos), algoritmos de busca não-determinística em IA (ex: minimax com branching), e verificação formal de software para detectar caminhos de falha em sistemas concorrentes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.2",
                        "name": "Estrutura de Algoritmos Não-Determinísticos",
                        "description": "Algoritmos executados em MTND que combinam uma fase de 'adivinhação' não-determinística seguida de verificação determinística em tempo polinomial.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.2.1",
                            "name": "Descrever a estrutura típica de um algoritmo não-determinístico",
                            "description": "Explicar o paradigma de dois estágios: geração não-determinística de uma solução candidata (guess) e verificação determinística em tempo polinomial (check).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Não-Determinismo Computacional",
                                  "subSteps": [
                                    "Definir algoritmo determinístico: segue um único caminho baseado na entrada.",
                                    "Contrastar com não-determinístico: máquina ramifica em múltiplos caminhos possíveis simultaneamente.",
                                    "Explicar aceitação em NTM: aceita se existe pelo menos um caminho que leva ao estado de aceitação.",
                                    "Visualizar não-determinismo como 'escolha mágica' sem custo computacional extra.",
                                    "Diferenciar de aleatoriedade: não é probabilístico, mas existencial."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre TM determinística e NTM, com um diagrama simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Capítulo sobre Máquinas de Turing Não-Determinísticas em livro de Teoria da Computação (ex: Sipser)",
                                    "Vídeo curto sobre não-determinismo (YouTube: 'Nondeterminism Explained')",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Imagine uma bifurcação infinita onde a máquina 'tenta tudo' em paralelo sem esforço.",
                                  "learningObjective": "Dominar a intuição de não-determinismo como exploração paralela de caminhos.",
                                  "commonMistakes": [
                                    "Confundir com algoritmos probabilísticos (esperança vs existência)",
                                    "Acreditar que NTM executa todos os caminhos sequencialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detalhar a Fase de Geração Não-Determinística (Guess)",
                                  "subSteps": [
                                    "Identificar o 'guess' como escolha não-determinística de uma solução candidata (certificado).",
                                    "Especificar que o certificado tem tamanho polinomial na entrada.",
                                    "Exemplificar: em SAT, guess valores booleanos para variáveis.",
                                    "Praticar: para Subset Sum, guess subconjunto de números.",
                                    "Entender que o guess não requer algoritmo; é fornecido 'magicamente'."
                                  ],
                                  "verification": "Escrever pseudocódigo para o guess em um problema como 3-SAT e justificar seu tamanho polinomial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de problemas NP (folha de referência SAT, Hamiltoniano)",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "O guess é o 'bilhete premiado' gerado instantaneamente pela não-determinização.",
                                  "learningObjective": "Descrever precisamente o papel e características do estágio de guess.",
                                  "commonMistakes": [
                                    "Fazer o guess exponencial em tempo (não tamanho)",
                                    "Pensar no guess como computacionalmente custoso"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Fase de Verificação Determinística (Check)",
                                  "subSteps": [
                                    "Definir check como algoritmo determinístico que valida o guess em tempo polinomial.",
                                    "Requisito chave: tempo O(poly(n + |certificado|)), onde n é tamanho da entrada.",
                                    "Exemplificar: em SAT, substituir valores no guess e testar cada cláusula.",
                                    "Implementar mentalmente: para Hamiltoniano, check se o caminho guess forma ciclo visitando todos vértices.",
                                    "Verificar determinismo: único caminho, sem ramificações."
                                  ],
                                  "verification": "Implementar e testar um check simples para Subset Sum com um guess dado, cronometrando manualmente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Implementação Python simples de check para SAT (código modelo)",
                                    "Ferramenta online para SAT solvers (para validação)"
                                  ],
                                  "tips": "O check é o 'juiz imparcial' que roda rápido apenas no candidato prometedor.",
                                  "learningObjective": "Construir e validar um verificador determinístico polinomial.",
                                  "commonMistakes": [
                                    "Permitir não-determinismo no check",
                                    "Ignorar dependência polinomial no certificado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Descrever a Estrutura Típica Completa",
                                  "subSteps": [
                                    "Sintetizar: algoritmo NTM = guess não-det. seguido de check det. polinomial.",
                                    "Escrever pseudocódigo padrão: 'nondet guess(c); if check(c, input) accept else reject'.",
                                    "Comparar com determinístico: resolve em tempo polinomial se NP=P.",
                                    "Discutir implicações: define classe NP.",
                                    "Aplicar a um exemplo completo: descrever estrutura para TSP."
                                  ],
                                  "verification": "Redigir uma descrição completa da estrutura típica, com pseudocódigo e exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelo de pseudocódigo NTM (referência)",
                                    "Problemas NP padrão (TSP, Clique)"
                                  ],
                                  "tips": "Estrutura é sempre 'gerar candidato mágico + validar rápido'.",
                                  "learningObjective": "Articular a estrutura de dois estágios de forma clara e precisa.",
                                  "commonMistakes": [
                                    "Omitir requisito polinomial no check",
                                    "Confundir tempo de NTM com tempo real de simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Reforçar com Exemplos e Diferenças",
                                  "subSteps": [
                                    "Aplicar estrutura a 3 problemas NP: SAT, Clique, Partition.",
                                    "Destacar diferenças com algoritmos determinísticos (ex: busca exaustiva).",
                                    "Simular execução NTM vs simulação determinística.",
                                    "Identificar quando usar paradigma guess-check.",
                                    "Autoavaliar descrições com critérios de precisão."
                                  ],
                                  "verification": "Criar tabela comparativa: problema, guess, check, tempo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de problemas NP (folha de exercícios)",
                                    "Ferramenta de diagramação (Draw.io ou papel)"
                                  ],
                                  "tips": "Sempre pergunte: 'Qual o certificado? Como validar em poly tempo?'",
                                  "learningObjective": "Aplicar fluentemente a estrutura a novos problemas.",
                                  "commonMistakes": [
                                    "Generalizar demais sem exemplos concretos",
                                    "Esquecer que NTM aceita se qualquer ramificação aceita"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema 3-SAT (fórmula com 3 literais por cláusula): Guess não-determinístico atribui true/false a cada variável (certificado de n bits). Check determinístico: para cada cláusula, verifica se pelo menos um literal é satisfeito após substiuição (O(n*m) tempo, polinomial). Se todas cláusulas verdadeiras, aceita.",
                              "finalVerifications": [
                                "Descreve corretamente os dois estágios: guess e check?",
                                "Explica geração não-determinística como 'escolha mágica' de certificado polinomial?",
                                "Menciona verificação determinística em tempo polinomial?",
                                "Fornece pseudocódigo ou diagrama representando a estrutura?",
                                "Diferencia adequadamente de algoritmos determinísticos?",
                                "Aplica a estrutura a pelo menos um exemplo concreto?",
                                "Identifica implicações para classe NP?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção guess (não-det., poly tamanho) vs check (det., poly tempo).",
                                "Clareza e completude na descrição dos estágios.",
                                "Uso correto de terminologia (NTM, certificado, polinomial).",
                                "Capacidade de exemplificar com problemas reais (SAT, etc.).",
                                "Compreensão de aceitação existencial vs universal.",
                                "Profundidade na comparação com determinismo.",
                                "Criatividade em aplicações ou extensões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e teoria dos grafos (problemas NP).",
                                "Filosofia: Noção de possibilidade e existência vs certeza determinística.",
                                "Engenharia: Verificação de software e testes automatizados (check).",
                                "Física: Modelos quânticos de computação (análogos ao não-determinismo).",
                                "Economia: Otimização combinatorial em problemas de decisão."
                              ],
                              "realWorldApplication": "Em criptografia, problemas como fatoração de inteiros estão em NP (guess fatores, check multiplicação em poly tempo), base para segurança de RSA; usado em provas de complexidade para justificar heurísticas em IA e otimização logística."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.2.2",
                            "name": "Identificar exemplos de algoritmos não-determinísticos",
                            "description": "Reconhecer algoritmos não-determinísticos para problemas como Satisfatibilidade Booleana (SAT), onde se adivinha uma atribuição de variáveis e verifica se satisfaz a fórmula.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Algoritmos Não-Determinísticos",
                                  "subSteps": [
                                    "Defina algoritmo determinístico: segue um caminho único baseado em entradas.",
                                    "Defina algoritmo não-determinístico: pode 'adivinhar' soluções em tempo polinomial e verificar.",
                                    "Compare com Máquina de Turing Não-Determinística (MTND): branches paralelos em escolhas.",
                                    "Identifique características chave: adivinhação livre e verificação eficiente.",
                                    "Estude a relação com classes de complexidade como NP."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre determinístico e não-determinístico, com um diagrama simples.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Acesso a slides ou vídeo sobre MTND (ex: Khan Academy ou Wikipedia)"
                                  ],
                                  "tips": "Use analogias como 'fork em uma estrada' para branches não-determinísticos.",
                                  "learningObjective": "Diferenciar algoritmos determinísticos de não-determinísticos e suas bases teóricas.",
                                  "commonMistakes": [
                                    "Confundir não-determinismo com aleatoriedade",
                                    "Achar que ND resolve em tempo real (é teórico)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Problema de Satisfatibilidade Booleana (SAT)",
                                  "subSteps": [
                                    "Aprenda fórmula booleana em Forma Normal Conjuntiva (CNF): conjunção de disjunções.",
                                    "Entenda cláusulas: cada disjunção de literais (variáveis ou negadas).",
                                    "Defina SAT: existe atribuição de verdadeiros/falsos que satisfaz todas cláusulas?",
                                    "Estude exemplo simples: (A ∨ ¬B) ∧ (¬A ∨ B) – teste atribuições.",
                                    "Reconheça SAT como NP-completo e base para algoritmos ND."
                                  ],
                                  "verification": "Construa uma fórmula CNF pequena e liste todas atribuições possíveis manualmente.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Editor de texto ou Python para simular fórmulas",
                                    "Tabela verdade impressa"
                                  ],
                                  "tips": "Comece com 2 variáveis para visualizar todas 4 atribuições.",
                                  "learningObjective": "Compreender a estrutura do problema SAT e sua representação.",
                                  "commonMistakes": [
                                    "Esquecer negações em literais",
                                    "Confundir satisfatibilidade com tautologia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir um Algoritmo Não-Determinístico para SAT",
                                  "subSteps": [
                                    "Descreva a fase de adivinhação: não-determinísticamente atribua valores a todas variáveis.",
                                    "Defina a fase de verificação: cheque se cada cláusula tem pelo menos um literal verdadeiro.",
                                    "Escreva pseudocódigo: guess(assignment); if verify(assignment, formula) accept.",
                                    "Simule em uma fórmula exemplo: para (x1 ∨ ¬x2) ∧ (¬x1 ∨ x2), mostre branches.",
                                    "Analise por que é polinomial: adivinhação O(1), verificação O(n*m) onde n=vars, m=cláusulas."
                                  ],
                                  "verification": "Implemente pseudocódigo e teste com fórmula de 3 variáveis.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Pseudocódigo em papel ou Jupyter Notebook",
                                    "Exemplos de fórmulas SAT online"
                                  ],
                                  "tips": "Pense na adivinhação como 'mágica' que testa todas possibilidades em paralelo.",
                                  "learningObjective": "Desenvolver e simular um algoritmo ND completo para SAT.",
                                  "commonMistakes": [
                                    "Ignorar que verificação deve ser determinística e eficiente",
                                    "Achar que adivinhação é iterativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Diferenciar Exemplos de Algoritmos Não-Determinísticos",
                                  "subSteps": [
                                    "Liste exemplos: SAT, Clique, Caminho Hamiltoniano – todos com guess + verify.",
                                    "Compare com determinístico: brute-force para SAT é exponencial.",
                                    "Identifique padrões: problemas de decisão NP com verificador polinomial.",
                                    "Pratique: dado pseudocódigo, classifique como ND ou não.",
                                    "Crie seu exemplo: adapte para 3-SAT ou outro problema NP."
                                  ],
                                  "verification": "Classifique 3 pseudocódigos fornecidos ou criados como ND ou determinísticos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Lista de problemas NP (Wikipedia)",
                                    "Flashcards com exemplos"
                                  ],
                                  "tips": "Pergunte: 'Há adivinhação seguida de verificação rápida?'",
                                  "learningObjective": "Reconhecer padrões em algoritmos ND e diferenciá-los.",
                                  "commonMistakes": [
                                    "Classificar busca exaustiva como ND",
                                    "Confundir P com NP"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a fórmula SAT (x ∨ ¬y) ∧ (¬x ∨ z) ∧ (y ∨ ¬z):\n- Adivinhação ND: atribui x=V, y=F, z=V.\n- Verificação: Primeira cláusula V; segunda V; terceira V. Aceita! (Em MTND, um branch aceita se qualquer um satisfaz).",
                              "finalVerifications": [
                                "Explique verbalmente um algoritmo ND para SAT.",
                                "Simule manualmente um exemplo com 3 variáveis.",
                                "Diferencie SAT-ND de brute-force.",
                                "Identifique 2 outros problemas NP com estrutura ND.",
                                "Crie diagrama de branches ND para fórmula simples.",
                                "Responda quiz: 'SAT é em P ou NP?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de não-determinismo (80%+ correto).",
                                "Capacidade de construir pseudocódigo ND funcional.",
                                "Correta identificação de exemplos vs. contraexemplos.",
                                "Profundidade na explicação de guess vs. verify.",
                                "Criatividade em exemplos personalizados.",
                                "Tempo de verificação polinomial demonstrado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica Proposicional e Teoria dos Grafos.",
                                "Filosofia: Raciocínio Não-Monótono e Indecidibilidade.",
                                "Inteligência Artificial: Busca Heurística e SAT Solvers.",
                                "Engenharia de Software: Verificação Formal de Programas."
                              ],
                              "realWorldApplication": "Em verificadores de teoremas (ex: Z3 solver) e otimização industrial (agendamento, VLSI design), onde SAT ND modela problemas reais para provar existência de soluções viáveis em hardware/software design."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.2.3",
                            "name": "Construir um algoritmo não-determinístico simples",
                            "description": "Desenvolver um algoritmo não-determinístico para um problema básico, como verificar se um grafo tem um clique de tamanho k, usando adivinhação de vértices e verificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Algoritmos Não-Determinísticos",
                                  "subSteps": [
                                    "Estude a definição de algoritmo não-determinístico: uma máquina que pode adivinhar soluções corretas em um ramo não-determinístico.",
                                    "Revise grafos: vértices, arestas e subgrafos completos (cliques).",
                                    "Entenda o problema Clique-k: dado um grafo G e inteiro k, existe um subconjunto de k vértices todos conectados?",
                                    "Diferencie determinístico vs. não-determinístico: foco em adivinhação + verificação.",
                                    "Analise por que Clique-k é NP-completo e como não-determinismo resolve em tempo polinomial."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe um grafo simples com um clique de tamanho 3.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Editor de grafos online (ex: Graphviz ou draw.io)"
                                  ],
                                  "tips": "Use diagramas para visualizar grafos; comece com exemplos pequenos (k=3).",
                                  "learningObjective": "Dominar os fundamentos teóricos de grafos e não-determinismo.",
                                  "commonMistakes": [
                                    "Confundir clique com caminho",
                                    "Ignorar que não-determinismo assume adivinhação instantânea"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a Fase de Adivinhação (Guess)",
                                  "subSteps": [
                                    "Defina o não-determinismo: a máquina adivinha um subconjunto S de exatamente k vértices do grafo G.",
                                    "Especifique como gerar todas as combinações possíveis de k vértices (C(n,k) ramos).",
                                    "Descreva formalmente: em um passo não-determinístico, selecione k vértices v1, v2, ..., vk.",
                                    "Implemente pseudocódigo para a adivinhação: 'não-deterministically choose S subset of V with |S|=k'.",
                                    "Verifique se a adivinhação é válida apenas se |S| = k."
                                  ],
                                  "verification": "Escreva pseudocódigo para a adivinhação e liste 3 exemplos de subconjuntos para um grafo com 5 vértices e k=2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e caneta para combinações",
                                    "Python ou pseudocódigo editor"
                                  ],
                                  "tips": "Pense em recursão para gerar combinações; não implemente exaustivamente ainda.",
                                  "learningObjective": "Modelar a adivinhação não-determinística para seleção de subconjuntos.",
                                  "commonMistakes": [
                                    "Adivinhar subconjuntos de tamanho variável",
                                    "Esquecer de garantir exatamente k vértices"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar a Fase de Verificação (Verify)",
                                  "subSteps": [
                                    "Para o subconjunto S adivinhado, verifique se todo par de vértices em S está conectado por uma aresta.",
                                    "Implemente loop duplo: para cada par (vi, vj) em S com i < j, cheque se existe aresta (vi,vj).",
                                    "Especifique tempo polinomial: O(k^2) para verificação, assumindo representação de adjacência ou matriz.",
                                    "Escreva pseudocódigo: 'for each pair in S: if no edge, reject'.",
                                    "Se todos os pares conectados, aceite; senão, rejeite."
                                  ],
                                  "verification": "Aplique a verificação manualmente em um grafo exemplo com S inválido e válido.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matriz de adjacência de um grafo exemplo",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Use matriz de adjacência para cheque rápido O(1) por par.",
                                  "learningObjective": "Criar uma verificadora determinística polinomial para o certificado.",
                                  "commonMistakes": [
                                    "Verificar apenas vizinhança individual",
                                    "Usar tempo superpolinomial na verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Fases e Formalizar o Algoritmo Completo",
                                  "subSteps": [
                                    "Estruture o algoritmo: Guess(S) seguido de Verify(S).",
                                    "Escreva o algoritmo completo em pseudocódigo não-determinístico.",
                                    "Analise complexidade: tempo O(n^k) determinístico equivalente, mas polinomial não-det (O(k^2)).",
                                    "Defina linguagens: L = { <G,k> | G tem clique de tamanho k }.",
                                    "Teste com grafo pequeno: implemente em código simples se possível."
                                  ],
                                  "verification": "Produza o pseudocódigo final e prove que aceita/rejeita corretamente um exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Template de algoritmo não-det",
                                    "Ferramenta de grafos para teste"
                                  ],
                                  "tips": "Use notação NPM para formalidade.",
                                  "learningObjective": "Integrar adivinhação e verificação em um NTM completo.",
                                  "commonMistakes": [
                                    "Misturar fases",
                                    "Esquecer análise de complexidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar o Algoritmo",
                                  "subSteps": [
                                    "Crie 3 grafos de teste: um com clique-k, um sem, um edge-case (k=1 ou k=n).",
                                    "Simule execuções não-determinísticas manualmente.",
                                    "Implemente uma versão determinística brute-force para comparar.",
                                    "Documente saídas e ramos aceitadores.",
                                    "Refine com base em erros encontrados."
                                  ],
                                  "verification": "Registre testes em tabela: input, expected, actual.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Grafos de teste prontos",
                                    "Simulador ou código Python"
                                  ],
                                  "tips": "Comece com grafos pequenos (n<=5) para simulação manual.",
                                  "learningObjective": "Validar corretude e soundess do algoritmo.",
                                  "commonMistakes": [
                                    "Ignorar casos k=0 ou grafo vazio",
                                    "Não testar rejeições"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um grafo G com vértices {1,2,3,4} e arestas {(1,2),(2,3),(3,1),(1,4)}, k=3: Adivinhe S={1,2,3} → Verifique pares (1-2,1-3,2-3) todos existem → Aceite. Para S={1,2,4}: Falta (2-4) → Rejeite.",
                              "finalVerifications": [
                                "Pseudocódigo completo descreve adivinhação e verificação corretamente.",
                                "Análise de complexidade mostra tempo polinomial na verificação.",
                                "Testes com 3 grafos diferentes produzem resultados corretos.",
                                "Explicação clara da diferença entre Guess e Verify.",
                                "Identificação de pelo menos 2 problemas NP-completos similares."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 30% (definições corretas de não-determinismo e clique).",
                                "Qualidade do pseudocódigo: 25% (claro, completo, sem erros lógicos).",
                                "Análise de complexidade: 20% (correta e justificada).",
                                "Testes e validação: 15% (cobertura de casos).",
                                "Documentação e clareza: 10% (fácil de seguir)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos e Combinatória (combinações C(n,k)).",
                                "Lógica: Prova por contradição em verificações.",
                                "Física: Modelagem de redes (ex: partículas conectadas).",
                                "Engenharia de Software: Verificação de propriedades em grafos de dependências."
                              ],
                              "realWorldApplication": "Em bioinformática, verificar cliques em grafos de interação proteica para módulos funcionais; em redes sociais, detectar grupos densos de amigos; otimização em design de circuitos VLSI."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.2.4",
                            "name": "Analisar equivalência com algoritmos determinísticos",
                            "description": "Discutir que qualquer MTND pode ser simulada por uma MTD com overhead exponencial, destacando a potência aparente da não-determinística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Máquinas de Turing Determinísticas e Não-Determinísticas",
                                  "subSteps": [
                                    "Defina formalmente uma Máquina de Turing Determinística (MTD): componentes como estados, fita, cabeçote e função de transição única.",
                                    "Defina uma Máquina de Turing Não-Determinística (MTND): destaque a função de transição que permite múltiplas transições simultâneas.",
                                    "Compare as diferenças chave: determinismo vs. não-determinismo em termos de branches de computação.",
                                    "Estude exemplos simples: uma MTD somando dois números vs. uma MTND 'adivinhando' uma solução.",
                                    "Identifique classes de problemas resolvíveis por cada: P para MTD em tempo polinomial, NP para MTND."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre MTD e MTND, incluindo um diagrama de transição.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Slides ou vídeo sobre Máquinas de Turing",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use diagramas de estados para visualizar as transições múltiplas da MTND.",
                                  "learningObjective": "Compreender as definições formais e diferenças operacionais entre MTD e MTND.",
                                  "commonMistakes": "Confundir não-determinismo com aleatoriedade; lembre-se que MTND explora todos os caminhos em paralelo conceitualmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Mecanismo de Simulação de MTND por MTD",
                                  "subSteps": [
                                    "Aprenda o algoritmo de simulação: MTD constrói uma árvore de computação onde cada nó representa um configuração da MTND.",
                                    "Descreva o uso de BFS (Busca em Largura): MTD simula camadas de branches não-determinísticos nivel por nivel.",
                                    "Detalhe a codificação: representar múltiplas fitas ou estados compostos para rastrear todas as configurações possíveis.",
                                    "Implemente pseudocódigo para a simulação: inicializar fila com configuração inicial, expandir branches até aceitar ou rejeitar.",
                                    "Simule manualmente um passo: de uma configuração inicial com 2 branches, mostre como MTD gera 2 configurações filhas."
                                  ],
                                  "verification": "Desenhe a árvore de computação para uma MTND simples com 3 passos e verifique se todas as branches são exploradas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Pseudocódigo template para simulação",
                                    "Ferramenta de desenho como Draw.io",
                                    "Exemplo de MTND para problema de aceitação simples"
                                  ],
                                  "tips": "Pense na MTD como um 'simulador universal' que mantém uma fila de todos os caminhos possíveis da MTND.",
                                  "learningObjective": "Dominar o algoritmo de simulação que prova a equivalência de poder computacional.",
                                  "commonMistakes": "Ignorar o gerenciamento da fita para configurações múltiplas; sempre codifique configurações como tuplas (estado, posição, conteúdo)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Overhead Exponencial da Simulação",
                                  "subSteps": [
                                    "Calcule o número de configurações: se MTND tem b branches por passo e d passos, árvore tem até b^d folhas.",
                                    "Demonstre o tempo de simulação: O(t) = O(2^{|q| * n}) onde |q| é estados e n é tamanho da entrada.",
                                    "Compare tempos: MTND resolve em tempo polinomial aparente, mas MTD requer exponencial para simular.",
                                    "Discuta espaço: MTD precisa de espaço logarítmico extra para fila, mas tempo domina.",
                                    "Grafique o crescimento: plote tempo vs. profundidade para b=2, mostrando explosão exponencial.",
                                    "Relacione com classes P vs. NP: simulação explica por que NP ⊆ EXP."
                                  ],
                                  "verification": "Compute e explique o overhead para uma MTND com 2 branches e 10 passos de profundidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora ou Python para simulações numéricas",
                                    "Gráficos de crescimento exponencial",
                                    "Referência sobre classes de complexidade"
                                  ],
                                  "tips": "Use notação big-O para formalizar; foque no pior caso onde todas branches são exploradas.",
                                  "learningObjective": "Quantificar matematicamente o custo da simulação e suas implicações.",
                                  "commonMistakes": "Subestimar branches; conte todas as transições possíveis, não só as 'úteis'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir a Potência Aparente da Não-Determinística e Implicações",
                                  "subSteps": [
                                    "Explique 'potência aparente': MTND parece mais poderosa por 'adivinhação paralela', mas é simulável.",
                                    "Dê exemplos de problemas NP: SAT, onde MTND verifica certificado em tempo polinomial.",
                                    "Debata implicações: P=NP? Se sim, overhead colapsa; caso contrário, útil para modelagem.",
                                    "Compare com paralelismo real: MTND modela computação massivamente paralela teórica.",
                                    "Aplique a otimização: algoritmos não-determinísticos inspiram heurísticas como branch-and-bound.",
                                    "Conclua equivalência: ambas reconhecem linguagens recursivamente enumeráveis."
                                  ],
                                  "verification": "Escreva um parágrafo discutindo por que MTND parece mais potente apesar da equivalência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos sobre P vs NP",
                                    "Exemplos de problemas NP-completos",
                                    "Fórum ou vídeo debate sobre equivalência"
                                  ],
                                  "tips": "Ligue à intuição: não-determinismo é como 'tentativa e erro' infinita em paralelo.",
                                  "learningObjective": "Interpretar teoricamente a equivalência e destacar sutilezas conceituais.",
                                  "commonMistakes": "Achar MTND mais poderosa; reforce que é só mais eficiente em tempo, não em poder."
                                }
                              ],
                              "practicalExample": "Considere uma MTND para o problema SAT (satisfatibilidade booleana): ela não-determinísticamente atribui valores às variáveis e verifica cláusulas em tempo linear. Simule com MTD usando BFS na árvore de 2^n atribuições possíveis (n variáveis), demonstrando overhead exponencial ao enumerar todas as combinações até achar uma satisfatória.",
                              "finalVerifications": [
                                "Explique o algoritmo de simulação BFS para MTND em MTD.",
                                "Calcule overhead para uma MTND com branching factor 2 e profundidade 20.",
                                "Descreva um exemplo onde MTND aceita em 1 passo, mas MTD leva 2^20 passos.",
                                "Discuta implicações para P vs. NP.",
                                "Compare poder computacional total: ambas decidem RE.",
                                "Identifique limitações da simulação em termos de tempo prático."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição formal da simulação (BFS e codificação de configurações).",
                                "Correção no cálculo do overhead exponencial com notação big-O.",
                                "Profundidade na discussão de potência aparente vs. equivalência real.",
                                "Uso de exemplos concretos e diagramas claros.",
                                "Conexão com classes de complexidade (P, NP, EXP).",
                                "Capacidade de identificar erros comuns na simulação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (árvores de computação como grafos de busca).",
                                "Matemática: Análise Assintótica (funções exponenciais e recorrências).",
                                "Filosofia: Lógica e Paradoxos (poder computacional e decidibilidade).",
                                "Engenharia de Software: Algoritmos de Busca e Otimização (branch-and-bound).",
                                "Física: Computação Quântica (analogia com superposição não-determinística)."
                              ],
                              "realWorldApplication": "Em otimização combinatorial como roteamento de veículos ou escalonamento de tarefas, modelamos problemas NP como MTND para heurísticas; a simulação explica por que solvers exaustivos são inviáveis para instâncias grandes, guiando o uso de aproximações ou paralelismo em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.3",
                        "name": "Tempo Polinomial Não-Determinístico e Classe NP",
                        "description": "Medida de complexidade onde um problema é resolvido por MTND em tempo polinomial, definindo a classe NP de problemas com soluções verificáveis em tempo polinomial.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.3.1",
                            "name": "Definir tempo polinomial não-determinístico",
                            "description": "Explicar que o tempo de uma MTND é o comprimento máximo do menor caminho de aceitação sobre todas as ramificações possíveis para uma entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Máquinas de Turing Não-Determinísticas (MTND)",
                                  "subSteps": [
                                    "Estude a definição formal de uma MTND: conjunto de estados, alfabeto, função de transição não-determinística, estado inicial, estados de aceitação e rejeição.",
                                    "Entenda como uma MTND computa: em cada passo, pode ramificar em múltiplas transições possíveis.",
                                    "Compare MTND com MTD (determinística): MTND aceita se existe pelo menos um caminho de aceitação.",
                                    "Visualize com diagrama: desenhe uma MTND simples com ramificações para uma entrada curta.",
                                    "Pratique traçando execuções ramificadas para uma entrada de exemplo."
                                  ],
                                  "verification": "Desenhe e explique uma execução ramificada de uma MTND simples, identificando caminhos de aceitação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser), papel e caneta para diagramas, vídeo tutorial sobre MTND.",
                                  "tips": "Use setas duplas para ramificações não-determinísticas nos diagramas para clareza visual.",
                                  "learningObjective": "Compreender o comportamento não-determinístico de MTND e suas ramificações.",
                                  "commonMistakes": "Confundir aceitação (existe caminho) com rejeição (todos os caminhos rejeitam); assumir determinismo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Conceito de Tempo de Computação em MTND",
                                  "subSteps": [
                                    "Defina o comprimento de uma computação: número de passos em um caminho específico de configuração.",
                                    "Identifique o menor caminho de aceitação: o caminho aceitador com o menor número de passos para uma dada entrada.",
                                    "Explique o tempo de uma MTND para uma entrada w: máximo, sobre todas as entradas de tamanho |w|, do comprimento do menor caminho de aceitação.",
                                    "Diferencie tempo de aceitação vs. tempo de rejeição: foco em aceitação para classe NP.",
                                    "Calcule exemplos: para uma MTND que aceita strings pares, encontre tempos para entradas pequenas."
                                  ],
                                  "verification": "Calcule o tempo de uma MTND simples para entradas de tamanho 1, 2 e 3, justificando o máximo do menor caminho.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador de MTND online (ex: JFLAP), exemplos de exercícios de complexidade.",
                                  "tips": "Sempre considere 'o pior caso' entre as entradas, e 'o melhor caso' entre os caminhos para cada entrada.",
                                  "learningObjective": "Dominar a medida de tempo em MTND via menor caminho de aceitação.",
                                  "commonMistakes": "Usar o caminho mais longo em vez do menor para aceitação; ignorar o máximo sobre entradas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Tempo Polinomial Não-Determinístico",
                                  "subSteps": [
                                    "Estabeleça que uma MTND roda em tempo polinomial se existe um polinômio p tal que tempo(M, w) ≤ p(|w|) para todo w.",
                                    "Formalize: tempo polinomial não-determinístico é O(n^k) para algum k constante.",
                                    "Relacione com classe NP: L em NP se existe MTND que aceita L em tempo polinomial.",
                                    "Escreva a definição precisa: 'O tempo de uma MTND é o comprimento máximo do menor caminho de aceitação sobre todas as ramificações possíveis para uma entrada.'",
                                    "Pratique reescrevendo a definição em suas palavras e comparando com fontes padrão."
                                  ],
                                  "verification": "Escreva a definição formal e explique com um exemplo onde tempo é O(n^2).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Referência: 'Introduction to the Theory of Computation' de Sipser (Capítulo NP), notas pessoais.",
                                  "tips": "Memorize a frase chave: 'máximo do menor caminho de aceitação' para evitar confusões.",
                                  "learningObjective": "Articular precisamente a definição de tempo polinomial não-determinístico.",
                                  "commonMistakes": "Confundir com tempo determinístico (maior caminho); omitir 'menor' ou 'máximo'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar a Definição no Contexto da Classe NP",
                                  "subSteps": [
                                    "Exemplo: MTND para SAT (satisfatibilidade booleana) adivinha atribuição e verifica em tempo polinomial.",
                                    "Prove que SAT está em NP: tempo é polinomial no tamanho da fórmula.",
                                    "Discuta implicações: por que não-determinismo 'adivinha' soluções eficientemente.",
                                    "Compare com P: se P=NP, MTND simulável em tempo polinomial determinístico.",
                                    "Resolva exercício: classifique uma linguagem como NP via tempo polinomial não-det."
                                  ],
                                  "verification": "Classifique uma linguagem simples (ex: Clique) como NP, justificando o tempo da MTND.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exercícios de complexidade NP-completos, software para grafos (ex: NetworkX).",
                                  "tips": "Pense em 'certificados' curtos verificáveis: essência do tempo polinomial em NP.",
                                  "learningObjective": "Conectar definição de tempo polinomial não-det com classe NP.",
                                  "commonMistakes": "Achar que NP inclui problemas intratáveis; ignorar que tempo é só para aceitação."
                                }
                              ],
                              "practicalExample": "Considere uma MTND para o problema Clique: para grafo G e k, adivinha k vértices, verifica se formam clique (todas arestas presentes). O menor caminho de aceitação tem O(n^2) passos (verificação), máximo sobre grafos é polinomial, logo Clique em NP.",
                              "finalVerifications": [
                                "Explica corretamente que tempo é 'máximo do menor caminho de aceitação'.",
                                "Calcula tempo para MTND simples com ramificações.",
                                "Distingue tempo não-det de det e relaciona com NP.",
                                "Formaliza definição matemática precisa.",
                                "Identifica exemplos de problemas em tempo polinomial não-det.",
                                "Discute por que 'polinomial' é relativo ao tamanho da entrada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: inclui 'menor caminho' e 'máximo sobre entradas'.",
                                "Compreensão conceitual: diferencia ramificações e aceitação.",
                                "Uso de exemplos: aplica a problemas reais como SAT ou Clique.",
                                "Formalismo: usa notação O(n^k) corretamente.",
                                "Clareza explicativa: evita jargões sem definição.",
                                "Conexão com NP: explica relação com verificadores polinomiais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (problemas NP como Clique, Hamiltoniano).",
                                "Lógica: Fórmulas booleanas e satisfatibilidade (SAT).",
                                "Filosofia: Questão P vs NP e limites da computação.",
                                "Engenharia de Software: Otimização e heurísticas para NP-difíceis."
                              ],
                              "realWorldApplication": "Em otimização logística (roteamento de veículos NP-difícil), modela-se como NP usando MTND para 'adivinhar' rotas ótimas, verificando em tempo polinomial; inspira algoritmos genéticos e IA para soluções aproximadas em scheduling, criptografia e planejamento."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.3.2",
                            "name": "Relacionar algoritmos não-determinísticos à classe NP",
                            "description": "Demonstrar que problemas com algoritmos não-determinísticos em tempo polinomial O(n^k) pertencem à classe NP, com exemplos como problemas da mochila e caixeiro viajante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Algoritmos e Máquinas Não-Determinísticas",
                                  "subSteps": [
                                    "Estude a definição formal de Máquina de Turing Não-Determinística (NDTM), que permite múltiplas transições simultâneas de um estado.",
                                    "Compare com Máquina de Turing Determinística (DTM), destacando que NDTM explora todos os caminhos possíveis em paralelo.",
                                    "Analise como o não-determinismo modela 'adivinhação' ou escolha ótima sem busca exaustiva.",
                                    "Simule um exemplo simples de NDTM aceitando uma linguagem regular.",
                                    "Discuta o conceito de tempo de execução em NDTM como o comprimento da menor cadeia de computação aceitadora."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a diferença entre NDTM e DTM, com um diagrama de transições.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 7)",
                                    "Vídeos Khan Academy ou YouTube sobre NDTM",
                                    "Simulador online de Máquinas de Turing"
                                  ],
                                  "tips": "Pense no não-determinismo como um 'demônio' que escolhe o caminho certo instantaneamente, sem custo extra no modelo teórico.",
                                  "learningObjective": "Diferenciar máquinas determinísticas e não-determinísticas e entender o papel do não-determinismo na teoria da computação.",
                                  "commonMistakes": [
                                    "Confundir não-determinismo com aleatoriedade (ND é 'adivinhação' determinística)",
                                    "Acreditar que NDTM executa mais devagar que DTM na prática"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Tempo Polinomial Não-Determinístico e Classe NP",
                                  "subSteps": [
                                    "Defina formalmente a classe DTIME(f(n)) e NTIME(f(n)), focando em NTIME(n^k) para k constante.",
                                    "Estude a definição de NP: conjunto de linguagens L onde existe uma NDTM que decide L em tempo O(n^k).",
                                    "Entenda o verificador polinomial: para x em L, existe certificado c (|c| polinomial) verificável em tempo polinomial por DTM.",
                                    "Prove que NP ⊆ NTIME(poly(n)) e discuta a relação bidirecional conceitual.",
                                    "Liste problemas conhecidos em NP, como aceitação por NDTM polinomial."
                                  ],
                                  "verification": "Escreva as definições formais de NTIME(n^k) e NP em notação matemática.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Notas de aula sobre complexidade (CLRS cap. 34)",
                                    "Artigo Wikipedia 'NP (complexity)' com referências",
                                    "Folha de anotações para fórmulas"
                                  ],
                                  "tips": "Lembre-se: NP significa 'Não-determinístico Polinomial'; foque no 'sim' com certificado rápido.",
                                  "learningObjective": "Definir precisamente NTIME polinomial e a classe NP usando máquinas de Turing.",
                                  "commonMistakes": [
                                    "Confundir NP com 'Não-Polynomial' (é polinomial não-determinístico)",
                                    "Ignorar o papel do certificado no verificador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Algoritmos Não-Determinísticos Polinomiais à Classe NP",
                                  "subSteps": [
                                    "Demonstre que se uma linguagem L tem NDTM decidindo em O(n^k), então L ∈ NP.",
                                    "Construa o verificador DTM: dado x e certificado (cadeia de computação aceitadora), simule a NDTM em tempo polinomial.",
                                    "Analise a complexidade: simulação de ramificação única leva O(n^k) tempo.",
                                    "Discuta por que isso prova L ∈ NP sem resolver P=NP.",
                                    "Exercite com pseudocódigo de um algoritmo ND-polynomial genérico."
                                  ],
                                  "verification": "Forneça uma prova curta (3-5 linhas) de que NTIME(n^k) ⊆ NP.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e caneta para provas",
                                    "Exemplos de provas em 'Computational Complexity' de Arora/Barak",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "A chave é o certificado ser a 'trilha' da computação ND aceitadora, verificável deterministicamente.",
                                  "learningObjective": "Provar formalmente a inclusão de problemas ND-polynomial em NP.",
                                  "commonMistakes": [
                                    "Esquecer que a simulação do certificado é determinística e polinomial",
                                    "Pensar que isso implica P=NP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Relação com Exemplos Clássicos",
                                  "subSteps": [
                                    "Analise o Problema da Mochila (Knapsack): NDTM 'adivinha' subconjunto e verifica soma em O(n).",
                                    "Estude o Caixeiro Viajante (TSP): NDTM gera permutação de cidades e verifica tour em O(n^2).",
                                    "Implemente simulações simples em Python para Knapsack ND.",
                                    "Compare com versões determinísticas exponenciais.",
                                    "Discuta implicações para problemas NP-completos."
                                  ],
                                  "verification": "Descreva algoritmos ND para Knapsack e TSP, mostrando tempo O(n^k).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python IDLE ou Jupyter Notebook",
                                    "Código exemplo de Knapsack/TSP em repositórios GitHub",
                                    "Gráficos para TSP"
                                  ],
                                  "tips": "Use 'força bruta paralela' mental para visualizar o ND em ação.",
                                  "learningObjective": "Ilustrar a relação teórica com problemas reais em NP.",
                                  "commonMistakes": [
                                    "Calcular tempo errado para verificação (é polinomial!)",
                                    "Confundir decisão (sim/não) com otimização"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o Problema da Mochila: Dada uma mochila de capacidade W e itens com pesos/pesos vi, uma NDTM em tempo O(n) não-determinísticamente escolhe um subconjunto S (certificado), verifica se soma(pesos S) ≤ W e soma(valores S) = ótimo. O verificador DTM checa isso em O(n) tempo, provando Knapsack ∈ NP.",
                              "finalVerifications": [
                                "Defina corretamente NP usando NDTM ou verificador.",
                                "Prove que um problema ND-polynomial pertence a NP.",
                                "Forneça exemplo de certificado para Knapsack.",
                                "Explique por que TSP está em NP.",
                                "Diferencie tempo de decisão ND vs. verificação DT.",
                                "Liste 3 problemas em NP."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (30%)",
                                "Correção da prova de relação ND-poly a NP (25%)",
                                "Qualidade e acurácia dos exemplos (20%)",
                                "Clareza na explicação de certificados e verificadores (15%)",
                                "Uso correto de notação assintótica O(n^k) (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (TSP como grafo completo)",
                                "Lógica: Provas existenciais e não-construtivas",
                                "Física: Otimização em simulações quânticas (análoga a ND)",
                                "Economia: Problemas de alocação ótima (Knapsack)"
                              ],
                              "realWorldApplication": "Em logística, TSP modela rotas de entrega eficientes; em criptografia, problemas NP como fatoração sustentam segurança (ex: RSA assume difícil resolver, mas fácil verificar); otimização em IA e supply chain usa heurísticas para problemas NP."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.3.3",
                            "name": "Comparar classes P e NP",
                            "description": "Comparar a classe P (resolvível deterministicamente em tempo polinomial) com NP (resolvível não-deterministicamente em tempo polinomial), destacando a questão aberta P=NP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição e Características da Classe P",
                                  "subSteps": [
                                    "Leia a definição formal: P é o conjunto de problemas de decisão resolvíveis por uma máquina de Turing determinística em tempo polinomial.",
                                    "Identifique exemplos clássicos como ordenação de listas ou busca binária.",
                                    "Entenda o significado de 'tempo polinomial': O(n^k) para constante k.",
                                    "Diferencie problemas em P de problemas intratáveis (exponenciais).",
                                    "Pratique identificando se um algoritmo roda em tempo polinomial."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição de P e dê 2 exemplos corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Algoritmos (ex: Cormen), máquina de Turing simulador online, notas de aula sobre complexidade"
                                  ],
                                  "tips": "Use notação big-O para quantificar tempos; foque em determinismo.",
                                  "learningObjective": "Compreender precisamente o que define a classe P e seus problemas resolvíveis eficientemente.",
                                  "commonMistakes": [
                                    "Confundir tempo polinomial com linear",
                                    "Ignorar o aspecto determinístico",
                                    "Achar que todos os problemas práticos estão em P"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Definição e Características da Classe NP",
                                  "subSteps": [
                                    "Defina NP: Problemas de decisão onde uma solução proposta pode ser verificada em tempo polinomial por uma máquina determinística.",
                                    "Estude máquinas de Turing não-determinísticas: 'adivinhação' em um passo.",
                                    "Aprenda sobre certificados: Provas curtas que validam 'sim' instances.",
                                    "Exemplos: Problema da Satisfatibilidade Booleana (SAT), Caixeiro Viajante (TSP).",
                                    "Compare verificação vs. resolução em NP."
                                  ],
                                  "verification": "Forneça um exemplo de problema NP e descreva como verificar uma solução em tempo polinomial.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Simulador de TM não-determinística online, exemplos de problemas NP-completos, vídeo sobre NP"
                                  ],
                                  "tips": "Pense em 'NP' como 'Non-deterministic Polynomial time'; foque na verificação rápida.",
                                  "learningObjective": "Dominar a noção de verifiabilidade polinomial e não-determinismo em NP.",
                                  "commonMistakes": [
                                    "Confundir NP com 'não polinomial'",
                                    "Achar que NP é só para problemas difíceis de resolver",
                                    "Ignorar que P ⊆ NP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diretamente as Classes P e NP",
                                  "subSteps": [
                                    "Liste semelhanças: Ambos envolvem tempo polinomial (resolução para P, verificação para NP).",
                                    "Destaque diferenças: P é resolvível deterministicamente; NP permite não-determinismo.",
                                    "Discuta inclusão: P ⊆ NP (todo problema P é NP).",
                                    "Crie uma tabela comparativa: tempo, máquina, exemplos.",
                                    "Analise implicações: Se P=NP, então todos NP resolvíveis eficientemente."
                                  ],
                                  "verification": "Crie e explique uma tabela comparativa precisa entre P e NP.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela, diagramas de Venn de complexidade"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar P dentro de NP.",
                                  "learningObjective": "Identificar e articular diferenças e relações entre P e NP.",
                                  "commonMistakes": [
                                    "Achar que NP está fora de P sem prova",
                                    "Confundir NP-completo com NP",
                                    "Subestimar a verificação em NP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a Questão Aberta P=NP e Suas Implicações",
                                  "subSteps": [
                                    "Explique o problema P=NP: Existe algoritmo determinístico polinomial para todo NP?",
                                    "Discuta status: Aberto desde 1971 (Cook, Levin); prêmio de US$1M.",
                                    "Explore consequências: Se P=NP, criptografia quebra; otimização fácil.",
                                    "Se NP≠P, hierarquia de complexidade.",
                                    "Pesquise opiniões de experts (a maioria crê NP≠P)."
                                  ],
                                  "verification": "Resuma em parágrafo as implicações se P=NP ou não.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Página da Clay Mathematics Institute sobre P=NP, artigos introdutórios"
                                  ],
                                  "tips": "Conecte a problemas reais como criptografia RSA.",
                                  "learningObjective": "Compreender a importância e o status aberto da questão P=NP.",
                                  "commonMistakes": [
                                    "Achar que P=NP foi provado",
                                    "Ignorar impactos práticos",
                                    "Confundir com NP-completo sem contexto"
                                  ]
                                }
                              ],
                              "practicalExample": "Compare o problema de ordenação de números (em P: algoritmo Merge Sort O(n log n)) com o Problema da Satisfatibilidade (SAT, em NP): solução pode ser verificada plugando valores em fórmulas booleanas em tempo polinomial, mas resolução é dura.",
                              "finalVerifications": [
                                "Defina corretamente P e NP com exemplos.",
                                "Explique por que P ⊆ NP.",
                                "Descreva diferenças chave em uma frase.",
                                "Discuta uma implicação da resolução de P=NP.",
                                "Identifique um problema em P e um em NP\\P (presumido)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (máx. 30%)",
                                "Clareza na comparação e tabela (25%)",
                                "Compreensão de não-determinismo e verificação (20%)",
                                "Análise de implicações de P=NP (15%)",
                                "Uso correto de exemplos e contra-exemplos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Lógica Proposicional",
                                "Filosofia: Limites do Conhecimento e Decidibilidade",
                                "Engenharia: Otimização e Design de Algoritmos",
                                "Economia: Problemas de Otimização em Recursos"
                              ],
                              "realWorldApplication": "Em criptografia (ex: RSA assume NP≠P para segurança), otimização logística (TSP aproximado pois em NP), IA (aprendizado de máquina luta com problemas NP-difíceis), e prova de teoremas automatizada."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.3",
                    "name": "Classe NP",
                    "description": "Conjunto de problemas de decisão verificáveis em tempo polinomial por uma máquina de Turing determinística.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.3.1",
                        "name": "Máquinas de Turing Não-Determinísticas (MTND)",
                        "description": "Modelos computacionais que permitem múltiplas transições simultâneas a partir de um estado, representando não-determinismo, e sua relação com a classe NP.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.1.1",
                            "name": "Definir formalmente uma MTND",
                            "description": "Explicar a estrutura de uma Máquina de Turing Não-Determinística, incluindo conjunto de estados, alfabeto, função de transição que pode gerar múltiplas possibilidades, fita, cabeçote e configurações de aceitação/rejeição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes comuns de Máquinas de Turing",
                                  "subSteps": [
                                    "Identifique o conjunto de estados Q, que inclui todos os estados possíveis da máquina.",
                                    "Defina o alfabeto de entrada Σ como o conjunto de símbolos válidos na entrada.",
                                    "Explique o alfabeto da fita Γ, que inclui Σ, o símbolo em branco B e possivelmente outros símbolos auxiliares.",
                                    "Descreva o cabeçote, que lê/escreve um símbolo por vez e move-se para Esquerda (L) ou Direita (R).",
                                    "Identifique o estado inicial q0 ∈ Q."
                                  ],
                                  "verification": "Liste corretamente Q, Σ, Γ, B, q0 e suas propriedades em um diagrama ou tabela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência: Livro de Teoria da Computação (Sipser ou similar)"
                                  ],
                                  "tips": "Use notação de conjuntos para precisão; lembre-se que Γ ⊇ Σ ∪ {B}.",
                                  "learningObjective": "Dominar os elementos compartilhados entre MT e MTND.",
                                  "commonMistakes": [
                                    "Confundir Σ com Γ",
                                    "Esquecer que B é especial e não em Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a função de transição não-determinística",
                                  "subSteps": [
                                    "Compare a transição determinística δ: Q × Γ → Q × Γ × {L, R} com a não-determinística.",
                                    "Defina δ como uma relação: δ ⊆ Q × Γ × P(Q × Γ × {L, R}), onde P é o conjunto potências.",
                                    "Explique que para uma configuração (q, símbolo), δ pode mapear para múltiplas transições simultâneas.",
                                    "Ilustre com exemplo: δ(q0, a) = {(q1, b, R), (q2, c, L)}.",
                                    "Discuta o conceito de 'não-determinismo' como escolha paralela de caminhos."
                                  ],
                                  "verification": "Escreva a definição formal de δ e dê um exemplo com múltiplas saídas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto para fórmulas",
                                    "Ferramenta de desenho para diagramas de transição"
                                  ],
                                  "tips": "Pense em δ como um conjunto de regras possíveis, não uma função única.",
                                  "learningObjective": "Diferenciar e formalizar o coração da MTND: a transição múltipla.",
                                  "commonMistakes": [
                                    "Tratar δ como função em vez de relação",
                                    "Ignorar o poder das potências P"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir configurações de aceitação e rejeição",
                                  "subSteps": [
                                    "Defina o conjunto de estados de aceitação F ⊆ Q.",
                                    "Explique estados de rejeição R ⊆ Q (opcional, mas comum).",
                                    "Descreva uma configuração como <q, w> onde q é estado e w é conteúdo da fita com cabeçote marcado.",
                                    "Detalhe o processo: máquina aceita se atinge q ∈ F; rejeita se q ∈ R ou loop infinito.",
                                    "Esclareça que em MTND, aceita se QUALQUER caminho leva a F."
                                  ],
                                  "verification": "Descreva formalmente como uma entrada é aceita/rejeitada em MTND.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para simular configurações",
                                    "Exemplos de livros de teoria da computação"
                                  ],
                                  "tips": "Lembre: aceitação é existencial (existe caminho), não universal.",
                                  "learningObjective": "Compreender os critérios de decisão em MTND.",
                                  "commonMistakes": [
                                    "Confundir aceitação existencial com determinística",
                                    "Esquecer loops infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a definição formal completa de uma MTND",
                                  "subSteps": [
                                    "Escreva a tupla formal: M = (Q, Σ, Γ, δ, q0, B, F).",
                                    "Verifique que todos componentes atendem aos tipos corretos (ex: δ ⊆ Q × Γ × P(Q × Γ × {L,R})).",
                                    "Crie um exemplo mínimo de MTND.",
                                    "Compare com MT determinística.",
                                    "Teste a definição com uma linguagem simples."
                                  ],
                                  "verification": "Escreva a definição completa e valide com um peer ou auto-teste.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Simulador online de MT (opcional)"
                                  ],
                                  "tips": "Sempre especifique os tipos matemáticos exatos para formalidade.",
                                  "learningObjective": "Construir e validar a definição integral de MTND.",
                                  "commonMistakes": [
                                    "Omitir B ou F na tupla",
                                    "Erro na assinatura de δ"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina formalmente uma MTND que aceita linguagens com número par de 'a's: Q = {q0, q1, q_even, q_odd, q_accept}, Σ = {a}, Γ = {a, B}, δ inclui δ(q0, a) = {(q_even, B, R), (q_odd, B, R)}, etc., com F = {q_accept}. Simule entrada 'aa': dois caminhos, um aceita.",
                              "finalVerifications": [
                                "Escreva a tupla completa (Q, Σ, Γ, δ, q0, B, F) corretamente.",
                                "Explique δ com pelo menos duas transições múltiplas.",
                                "Diferencie aceitação em MT vs MTND.",
                                "Identifique todos os 7 componentes sem erros.",
                                "Simule uma configuração inicial para uma entrada dada.",
                                "Defina o que significa 'linguagem aceita por M'."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (tipos corretos de δ, etc.).",
                                "Completude: todos os 7 componentes incluídos.",
                                "Clareza na explicação de não-determinismo.",
                                "Correta distinção entre aceitação existencial e determinística.",
                                "Uso apropriado de exemplos para ilustrar conceitos.",
                                "Ausência de confusões com MT determinística."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Relações (P para potências).",
                                "Lógica: Quantificadores existenciais na aceitação.",
                                "Física: Modelos probabilísticos e superposição quântica (análoga).",
                                "Engenharia de Software: Modelagem de buscas paralelas em algoritmos."
                              ],
                              "realWorldApplication": "MTND modela problemas em classe NP, como planejamento de rotas otimizadas (ex: TSP aproximado), verificação de satisfação de cláusulas em SAT solvers e simulações paralelas em computação quântica ou otimização heurística em IA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.1.2",
                            "name": "Comparar MTND com Máquina de Turing Determinística (MTD)",
                            "description": "Identificar diferenças chave entre MTND e MTD, como ramificação de computações e simulação de não-determinismo por MTD em tempo exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Máquina de Turing Determinística (MTD)",
                                  "subSteps": [
                                    "Estude a definição formal de uma MTD: conjunto de estados Q, alfabeto de fita Γ, função de transição δ: Q × Γ → Q × Γ × {L, R}, estado inicial q0, estados de aceitação F.",
                                    "Desenhe um diagrama de uma MTD simples que reconhece uma linguagem regular, como {a^n b^n}.",
                                    "Simule manualmente 5 passos de execução em uma fita inicial específica.",
                                    "Identifique características chave: única computação linear, tempo polinomial para linguagens decidíveis.",
                                    "Anote como a MTD segue um caminho único sem ramificações."
                                  ],
                                  "verification": "Crie um diagrama de transição completo e simule corretamente uma entrada sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Referência: Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 3)"
                                  ],
                                  "tips": "Use setas coloridas para diferenciar movimentos da cabeça de leitura/escrita.",
                                  "learningObjective": "Compreender o funcionamento sequencial e determinístico de uma MTD.",
                                  "commonMistakes": [
                                    "Confundir função de transição com não-determinística (permitir múltiplas saídas)",
                                    "Ignorar o estado de rejeição implícito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Máquina de Turing Não-Determinística (MTND)",
                                  "subSteps": [
                                    "Defina formalmente uma MTND: δ: Q × Γ → finito subconjunto de Q × Γ × {L, R}.",
                                    "Desenhe um exemplo de MTND para linguagem {a^n b^n | n ≥ 0} com ramificações.",
                                    "Simule uma computação não-determinística, mostrando múltiplos caminhos possíveis.",
                                    "Explique aceitação: existe pelo menos um caminho que aceita.",
                                    "Compare visualmente com MTD: destaque ramificações em árvore de computação."
                                  ],
                                  "verification": "Desenhe a árvore de computação para uma entrada de tamanho 4 e identifique caminhos de aceitação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software de desenho como Draw.io",
                                    "Vídeo tutorial sobre MTND no YouTube (canal 'Computerphile')"
                                  ],
                                  "tips": "Pense na MTND como um 'adivinhador' que testa múltiplas hipóteses simultaneamente.",
                                  "learningObjective": "Dominar o conceito de não-determinismo e ramificação de computações.",
                                  "commonMistakes": [
                                    "Assumir que todos os caminhos devem aceitar",
                                    "Não representar adequadamente as múltiplas transições"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Chave entre MTND e MTD",
                                  "subSteps": [
                                    "Liste diferenças: determinismo vs. não-determinismo, caminho único vs. árvore de computações, tempo de execução.",
                                    "Crie uma tabela comparativa: colunas para MTD e MTND, linhas para poder computacional, tempo, simulação.",
                                    "Discuta impacto na classe P vs. NP: MTND resolve problemas NP em tempo polinomial.",
                                    "Analise exemplo concreto: SAT resolvido por MTND em P, mas MTD em exponencial.",
                                    "Debata se MTND é mais 'poderosa' (não em poder total, mas em tempo)."
                                  ],
                                  "verification": "Preencha tabela comparativa com pelo menos 5 diferenças precisas e justifique cada uma.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Google Sheets para tabela",
                                    "Artigo Wikipedia 'Nondeterministic Turing machine'"
                                  ],
                                  "tips": "Use bullet points para diferenças qualitativas e fórmulas O() para quantitativas.",
                                  "learningObjective": "Mapear diferenças estruturais e computacionais entre os modelos.",
                                  "commonMistakes": [
                                    "Afirmar que MTND decide mais linguagens que MTD",
                                    "Ignorar equivalência em poder recursivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender Simulação de MTND por MTD",
                                  "subSteps": [
                                    "Descreva o simulador padrão: MTD que gera árvore de computação da MTND via busca em largura.",
                                    "Calcule complexidade: se MTND roda em T(n), simulador usa O(2^T(n)) tempo/espaco.",
                                    "Implemente pseudocódigo para simulador simples.",
                                    "Simule um exemplo pequeno: entrada de 3 símbolos, mostre explosão exponencial.",
                                    "Conclua implicações para P=NP."
                                  ],
                                  "verification": "Escreva pseudocódigo funcional e calcule tempo para T(n)=n.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Ferramenta JFLAP para simulação de Turing"
                                  ],
                                  "tips": "Represente configuração como (estado, fita, posição) em pilha/fila.",
                                  "learningObjective": "Compreender equivalência via simulação e custo exponencial.",
                                  "commonMistakes": [
                                    "Subestimar branching factor como 1",
                                    "Confundir simulação com paralelismo real"
                                  ]
                                }
                              ],
                              "practicalExample": "Compare MTND e MTD para decidir se uma fórmula booleana 3-SAT é satisfatível: MTND 'adivinha' atribuição em O(n) passos; MTD testa todas 2^n em exponencial.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave sem hesitação.",
                                "Desenhar árvore de computação MTND vs. caminho linear MTD.",
                                "Calcular corretamente tempo de simulação para MTND com 10 passos.",
                                "Identificar que P ⊆ NP devido à simulação.",
                                "Discutir por que prova P=NP é aberta."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (80% correto).",
                                "Profundidade na análise de diferenças (cobertura de ramificação e tempo).",
                                "Correção no pseudocódigo de simulação.",
                                "Criatividade em exemplos práticos.",
                                "Compreensão de implicações para complexidade (P vs NP)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (árvore de computação como grafo).",
                                "Lógica: Equivalência entre não-determinismo e busca exaustiva.",
                                "Filosofia: Determinismo vs. Livre-arbítrio em computação.",
                                "Engenharia de Software: Backtracking em algoritmos como A*."
                              ],
                              "realWorldApplication": "Em verificadores de software (model checking), MTND modela explorações paralelas; simulação por MTD explica por que ferramentas como SPIN usam aproximações heurísticas para evitar explosão exponencial em hardware real."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.1.3",
                            "name": "Simular execução de uma MTND em problemas simples",
                            "description": "Executar manualmente o processo de aceitação de uma MTND para uma linguagem como {a^n b^n | n ≥ 0}, ilustrando ramificações e aceitação em tempo polinomial não-determinístico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e diagramar a MTND para a linguagem {a^n b^n | n ≥ 0}",
                                  "subSteps": [
                                    "Identifique os estados necessários: q0 (inicial), q1 (contando a's), q2 (contando b's), q_accept, q_reject.",
                                    "Defina a fita inicial com símbolo branco (B) nos extremos e a string de entrada no meio.",
                                    "Especifique transições não-determinísticas: de q0 lendo 'a', vá para q1 escrevendo X e movendo direita (adivinhando o primeiro a); ou mude para q2 se não houver mais a's.",
                                    "Inclua loops para marcar a's com X enquanto move direita, depois volte adivinhando quando terminar a's.",
                                    "Adicione transições para contar b's similarmente, comparando com a's marcados, aceitando se igual."
                                  ],
                                  "verification": "Desenhe o diagrama da MTND em papel ou ferramenta digital e confirme que reconhece strings como ε, ab, aabb, mas rejeita aa ou abb.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, ou software como Draw.io; referência teórica de MTND.",
                                  "tips": "Use setas duplas para transições não-determinísticas para visualizar ramificações.",
                                  "learningObjective": "Compreender a estrutura formal de uma MTND para linguagens context-free.",
                                  "commonMistakes": "Esquecer transições para rejeição ou não marcar símbolos corretamente na fita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar a configuração inicial e escolher string de teste",
                                  "subSteps": [
                                    "Escreva a string de entrada, ex: 'aabb', na fita: ...B a a b b B...",
                                    "Posicione a cabeça de leitura em q0 sobre o primeiro 'a'.",
                                    "Liste todas as transições possíveis do estado inicial para ilustrar não-determinismo.",
                                    "Defina convenções: use sublinhado para cabeça de leitura, liste configurações como (q, fita, posição).",
                                    "Prepare uma árvore de ramificações vazia para rastrear caminhos."
                                  ],
                                  "verification": "A configuração inicial está corretamente representada e a string é válida para a linguagem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado ou editor de texto para simular fita.",
                                  "tips": "Use cores diferentes para símbolos marcados (ex: X em vermelho) para clareza visual.",
                                  "learningObjective": "Configurar corretamente o ambiente de simulação de MTND.",
                                  "commonMistakes": "Posicionar a cabeça errada ou esquecer blanks nos extremos da fita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular ramificações não-determinísticas passo a passo",
                                  "subSteps": [
                                    "Do estado atual, liste e execute todas as transições possíveis, criando ramificações paralelas.",
                                    "Para cada ramificação, aplique regras: escreva símbolo, mude estado, mova cabeça (L/R).",
                                    "Continue até aceitação em uma ramificação ou rejeição em todas; pare se loop detectado.",
                                    "Registre 3-5 passos por ramificação principal, mostrando fita evoluindo.",
                                    "Ilustre adivinhação: uma ramificação 'adivinha' n=2 corretamente para 'aabb'."
                                  ],
                                  "verification": "Todas ramificações são rastreadas até aceitação ou rejeição, com pelo menos uma aceitando.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Árvore de decisão em papel ou ferramenta como Graphviz.",
                                  "tips": "Numere ramificações (ex: Path1, Path2) e limite profundidade para evitar explosão.",
                                  "learningObjective": "Executar simulação manual destacando poder não-determinístico.",
                                  "commonMistakes": "Confundir movimentos da cabeça ou ignorar transições não-determinísticas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar aceitação e tempo polinomial não-determinístico",
                                  "subSteps": [
                                    "Identifique a ramificação aceitadora e conte passos até q_accept.",
                                    "Compare com ramificações rejeitadoras, mostrando por que falham.",
                                    "Calcule comprimento máximo de ramificação: O(n^2) para n símbolos, polinomial.",
                                    "Discuta: MTND aceita se existe pelo menos um caminho aceitador curto.",
                                    "Resuma em tabela: passos, ramificações totais, tempo máximo."
                                  ],
                                  "verification": "Demonstre que aceitação ocorre em tempo polinomial e rejeição para strings inválidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha ou tabela para contagem de passos.",
                                  "tips": "Foquem em 'existe caminho aceitador' vs. verificar todos.",
                                  "learningObjective": "Relacionar simulação à definição de NP e tempo polinomial.",
                                  "commonMistakes": "Contar tempo determinístico em vez de não-determinístico (pior caso polinomial)."
                                }
                              ],
                              "practicalExample": "Para entrada 'aabb': Ramificação 1 rejeita após marcar um 'a' cedo; Ramificação 2 marca dois 'a's (XXbb), volta, marca dois 'b's (XXYY), aceita em ~10 passos, ilustrando adivinhação correta de n=2.",
                              "finalVerifications": [
                                "Diagrama da MTND cobre todos casos de {a^n b^n}.",
                                "Simulação manual mostra ramificações com uma aceitando 'aabb'.",
                                "String inválida como 'aab' é rejeitada em todas ramificações.",
                                "Tempo máximo por ramificação é polinomial em |w|.",
                                "Configurações de fita evoluem corretamente sem loops infinitos.",
                                "Explicação verbal da não-deterministicidade está clara."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de transições não-determinísticas (90% correto).",
                                "Correta simulação de pelo menos 3 ramificações com fitas atualizadas.",
                                "Identificação correta de aceitação/rejeição com justificativa.",
                                "Análise de complexidade temporal polinomial demonstrada.",
                                "Visualizações claras (diagramas, árvores) sem erros.",
                                "Compreensão conceitual via explicação em 2-3 frases."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Autômatos e linguagens formais.",
                                "Lógica: Ramificações como busca em árvores de decisão.",
                                "Programação: Modelagem em Python com recursão para simular MTND.",
                                "Inteligência Artificial: Busca não-determinística em jogos ou planejamento."
                              ],
                              "realWorldApplication": "Modela verificadores NP como SAT solvers em compiladores ou criptografia, onde 'adivinhar' uma prova curta (polinomial) valida soluções complexas, usado em otimização de rotas ou verificação de software."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.3.2",
                        "name": "Verificador Polinomial",
                        "description": "Máquina de Turing determinística que verifica uma solução proposta para um problema de decisão em tempo polinomial, definindo a essência da classe NP.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.2.1",
                            "name": "Explicar o conceito de verificador polinomial",
                            "description": "Descrever um verificador V como uma MTD que, dada uma instância x e um certificado y de tamanho polinomial em |x|, decide em tempo polinomial se y é uma prova válida para x na linguagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Linguagens e Máquinas de Turing",
                                  "subSteps": [
                                    "Defina uma linguagem formal como um subconjunto de strings reconhecíveis por uma máquina de Turing.",
                                    "Explique o que é uma instância x: uma string de entrada representando um problema específico.",
                                    "Descreva uma Máquina de Turing Determinística (MTD) e seu funcionamento básico.",
                                    "Discuta tempo de execução polinomial em relação ao tamanho da entrada |x|.",
                                    "Diferencie tempo polinomial de tempo exponencial com exemplos simples."
                                  ],
                                  "verification": "Escreva definições curtas para linguagem, instância e MTD, e calcule p(|x|) para um polinômio simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre teoria da computação, diagrama de Máquina de Turing.",
                                  "tips": "Use notação O(n^k) para visualizar polinômios; desenhe uma MTD simples.",
                                  "learningObjective": "Compreender os fundamentos necessários para verificadores.",
                                  "commonMistakes": "Confundir MTD com não-determinística; ignorar que polinomial é em |x|."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Certificado ou Prova",
                                  "subSteps": [
                                    "Defina certificado y como uma string curta (tamanho polinomial em |x|), como uma solução proposta.",
                                    "Explique que y serve como 'prova' de que x pertence à linguagem L.",
                                    "Discuta por que y deve ser polinomial: para eficiência na verificação.",
                                    "Dê exemplo: para SAT, y é uma atribuição de variáveis.",
                                    "Compare y com uma chave de criptografia que valida uma mensagem."
                                  ],
                                  "verification": "Crie um exemplo de x e y para uma linguagem simples como 'números primos'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de problemas NP-completos, papel e caneta para esboços.",
                                  "tips": "Sempre relacione y ao tamanho de x: |y| ≤ p(|x|) para algum polinômio p.",
                                  "learningObjective": "Entender o papel do certificado na verificação.",
                                  "commonMistakes": "Achar que y resolve o problema; esquecer limitação polinomial no tamanho."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente o Verificador Polinomial V",
                                  "subSteps": [
                                    "Descreva V como uma MTD que recebe (x, y) e aceita/rejeita em tempo polinomial.",
                                    "Especifique: V aceita se y é prova válida para x ∈ L; rejeita caso contrário.",
                                    "Formalize: Para todo x ∈ L, existe y com |y| ≤ p(|x|) tal que V(x,y)=1; para x ∉ L, todo y tem V(x,y)=0.",
                                    "Implemente pseudocódigo simples para V em um exemplo.",
                                    "Verifique completude e correção da definição."
                                  ],
                                  "verification": "Escreva a definição formal de V e teste com um par (x,y) fictício.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Livro de complexidade (ex: Sipser), editor de texto para pseudocódigo.",
                                  "tips": "Lembre: V é determinística e rápida; não resolve sozinha, só verifica.",
                                  "learningObjective": "Dominar a definição precisa de verificador polinomial.",
                                  "commonMistakes": "Omitir condições de completude ou soundess; confundir tempo de V com tempo para achar y."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Verificador com a Classe NP",
                                  "subSteps": [
                                    "Explique que L ∈ NP se existe V polinomial para L.",
                                    "Discuta por que NP é 'fácil de verificar, difícil de decidir'.",
                                    "Compare com P: em P, V(x, ε) basta (sem certificado).",
                                    "Analise implicações: NP contém problemas práticos com provas curtas.",
                                    "Resuma com diagrama: x → y → V → aceita/rejeita."
                                  ],
                                  "verification": "Classifique uma linguagem como NP usando sua V e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama de classes de complexidade, exemplos de linguagens NP.",
                                  "tips": "Pense em NP como 'non-deterministic polynomial time' via simulação por V.",
                                  "learningObjective": "Conectar verificadores à definição de NP.",
                                  "commonMistakes": "Achar NP = problemas difíceis; ignorar que P ⊆ NP."
                                }
                              ],
                              "practicalExample": "Para o problema SAT (satisfatibilidade booleana): x é uma fórmula booleana, y é uma atribuição de valores verdadeiros/falsos às variáveis. V(x,y) verifica em tempo polinomial se y satisfaz x substituindo e avaliando cláusulas.",
                              "finalVerifications": [
                                "Defina corretamente um verificador polinomial V(x,y).",
                                "Forneça exemplo de certificado y polinomial para x ∈ L.",
                                "Explique completude e soundess de V.",
                                "Diferencie V de uma máquina decisor para L.",
                                "Classifique uma linguagem em NP usando V.",
                                "Calcule tempo polinomial para um V simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de V e suas propriedades.",
                                "Correta relação entre tamanho de y e |x|.",
                                "Uso apropriado de tempo polinomial na análise.",
                                "Exemplos concretos e relevantes.",
                                "Compreensão clara de NP via verificadores.",
                                "Ausência de confusões com P ou classes exponenciais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e teoria dos conjuntos.",
                                "Filosofia: Conceitos de prova e verificabilidade.",
                                "Engenharia de Software: Verificação de testes automatizados.",
                                "Criptografia: Verificação de assinaturas digitais."
                              ],
                              "realWorldApplication": "Em compiladores, verificadores polinomiais validam otimizações com provas curtas; em blockchain, verificam transações/provas sem recalcular tudo; em IA, checam soluções candidatas para problemas NP-difíceis como planejamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.2.2",
                            "name": "Construir um verificador para um problema em NP",
                            "description": "Criar um algoritmo de verificador polinomial para o problema SAT (Satisfatibilidade Booleana), verificando se uma atribuição de variáveis satisfaz uma fórmula em forma normal conjuntiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema SAT e preparar a entrada do verificador",
                                  "subSteps": [
                                    "Estude a definição de SAT: fórmula em Forma Normal Conjuntiva (CNF) como conjunção de cláusulas, onde cada cláusula é disjunção de literais.",
                                    "Identifique os componentes de entrada: a fórmula CNF (lista de cláusulas) e uma atribuição de variáveis booleanas (dicionário ou array).",
                                    "Represente a fórmula em estrutura de dados: lista de listas, onde cada sublista é uma cláusula com literais (ex: [[1, -2, 3], [-1, 4]]).",
                                    "Defina a atribuição como um mapa de variável para booleano (ex: {1: true, 2: false}).",
                                    "Escreva pseudocódigo para parsing da entrada."
                                  ],
                                  "verification": "Crie um diagrama ou código que parse uma fórmula exemplo corretamente e imprima a estrutura.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de SAT, editor de código (Python recomendado), papel para diagramas.",
                                  "tips": "Use índices positivos para variáveis verdadeiras e negativos para negadas.",
                                  "learningObjective": "Entender a representação padrão de instâncias SAT para verificadores.",
                                  "commonMistakes": "Ignorar a negação de literais (sinal negativo) ou confundir cláusulas com literais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a verificação de uma única cláusula",
                                  "subSteps": [
                                    "Para uma cláusula, itere sobre cada literal nela.",
                                    "Para cada literal, verifique se é positivo ou negativo e avalie com a atribuição.",
                                    "Se o literal for positivo (ex: x_i = true) ou negativo (~x_i = false), a cláusula é satisfeita.",
                                    "Se nenhum literal satisfaz, a cláusula é falsa.",
                                    "Retorne true se pelo menos um literal for verdadeiro sob a atribuição."
                                  ],
                                  "verification": "Teste a função com cláusulas isoladas: uma satisfeita e uma não satisfeita.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código, exemplos de cláusulas manuais.",
                                  "tips": "Use uma função auxiliar para avaliar literal: abs(literal) pega a variável, sinal define negação.",
                                  "learningObjective": "Desenvolver lógica para avaliação semântica de cláusulas CNF.",
                                  "commonMistakes": "Esquecer de inverter o valor para literais negativos ou sair cedo sem verificar todos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a verificação completa da fórmula CNF",
                                  "subSteps": [
                                    "Itere sobre todas as cláusulas da fórmula.",
                                    "Para cada cláusula, chame a função de verificação de cláusula.",
                                    "Se todas as cláusulas forem verdadeiras, retorne true (fórmula satisfeita).",
                                    "Caso contrário, retorne false.",
                                    "Adicione tratamento de erros para entradas inválidas (ex: variáveis não atribuídas)."
                                  ],
                                  "verification": "Execute o verificador em uma fórmula completa com atribuição conhecida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código dos passos anteriores, testes unitários.",
                                  "tips": "Use loops aninhados eficientes: O(n*m) onde n=cláusulas, m=literais por cláusula.",
                                  "learningObjective": "Construir um verificador que cheque satisfatibilidade em tempo polinomial.",
                                  "commonMistakes": "Retornar true prematuramente sem verificar todas as cláusulas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, validar e analisar a complexidade do verificador",
                                  "subSteps": [
                                    "Crie casos de teste: fórmula satisfeita, insatisfazível, fórmulas vazias ou unitárias.",
                                    "Meça o tempo de execução em instâncias crescentes para confirmar polinomialidade.",
                                    "Analise complexidade: O(|C| * |L|) onde |C| é número de cláusulas e |L| literais médios.",
                                    "Documente o código com comentários sobre por que é em NP.",
                                    "Compare com brute-force para destacar eficiência."
                                  ],
                                  "verification": "Todos os testes passam e análise de complexidade documentada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramentas de profiling (timeit em Python), gerador de instâncias SAT.",
                                  "tips": "Use asserts para testes automatizados.",
                                  "learningObjective": "Validar que o algoritmo é um verificador polinomial correto para SAT.",
                                  "commonMistakes": "Usar recursão desnecessária ou estruturas ineficientes que levam a exponencial."
                                }
                              ],
                              "practicalExample": "Fórmula CNF: (x1 / ~x2) ^ (~x1 / x2). Atribuição: {1: true, 2: false}. Verificação: Primeira cláusula (true / ~false = true / true = true), segunda (~true / false = false / false = false) → Fórmula falsa. Implemente e rode o verificador para confirmar.",
                              "finalVerifications": [
                                "O verificador retorna true apenas se todas cláusulas são satisfeitas.",
                                "Executa em tempo polinomial (linear no tamanho da fórmula).",
                                "Lida corretamente com literais positivos e negativos.",
                                "Passa em testes com 10+ instâncias variadas.",
                                "Código é legível e comentado.",
                                "Análise de complexidade confirma classe NP."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: 30% (testes passam sem erros).",
                                "Eficiência polinomial: 20% (análise e medições).",
                                "Estrutura de código: 20% (modular, com funções auxiliares).",
                                "Tratamento de edge cases: 15% (fórmulas vazias, unitárias).",
                                "Documentação e análise: 15% (complexidade e justificativa NP)."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Proposicional (Matemática): Avaliação de fórmulas booleanas.",
                                "Programação Algorítmica: Loops e estruturas de dados.",
                                "Teoria da Computação: Máquinas de Turing e reduzibilidades.",
                                "Inteligência Artificial: Solvers SAT em planejamento.",
                                "Matemática Discreta: Conjuntos e satisfatibilidade."
                              ],
                              "realWorldApplication": "Verificadores SAT são usados em ferramentas como MiniSat para otimização combinatória, verificação de hardware (circuitos lógicos), planejamento de IA (ex: robótica), e resolução de problemas em bioinformática como alinhamento de sequências."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.2.3",
                            "name": "Analisar tempo de execução do verificador",
                            "description": "Calcular a complexidade temporal de um verificador, garantindo que seja O(n^k) para algum k constante, onde n é o tamanho da entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Verificador e Definir a Entrada",
                                  "subSteps": [
                                    "Leia a descrição completa do problema NP e o pseudocódigo do verificador.",
                                    "Identifique todos os parâmetros de entrada: instância do problema e certificado.",
                                    "Defina n como o tamanho total da entrada (tamanho da instância + tamanho do certificado).",
                                    "Documente os tipos de dados e estruturas usadas (ex: arrays, grafos)."
                                  ],
                                  "verification": "Lista clara e documentada dos componentes da entrada com n explicitamente definido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo do verificador",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Sempre inclua o certificado no cálculo de n, pois ele é parte essencial da entrada.",
                                  "learningObjective": "Entender precisamente o escopo da entrada para análise de complexidade temporal.",
                                  "commonMistakes": [
                                    "Ignorar o certificado e usar apenas tamanho da instância",
                                    "Confundir bits de entrada com elementos lógicos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor o Verificador em Operações Primitivas",
                                  "subSteps": [
                                    "Divida o pseudocódigo em blocos lineares: atribuições, condicionais e chamadas de funções básicas.",
                                    "Classifique cada operação primitiva: O(1) para acessos a arrays, comparações; O(n) para varreduras lineares.",
                                    "Liste todas as operações não-triviais e ignore constantes multiplicativas inicialmente.",
                                    "Crie uma tabela resumindo operações e suas complexidades base."
                                  ],
                                  "verification": "Tabela completa de operações com complexidades primitivas associadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo impresso ou digital",
                                    "Planilha (Excel/Google Sheets) ou papel quadriculado"
                                  ],
                                  "tips": "Considere o modelo RAM: acessos a memória são O(1), mas varreduras não.",
                                  "learningObjective": "Mapear instruções de alto nível para custos computacionais primitivos.",
                                  "commonMistakes": [
                                    "Tratar operações compostas (ex: sort) como O(1)",
                                    "Esquecer custos de estruturas de dados como listas ligadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Loops, Condicionais e Dependências",
                                  "subSteps": [
                                    "Identifique loops for/while e seus limites superiores em termos de n (ex: for i=1 to n).",
                                    "Calcule complexidade de loops aninhados multiplicando (ex: O(n^2) para dois loops).",
                                    "Avalie ramos condicionais: pegue o pior caso ou some se balanceados.",
                                    "Desenhe um diagrama de fluxo de controle anotado com complexidades por seção."
                                  ],
                                  "verification": "Diagrama de fluxo com complexidades calculadas para cada loop e ramo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io ou papel)",
                                    "Calculadora para potências"
                                  ],
                                  "tips": "Use a regra: complexidade de loop = iterações * corpo; assuma pior caso para upper bound.",
                                  "learningObjective": "Dominar análise de estruturas de controle em algoritmos.",
                                  "commonMistakes": [
                                    "Assumir todos loops são O(n) independentemente do limite",
                                    "Ignorar recursão implícita em chamadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Complexidade Total e Verificar Polinomialidade",
                                  "subSteps": [
                                    "Some complexidades de todos os blocos: domine pelo termo de maior ordem.",
                                    "Expresse como O(n^k) onde k é o expoente dominante (ex: O(n^3) se cubos dominam).",
                                    "Verifique se k é constante (fixo, não função de n ou parâmetros variáveis).",
                                    "Teste com valores pequenos de n para validar numericamente."
                                  ],
                                  "verification": "Equação final T(n) = O(n^k) com k explícito e justificativa passo a passo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resultados dos passos 1-3",
                                    "Calculadora ou Python para testes numéricos"
                                  ],
                                  "tips": "Lembre: polinomial requer k constante; exponencial como 2^n falha.",
                                  "learningObjective": "Concluir análise assintótica confirmando propriedade polinomial.",
                                  "commonMistakes": [
                                    "Somar expoentes em vez de multiplicar em aninhados",
                                    "Aceitar k log n como polinomial"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar Análise e Realizar Verificações Finais",
                                  "subSteps": [
                                    "Escreva relatório resumido: entrada, decomposição, cálculo e conclusão.",
                                    "Inclua exemplo numérico: para n=10, estime operações totais.",
                                    "Compare com verificadores não-polinomiais para contraste.",
                                    "Revise por omissões ou erros aritméticos."
                                  ],
                                  "verification": "Relatório completo com análise, exemplo numérico e confirmação O(n^k).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Template de relatório",
                                    "Exemplos de problemas NP"
                                  ],
                                  "tips": "Use notação matemática clara: ∑ ou max para somas.",
                                  "learningObjective": "Comunicar análise de complexidade de forma profissional.",
                                  "commonMistakes": [
                                    "Pular justificativa para saltos assintóticos",
                                    "Não testar com n pequeno"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema Subset Sum (NP-completo): instância = lista de m inteiros S[1..m], target t; certificado = vetor booleano B[1..m] de tamanho m, n ≈ 2m. Verificador: inicializa soma=0 (O(1)); for i=1 to m: if B[i] soma += S[i] (O(m)); if soma==t aceita. Complexidade: O(m) = O(n).",
                              "finalVerifications": [
                                "Complexidade total expressa corretamente como O(n^k) com k≤5 típico.",
                                "Justificativa cobre todos loops e operações principais.",
                                "Teste numérico para n=100 mostra ops < 100^3 = 1e6.",
                                "k é comprovadamente constante e independente de instância específica.",
                                "Análise ignora fatores constantes mas nota eles.",
                                "Comparação com exponential verifier destaca diferença.",
                                "Documentação clara permite reprodução por terceiro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de n e entrada (20%).",
                                "Correta decomposição e classificação de operações (25%).",
                                "Análise precisa de loops/aninhados (25%).",
                                "Síntese assintótica e verificação polinomial (20%).",
                                "Clareza, completude e testes numéricos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Notação Big O e análise assintótica de funções.",
                                "Física: Modelagem de tempo de computação em simulações dinâmicas.",
                                "Economia: Análise custo-benefício em otimização de recursos computacionais.",
                                "Lógica: Verificação formal de propriedades em teoremas.",
                                "Engenharia: Design de sistemas escaláveis com bounds de performance."
                              ],
                              "realWorldApplication": "Em ferramentas de verificação formal como SAT solvers (ex: Z3), analisar verificadores polinomiais garante escalabilidade para instâncias reais de milhões de variáveis, usado em hardware design, scheduling e cibersegurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.3.3",
                        "name": "Definição Formal da Classe NP",
                        "description": "Conjunto de linguagens de decisão L ⊆ {0,1}* para as quais existe um verificador polinomial V tal que x ∈ L iff existe y com |y| ≤ p(|x|) e V(x,y) aceita.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.3.1",
                            "name": "Estabelecer definição precisa da classe NP",
                            "description": "Formular matematicamente NP = ∪_k NTIME(n^k), ou equivalentemente via verificadores polinomiais, e provar equivalência entre as duas definições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular a definição de NP via NTIME",
                                  "subSteps": [
                                    "Relembrar a definição formal de NTIME(f(n)): conjunto de linguagens reconhecidas por máquinas de Turing não-determinísticas em tempo O(f(n)).",
                                    "Definir formalmente NP = ∪_{k≥1} NTIME(n^k), explicando a união sobre todos polinômios.",
                                    "Discutir propriedades chave: não-determinismo permite ramificações paralelas em tempo polinomial.",
                                    "Fornecer exemplo simples, como o problema de satisfação booleana (SAT), mostrando como uma NTM resolve em tempo polinomial não-determinístico."
                                  ],
                                  "verification": "Escrever a definição matemática exata em um papel ou documento e verificar se corresponde à de livros-texto padrão (ex: Sipser).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 7)",
                                    "Notas de aula sobre complexidade",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Comece com exemplos intuitivos de não-determinismo para visualizar 'adivinhação' em tempo polinomial.",
                                  "learningObjective": "Dominar a definição temporal de NP e sua notação formal.",
                                  "commonMistakes": "Confundir NTIME com DTIME (determinístico); lembrar que é não-determinístico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a definição de NP via Verificadores Polinomiais",
                                  "subSteps": [
                                    "Definir um verificador V como uma máquina de Turing determinística que, em entrada (x,w) com |w| ≤ p(|x|), aceita em tempo polinomial se w é certificado para x.",
                                    "Estabelecer L_V = {x | ∃ w, |w| ≤ p(|x|), V(x,w) aceita} para polinômio p.",
                                    "Definir NP como a classe de linguagens L tal que ∃ verificador polinomial V com L = L_V.",
                                    "Ilustrar com SAT: w é uma atribuição de variáveis que satisfaz a fórmula x."
                                  ],
                                  "verification": "Construir um esboço formal da definição e testá-lo verbalmente explicando para si mesmo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Computational Complexity' de Arora e Barak (Seção 2.2)",
                                    "Ferramenta online como Overleaf para LaTeX",
                                    "Vídeos de teoria da computação no YouTube (MIT OCW)"
                                  ],
                                  "tips": "Pense no verificador como um 'juiz' que checa certificados rapidamente.",
                                  "learningObjective": "Entender NP como linguagens com certificados curtos e verificáveis eficientemente.",
                                  "commonMistakes": "Esquecer a restrição polinomial no tamanho do certificado |w| ≤ p(n)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que ∪ NTIME(n^k) ⊆ NP (definição por verificadores)",
                                  "subSteps": [
                                    "Para L ∈ NTIME(n^k), construir um verificador V que simula todas as ramificações não-determinísticas usando w como 'caminho de aceitação'.",
                                    "Mostrar que |w| = O(n^k) (comprimento do caminho na árvore de computação).",
                                    "Provar que V roda em tempo polinomial: O(n^k) para simular o caminho.",
                                    "Verificar que x ∈ L iff ∃ w tal que V(x,w) aceita."
                                  ],
                                  "verification": "Escrever a prova formal em LaTeX ou papel, checando cada lemna com referências.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel para provas",
                                    "Livro de Sipser (Teorema 7.18)",
                                    "Software LaTeX como Overleaf"
                                  ],
                                  "tips": "Visualize a árvore de computação da NTM; w codifica o caminho aceitador.",
                                  "learningObjective": "Compreender como não-determinismo é 'compilado' em um verificador determinístico.",
                                  "commonMistakes": "Subestimar o tempo de simulação; certificar-se de que é polinomial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar que NP ⊆ ∪ NTIME(n^k) (definição temporal)",
                                  "subSteps": [
                                    "Para L ∈ NP com verificador V e polinômio p, construir NTM M que adivinha w (|w|≤p(n)) e simula V(x,w).",
                                    "Mostrar que M aceita em tempo O(p(n)^c + n^k) para algum k, pois simulação de V é polinomial.",
                                    "Estabelecer que L_M = L, pois adivinhação cobre ∃ w.",
                                    "Concluir a equivalência bidirecional."
                                  ],
                                  "verification": "Completar a prova e compará-la com versões padrão em livros-texto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Sipser ou Arora-Barak",
                                    "Notas pessoais de passos anteriores"
                                  ],
                                  "tips": "A NTM 'adivinha' o certificado e verifica; simples e direto.",
                                  "learningObjective": "Fechar a equivalência entre definições, solidificando compreensão de NP.",
                                  "commonMistakes": "Confundir tempos; garantir que adivinhação + verificação seja NTIME(n^k)."
                                }
                              ],
                              "practicalExample": "Para o problema Hamilton Cycle (HC): Na definição NTIME, NTM adivinha um ciclo e verifica em tempo polinomial. No verificador, w é a sequência de vértices do ciclo, verificada em O(n^2). Ambas definem HC ∈ NP.",
                              "finalVerifications": [
                                "Formulação correta de NP = ∪ NTIME(n^k).",
                                "Definição precisa de verificador polinomial.",
                                "Prova completa de NTIME ⊆ NP com simulação de caminhos.",
                                "Prova completa de NP ⊆ NTIME com adivinhação de w.",
                                "Exemplo concreto como SAT ou HC ilustrando ambas definições."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas definições (sem erros de notação).",
                                "Corretude lógica das provas (cada passo justificado).",
                                "Clareza na distinção entre não-determinismo e verificadores.",
                                "Uso apropriado de polinômios em tempos e tamanhos.",
                                "Capacidade de aplicar a ambas as definições a um problema exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e uniões enumeráveis.",
                                "Lógica: Conceitos de existência quantificada (∃ w).",
                                "Análise de Algoritmos: Análise assintótica de tempo polinomial.",
                                "Filosofia da Computação: Questões de decidibilidade e limites."
                              ],
                              "realWorldApplication": "A definição precisa de NP é fundamental para o problema P vs NP, impactando otimização em logística (ex: roteamento de veículos), criptografia (protocolos baseados em NP-hard) e IA (aprendizado de máquina com problemas NP-completos como TSP)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.3.2",
                            "name": "Relacionar NP com linguagens aceitas por MTND em tempo polinomial",
                            "description": "Demonstrar que uma linguagem é aceita por MTND em tempo polinomial se e só se tem um verificador polinomial, via construção de certificado a partir de caminhos de aceitação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Máquinas de Turing Não-Determinísticas (MTND) e aceitação em tempo polinomial",
                                  "subSteps": [
                                    "Estudar a definição formal de MTND e suas transições não-determinísticas.",
                                    "Analisar como uma MTND aceita uma linguagem em tempo polinomial (comprimento da entrada n, tempo O(n^k)).",
                                    "Explorar o conceito de 'caminho de aceitação' em computações não-determinísticas.",
                                    "Diferenciar MTND de MTD (Determinística).",
                                    "Resolver exercícios simples de simulação de MTND."
                                  ],
                                  "verification": "Simular manualmente uma MTND em uma entrada pequena e identificar um caminho de aceitação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 7)",
                                    "Notas de aula sobre MTND",
                                    "Simulador online de Máquinas de Turing"
                                  ],
                                  "tips": "Visualize a árvore de computação da MTND para entender ramificações.",
                                  "learningObjective": "Dominar os fundamentos de MTND e o papel do tempo polinomial na definição de NP.",
                                  "commonMistakes": [
                                    "Confundir tempo de todas as ramificações com tempo por ramificação.",
                                    "Ignorar que apenas um caminho precisa aceitar."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender verificadores polinomiais e a definição de NP via certificados",
                                  "subSteps": [
                                    "Definir um verificador polinomial V(x, c) onde |c| ≤ poly(|x|).",
                                    "Explicar que L ∈ NP se existe V tal que x ∈ L iff ∃c V(x,c)=1.",
                                    "Estudar exemplos como SAT (certificado: atribuição booleana).",
                                    "Comparar as duas definições de NP: MTND vs. Verificador.",
                                    "Provar propriedades básicas de verificadores."
                                  ],
                                  "verification": "Escrever a definição formal de verificador e aplicar a um exemplo como GRAPH-ISOMORPHISM.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Apostila de Complexidade Computacional",
                                    "Vídeos do MIT OCW sobre NP",
                                    "Folha de exercícios sobre NP"
                                  ],
                                  "tips": "Lembre-se: o verificador é determinístico e rápido; o não-determinismo está no 'adivinhar' c.",
                                  "learningObjective": "Compreender a equivalência conceitual entre as definições de NP.",
                                  "commonMistakes": [
                                    "Achar que o verificador resolve o problema (ele só verifica).",
                                    "Confundir tamanho do certificado com tempo de verificação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar: Se L aceita por MTND em tempo polinomial, então L ∈ NP (construção do certificado)",
                                  "subSteps": [
                                    "Dado M (MTND) que aceita L em tempo p(n), descrever a computação em árvore de altura ≤ p(n).",
                                    "Construir o certificado c como a sequência de escolhas não-determinísticas ao longo de um caminho de aceitação.",
                                    "Mostrar que |c| ≤ p(n) * log(transições).",
                                    "Construir o verificador V(x,c): simular M em x usando c como guia (tempo polinomial).",
                                    "Provar correção: se x ∈ L, existe c; se V(x,c)=1, então x ∈ L."
                                  ],
                                  "verification": "Escrever a prova formal da construção e verificar com um exemplo como HALTING (restringido).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Teorema 7.20 de Sipser",
                                    "Papel e lápis para diagramas de árvore",
                                    "Pseudocódigo de simulador"
                                  ],
                                  "tips": "Codifique escolhas como índices de transições para compactar o certificado.",
                                  "learningObjective": "Dominar a construção explícita do certificado a partir do caminho de aceitação.",
                                  "commonMistakes": [
                                    "Esquecer de provar que a simulação guiada é determinística e polinomial.",
                                    "Superestimar o tamanho do certificado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar: Se L ∈ NP, então L aceita por MTND em tempo polinomial",
                                  "subSteps": [
                                    "Dado verificador V para L, construir MTND M que, na entrada x, não-determinísticamente gera c de tamanho ≤ p(|x|).",
                                    "Simular V(x,c) determinísticamente.",
                                    "Aceitar se V(x,c)=1.",
                                    "Mostrar que qualquer caminho de aceitação tem tempo ≤ p(|x|) + poly(|x|).",
                                    "Provar que M aceita exatamente L."
                                  ],
                                  "verification": "Construir explicitamente M para o exemplo de SAT e simular.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Arora & Barak (cap. 2)",
                                    "Exemplos resolvidos de provas de NP",
                                    "Ferramenta JFLAP para MTND"
                                  ],
                                  "tips": "A MTND 'adivinha' c bit a bit, simulando o não-determinismo do verificador.",
                                  "learningObjective": "Completar a equivalência das definições de NP.",
                                  "commonMistakes": [
                                    "Gerar c maior que polinomial.",
                                    "Não limitar o tempo da simulação de V."
                                  ]
                                }
                              ],
                              "practicalExample": "Para SAT (3-SAT), MTND adivinha atribuição (caminho de aceitação: sequência de escolhas para cláusulas satisfeitas). Certificado: a atribuição booleana. Verificador: pluga na fórmula e checa em tempo linear.",
                              "finalVerifications": [
                                "Consegue construir certificado de um caminho de aceitação para uma MTND dada.",
                                "Implementa corretamente o verificador V a partir de M.",
                                "Prova a direção inversa com MTND gerando certificado.",
                                "Aplica a equivalência a um problema como TSP (versão de decisão).",
                                "Identifica erros comuns em provas de estudantes.",
                                "Explica verbalmente a intuição para um par.",
                                "Simula completa para entrada de tamanho 10."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do certificado (tamanho e conteúdo).",
                                "Correção das provas de ambas as direções (⇒ e ⇐).",
                                "Uso correto de notação formal (O(n^k), etc.).",
                                "Clareza na descrição do verificador e MTND.",
                                "Aplicação a exemplos concretos sem erros.",
                                "Identificação de limites polinomiais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (árvores de computação).",
                                "Análise de Algoritmos: Análise assintótica de tempo.",
                                "Lógica: Verificação de fórmulas proposicionais.",
                                "Criptografia: Provas de conhecimento zero (certificados).",
                                "Inteligência Artificial: Busca não-determinística."
                              ],
                              "realWorldApplication": "Em verificação de software e hardware, certificados NP permitem checar rapidamente soluções candidatas para problemas como alocação ótima de recursos ou schedulings, sem resolver o problema inteiro."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.3.3",
                            "name": "Identificar exemplos clássicos de problemas em NP",
                            "description": "Listar e descrever problemas como SAT, Clique, Vertex Cover e Hamiltoneano, explicando por que pertencem a NP via esboço de verificadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Problema SAT (Satisfatibilidade Booleana)",
                                  "subSteps": [
                                    "Defina SAT: dada uma fórmula booleana em forma normal conjuntiva (CNF), determinar se existe uma atribuição de variáveis que a torna verdadeira.",
                                    "Estude a estrutura de uma fórmula CNF: cláusulas AND de literais OR.",
                                    "Descreva o verificador: dado um certificado (atribuição de valores verdadeiros/falsos), verifique em tempo polinomial se satisfaz todas as cláusulas.",
                                    "Implemente um pseudocódigo simples para o verificador de SAT.",
                                    "Teste com exemplo: (x1 ∨ ¬x2) ∧ (¬x1 ∨ x2) com atribuição x1=true, x2=true."
                                  ],
                                  "verification": "Escreva e execute um verificador manual para uma fórmula CNF simples, confirmando se o certificado é válido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Documentação sobre lógica booleana",
                                    "Exemplos de fórmulas CNF online"
                                  ],
                                  "tips": "Comece com fórmulas pequenas (2-3 variáveis) para visualizar atribuições.",
                                  "learningObjective": "Compreender por que SAT está em NP através de seu polinomial-time verificador.",
                                  "commonMistakes": [
                                    "Confundir SAT com 3-SAT (versão NP-completa restrita)",
                                    "Ignorar que o verificador deve rodar em tempo polinomial no tamanho da entrada."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Problema Clique",
                                  "subSteps": [
                                    "Defina Clique: em um grafo não-direcionado, dado k, existe um subgrafo completo com k vértices?",
                                    "Represente grafos com matriz de adjacência ou lista de adjacência.",
                                    "Descreva o verificador: dado um conjunto S de k vértices, verifique se todo par em S tem aresta (O(k^2) tempo).",
                                    "Desenhe um grafo exemplo com clique de tamanho 3.",
                                    "Prove polynomialidade: verificação é O(|V|^2) no pior caso."
                                  ],
                                  "verification": "Para um grafo dado e conjunto S, confirme manualmente se S forma um clique.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de desenho de grafos como Draw.io",
                                    "Exemplos de grafos com cliques"
                                  ],
                                  "tips": "Lembre-se: clique é subgrafo onde todos estão mutuamente conectados.",
                                  "learningObjective": "Identificar o certificado (conjunto de vértices) e seu verificador polinomial para Clique.",
                                  "commonMistakes": [
                                    "Confundir clique com conjunto independente",
                                    "Esquecer de verificar todas as pares em S."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Vertex Cover",
                                  "subSteps": [
                                    "Defina Vertex Cover: dado grafo G e k, existe um conjunto C de k vértices que cobre todas as arestas?",
                                    "Explique 'cobre': toda aresta incidente a pelo menos um vértice em C.",
                                    "Verificador: dado C com |C|=k, para cada aresta, cheque se pelo menos um endpoint está em C (O(|E|k) tempo).",
                                    "Exemplo: grafo com 3 arestas, C com 2 vértices cobrindo todas.",
                                    "Compare com complemento: relacionado a Vertex Independent Set."
                                  ],
                                  "verification": "Valide um conjunto C proposto em um grafo pequeno, listando arestas não cobertas (deve ser zero).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Grafo exemplo impresso ou digital",
                                    "Pseudocódigo para verificador"
                                  ],
                                  "tips": "Use busca exaustiva manual em grafos pequenos para intuition.",
                                  "learningObjective": "Dominar o verificador de Vertex Cover e sua eficiência polinomial.",
                                  "commonMistakes": [
                                    "Verificar apenas vértices, não arestas",
                                    "Permitir |C| > k no verificador."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar o Problema Hamiltoniano e Generalizar",
                                  "subSteps": [
                                    "Defina Hamiltonian Cycle/Path: ciclo/caminho visitando cada vértice exatamente uma vez.",
                                    "Verificador para Cycle: dado ciclo (sequência de vértices), cheque: |sequência|=|V|+1, primeiro=último, todos distintos, arestas adjacentes existem (O(|V|) tempo).",
                                    "Exemplo: grafo completo K3 tem ciclo hamiltoniano.",
                                    "Generalize: todos esses problemas têm certificados curtos (polinomiais) verificáveis rapidamente.",
                                    "Liste os 4 problemas e resuma seus verificadores em tabela."
                                  ],
                                  "verification": "Crie uma tabela comparativa dos 4 problemas com certificados e complexidade de verificação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Tabela modelo em Excel ou papel",
                                    "Grafo hamiltoniano exemplo"
                                  ],
                                  "tips": "Foquem em 'visita exata uma vez' para Hamiltoniano.",
                                  "learningObjective": "Conectar os exemplos ao conceito formal de NP via verificadores.",
                                  "commonMistakes": [
                                    "Confundir Hamiltoniano com Euleriano (visita arestas)",
                                    "Achar que encontrar o ciclo é polinomial (não é)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em design de circuitos lógicos, use SAT para verificar se uma atribuição de sinais satisfaz especificações de hardware, testando rapidamente candidatas soluções.",
                              "finalVerifications": [
                                "Liste corretamente SAT, Clique, Vertex Cover e Hamiltoniano como problemas em NP.",
                                "Descreva o certificado e verificador para cada um sem erros.",
                                "Explique por que cada verificador roda em tempo polinomial.",
                                "Identifique um exemplo concreto para cada problema.",
                                "Diferencie decisão (NP) de otimização.",
                                "Crie um verificador pseudocódigo para pelo menos dois problemas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de cada problema (100% cobertura de elementos chave).",
                                "Correção do verificador (inclui certificado curto e tempo polinomial).",
                                "Profundidade de exemplos (concretos e testáveis).",
                                "Capacidade de generalização para classe NP.",
                                "Ausência de confusões com problemas fora de NP (ex: P vs NP).",
                                "Clareza na comunicação (diagramas/grafos quando aplicável)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Lógica Proposicional.",
                                "Filosofia: Questões de decidibilidade e limites da computação.",
                                "Engenharia: Otimização em redes e design de circuitos.",
                                "Economia: Modelagem de problemas de alocação como Vertex Cover."
                              ],
                              "realWorldApplication": "Esses problemas modelam desafios como escalonamento de tarefas (Hamiltoniano em grafos de precedência), detecção de fraudes em redes sociais (Clique para grupos densos) e otimização de coberturas em redes de sensores (Vertex Cover)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.3.4",
                            "name": "Diferenciar NP de P e co-NP",
                            "description": "Explicar que P ⊆ NP, conjectura P ≠ NP, e que co-NP contém problemas cujos complementos estão em NP, com exemplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a classe P e sua relação com NP",
                                  "subSteps": [
                                    "Defina a classe P como o conjunto de problemas decidíveis em tempo polinomial por uma máquina de Turing determinística.",
                                    "Explique que todo problema em P pode ser resolvido eficientemente sem adivinhação.",
                                    "Discuta que P ⊆ NP, pois qualquer solução em P pode ser verificada trivialmente em tempo polinomial.",
                                    "Forneça um exemplo simples: ordenação de listas (Bubble Sort em O(n²), mas otimizável).",
                                    "Compare com problemas que exigem busca exaustiva."
                                  ],
                                  "verification": "Escreva uma definição precisa de P e prove verbalmente que P ⊆ NP.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre complexidade",
                                    "Pseudocódigo de algoritmo em P",
                                    "Máquina de Turing virtual online"
                                  ],
                                  "tips": [
                                    "Foquem em 'determinístico' vs. 'não-determinístico'. Use diagramas de Venn para visualizar."
                                  ],
                                  "learningObjective": "Dominar a definição de P e sua inclusão em NP.",
                                  "commonMistakes": [
                                    "Confundir P com problemas NP-completos.",
                                    "Achar que P = NP sem conjectura."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a classe NP em detalhes",
                                  "subSteps": [
                                    "Defina NP como problemas cujas soluções podem ser verificadas em tempo polinomial por uma máquina determinística.",
                                    "Explique o não-determinismo: 'máquina adivinha' a solução e verifica.",
                                    "Dê exemplo clássico: SAT (Satisfatibilidade Booleana) está em NP.",
                                    "Discuta o certificado de verificação: para SAT, um certificado é uma atribuição de variáveis.",
                                    "Pratique convertendo um problema para mostrar que está em NP."
                                  ],
                                  "verification": "Construa um verificador polinomial para um problema dado em NP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de problemas NP",
                                    "Ferramenta SAT solver online",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Pense em 'fácil de verificar, difícil de resolver'. Desenhe o processo de verificação."
                                  ],
                                  "learningObjective": "Identificar e justificar problemas em NP.",
                                  "commonMistakes": [
                                    "Confundir resolução com verificação.",
                                    "Achar que todos problemas em NP são intratáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a classe co-NP e suas propriedades",
                                  "subSteps": [
                                    "Defina co-NP como o conjunto de problemas cujos complementos estão em NP.",
                                    "Explique que se L ∈ NP, então complemento de L ∈ co-NP.",
                                    "Dê exemplo: UNSAT (insatisfatibilidade) é co-NP, pois complemento de SAT.",
                                    "Discuta que NP ⊆ co-NP se P = NP, mas conjectura-se que não.",
                                    "Mostre que P ⊆ co-NP também, similar a P ⊆ NP."
                                  ],
                                  "verification": "Prove que o complemento de um problema NP está em co-NP com um exemplo concreto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de classes de complexidade",
                                    "Exemplos de fórmulas SAT/UNSAT",
                                    "Livro texto sobre teoria da computação"
                                  ],
                                  "tips": [
                                    "Lembre: co-NP foca no 'não' da solução. Use tabelas verdade para SAT."
                                  ],
                                  "learningObjective": "Diferenciar co-NP de NP via complementos.",
                                  "commonMistakes": [
                                    "Confundir co-NP com NP-complemento completo.",
                                    "Ignorar que P está em ambos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar P, NP e co-NP com conjecturas e exemplos",
                                  "subSteps": [
                                    "Resuma: P ⊆ NP ∩ co-NP, conjectura P ≠ NP implica NP ≠ co-NP.",
                                    "Discuta P vs NP vs co-NP: P eficiente, NP verificável, co-NP 'não-verificável' diretamente.",
                                    "Exemplos comparativos: Primality (agora em P), Factoring (NP ∩ co-NP?).",
                                    "Aborde conjectura P ≠ NP e implicações para co-NP.",
                                    "Crie um diagrama comparativo das classes."
                                  ],
                                  "verification": "Desenhe diagrama de Venn e explique diferenças com exemplos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagrama de Venn em branco",
                                    "Lista de problemas por classe",
                                    "Vídeo curto sobre P vs NP"
                                  ],
                                  "tips": [
                                    "Use cores no diagrama: verde P, amarelo NP, vermelho co-NP."
                                  ],
                                  "learningObjective": "Integrar conhecimentos para diferenciar as classes.",
                                  "commonMistakes": [
                                    "Achar que co-NP é 'mais difícil' que NP.",
                                    "Esquecer P em ambas."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema 3-SAT (NP-completo). Uma instância é: (x1 ∨ ¬x2 ∨ x3) ∧ (¬x1 ∨ x2 ∨ ¬x3). Para diferenciar: em P? Não (conjectura). Verificador NP: dada atribuição x1=true, x2=false, x3=true, verifica em O(n). Para co-NP (3-UNSAT): certificado seria prova de insatisfatibilidade, mas difícil de verificar diretamente.",
                              "finalVerifications": [
                                "Explicar corretamente P ⊆ NP e por quê.",
                                "Dar exemplo de problema em NP mas não conhecido em P.",
                                "Definir co-NP via complemento e dar exemplo (ex: UNSAT).",
                                "Desenhar diagrama de Venn com P, NP, co-NP.",
                                "Discutir conjectura P ≠ NP e implicação para co-NP.",
                                "Identificar se um problema dado (ex: Hamiltoniano) está em NP ou co-NP."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de P, NP e co-NP (80% correto).",
                                "Uso correto de exemplos e não-exemplos.",
                                "Compreensão de inclusões e conjecturas.",
                                "Capacidade de justificar verificadores polinomiais.",
                                "Clareza no diagrama comparativo.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e complementos.",
                                "Lógica: Lógica proposicional e tautologias (SAT/UNSAT).",
                                "Filosofia: Limites da computação e decidibilidade.",
                                "Criptografia: Problemas em NP ∩ co-NP como base para segurança."
                              ],
                              "realWorldApplication": "Em otimização de rotas logísticas (NP), verificação de provas matemáticas (co-NP) e design de algoritmos eficientes em IA, onde entender P vs NP guia escolhas entre exaustão e heurísticas, impactando campos como cibersegurança e planejamento urbano."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.4",
                    "name": "Teorema de Cook-Levin",
                    "description": "Demonstra que o problema SAT (Satisfatibilidade Booleana) é NP-completo, o primeiro problema identificado nessa classe.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.4.1",
                        "name": "Problema de Satisfatibilidade Booleana (SAT)",
                        "description": "Definição formal do problema SAT, incluindo fórmulas em Forma Normal Conjuntiva (CNF) e sua decisão de satisfatibilidade por atribuição de valores verdadeiros/falsos às variáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.1.1",
                            "name": "Definir e reconhecer fórmulas CNF",
                            "description": "Identificar e construir fórmulas booleanas em Forma Normal Conjuntiva (CNF), compreendendo cláusulas como disjunções de literais e a estrutura geral de uma conjunção de cláusulas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Lógica Proposicional",
                                  "subSteps": [
                                    "Revise variáveis proposicionais (p, q, r) e seus valores verdadeiros (V) ou falsos (F).",
                                    "Aprenda literais: uma variável positiva (p) ou negada (¬p).",
                                    "Entenda disjunção (OR, ∨): verdadeira se pelo menos um literal for verdadeiro.",
                                    "Entenda conjunção (AND, ∧): verdadeira se todos os literais forem verdadeiros.",
                                    "Pratique tabelas-verdade para expressões simples com 2 variáveis."
                                  ],
                                  "verification": "Construa tabelas-verdade corretas para (p ∨ ¬q) e (p ∧ q) sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de lógica como Truth Table Generator online"
                                  ],
                                  "tips": "Comece com poucas variáveis para evitar confusão nas tabelas-verdade.",
                                  "learningObjective": "Dominar literais, disjunções e conjunções como blocos de construção de CNF.",
                                  "commonMistakes": "Confundir negação de disjunção com disjunção de negações (Lei de De Morgan)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente a Forma Normal Conjuntiva (CNF)",
                                  "subSteps": [
                                    "Leia a definição: CNF é uma conjunção de cláusulas, onde cada cláusula é uma disjunção de literais.",
                                    "Exemplo: (p ∨ ¬q) ∧ (¬p ∨ r) é CNF.",
                                    "Identifique estrutura: ∧ de (∨ de literais).",
                                    "Diferencie de DNF (disjunção de conjunções).",
                                    "Memorize que CNF é usada em problemas de satisfatibilidade (SAT)."
                                  ],
                                  "verification": "Escreva a definição exata de CNF e dê um exemplo válido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula",
                                    "Vídeo tutorial sobre CNF no YouTube (ex: canal de lógica computacional)"
                                  ],
                                  "tips": "Pense em CNF como 'todas as cláusulas devem ser verdadeiras simultaneamente'.",
                                  "learningObjective": "Articular a definição precisa de CNF e sua representação.",
                                  "commonMistakes": "Achar que qualquer fórmula com ∨ e ∧ é CNF; ignorar que cláusulas não podem ter conjunções internas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Fórmulas em CNF",
                                  "subSteps": [
                                    "Analise uma fórmula: verifique se é conjunção de disjunções puras de literais.",
                                    "Teste exemplos: (p ∨ q) ∧ (¬p) é CNF? Sim.",
                                    "Identifique não-CNF: p ∧ (q ∨ r) ∧ ¬s não é, pois tem conjunção solta.",
                                    "Pratique com 5 fórmulas aleatórias.",
                                    "Use árvore de parsing para decompor a fórmula."
                                  ],
                                  "verification": "Classifique corretamente 5 fórmulas como CNF ou não-CNF, justificando.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de exercícios impressa ou digital",
                                    "Editor de texto para fórmulas"
                                  ],
                                  "tips": "Procure por parênteses: cada cláusula deve ser (literal ∨ literal ∨ ...).",
                                  "learningObjective": "Identificar rapidamente se uma fórmula booleana está em CNF.",
                                  "commonMistakes": "Permitir conjunções dentro de cláusulas ou literais repetidos na mesma cláusula."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir Fórmulas em CNF",
                                  "subSteps": [
                                    "Comece com uma expressão arbitrária, como (p → q).",
                                    "Converta para CNF usando leis equivalentes: p → q ≡ ¬p ∨ q.",
                                    "Para expressões complexas, use distribuição: aplique regras de De Morgan e fatoração.",
                                    "Verifique o resultado: deve ser conjunção de disjunções de literais.",
                                    "Pratique convertendo 3 expressões para CNF."
                                  ],
                                  "verification": "Converta (p ∧ q) → r para CNF corretamente: (¬p ∨ ¬q ∨ r).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Folha de leis lógicas (equivalências)",
                                    "Calculadora simbólica como Wolfram Alpha para verificação"
                                  ],
                                  "tips": "Distribua ∧ sobre ∨ como em álgebra: a ∧ (b ∨ c) = (a ∧ b) ∨ (a ∧ c).",
                                  "learningObjective": "Construir CNF a partir de fórmulas booleanas dadas.",
                                  "commonMistakes": "Esquecer de propagar negações com De Morgan em conversões."
                                }
                              ],
                              "practicalExample": "Dada a fórmula (p ∧ ¬q) → r, converta para CNF: Equivale a ¬(p ∧ ¬q) ∨ r = (¬p ∨ q) ∨ r, que é CNF (uma única cláusula). Para múltiplas: expanda para conjunção de cláusulas como (¬p ∨ r) ∧ (q ∨ r).",
                              "finalVerifications": [
                                "Defina CNF em suas próprias palavras corretamente.",
                                "Identifique CNF em 10 fórmulas mistas com 100% de acerto.",
                                "Construa CNF para uma fórmula com 3 variáveis.",
                                "Explique por que uma fórmula não-CNF falha nos critérios.",
                                "Gere uma tabela-verdade para uma CNF simples e verifique satisfatibilidade.",
                                "Compare CNF com DNF em um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de CNF (30%)",
                                "Capacidade de reconhecimento correto (25%)",
                                "Habilidade de construção sem erros lógicos (25%)",
                                "Justificativas claras e uso de leis equivalentes (10%)",
                                "Eficiência na conversão (mínimo de cláusulas) (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equivalências lógicas e tabelas-verdade (Álgebra Booleana).",
                                "Inteligência Artificial: SAT solvers para planejamento e otimização.",
                                "Filosofia: Lógica proposicional em argumentos deductivos.",
                                "Engenharia de Software: Verificação formal de programas."
                              ],
                              "realWorldApplication": "CNF é fundamental em solvers SAT usados em verificação de hardware (ex: chips Intel), agendamento de voos, configuração de redes e provas automáticas em teoremas matemáticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.1.2",
                            "name": "Verificar satisfatibilidade de instâncias SAT",
                            "description": "Dado uma fórmula CNF, determinar se existe uma atribuição de valores booleanos que a satisfaz, utilizando busca exaustiva ou backtracking simples para instâncias pequenas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar a fórmula CNF como estrutura de dados",
                                  "subSteps": [
                                    "Identifique as variáveis booleanas (ex: x1, x2, x3) e atribua índices numéricos (0,1,2).",
                                    "Parse a fórmula CNF em uma lista de cláusulas, onde cada cláusula é uma lista de literais (positivo para true, negativo para false).",
                                    "Exemplo: Para (x1 ∨ ¬x2) ∧ (x2 ∨ x3), represente como [[1, -2], [2, 3]].",
                                    "Valide a representação verificando que cada cláusula tenha pelo menos um literal.",
                                    "Crie uma função para imprimir a fórmula de forma legível."
                                  ],
                                  "verification": "Execute a função de parsing e imprima a estrutura; confirme que corresponde à fórmula original sem erros de sinal ou ordem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python recomendado)",
                                    "Documentação de SAT/CNF online"
                                  ],
                                  "tips": "Use dicionários para mapear nomes de variáveis a índices para facilitar depuração.",
                                  "learningObjective": "Compreender e implementar a representação padrão de fórmulas CNF para processamento algorítmico.",
                                  "commonMistakes": [
                                    "Confundir sinal de literais (¬x como -1 em vez de +1)",
                                    "Esquecer cláusulas unitárias ou vazias",
                                    "Não tratar variáveis não usadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar função base de backtracking recursivo",
                                  "subSteps": [
                                    "Crie um array de atribuições parciais (ex: assignment = [-1] * num_vars, onde -1=indefinido, 0=false, 1=true).",
                                    "Defina função recursiva que tenta atribuir True (1) a uma variável não atribuída.",
                                    "Se todas variáveis atribuídas, verifique se satisfaz todas cláusulas.",
                                    "Se não satisfaz, backtrack: tente False (0) na mesma variável.",
                                    "Se nem True nem False funcionam, retorne False e backtrack para variável anterior."
                                  ],
                                  "verification": "Teste com fórmula trivial como (x1) e confirme que retorna True com x1=True.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com recursão habilitada",
                                    "Exemplos de código recursivo simples"
                                  ],
                                  "tips": "Use um índice atual para a variável em trial (var_index) em vez de loop sobre lista.",
                                  "learningObjective": "Dominar o paradigma de backtracking recursivo para exploração exaustiva de espaços de busca booleanos.",
                                  "commonMistakes": [
                                    "Não verificar sat após atribuição completa",
                                    "Loop infinito por falta de backtrack",
                                    "Ignorar cláusulas durante verificação parcial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Otimizar com verificação parcial e executar na instância",
                                  "subSteps": [
                                    "Adicione poda: após atribuir uma variável, verifique se alguma cláusula já é falsa (todos literais falsos).",
                                    "Se cláusula falsa, backtrack imediatamente sem prosseguir.",
                                    "Integre a representação CNF à função de backtracking.",
                                    "Execute o solver na instância alvo e capture a atribuição satisfatória ou None.",
                                    "Adicione logging para rastrear tentativas e profundidade de recursão."
                                  ],
                                  "verification": "Rode em instância pequena (3 vars) e confirme que encontra solução ou prova insatisfatibilidade corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Mesmos do step anterior",
                                    "Instância de teste: [[1,-2],[ -1,2,3],[3]]"
                                  ],
                                  "tips": "Verificação parcial reduz drasticamente o tempo para instâncias pequenas; implemente primeiro sem ela para depurar.",
                                  "learningObjective": "Aplicar pruning heurístico para eficiência em backtracking, simulando solvers reais.",
                                  "commonMistakes": [
                                    "Verificar todas cláusulas só no final (lento)",
                                    "Erro em lógica de literal: abs(lit) para var, sign(lit) para valor",
                                    "Recursão profunda sem limite"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar solução e analisar complexidade",
                                  "subSteps": [
                                    "Crie função separada para validar: para cada cláusula, cheque se pelo menos um literal é verdadeiro sob a atribuição.",
                                    "Teste com múltiplas instâncias: satisfatível, insatisfatível e unitária.",
                                    "Meça número de chamadas recursivas para estimar complexidade (2^n no pior caso).",
                                    "Discuta limitações: viável só para n<=20 variáveis.",
                                    "Documente o código com comentários sobre cada parte."
                                  ],
                                  "verification": "Validador retorna True para solução encontrada e lista contadores de performance.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Instâncias de teste variadas",
                                    "Relógio para timing"
                                  ],
                                  "tips": "Use assert para testes unitários automáticos.",
                                  "learningObjective": "Avaliar corretude e performance de algoritmos NP-completos em escala pequena.",
                                  "commonMistakes": [
                                    "Não validar solução final",
                                    "Confundir SAT com 3-SAT",
                                    "Ignorar crescimento exponencial"
                                  ]
                                }
                              ],
                              "practicalExample": "Fórmula CNF: (x1 ∨ ¬x2) ∧ (¬x1 ∨ x3) ∧ (x2 ∨ ¬x3). Representação: [[1,-2], [-1,3], [2,-3]]. Backtracking encontra atribuição {x1: True, x2: False, x3: True}, validada pois: primeira cláusula True (x1), segunda True (x3), terceira True (¬x3=False? Espera: x2=False torna ¬x2=True na primeira, etc. Solução válida confirmada por validação.",
                              "finalVerifications": [
                                "Pode parsear e representar CNF corretamente para qualquer instância pequena.",
                                "Implementa backtracking que termina em <1s para 10 variáveis.",
                                "Encontra atribuição satisfatória ou prova insatisfatibilidade corretamente em 5 testes.",
                                "Código inclui verificação parcial e logging funcional.",
                                "Validador independente confirma soluções.",
                                "Entende por que é exponencial e limites práticos."
                              ],
                              "assessmentCriteria": [
                                "Corretude: 100% acerto em testes SAT/UNSAT.",
                                "Eficiência: Pruning reduz chamadas recursivas >50%.",
                                "Clareza: Código comentado, estrutura modular.",
                                "Robustez: Trata edge cases (0 vars, cláusulas vazias).",
                                "Documentação: Explica passos e complexidade.",
                                "Performance: Resolve 15 vars em tempo razoável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e tabelas-verdade.",
                                "Inteligência Artificial: Algoritmos de busca e constraint satisfaction.",
                                "Engenharia de Software: Verificação formal e testing automatizado.",
                                "Análise de Algoritmos: Introdução a NP-completude.",
                                "Filosofia: Raciocínio dedutivo e provas por exaustão."
                              ],
                              "realWorldApplication": "Solvers SAT como MiniSat são usados em verificação de hardware (Intel), planejamento de rotas em logística (UPS), configuração de software (Eclipse), e otimização em bioinformática, provando configurações viáveis em problemas reais com milhões de cláusulas via heurísticas avançadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.1.3",
                            "name": "Relacionar SAT com a classe NP",
                            "description": "Explicar por que SAT pertence à classe NP, destacando o verificador polinomial que confere uma solução candidata (atribuição) em tempo polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição da Classe NP",
                                  "subSteps": [
                                    "Defina linguagem de decisão e problema de decisão.",
                                    "Explique a distinção entre P e NP: P é decidível em tempo polinomial; NP é verificável em tempo polinomial.",
                                    "Descreva o conceito de 'certificado' ou 'solução candidata' e o papel do verificador polinomial.",
                                    "Discuta exemplos clássicos como TSP (Caixeiro Viajante) em NP."
                                  ],
                                  "verification": "Escreva uma definição precisa de NP e identifique o componente 'verificador' nela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Complexidade Computacional (ex: Sipser)",
                                    "Notas de aula sobre classes P e NP"
                                  ],
                                  "tips": "Lembre-se: NP não é sobre encontrar soluções, mas verificá-las rapidamente.",
                                  "learningObjective": "Compreender os fundamentos conceituais da classe NP.",
                                  "commonMistakes": "Confundir 'resolver em polinomial' (P) com 'verificar em polinomial' (NP)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Problema SAT em Detalhe",
                                  "subSteps": [
                                    "Defina fórmula booleana em Forma Normal Conjuntiva (CNF).",
                                    "Explique o que significa uma atribuição satisfaz uma cláusula e a fórmula inteira.",
                                    "Forneça um exemplo pequeno de fórmula SAT: (x1 ∨ ¬x2) ∧ (¬x1 ∨ x3).",
                                    "Discuta por que SAT é um problema de decisão: sim/não para satisfatibilidade."
                                  ],
                                  "verification": "Construa uma fórmula CNF simples e liste atribuições que a satisfazem ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para fórmulas lógicas",
                                    "Ferramenta online SAT solver (para verificação posterior)"
                                  ],
                                  "tips": "Sempre reduza fórmulas a CNF para padronização.",
                                  "learningObjective": "Dominar a representação e instâncias do problema SAT.",
                                  "commonMistakes": "Ignorar a necessidade de CNF; confundir com DNF."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Verificador Polinomial para SAT",
                                  "subSteps": [
                                    "Defina o verificador V: recebe instância φ (fórmula CNF) e certificado a (atribuição de variáveis).",
                                    "Descreva o algoritmo: para cada cláusula em φ, cheque se pelo menos uma literal é verdadeira sob a.",
                                    "Implemente pseudocódigo: loop sobre cláusulas, eval literais com a.",
                                    "Garanta que |a| = número de variáveis, e tempo O(n * m) onde n=vars, m=cláusulas."
                                  ],
                                  "verification": "Escreva pseudocódigo do verificador e teste com exemplo manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para pseudocódigo",
                                    "Python/IDEs para protótipo simples"
                                  ],
                                  "tips": "Pense em avaliação literal como tabela-verdade local por cláusula.",
                                  "learningObjective": "Implementar conceitualmente o verificador que prova SAT ∈ NP.",
                                  "commonMistakes": "Esquecer de checar todas cláusulas; assumir tempo exponencial na verificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade e Concluir Pertinência a NP",
                                  "subSteps": [
                                    "Calcule complexidade: O(nm) é polinomial pois n,m polinomiais no tamanho da entrada.",
                                    "Compare com definição formal de NP: L ∈ NP se existe V tal que |cert| polinomial e V roda em polinomial.",
                                    "Discuta Teorema de Cook-Levin brevemente: SAT é NP-completo, logo primeiro problema em NP.",
                                    "Resuma: SAT ∈ NP porque soluções candidatas são verificáveis em tempo polinomial."
                                  ],
                                  "verification": "Prove formalmente que o verificador roda em O(poly(|φ|)) e escreva conclusão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de cálculos de complexidade",
                                    "Referência ao teorema formal de NP"
                                  ],
                                  "tips": "Tamanho entrada |φ| ≈ nm, então O(nm) = O(|φ|).",
                                  "learningObjective": "Conectar verificador à definição de NP e concluir corretamente.",
                                  "commonMistakes": "Confundir verificação com resolução; ignorar tamanho do certificado."
                                }
                              ],
                              "practicalExample": "Considere φ = (x1 ∨ ¬x2) ∧ (x2 ∨ x3) ∧ (¬x1 ∨ ¬x3). Certificado a = {x1=true, x2=true, x3=false}. Verificador: Cláusula1: x1=true → ok; Cláusula2: x2=true → ok; Cláusula3: ¬x1=false mas ¬x3=true → ok. Aceita em O(1) tempo para este caso.",
                              "finalVerifications": [
                                "Pode definir NP corretamente?",
                                "Descreve o verificador SAT com pseudocódigo?",
                                "Calcula complexidade do verificador como polinomial?",
                                "Explica por que certificado é uma atribuição binária?",
                                "Distingue SAT de problemas fora de NP?",
                                "Liga ao Teorema de Cook-Levin?",
                                "Testa verificador em exemplo concreto?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de NP (20%)",
                                "Detalhe do verificador e pseudocódigo (25%)",
                                "Análise de complexidade correta (20%)",
                                "Exemplo prático funcional (15%)",
                                "Conclusão lógica e formal (10%)",
                                "Ausência de confusões P/NP (5%)",
                                "Conexões com contexto maior (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Avaliação de fórmulas proposicionais.",
                                "Teoria dos Grafos: Reduções para 3-SAT via grafos.",
                                "Filosofia da Computação: Questões de decidibilidade e Church-Turing.",
                                "Inteligência Artificial: SAT solvers em planejamento e otimização."
                              ],
                              "realWorldApplication": "SAT solvers são usados em verificação de hardware (circuitos lógicos), escalonamento de tarefas (agendamento), configuração de software (instaladores), e otimização em logística, provando soluções candidatas rapidamente em indústrias como semicondutores e aviação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.4.2",
                        "name": "Máquinas de Turing Não-Determinísticas (NTM) e Classe NP",
                        "description": "Conceitos de NTM, sua linguagem de aceitação em tempo polinomial e a equivalência com a classe NP via simulação não-determinística.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.2.1",
                            "name": "Descrever o modelo de NTM",
                            "description": "Formalizar uma Máquina de Turing Não-Determinística, incluindo transições múltiplas, configurações e o processo de aceitação por alguma ramificação em tempo polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os componentes básicos de uma Máquina de Turing Determinística (MT)",
                                  "subSteps": [
                                    "Identifique os 7 componentes formais de uma MT: Q (estados), Σ (alfabeto), Γ (alfabeto da fita), δ (função de transição), q0 (estado inicial), B (símbolo em branco), F (estados de aceitação).",
                                    "Descreva a configuração inicial: cabeça na posição 0, fita com entrada rodeada por B.",
                                    "Explique a evolução determinística: única transição por configuração.",
                                    "Diferencie aceitação por estado final versus por rejeição.",
                                    "Pratique diagramando uma MT simples para reconhecer {a^n b^n}."
                                  ],
                                  "verification": "Escreva a definição formal de uma MT e simule 3 passos de uma configuração inicial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Papel e lápis para diagramas",
                                    "Simulador online de MT (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": "Use notação matemática precisa: δ: Q × Γ → Q × Γ × {L,R}. Foque na unicidade da transição.",
                                  "learningObjective": "Compreender a base determinística para contrastar com NTM.",
                                  "commonMistakes": [
                                    "Confundir alfabeto de entrada Σ com alfabeto da fita Γ.",
                                    "Esquecer o símbolo em branco B como parte de Γ."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de não-determinismo na transição",
                                  "subSteps": [
                                    "Defina NTM como similar à MT, mas com δ: Q × Γ → P(Q × Γ × {L,R}), onde P é o conjunto potências (múltiplas transições possíveis).",
                                    "Explique que de uma configuração, há um conjunto finito de configurações sucessoras.",
                                    "Discuta o 'ramo' ou 'caminho de computação' como uma sequência de configurações.",
                                    "Compare com MT: MT tem árvore de computação linear; NTM tem árvore ramificada.",
                                    "Implemente uma transição não-determinística simples em pseudocódigo."
                                  ],
                                  "verification": "Construa δ para um estado com 2 transições possíveis e liste as configurações resultantes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de aula sobre MT",
                                    "Editor de texto para pseudocódigo",
                                    "Ferramenta de desenho para árvores de computação"
                                  ],
                                  "tips": "Visualize como um grafo onde nós têm múltiplas arestas de saída.",
                                  "learningObjective": "Dominar a mudança de função para relação de transição.",
                                  "commonMistakes": [
                                    "Pensar que NTM executa todas ramificações simultaneamente (é modelo teórico).",
                                    "Confundir com paralelismo real."
                                  ]
                                },
                                {
                                  "stepNumber": "3",
                                  "title": "Definir formalmente configurações e evolução da computação",
                                  "subSteps": [
                                    "Defina configuração formal: (q, u, α, β) onde q estado, u posição cabeça, α esquerda da cabeça (invertida), β direita.",
                                    "Descreva sucessor imediato: para cada (p, s, D) em δ(q, símbolo sob cabeça), novas configs.",
                                    "Explique computação como árvore: raiz configuração inicial, folhas halting configs.",
                                    "Defina tempo de computação de uma ramificação: número de passos até halt.",
                                    "Calcule o número máximo de configurações em t passos (polinomial em |entrada|)."
                                  ],
                                  "verification": "Dada uma configuração inicial, liste todos sucessores em 2 passos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel quadriculado para simular fita",
                                    "Software JFLAP para NTM",
                                    "Referência formal (Hopcroft/Ullman)"
                                  ],
                                  "tips": "Use notação compacta para configs longas: ...α q σ β... onde σ sob cabeça.",
                                  "learningObjective": "Formalizar o 'espaço de busca' da NTM.",
                                  "commonMistakes": [
                                    "Ignorar inversão em α (lado esquerdo).",
                                    "Subestimar explosão exponencial de ramificações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever o processo de aceitação e relação com NP",
                                  "subSteps": [
                                    "Defina aceitação: NTM aceita w se existe ramificação que para em estado de F em ≤ p(|w|) passos, para polinomial p.",
                                    "Explique rejeição: todas ramificações param em não-F ou loop (mas assumimos sem loops para NP).",
                                    "Relacione com NP: L ∈ NP se existe NTM que decide L em tempo polinomial.",
                                    "Discuta verificación: 'adivinhador' não-determinístico resolve em tempo poly.",
                                    "Prove que SAT é em NP via NTM para verificar atribuições."
                                  ],
                                  "verification": "Escreva definição formal de L(NTM) e prove que tempo poly implica NP.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de problemas NP-completos",
                                    "Artigo sobre Cook-Levin",
                                    "Simulador NTM"
                                  ],
                                  "tips": "Enfatize 'existe ramificação aceitante' vs. 'todas aceitam'.",
                                  "learningObjective": "Conectar modelo NTM à classe de complexidade NP.",
                                  "commonMistakes": [
                                    "Confundir aceitação NTM com P (determinístico poly).",
                                    "Esquecer bound polinomial no tempo."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e praticar a descrição completa do modelo",
                                  "subSteps": [
                                    "Escreva a definição integral de NTM como 7-tupla com δ não-determinística.",
                                    "Descreva algoritmo conceitual de simulação: BFS na árvore até profundidade poly.",
                                    "Compare formalmente MT vs NTM em termos de poder e eficiência.",
                                    "Crie um exemplo completo: NTM para 3-SAT com não-determinismo na escolha de valores.",
                                    "Autoavalie sua descrição contra referências padrão."
                                  ],
                                  "verification": "Produza um relatório de 1 página descrevendo NTM formalmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Template de relatório",
                                    "Livros texto (Arora/Barak)",
                                    "Peer review opcional"
                                  ],
                                  "tips": "Use LaTeX para notação matemática se possível.",
                                  "learningObjective": "Capacitar descrição fluida e precisa do modelo.",
                                  "commonMistakes": [
                                    "Omitir detalhes como halting sem aceitação.",
                                    "Não especificar tempo polinomial na aceitação."
                                  ]
                                }
                              ],
                              "practicalExample": "Construa uma NTM para decidir se uma fórmula 3-SAT φ é satisfatível: não-determinísticamente gere uma atribuição de variáveis (ramificação por escolha true/false), então verifique em tempo linear se satisfaz φ, aceitando se sim.",
                              "finalVerifications": [
                                "Pode listar os 7 componentes exatos de uma NTM?",
                                "Descreve corretamente δ como relação finita?",
                                "Explica configurações com notação padrão?",
                                "Define aceitação como 'existe ramificação poly-time halting em F'?",
                                "Distingue NTM de MT e relaciona a NP?",
                                "Simula manualmente 3 passos de uma NTM simples?"
                              ],
                              "assessmentCriteria": [
                                "Precisão formal: uso correto de notação matemática (20%)",
                                "Completude: cobre transições, configs, aceitação (25%)",
                                "Clareza: explicação passo-a-passo sem ambiguidades (20%)",
                                "Correção conceitual: diferencia não-determinismo de paralelismo (20%)",
                                "Exemplos: inclui aplicação prática em NP (10%)",
                                "Profundidade: discute tempo polinomial e árvore de computação (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos (potências para transições), grafos (árvore de computação)",
                                "Lógica: Verificação de fórmulas booleanas (Cook-Levin)",
                                "Filosofia: Não-determinismo vs livre-arbítrio em modelos computacionais",
                                "Engenharia de Software: Modelagem de busca exaustiva em algoritmos de otimização"
                              ],
                              "realWorldApplication": "Modelagem de problemas de otimização combinatória como roteamento de veículos ou escalonamento de tarefas, onde o não-determinismo simula 'tentativa e erro' guess-and-check em solvers de SAT modernos como MiniSat."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.2.2",
                            "name": "Definir a linguagem NTIME(p(n))",
                            "description": "Explicar a classe de linguagens aceitas por NTM em tempo O(p(n)), onde p é polinomial, e relacioná-la com a classe NP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Máquinas de Turing Não-Determinísticas (NTM)",
                                  "subSteps": [
                                    "Lembre-se da definição formal de uma NTM: um septeto (Q, Σ, Γ, δ, q0, B, F) onde δ é uma relação não-determinística.",
                                    "Entenda o conceito de ramificações computacionais: a NTM pode 'escolher' transições múltiplas simultaneamente.",
                                    "Diferencie aceitação em NTM: uma entrada é aceita se existe pelo menos um caminho de computação que termina em estado de aceitação.",
                                    "Revise o tempo de execução de uma NTM: o comprimento máximo de qualquer caminho de computação.",
                                    "Pratique com um exemplo simples de NTM para linguagem {a^n b^n}."
                                  ],
                                  "verification": "Escreva uma definição precisa de NTM e dê um exemplo de transição não-determinística.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 7)",
                                    "Notas de aula sobre Autômatos Não-Determinísticos"
                                  ],
                                  "tips": "Visualize as ramificações como uma árvore de computação para entender a não-determinização.",
                                  "learningObjective": "Compreender os componentes e o comportamento básico de NTMs.",
                                  "commonMistakes": "Confundir NTM com DTM (determinística) ou ignorar que aceitação requer apenas um caminho aceitador."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Tempo de Execução Polinomial em NTMs",
                                  "subSteps": [
                                    "Defina formalmente o tempo de uma NTM M em uma entrada x: t_M(|x|) = máximo comprimento de configuração sobre todos os caminhos.",
                                    "Explique O(p(n)) onde p(n) é polinomial: existe c tal que t_M(n) ≤ p(n) para n ≥ c.",
                                    "Discuta por que o tempo é medido pelo pior caso entre ramificações.",
                                    "Compare com tempo determinístico: NTMs podem ser mais rápidas devido à não-determinização.",
                                    "Calcule o tempo para um exemplo: NTM para SAT com tempo O(n^k)."
                                  ],
                                  "verification": "Prove que uma NTM simples roda em tempo O(n^2) para uma linguagem específica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para desenhar configurações",
                                    "Ferramenta online como JFLAP para simular NTMs"
                                  ],
                                  "tips": "Lembre-se: o tempo é o da árvore de computação mais longa, não a soma.",
                                  "learningObjective": "Dominar a noção de tempo polinomial em contextos não-determinísticos.",
                                  "commonMistakes": "Medir tempo como soma de caminhos em vez de máximo; confundir com espaço."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Classe NTIME(p(n))",
                                  "subSteps": [
                                    "Defina NTIME(p(n)) = { L | existe NTM M que decide L e para todo x ∈ L, t_M(|x|) ≤ p(|x|) }.",
                                    "Especifique que p é uma função polinomial e que a NTM aceita corretamente (rejeita o resto em tempo polinomial).",
                                    "Mostre que NTIME é fechada sob união e concatenação polinomial.",
                                    "Discuta hierarquia: NTIME(p(n)) ⊆ NTIME(q(n)) se p(n) = o(q(n)).",
                                    "Escreva a definição matemática usando notação big-O."
                                  ],
                                  "verification": "Escreva a definição formal de NTIME(p(n)) e classifique uma linguagem exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de fórmulas de complexidade",
                                    "Artigo de Wikipedia sobre Classes de Tempo Não-Determinístico"
                                  ],
                                  "tips": "Use notação precisa: inclua tanto aceitação quanto rejeição em tempo polinomial.",
                                  "learningObjective": "Definir precisamente a linguagem NTIME(p(n)) com rigor formal.",
                                  "commonMistakes": "Esquecer que rejeição também deve ser em tempo polinomial; confundir com DTIME."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar NTIME(p(n)) com a Classe NP",
                                  "subSteps": [
                                    "Lembre que NP = ∪_{k≥1} NTIME(n^k), a união sobre todos polinômios.",
                                    "Prove que SAT ∈ NTIME(n^3) via redução do Teorema de Cook-Levin.",
                                    "Discuta P ⊆ NP: toda linguagem em P tem NTM trivial em tempo polinomial.",
                                    "Explique implicações para P vs NP: se P=NP, então hierarquias colapsam.",
                                    "Dê exemplos de linguagens presumidamente em NP mas não P."
                                  ],
                                  "verification": "Explique por que NP é definida como essa união e dê um exemplo de linguagem em NP.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Livro de Arora e Barak 'Computational Complexity' (Capítulo 5)",
                                    "Vídeo de aula sobre P vs NP"
                                  ],
                                  "tips": "Pense em 'certificados' curtos: NP como problemas verificáveis em tempo polinomial.",
                                  "learningObjective": "Conectar NTIME polinomial diretamente à definição de NP.",
                                  "commonMistakes": "Confundir NP com NTIME específico vs união; ignorar que NP requer tempo polinomial para verificação."
                                }
                              ],
                              "practicalExample": "Considere a linguagem SAT de fórmulas booleanas satisfatíveis. Construa uma NTM que adivinha uma atribuição (não-determinísticamente) e verifica em tempo O(n^3), mostrando SAT ∈ NTIME(n^3) ⊆ NP.",
                              "finalVerifications": [
                                "Definição correta de NTIME(p(n)) escrita formalmente.",
                                "Exemplo de NTM em tempo polinomial identificado e analisado.",
                                "Relação precisa entre NTIME(p(n)) e NP explicada.",
                                "Diferença entre tempo determinístico e não-determinístico compreendida.",
                                "Implicações para P vs NP discutidas.",
                                "Hierarquia de NTIME reconhecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão formal na definição de NTIME(p(n)) (exata vs aproximada).",
                                "Correta análise de tempo de execução em NTMs.",
                                "Conexão lógica e precisa com NP.",
                                "Uso apropriado de notação big-O e polinômios.",
                                "Capacidade de dar exemplos concretos e contra-exemplos.",
                                "Compreensão de propriedades de fechamento e hierarquias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Relações Não-Determinísticas.",
                                "Lógica: Equivalência com Verificadores Polinomiais no Teorema de Cook-Levin.",
                                "Filosofia da Computação: Discussões sobre P vs NP e decidibilidade.",
                                "Inteligência Artificial: Busca não-determinística em algoritmos de IA."
                              ],
                              "realWorldApplication": "Em verificação de software e otimização, problemas NP-completos como SAT são modelados com NTMs para provar dureza; usado em compiladores para análise de satisfatibilidade e em criptografia para demonstrar segurança baseada em NP."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.4.3",
                        "name": "Redução Polinomial no Teorema de Cook-Levin",
                        "description": "Construção da redução polinomial do problema de aceitação de NTM para SAT, provando que SAT é NP-completo.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.3.1",
                            "name": "Entender a ideia da redução Cook-Levin",
                            "description": "Compreender a estratégia de codificar uma computação possível de uma NTM em uma fórmula SAT que é satisfatível se e somente se a NTM aceita a entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de NTMs e SAT",
                                  "subSteps": [
                                    "Defina uma Máquina de Turing Não-Determinística (NTM), incluindo componentes: fita infinita, cabeçote, estados, função de transição não-determinística.",
                                    "Explique como uma NTM aceita uma entrada: existe pelo menos um caminho de computação que termina em estado de aceitação.",
                                    "Descreva o problema SAT: dada uma fórmula booleana em forma normal conjuntiva (CNF), existe uma atribuição de variáveis que a torna verdadeira?",
                                    "Entenda por que SAT está em NP e é NP-completo, justificando a necessidade de reduções.",
                                    "Compare NTMs com DTMs, destacando o poder não-determinístico."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando NTM e SAT, e liste 3 diferenças chave entre eles.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 2 e 7)",
                                    "Artigo da Wikipedia sobre 'Cook–Levin theorem'",
                                    "Vídeo Khan Academy ou YouTube sobre NP-completude"
                                  ],
                                  "tips": "Use diagramas para visualizar transições não-determinísticas de NTMs.",
                                  "learningObjective": "Dominar os pré-requisitos para entender a redução sem confusões conceituais.",
                                  "commonMistakes": [
                                    "Confundir aceitação de NTM (existe caminho) com DTM (único caminho)",
                                    "Achar que SAT é trivial de resolver (é NP-completo)",
                                    "Ignorar que fórmulas SAT devem estar em CNF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar Configurações Instantâneas da Computação",
                                  "subSteps": [
                                    "Defina uma configuração instantânea: tupla (estado, posição da cabeça, conteúdo da fita).",
                                    "Aprenda a representar a fita de forma finita para entradas de tamanho n, usando células limitadas (O(n + t), onde t é passos polinomiais).",
                                    "Introduza variáveis booleanas SAT: para cada timestep i (1 a T, polinomial), posição j, símbolo σ, estado q: variável V_{i,j,σ,q} indicando se nessa configuração a cabeça está em j lendo σ em estado q.",
                                    "Garanta que exatamente uma configuração por timestep: adicione cláusulas para exclusividade e exaustividade.",
                                    "Discuta por que isso captura todas as computações possíveis em tempo polinomial."
                                  ],
                                  "verification": "Desenhe as variáveis para uma NTM simples com 2 estados e entrada de tamanho 2, listando cláusulas para timestep 1.",
                                  "estimatedTime": "1.5-2 horas",
                                  "materials": [
                                    "Anotações do teorema Cook-Levin (pseudocódigo da prova)",
                                    "Ferramenta online como Logicly para simular SAT",
                                    "Papel e lápis para diagramas de configurações"
                                  ],
                                  "tips": "Pense nas variáveis como uma 'grade 4D' colapsada em booleanas para polinomialidade.",
                                  "learningObjective": "Saber codificar o 'espaço de estados' da NTM em variáveis SAT.",
                                  "commonMistakes": [
                                    "Usar representação infinita da fita (deve ser finita/polynomial)",
                                    "Esquecer cláusulas de 'exatamente uma' configuração por timestep",
                                    "Confundir posição da cabeça com conteúdo da fita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar Transições e Condições Iniciais/Final",
                                  "subSteps": [
                                    "Codifique transições: para cada timestep i, configuração C_i implica em C_{i+1} válida via função de transição da NTM (cláusulas para símbolos lidos, escritos, movimentos, mudanças de estado).",
                                    "Adicione cláusulas para condições iniciais: timestep 1 com entrada na fita, cabeça no início, estado inicial.",
                                    "Adicione cláusulas para aceitação: em algum timestep T, estado de aceitação, cabeça em posição de aceitação.",
                                    "Inclua cláusulas para não-sobreposição de cabeça e propagação de símbolos em branco.",
                                    "Verifique que o número total de cláusulas é polinomial em n."
                                  ],
                                  "verification": "Escreva cláusulas SAT para uma transição simples: δ(q0, 0) = (q1, 1, R).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplo detalhado da prova Cook-Levin em Sipser ou Arora/Barak",
                                    "Editor de texto para listar cláusulas CNF",
                                    "Solver SAT online como minisat para testar pequenas instâncias"
                                  ],
                                  "tips": "Comece com NTMs de 1 timestep para depurar cláusulas.",
                                  "learningObjective": "Construir as cláusulas que forçam uma computação válida da NTM.",
                                  "commonMistakes": [
                                    "Cláusulas erradas para não-determinismo (deve permitir branches, mas consistentes)",
                                    "Esquecer condições de aceitação ou iniciais",
                                    "Cláusulas não-polinomiais em tamanho"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender a Corretude da Redução",
                                  "subSteps": [
                                    "Prove 'se NTM aceita' => 'SAT satisfatível': construa atribuição das configurações do caminho aceitador.",
                                    "Prove 'SAT satisfatível' => 'NTM aceita': extraia o caminho de configurações da atribuição verdadeira.",
                                    "Discuta por que tudo é polinomial: variáveis e cláusulas O(T * posições * símbolos * estados), T polinomial.",
                                    "Aborde limitações: assume tempo polinomial bounded para NTM.",
                                    "Resuma a estratégia: 'adivinhar' o caminho não-determinístico via busca SAT."
                                  ],
                                  "verification": "Escreva as duas direções da bicondicional em pseudoprova.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Prova formal do teorema em paper original de Cook (1971)",
                                    "Resumo em blog como Scott Aaronson ou StackExchange CS Theory"
                                  ],
                                  "tips": "Use setas para mapear 'satisfatível -> aceita' visualmente.",
                                  "learningObjective": "Internalizar por que a redução preserva NP.",
                                  "commonMistakes": [
                                    "Ignorar bound polinomial no tempo da NTM",
                                    "Confundir 'existe atribuição' com 'todos caminhos aceitam'",
                                    "Não provar ambas direções"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma NTM M que aceita {w | w tem comprimento par}: configurações codificam contagem de símbolos par via transições que 'andam' pela fita. Cláusulas iniciais: fita = w#blanks, q0 na posição 1. Transições: ler 0/1, mover R, alternar estado par/impar. Aceitação se q_accept após |w| passos. SAT satisfatível iff existe paridade correta.",
                              "finalVerifications": [
                                "Explique em 1 minuto a ideia principal sem notas.",
                                "Liste 5 variáveis booleanas chave e seu significado.",
                                "Descreva cláusulas para uma transição específica.",
                                "Prove intuitivamente uma direção da bicondicional.",
                                "Identifique por que é redução polinomial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de configurações e variáveis SAT (sem erros lógicos).",
                                "Correta codificação de transições CNF (polinomial e completa).",
                                "Compreensão clara da bicondicional (aceita <=> satisfatível).",
                                "Uso correto de termos técnicos (NTM, timestep, CNF).",
                                "Capacidade de aplicar a um exemplo simples sem ajuda."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e teoria de modelos.",
                                "Filosofia: Limites da computação e decidibilidade.",
                                "Engenharia: Verificação formal de software (model checking).",
                                "Física: Computação quântica e simulações NP."
                              ],
                              "realWorldApplication": "Provas de NP-completude guiam algoritmos de otimização em IA (ex: SAT solvers em planejamento de rotas, scheduling, verificação de hardware VLSI), criptografia (problemas hard assumidos NP-difíceis) e bioinformática (folding de proteínas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.3.2",
                            "name": "Construir a fórmula booleana para configurações",
                            "description": "Codificar sequências de configurações da NTM usando tabelas de verdade booleanas para posições da fita, estado e cabeça de leitura/escrita em tempo polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Encoding de Variáveis Booleanas para Configurações da NTM",
                                  "subSteps": [
                                    "Revise a estrutura de uma configuração de NTM: posição da cabeça (h), estado atual (q), símbolos na fita (σ_i para cada célula i).",
                                    "Defina o número de timestep t de 0 a p(n)^2, onde p(n) é o tempo polinomial da NTM.",
                                    "Crie variáveis booleanas: Para cada t, i (posição da fita), use variáveis para estado H_{t,i,k} (cabeça em i no tempo t no estado k), S_{t,i,s} (símbolo s em i no tempo t), Q_{t,i,q} (estado q em i no tempo t).",
                                    "Use tabelas de verdade para representar combinações: exatamente um estado, um símbolo e uma posição da cabeça por timestep.",
                                    "Garanta que o encoding seja polinomial: número de variáveis O(p(n)^4 * |Q| * |Σ|)."
                                  ],
                                  "verification": "Liste todas as variáveis booleanas para uma NTM de exemplo com 2 estados, 2 símbolos e fita de tamanho 3 em 2 timesteps.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Referência ao teorema de Cook-Levin",
                                    "Exemplo de NTM simples"
                                  ],
                                  "tips": "Comece com uma NTM mínima para visualizar; use log2 para calcular bits necessários se aplicável.",
                                  "learningObjective": "Compreender e definir precisamente o encoding booleano de configurações de NTM em tempo polinomial.",
                                  "commonMistakes": [
                                    "Esquecer de codificar exatamente uma cabeça por timestep",
                                    "Não limitar i e t ao polinomial",
                                    "Confundir símbolos de fita com estados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Fórmula Booleana para a Configuração Inicial (t=0)",
                                  "subSteps": [
                                    "Especifique cláusulas para a entrada na fita: S_{0,i,u} verdadeiro se u é o símbolo da entrada na posição i.",
                                    "Defina posição inicial da cabeça: H_{0,0,q0} verdadeiro para estado inicial q0 na posição 0.",
                                    "Adicione cláusulas de exclusividade: Para cada i, exatamente um S_{0,i,s}; exatamente um Q_{0,h,q} para cabeça em h.",
                                    "Inclua cláusulas de unicidade: ∑_k H_{0,i,k} = 1 para cada i; ∑_s S_{0,i,s} = 1.",
                                    "Converta para CNF usando tabelas de verdade para cada combinação inválida."
                                  ],
                                  "verification": "Escreva a fórmula CNF para configuração inicial de uma entrada '01' com NTM de 2 símbolos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora para tabelas de verdade",
                                    "Ferramenta de lógica booleana online (opcional)",
                                    "Diagrama de NTM"
                                  ],
                                  "tips": "Use a forma 'pelo menos um' e 'no máximo um' para cardinalidade 1.",
                                  "learningObjective": "Codificar logicamente a configuração inicial usando cláusulas SAT.",
                                  "commonMistakes": [
                                    "Não tratar padding da fita com blanks",
                                    "Esquecer cláusulas de 'exatamente um'",
                                    "Usar DNF em vez de CNF"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Fórmulas Booleanas para Transições entre Configurações Consecutivas",
                                  "subSteps": [
                                    "Para cada t de 0 a T-1, defina transições baseadas na função δ da NTM: se em (q,σ) -> (q',σ',D), codifique isso.",
                                    "Crie cláusulas para leitura: símbolo lido σ = S_{t,h,σ} onde h é posição da cabeça H_{t,h,q}.",
                                    "Cláusulas para escrita e movimento: S_{t+1,h,σ'} se escrita σ'; mover cabeça para h+D.",
                                    "Estado novo: Q_{t+1,h',q'} verdadeiro.",
                                    "Garanta consistência: símbolos não lidos permanecem iguais; cabeça move corretamente."
                                  ],
                                  "verification": "Gere cláusulas de transição para uma regra δ(q0,0)=(q1,1,R) em posições específicas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Tabela de transição da NTM",
                                    "Folhas para CNF",
                                    "Exemplos de reduções Cook-Levin"
                                  ],
                                  "tips": "Visualize com diagramas de fita antes de booleanizar; teste com timestep único.",
                                  "learningObjective": "Modelar as regras de transição da NTM como restrições booleanas satisfatíveis.",
                                  "commonMistakes": [
                                    "Não copiar símbolos em células não afetadas",
                                    "Erro em direção da cabeça (L/R)",
                                    "Cláusulas incompletas para não-determinismo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir a Configuração Final de Aceitação e Combinar a Fórmula Completa",
                                  "subSteps": [
                                    "Para t=T, adicione cláusulas para aceitação: existe h tal que H_{T,h,q_accept}.",
                                    "Garanta que fita final seja válida (não necessário para aceitação, mas inclua consistência).",
                                    "Una todas as fórmulas: INIT ∧ ∀t TRANS(t,t+1) ∧ ACCEPT.",
                                    "Verifique tamanho polinomial: número de cláusulas O(p(n)^4 * |δ|).",
                                    "Teste satisfatibilidade conceitual para entrada aceita/rejeitada."
                                  ],
                                  "verification": "Escreva a fórmula completa para uma NTM que aceita strings vazias.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Resumo das fórmulas anteriores",
                                    "Solver SAT online para validação pequena"
                                  ],
                                  "tips": "Mantenha T = p(n)^2 para cobrir todas computações não-determinísticas.",
                                  "learningObjective": "Completar a redução SAT para NTM via fórmulas de configuração.",
                                  "commonMistakes": [
                                    "Definir T muito pequeno",
                                    "Esquecer cláusulas de aceitação",
                                    "Não conjugar todas as partes"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma NTM M que aceita {0} em 2 passos: t=0: cabeça em 0, estado q0, fita '0#...'; lê 0, escreve #, move R para q1. t=1: aceita. Encoding: Variáveis H_{0,0,q0}, S_{0,0,0}=true; cláusulas transição para S_{1,0,#}, H_{1,1,q1}, H_{2,1,q_acc}=true.",
                              "finalVerifications": [
                                "Codificar corretamente variáveis para uma NTM com 3 estados e fita tamanho 4.",
                                "Gerar CNF válida para configuração inicial de entrada '101'.",
                                "Derivar cláusulas de transição para todas regras δ da NTM.",
                                "Verificar que fórmula completa é satisfatível apenas se NTM aceita.",
                                "Calcular número polinomial de variáveis e cláusulas.",
                                "Explicar por que o encoding captura todas computações não-determinísticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no encoding de variáveis (exclusividade e cobertura).",
                                "Corretude das cláusulas CNF para init, trans e accept.",
                                "Demonstração de tamanho polinomial na redução.",
                                "Capacidade de lidar com não-determinismo via SAT.",
                                "Clareza na derivação de tabelas de verdade.",
                                "Ausência de erros comuns como inconsistências na cabeça."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Lógica proposicional e CNF.",
                                "Algoritmos: Verificação de NP-completude.",
                                "Lógica: Tabelas de verdade e satisfatibilidade.",
                                "Física Computacional: Modelos de computação quântica semelhantes."
                              ],
                              "realWorldApplication": "Essa redução é fundamental para solvers SAT modernos usados em verificação de hardware (e.g., Intel), otimização de circuitos VLSI, planejamento de software e prova de teoremas automáticos em IA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.3.3",
                            "name": "Verificar propriedades da redução",
                            "description": "Provar que a redução é polinomial e preserva a aceitação: SAT satisfatível iff NTM aceita, incluindo cláusulas para início, passo e aceitação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a complexidade polinomial da construção da instância NTM",
                                  "subSteps": [
                                    "Examinar a fórmula SAT φ com m cláusulas e n variáveis.",
                                    "Descrever a construção da fita da NTM: histórico de configurações com tamanho O(m² n²).",
                                    "Contar o número de símbolos e estados na NTM derivados de φ.",
                                    "Calcular o tempo de construção: polinomial em |φ|.",
                                    "Verificar que o comprimento da fita inicial é O(poly(|φ|))."
                                  ],
                                  "verification": "Construir explicitamente para uma φ pequena e medir tamanhos; confirmar todos são O(|φ|^k) para k constante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, fórmula SAT de exemplo, livro de teoria da computação (Sipser ou Arora-Barak).",
                                  "tips": "Use notação big-O rigorosa; foque no histórico quadrático como bottleneck principal.",
                                  "learningObjective": "Compreender por que a redução é polinomial apesar da simulação universal.",
                                  "commonMistakes": "Confundir tempo de redução com tempo de execução da NTM; ignorar dependência quadrática em m."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar cláusulas de início e configuração inicial",
                                  "subSteps": [
                                    "Confirmar cláusula inicial: cabeça em posição inicial, estado q0, fita com símbolos de entrada.",
                                    "Verificar que a cláusula de início força a configuração inicial válida apenas se φ tem atribuição inicial.",
                                    "Provar que SAT satisfazível permite configuração inicial aceitável.",
                                    "Garantir ausência de configurações inválidas iniciais.",
                                    "Analisar propagação para o primeiro passo."
                                  ],
                                  "verification": "Substituir cláusulas iniciais na SAT e checar tautologia para configurações válidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto para fórmulas lógicas, calculadora simbólica.",
                                  "tips": "Desenhe a fita inicial diagramaticamente para visualizar.",
                                  "learningObjective": "Dominar como cláusulas codificam condições iniciais exatas da NTM.",
                                  "commonMistakes": "Esquecer símbolos de padding ou posições exatas da cabeça."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar cláusulas de passo da simulação",
                                  "subSteps": [
                                    "Analisar cláusulas de transição: para cada célula, cabeça e estado, impor regra de transição.",
                                    "Verificar cláusulas de movimento da cabeça (esquerda/direita/fica).",
                                    "Confirmar que exatamente uma transição ocorre por timestep.",
                                    "Provar que caminhos válidos simulam computação legítima da NTM.",
                                    "Checar que passos preservam aceitação parcial."
                                  ],
                                  "verification": "Simular um passo manualmente e verificar se cláusulas o permitem unicamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha para tabelas de transição, exemplos de NTM simples.",
                                  "tips": "Use tabelas para mapear transições; conte axiomas de 'exatamente um'.",
                                  "learningObjective": "Entender codificação local de computação global via cláusulas.",
                                  "commonMistakes": "Permitir múltiplas transições simultâneas; ignorar carry-over entre células."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar cláusulas de aceitação e prova de preservação iff",
                                  "subSteps": [
                                    "Examinar cláusula de aceitação: estado final em posição específica.",
                                    "Provar direção =>: SAT satisfazível → NTM aceita via caminho válido.",
                                    "Provar direção <=: NTM aceita → SAT satisfazível por extração de atribuições.",
                                    "Confirmar que rejeição corresponde a insatisfatibilidade.",
                                    "Integrar todas cláusulas para completude."
                                  ],
                                  "verification": "Escrever prova formal bidirecional; testar com SAT trivial (verdadeiro/falso).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel para provas, software SAT solver para validação.",
                                  "tips": "Estruture prova como lema1 (=>) e lema2 (<=); use contrapositiva para rejeição.",
                                  "learningObjective": "Masterizar argumento de correção da redução Cook-Levin.",
                                  "commonMistakes": "Confundir aceitação não-determinística com determinística; falhar em extrair witness."
                                }
                              ],
                              "practicalExample": "Para φ = (x1 ∨ ¬x2 ∨ x3) ∧ (¬x1 ∨ x2 ∨ ¬x3), construa NTM M_φ com fita de histórico para 2 passos. Verifique cláusulas iniciais forçam q0 na posição 1, passos simulam verificação de cláusulas via atribuições x1=1, x2=0, x3=1, e aceitação em timestep 2.",
                              "finalVerifications": [
                                "Tamanho da instância NTM é O(|φ|^4).",
                                "Cláusulas iniciais permitem apenas configuração q0 válida.",
                                "Todo caminho válido simula computação NTM legítima.",
                                "SAT satisfazível iff existe aceitação em timestep polinomial.",
                                "Nenhuma configuração inválida satisfaz todas cláusulas."
                              ],
                              "assessmentCriteria": [
                                "Prova correta de polinomialidade com análise de graus.",
                                "Descrição precisa de todas cláusulas (início, passo, aceitação).",
                                "Argumento bidirecional iff sem falhas lógicas.",
                                "Exemplo prático resolvido com cálculos explícitos.",
                                "Identificação de erros comuns e contraexemplos."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Proposicional: Codificação de transições via CNF.",
                                "Matemática Discreta: Contagem polinomial e indução em passos.",
                                "Teoria dos Autômatos: Simulação universal de NTMs.",
                                "Prova Formal: Lemas e contrapositivas em complexidade."
                              ],
                              "realWorldApplication": "Usado em provas de NP-completude para otimização (ex: SAT solvers em VLSI design verificam reduções para circuitos satisfatibilidade); fundamenta approximability em scheduling e criptografia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.3.4",
                            "name": "Aplicar o teorema para NP-completude",
                            "description": "Concluir que SAT é NP-completo pelo Teorema de Cook-Levin, pois todo problema em NP reduz polinomialmente a SAT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Enunciado do Teorema de Cook-Levin",
                                  "subSteps": [
                                    "Leia e memorize o enunciado exato do Teorema de Cook-Levin: todo problema de decisão em NP pode ser reduzido em tempo polinomial a uma instância do problema SAT.",
                                    "Identifique os componentes chave: problemas em NP, redução polinomial e SAT como problema-alvo.",
                                    "Anote as implicações: SAT serve como um 'problema universal' para NP.",
                                    "Compare com outros teoremas de completude para fixar o contexto histórico.",
                                    "Discuta em voz alta ou escreva uma paráfrase para reforçar a compreensão."
                                  ],
                                  "verification": "Escreva o teorema de memória e verifique contra uma fonte confiável; deve ser preciso em 90%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de teoria da computação (ex: Sipser), notas de aula, papel e caneta"
                                  ],
                                  "tips": "Use analogias como 'SAT é o 'idioma universal' de NP' para memorizar.",
                                  "learningObjective": "Enunciar corretamente o Teorema de Cook-Levin e suas implicações principais.",
                                  "commonMistakes": "Confundir com o Teorema de Rice ou achar que é sobre P=NP."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar que SAT Pertence à Classe NP",
                                  "subSteps": [
                                    "Defina formalmente o problema SAT: dada uma fórmula booleana em CNF, existe uma atribuição que a satisfaz?",
                                    "Construa um certificado para SAT: uma atribuição de variáveis verdadeiras/falsas.",
                                    "Mostre que o verificador polinomial aceita certificados válidos em tempo polinomial (O(n) onde n é o tamanho da fórmula).",
                                    "Esboce um pseudocódigo para o verificador de SAT.",
                                    "Teste com uma fórmula pequena para validar."
                                  ],
                                  "verification": "Implemente ou descreva um verificador que rode em tempo polinomial para uma instância de SAT.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de texto ou Python para pseudocódigo, exemplos de fórmulas CNF"
                                  ],
                                  "tips": "Lembre-se: NP requer verificação rápida, não solução rápida.",
                                  "learningObjective": "Provar formalmente que SAT ∈ NP.",
                                  "commonMistakes": "Esquecer que SAT deve ser em forma CNF normalizada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Reduções Polinomiais no Contexto do Teorema",
                                  "subSteps": [
                                    "Defina redução polinomial: função f computável em tempo polinomial tal que x ∈ L1 iff f(x) ∈ L2.",
                                    "Estude a prova do Cook-Levin: como uma máquina de Turing não-determinística é codificada em uma fórmula SAT.",
                                    "Identifique passos da construção: simular computação em passos lineares, variáveis para cada célula/tempo/cabeça.",
                                    "Trace a redução para um exemplo simples como o problema de Hamiltoniano.",
                                    "Calcule o tempo polinomial da redução (O(n^2) tipicamente)."
                                  ],
                                  "verification": "Descreva os passos principais da construção da redução para um problema em NP.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Artigo original de Cook-Levin ou capítulo de livro, diagramas de MT para SAT"
                                  ],
                                  "tips": "Desenhe diagramas da 'fita de computação' para visualizar a redução.",
                                  "learningObjective": "Entender e reproduzir os elementos chave da redução polinomial no teorema.",
                                  "commonMistakes": "Confundir redução com mapeamento exponencial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema para Concluir NP-Completude de SAT",
                                  "subSteps": [
                                    "Reúna: SAT ∈ NP (do step 2) e todo L ∈ NP reduz a SAT (teorema).",
                                    "Formalize: SAT é NP-duro porque aceita reduções de todos em NP; logo NP-completo.",
                                    "Escreva a prova completa em notação formal.",
                                    "Discuta consequências: implicações para P vs NP.",
                                    "Teste a conclusão respondendo: 'Por que SAT é o primeiro problema NP-completo?'"
                                  ],
                                  "verification": "Escreva uma prova concisa de 1 página provando NP-completude de SAT.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel, referências teóricas"
                                  ],
                                  "tips": "Estruture como: Premissa 1 + Premissa 2 → Conclusão.",
                                  "learningObjective": "Concluir logicamente a NP-completude de SAT usando o teorema.",
                                  "commonMistakes": "Omitir prova de SAT ∈ NP ou inverter dureza/completude."
                                }
                              ],
                              "practicalExample": "Reduza o problema de Clique (encontrar subgrafo completo de tamanho k) para SAT: codifique vértices e arestas em variáveis booleanas, crie cláusulas CNF para garantir exatamente k vértices selecionados e todas as arestas presentes entre eles. Verifique que a redução é polinomial.",
                              "finalVerifications": [
                                "Enuncie o Teorema de Cook-Levin sem erros.",
                                "Prove SAT ∈ NP com um verificador explícito.",
                                "Descreva a construção de redução para um problema exemplo.",
                                "Escreva a prova completa de NP-completude de SAT.",
                                "Explique por que isso implica que SAT é 'universal' para NP.",
                                "Identifique 2 problemas NP-completos derivados de SAT."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado do teorema (100% correto).",
                                "Correta demonstração de SAT ∈ NP com análise de tempo.",
                                "Descrição detalhada e correta da redução polinomial.",
                                "Lógica impecável na conclusão de NP-completude.",
                                "Uso apropriado de notação formal e exemplos.",
                                "Profundidade nas implicações teóricas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e teoria dos modelos.",
                                "Filosofia: Questões de decidibilidade e limites do conhecimento.",
                                "Engenharia de Software: Verificação formal de programas.",
                                "Inteligência Artificial: Limites de solvers de SAT em otimização."
                              ],
                              "realWorldApplication": "Em verificação de hardware/software (usando SAT solvers como Z3 para provar propriedades), otimização de circuitos lógicos e planejamento em IA, onde entender NP-completude guia escolhas entre algoritmos exatos e heurísticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.5",
                    "name": "Reduções Polinomiais",
                    "description": "Método para transformar um problema em outro em tempo polinomial, provando equivalência de dificuldade computacional.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.5.1",
                        "name": "Definição Formal de Redução Polinomial",
                        "description": "Conceito fundamental que define uma redução polinomial como uma transformação computável em tempo polinomial de instâncias de um problema A para instâncias de um problema B, preservando a resposta sim/não.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.1.1",
                            "name": "Enunciar a definição formal de redução polinomial",
                            "description": "Explicar precisamente o que é uma redução polinomial entre dois problemas de decisão, incluindo os requisitos de tempo polinomial e preservação da solucionabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Problemas de Decisão",
                                  "subSteps": [
                                    "Defina o que é um problema de decisão em computação.",
                                    "Explique o conceito de linguagem formal associada a um problema de decisão.",
                                    "Diferencie entre instâncias 'sim' e 'não' em problemas de decisão.",
                                    "Identifique exemplos clássicos como SAT e HALTING.",
                                    "Entenda o papel das máquinas de Turing na formalização."
                                  ],
                                  "verification": "Escreva definições curtas para problema de decisão e linguagem, e liste 3 exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre teoria da computação",
                                    "Livro 'Sipser - Introdução à Teoria da Computação' (Capítulo 7)"
                                  ],
                                  "tips": "Use diagramas para visualizar instâncias 'sim' vs 'não'.",
                                  "learningObjective": "Compreender a base formal para reduções.",
                                  "commonMistakes": [
                                    "Confundir problemas de decisão com problemas de otimização",
                                    "Ignorar o papel das máquinas de Turing determinísticas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Reduções em Geral",
                                  "subSteps": [
                                    "Defina redução many-one e Turing em teoria da computação.",
                                    "Explique como uma redução preserva a solucionabilidade (x em A iff f(x) em B).",
                                    "Discuta o propósito das reduções: relacionar dificuldades de problemas.",
                                    "Compare reduções computáveis com reduções polinomiais.",
                                    "Pratique com um exemplo simples não-polinomial."
                                  ],
                                  "verification": "Descreva uma redução many-one entre dois problemas triviais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo Khan Academy sobre reduções",
                                    "Folha de exercícios sobre reduções básicas"
                                  ],
                                  "tips": "Pense em reduções como 'tradutores' entre problemas.",
                                  "learningObjective": "Dominar o conceito genérico de redução antes do polinomial.",
                                  "commonMistakes": [
                                    "Confundir preservação de solucionabilidade com equivalência exata",
                                    "Esquecer a direção da redução (A ≤ B significa A é 'mais fácil' que B)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Requisitos de Tempo Polinomial",
                                  "subSteps": [
                                    "Defina tempo polinomial em máquinas de Turing (O(n^k) para k constante).",
                                    "Explique por que o tempo polinomial é crucial para classes como P e NP.",
                                    "Discuta funções polinomiais f: Σ* → Σ* computáveis em tempo polinomial.",
                                    "Verifique como |f(x)| deve ser polinomial em |x|.",
                                    "Analise impacto em problemas NP."
                                  ],
                                  "verification": "Calcule o tempo polinomial para uma função f simples, como codificação binária.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou simulador de complexidade",
                                    "Artigo Wikipedia sobre Reduções Polinomiais"
                                  ],
                                  "tips": "Lembre-se: polinomial significa 'eficiente' para propósitos de complexidade.",
                                  "learningObjective": "Entender o aspecto temporal da redução polinomial.",
                                  "commonMistakes": [
                                    "Confundir tempo polinomial com espaço polinomial",
                                    "Achar que qualquer função computável é polinomial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enunciar e Memorizar a Definição Formal",
                                  "subSteps": [
                                    "Escreva a definição: A ≤_p B se existe f polinomial tal que x ∈ A iff f(x) ∈ B.",
                                    "Inclua formalmente: f computável por TM em tempo polinomial.",
                                    "Pratique reescrevendo a definição em suas próprias palavras.",
                                    "Compare com definições de livros-texto (ex: Sipser, Arora-Barak).",
                                    "Teste com flashcards para memorização."
                                  ],
                                  "verification": "Enuncie a definição completa sem consultar notas e explique cada parte.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Flashcards Anki com definição",
                                    "Exemplos de reduções polinomiais (SAT para 3SAT)"
                                  ],
                                  "tips": "Use mnemônicos: 'Poly-time f preserves membership'.",
                                  "learningObjective": "Capacitar-se a enunciar precisamente a definição formal.",
                                  "commonMistakes": [
                                    "Omitir 'tempo polinomial' ou 'preservação iff'",
                                    "Esquecer que f deve ser total e definida para todas entradas"
                                  ]
                                }
                              ],
                              "practicalExample": "Redução polinomial de VERTEX-COVER para INDEPENDENT-SET: Dada uma grafo G e k, construa G' = complemento de G e use k' = n - k, onde n é número de vértices. Essa f é computável em O(n^2) tempo e preserva solucionabilidade.",
                              "finalVerifications": [
                                "Enuncie a definição sem erros em menos de 1 minuto.",
                                "Explique 'preservação da solucionabilidade' com um diagrama.",
                                "Identifique se uma dada função f é uma redução polinomial válida.",
                                "Distinga redução polinomial de redução exponencial.",
                                "Aplique a definição a um exemplo real como CIRCUIT-SAT para SAT.",
                                "Responda corretamente a 5 perguntas de quiz sobre a definição."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inclusão de tempo polinomial e preservação iff (obrigatório).",
                                "Clareza na distinção entre problemas de decisão A e B.",
                                "Capacidade de formalizar com notação matemática (≤_p, TM polinomial).",
                                "Exemplificação correta sem ambiguidades.",
                                "Ausência de omissões chave como computabilidade total de f.",
                                "Fluência na explicação verbal ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções polinomiais e teoria dos conjuntos.",
                                "Lógica: Preservação de verdades booleanas em problemas de decisão.",
                                "Filosofia da Ciência: Analogia com reduções experimentais em física.",
                                "Engenharia de Software: Refatoração de problemas complexos em módulos simples."
                              ],
                              "realWorldApplication": "Em provas de NP-completude para otimizar algoritmos em IA, como planejamento de rotas (TSP) ou alocação de recursos em cloud computing, onde reduções polinomiais ajudam a transferir soluções conhecidas para novos problemas práticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.5.1.2",
                            "name": "Identificar componentes de uma redução polinomial",
                            "description": "Reconhecer e descrever os elementos chave de uma redução: função de mapeamento f, verificador polinomial e relação com classes de complexidade como P e NP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal de Redução Polinomial",
                                  "subSteps": [
                                    "Leia a definição formal: Uma redução polinomial de L1 para L2 é uma função f computável em tempo polinomial tal que x ∈ L1 iff f(x) ∈ L2.",
                                    "Identifique os elementos principais: linguagem origem L1, linguagem destino L2, função f e o verificador implícito.",
                                    "Anote a condição de preservação: aceitação/rejeição deve ser preservada.",
                                    "Compare com transformações não-polinomiais para destacar a restrição de tempo.",
                                    "Desenhe um diagrama de fluxo mostrando L1 -> f -> L2."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo da definição e circule os componentes chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de complexidade (ex: Sipser), papel e caneta, diagrama em branco"
                                  ],
                                  "tips": "Use cores diferentes para destacar f, L1 e L2 no diagrama.",
                                  "learningObjective": "Compreender a estrutura geral de uma redução polinomial.",
                                  "commonMistakes": [
                                    "Confundir redução com simulação direta",
                                    "Ignorar a restrição polinomial",
                                    "Esquecer a bicondicional iff"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Função de Mapeamento f",
                                  "subSteps": [
                                    "Defina f: Deve ser computável em tempo polinomial e preservar membership.",
                                    "Examine propriedades: |f(x)| deve ser polinomial em |x|, e tempo de computação O(|x|^k).",
                                    "Identifique entrada/saída: f recebe instância de L1 e produz instância válida de L2.",
                                    "Verifique exemplos: Para x em L1, f(x) em L2; senão, não.",
                                    "Pratique codificando um f simples em pseudocódigo."
                                  ],
                                  "verification": "Escreva pseudocódigo para f em uma redução conhecida e verifique tempo polinomial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto, exemplos de reduções (ex: SAT para 3-COLORING)"
                                  ],
                                  "tips": "Sempre inclua análise de complexidade: conte operações e tamanho de saída.",
                                  "learningObjective": "Reconhecer o papel e propriedades da função f.",
                                  "commonMistakes": [
                                    "Assumir f é bijetora",
                                    "Não verificar tamanho polinomial da saída",
                                    "Confundir f com algoritmo de decisão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar o Verificador Polinomial",
                                  "subSteps": [
                                    "Entenda o verificador: Máquina polinomial V que decide L2 em tempo polinomial.",
                                    "Conecte com f: V(f(x)) aceita iff x em L1.",
                                    "Discuta composição: Tempo total V ∘ f é polinomial.",
                                    "Diferencie de resolvedor: Verificador só checa sim/não, não resolve.",
                                    "Liste requisitos: V deve rodar em O(n^k) para instâncias f(x)."
                                  ],
                                  "verification": "Descreva como V interage com f em uma frase por componente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre NP e verificadores",
                                    "Máquina de Turing simulador opcional"
                                  ],
                                  "tips": "Pense em V como um 'juiz' que valida a transformação f.",
                                  "learningObjective": "Identificar e descrever o verificador na redução.",
                                  "commonMistakes": [
                                    "Confundir verificador com resolvedor completo",
                                    "Ignorar composição de tempos",
                                    "Esquecer que V é para L2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Classes P e NP",
                                  "subSteps": [
                                    "Revise P: Decidível em tempo polinomial.",
                                    "Revise NP: Verificável em tempo polinomial.",
                                    "Explique implicação: Se L1 reduz para L2 e L2 em P, então L1 em P.",
                                    "Discuta NP-completude: Reduções mostram equivalência.",
                                    "Aplique: Redução polinomial preserva inclusão em P/NP."
                                  ],
                                  "verification": "Responda: 'Se A reduz para B em P, o que isso diz sobre A?'",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de classes de complexidade",
                                    "Exemplos de problemas NP-completos"
                                  ],
                                  "tips": "Use setas: L1 ≤p L2 implica hardness de L1 ≤ L2.",
                                  "learningObjective": "Compreender implicações para P e NP.",
                                  "commonMistakes": [
                                    "Confundir redução com inclusão direta",
                                    "Ignorar direção da redução",
                                    "Esquecer que P ⊆ NP"
                                  ]
                                }
                              ],
                              "practicalExample": "Na redução de 3-SAT para Vertex Cover: f transforma fórmula φ em grafo G onde vértices são literais/cláusulas, arestas evitam conflitos; verificador V checa se cover cobre cláusulas; se φ satisfazível, cover de tamanho |cláusulas| existe, relacionando ambos a NP.",
                              "finalVerifications": [
                                "Liste os 3 componentes principais de uma redução polinomial.",
                                "Dada uma descrição, identifique f e V corretamente.",
                                "Explique por que reduções preservam P/NP.",
                                "Desenhe diagrama de redução com labels.",
                                "Diferencie redução de simulação direta.",
                                "Verifique tempo polinomial em um exemplo dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de f, V e relação P/NP (40%)",
                                "Detalhes nos subcomponentes e propriedades (30%)",
                                "Uso correto de terminologia técnica (15%)",
                                "Capacidade de aplicar em exemplo prático (10%)",
                                "Clareza em diagramas e explicações (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria das funções e composição polinomial.",
                                "Lógica: Verificadores como provas em lógica proposicional.",
                                "Filosofia: Questões de decidibilidade e limites computacionais.",
                                "Engenharia de Software: Design de transformações em compiladores."
                              ],
                              "realWorldApplication": "Em otimização de software, reduções polinomiais ajudam a transformar problemas de scheduling (NP-duro) para problemas gráficos solucionáveis heuristicamente, como em roteirização de entregas ou alocação de recursos em data centers."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.5.1.3",
                            "name": "Diferenciar reduções polinomiais de outras transformações",
                            "description": "Comparar reduções polinomiais com reduções logspace ou exponenciais, destacando por que o tempo polinomial é crucial para provas de NP-completude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal de Redução Polinomial",
                                  "subSteps": [
                                    "Ler a definição formal: Uma linguagem L1 reduz polinomialmente para L2 se existe f computável em tempo polinomial tal que x ∈ L1 ⇔ f(x) ∈ L2 e |f(x)| é polinomial em |x|.",
                                    "Analisar componentes: máquina determinística em tempo O(n^k), preservação de sim/não.",
                                    "Estudar exemplos canônicos como 3SAT → Clique ou Vertex Cover → Clique.",
                                    "Verificar propriedades: f deve ser de string para string, injetiva não necessária mas útil.",
                                    "Praticar reescrevendo a definição em pseudocódigo."
                                  ],
                                  "verification": "Escrever a definição em palavras próprias e dar um exemplo simples sem consultar materiais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Cap. 7)",
                                    "Notas de aula sobre complexidade P vs NP",
                                    "Ferramenta online como Complexity Zoo"
                                  ],
                                  "tips": "Enfatize o 'polinomial' em tempo e tamanho; ignore reduções não-efetivas.",
                                  "learningObjective": "Compreender precisamente os requisitos de uma redução polinomial válida.",
                                  "commonMistakes": "Confundir redução polinomial com mapeamento arbitrário ou aproximação; esquecer a bicondicional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Reduções Logspace e Exponenciais",
                                  "subSteps": [
                                    "Definir redução logspace (L): f computável por máquina Turing com O(log n) espaço.",
                                    "Comparar com polinomial: logspace ⊆ polinomial, mas mais restritiva.",
                                    "Estudar redução exponencial: f computável em tempo 2^{O(n^k)}, usada em contextes como EXP-completude.",
                                    "Exemplos: Redução logspace para problemas em NL como PATH → STCONN; exponencial para problemas em EXP.",
                                    "Diferenciar classes: P-reduções para NP, L para NL, EXP para EXP."
                                  ],
                                  "verification": "Listar 3 diferenças chave entre L e P reduções, com exemplos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel 'Logspace reductions' de Wikipedia",
                                    "Livro 'Computational Complexity' de Arora e Barak (Cap. 3)",
                                    "Simulador de MT online"
                                  ],
                                  "tips": "Lembre que logspace não usa fita auxiliar ilimitada; foque em restrições de recursos.",
                                  "learningObjective": "Identificar definições e exemplos de reduções não-polinomiais.",
                                  "commonMistakes": "Achar que logspace é 'mais fácil' que polinomial (na verdade, é mais forte); confundir tempo com espaço."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Reduções Polinomiais com Outras",
                                  "subSteps": [
                                    "Criar tabela comparativa: tempo/espaço, classes afetadas (NP vs NL vs EXP), transitividade.",
                                    "Analisar por que polinomial é 'padrão ouro' para NP: preserva P vs NP?",
                                    "Destacar falhas: L-redução não captura toda dureza NP; EXP muito fraca para prática.",
                                    "Exemplificar: Clique tem P-redução de SAT (Cook-Levin), mas não trivial logspace.",
                                    "Testar com contraexemplos: uma L-redução que falha como P? Vice-versa."
                                  ],
                                  "verification": "Preencher tabela comparativa corretamente e explicar 2 cenários onde escolha importa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Exemplos de reduções de Papadimitriou 'Computational Complexity'"
                                  ],
                                  "tips": "Use setas para mostrar inclusões: L ⊆ P ⊆ EXP.",
                                  "learningObjective": "Discernir diferenças qualitativas e quantitativas entre tipos de reduções.",
                                  "commonMistakes": "Ignorar impacto na completude: só P preserva NP-completude adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender Importância em Provas de NP-Completude",
                                  "subSteps": [
                                    "Recapitular teorema Cook-Levin: SAT universal via P-redução.",
                                    "Explicar por quê polinomial crucial: se P=NP, todas P-completas em P; logspace falharia.",
                                    "Discutir implicações: provas de dureza relativa dependem de P-reduções.",
                                    "Aplicar a exemplo: por que 3PARTITION usa P não EXP?",
                                    "Refletir: sem P, colapso de hierarquia?."
                                  ],
                                  "verification": "Explicar verbalmente por que uma EXP-redução invalidaria prova de NP-hardness.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo original Cook 1971",
                                    "Vídeo Khan Academy ou YouTube sobre NP-completude"
                                  ],
                                  "tips": "Ligue à 'cadeia de reduções' partindo de SAT.",
                                  "learningObjective": "Graspar papel pivotal de tempo polinomial em teoria da complexidade.",
                                  "commonMistakes": "Subestimar: achar qualquer redução prova dureza; esquecer 'polytime' no nome."
                                }
                              ],
                              "practicalExample": "Considere provar NP-completude de Clique: use P-redução de 3SAT (constrói grafo em O(n^3) tempo). Uma L-redução seria ideal mas rara; uma EXP (enumerando fórmulas) invalidaria para NP, pois EXP contém NP trivialmente.",
                              "finalVerifications": [
                                "Definir corretamente redução polinomial vs logspace.",
                                "Dar exemplo onde L-redução existe mas não P (raro, mas hipotético).",
                                "Explicar por que EXP-redução não prova NP-hardness.",
                                "Comparar em tabela: tempo, preservação de classes.",
                                "Aplicar a um problema real como TSP.",
                                "Identificar erro em redução inválida.",
                                "Discutir transitividade em cadeia SAT → Clique → Hamilton."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (100% match formal).",
                                "Correção em comparações (sem confusões L/P/EXP).",
                                "Profundidade na importância para NP (menciona Cook-Levin).",
                                "Criatividade em exemplos práticos.",
                                "Clareza em tabela ou diagrama comparativo.",
                                "Identificação de ≥2 erros comuns.",
                                "Conexão explícita com provas de completude."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica de funções polinomiais vs exponenciais.",
                                "Lógica: Teoremas de redução semelhantes a Gödel em incompletude.",
                                "Filosofia da Ciência: Limites epistemológicos da computação.",
                                "Economia: Otimização combinatorial em teoria dos jogos.",
                                "Engenharia de Software: Análise de complexidade em design de algoritmos."
                              ],
                              "realWorldApplication": "Em otimização de rotas logísticas (TSP NP-hard), P-reduções provam que é tão difícil quanto SAT, justificando uso de heurísticas/IA em empresas como Amazon ou Google, em vez de soluções exatas exponenciais impraticáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.5.2",
                        "name": "Teorema de Cook-Levin",
                        "description": "Teorema que estabelece a NP-completude do problema SAT por meio de uma redução polinomial genérica de qualquer problema em NP para SAT.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.2.1",
                            "name": "Enunciar o Teorema de Cook-Levin",
                            "description": "Declarar o teorema e explicar que qualquer linguagem em NP pode ser reduzida polinomialmente para o problema de satisfatibilidade booleana (SAT).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Complexidade NP",
                                  "subSteps": [
                                    "Defina formalmente uma linguagem em NP usando máquinas de Turing não-determinísticas (TMND).",
                                    "Explique a diferença entre P e NP com exemplos simples como ordenação vs. problema da mochila.",
                                    "Liste pelo menos três problemas conhecidos em NP, como SAT, Clique e Vertex Cover.",
                                    "Descreva o verificador polinomial para uma instância em NP.",
                                    "Pratique convertendo um problema trivial em NP para uma descrição formal."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o que é NP e forneça um exemplo verificável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (capítulo sobre NP)",
                                    "Notas de aula sobre complexidade computacional",
                                    "Vídeo Khan Academy ou YouTube sobre P vs NP"
                                  ],
                                  "tips": "Use diagramas de TMND para visualizar não-determinismo; evite confundir com determinismo.",
                                  "learningObjective": "Compreender precisamente o que constitui uma linguagem em NP.",
                                  "commonMistakes": [
                                    "Confundir NP com problemas intratáveis",
                                    "Ignorar o papel do verificador polinomial",
                                    "Pensar que NP inclui apenas problemas difíceis de resolver"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Problema de Satisfatibilidade Booleana (SAT)",
                                  "subSteps": [
                                    "Defina formalmente o problema SAT: dada uma fórmula booleana em CNF, existe uma atribuição que a satisfaz?",
                                    "Construa exemplos simples de fórmulas CNF com 3 variáveis e resolva manualmente.",
                                    "Explique por que SAT está em NP (construção do certificado).",
                                    "Discuta trivialidades: SAT é decidível, mas potencialmente custoso.",
                                    "Pratique reduzindo um problema lógico simples para SAT."
                                  ],
                                  "verification": "Crie e resolva uma fórmula SAT com pelo menos 4 cláusulas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online SAT solver como minisat ou SAT4J demo",
                                    "Papel e lápis para CNF",
                                    "Artigo Wikipedia sobre SAT (seção formal)"
                                  ],
                                  "tips": "Sempre converta para CNF usando regras de equivalência; memorize as cláusulas unitárias.",
                                  "learningObjective": "Dominar a definição e estrutura do SAT como base para reduções.",
                                  "commonMistakes": [
                                    "Esquecer que SAT requer CNF",
                                    "Confundir satisfatibilidade com tautologia",
                                    "Não reconhecer SAT em NP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enunciar Precisamente o Teorema de Cook-Levin",
                                  "subSteps": [
                                    "Leia o enunciado exato: 'Todo problema em NP é redutível em tempo polinomial para SAT'.",
                                    "Escreva o teorema em suas próprias palavras, incluindo formalismos L ∈ NP ⇒ L ≤_p SAT.",
                                    "Identifique os elementos chave: redução polinomial, preservação de 'sim' instâncias.",
                                    "Compare com teoremas de redução anteriores (ex: para 3SAT).",
                                    "Memorize e recite o teorema sem consultar fontes."
                                  ],
                                  "verification": "Registre-se recitando o teorema para um colega ou gravando áudio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel de Sipser ou Arora-Barak 'Computational Complexity'",
                                    "Flashcards com enunciados",
                                    "Gravação de voz no celular"
                                  ],
                                  "tips": "Use mnemônicos como 'Cook-Levin cozinha NP em SAT'; pratique diariamente.",
                                  "learningObjective": "Declarar o teorema com precisão matemática.",
                                  "commonMistakes": [
                                    "Omitir 'polinomial' na redução",
                                    "Confundir com 3SAT",
                                    "Invertir a direção da redução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a Ideia da Redução e Implicações",
                                  "subSteps": [
                                    "Descreva conceitualmente a redução: simule TMND via fórmula SAT que codifica computação.",
                                    "Esboce os componentes: variáveis para configurações, cláusulas para transições.",
                                    "Discuta por que a redução é polinomial (tamanho da fórmula O(n^k)).",
                                    "Explique implicações: SAT é NP-completo, base para teoria da complexidade.",
                                    "Aplique a um exemplo pequeno: reduza PATH em grafo para SAT."
                                  ],
                                  "verification": "Escreva um parágrafo explicando a redução e desenhe um diagrama conceitual.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Pseudocódigo da prova de Cook-Levin",
                                    "Software de desenho como Draw.io",
                                    "Exemplo resolvido de redução em blog de teoria CS"
                                  ],
                                  "tips": "Foque na codificação de 'tape' e 'head'; ignore detalhes full para enunciado.",
                                  "learningObjective": "Entender e articular a essência da prova do teorema.",
                                  "commonMistakes": [
                                    "Pensar que prova constrói resolvedor",
                                    "Subestimar tamanho polinomial",
                                    "Confundir NP-complete com NP-hard"
                                  ]
                                }
                              ],
                              "practicalExample": "Para verificar se um grafo tem um caminho de Hamilton (em NP), reduza para SAT criando variáveis x_{i,t} indicando se nó i está na posição t do caminho, e cláusulas CNF garantindo unicidade, adjacência e cobertura de nós – resultando em fórmula SAT equivalente.",
                              "finalVerifications": [
                                "Recite o teorema sem erros em menos de 30 segundos.",
                                "Explique corretamente por que SAT está em NP.",
                                "Identifique uma redução inválida e corrija-a.",
                                "Distinga Cook-Levin de Levin's theorem.",
                                "Aplique o teorema a um novo problema em NP."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado formal (100% match com fontes padrão).",
                                "Correta explicação da redução polinomial (inclui tempo e preservação).",
                                "Compreensão conceitual via exemplo prático sem falhas.",
                                "Uso correto de terminologia (NP, SAT, ≤_p).",
                                "Capacidade de discutir implicações para NP-completude."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e teoria de modelos.",
                                "Filosofia: Questões de decidibilidade e limites do conhecimento.",
                                "Engenharia de Software: Otimização em compiladores e verificação.",
                                "Inteligência Artificial: Planejamento e solvers SAT em AI."
                              ],
                              "realWorldApplication": "O teorema fundamenta solvers SAT modernos usados em verificação de hardware (ex: Intel CPUs), otimização logística (ex: roteirização de entregas na Amazon) e criptografia (testando quebra de chaves), permitindo reduzir problemas complexos a SAT para soluções eficientes em prática."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.8.5.2.2",
                            "name": "Compreender a construção da redução para SAT",
                            "description": "Descrever os passos da prova: simulação de Máquina de Turing não-determinística via fórmula booleana, incluindo cláusulas para histórico de computação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do Teorema de Cook-Levin",
                                  "subSteps": [
                                    "Estudar a declaração do teorema: todo problema em NP é redutível em tempo polinomial a SAT.",
                                    "Revisar o que é uma Máquina de Turing Não-Determinística (MTND) e sua relação com NP.",
                                    "Entender o objetivo: simular a computação da MTND via uma fórmula booleana satisfatível.",
                                    "Identificar os componentes principais: configurações, histórico e cláusulas CNF.",
                                    "Analisar por que SAT é NP-completo."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o teorema e sua importância em 5 minutos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou Arora-Barak)",
                                    "Notas de aula sobre NP",
                                    "Vídeo introdutório sobre Cook-Levin"
                                  ],
                                  "tips": "Comece com exemplos simples de problemas NP para contextualizar.",
                                  "learningObjective": "Dominar os conceitos básicos que motivam a redução.",
                                  "commonMistakes": [
                                    "Confundir MTND com MT determinística",
                                    "Ignorar o papel polinomial da redução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar configurações de MTND com variáveis booleanas",
                                  "subSteps": [
                                    "Definir uma configuração como tape content, head position, state e direction.",
                                    "Codificar cada célula da fita, posição da cabeça e estado com variáveis booleanas (e.g., P_{t,i,j,s} para posição i, símbolo j, estado s no tempo t).",
                                    "Determinar o tamanho polinomial: número de variáveis O(n * T * |Q| * |Γ|), onde T é tempo polinomial.",
                                    "Exemplificar com uma fita de tamanho fixo para uma entrada dada.",
                                    "Garantir que cada configuração tenha exatamente uma cabeça ativa."
                                  ],
                                  "verification": "Desenhar a codificação para uma MTND simples com 3 estados e fita de 5 células.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Editor de texto para fórmulas",
                                    "Referência ao pseudocódigo da MTND"
                                  ],
                                  "tips": "Use tabelas para mapear variáveis booleanas às configurações.",
                                  "learningObjective": "Saber codificar atomicamente as configurações em booleanos.",
                                  "commonMistakes": [
                                    "Esquecer de codificar direção da cabeça",
                                    "Usar variáveis exponenciais em vez de polinomiais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir cláusulas para configuração inicial",
                                  "subSteps": [
                                    "Definir cláusulas para iniciar com entrada na fita (símbolos corretos nas posições iniciais).",
                                    "Adicionar cláusulas para cabeça na posição inicial e estado inicial.",
                                    "Garantir fita em branco fora da entrada com cláusulas de unicidade.",
                                    "Implementar cláusulas de 'exatamente uma' para cada posição (usando at-most-one e at-least-one).",
                                    "Verificar que a configuração tempo 0 satisfaz todas as cláusulas iniciais."
                                  ],
                                  "verification": "Escrever 5-10 cláusulas CNF para uma entrada exemplo e testar satisfatibilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Solver SAT online (como minisat)",
                                    "Folha de cálculo para cláusulas"
                                  ],
                                  "tips": "Teste cláusulas isoladamente antes de combinar.",
                                  "learningObjective": "Gerar cláusulas CNF precisas para o estado inicial.",
                                  "commonMistakes": [
                                    "Permitir múltiplos símbolos por célula",
                                    "Não tratar brancos adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir cláusulas para transições entre configurações",
                                  "subSteps": [
                                    "Para cada tempo t, adicionar cláusulas que garantem transição válida de t para t+1 baseada na função de transição δ.",
                                    "Codificar: se em (q, σ) então próximo é δ(q, σ) = (q', σ', D).",
                                    "Incluir cláusulas para movimento da cabeça (esquerda/direita/permanecer).",
                                    "Garantir persistência da fita exceto na célula da cabeça.",
                                    "Usar cláusulas para estados halting serem propagados."
                                  ],
                                  "verification": "Simular uma transição passo a passo e listar as cláusulas envolvidas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pseudocódigo da função δ da MTND",
                                    "Solver SAT para validação"
                                  ],
                                  "tips": "Divida em sub-transições: leitura, escrita, movimento, mudança de estado.",
                                  "learningObjective": "Modelar dinamicamente as transições via CNF.",
                                  "commonMistakes": [
                                    "Ignorar propagação de símbolos na fita",
                                    "Cláusulas erradas para direção"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar cláusulas para histórico e aceitação",
                                  "subSteps": [
                                    "Adicionar cláusulas para o histórico: pelo menos uma configuração de aceitação no final.",
                                    "Garantir continuidade: cada configuração t+1 segue de t.",
                                    "Cláusulas para rejeição: evitar halting em estado rejeita antes do tempo limite.",
                                    "Definir tempo limite polinomial T(n) e cláusulas para não-halting prematuro.",
                                    "Verificar satisfatibilidade: fórmula é SAT iff MTND aceita a entrada."
                                  ],
                                  "verification": "Construir fórmula completa para MTND toy e usar solver para validar.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Implementação em Python de gerador de CNF",
                                    "Solver SAT"
                                  ],
                                  "tips": "Comece com T pequeno para depuração.",
                                  "learningObjective": "Completar a redução com histórico e verificação final.",
                                  "commonMistakes": [
                                    "Histórico não contínuo",
                                    "Não limitar tempo polinomial"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma MTND que aceita linguagens com comprimento par: entrada 'ab', fita inicial codificada com cláusulas para 'a' em pos 1, 'b' em pos 2; transições alternam estados par/ímpar até halting aceita em tempo 4.",
                              "finalVerifications": [
                                "Descrever todos os tipos de cláusulas (inicial, transição, histórico).",
                                "Explicar por que o número de variáveis/cláusulas é polinomial.",
                                "Simular redução para uma MTND com 2 estados.",
                                "Identificar erro em uma cláusula malformada.",
                                "Provar que SAT satisfatível implica aceitação da MTND.",
                                "Discutir generalização para qualquer L em NP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na codificação de configurações (90% correto).",
                                "Corretude das cláusulas CNF (testadas em solver).",
                                "Explicação clara do fluxo lógico da redução.",
                                "Uso correto de tempo polinomial em todos componentes.",
                                "Identificação de erros comuns e soluções.",
                                "Capacidade de aplicar a uma MTND exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Proposicional (Matemática Discreta): CNF e satisfatibilidade.",
                                "Teoria dos Autômatos: Máquinas de Turing e simulações.",
                                "Verificação Formal: Model checking via SAT solvers.",
                                "Algoritmos: Reduções e provas de NP-completude.",
                                "Inteligência Artificial: Encoding de problemas em SAT."
                              ],
                              "realWorldApplication": "Em SAT solvers como Z3 ou MiniSat para verificar propriedades de software/hardware, otimização combinatória em VLSI design e planejamento de rotas, provando NP-completude de problemas práticos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2.1",
                              "10.1.8.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.5.2.3",
                            "name": "Aplicar o teorema para provar NP-completude inicial",
                            "description": "Usar o Teorema de Cook para argumentar a NP-completude de SAT e implicações para outros problemas via reduções em cadeia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Teorema de Cook-Levin e Definições Fundamentais",
                                  "subSteps": [
                                    "Relembrar a definição formal da classe NP como problemas com verificadores polinomiais.",
                                    "Estudar a declaração precisa do Teorema de Cook-Levin: todo problema em NP é redutível em tempo polinomial para SAT.",
                                    "Entender os conceitos de redução polinomial logspace ou Karp, e NP-hard.",
                                    "Revisar máquinas de Turing não-determinísticas e sua simulação.",
                                    "Explorar a intuição por trás da universalidade das máquinas NP."
                                  ],
                                  "verification": "Parafrasear corretamente o teorema e suas implicações em um parágrafo coerente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Cap. 7)",
                                    "Notas de aula sobre complexidade NP",
                                    "Artigo original de Cook-Levin (opcional)"
                                  ],
                                  "tips": [
                                    "Visualize a construção como uma 'simulação codificada' em fórmula booleana.",
                                    "Use diagramas para mapear transições de MT para cláusulas SAT."
                                  ],
                                  "learningObjective": "Dominar os fundamentos teóricos do teorema e classes de complexidade.",
                                  "commonMistakes": [
                                    "Confundir NP-hard com NP-complete sem membership em NP.",
                                    "Ignorar que a redução é polinomial no tamanho da instância."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que SAT Pertence à Classe NP",
                                  "subSteps": [
                                    "Definir formalmente o problema SAT: dada uma fórmula em CNF, existe uma atribuição satisfatória?",
                                    "Construir um verificador determinístico V que, dado (φ, a), verifica se a satisfaz φ em tempo polinomial.",
                                    "Mostrar que |a| = número de variáveis, e verificação envolve avaliação de cláusulas.",
                                    "Argumentar que SAT ∈ NP pois V roda em O(n^3) onde n é tamanho de φ.",
                                    "Testar com exemplo pequeno de fórmula SAT."
                                  ],
                                  "verification": "Escrever e validar a prova formal de membership em NP para SAT.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta para fórmulas",
                                    "Ferramenta online SAT solver para testes (ex: minisat)",
                                    "Apostila de lógica proposicional"
                                  ],
                                  "tips": [
                                    "Lembre que o certificador é a atribuição binária das variáveis.",
                                    "Foquem na linearidade na avaliação de cada cláusula."
                                  ],
                                  "learningObjective": "Demonstrar habilidade em provar membership em NP via certificadores.",
                                  "commonMistakes": [
                                    "Esquecer de especificar tempo polinomial do verificador.",
                                    "Confundir SAT com TAUT (que é coNP-completo)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Teorema de Cook-Levin para Provar SAT NP-Difícil",
                                  "subSteps": [
                                    "Dado L ∈ NP com MTN M, construir fórmula φ_M que codifica computação aceitadora de M em w.",
                                    "Descrever cláusulas para: posições de fita, estados, cabeçote, transições.",
                                    "Verificar que φ_M é satisfatível iff M aceita w.",
                                    "Mostrar que tamanho de φ_M é polinomial em |w| e passos de computação.",
                                    "Analisar complexidade da redução: O((|Q|*|Γ|*|n|)^3) ou similar."
                                  ],
                                  "verification": "Construir esboço da fórmula SAT para uma MTN simples e verificar correção.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pseudocódigo do teorema de Sipser ou Arora",
                                    "Software para gerar fórmulas SAT (ex: Python script)",
                                    "Quadro branco para diagramas"
                                  ],
                                  "tips": [
                                    "Pense na fita como uma matriz temporal de símbolos.",
                                    "Use variáveis booleanas para cada célula (tempo, posição)."
                                  ],
                                  "learningObjective": "Executar a prova de NP-hardness via redução de Cook-Levin.",
                                  "commonMistakes": [
                                    "Subestimar o número de cláusulas para transições.",
                                    "Confundir simulação determinística com não-determinística."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Implicações para Reduções em Cadeia",
                                  "subSteps": [
                                    "Explicar que SAT NP-completo implica reduções SAT → outros problemas.",
                                    "Dar exemplo: redução SAT para 3-SAT via cláusulas auxiliares.",
                                    "Discutir cadeia: Cook-Levin → SAT → 3SAT → Clique → etc.",
                                    "Analisar transitividade de reduções polinomiais.",
                                    "Refletir sobre P=NP e heurísticas práticas."
                                  ],
                                  "verification": "Esboçar uma redução em cadeia para um problema conhecido (ex: Vertex Cover).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Lista de problemas NP-completos (Wikipedia ou compêndio)",
                                    "Exemplos de reduções de livros texto"
                                  ],
                                  "tips": [
                                    "Reduções em cadeia preservam NP-completude se composições polinomiais.",
                                    "Teste pequenas instâncias manualmente."
                                  ],
                                  "learningObjective": "Entender propagação de NP-completude via reduções.",
                                  "commonMistakes": [
                                    "Achar que toda redução preserva completude sem polinomialidade.",
                                    "Ignorar direção da redução (L1 ≤p L2 implica hardness de L2)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para provar Clique NP-completo: Como SAT é NP-completo por Cook-Levin, construa redução polinomial SAT → Clique (codifique variáveis como vértices, cláusulas como cliques necessários), assim Clique herda NP-completude.",
                              "finalVerifications": [
                                "Pode citar e provar SAT ∈ NP corretamente.",
                                "Descreve a construção de cláusulas no teorema de Cook-Levin.",
                                "Explica uma redução em cadeia de SAT para outro problema.",
                                "Identifica erros comuns em provas de NP-completude.",
                                "Aplica o teorema a um exemplo ad hoc simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão e formalidade na prova de membership em NP (30%).",
                                "Correção na descrição da redução Cook-Levin (40%).",
                                "Clareza nas implicações de reduções em cadeia (20%).",
                                "Uso apropriado de notação matemática e exemplos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica Proposicional e Teoria dos Grafos.",
                                "Filosofia: Questões de Decidibilidade e Gödel.",
                                "Engenharia: Design de Algoritmos Aproximados em IA e Otimização.",
                                "Economia: Modelagem de Problemas de Alocação NP-completos."
                              ],
                              "realWorldApplication": "Em criptografia (ex: fatoração é candidato NP-intermediário, mas reduções de SAT guiam ataques heurísticos) e logística (escalonamento NP-completo usa insights de Cook-Levin para solvers SAT como base de CDCL em CPLEX ou Gurobi)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.5.3",
                        "name": "Exemplos e Aplicações de Reduções Polinomiais",
                        "description": "Ilustrações práticas de reduções polinomiais entre problemas NP-completos, como de Clique para Vertex Cover ou 3-SAT para Clique.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.3.1",
                            "name": "Analisar uma redução polinomial clássica",
                            "description": "Estudar e reproduzir a redução de 3-SAT para Clique, verificando tempo polinomial e preservação de sim/não.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Problemas 3-SAT e Clique",
                                  "subSteps": [
                                    "Defina formalmente o problema 3-SAT: dada uma fórmula em forma normal conjuntiva com cláusulas de exatamente 3 literais, determinar se é satisfatível.",
                                    "Defina formalmente o problema Clique: dado um grafo não direcionado G e um inteiro k, determinar se G possui um clique de tamanho k (subconjunto de k vértices todos conectados).",
                                    "Identifique as classes de complexidade: ambos são NP-completos.",
                                    "Revise conceitos chave: literais, cláusulas, satisfatibilidade, grafos, cliques.",
                                    "Compare as estruturas: 3-SAT é lógico-booleano, Clique é gráfico."
                                  ],
                                  "verification": "Escreva definições precisas e exemplos simples de cada problema, confirmando que entende as entradas/saídas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de teoria da complexidade",
                                    "Papel e caneta",
                                    "Referência: Livro 'Computers and Intractability' de Garey e Johnson"
                                  ],
                                  "tips": [
                                    "Use diagramas para visualizar grafos e fórmulas.",
                                    "Memorize que Clique é NP-completo via essa redução clássica.",
                                    "Pratique com exemplos pequenos primeiro."
                                  ],
                                  "learningObjective": "Dominar as definições formais e intuições dos problemas fonte e alvo.",
                                  "commonMistakes": [
                                    "Confundir Clique com Independente Set.",
                                    "Esquecer que 3-SAT tem exatamente 3 literais por cláusula.",
                                    "Ignorar que grafos são não direcionados e sem laços."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Construção da Redução",
                                  "subSteps": [
                                    "Para uma fórmula φ com m cláusulas, crie um grafo G com 3m vértices: para cada cláusula C_i = (l_{i1} / l_{i2} / l_{i3}), crie três vértices v_{i1}, v_{i2}, v_{i3} representando os literais.",
                                    "Adicione arestas entre v_{ij} e v_{kl} se i ≠ k (cláusulas diferentes) e os literais l_{ij}, l_{kl} são consistentes (não são negações um do outro).",
                                    "Não adicione arestas dentro da mesma cláusula, pois qualquer literal da cláusula é selecionável.",
                                    "Defina k = m, pois um clique de tamanho m seleciona exatamente um literal por cláusula.",
                                    "Desenhe o grafo para uma fórmula pequena para visualizar."
                                  ],
                                  "verification": "Construa o grafo G manualmente para uma fórmula 3-SAT de 2-3 cláusulas e liste todas as arestas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Fórmulas 3-SAT de exemplo",
                                    "Software de desenho de grafos como Graphviz ou papel",
                                    "Pseudocódigo da construção"
                                  ],
                                  "tips": [
                                    "Rotule vértices claramente como 'C1_x1' para rastrear.",
                                    "Verifique consistência: x e ~x nunca conectados.",
                                    "Comece com fórmula satisfatível para testar."
                                  ],
                                  "learningObjective": "Reproduzir a transformação polinomial de φ em (G, k).",
                                  "commonMistakes": [
                                    "Adicionar arestas dentro da mesma cláusula.",
                                    "Esquecer arestas entre cláusulas com literais consistentes.",
                                    "Confundir k com número de variáveis em vez de cláusulas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar o Tempo Polinomial da Redução",
                                  "subSteps": [
                                    "Analise o tamanho da entrada: φ tem n variáveis e m cláusulas, tamanho O(m).",
                                    "Número de vértices em G: 3m, O(m).",
                                    "Número de arestas: para cada par de cláusulas, cheque 3x3=9 pares de literais, total O(m^2) tempo.",
                                    "Construa uma tabela de complexidade: vertices O(m), edges O(m^2), total polinomial em |φ|.",
                                    "Implemente um pseudocódigo e estime big-O."
                                  ],
                                  "verification": "Escreva análise big-O mostrando que redução roda em O(|φ|^2) ou melhor.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou planilha para contagens",
                                    "Pseudocódigo editor",
                                    "Referência de análise assintótica"
                                  ],
                                  "tips": [
                                    "Conte operações: para cada par cláusulas, 9 checks constantes.",
                                    "Lembre: polinomial significa qualquer O(n^c) para c constante.",
                                    "Teste com m crescente."
                                  ],
                                  "learningObjective": "Provar que a redução é computacionalmente eficiente (polinomial).",
                                  "commonMistakes": [
                                    "Subestimar edges como O(m) em vez de O(m^2).",
                                    "Ignorar tempo de cheque de consistência.",
                                    "Confundir com tempo de resolução do problema alvo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Preservação de Sim/Não (Corretude)",
                                  "subSteps": [
                                    "Direção →: Se φ satisfatível, encontre uma atribuição que satisfaz cada cláusula; selecione um vértice por cláusula correspondente ao literal verdadeiro, formando clique de tamanho m.",
                                    "Direção ←: Se (G,k) tem clique de tamanho m, selecione um vértice por cláusula; como clique, literais são consistentes (sem contradições), defina variáveis verdadeiras conforme seleção, satisfazendo φ.",
                                    "Prove consistência: arestas garantem não-contradição entre seleções.",
                                    "Verifique completude: toda cláusula coberta por seleção válida.",
                                    "Formalize em lema: φ satisfatível ⇔ G tem clique de tamanho m."
                                  ],
                                  "verification": "Escreva prova bidirecional completa, com casos base e indutivos se necessário.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel para provas formais",
                                    "Exemplos de fórmulas satisfatíveis e não-satisfatíveis",
                                    "Templates de prova por contraposição"
                                  ],
                                  "tips": [
                                    "Use seta → para SAT implica Clique, ← para vice-versa.",
                                    "Desenhe subgrafos do clique para ilustrar.",
                                    "Teste com contraexemplo se falhar."
                                  ],
                                  "learningObjective": "Estabelecer equivalência decisória via redução.",
                                  "commonMistakes": [
                                    "Esquecer direção ← (Clique implica SAT).",
                                    "Não provar que seleção define atribuição total válida.",
                                    "Assumir consistência sem usar ausência de arestas para contraditórios."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Reproduzir e Analisar com Exemplo Prático",
                                  "subSteps": [
                                    "Pegue φ = (x∨¬y∨z) ∧ (¬x∨y∨¬z); construa G com 6 vértices.",
                                    "Liste arestas: cheque consistência entre cláusulas.",
                                    "Verifique se φ satisfatível (ex: x=F, y=T, z=T); encontre clique.",
                                    "Analise tempo de construção e valide corretude.",
                                    "Generalize lições para outras reduções."
                                  ],
                                  "verification": "Documente construção completa, clique encontrado e atribuição correspondente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplo específico impresso",
                                    "Ferramenta de grafos online como yEd",
                                    "Checklist de verificação"
                                  ],
                                  "tips": [
                                    "Escolha fórmula pequena mas com contradições potenciais.",
                                    "Simule insatisfatível para testar ←.",
                                    "Fotografe/diagrame grafo final."
                                  ],
                                  "learningObjective": "Aplicar redução end-to-end em exemplo real.",
                                  "commonMistakes": [
                                    "Erros de rotulagem de vértices.",
                                    "Perder arestas críticas.",
                                    "Não validar ambas direções no exemplo."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere φ = (x₁ ∨ ¬x₂ ∨ x₃) ∧ (¬x₁ ∨ x₂ ∨ ¬x₄). Cláusulas C1: v11=x1, v12=¬x2, v13=x3; C2: v21=¬x1, v22=x2, v23=¬x4. Arestas: v11-v22 (x1 e x2 ok), v11-v23 (x1 e ¬x4 ok), v12-v21 (¬x2 e ¬x1 ok), etc. (não v11-v21 pois x1 e ¬x1 contraditórios). φ satisfatível (x1=T, x2=F, x3=F, x4=T)? Clique {v11, v22} ou similar valida.",
                              "finalVerifications": [
                                "Construir corretamente grafo para nova fórmula 3-SAT.",
                                "Calcular big-O da redução com justificativa.",
                                "Escrever prova bidirecional concisa.",
                                "Identificar erros comuns na construção.",
                                "Explicar por que k=m.",
                                "Aplicar a um exemplo insatisfatível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do grafo (100% arestas corretas).",
                                "Análise assintótica correta (polinomial comprovado).",
                                "Prova de corretude completa e lógica.",
                                "Exemplo prático validado em ambas direções.",
                                "Clareza e organização na documentação.",
                                "Identificação de pelo menos 3 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: propriedades de cliques e subgrafos induzidos.",
                                "Lógica Proposicional: satisfatibilidade e tautologias.",
                                "Matemática Discreta: contagens combinatórias em reduções.",
                                "Algoritmos: análise de tempo em transformações.",
                                "Filosofia da Computação: limites da decidibilidade."
                              ],
                              "realWorldApplication": "Essa redução prova NP-hardness do problema Clique, aplicado em otimização de redes sociais (comunidades densas), bioinformática (clusters moleculares), VLSI design (agrupamento de módulos) e scheduling (grupos compatíveis), guiando heurísticas quando exato é intratável."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.2",
                              "10.1.8.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.8.5.3.2",
                            "name": "Construir uma redução polinomial simples",
                            "description": "Desenvolver uma redução de Vertex Cover para Independent Set, especificando a função de mapeamento e provando corretude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Definições Formal de Vertex Cover e Independent Set",
                                  "subSteps": [
                                    "Defina formalmente o problema de Vertex Cover (VC): dado grafo G=(V,E) e inteiro k, existe subconjunto C ⊆ V com |C| ≤ k tal que toda aresta em E tem pelo menos um endpoint em C?",
                                    "Defina formalmente o problema de Independent Set (IS): dado grafo G'=(V',E') e inteiro k', existe subconjunto I ⊆ V' com |I| ≥ k' tal que nenhuma aresta em E' conecta dois vértices em I?",
                                    "Explique a relação complementar entre VC e IS: um conjunto é VC em G iff seu complemento é IS no grafo complemento de G.",
                                    "Forneça um exemplo simples de grafo com VC e IS correspondentes.",
                                    "Formalize as instâncias de decisão para ambos os problemas."
                                  ],
                                  "verification": "Escreva definições precisas, exemplos e relação complementar em um documento ou quadro, sem ambiguidades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a livro-texto ou notas sobre teoria dos grafos (ex: Sipser ou Cormen)"
                                  ],
                                  "tips": [
                                    "Use notação padrão: G=(V,E), |V|=n.",
                                    "Desenhe grafos pequenos para visualizar."
                                  ],
                                  "learningObjective": "Dominar definições exatas e intuição da dualidade VC-IS.",
                                  "commonMistakes": [
                                    "Confundir tamanhos (<=k para VC vs >=k para IS).",
                                    "Esquecer que são problemas de decisão NP-completos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar a Função de Mapeamento da Redução",
                                  "subSteps": [
                                    "Construa o grafo complemento G'=(V, E'), onde E' = { {u,v} | u≠v, {u,v} ∉ E }.",
                                    "Defina k' = |V| - k.",
                                    "Especifique a função f: f((G,k)) = (G', k').",
                                    "Verifique que |V'| = |V| = n e que a construção é determinística.",
                                    "Descreva algoritmo para computar G' (ex: matriz de adjacência invertida)."
                                  ],
                                  "verification": "Escreva a definição exata de f(G,k) e um pseudocódigo para construí-la.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de grafos como Graphviz ou Python com NetworkX",
                                    "Papel para desenhar grafos"
                                  ],
                                  "tips": [
                                    "Represente grafos como listas de adjacência para facilitar complemento.",
                                    "Confirme n permanece igual."
                                  ],
                                  "learningObjective": "Construir explicitamente transformações polinomiais entre instâncias.",
                                  "commonMistakes": [
                                    "Errar k' como k em vez de n-k.",
                                    "Confundir grafo complemento com inverso de arestas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Implicação Forward: VC Sim implica IS Sim",
                                  "subSteps": [
                                    "Assuma que existe C ⊆ V, |C| ≤ k, tal que C é VC em G (todas arestas de E incidentes a C).",
                                    "Considere I = V \\ C, então |I| ≥ n - k = k'.",
                                    "Prove que I é IS em G': não existe aresta em E' entre dois vértices de I, pois qualquer par em I teria aresta em E (caso contrário estaria em E'), mas E é coberto por C.",
                                    "Conclua que f preserva 'sim' na direção forward.",
                                    "Escreva a prova em linguagem formal com ∀ e ⇒."
                                  ],
                                  "verification": "Escreva prova completa sem lacunas lógicas, verificada por leitura reversa.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel para rascunhos de provas",
                                    "Exemplos de grafos impressos"
                                  ],
                                  "tips": [
                                    "Use contradição: suponha aresta em E' dentro de I, então ausência em E não coberta por C."
                                  ],
                                  "learningObjective": "Aplicar raciocínio lógico para provar preservação de solucionabilidade.",
                                  "commonMistakes": [
                                    "Esquecer de provar |I| ≥ k'.",
                                    "Confundir cobertura em G com independência em G'."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a Implicação Backward e Analisar Complexidade Polinomial",
                                  "subSteps": [
                                    "Assuma que existe I ⊆ V, |I| ≥ k', tal que I é IS em G'.",
                                    "Defina C = V \\ I, então |C| ≤ n - k' = k.",
                                    "Prove que C é VC em G: toda aresta em E tem endpoint em C, pois se ambos em I, haveria aresta em E' (contradiz IS).",
                                    "Mostre que f é computável em tempo polinomial: O(n^2) para complemento via matriz.",
                                    "Conclua corretude total da redução ( Karp-style )."
                                  ],
                                  "verification": "Prova backward escrita + análise de tempo O(n^2) com justificativa.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora para contagens de tempo",
                                    "Referência de complexidade (ex: CLRS)"
                                  ],
                                  "tips": [
                                    "Simetria das provas forward/backward facilita.",
                                    "Conte operações: para n vértices, checar todos pares potenciais."
                                  ],
                                  "learningObjective": "Completar prova de corretude bidirecional e certificar polynomialidade.",
                                  "commonMistakes": [
                                    "Ignorar direção backward.",
                                    "Subestimar tempo do complemento como O(1)."
                                  ]
                                }
                              ],
                              "practicalExample": "G = (V={a,b,c}, E={(a,b),(b,c)}), n=3, k=1 para VC. f(G,1) = (G, 3-1=2) para IS >=2. C={b} é VC (cobre (a,b),(b,c)). I={a,c} é IS (no edge (a,c) in G). Correto. Se k=0, IS>=3 impossível pois grafo tem arestas.",
                              "finalVerifications": [
                                "Definições de VC e IS escritas corretamente com formalismo.",
                                "Função f(G,k) = (G, n-k) especificada explicitamente.",
                                "Prova forward: VC <=k implica IS >=n-k demonstrada.",
                                "Prova backward: IS >=n-k implica VC <=k demonstrada.",
                                "Análise confirma tempo polinomial O(1).",
                                "Exemplo prático verificado em ambos sentidos.",
                                "Duality VC-IS no mesmo grafo destacada."
                              ],
                              "assessmentCriteria": [
                                "Precisão das definições e dualidade (20%)",
                                "Clareza e exatidão da função f (20%)",
                                "Corretude e completude da prova forward (25%)",
                                "Corretude e completude da prova backward (25%)",
                                "Análise de complexidade e exemplo prático (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e conjuntos complementares",
                                "Lógica e Provas: Raciocínio por contradição e bicondicional",
                                "Programação: Implementação de algoritmos de grafos em Python/NetworkX",
                                "Filosofia da Ciência: Conceitos de redução e equivalência em complexidade"
                              ],
                              "realWorldApplication": "Essa redução é fundamental para provar NP-completude de problemas de otimização em redes (ex: alocação de recursos onde VC modela coberturas mínimas, IS modela seleções independentes como agendamento sem conflitos), usada em algoritmos aproximados para redes sociais, bioinformática e logística."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.3.1",
                              "10.1.8.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.8.5.3.3",
                            "name": "Avaliar implicações de reduções em cadeia",
                            "description": "Explicar como uma cadeia de reduções polinomiais prova NP-completude transitiva e discute limitações para P vs NP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Reduções Polinomiais e NP-Completude",
                                  "subSteps": [
                                    "Defina redução polinomial como uma transformação de um problema A para B em tempo polinomial.",
                                    "Explique NP e NP-completude: problemas em NP cujos sim, todos os problemas em NP reduzem para eles.",
                                    "Identifique exemplos clássicos como SAT e Clique.",
                                    "Discuta por que reduções preservam a 'dureza' computacional.",
                                    "Estude o teorema de Cook-Levin para SAT como primeiro NP-completo."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e liste 3 exemplos de problemas NP-completos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to Algorithms' (CLRS), slides de complexidade computacional, Wikipedia: NP-completeness.",
                                  "tips": "Use diagramas para visualizar reduções como setas entre problemas.",
                                  "learningObjective": "Compreender a base teórica necessária para reduções em cadeia.",
                                  "commonMistakes": "Confundir redução polinomial com exponencial ou ignorar o aspecto de 'preservação de sim/não'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Reduções em Cadeia e Sua Transitividade",
                                  "subSteps": [
                                    "Construa uma cadeia: SAT → 3-SAT → Clique → Vertex Cover.",
                                    "Demonstre transitividade: se A reduz para B e B para C, então A reduz para C em tempo polinomial.",
                                    "Prove formalmente que NP-completude é transitiva via composição de reduções.",
                                    "Implemente um exemplo simples em pseudocódigo para composição.",
                                    "Analise o tempo total da redução composta (soma polinomial)."
                                  ],
                                  "verification": "Desenhe um diagrama de cadeia com pelo menos 3 problemas e calcule o tempo composto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e caneta para diagramas, ferramenta online como Draw.io, artigos sobre reduções clássicas.",
                                  "tips": "Comece com cadeias curtas para evitar sobrecarga; foque em composição passo a passo.",
                                  "learningObjective": "Dominar como reduções em cadeia propagam NP-completude.",
                                  "commonMistakes": "Assumir que cadeia infinita prova algo sobre P=NP; ignorar que composição deve ser polinomial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Implicações para Provas de NP-Completude",
                                  "subSteps": [
                                    "Explique como uma cadeia prova que todos os problemas na cadeia são NP-completos se o primeiro for.",
                                    "Discuta implicações: acelera provas ao reutilizar reduções existentes.",
                                    "Analise um caso real: cadeia de SAT para Hamiltoniano Path.",
                                    "Identifique quando cadeias fortalecem argumentos de inaproximabilidade.",
                                    "Crie sua própria mini-cadeia para um problema novo."
                                  ],
                                  "verification": "Escreva um relatório curto explicando por que Clique é NP-completo via cadeia de SAT.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Lista de problemas NP-completos ( Garey & Johnson ), editor de texto para relatórios.",
                                  "tips": "Mantenha a cadeia lógica e verifique cada seta individualmente.",
                                  "learningObjective": "Aplicar reduções em cadeia para validar NP-completude de múltiplos problemas.",
                                  "commonMistakes": "Não verificar se todos os problemas estão em NP; pular prova de membership em NP."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Limitações das Reduções em Cadeia para P vs NP",
                                  "subSteps": [
                                    "Explique que reduções mostram equivalência relativa, não dureza absoluta.",
                                    "Discuta: se um NP-completo estiver em P, todos em NP estão em P.",
                                    "Analise por que cadeias não resolvem P=?NP (relativização, oráculos).",
                                    "Explore barreiras: Baker-Gill-Solovay para relativização.",
                                    "Debata implicações filosóficas para computação."
                                  ],
                                  "verification": "Responda: 'Uma cadeia infinita de reduções prova P≠NP?' com justificativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigo 'Relativization Barriers' de Baker-Gill-Solovay, fóruns como StackExchange CS.",
                                  "tips": "Compare com analogias cotidianas, como dominós caindo.",
                                  "learningObjective": "Reconhecer os limites das reduções em cadeias no contexto aberto de P vs NP.",
                                  "commonMistakes": "Acreditar que cadeias provam separação P≠NP; confundir transitividade com universalidade."
                                }
                              ],
                              "practicalExample": "Considere a cadeia SAT → 3-SAT → Independent Set → Graph Coloring. Como SAT é NP-completo, reduza SAT para 3-SAT (paddings), 3-SAT para Independent Set (construção de grafo), e assim por diante. Isso prova que Graph Coloring é NP-completo transitivamente, permitindo colorir grafos em tempo polinomial se possível.",
                              "finalVerifications": [
                                "Construir e validar uma cadeia de 3 reduções corretas.",
                                "Explicar transitividade com prova formal breve.",
                                "Identificar limitações: não resolve P=NP.",
                                "Aplicar a um problema novo com sucesso.",
                                "Discutir uma barreira teórica como relativização.",
                                "Criar diagrama visual da cadeia."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de redução e NP-completude (30%).",
                                "Profundidade da análise de cadeia: composição e tempos corretos (25%).",
                                "Compreensão de implicações e limitações (20%).",
                                "Criatividade em exemplos e diagramas (15%).",
                                "Clareza na comunicação escrita/oral (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (construções em reduções).",
                                "Lógica: Provas formais e transitividade em teoremas.",
                                "Filosofia: Limites do conhecimento computacional e decidibilidade.",
                                "Engenharia de Software: Análise de complexidade em otimização."
                              ],
                              "realWorldApplication": "Em otimização logística, reduções em cadeia ajudam a provar que problemas como Vehicle Routing são NP-completos, guiando escolhas entre heurísticas (ex: GPS routing apps) e algoritmos exatos, impactando eficiência em supply chain da Amazon ou Uber."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.8.5.3.4",
                            "name": "Consultar referências para reduções específicas",
                            "description": "Localizar e resumir reduções de problemas como Mochila ou Caixeiro Viajante nos livros de Cormen, Garey & Johnson.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o problema e localizar os livros de referência",
                                  "subSteps": [
                                    "Pesquise o nome exato do problema (ex: '0-1 Knapsack' ou 'Traveling Salesman Problem') para garantir precisão.",
                                    "Liste os livros principais: 'Introduction to Algorithms' de Cormen et al. (Capítulo 34 ou 35 sobre NP-completude) e 'Computers and Intractability' de Garey & Johnson (índice de problemas NP-completos).",
                                    "Verifique edições disponíveis e acesse índices ou sumários online ou físicos para seções relevantes.",
                                    "Anote palavras-chave como 'reduction', 'NP-complete proof' associadas ao problema."
                                  ],
                                  "verification": "Lista de livros e seções identificadas está documentada com citações precisas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Cópias físicas ou PDFs dos livros: Cormen et al., Garey & Johnson",
                                    "Acesso a índices online ou ferramentas de busca em PDF (ex: Adobe Acrobat, Ctrl+F)"
                                  ],
                                  "tips": "Use o índice alfabético de Garey & Johnson para problemas específicos; é mais direto que Cormen.",
                                  "learningObjective": "Dominar a localização eficiente de conteúdos em referências acadêmicas padrão de teoria da computação.",
                                  "commonMistakes": "Confundir variantes do problema (ex: Knapsack ilimitado vs. 0-1); ignorar edições diferentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e ler a seção da redução no livro",
                                  "subSteps": [
                                    "Navegue até a página indicada no índice (ex: para TSP, seção 3.12 em Garey & Johnson).",
                                    "Leia a definição formal do problema e o teorema de NP-completude.",
                                    "Identifique a redução específica: origem (problema conhecido NP-completo) e passos de transformação polinomial.",
                                    "Anote diagramas, lemas ou pseudocódigos associados à prova."
                                  ],
                                  "verification": "Trechos chave da redução extraídos e destacados com paginação exata.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Livros abertos nas seções relevantes",
                                    "Bloco de notas ou ferramenta digital como Notion/Obsidian para anotações"
                                  ],
                                  "tips": "Leia duas vezes: primeira para visão geral, segunda para detalhes da construção da redução.",
                                  "learningObjective": "Extrair e compreender provas formais de NP-dureza de textos densos.",
                                  "commonMistakes": "Pular a justificativa de correção da redução (redução direta e reversa); confundir redução com aproximação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar os componentes da redução",
                                  "subSteps": [
                                    "Decomponha a redução em etapas: construção da instância, tempo polinomial, preservação de sim/não.",
                                    "Verifique se a redução é de Karp (muitos-para-um) ou Cook (Turing).",
                                    "Compare com reduções similares para o mesmo problema em diferentes livros.",
                                    "Desenhe fluxogramas ou exemplos numéricos pequenos para ilustrar."
                                  ],
                                  "verification": "Diagrama ou tabela resumindo entrada -> transformação -> saída da redução está criada.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": [
                                    "Papel/caneta para diagramas",
                                    "Ferramentas como Draw.io ou LaTeX para formalização"
                                  ],
                                  "tips": "Teste a redução com instância trivial (ex: 2 itens no Knapsack) para validar compreensão.",
                                  "learningObjective": "Analisar criticamente a estrutura e validade de reduções polinomiais.",
                                  "commonMistakes": "Ignorar análise de complexidade temporal da redução; assumir equivalência sem prova de ambas direções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resumir e sintetizar a redução",
                                  "subSteps": [
                                    "Escreva um resumo conciso: problema origem, construção, complexidade, referência exata.",
                                    "Inclua pseudocódigo se aplicável e um exemplo numérico.",
                                    "Compare reduções entre Cormen e Garey & Johnson se discrepâncias.",
                                    "Formate em parágrafos claros ou bullet points para clareza."
                                  ],
                                  "verification": "Resumo de 200-400 palavras revisado por clareza e precisão, com citações.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Editor de texto (Google Docs, Overleaf)",
                                    "Referências originais para verificação cruzada"
                                  ],
                                  "tips": "Use estrutura: Introdução -> Construção -> Correção -> Complexidade -> Conclusão.",
                                  "learningObjective": "Sintetizar conhecimento complexo em comunicação acionável e precisa.",
                                  "commonMistakes": "Omitir referência bibliográfica completa; exagerar ou simplificar demais a prova."
                                }
                              ],
                              "practicalExample": "Para o problema 0-1 Knapsack (NP-completo via redução de Partition): Em Garey & Johnson (p. 246), a instância de Partition {a1,...,an} é transformada em Knapsack com W = S/2, onde S=sum(ai), e pesos/valores=ai. Verifique se OTIMIZAÇÃO atinge S/2 iff Partition é sim.",
                              "finalVerifications": [
                                "Resumo localiza corretamente a seção/página nos livros citados.",
                                "Descreve origem da redução e passos de construção com precisão.",
                                "Inclui verificação de polinomialidade e preservação de solucionabilidade.",
                                "Fornece exemplo numérico executado manualmente.",
                                "Citações bibliográficas completas e consistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: 100% alinhado com texto original (sem invenções).",
                                "Clareza e estrutura: Fluxo lógico com subseções definidas.",
                                "Profundidade: Cobertura de correção (direta/reversa) e complexidade.",
                                "Originalidade: Síntese própria, não cópia direta.",
                                "Completude: Inclui diagramas/exemplos e comparações entre fontes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de Grafos para reduções em TSP.",
                                "Otimização Linear: Relaxações para Knapsack aproximado.",
                                "Lógica e Provas: Estruturas formais de teoremas de redução.",
                                "Pesquisa Acadêmica: Métodos de literatura review em CS."
                              ],
                              "realWorldApplication": "Em otimização de logística (TSP para rotas de entrega) ou alocação de recursos limitados (Knapsack em cloud computing), compreender reduções ajuda a justificar uso de heurísticas em problemas intratáveis, guiando escolhas em software como OR-Tools ou CPLEX."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 383
          }
        ],
        "totalSkills": 383
      }
    ]
  }
}