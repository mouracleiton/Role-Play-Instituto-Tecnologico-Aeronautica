{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T21:42:31.234Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - ES-10",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 334
    },
    "areas": [
      {
        "id": "10",
        "name": "Engenharia de Software",
        "description": "Área dedicada ao desenvolvimento e fundamentos de software no Instituto Tecnológico de Aeronáutica (ITA).",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Introdução à Computação",
            "description": "Introdução aos conceitos básicos de computação: algoritmo, programa, linguagem de programação e compilador. Software básico, lógica de programação e comandos em linguagem procedimental (atribuição, entrada/saída, condicionais, repetitivos, seletivos). Tratamento de exceções, tipos escalares e estruturados, subprogramação (funções, passagem de parâmetros por valor/referência, escopo, recursividade) e ponteiros.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Conceitos Básicos de Computação",
                "description": "Apresenta definições fundamentais como algoritmo, programa, linguagem de programação, compilador e software básico para computadores.",
                "totalSkills": 49,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Definição de Algoritmo",
                    "description": "Conceito fundamental de algoritmo, suas propriedades e representação em pseudocódigo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Definição de Algoritmo",
                        "description": "Compreender o conceito fundamental de algoritmo como uma sequência finita e ordenada de instruções bem definidas, independentes de linguagem de programação, destinadas a resolver um problema específico de forma eficiente.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Definir o que é um algoritmo",
                            "description": "Fornecer uma definição precisa de algoritmo, enfatizando sua natureza sequencial, finita e determinística, com exemplos cotidianos como receitas de cozinha ou instruções de montagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de sequencialidade, finitude e determinismo",
                                  "subSteps": [
                                    "Pesquise a definição de 'sequencial' no contexto de instruções: ações executadas uma após a outra em ordem fixa.",
                                    "Analise 'finita': um conjunto limitado de passos que termina após alcançar o objetivo.",
                                    "Estude 'determinística': o mesmo conjunto de entradas sempre produz a mesma saída, sem aleatoriedade.",
                                    "Compare esses termos com processos não algoritmos, como adivinhação.",
                                    "Anote exemplos pessoais para cada conceito."
                                  ],
                                  "verification": "Liste corretamente as três propriedades com definições próprias e um exemplo para cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dicionário online ou livro de introdução à computação",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use analogias simples como uma linha de produção para sequencialidade.",
                                  "learningObjective": "Identificar e definir as três propriedades essenciais de um algoritmo.",
                                  "commonMistakes": [
                                    "Confundir finitude com infinitude em loops",
                                    "Ignorar que determinismo exclui decisões aleatórias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar exemplos cotidianos de algoritmos",
                                  "subSteps": [
                                    "Escolha uma receita de cozinha simples e liste seus passos em ordem.",
                                    "Descreva instruções para amarrar sapatos como um algoritmo sequencial.",
                                    "Analise direções de GPS: entradas (origem/destino), passos finitos, saída previsível.",
                                    "Identifique por que uma lista de compras não é um algoritmo completo.",
                                    "Crie um fluxograma simples para um desses exemplos."
                                  ],
                                  "verification": "Forneça dois exemplos cotidianos com suas propriedades algoritmicas explicadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Receita impressa ou app de receitas",
                                    "Papel para fluxograma",
                                    "Vídeo de instruções cotidianas no YouTube"
                                  ],
                                  "tips": "Desenhe setas para mostrar a sequência visualmente.",
                                  "learningObjective": "Reconhecer algoritmos em atividades diárias através de análise.",
                                  "commonMistakes": [
                                    "Omitir a necessidade de entradas/saídas claras",
                                    "Confundir hábitos rotineiros com algoritmos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar algoritmos de outros processos",
                                  "subSteps": [
                                    "Liste processos não algoritmos: arte criativa, jogos de azar, conversas informais.",
                                    "Compare um algoritmo (receita) vs. improvisação (cozinhar sem receita).",
                                    "Discuta ambiguidades: instruções vagas não são algoritmos.",
                                    "Crie uma tabela comparativa: Algoritmo vs. Não-Algoritmo.",
                                    "Teste com um colega: explique a diferença usando sua tabela."
                                  ],
                                  "verification": "Crie e explique uma tabela com pelo menos 3 exemplos de cada categoria.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Timer para discussão"
                                  ],
                                  "tips": "Foque em critérios rigorosos: sequencial, finita, determinística.",
                                  "learningObjective": "Distinguir algoritmos de processos ambíguos ou infinitos.",
                                  "commonMistakes": [
                                    "Classificar qualquer instrução como algoritmo",
                                    "Ignorar a finitude em processos repetitivos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e verbalizar uma definição completa de algoritmo",
                                  "subSteps": [
                                    "Sintetize as propriedades: 'sequência finita de instruções determinísticas para resolver um problema'.",
                                    "Inclua entradas/saídas: 'Dadas entradas específicas, produz saída definida'.",
                                    "Escreva sua definição em 1-2 frases.",
                                    "Teste a definição com 3 exemplos e 1 contraexemplo.",
                                    "Grave-se explicando a definição em 1 minuto."
                                  ],
                                  "verification": "Apresente definição escrita e gravação que cubra todos os elementos chave.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gravador de voz ou celular",
                                    "Papel para rascunho"
                                  ],
                                  "tips": "Use linguagem simples, evite jargões desnecessários.",
                                  "learningObjective": "Construir e comunicar uma definição precisa e pessoal de algoritmo.",
                                  "commonMistakes": [
                                    "Definição vaga sem propriedades específicas",
                                    "Esquecer exemplos na explicação"
                                  ]
                                }
                              ],
                              "practicalExample": "Receita de sanduíche: 1. Pegue pão (entrada: ingredientes). 2. Coloque recheio. 3. Feche e corte. Sempre resulta no mesmo sanduíche para mesmas entradas.",
                              "finalVerifications": [
                                "Pode listar e explicar sequencial, finita e determinística?",
                                "Fornece 2 exemplos cotidianos corretos?",
                                "Diferencia algoritmo de processo não-algoritmico?",
                                "Escreve definição precisa com entradas/saídas?",
                                "Explica com fluxograma simples?",
                                "Responde perguntas de teste sem hesitação?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (cobre 3 propriedades principais)",
                                "Uso correto de exemplos cotidianos (relevantes e analisados)",
                                "Capacidade de diferenciação (tabela ou comparação clara)",
                                "Clareza na comunicação verbal/escrita",
                                "Inclusão de entradas/saídas na definição",
                                "Criatividade em analogias sem perder rigor"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e funções determinísticas",
                                "Ciências: Experimentos com passos replicáveis",
                                "Língua Portuguesa: Instruções claras e precisas",
                                "Artes: Coreografias como sequências finitas",
                                "Educação Física: Rotinas de exercícios sequenciais"
                              ],
                              "realWorldApplication": "Em programação, algoritmos formam a base de apps como Google Maps (direções otimizadas) ou redes sociais (feeds personalizados), resolvendo problemas cotidianos de forma eficiente e previsível."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Diferenciar algoritmo de programa",
                            "description": "Explicar as diferenças entre algoritmo (descrição abstrata e independente de hardware/software) e programa (implementação concreta em linguagem de programação específica, como C++ ou Python).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de algoritmo",
                                  "subSteps": [
                                    "Leia a definição: Algoritmo é uma sequência finita de instruções abstratas, independentes de linguagem ou hardware.",
                                    "Identifique características chave: passo a passo, finito, determinístico, entrada/saída definidas.",
                                    "Anote exemplos cotidianos: receita de bolo ou instruções para montar um móvel IKEA.",
                                    "Pesquise origens históricas: mencione Alan Turing ou problemas como o das Torres de Hanói.",
                                    "Resuma em suas palavras as propriedades essenciais de um algoritmo."
                                  ],
                                  "verification": "Escreva um parágrafo definindo algoritmo e liste 3 exemplos não-computacionais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a internet para pesquisa rápida",
                                    "Livro ou site sobre fundamentos de computação"
                                  ],
                                  "tips": [
                                    "Use analogias simples como 'receita de cozinha' para fixar o conceito abstrato.",
                                    "Evite confundir com código; foque na independência de plataforma."
                                  ],
                                  "learningObjective": "Definir algoritmo e suas propriedades principais de forma precisa.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com código fonte.",
                                    "Pensar que algoritmos precisam de computador.",
                                    "Ignorar a finitude (algoritmo deve terminar)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a definição de programa",
                                  "subSteps": [
                                    "Leia a definição: Programa é a implementação concreta de um algoritmo em uma linguagem de programação específica.",
                                    "Identifique características: dependente de sintaxe da linguagem (ex: Python, C++), compilável/executável em hardware.",
                                    "Compare com software: programa é o código fonte/binário que roda em máquina.",
                                    "Estude exemplos: código Python para somar dois números vs pseudocódigo.",
                                    "Anote dependências: compilador, interpretador, ambiente de execução."
                                  ],
                                  "verification": "Escreva um exemplo simples de programa em Python e explique sua ligação com um algoritmo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE online como Replit",
                                    "Documentação básica de Python",
                                    "Papel para rascunhos"
                                  ],
                                  "tips": [
                                    "Sempre comece com pseudocódigo antes de codificar para ver a transição.",
                                    "Teste o programa em um ambiente real para validar."
                                  ],
                                  "learningObjective": "Definir programa e contrastar sua concretude com a abstração do algoritmo.",
                                  "commonMistakes": [
                                    "Achar que todo programa é algoritmo (nem todo código bem estruturado é).",
                                    "Ignorar erros de sintaxe que impedem execução.",
                                    "Confundir programa com aplicativo final."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e listar diferenças chave",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para Algoritmo vs Programa (abstração vs concretude, independência vs dependência).",
                                    "Liste 5 diferenças principais: linguagem, hardware, legibilidade, execução, portabilidade.",
                                    "Discuta trade-offs: algoritmo é universal, programa é otimizado para contexto.",
                                    "Use fluxogramas: desenhe um algoritmo simples e sua versão em código.",
                                    "Revise com perguntas: 'Pode um algoritmo rodar sozinho? Um programa sem algoritmo?'"
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 diferenças e 1 exemplo cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel quadriculado para tabela",
                                    "Ferramenta de fluxograma online como Lucidchart free",
                                    "Exemplos de códigos prontos"
                                  ],
                                  "tips": [
                                    "Use mnemônicos: Algoritmo = 'A' de Abstrato, Programa = 'P' de Prático/Plataforma.",
                                    "Inclua portabilidade como diferença crucial."
                                  ],
                                  "learningObjective": "Articular diferenças fundamentais entre algoritmo e programa.",
                                  "commonMistakes": [
                                    "Minimizar a dependência de hardware no programa.",
                                    "Achar que algoritmos são sempre visuais (podem ser textuais).",
                                    "Confundir pseudocódigo com programa."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conceito em exemplos práticos",
                                  "subSteps": [
                                    "Escolha um problema simples: calcular média de notas.",
                                    "Escreva o algoritmo em pseudocódigo.",
                                    "Implemente como programa em Python.",
                                    "Compare: discuta mudanças necessárias pela linguagem.",
                                    "Teste e debugs: execute e note erros se algoritmo mal traduzido."
                                  ],
                                  "verification": "Produza algoritmo + programa para um problema e explique 3 diferenças observadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE Python online",
                                    "Lista de problemas simples de programação"
                                  ],
                                  "tips": [
                                    "Mantenha o algoritmo o mais simples possível para destacar diferenças.",
                                    "Documente suposições de entrada/saída."
                                  ],
                                  "learningObjective": "Demonstrar diferenciação prática através de implementação.",
                                  "commonMistakes": [
                                    "Implementar sem algoritmo primeiro.",
                                    "Ignorar tratamento de erros no programa.",
                                    "Tornar o algoritmo dependente de sintaxe."
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Encontrar o maior número em uma lista. Algoritmo (pseudocódigo): 1. Inicialize max = primeiro elemento. 2. Para cada elemento subsequente, se maior que max, atualize max. 3. Retorne max. Programa (Python): def maior(lista): max_val = lista[0] for num in lista[1:]: if num > max_val: max_val = num return max_val. Diferença: Algoritmo é legível em qualquer lugar; programa requer Python e sintaxe específica.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças principais sem hesitação.",
                                "Converter um algoritmo dado em programa correto em <5 minutos.",
                                "Identificar se um texto é algoritmo ou programa com 100% acerto em 5 exemplos.",
                                "Criar tabela comparativa completa e precisa.",
                                "Discutir por que planejar algoritmo antes de programar economiza tempo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem confusões conceituais).",
                                "Capacidade de listar ≥5 diferenças com exemplos.",
                                "Qualidade da implementação prática (código executável e correto).",
                                "Clareza na comunicação escrita/oral das diferenças.",
                                "Uso correto de analogias e conexões reais.",
                                "Ausência de erros comuns identificados nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica sequencial e estruturas de controle (loops, condicionais).",
                                "Língua Portuguesa: Redação clara e precisa de instruções (pseudocódigo como texto técnico).",
                                "Física: Abstração de processos físicos em passos lógicos (ex: simulações).",
                                "Artes: Fluxogramas como representação visual de ideias abstratas."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, engenheiros primeiro criam algoritmos para resolver problemas (ex: busca no Google), depois implementam em programas (Java/Scala), garantindo eficiência e portabilidade antes de codificar, reduzindo bugs e tempo de desenvolvimento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Relacionar algoritmo com lógica de programação",
                            "description": "Identificar como algoritmos formam a base da lógica de programação, conectando-os a conceitos como comandos procedurais e estruturas de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e características de um algoritmo",
                                  "subSteps": [
                                    "Leia a definição formal de algoritmo: sequência finita de instruções bem definidas para resolver um problema.",
                                    "Identifique as cinco características essenciais: finitude, definitividade, efetividade, entrada e saída.",
                                    "Escreva um exemplo simples de algoritmo em linguagem natural, como 'fazer um café'.",
                                    "Compare com fluxogramas ou pseudocódigo para visualizar a estrutura.",
                                    "Anote como algoritmos são independentes de linguagem de programação."
                                  ],
                                  "verification": "Você consegue listar e explicar as 5 características de um algoritmo com um exemplo próprio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a um fluxograma online simples"
                                  ],
                                  "tips": "Use analogias cotidianas para fixar conceitos abstratos.",
                                  "learningObjective": "Entender os fundamentos de um algoritmo como base lógica.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com programa (algoritmo é abstrato)",
                                    "Ignorar a finitude (algoritmos devem terminar)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar conceitos básicos de lógica de programação",
                                  "subSteps": [
                                    "Defina lógica de programação: conjunto de regras para instruir computadores de forma sequencial e lógica.",
                                    "Identifique comandos procedurais: instruções passo a passo executadas em ordem.",
                                    "Estude estruturas de controle: sequencial (ordem natural), condicional (if-else) e repetição (loops).",
                                    "Desenhe um diagrama simples mostrando o fluxo de execução.",
                                    "Compare lógica de programação com 'receitas de cozinha' para reforçar."
                                  ],
                                  "verification": "Você pode descrever as três principais estruturas de controle com exemplos verbais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou papel para diagramas",
                                    "Vídeo curto sobre estruturas de controle (YouTube)"
                                  ],
                                  "tips": "Pense na lógica como 'instruções para um robô sem bom senso'.",
                                  "learningObjective": "Dominar os blocos fundamentais da lógica de programação.",
                                  "commonMistakes": [
                                    "Misturar sequencial com condicional",
                                    "Esquecer que loops precisam de condição de parada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear conexões entre algoritmos e lógica de programação",
                                  "subSteps": [
                                    "Mapeie sequência de algoritmo para comandos procedurais sequenciais.",
                                    "Conecte decisões em algoritmos a estruturas condicionais (if-else).",
                                    "Relacione repetições em algoritmos a loops (while, for).",
                                    "Crie uma tabela comparativa: coluna algoritmo vs. lógica de programação.",
                                    "Analise como algoritmos fornecem a 'espinha dorsal' lógica antes da codificação."
                                  ],
                                  "verification": "Você constrói uma tabela com pelo menos 3 conexões claras entre algoritmo e lógica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela comparativa"
                                  ],
                                  "tips": "Use setas para mostrar 'algoritmo → implementa via lógica'.",
                                  "learningObjective": "Identificar como algoritmos se traduzem em lógica programável.",
                                  "commonMistakes": [
                                    "Ver algoritmo como 'código pronto' em vez de plano lógico",
                                    "Ignorar dependência: lógica implementa algoritmo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a relação em um exemplo integrado",
                                  "subSteps": [
                                    "Escolha um problema simples: 'verificar se um número é par ou ímpar'.",
                                    "Escreva o algoritmo em passos naturais.",
                                    "Traduza para pseudocódigo usando sequencial, condicional e (opcional) loop.",
                                    "Simule a execução passo a passo manualmente.",
                                    "Reflita: como o algoritmo guiou a lógica?"
                                  ],
                                  "verification": "Você executa o exemplo sem erros e explica a conexão em voz alta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo editor (como Notepad++)"
                                  ],
                                  "tips": "Teste com múltiplos inputs para validar.",
                                  "learningObjective": "Praticar a transição de algoritmo para lógica de programação.",
                                  "commonMistakes": [
                                    "Pular passos no algoritmo",
                                    "Implementar lógica sem base algorítmica"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Calcular a média de 3 notas e aprovar se >=7. Algoritmo: 1. Ler notas; 2. Somar; 3. Dividir por 3; 4. Se média >=7, aprovar. Pseudocódigo: INICIO; ler n1,n2,n3; media=(n1+n2+n3)/3; SE media>=7 ENTÃO aprovar SENÃO reprovar; FIM. Aqui, sequência forma procedurais, 'SE' é condicional.",
                              "finalVerifications": [
                                "Explica verbalmente como um algoritmo é a base lógica de um programa.",
                                "Identifica corretamente sequencial, condicional e iterativa em um algoritmo dado.",
                                "Traduz um algoritmo simples para pseudocódigo lógico.",
                                "Distingue algoritmo (abstrato) de código (concreto).",
                                "Lista exemplos reais onde lógica falha sem bom algoritmo.",
                                "Cria um fluxograma conectando ambos conceitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de conexões (80% correto).",
                                "Profundidade nos exemplos práticos (pelo menos 2 variações).",
                                "Clareza na explicação oral ou escrita.",
                                "Uso correto de terminologia (algoritmo, procedural, controle).",
                                "Capacidade de aplicação em novos problemas.",
                                "Ausência de confusões comuns (ex: loops infinitos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e sequências.",
                                "Língua Portuguesa: Estrutura narrativa sequencial e condicional.",
                                "Ciências: Processos experimentais passo a passo.",
                                "Artes: Fluxogramas como representação visual.",
                                "Física: Modelagem de sistemas com entradas/saídas."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, como apps de delivery: algoritmo planeja rota ótima (lógica sequencial/condicional/loops), implementado em código para otimizar entregas em tempo real, economizando combustível e tempo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Propriedades dos Algoritmos",
                        "description": "Identificar e descrever as propriedades essenciais que todo algoritmo deve possuir, garantindo sua validade e eficácia na resolução de problemas computacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Listar as propriedades básicas de um algoritmo",
                            "description": "Enumerar e descrever propriedades como definitividade (instruções precisas), finitude (término em passos finitos), entrada/saída (dados de entrada e resultados de saída) e efetividade (execução mecanicamente possível).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Geral de Algoritmo e Identificar Propriedades Principais",
                                  "subSteps": [
                                    "Ler a definição padrão de algoritmo como uma sequência de instruções finitas para resolver um problema.",
                                    "Identificar exemplos cotidianos de algoritmos, como receitas de bolo ou instruções de montagem de móveis.",
                                    "Listar as quatro propriedades básicas: definitividade, finitude, entrada/saída e efetividade.",
                                    "Explicar brevemente o propósito de cada propriedade em uma frase curta.",
                                    "Anotar em um quadro ou papel para visualização."
                                  ],
                                  "verification": "Escrever uma lista inicial das quatro propriedades com uma frase de definição para cada uma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto introdutório sobre algoritmos (livro ou PDF)",
                                    "Papel e caneta ou quadro branco",
                                    "Acesso a internet para exemplos visuais"
                                  ],
                                  "tips": "Use analogias simples como 'receita de cozinha' para fixar o conceito de sequência de passos.",
                                  "learningObjective": "Reconhecer as propriedades fundamentais de um algoritmo como base para listagem precisa.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com programa de computador",
                                    "Omitir alguma das quatro propriedades principais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar em Detalhe as Propriedades de Definitividade e Finitude",
                                  "subSteps": [
                                    "Definir definitividade: cada instrução deve ser precisa e unambígua, sem interpretações múltiplas.",
                                    "Exemplificar definitividade com um passo vago vs. preciso (ex: 'cozinhe' vs. 'ferva por 10 minutos a 100°C').",
                                    "Definir finitude: o algoritmo deve terminar após um número finito de passos.",
                                    "Exemplificar finitude com loops infinitos vs. contadores limitados.",
                                    "Criar um fluxograma simples ilustrando essas propriedades."
                                  ],
                                  "verification": "Descrever oralmente ou por escrito as duas propriedades com exemplos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma online (ex: Draw.io gratuito)",
                                    "Exemplos impressos de algoritmos ruins"
                                  ],
                                  "tips": "Teste a definitividade lendo o passo para outra pessoa e veja se entende sem dúvidas.",
                                  "learningObjective": "Dominar as descrições precisas de definitividade e finitude com exemplos práticos.",
                                  "commonMistakes": [
                                    "Confundir definitividade com finitude",
                                    "Ignorar exemplos concretos nas descrições"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Propriedades de Entrada/Saída e Efetividade",
                                  "subSteps": [
                                    "Definir entrada/saída: deve haver zero ou mais entradas definidas e pelo menos uma saída.",
                                    "Exemplificar com algoritmo de soma: entradas (dois números), saída (resultado).",
                                    "Definir efetividade: cada passo deve ser executável mecanicamente por humanos ou máquinas em tempo finito.",
                                    "Exemplificar efetividade com cálculos simples vs. operações impossíveis.",
                                    "Comparar as quatro propriedades em uma tabela comparativa."
                                  ],
                                  "verification": "Preencher uma tabela com definições, exemplos e não-exemplos para entrada/saída e efetividade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Calculadora para testes de efetividade"
                                  ],
                                  "tips": "Sempre pergunte: 'O que entra? O que sai? Dá para fazer à mão?' para validar.",
                                  "learningObjective": "Diferenciar e descrever entrada/saída e efetividade com clareza.",
                                  "commonMistakes": [
                                    "Esquecer que entradas podem ser zero",
                                    "Confundir efetividade com eficiência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Listagem Completa e Verificação das Propriedades",
                                  "subSteps": [
                                    "Listar as quatro propriedades em ordem padrão com descrições completas.",
                                    "Aplicar a listagem a um algoritmo simples, verificando cada propriedade.",
                                    "Recitar a lista de memória para um parceiro ou gravar áudio.",
                                    "Revisar e corrigir qualquer imprecisão nas descrições.",
                                    "Criar um cartão de memória (flashcard) para revisão rápida."
                                  ],
                                  "verification": "Listar verbalmente ou por escrito todas as propriedades com descrições exatas sem consulta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Flashcards ou app como Anki",
                                    "Gravador de voz no celular"
                                  ],
                                  "tips": "Pratique a listagem em voz alta diariamente por 5 minutos para memorização ativa.",
                                  "learningObjective": "Listar fluentemente as propriedades básicas com descrições precisas e acionáveis.",
                                  "commonMistakes": [
                                    "Alterar nomes das propriedades",
                                    "Fornecer descrições vagas ou incompletas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o algoritmo 'Calcular a soma de dois números': 1. Definitividade: Instruções precisas como 'some A + B'. 2. Finitude: Termina em 3 passos finitos. 3. Entrada/Saída: Entradas (A, B), Saída (S = A+B). 4. Efetividade: Soma executável manualmente.",
                              "finalVerifications": [
                                "Lista corretamente as quatro propriedades sem omissões.",
                                "Fornece definições precisas para cada propriedade.",
                                "Inclui exemplos relevantes para pelo menos duas propriedades.",
                                "Diferencia corretamente todas as propriedades umas das outras.",
                                "Aplica a listagem a um algoritmo simples com verificação.",
                                "Recita de memória em menos de 1 minuto."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem erros conceituais).",
                                "Completude: Todas as quatro propriedades incluídas.",
                                "Clareza nas descrições (linguagem simples e objetiva).",
                                "Uso de exemplos concretos para ilustração.",
                                "Capacidade de aplicação em contextos reais.",
                                "Fluência na recitação sem hesitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica sequencial e finitude em provas matemáticas.",
                                "Língua Portuguesa: Redação clara e precisa de instruções.",
                                "Física: Processos determinísticos e efetividade em experimentos.",
                                "História da Ciência: Evolução de algoritmos desde Euclides."
                              ],
                              "realWorldApplication": "Desenvolvedores de software usam essas propriedades para validar algoritmos antes de codificar, evitando loops infinitos em apps bancários ou sistemas de navegação GPS que processam entradas de localização para saídas precisas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Exemplificar cada propriedade",
                            "description": "Aplicar cada propriedade a um exemplo simples, como um algoritmo para calcular a média de números, demonstrando como a ausência de uma propriedade invalida o algoritmo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as propriedades fundamentais de um algoritmo",
                                  "subSteps": [
                                    "Liste as cinco propriedades principais: definitude, finitude, entrada, saída e eficácia.",
                                    "Defina cada propriedade em suas próprias palavras com um exemplo breve não relacionado à média.",
                                    "Crie uma tabela ou diagrama resumindo cada propriedade e seu significado.",
                                    "Compare com exemplos de pseudo-código simples para ilustrar.",
                                    "Discuta por que todas são necessárias para um algoritmo válido."
                                  ],
                                  "verification": "Conseguiu listar e definir corretamente todas as cinco propriedades sem erros factuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; acesso a material didático sobre algoritmos.",
                                  "tips": "Use mnemônicos como 'DEFES' (Definitude, Finitude, Entrada, Saída, Eficácia) para memorizar.",
                                  "learningObjective": "Compreender e articular as cinco propriedades essenciais de um algoritmo.",
                                  "commonMistakes": "Confundir finitude com infinitude ou ignorar a eficácia como executabilidade manual."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e descrever o algoritmo exemplo: calcular a média de números",
                                  "subSteps": [
                                    "Escreva o algoritmo em pseudo-código para calcular a média de 3 números: leia a, b, c; some = a+b+c; média = some/3; exiba média.",
                                    "Identifique claramente as entradas (3 números) e saídas (média calculada).",
                                    "Desenhe um fluxograma simples do algoritmo.",
                                    "Execute manualmente com números exemplo (ex: 10, 20, 30) e anote o resultado.",
                                    "Valide se o algoritmo atende preliminarmente às propriedades."
                                  ],
                                  "verification": "Pseudo-código escrito corretamente e execução manual produz resultado preciso (ex: média=20).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto ou papel; calculadora para verificação.",
                                  "tips": "Mantenha o exemplo simples com números fixos ou variáveis para evitar complexidade desnecessária.",
                                  "learningObjective": "Construir um algoritmo concreto que sirva de base para exemplificação de propriedades.",
                                  "commonMistakes": "Esquecer de definir variáveis ou não especificar como exibir a saída."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Exemplificar cada propriedade no algoritmo de média",
                                  "subSteps": [
                                    "Para definitude: Explique como cada instrução é precisa (ex: 'some = a+b+c' sem ambiguidades).",
                                    "Para finitude: Conte os passos finitos (5 passos) e mostre que termina.",
                                    "Para entrada: Destaque 'leia a, b, c' como dados necessários.",
                                    "Para saída: Indique 'exiba média' como resultado produzido.",
                                    "Para eficácia: Demonstre execução manual passo a passo com lápis e papel.",
                                    "Registre cada explicação em uma tabela: Propriedade | Exemplo no Algoritmo."
                                  ],
                                  "verification": "Tabela completa com explicações claras e exemplos específicos para todas as propriedades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela em planilha ou papel; exemplos numéricos anotados.",
                                  "tips": "Use setas ou destaques no pseudo-código para mapear cada propriedade visualmente.",
                                  "learningObjective": "Aplicar cada propriedade ao exemplo, demonstrando conformidade.",
                                  "commonMistakes": "Ser vago nas explicações, como dizer 'é finito' sem contar passos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar invalidação removendo cada propriedade",
                                  "subSteps": [
                                    "Remova definitude: Torne uma instrução ambígua (ex: 'some = a + algo') e explique falha.",
                                    "Remova finitude: Adicione loop infinito e mostre não término.",
                                    "Remova entrada: Omita 'leia' e discuta falta de dados.",
                                    "Remova saída: Remova 'exiba' e explique ausência de resultado.",
                                    "Remova eficácia: Inclua passo impossível (ex: 'divida por zero sempre') e demonstre.",
                                    "Para cada, reescreva pseudo-código modificado e anote consequências."
                                  ],
                                  "verification": "Cinco versões modificadas do algoritmo, cada uma com explicação de invalidação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Cópias do pseudo-código original; espaço para anotações.",
                                  "tips": "Teste cada versão manualmente para vivenciar a invalidação.",
                                  "learningObjective": "Ilustrar criticamente por que cada propriedade é indispensável.",
                                  "commonMistakes": "Não mostrar impacto prático, como 'não funciona' sem demonstração."
                                }
                              ],
                              "practicalExample": "Algoritmo para calcular média de 3 números: 1. Leia a, b, c. 2. some ← a + b + c. 3. média ← some / 3. 4. Exiba média. (Exemplo: a=10, b=20, c=30 → média=20). Modificação sem finitude: Adicione 'repita indefinidamente' → nunca termina.",
                              "finalVerifications": [
                                "Pode listar e definir as 5 propriedades sem hesitação.",
                                "Executa o algoritmo de média corretamente com novos números.",
                                "Explica cada propriedade aplicada ao exemplo com precisão.",
                                "Modifica o algoritmo para invalidar cada propriedade e justifica.",
                                "Cria fluxograma ou tabela resumindo tudo.",
                                "Responde perguntas sobre diferenças entre versões válidas e inválidas."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão nas definições das propriedades (20%).",
                                "Qualidade do pseudo-código e execução manual (20%).",
                                "Profundidade das exemplificações positivas (20%).",
                                "Eficácia das demonstrações de invalidação (20%).",
                                "Organização visual (tabelas/fluxogramas) e completude (20%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de média e operações aritméticas básicas.",
                                "Lógica e Filosofia: Conceitos de precisão e validade em raciocínio.",
                                "Língua Portuguesa: Redação clara de instruções e descrições.",
                                "Educação Financeira: Algoritmos para médias em orçamentos ou notas."
                              ],
                              "realWorldApplication": "Em programação de apps (ex: calculadora de notas escolares), receitas culinárias (proporções exatas), planejamento de rotas GPS (passos finitos e precisos) ou processos industriais (linhas de produção com entradas/saídas definidas)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Avaliar se uma sequência é um algoritmo válido",
                            "description": "Analisar uma dada sequência de instruções e verificar se atende a todas as propriedades, justificando sim ou não com argumentos baseados nas definições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as Propriedades Fundamentais de um Algoritmo",
                                  "subSteps": [
                                    "Liste as cinco propriedades principais de um algoritmo: Finitividade, Definitividade, Entrada, Saída e Efetividade.",
                                    "Escreva a definição precisa de cada propriedade em suas próprias palavras.",
                                    "Forneça um exemplo simples de uma sequência que atende e outra que falha em cada propriedade.",
                                    "Explique por que cada propriedade é essencial para garantir que a sequência funcione como algoritmo.",
                                    "Anote qualquer dúvida ou confusão para esclarecer antes de prosseguir."
                                  ],
                                  "verification": "Você consegue recitar e explicar corretamente todas as cinco propriedades com exemplos, sem consultar notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência às definições de algoritmo (livro didático ou site confiável)"
                                  ],
                                  "tips": "Use o acrônimo 'FDESE' para memorizar as propriedades: Finitividade, Definitividade, Entrada, Saída, Efetividade.",
                                  "learningObjective": "Internalizar as definições exatas das propriedades de um algoritmo para análise precisa.",
                                  "commonMistakes": [
                                    "Confundir finitividade com presença de loops (loops finitos são permitidos).",
                                    "Achar que 'definitividade' significa apenas 'correto', ignorando ambiguidades linguísticas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ler e Compreender a Sequência de Instruções",
                                  "subSteps": [
                                    "Leia a sequência inteira pelo menos duas vezes para captar o fluxo geral.",
                                    "Numere cada instrução sequencialmente para facilitar referências futuras.",
                                    "Identifique entradas explícitas (dados iniciais) e implícitas na sequência.",
                                    "Identifique saídas explícitas (resultados produzidos) e implícitas.",
                                    "Registre qualquer parte ambígua, vaga ou mal definida nas instruções."
                                  ],
                                  "verification": "Você possui uma versão anotada da sequência com números, entradas/saídas destacadas e ambiguidades marcadas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Cópia impressa ou digital da sequência de instruções",
                                    "Caneta marca-texto ou editor com realce"
                                  ],
                                  "tips": "Destaque entradas em azul, saídas em verde e ambiguidades em vermelho para visualização rápida.",
                                  "learningObjective": "Desenvolver habilidade de leitura atenta e identificação de componentes chave em sequências instrucionais.",
                                  "commonMistakes": [
                                    "Ler superficialmente e pular detalhes lógicos.",
                                    "Assumir entradas/saídas sem evidência explícita na sequência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Cada Propriedade Sistematicamente",
                                  "subSteps": [
                                    "Crie uma tabela com colunas: Propriedade, Atende? (Sim/Não), Justificativa com citação de instruções.",
                                    "Verifique Finitividade: A sequência termina em passos finitos, sem loops infinitos?",
                                    "Verifique Definitividade: Cada instrução é precisa, sem ambiguidades?",
                                    "Verifique Entrada e Saída: Há dados de entrada e resultado de saída claros?",
                                    "Verifique Efetividade: Todas as instruções são executáveis por humanos ou máquinas?",
                                    "Preencha a tabela com evidências específicas da sequência."
                                  ],
                                  "verification": "Tabela completa preenchida com todas as propriedades avaliadas e justificativas baseadas em instruções específicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelo de tabela de verificação (papel ou planilha)",
                                    "Sequência anotada do passo anterior"
                                  ],
                                  "tips": "Sempre cite o número da instrução na justificativa, ex: 'Instrução 3 falha pois...'.",
                                  "learningObjective": "Aplicar critérios analíticos de forma estruturada e evidência-based.",
                                  "commonMistakes": [
                                    "Justificativas vagas sem referência a instruções específicas.",
                                    "Marcar 'sim' em efetividade sem considerar se passos são factíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Resultados e Formular Conclusão Justificada",
                                  "subSteps": [
                                    "Conte o número de propriedades atendidas (todas 5 necessárias para válido).",
                                    "Se todas atendidas, escreva conclusão 'Sim, é algoritmo válido' com resumo das forças.",
                                    "Se alguma falha, liste as falhas principais e explique por que invalidam.",
                                    "Redija um parágrafo de justificativa completa, lógico e conciso.",
                                    "Revise a conclusão para clareza, correção e completude, corrigindo erros."
                                  ],
                                  "verification": "Conclusão final clara (sim/não) acompanhada de justificativa que referencia a tabela de verificação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de verificação do passo 3",
                                    "Rascunho para redação final"
                                  ],
                                  "tips": "Estruture a justificativa como: 'Baseado na análise, [conclusão] porque [falhas ou forças principais].'",
                                  "learningObjective": "Sintetizar análise em argumento persuasivo e bem fundamentado.",
                                  "commonMistakes": [
                                    "Concluir 'válido' se faltar uma propriedade essencial.",
                                    "Justificativas subjetivas sem ligação à análise tabular."
                                  ]
                                }
                              ],
                              "practicalExample": "Sequência: '1. Pegue dois números inteiros positivos A e B. 2. Enquanto A ≠ B, se A > B subtraia B de A, senão subtraia A de B. 3. Imprima A.' Análise: Verifique finitividade (loop termina quando A=B), definitividade (instruções claras), entrada (A,B), saída (imprime A=MDC), efetividade (operações básicas). Conclusão: Válido (algoritmo de Euclides).",
                              "finalVerifications": [
                                "Lista e define corretamente todas as 5 propriedades.",
                                "Analisa sequências exemplo com acurácia de 100%.",
                                "Produz justificativas claras e evidência-based.",
                                "Identifica falhas sutis como ambiguidades ou loops infinitos.",
                                "Aplica o método a novas sequências sem erros.",
                                "Explica implicações de falhas em termos práticos."
                              ],
                              "assessmentCriteria": [
                                "Completude da verificação de todas propriedades (30%)",
                                "Precisão e profundidade das justificativas (30%)",
                                "Clareza e organização da tabela/análise (20%)",
                                "Lógica e correção da conclusão final (10%)",
                                "Uso de exemplos e referências específicas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e análise de provas por casos.",
                                "Língua Portuguesa: Interpretação textual e argumentação escrita.",
                                "Filosofia: Análise conceitual e definição de termos.",
                                "Ciências: Verificação de procedimentos experimentais.",
                                "Engenharia: Validação de especificações técnicas."
                              ],
                              "realWorldApplication": "Desenvolvedores verificam pseudocódigo antes de codificar para evitar bugs; gerentes de processos industriais validam SOPs (Standard Operating Procedures) para segurança e eficiência; educadores analisam receitas ou instruções para ensinar lógica computacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Representação em Pseudocódigo",
                        "description": "Dominar a técnica de representação de algoritmos em pseudocódigo, uma notação intermediária legível e independente de linguagens específicas, facilitando a transição para programação real.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Compreender a estrutura do pseudocódigo",
                            "description": "Explicar convenções básicas do pseudocódigo, como uso de INÍCIO/FIM, atribuições (← ou :=), entrada (LER) e saída (ESCREVER), condicionais (SE/ENTÃO/SENÃO) e laços (ENQUANTO/REPETIR).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura geral e blocos do pseudocódigo",
                                  "subSteps": [
                                    "Reconhecer o pseudocódigo como linguagem intermediária entre o natural e a programação.",
                                    "Identificar o uso obrigatório de INÍCIO e FIM para delimitar o algoritmo.",
                                    "Aprender a usar indentação para representar blocos hierárquicos.",
                                    "Observar convenções como palavras-chave em maiúsculas (ex: INÍCIO, FIM).",
                                    "Analisar exemplos simples de estrutura básica."
                                  ],
                                  "verification": "Escrever um pseudocódigo vazio com INÍCIO e FIM corretos e indentação adequada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples",
                                    "Exemplos de pseudocódigo impressos"
                                  ],
                                  "tips": "Sempre use INÍCIO no topo e FIM no final; indentação ajuda na legibilidade.",
                                  "learningObjective": "Compreender a delimitação e organização básica de um pseudocódigo.",
                                  "commonMistakes": [
                                    "Esquecer INÍCIO ou FIM.",
                                    "Não usar indentação, tornando o código confuso.",
                                    "Misturar minúsculas e maiúsculas em palavras-chave."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar atribuições, entrada e saída de dados",
                                  "subSteps": [
                                    "Aprender símbolos de atribuição: ← ou := para atribuir valores a variáveis.",
                                    "Usar LER para entrada de dados do usuário.",
                                    "Usar ESCREVER para saída de resultados na tela.",
                                    "Praticar declarações simples como: nota ← LER(\"Digite a nota\").",
                                    "Combinar atribuição com entrada e saída em um fluxo básico."
                                  ],
                                  "verification": "Criar pseudocódigo que leia um número e o exiba com atribuição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Simulador online de pseudocódigo (opcional)"
                                  ],
                                  "tips": "LER sempre entre parênteses com mensagem; evite confundir atribuição com igualdade.",
                                  "learningObjective": "Aplicar comandos básicos de fluxo de dados no pseudocódigo.",
                                  "commonMistakes": [
                                    "Usar = em vez de ← ou :=.",
                                    "Esquecer parênteses em LER ou ESCREVER.",
                                    "Não inicializar variáveis antes de usar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender estruturas condicionais",
                                  "subSteps": [
                                    "Estudar a sintaxe: SE condição ENTÃO ... SENÃO ... FIM-SE.",
                                    "Identificar operadores relacionais: >, <, =, >=, etc.",
                                    "Praticar condições simples como SE idade >= 18 ENTÃO maior ← VERDADEIRO.",
                                    "Aninhar condicionais dentro de blocos indentados.",
                                    "Testar com exemplos de decisão binária."
                                  ],
                                  "verification": "Escrever pseudocódigo com SE/SENÃO para verificar aprovação de nota.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Lista de operadores relacionais"
                                  ],
                                  "tips": "Sempre feche com FIM-SE; use ENTÃO após a condição.",
                                  "learningObjective": "Implementar lógica de decisão em pseudocódigo.",
                                  "commonMistakes": [
                                    "Esquecer FIM-SE.",
                                    "Usar operadores lógicos incorretos (ex: && em vez de E).",
                                    "Não indentar o bloco SENÃO."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar estruturas de repetição (laços)",
                                  "subSteps": [
                                    "Aprender ENQUANTO condição FAÇA ... FIM-ENQUANTO.",
                                    "Estudar REPETIR ... ATÉ condição.",
                                    "Praticar contadores em laços como ENQUANTO i <= 10 FAÇA.",
                                    "Combinar laços com condicionais e entrada/saída.",
                                    "Analisar diferenças entre pré e pós-teste."
                                  ],
                                  "verification": "Criar pseudocódigo com laço para somar números até um limite.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de laços impressos"
                                  ],
                                  "tips": "Inicialize contadores antes do laço; teste condições para evitar loops infinitos.",
                                  "learningObjective": "Utilizar repetições controladas em pseudocódigo.",
                                  "commonMistakes": [
                                    "Loop infinito por condição sempre verdadeira.",
                                    "Esquecer FIM-ENQUANTO ou ATÉ.",
                                    "Não alterar variável de controle no laço."
                                  ]
                                }
                              ],
                              "practicalExample": "Pseudocódigo para calcular média de 3 notas:\nINÍCIO\n  nota1 ← LER(\"Nota 1\")\n  nota2 ← LER(\"Nota 2\")\n  nota3 ← LER(\"Nota 3\")\n  media ← (nota1 + nota2 + nota3) / 3\n  SE media >= 7 ENTÃO\n    ESCREVER(\"Aprovado\")\n  SENÃO\n    ESCREVER(\"Reprovado\")\n  FIM-SE\nFIM",
                              "finalVerifications": [
                                "Explicar verbalmente o papel de INÍCIO/FIM.",
                                "Identificar e corrigir erros em um pseudocódigo dado.",
                                "Escrever pseudocódigo simples com entrada, saída e condicional.",
                                "Converter um laço ENQUANTO para REPETIR e vice-versa.",
                                "Ler e descrever o fluxo de um pseudocódigo completo.",
                                "Listar 3 convenções básicas do pseudocódigo."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de INÍCIO/FIM e indentação (30%).",
                                "Precisão em atribuições, LER e ESCREVER (20%).",
                                "Estruturas condicionais sem erros sintáticos (20%).",
                                "Laços com controle adequado e sem loops infinitos (20%).",
                                "Legibilidade geral e convenções maiúsculas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e operadores relacionais.",
                                "Língua Portuguesa: Estrutura textual e redação clara.",
                                "Física/Química: Modelagem de processos iterativos em experimentos.",
                                "Artes: Fluxogramas como representação visual equivalente."
                              ],
                              "realWorldApplication": "Desenvolvedores usam pseudocódigo para planejar soluções algorítmicas antes de implementar em linguagens reais como Python ou Java, facilitando depuração inicial e comunicação em equipes multidisciplinares."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Escrever pseudocódigo simples",
                            "description": "Converter um problema básico, como somar dois números, em pseudocódigo estruturado, incluindo entrada, processamento e saída, respeitando as propriedades algorítmicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Problema e Identificar Componentes",
                                  "subSteps": [
                                    "Leia cuidadosamente a descrição do problema, como 'somar dois números'.",
                                    "Identifique as entradas necessárias (ex: dois números do usuário).",
                                    "Defina o processamento principal (ex: realizar a soma).",
                                    "Determine a saída esperada (ex: exibir o resultado da soma).",
                                    "Verifique as propriedades algorítmicas: definitude (instruções claras), finitude (passos limitados), efetividade (executável manualmente)."
                                  ],
                                  "verification": "Crie uma lista ou tabela com entradas, processamento, saída e propriedades confirmadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Descrição do problema impressa ou digital"
                                  ],
                                  "tips": "Use a pergunta IPO (Input-Process-Output) para estruturar sua análise.",
                                  "learningObjective": "Compreender e decompor um problema em componentes algorítmicos básicos.",
                                  "commonMistakes": [
                                    "Pular a identificação de entradas/saídas",
                                    "Ignorar propriedades algorítmicas como finitude"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Variáveis e Estrutura Inicial",
                                  "subSteps": [
                                    "Escolha nomes descritivos para variáveis (ex: numero1, numero2, resultado).",
                                    "Escreva o cabeçalho do pseudocódigo: 'INÍCIO'.",
                                    "Declare todas as variáveis no início.",
                                    "Adicione a seção de entrada: 'LEIA numero1' e 'LEIA numero2'.",
                                    "Inclua placeholders para processamento e saída."
                                  ],
                                  "verification": "Estrutura inicial escrita com declarações e entradas completas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto simples ou papel",
                                    "Referência de sintaxe de pseudocódigo (ex: guia online)"
                                  ],
                                  "tips": "Use verbos no infinitivo para comandos (LEIA, ESCREVA) e evite acentos para simplicidade.",
                                  "learningObjective": "Criar uma estrutura esquelética clara e padronizada para pseudocódigo.",
                                  "commonMistakes": [
                                    "Nomes de variáveis ambíguos como 'a' ou 'x'",
                                    "Esquecer declarações de variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Processamento e Saída",
                                  "subSteps": [
                                    "Escreva o processamento: 'resultado = numero1 + numero2'.",
                                    "Adicione a seção de saída: 'ESCREVA resultado'.",
                                    "Garanta sequência lógica sem loops ou condicionais desnecessários para problemas simples.",
                                    "Teste mentalmente: simule com valores (ex: 5 + 3 = 8).",
                                    "Adicione o rodapé: 'FIM'."
                                  ],
                                  "verification": "Pseudocódigo completo simulado com entrada de teste produzindo saída correta.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Calculadora para validação manual"
                                  ],
                                  "tips": "Mantenha linear para problemas básicos; adicione indentação para clareza visual.",
                                  "learningObjective": "Construir o núcleo lógico do algoritmo com processamento e saída precisos.",
                                  "commonMistakes": [
                                    "Confundir atribuição (=) com igualdade (==)",
                                    "Omitir saída ou usar ESCREVA incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Revisar e Validar o Pseudocódigo",
                                  "subSteps": [
                                    "Leia o pseudocódigo inteiro verificando clareza e legibilidade.",
                                    "Confirme todas as propriedades algorítmicas (definitude, efetividade, finitude).",
                                    "Teste com múltiplos exemplos (ex: 0+0, negativos).",
                                    "Corrija erros gramaticais ou lógicos.",
                                    "Melhore formatação para melhor apresentação."
                                  ],
                                  "verification": "Pseudocódigo revisado passa em testes manuais e checklist de propriedades.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Pseudocódigo impresso",
                                    "Checklist de propriedades algorítmicas"
                                  ],
                                  "tips": "Peça a alguém para ler e seguir os passos sem sua ajuda.",
                                  "learningObjective": "Garantir qualidade e correção através de revisão sistemática.",
                                  "commonMistakes": [
                                    "Não testar com casos extremos",
                                    "Ignorar indentação ou formatação"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Somar dois números.\n\nINÍCIO\n  numero1 ← LEIA \"Digite o primeiro número:\"\n  numero2 ← LEIA \"Digite o segundo número:\"\n  resultado ← numero1 + numero2\n  ESCREVA \"A soma é: \" + resultado\nFIM",
                              "finalVerifications": [
                                "Pseudocódigo inicia com INÍCIO e termina com FIM?",
                                "Entradas, processamento e saídas estão claramente separadas?",
                                "Variáveis declaradas e usadas consistentemente?",
                                "Propriedades algorítmicas (definitude, finitude, efetividade) atendidas?",
                                "Testes manuais com 3 exemplos diferentes produzem resultados corretos?",
                                "Texto é legível, sem ambiguidades ou erros?"
                              ],
                              "assessmentCriteria": [
                                "Estrutura IPO (Input-Process-Output) completa e lógica.",
                                "Comandos padronizados (LEIA, ESCREVA, atribuições corretas).",
                                "Nomes de variáveis descritivos e consistentes.",
                                "Respeito integral às propriedades algorítmicas.",
                                "Clareza e formatação visual (indentação, maiúsculas para comandos).",
                                "Funcionalidade comprovada por simulação manual."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de operações aritméticas básicas.",
                                "Lógica e Raciocínio: Sequenciação de passos ordenados.",
                                "Língua Portuguesa: Escrita clara, objetiva e sem ambiguidades.",
                                "Resolução de Problemas: Decomposição sistemática de tarefas."
                              ],
                              "realWorldApplication": "Desenvolvedores usam pseudocódigo para planejar soluções complexas antes de implementar em linguagens como Python ou Java, facilitando prototipagem rápida, revisão por pares e redução de erros em projetos de software reais, como apps de calculadora ou sistemas financeiros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.1",
                              "10.1.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Interpretar pseudocódigo existente",
                            "description": "Ler e simular a execução passo a passo de um pseudocódigo fornecido, rastreando variáveis e fluxos de controle para prever saídas em cenários variados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Familiarizar-se com a sintaxe e estrutura geral do pseudocódigo",
                                  "subSteps": [
                                    "Leia o pseudocódigo inteiro de cima para baixo para obter uma visão geral.",
                                    "Identifique blocos principais: início/fim, declarações de variáveis, instruções de entrada/saída.",
                                    "Destaque palavras-chave como SE, SENÃO, ENQUANTO, PARA, LEIA, ESCREVA.",
                                    "Anote a indentação para entender hierarquia de blocos.",
                                    "Desenhe um fluxograma simples da estrutura de alto nível."
                                  ],
                                  "verification": "Crie um fluxograma ou mapa mental da estrutura e compare com o pseudocódigo original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta digital como Draw.io",
                                    "Pseudocódigo impresso ou em editor de texto"
                                  ],
                                  "tips": "Use cores diferentes para destacar tipos de instruções (ex: azul para condicionais, verde para loops).",
                                  "learningObjective": "Compreender a organização e convenções sintáticas do pseudocódigo.",
                                  "commonMistakes": [
                                    "Ignorar indentação, levando a confusão em blocos aninhados.",
                                    "Confundir pseudocódigo com sintaxe de linguagem real."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e rastrear inicialização de variáveis",
                                  "subSteps": [
                                    "Liste todas as variáveis declaradas e seus valores iniciais (se especificados).",
                                    "Marque pontos de entrada de dados (LEIA) e atribuições.",
                                    "Crie uma tabela de rastreamento com colunas: Linha, Variável, Valor Inicial.",
                                    "Simule valores iniciais antes da execução.",
                                    "Verifique se há variáveis não inicializadas que podem causar erros."
                                  ],
                                  "verification": "Preencha a tabela inicial e confirme que todas as variáveis têm valores plausíveis no início.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Pseudocódigo anotado"
                                  ],
                                  "tips": "Assuma valores padrão (como 0 para inteiros) apenas se o pseudocódigo implicar.",
                                  "learningObjective": "Mapear o estado inicial das variáveis para preparar a simulação.",
                                  "commonMistakes": [
                                    "Esquecer variáveis locais em blocos.",
                                    "Confundir nomes semelhantes de variáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular execução passo a passo, rastreando fluxos de controle",
                                  "subSteps": [
                                    "Execute linha por linha, atualizando a tabela de variáveis a cada mudança.",
                                    "Para condicionais (SE), avalie a condição e marque o caminho tomado.",
                                    "Para loops (ENQUANTO/PARA), conte iterações e atualize variáveis por ciclo.",
                                    "Registre saídas (ESCREVA) em uma lista de resultados esperados.",
                                    "Pule linhas não executadas e anote desvios de fluxo."
                                  ],
                                  "verification": "A tabela final de variáveis deve coincidir com o estado ao final do pseudocódigo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de rastreamento expandida",
                                    "Marcadores para anotações"
                                  ],
                                  "tips": "Use setas na tabela para mostrar mudanças de valor ao longo das linhas.",
                                  "learningObjective": "Dominar a simulação dinâmica de variáveis e decisões.",
                                  "commonMistakes": [
                                    "Atualizar variáveis incorretamente em loops.",
                                    "Perder o controle de fluxo em condicionais aninhados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever saídas e validar a simulação em cenários variados",
                                  "subSteps": [
                                    "Compile todas as saídas previstas de ESCREVA.",
                                    "Teste com entradas diferentes alterando valores iniciais.",
                                    "Compare previsão com execução mental repetida.",
                                    "Identifique possíveis erros lógicos no pseudocódigo.",
                                    "Escreva uma explicação narrativa da execução."
                                  ],
                                  "verification": "Para 3 entradas diferentes, as saídas previstas batem com simulações independentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo com múltiplas entradas hipotéticas",
                                    "Lista de saídas esperadas"
                                  ],
                                  "tips": "Escolha entradas que testem bordas, como zero, negativos ou valores extremos.",
                                  "learningObjective": "Aplicar a interpretação para prever comportamentos em contextos reais.",
                                  "commonMistakes": [
                                    "Não testar casos extremos.",
                                    "Ignorar efeitos colaterais de loops infinitos potenciais."
                                  ]
                                }
                              ],
                              "practicalExample": "Pseudocódigo: INICIO; LEIA nota1, nota2; media = (nota1 + nota2)/2; SE media >= 7 ENTAO ESCREVA 'Aprovado'; SENAO ESCREVA 'Reprovado'; FIM. Simulação com nota1=8, nota2=6: media=7, saída 'Aprovado'. Com nota1=5, nota2=5: media=5, saída 'Reprovado'.",
                              "finalVerifications": [
                                "Rastreia corretamente valores de variáveis em pelo menos 3 execuções completas.",
                                "Identifica caminhos de fluxo corretos em condicionais e loops.",
                                "Prevê saídas precisas para entradas variadas, incluindo casos extremos.",
                                "Cria tabelas de rastreamento sem erros de atualização.",
                                "Explica verbalmente a execução passo a passo.",
                                "Detecta anomalias lógicas no pseudocódigo."
                              ],
                              "assessmentCriteria": [
                                "Precisão no rastreamento de variáveis (90% correto).",
                                "Correta simulação de fluxos de controle sem desvios.",
                                "Capacidade de lidar com estruturas aninhadas.",
                                "Eficiência na previsão de saídas para múltiplos cenários.",
                                "Clareza na documentação da simulação (tabelas/fluxogramas).",
                                "Identificação de erros potenciais no pseudocódigo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Raciocínio lógico e avaliação de expressões aritméticas.",
                                "Língua Portuguesa: Compreensão e interpretação de textos instrucionais.",
                                "Física: Modelagem sequencial de processos e simulações.",
                                "Artes: Visualização através de fluxogramas e diagramas."
                              ],
                              "realWorldApplication": "Na engenharia de software, interpretar pseudocódigo permite debugar algoritmos antes da codificação real, revisar código de equipes e entender especificações em projetos como apps de cálculo financeiro ou sistemas de controle de estoque."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.4",
                            "name": "Relacionar pseudocódigo a compiladores e linguagens",
                            "description": "Explicar como pseudocódigo serve de ponte para implementação em linguagens de programação, envolvendo compiladores para tradução em código executável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Pseudocódigo como Ponte Conceitual",
                                  "subSteps": [
                                    "Defina pseudocódigo como uma representação informal e legível de algoritmos, independente de linguagem específica.",
                                    "Identifique elementos chave do pseudocódigo: estruturas de controle (SE, ENQUANTO, PARA) e variáveis abstratas.",
                                    "Explique como o pseudocódigo abstrai a lógica, ignorando sintaxe rígida de linguagens reais.",
                                    "Compare pseudocódigo com fluxogramas para reforçar sua função de planejamento."
                                  ],
                                  "verification": "Escreva uma definição de pseudocódigo em suas palavras e liste 3 exemplos de estruturas comuns.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de pseudocódigo de aulas anteriores"
                                  ],
                                  "tips": "Mantenha o foco na lógica, não na sintaxe; use português ou inglês simples para clareza.",
                                  "learningObjective": "Reconhecer o pseudocódigo como etapa intermediária entre ideia algorítmica e código executável.",
                                  "commonMistakes": [
                                    "Confundir pseudocódigo com código fonte real",
                                    "Omitir estruturas de controle essenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Linguagens de Programação e o Papel dos Compiladores",
                                  "subSteps": [
                                    "Descreva linguagens de programação como conjuntos de instruções formais para computadores.",
                                    "Diferencie linguagens compiladas (ex: C++) de interpretadas (ex: Python).",
                                    "Explique o compilador: traduz código fonte para código máquina/executável via fases (léxico, sintático, semântico).",
                                    "Liste etapas básicas de compilação: pré-processamento, compilação, linkage."
                                  ],
                                  "verification": "Desenhe um fluxograma simples mostrando código fonte -> compilador -> executável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre compiladores (YouTube: 'How Compilers Work')",
                                    "Diagrama impresso de processo de compilação"
                                  ],
                                  "tips": "Visualize o compilador como um 'tradutor' que verifica erros antes da execução.",
                                  "learningObjective": "Entender como compiladores transformam abstrações em instruções de máquina.",
                                  "commonMistakes": [
                                    "Confundir compilador com interpretador",
                                    "Ignorar fases de verificação de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Pseudocódigo para Código Fonte em uma Linguagem Específica",
                                  "subSteps": [
                                    "Selecione um algoritmo simples em pseudocódigo (ex: calcular média de números).",
                                    "Traduza estruturas pseudocódigo para sintaxe de uma linguagem (ex: Python: if, while, for).",
                                    "Adapte variáveis e tipos de dados para a linguagem escolhida.",
                                    "Teste mentalmente a lógica para garantir equivalência."
                                  ],
                                  "verification": "Produza o código fonte completo equivalente ao pseudocódigo original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou Notepad++)",
                                    "Referência rápida de sintaxe Python"
                                  ],
                                  "tips": "Mantenha a lógica idêntica; adicione apenas sintaxe necessária.",
                                  "learningObjective": "Aplicar pseudocódigo como blueprint para implementação real.",
                                  "commonMistakes": [
                                    "Alterar a lógica durante a tradução",
                                    "Esquecer indentação ou ponto-virgula"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Compilação, Execução e Análise de Erros",
                                  "subSteps": [
                                    "Salve o código fonte e execute via compilador/interpretador.",
                                    "Analise mensagens de erro comuns (sintaxe, semântica) e corrija.",
                                    "Compare saída executável com resultado esperado do pseudocódigo.",
                                    "Reflita sobre como pseudocódigo evitaria erros iniciais."
                                  ],
                                  "verification": "Execute o código com sucesso e documente um erro corrigido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python instalado ou online REPL (Replit)",
                                    "Pseudocódigo original para comparação"
                                  ],
                                  "tips": "Use --verbose no compilador para ver detalhes de tradução.",
                                  "learningObjective": "Conectar pseudocódigo ao ciclo completo de desenvolvimento executável.",
                                  "commonMistakes": [
                                    "Ignorar warnings do compilador",
                                    "Executar sem testar casos extremos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar a Relação e Praticar com Variações",
                                  "subSteps": [
                                    "Resuma como pseudocódigo guia a escolha de linguagem e compilação.",
                                    "Traduza outro pseudocódigo para uma segunda linguagem (ex: Java).",
                                    "Discuta limitações: pseudocódigo não captura otimizações de compilador.",
                                    "Crie um pseudocódigo próprio e mapeie para código."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras relacionando os conceitos e produza uma tradução adicional.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dois compiladores/REPLs (Python e Java online)",
                                    "Template de resumo"
                                  ],
                                  "tips": "Escolha linguagens contrastantes para destacar diferenças.",
                                  "learningObjective": "Internalizar pseudocódigo como ponte universal para qualquer compilador.",
                                  "commonMistakes": [
                                    "Generalizar demais sem exemplos concretos",
                                    "Pular reflexão sobre limitações"
                                  ]
                                }
                              ],
                              "practicalExample": "Algoritmo em pseudocódigo: INÍCIO, ler n, soma=0, PARA i=1 ATÉ n FAÇA soma = soma + i, FIM PARA, média = soma/n, mostrar média. Tradução Python: n = int(input()); soma = 0; for i in range(1, n+1): soma += i; media = soma / n; print(media). Compile/executar: python script.py → saída numérica correta, demonstrando tradução via interpretador/compilador.",
                              "finalVerifications": [
                                "Explica com precisão o papel do pseudocódigo como abstração lógica.",
                                "Descreve corretamente o fluxo: pseudocódigo → código fonte → compilador → executável.",
                                "Identifica pelo menos 3 diferenças entre pseudocódigo e linguagens formais.",
                                "Simula compilação sem erros em um exemplo prático.",
                                "Relaciona conceitos a um diagrama ou fluxograma pessoal."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (correta distinção de papéis: 30%)",
                                "Clareza na explicação e exemplos (25%)",
                                "Profundidade nos subpassos e verificações (20%)",
                                "Uso correto de terminologia (compilador, sintaxe, semântica: 15%)",
                                "Criatividade em aplicações práticas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica algébrica e estruturas de repetição em sequências.",
                                "Linguística: Análise sintática e semântica em textos formais.",
                                "Física/Engenharia: Processos de conversão de modelos abstratos para sistemas reais.",
                                "História da Computação: Evolução de linguagens e ferramentas de tradução."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, equipes usam pseudocódigo para prototipar algoritmos antes de codificar em linguagens como C++ ou Java, permitindo que compiladores otimizem para hardware específico, acelerando ciclos de debug e colaboração em projetos como apps mobile ou IA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Programa de Computador",
                    "description": "Diferença entre algoritmo e programa, e o processo de execução em computadores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Algoritmo",
                        "description": "Sequência finita de instruções bem definidas, independentes de linguagem específica, para resolver um problema de forma lógica e passo a passo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Definir algoritmo",
                            "description": "Explicar o conceito de algoritmo como uma receita lógica passo a passo, identificando suas características principais: finitude, definitividade, efetividade e entrada/saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Intuitivo de Algoritmo",
                                  "subSteps": [
                                    "Pense em uma atividade cotidiana que segue passos sequenciais, como preparar um café.",
                                    "Descreva mentalmente os passos iniciais, ações intermediárias e resultado final.",
                                    "Identifique o que torna essa sequência útil: começa com algo e termina com outro.",
                                    "Anote uma analogia simples entre essa atividade e uma 'receita lógica'.",
                                    "Reflita: por que a ordem dos passos importa?"
                                  ],
                                  "verification": "Escreva uma analogia pessoal de 3-5 linhas comparando uma tarefa diária a um algoritmo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de receita simples (impresso ou mental)"
                                  ],
                                  "tips": "Escolha uma tarefa que você faz diariamente para facilitar a associação.",
                                  "learningObjective": "Associar o conceito de algoritmo a processos sequenciais do dia a dia.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com uma lista aleatória de tarefas",
                                    "Ignorar a necessidade de sequência lógica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar as Características Principais de um Algoritmo",
                                  "subSteps": [
                                    "Defina 'finitude': o algoritmo deve ter um número finito de passos e terminar.",
                                    "Explique 'definitividade': cada passo deve ser claro e sem ambiguidades.",
                                    "Descreva 'efetividade': todos os passos devem ser executáveis com recursos finitos.",
                                    "Identifique 'entrada/saída': entradas são dados iniciais; saídas são resultados produzidos.",
                                    "Crie uma tabela resumindo cada característica com um exemplo curto."
                                  ],
                                  "verification": "Preencha uma tabela com as 4 características, definições e exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado ou planilha digital",
                                    "Referência impressa das características"
                                  ],
                                  "tips": "Use exemplos visuais, como desenhos, para ilustrar cada característica.",
                                  "learningObjective": "Memorizar e diferenciar as quatro características essenciais de um algoritmo.",
                                  "commonMistakes": [
                                    "Omitir uma característica",
                                    "Confundir definitividade com efetividade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Práticos de Algoritmos",
                                  "subSteps": [
                                    "Pegue uma receita de bolo e mapeie entradas (ingredientes), passos e saída (bolo pronto).",
                                    "Verifique se atende às 4 características: finita? Definida? Efetiva? Com I/O?",
                                    "Compare com um exemplo ruim: uma receita vaga como 'faça um bolo bom'.",
                                    "Crie um fluxograma simples para um desses exemplos.",
                                    "Discuta por que o exemplo ruim não é um algoritmo válido."
                                  ],
                                  "verification": "Desenhe um fluxograma de um exemplo e anote como ele cumpre cada característica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Receita impressa",
                                    "Ferramenta de fluxograma online (ex: draw.io)",
                                    "Lápis e papel"
                                  ],
                                  "tips": "Comece com fluxogramas lineares antes de adicionar ramificações.",
                                  "learningObjective": "Aplicar as características a exemplos reais para validar algoritmos.",
                                  "commonMistakes": [
                                    "Não mapear entradas/saídas claramente",
                                    "Aceitar passos ambíguos como válidos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Definir Algoritmo em Próprias Palavras",
                                  "subSteps": [
                                    "Reúna as ideias dos passos anteriores em uma definição pessoal.",
                                    "Inclua explicitamente as 4 características na sua definição.",
                                    "Escreva um parágrafo explicando algoritmo como 'receita lógica passo a passo'.",
                                    "Teste sua definição criando um algoritmo simples para lavar louça.",
                                    "Revise e refine com base nas verificações das características."
                                  ],
                                  "verification": "Escreva e recite uma definição completa, validando com um exemplo criado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para rascunho",
                                    "Exemplos anteriores"
                                  ],
                                  "tips": "Leia em voz alta para checar clareza e precisão.",
                                  "learningObjective": "Formular uma definição precisa e pessoal de algoritmo.",
                                  "commonMistakes": [
                                    "Definição vaga sem mencionar características",
                                    "Confundir com 'programa de computador'"
                                  ]
                                }
                              ],
                              "practicalExample": "Algoritmo para preparar um sanduíche: Entradas: pão, queijo, presunto. Passos: 1. Pegue 2 fatias de pão (definitivo). 2. Coloque queijo em uma fatia (efetivo). 3. Adicione presunto (sequencial). 4. Feche com a outra fatia (finito). Saída: sanduíche pronto. Verificação: Todas características atendidas, sem ambiguidades.",
                              "finalVerifications": [
                                "Pode listar e explicar as 4 características principais de um algoritmo?",
                                "Consegue mapear entradas, saídas e passos em um exemplo cotidiano?",
                                "Diferencia corretamente algoritmo de uma lista desordenada ou vaga?",
                                "Cria um fluxograma simples para uma tarefa diária?",
                                "Escreve uma definição pessoal precisa e completa?",
                                "Identifica falhas em exemplos ruins de 'algoritmos'?"
                              ],
                              "assessmentCriteria": [
                                "Definição inclui todas as 4 características com precisão (finitude, definitividade, efetividade, I/O).",
                                "Exemplos práticos demonstram compreensão intuitiva e formal.",
                                "Analogias cotidianas são claras e relevantes.",
                                "Fluxogramas ou descrições de passos são sequenciais e sem ambiguidades.",
                                "Autoavaliação identifica erros comuns corretamente.",
                                "Síntese pessoal reflete aprendizado independente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências lógicas e resolução de problemas passo a passo.",
                                "Língua Portuguesa: Redação clara e precisa para evitar ambiguidades.",
                                "Ciências: Método científico como algoritmo experimental.",
                                "Artes: Criação de fluxogramas visuais.",
                                "Educação Física: Rotinas de exercícios como algoritmos corporais."
                              ],
                              "realWorldApplication": "Na programação, algoritmos formam a base de todo software, como apps de navegação (GPS calcula rotas finitas e efetivas); na vida diária, planejamento de compras ou cozinhar otimiza tempo e recursos; em engenharia, projetar pontes segue algoritmos de cálculo estrutural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Diferenciar algoritmo de programa",
                            "description": "Comparar algoritmo (abstração lógica em linguagem natural ou pseudocódigo) com programa (implementação concreta em linguagem de programação executável pelo computador).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição e características de um algoritmo",
                                  "subSteps": [
                                    "Leia a definição: Algoritmo é uma sequência finita de instruções lógicas, descrita em linguagem natural ou pseudocódigo, independente de linguagem de programação.",
                                    "Identifique características principais: finito, determinístico, entrada/saída definidas, passos claros.",
                                    "Escreva um algoritmo simples em pseudocódigo para somar dois números.",
                                    "Compare com instruções cotidianas, como uma receita de bolo.",
                                    "Liste 3 exemplos de algoritmos na vida diária."
                                  ],
                                  "verification": "Você consegue listar e explicar 3 características de um algoritmo com um exemplo escrito em pseudocódigo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a definições online de algoritmo"
                                  ],
                                  "tips": "Use pseudocódigo simples, evite sintaxe de programação real.",
                                  "learningObjective": "Compreender o conceito abstrato de algoritmo como sequência lógica independente de máquina.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com código executável",
                                    "Omitir entrada/saída nas descrições",
                                    "Fazer passos infinitos ou ambíguos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a definição e características de um programa",
                                  "subSteps": [
                                    "Leia a definição: Programa é a implementação concreta de um algoritmo em uma linguagem de programação específica, compilável ou interpretável por computador.",
                                    "Identifique características principais: sintaxe rigorosa, dependente de linguagem, executável, propenso a erros de compilação.",
                                    "Escreva um programa simples em Python para somar dois números.",
                                    "Execute o programa em um interpretador online e observe o resultado.",
                                    "Liste diferenças iniciais entre pseudocódigo e código real."
                                  ],
                                  "verification": "Você consegue codificar, executar e debugar um programa simples que implementa um algoritmo básico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código online como Replit ou Python IDLE",
                                    "Documentação básica de Python"
                                  ],
                                  "tips": "Sempre teste com entradas variadas para verificar robustez.",
                                  "learningObjective": "Compreender o programa como tradução técnica e executável de um algoritmo.",
                                  "commonMistakes": [
                                    "Ignorar sintaxe da linguagem",
                                    "Escrever pseudocódigo como se fosse programa",
                                    "Não testar execução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar diferenças chave entre algoritmo e programa",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para Algoritmo e Programa, linhas para legibilidade, executabilidade, dependência de linguagem, etc.",
                                    "Analise: Algoritmo é humano-legível e abstrato; Programa é máquina-legível e concreto.",
                                    "Discuta vantagens/desvantagens: Algoritmo facilita planejamento; Programa permite automação.",
                                    "Converta um algoritmo em programa e anote mudanças necessárias.",
                                    "Responda perguntas: 'Por que um algoritmo não roda no computador?'"
                                  ],
                                  "verification": "Tabela comparativa completa com pelo menos 5 diferenças explicadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos de algoritmos e programas"
                                  ],
                                  "tips": "Foque em aspectos conceituais, não técnicos avançados.",
                                  "learningObjective": "Dominar as distinções fundamentais entre abstração lógica e implementação técnica.",
                                  "commonMistakes": [
                                    "Tratar como sinônimos",
                                    "Ignorar abstração do algoritmo",
                                    "Confundir pseudocódigo com programa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar diferenciação com exemplos reais",
                                  "subSteps": [
                                    "Pegue um problema real: 'Ordenar uma lista de nomes'. Escreva algoritmo em pseudocódigo.",
                                    "Implemente como programa em Python (Bubble Sort simples).",
                                    "Compare os dois lado a lado, destacando traduções e adições.",
                                    "Crie um fluxograma para o algoritmo e código-fonte para o programa.",
                                    "Explique para um 'parceiro de estudo' as diferenças observadas."
                                  ],
                                  "verification": "Produzir par algoritmo-programa funcional com explicação escrita das diferenças.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma online como Lucidchart",
                                    "Ambiente Python"
                                  ],
                                  "tips": "Mantenha exemplos simples para focar na diferenciação.",
                                  "learningObjective": "Aplicar conceitos para diferenciar na prática.",
                                  "commonMistakes": [
                                    "Implementar algoritmo complexo demais",
                                    "Pular comparação detalhada",
                                    "Não validar execução do programa"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Calcular média de 3 notas. Algoritmo (pseudocódigo): 1. Ler nota1, nota2, nota3. 2. Somar = nota1 + nota2 + nota3. 3. Média = Somar / 3. 4. Exibir Média. Programa (Python): nota1 = float(input('Nota 1: ')); nota2 = float(input('Nota 2: ')); nota3 = float(input('Nota 3: ')); media = (nota1 + nota2 + nota3) / 3; print('Média:', media). Diferença: Algoritmo é legível por humanos; Programa usa sintaxe Python executável.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças principais sem hesitação.",
                                "Converter algoritmo dado em programa correto em <5 minutos.",
                                "Identificar se um texto é algoritmo ou programa com 100% acerto em 5 exemplos.",
                                "Criar algoritmo próprio e justificá-lo como não-programa.",
                                "Discutir por que planejamento algorítmico precede programação."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (80% match com conceitos padrão).",
                                "Capacidade de criar exemplos válidos e compará-los.",
                                "Compreensão de abstração vs. concretude (ausência de confusões).",
                                "Uso correto de pseudocódigo vs. sintaxe de programação.",
                                "Aplicação em cenários novos sem orientação.",
                                "Clareza na comunicação das diferenças."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica sequencial e fluxogramas semelhantes a provas geométricas.",
                                "Língua Portuguesa: Redação clara em linguagem natural para algoritmos.",
                                "Física: Modelos abstratos (teoria) vs. experimentos concretos (simulações computacionais).",
                                "Artes: Abstração conceitual como rascunho vs. obra final executada."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, engenheiros primeiro criam algoritmos para planejar soluções lógicas (ex: Google Maps rotas), depois implementam como programas executáveis, evitando erros caros na codificação direta."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Representar algoritmo em pseudocódigo",
                            "description": "Escrever um algoritmo simples em pseudocódigo utilizando estruturas básicas como atribuição, entrada/saída e sequencialidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do pseudocódigo",
                                  "subSteps": [
                                    "Defina pseudocódigo como uma forma de representar algoritmos em linguagem natural misturada com estruturas de programação.",
                                    "Identifique convenções básicas: use palavras em maiúsculas para comandos como INICIO, FIM, LEIA, ESCREVA.",
                                    "Estude exemplos simples de sequencialidade, onde instruções são executadas uma após a outra.",
                                    "Revise atribuição: usar ← ou = para atribuir valores a variáveis.",
                                    "Diferencie pseudocódigo de linguagens reais: não precisa de sintaxe rígida."
                                  ],
                                  "verification": "Explique em suas palavras o que é pseudocódigo e liste 3 convenções básicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, exemplos de pseudocódigo impressos ou em tela.",
                                  "tips": "Use maiúsculas para comandos para facilitar a leitura.",
                                  "learningObjective": "Entender a estrutura e convenções do pseudocódigo.",
                                  "commonMistakes": "Confundir pseudocódigo com código real; usar sintaxe de programação específica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar estruturas de atribuição e sequencialidade",
                                  "subSteps": [
                                    "Crie variáveis simples como numero1, numero2.",
                                    "Escreva instruções sequenciais: atribua valores constantes (ex: numero1 ← 5).",
                                    "Adicione operações básicas: numeroSoma ← numero1 + numero2.",
                                    "Estruture com INICIO e FIM.",
                                    "Execute mentalmente o fluxo sequencial."
                                  ],
                                  "verification": "Escreva um pseudocódigo que atribua 10 a uma variável e some 5, resultando em 15.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto simples ou papel.",
                                  "tips": "Sempre leia o pseudocódigo em voz alta para verificar o fluxo.",
                                  "learningObjective": "Dominar atribuição e execução sequencial.",
                                  "commonMistakes": "Esquecer setas de atribuição ou misturar ordem das instruções."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar entrada e saída de dados",
                                  "subSteps": [
                                    "Adicione LEIA para capturar input do usuário (ex: LEIA numero1).",
                                    "Use ESCREVA ou IMPRIMA para output (ex: ESCREVA 'A soma é: ', numeroSoma).",
                                    "Combine com atribuição: leia dois números, some e exiba o resultado.",
                                    "Teste com valores exemplo: input 3 e 4, output 7.",
                                    "Garanta que o fluxo seja sequencial sem ramificações."
                                  ],
                                  "verification": "Crie pseudocódigo que leia um nome e exiba 'Olá, [nome]'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador mental ou ferramenta online de pseudocódigo.",
                                  "tips": "Coloque aspas em textos constantes para clareza.",
                                  "learningObjective": "Integrar entrada/saída com estruturas básicas.",
                                  "commonMistakes": "Usar variáveis não declaradas ou esquecer de ler antes de usar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e validar um algoritmo simples completo",
                                  "subSteps": [
                                    "Escolha um problema: calcular média de duas notas.",
                                    "Escreva o pseudocódigo completo: INICIO, LEIA nota1, LEIA nota2, media ← (nota1 + nota2)/2, ESCREVA media, FIM.",
                                    "Simule execução com inputs reais.",
                                    "Revise por erros lógicos ou de sintaxe pseudocódigo.",
                                    "Compare com um exemplo modelo."
                                  ],
                                  "verification": "O pseudocódigo resolve o problema sem ambiguidades e segue convenções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, lápis, exemplos de referência.",
                                  "tips": "Indente linhas para melhor visualização do fluxo.",
                                  "learningObjective": "Criar um algoritmo funcional em pseudocódigo.",
                                  "commonMistakes": "Ignorar divisões por zero ou inputs inválidos em problemas simples."
                                }
                              ],
                              "practicalExample": "Pseudocódigo para calcular a soma de dois números: INICIO\nLEIA numero1\nLEIA numero2\nsoma ← numero1 + numero2\nESCREVA 'A soma é: ', soma\nFIM",
                              "finalVerifications": [
                                "O pseudocódigo inicia com INICIO e termina com FIM.",
                                "Todas as variáveis usadas foram atribuídas antes do uso.",
                                "Entrada e saída estão claramente indicadas com LEIA e ESCREVA.",
                                "O fluxo é puramente sequencial sem condicionais ou loops.",
                                "Simulação manual com inputs produz output correto.",
                                "Texto está legível e usa convenções padrão."
                              ],
                              "assessmentCriteria": [
                                "Clareza e legibilidade do pseudocódigo (formatação, indentação).",
                                "Correção lógica: algoritmo resolve o problema proposto.",
                                "Uso adequado de atribuição, entrada e saída.",
                                "Adesão a convenções de pseudocódigo (maiúsculas, setas).",
                                "Ausência de erros comuns como variáveis indefinidas.",
                                "Simplicidade e foco em estruturas básicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas básicas e lógica sequencial.",
                                "Língua Portuguesa: Redação clara e estruturada de instruções.",
                                "Lógica: Planejamento passo a passo de soluções.",
                                "Educação Tecnológica: Introdução a planejamento computacional."
                              ],
                              "realWorldApplication": "Desenvolvedores usam pseudocódigo para planejar soluções antes de codificar em linguagens reais, facilitando depuração e comunicação em equipes de software."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Programa de Computador",
                        "description": "Implementação de um algoritmo em uma linguagem de programação específica, traduzida para código de máquina executável pelo hardware.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Identificar componentes de um programa",
                            "description": "Descrever os elementos essenciais de um programa: código fonte, linguagem de programação, compilador ou interpretador, e software básico como sistema operacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de um programa de computador",
                                  "subSteps": [
                                    "Defina o que é um programa de computador: uma sequência de instruções para realizar tarefas.",
                                    "Liste os elementos essenciais: código fonte, linguagem, compilador/interpretador e sistema operacional.",
                                    "Explique por que esses componentes são interdependentes.",
                                    "Crie um diagrama simples mostrando a relação entre eles.",
                                    "Pesquise exemplos históricos, como o primeiro programa de Ada Lovelace."
                                  ],
                                  "verification": "Crie um resumo escrito ou diagrama que liste e relacione os 4 componentes principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; acesso à internet para pesquisa básica.",
                                  "tips": "Use analogias cotidianas, como uma receita de bolo (ingredientes = código, forno = compilador).",
                                  "learningObjective": "Entender a composição fundamental de um programa e suas interdependências.",
                                  "commonMistakes": "Confundir programa com hardware; ignorar o sistema operacional como componente essencial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e analisar o código fonte",
                                  "subSteps": [
                                    "Abra um editor de texto e crie um arquivo simples com código fonte (ex: print('Olá Mundo') em Python).",
                                    "Explique o que é código fonte: texto legível por humanos escrito em linguagem de programação.",
                                    "Diferencie código fonte de executável/binário.",
                                    "Modifique o código e salve em diferentes extensões (.py, .txt).",
                                    "Compare com código em outra linguagem, como C++."
                                  ],
                                  "verification": "Mostre o arquivo de código fonte e descreva seu conteúdo e propósito em voz alta ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto (Notepad++, VS Code); computador com Python instalado.",
                                  "tips": "Sempre comente o código para facilitar a compreensão futura.",
                                  "learningObjective": "Reconhecer o código fonte como a base humana-legível de um programa.",
                                  "commonMistakes": "Confundir código fonte com o programa rodando; não salvar com extensão correta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer a linguagem de programação",
                                  "subSteps": [
                                    "Liste linguagens comuns: Python (interpretada), Java (compilada), JavaScript.",
                                    "Identifique a linguagem pelo sintaxe no código fonte (ex: def em Python).",
                                    "Pesquise características únicas de 3 linguagens.",
                                    "Instale uma linguagem e execute um código simples nela.",
                                    "Compare sintaxes de 'Olá Mundo' em duas linguagens diferentes."
                                  ],
                                  "verification": "Classifique corretamente a linguagem de 3 exemplos de código fornecidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Acesso à internet; instaladores de Python e Java; exemplos de código impressos ou digitais.",
                                  "tips": "Use sites como W3Schools para exemplos rápidos de sintaxe.",
                                  "learningObjective": "Associar código fonte à linguagem de programação específica usada.",
                                  "commonMistakes": "Achar que todas as linguagens são iguais; ignorar diferenças de sintaxe."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar compilador e interpretador",
                                  "subSteps": [
                                    "Defina compilador: traduz todo código para binário antes da execução (ex: GCC para C).",
                                    "Defina interpretador: executa linha por linha (ex: Python interpreter).",
                                    "Instale e use um compilador (ex: javac) e um interpretador (python).",
                                    "Compile e execute um programa Java vs rode um Python.",
                                    "Crie uma tabela comparativa: velocidade, portabilidade, erros."
                                  ],
                                  "verification": "Explique com exemplo prático a diferença e demonstre execução de ambos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "JDK para Java; Python instalado; computador.",
                                  "tips": "Teste erros: compilador pega antes, interpretador durante execução.",
                                  "learningObjective": "Distinguir e exemplificar compiladores vs interpretadores.",
                                  "commonMistakes": "Confundir os dois; achar que interpretador é sempre mais lento."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar o papel do sistema operacional",
                                  "subSteps": [
                                    "Descreva o SO como camada intermediária: gerencia recursos, executa programas.",
                                    "Execute o mesmo programa em diferentes SOs (ex: Windows vs Linux via VM).",
                                    "Verifique processos no Gerenciador de Tarefas/ top command.",
                                    "Explique dependências: bibliotecas do SO necessárias.",
                                    "Discuta portabilidade: programas compilados para SO específico."
                                  ],
                                  "verification": "Descreva como o SO interage com um programa em execução e liste 3 funções dele.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Dois SOs (nativo + VM como VirtualBox); programa de teste.",
                                  "tips": "Use comandos como 'ps' no Linux para ver processos.",
                                  "learningObjective": "Compreender o SO como componente essencial para rodar programas.",
                                  "commonMistakes": "Subestimar o SO; achar que programa roda sem ele."
                                }
                              ],
                              "practicalExample": "Considere um programa 'Calculadora Simples' em Python: código fonte é o arquivo calculadora.py com funções de soma; linguagem é Python; interpretador é o executável python.exe; sistema operacional é Windows 10, que fornece APIs para entrada/saída e gerenciamento de memória.",
                              "finalVerifications": [
                                "Liste corretamente os 4 componentes essenciais de um programa com definições breves.",
                                "Analise um código fonte real e identifique todos os componentes envolvidos.",
                                "Diferencie compilador de interpretador com exemplos práticos.",
                                "Explique a interação do programa com o SO em um cenário de execução.",
                                "Crie um diagrama completo dos componentes e suas relações.",
                                "Responda a perguntas sobre dependências entre componentes sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do código fonte (100% dos elementos corretos).",
                                "Correta distinção entre linguagem, compilador e interpretador (sem confusões).",
                                "Explicação clara do papel do SO com exemplos (profundidade mínima).",
                                "Uso de exemplos práticos em todas as respostas.",
                                "Capacidade de relacionar componentes em um todo coeso.",
                                "Ausência de erros comuns como confundir fonte com binário."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica algorítmica no código fonte.",
                                "Física: Conceitos de hardware subjacente ao SO.",
                                "Língua Portuguesa: Redação técnica de descrições de componentes.",
                                "História: Evolução de linguagens e compiladores (ex: Fortran)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, engenheiros identificam esses componentes para debugar erros (ex: problema no interpretador), escolher linguagens portáveis ou otimizar para SOs específicos como em apps mobile (Android/iOS)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Explicar papel da linguagem de programação e compilador",
                            "description": "Detalhar como linguagens procedimentais (ex: C++) usam comandos de atribuição, entrada/saída, condicionais e repetitivos, e o compilador traduz código fonte para binário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Linguagens de Programação Procedimentais",
                                  "subSteps": [
                                    "Defina linguagem de programação procedural como uma que usa sequências de comandos imperativos.",
                                    "Explique comandos de atribuição (ex: 'int x = 5;' em C++ para armazenar valores).",
                                    "Descreva entrada/saída (ex: 'cin >> x;' para ler e 'cout << x;' para exibir).",
                                    "Detalhe estruturas condicionais (ex: 'if (x > 0) {} else {}' para decisões).",
                                    "Explique estruturas repetitivas (ex: 'for(int i=0; i<10; i++) {}' ou 'while()' para loops)."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras cobrindo todos os elementos com exemplos simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentação oficial de C++ (cppreference.com), editor de texto como VS Code.",
                                  "tips": "Use analogias como 'atribuição é como rotular uma caixa' para facilitar compreensão.",
                                  "learningObjective": "Identificar e exemplificar os comandos fundamentais de linguagens procedimentais.",
                                  "commonMistakes": "Confundir procedurais com orientadas a objetos; ignorar que loops evitam repetição manual."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Código Fonte, Código de Máquina e Binário",
                                  "subSteps": [
                                    "Defina código fonte como texto legível por humanos escrito em linguagem como C++.",
                                    "Explique código de máquina como instruções em linguagem assembly (ex: MOV, ADD).",
                                    "Descreva código binário como sequência de 0s e 1s executada diretamente pelo processador.",
                                    "Compare: fonte é alto nível, binário é baixo nível e específico da arquitetura.",
                                    "Discuta por que humanos não programam diretamente em binário (complexidade e portabilidade)."
                                  ],
                                  "verification": "Crie uma tabela comparativa com exemplos de cada tipo de código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramentas online como Godbolt.org para ver assembly de código C++.",
                                  "tips": "Visualize binário como 'idioma do hardware', fonte como 'tradução humana'.",
                                  "learningObjective": "Distinguir os níveis de representação de programas na computação.",
                                  "commonMistakes": "Achar que código fonte roda diretamente (sem compilação); confundir assembly com binário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Papel e Processo do Compilador",
                                  "subSteps": [
                                    "Defina compilador como software que traduz código fonte para binário (ex: g++ para C++).",
                                    "Descreva fases principais: pré-processamento (incluir headers), compilação (para assembly), montagem (para objeto), ligação (executável).",
                                    "Explique tradução: analisa sintaxe, semântica e otimiza para máquina.",
                                    "Diferencie de interpretadores (compilador gera executável único).",
                                    "Discuta erros comuns: sintaxe (não compila), lógica (compila mas falha)."
                                  ],
                                  "verification": "Desenhe um fluxograma do processo de compilação com 4-5 setas principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Instalador do GCC (g++), terminal para comandos como 'g++ main.cpp -o main'.",
                                  "tips": "Pense no compilador como 'tradutor juramentado' entre humano e CPU.",
                                  "learningObjective": "Compreender o compilador como ponte entre linguagens de alto nível e hardware.",
                                  "commonMistakes": "Ignorar fases múltiplas; confundir compilador com interpretador (ex: Python)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos com um Exemplo Prático de Compilação",
                                  "subSteps": [
                                    "Escreva um programa C++ simples usando atribuição, I/O, condicional e loop (ex: somar números pares).",
                                    "Compile o código com 'g++ programa.cpp -o programa'.",
                                    "Execute e observe saída, verificando tradução para binário.",
                                    "Use 'objdump' ou Godbolt para inspecionar código gerado.",
                                    "Modifique o código, recompile e compare mudanças."
                                  ],
                                  "verification": "Execute o programa e explique como cada comando foi traduzido pelo compilador.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ambiente Linux/Windows com g++, editor de código, Godbolt.org.",
                                  "tips": "Comece com Hello World e adicione complexidade gradualmente.",
                                  "learningObjective": "Demonstrar na prática o fluxo de linguagem procedural para execução binária.",
                                  "commonMistakes": "Esquecer #include <iostream>; erros de sintaxe como ; faltando."
                                }
                              ],
                              "practicalExample": "Programa C++: #include <iostream> int main() { int n; std::cin >> n; for(int i=1; i<=n; i++) { if(i%2==0) std::cout << i << ' '; } return 0; } Compile com g++ ex.cpp -o ex && ./ex. Lê n, imprime pares de 1 a n.",
                              "finalVerifications": [
                                "Explicar em 3 frases o papel da linguagem procedural e compilador.",
                                "Desenhar fluxograma completo de código fonte a execução.",
                                "Identificar 3 comandos básicos em um código dado.",
                                "Simular compilação verbal de um programa simples.",
                                "Diferenciar binário de fonte com exemplo concreto.",
                                "Listar 2 erros comuns de compilação e soluções."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual sobre comandos procedurais (30%)",
                                "Clareza na explicação do processo de compilação (25%)",
                                "Uso correto de exemplos e analogias (20%)",
                                "Compreensão de código fonte vs binário (15%)",
                                "Aplicação prática via compilação executada (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em condicionais e loops.",
                                "Física: Representação binária e portas lógicas no hardware.",
                                "Linguagens: Analogia com gramática e tradução de idiomas naturais.",
                                "História: Evolução de linguagens de máquina para alto nível."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software como jogos (Unreal Engine em C++), sistemas embarcados (carros autônomos) e aplicativos de alta performance, onde compiladores otimizam código para execução eficiente em hardware real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Aplicar lógica de programação básica",
                            "description": "Criar um programa simples com estruturas condicionais (if-else), repetitivas (for/while) e seletivas, incluindo tipos escalares (int, float).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar e manipular variáveis escalares (int e float)",
                                  "subSteps": [
                                    "Instalar um ambiente Python (ex: IDLE, VS Code com extensão Python ou Replit online).",
                                    "Criar um script simples declarando variáveis: idade (int), altura (float).",
                                    "Realizar operações aritméticas básicas: soma, subtração, multiplicação e divisão.",
                                    "Usar input() para ler valores do usuário e convertê-los com int() ou float().",
                                    "Imprimir resultados com print() formatado."
                                  ],
                                  "verification": "Executar o programa e confirmar que inputs são lidos, operações realizadas e saídas exibidas corretamente sem erros de tipo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python instalado",
                                    "Editor de código (VS Code ou Replit)",
                                    "Documentação oficial Python para tipos básicos"
                                  ],
                                  "tips": "Sempre use float() para números decimais em inputs para evitar perda de precisão.",
                                  "learningObjective": "Dominar declaração, entrada/saída e operações com tipos escalares int e float.",
                                  "commonMistakes": "Esquecer de converter input() para int/float, causando TypeError; confundir int com float em divisões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar estruturas condicionais (if-else)",
                                  "subSteps": [
                                    "Estudar sintaxe de if, elif e else com exemplos simples.",
                                    "Criar programa que verifica se um número inteiro é positivo, negativo ou zero.",
                                    "Adicionar condições compostas usando operadores lógicos (and, or, not).",
                                    "Desenvolver um classificador simples: nota float em A (>=9), B (>=7), C (>=5), D (<5).",
                                    "Testar com múltiplos inputs para validar todas as ramificações."
                                  ],
                                  "verification": "Rodar o programa com casos de teste variados (positivo/negativo, notas 9.5/6.0/4.5) e confirmar saídas corretas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ambiente Python",
                                    "Exemplos de código condicional online (W3Schools Python if-else)"
                                  ],
                                  "tips": "Use parênteses em condições complexas para clareza e evite indentação incorreta.",
                                  "learningObjective": "Aplicar lógica condicional para tomada de decisões em programas.",
                                  "commonMistakes": "Erro de indentação em blocos if-else; esquecer dois pontos (:) após if/else; usar == em vez de = para comparação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Usar estruturas repetitivas (for e while)",
                                  "subSteps": [
                                    "Aprender sintaxe de loop for (range()) e while com condição.",
                                    "Criar loop for que imprime números de 1 a 10 e calcula soma acumulada.",
                                    "Implementar while para repetir até condição falsa (ex: somar números até soma >= 50).",
                                    "Combinar com variáveis escalares: loop que lê números float até input inválido.",
                                    "Adicionar contador int para rastrear iterações."
                                  ],
                                  "verification": "Executar loops e verificar contagens, somas e parada correta nos logs de saída.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python shell para testes interativos",
                                    "Tutoriais Python loops (Real Python)"
                                  ],
                                  "tips": "Inicialize contadores antes do loop e use break para saídas prematuras se necessário.",
                                  "learningObjective": "Controlar repetições com for e while para processar sequências de dados.",
                                  "commonMistakes": "Loop infinito em while (condição nunca falsa); off-by-one em range(for); esquecer incremento no while."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar conceitos em um programa simples completo",
                                  "subSteps": [
                                    "Planejar programa: calculadora de média de notas com loop, condicional e escalares.",
                                    "Usar while para ler notas float até -1; contador int para quantidade.",
                                    "Calcular média com soma/notas; if-elif-else para classificar.",
                                    "Adicionar validação básica (ignorar notas inválidas).",
                                    "Testar integralmente com cenários reais e depurar erros."
                                  ],
                                  "verification": "Programa processa 5+ notas, calcula média precisa e classifica corretamente em todos os casos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ambiente de desenvolvimento completo",
                                    "Papel para fluxograma lógico"
                                  ],
                                  "tips": "Desenhe fluxograma antes de codificar para visualizar loops e condicionais.",
                                  "learningObjective": "Construir programa funcional combinando escalares, condicionais e loops.",
                                  "commonMistakes": "Divisão por zero (zero notas); não resetar variáveis entre testes; lógica errada em média."
                                }
                              ],
                              "practicalExample": "Programa Python: Use while para ler notas float até -1, conte com int, calcule média float, classifique com if-elif-else (A: >=9 'Excelente', B: >=7 'Bom', C: >=5 'Regular', D: <5 'Insuficiente') e imprima resultados.",
                              "finalVerifications": [
                                "Programa executa sem erros de sintaxe ou runtime.",
                                "Todos inputs são processados corretamente como int/float.",
                                "Loops param na condição exata (ex: -1).",
                                "Cálculos aritméticos (soma, média) precisos.",
                                "Classificações condicionais corretas para faixas variadas.",
                                "Saídas formatadas e legíveis."
                              ],
                              "assessmentCriteria": [
                                "Uso correto e consistente de tipos escalares int/float.",
                                "Estruturas condicionais implementadas sem falhas lógicas.",
                                "Loops for/while funcionais com controle preciso.",
                                "Integração lógica de todos elementos em programa coeso.",
                                "Código limpo, indentado e com comentários explicativos.",
                                "Tratamento básico de entradas inválidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas, médias e lógica numérica.",
                                "Lógica e Raciocínio: Fluxogramas e estruturas de decisão/repetição.",
                                "Estatística: Processamento e análise de dados sequenciais."
                              ],
                              "realWorldApplication": "Automatizar cálculos em planilhas empresariais, como média de vendas por vendedor com classificação de performance, ou controle de estoque com loops para inventário e condicionais para alertas baixos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Processo de Execução de Programas",
                        "description": "Etapas desde a escrita do código fonte até a execução no hardware, incluindo compilação, linkage e runtime com tratamento de exceções.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Descrever ciclo de compilação e execução",
                            "description": "Explicar as fases: pré-processamento, compilação (código fonte para assembly), assembly (para código objeto), linkage (para executável) e execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Pré-processamento",
                                  "subSteps": [
                                    "Explicar o que é pré-processamento: substituição de diretivas como #include e #define pelo pré-processador.",
                                    "Identificar macros e como elas são expandidas.",
                                    "Discutir remoção de comentários e expansão de includes.",
                                    "Analisar como o arquivo .i é gerado (código pré-processado).",
                                    "Comparar com código fonte original para ver diferenças."
                                  ],
                                  "verification": "Gerar e inspecionar o arquivo .i usando gcc -E.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador GCC, editor de texto, código fonte simples em C (ex: hello.c com #include <stdio.h>).",
                                  "tips": "Use flags como -E para parar no pré-processamento e visualizar mudanças.",
                                  "learningObjective": "Compreender como o pré-processador transforma o código fonte antes da compilação.",
                                  "commonMistakes": "Confundir pré-processamento com compilação; ignorar que includes trazem código externo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Fase de Compilação",
                                  "subSteps": [
                                    "Descrever compilação: conversão de código fonte (ou .i) para assembly.",
                                    "Explicar análise léxica, sintática e semântica.",
                                    "Discutir geração de código assembly intermediário.",
                                    "Gerar arquivo .s (assembly) usando gcc -S.",
                                    "Ler e interpretar instruções assembly básicas."
                                  ],
                                  "verification": "Compilar com -S e confirmar geração de .s com instruções assembly válidas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "GCC, código fonte C simples.",
                                  "tips": "Comece com código minimalista para assembly legível.",
                                  "learningObjective": "Dominar como o compilador traduz alto nível para assembly de baixo nível.",
                                  "commonMistakes": "Achar que compilação gera executável diretamente; pular verificação de erros de sintaxe."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Fase de Assembly",
                                  "subSteps": [
                                    "Definir assembly: montagem de código assembly em código objeto binário (.o).",
                                    "Explicar tradução de mnemonicos para códigos de máquina.",
                                    "Discutir tabelas de símbolos e relocações.",
                                    "Gerar .o usando as (ex: as hello.s -o hello.o).",
                                    "Usar objdump para inspecionar conteúdo do .o."
                                  ],
                                  "verification": "Executar as e verificar .o com objdump -d.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "GNU Assembler (as), objdump, arquivo .s gerado anteriormente.",
                                  "tips": "Use objdump para decodificar binário e ver instruções.",
                                  "learningObjective": "Entender a ponte entre assembly legível e binário de máquina.",
                                  "commonMistakes": "Confundir assembly com linkage; não verificar símbolos undefined."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender o Linkage",
                                  "subSteps": [
                                    "Explicar linkage: combinação de múltiplos .o e bibliotecas em executável.",
                                    "Diferenciar linker estático vs dinâmico.",
                                    "Discutir resolução de símbolos externos e bibliotecas.",
                                    "Linkar com ld ou gcc -o hello hello.o.",
                                    "Verificar executável com file ou ldd."
                                  ],
                                  "verification": "Gerar executável e executá-lo com sucesso sem erros de linking.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Linker ld ou GCC, arquivos .o, bibliotecas padrão.",
                                  "tips": "Use -static para linkage estático e comparar tamanhos.",
                                  "learningObjective": "Saber como módulos são unidos em um programa executável completo.",
                                  "commonMistakes": "Esquecer bibliotecas runtime; confundir com loading em runtime."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Investigar a Fase de Execução",
                                  "subSteps": [
                                    "Descrever execução: carregamento do executável na memória pelo OS.",
                                    "Explicar loader, inicialização de stack/heap, chamada de main().",
                                    "Discutir runtime: chamadas de sistema e bibliotecas dinâmicas.",
                                    "Executar o programa e usar gdb para stepwise.",
                                    "Analisar saída e uso de recursos (strace para syscalls)."
                                  ],
                                  "verification": "Rodar programa com gdb e observar fluxo de main() até exit.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "GDB debugger, strace, executável gerado.",
                                  "tips": "Use gdb run e next para simular execução passo a passo.",
                                  "learningObjective": "Compreender o ciclo completo desde binário até término do programa.",
                                  "commonMistakes": "Ignorar papel do OS; confundir execução com compilação."
                                }
                              ],
                              "practicalExample": "Compile um programa 'Hello World' em C: escreva hello.c com #include <stdio.h> e main() printf. Execute gcc -E hello.c > hello.i; gcc -S hello.i; as hello.s -o hello.o; gcc hello.o -o hello; ./hello. Inspecione cada fase.",
                              "finalVerifications": [
                                "Listar corretamente as 5 fases em ordem: pré-processamento, compilação, assembly, linkage, execução.",
                                "Gerar e executar um executável completo de um código fonte simples.",
                                "Explicar diferenças entre arquivos .i, .s, .o e executável.",
                                "Identificar erros comuns em cada fase usando ferramentas como gcc verbose.",
                                "Desenhar diagrama do fluxo de compilação.",
                                "Comparar processo em C vs outro linguagem (ex: Java bytecode)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de cada fase (80% cobertura).",
                                "Capacidade de demonstrar pipeline com ferramentas reais.",
                                "Identificação correta de artefatos intermediários (.i, .s, .o).",
                                "Explicação de erros comuns e soluções.",
                                "Integração de conceitos em diagrama ou narrativa coesa.",
                                "Aplicação a exemplo prático sem falhas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em assembly e otimização de código.",
                                "Física: Representação binária e circuitos lógicos na CPU.",
                                "Engenharia: Otimização de build systems em pipelines CI/CD.",
                                "História da Computação: Evolução de assemblers e linkers desde os anos 60."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, entender o ciclo permite debugging eficiente (ex: falhas de linkage em builds grandes), otimização de performance (escolha de compiladores/flags), e automação de builds em ferramentas como Make/CMake/Jenkins, essencial para deploy de apps em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Entender escopo e passagem de parâmetros",
                            "description": "Diferenciar passagem por valor e por referência em funções, explicar escopo de variáveis locais/globais e introduzir recursividade básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Escopo de Variáveis Locais e Globais",
                                  "subSteps": [
                                    "Defina escopo como a região do código onde uma variável é acessível.",
                                    "Explique variáveis locais: criadas dentro de uma função, só visíveis ali.",
                                    "Explique variáveis globais: declaradas fora de funções, acessíveis em todo o programa.",
                                    "Demonstre com código: crie uma variável global e tente acessá-la de uma função sem modificá-la.",
                                    "Mostre sombreamento: uma local com mesmo nome que global."
                                  ],
                                  "verification": "Execute código e confirme que variáveis locais não afetam globais e vice-versa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (ex: VS Code), interpretador Python ou similar",
                                  "tips": "Sempre declare locais primeiro para evitar confusões com globais.",
                                  "learningObjective": "Diferenciar acessibilidade de variáveis locais e globais em um programa.",
                                  "commonMistakes": "Confundir nomes de variáveis locais com globais, levando a bugs inesperados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Passagem de Parâmetros por Valor",
                                  "subSteps": [
                                    "Explique passagem por valor: cópia do valor é passada para a função, original não muda.",
                                    "Use exemplo com inteiros: função que soma 1 a um parâmetro.",
                                    "Execute código mostrando que variável original permanece inalterada.",
                                    "Compare com tipos primitivos em linguagens como C ou Python (imutáveis).",
                                    "Teste com múltiplos parâmetros para reforçar."
                                  ],
                                  "verification": "Chame função e imprima original antes/depois; valor não muda.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, interpretador",
                                  "tips": "Pense em 'cópia física' do valor para imutáveis.",
                                  "learningObjective": "Identificar quando alterações em parâmetros não afetam originais.",
                                  "commonMistakes": "Acreditar que funções sempre modificam originais por valor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Passagem de Parâmetros por Referência",
                                  "subSteps": [
                                    "Explique passagem por referência: endereço da variável é passado, alterações afetam original.",
                                    "Use exemplo com listas/arrays: função que appenda item.",
                                    "Execute código mostrando mudança no original.",
                                    "Compare com Python (mutáveis) ou C++ (ponteiros).",
                                    "Teste reatribuição vs mutação interna."
                                  ],
                                  "verification": "Modifique lista na função e confirme mudança no escopo chamador.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de código, interpretador",
                                  "tips": "Lembre: mutáveis são passados 'por objeto compartilhado'.",
                                  "learningObjective": "Reconhecer side effects em funções com referências.",
                                  "commonMistakes": "Reatribuir parâmetro inteiro em vez de mutar, fingindo por valor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir Recursividade Básica",
                                  "subSteps": [
                                    "Defina recursão: função chama a si mesma até condição base.",
                                    "Explique pilha de chamadas e escopo local em cada chamada.",
                                    "Implemente fatorial recursivo: fact(n) = n * fact(n-1), base fact(0)=1.",
                                    "Trace execução manualmente para n=4.",
                                    "Discuta passagem de parâmetros na recursão (por valor).",
                                    "Compare com loop iterativo."
                                  ],
                                  "verification": "Execute recursão para n=5, confirme resultado 120 sem stack overflow.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Editor de código, interpretador, papel para traçar pilha",
                                  "tips": "Sempre inclua condição base para evitar loops infinitos.",
                                  "learningObjective": "Implementar e debugar função recursiva simples.",
                                  "commonMistakes": "Esquecer condição base, causando stack overflow."
                                }
                              ],
                              "practicalExample": "Em Python: def modify_list(lst): lst.append(42). Chame com minha_lista = [1,2]; modify_list(minha_lista); print(minha_lista) -> [1,2,42] (por referência). Para recursão: def fatorial(n): if n <= 1: return 1; return n * fatorial(n-1).",
                              "finalVerifications": [
                                "Explicar verbalmente diferença entre por valor e por referência com exemplo.",
                                "Identificar escopo de uma variável em código fornecido.",
                                "Implementar fatorial recursivo sem erros.",
                                "Prever saída de código com globais/locais e funções.",
                                "Debugar código recursivo com stack overflow.",
                                "Diferenciar quando uma função modifica original."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de escopo local/global (90% acerto em quiz).",
                                "Correta implementação de passagem por valor vs referência em exemplos.",
                                "Função recursiva executa corretamente para n=1-6.",
                                "Explicação clara de pilha de chamadas recursivas.",
                                "Identificação de 3 erros comuns em cenários dados.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções recursivas ligadas a sequências e indução.",
                                "Lógica: Condições base semelhantes a provas por indução.",
                                "Física: Modelagem de processos iterativos/recursivos em simulações.",
                                "Design: Conceitos de encapsulamento em programação orientada a objetos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, entender escopo evita bugs de variáveis inesperadas; passagem por referência previne side effects em APIs; recursão otimiza algoritmos como árvore de diretórios ou parsing JSON, comum em ferramentas como editores de código e jogos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Implementar tratamento de exceções simples",
                            "description": "Usar estruturas para capturar erros em entrada/saída ou divisões por zero, garantindo robustez no processo de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Exceções",
                                  "subSteps": [
                                    "Estude o que são exceções: eventos que interrompem o fluxo normal de execução devido a erros como divisão por zero ou entrada inválida.",
                                    "Identifique exceções comuns em Python: ZeroDivisionError, ValueError e Exception genérica.",
                                    "Analise um exemplo de código sem tratamento que gera erro e observe a mensagem de traceback.",
                                    "Discuta por que tratar exceções melhora a robustez do programa.",
                                    "Liste cenários reais onde exceções ocorrem, como input do usuário ou leitura de arquivos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é uma exceção e dê 3 exemplos comuns.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python sobre exceções (docs.python.org/3/tutorial/errors.html)",
                                    "Editor de código como VS Code ou IDLE"
                                  ],
                                  "tips": "Use print() para simular exceções e observe o output no console.",
                                  "learningObjective": "Compreender o papel das exceções no fluxo de execução de programas.",
                                  "commonMistakes": [
                                    "Confundir exceções com erros de sintaxe",
                                    "Ignorar que exceções podem ser intencionais para controle de fluxo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Estrutura Básica try-except",
                                  "subSteps": [
                                    "Escreva um código simples que cause uma exceção, como divisão por zero: resultado = 10 / 0.",
                                    "Envolva o código em try: e adicione except Exception as e: print('Erro capturado!').",
                                    "Teste o código: execute e verifique se o programa continua rodando sem crash.",
                                    "Adicione uma mensagem informativa no except para descrever o erro.",
                                    "Experimente capturar exceções específicas: except ZeroDivisionError:"
                                  ],
                                  "verification": "Execute o código com input que cause erro e confirme que uma mensagem amigável é exibida sem crash.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "Console ou Jupyter Notebook para testes interativos"
                                  ],
                                  "tips": "Sempre teste com casos válidos e inválidos para validar o tratamento.",
                                  "learningObjective": "Dominar a sintaxe básica de try-except para capturar e gerenciar exceções genéricas e específicas.",
                                  "commonMistakes": [
                                    "Usar except: sem especificar tipo (captura tudo, incluindo KeyboardInterrupt)",
                                    "Colocar código após except que pode gerar nova exceção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Tratar Exceções em Entrada/Saída e Múltiplas Exceções",
                                  "subSteps": [
                                    "Crie um programa que leia dois números do usuário via input() e realize divisão.",
                                    "Adicione try-except para ValueError (input não numérico) e ZeroDivisionError.",
                                    "Use múltiplos except: um para cada tipo de exceção.",
                                    "Implemente um loop para repetir input até entrada válida.",
                                    "Teste com entradas inválidas: letras, zero no denominador."
                                  ],
                                  "verification": "Insira inputs inválidos e confirme que o programa pede nova entrada sem encerrar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código de input em Python",
                                    "Calculadora simples como base"
                                  ],
                                  "tips": "Use float(input()) para números reais e valide com try-except.",
                                  "learningObjective": "Aplicar tratamento de exceções em cenários reais de I/O do usuário.",
                                  "commonMistakes": [
                                    "Não tratar ValueError em input()",
                                    "Permitir loop infinito sem opção de saída"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar else, finally e Testes Completos",
                                  "subSteps": [
                                    "Inclua else: após excepts para código que roda só se não houver exceção.",
                                    "Adicione finally: para cleanup, como fechar arquivos ou imprimir 'Fim do programa'.",
                                    "Escreva testes unitários simples usando if __name__ == '__main__' com casos variados.",
                                    "Refatore o código para robustez: valide múltiplas vezes se necessário.",
                                    "Documente o código com comentários explicando cada bloco."
                                  ],
                                  "verification": "Execute testes completos: casos bons/ruins, verifique finally sempre executa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca unittest básica (opcional)",
                                    "Checklist de testes"
                                  ],
                                  "tips": "Finally é ideal para liberar recursos como arquivos abertos.",
                                  "learningObjective": "Completar o tratamento de exceções com else/finally e validação abrangente.",
                                  "commonMistakes": [
                                    "Esquecer finally para recursos não liberados",
                                    "Colocar lógica crítica no else"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa de calculadora simples: lê dois números do usuário, divide e exibe resultado. Trata ValueError (input inválido) pedindo nova entrada, ZeroDivisionError exibindo 'Não divida por zero!', usa finally para imprimir 'Cálculo concluído' e else para mostrar o resultado só se sucesso.",
                              "finalVerifications": [
                                "Programa executa sem crashes em inputs inválidos.",
                                "Mensagens de erro claras e úteis são exibidas.",
                                "Código em finally sempre roda, independentemente de exceções.",
                                "Loop de input continua até dados válidos.",
                                "Resultados corretos para divisões válidas.",
                                "Nenhum recurso é vazado (ex: prints de cleanup)."
                              ],
                              "assessmentCriteria": [
                                "Correta uso de try-except para exceções específicas.",
                                "Cobertura de cenários comuns: I/O inválido e divisão por zero.",
                                "Implementação de else e finally quando aplicável.",
                                "Código limpo, comentado e testado.",
                                "Robustez: programa não encerra prematuramente.",
                                "Eficiência: evita loops infinitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de divisão e validação numérica.",
                                "Lógica e Algoritmos: Estruturas de controle de fluxo com condições.",
                                "Inglês Técnico: Leitura de documentação Python e mensagens de erro.",
                                "Design de Software: Princípios de robustez e user-friendly interfaces."
                              ],
                              "realWorldApplication": "Em aplicativos bancários para evitar crashes em transações inválidas, jogos para lidar com inputs de usuário errados, ou scripts de automação que leem arquivos possivelmente corrompidos, garantindo continuidade e logs de erros para depuração."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.4",
                            "name": "Explorar ponteiros básicos",
                            "description": "Introduzir ponteiros como variáveis que armazenam endereços de memória, relacionando à passagem por referência e alocação dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Endereços de Memória e Conceito de Ponteiros",
                                  "subSteps": [
                                    "Explique o que é um endereço de memória usando o operador & em uma variável simples.",
                                    "Diferencie entre o valor de uma variável e seu endereço de memória.",
                                    "Visualize a memória como uma rua com casas numeradas, onde ponteiros são placas com números de casas.",
                                    "Escreva um programa simples que imprima o endereço e valor de uma variável inteira.",
                                    "Compare impressões de endereço para variáveis locais e globais."
                                  ],
                                  "verification": "Execute o programa e confirme que o endereço é exibido corretamente e difere do valor da variável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Compilador C (GCC ou online como Replit)",
                                    "Editor de texto (VS Code)"
                                  ],
                                  "tips": "Use printf com %p para endereços e %d para valores; compile com gcc -o programa programa.c",
                                  "learningObjective": "Entender ponteiros como variáveis que armazenam endereços de memória.",
                                  "commonMistakes": [
                                    "Confundir valor com endereço",
                                    "Esquecer o & ao obter endereço",
                                    "Ignorar que endereços são hexadecimal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar, Inicializar e Usar Ponteiros Básicos",
                                  "subSteps": [
                                    "Declare um ponteiro para inteiro: int *ptr;.",
                                    "Inicialize o ponteiro com o endereço de uma variável: ptr = &var;.",
                                    "Acesse o valor indireto usando *ptr.",
                                    "Modifique o valor da variável original através do ponteiro.",
                                    "Teste desreferenciando ponteiros não inicializados para ver comportamento indefinido."
                                  ],
                                  "verification": "Crie um programa que altere uma variável via ponteiro e imprima antes/depois para confirmar mudança.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Documentação de sintaxe de ponteiros (man pages ou cppreference.com)"
                                  ],
                                  "tips": "Sempre inicialize ponteiros para evitar dereferência de lixo; use NULL como valor sentinela.",
                                  "learningObjective": "Manipular ponteiros para acessar e modificar dados indiretamente.",
                                  "commonMistakes": [
                                    "Dereferenciar ponteiro não inicializado (segmentation fault)",
                                    "Esquecer asterisco (*) na declaração ou uso",
                                    "Confundir ptr e *ptr"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ponteiros em Funções: Passagem por Referência",
                                  "subSteps": [
                                    "Crie uma função que recebe um ponteiro como parâmetro para modificar uma variável externa.",
                                    "Compare passagem por valor vs. por referência com exemplos de troca de valores.",
                                    "Implemente uma função swap(int *a, int *b) que troca dois inteiros.",
                                    "Chame a função passando endereços e verifique a troca.",
                                    "Explique por que ponteiros permitem modificação de argumentos em funções."
                                  ],
                                  "verification": "Teste a função swap com valores iniciais diferentes e confirme inversão após chamada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Exemplos de código de funções com ponteiros"
                                  ],
                                  "tips": "Passagem por ponteiro simula referência; sempre passe & na chamada para variáveis.",
                                  "learningObjective": "Usar ponteiros para passagem eficiente por referência em funções.",
                                  "commonMistakes": [
                                    "Passar valor em vez de endereço na chamada",
                                    "Não dereferenciar dentro da função",
                                    "Modificar ponteiro em vez do valor apontado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introdução à Alocação Dinâmica de Memória",
                                  "subSteps": [
                                    "Inclua <stdlib.h> e use malloc(sizeof(int)) para alocar memória dinamicamente.",
                                    "Atribua valor ao ponteiro alocado: *ptr = 10;.",
                                    "Imprima endereço e valor alocados.",
                                    "Libere memória com free(ptr) e defina ptr = NULL.",
                                    "Teste acesso após free para ver undefined behavior."
                                  ],
                                  "verification": "Programa aloca, usa, libera memória sem vazamentos (use valgrind para checar).",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Compilador C com valgrind (opcional)",
                                    "Documentação malloc/free"
                                  ],
                                  "tips": "Sempre free o que malloc; evite vazamentos comparando alocação com liberação.",
                                  "learningObjective": "Gerenciar memória dinâmica com ponteiros para tamanhos variáveis.",
                                  "commonMistakes": [
                                    "Não incluir stdlib.h",
                                    "Free múltiplas vezes ou não free",
                                    "Usar memória após free"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um programa em C que use ponteiros para criar uma lista simples de 3 inteiros alocados dinamicamente, preencha com valores do usuário via função com ponteiros, imprima-os e libere a memória, demonstrando passagem por referência e alocação dinâmica.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito a diferença entre variável, endereço e ponteiro.",
                                "Executar programa que modifica variável via ponteiro em função.",
                                "Criar e testar alocação dinâmica sem erros de memória.",
                                "Identificar e corrigir código com ponteiro não inicializado.",
                                "Usar debugger (gdb) para inspecionar endereço e valor de ponteiro."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre & e *.",
                                "Correção do código: Compila e executa sem erros ou warnings.",
                                "Eficiência: Uso apropriado de ponteiros sem vazamentos.",
                                "Compreensão prática: Modificações via referência funcionam.",
                                "Documentação: Comentários explicando uso de ponteiros.",
                                "Tratamento de erros: Checagem de malloc != NULL."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como números hexadecimais e aritmética de ponteiros.",
                                "Física: Analogia de memória como espaço físico com endereços.",
                                "Lógica e Algoritmos: Ponteiros em estruturas de dados como listas ligadas.",
                                "Segurança da Informação: Vulnerabilidades como buffer overflow via ponteiros mal gerenciados."
                              ],
                              "realWorldApplication": "Ponteiros são fundamentais em sistemas operacionais para gerenciamento de processos (linked lists), jogos para otimização de arrays dinâmicos de objetos, e embedded systems para alocação eficiente de memória limitada."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Linguagem de Programação",
                    "description": "Tipos de linguagens de programação e sua função na tradução de algoritmos para instruções executáveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Definição e Tipos de Linguagens de Programação",
                        "description": "Compreender o que é uma linguagem de programação, seus tipos principais (alto nível, baixo nível, procedimentais) e sua relação com algoritmos e programas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Definir linguagem de programação",
                            "description": "Explicar o conceito de linguagem de programação como ferramenta para expressar algoritmos em forma de programas executáveis por computadores, diferenciando de linguagens naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender linguagens naturais",
                                  "subSteps": [
                                    "Leia exemplos de frases em português ou inglês, como 'Ferva água por 5 minutos'.",
                                    "Identifique ambiguidades, como 'banco' podendo ser financeiro ou de sentar.",
                                    "Discuta com um parceiro como o contexto resolve ambiguidades em conversas diárias.",
                                    "Anote 3 exemplos de ambiguidades em linguagem natural.",
                                    "Compare com instruções precisas, como uma lista de compras."
                                  ],
                                  "verification": "Liste 3 ambiguidades encontradas e explique como o contexto as resolve.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos impressos de frases ambíguas"
                                  ],
                                  "tips": "Use exemplos cotidianos para tornar relatable; evite jargões técnicos ainda.",
                                  "learningObjective": "Reconhecer limitações das linguagens naturais em comunicações precisas.",
                                  "commonMistakes": [
                                    "Confundir linguagem natural com formal",
                                    "Ignorar ambiguidades intencionalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de linguagens formais",
                                  "subSteps": [
                                    "Defina linguagem formal como conjunto de símbolos e regras fixas sem ambiguidades.",
                                    "Estude exemplos simples como aritmética: '2 + 3 = 5'.",
                                    "Compare com linguagem natural destacando ausência de contexto subjetivo.",
                                    "Crie uma regra simples, como 'somar dois números pares resulta em par'.",
                                    "Teste a regra com exemplos: 2+4=6 (par), 2+3=5 (ímpar, ajuste regra)."
                                  ],
                                  "verification": "Crie e valide uma regra formal simples sem ambiguidades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou app de notas",
                                    "Exemplos de expressões matemáticas"
                                  ],
                                  "tips": "Comece com matemática básica para construir confiança.",
                                  "learningObjective": "Diferenciar linguagens formais das naturais pela precisão e regras.",
                                  "commonMistakes": [
                                    "Misturar regras com interpretações pessoais",
                                    "Usar palavras em vez de símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar linguagens de programação como ferramenta para algoritmos",
                                  "subSteps": [
                                    "Defina algoritmo como sequência finita de instruções para resolver problemas.",
                                    "Exemplo: Algoritmo para somar dois números.",
                                    "Introduza sintaxe básica de pseudocódigo: 'INICIO; leia a, b; soma = a + b; escreva soma; FIM'.",
                                    "Traduza um algoritmo simples de linguagem natural para pseudocódigo.",
                                    "Explique execução: computador segue instruções linha por linha sem ambiguidades."
                                  ],
                                  "verification": "Converta um algoritmo de linguagem natural para pseudocódigo executável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Exemplos de algoritmos impressos"
                                  ],
                                  "tips": "Use pseudocódigo primeiro para evitar sintaxe específica de linguagens.",
                                  "learningObjective": "Entender linguagens de programação como meio para expressar algoritmos de forma executável.",
                                  "commonMistakes": [
                                    "Omitir passos finitos no algoritmo",
                                    "Confundir pseudocódigo com código real"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e sintetizar a definição de linguagem de programação",
                                  "subSteps": [
                                    "Liste diferenças: precisão, sintaxe rígida, compilação/interpretação vs. interpretação humana.",
                                    "Exemplos: Python vs. Português para 'some dois números'.",
                                    "Crie definição própria: 'Linguagem de programação é uma linguagem formal para escrever programas que expressam algoritmos executáveis por máquinas'.",
                                    "Compare tipos: Python (alta nível), Assembly (baixa nível).",
                                    "Debata: Por que computadores precisam de linguagens específicas?"
                                  ],
                                  "verification": "Escreva e recite sua definição, comparando com 2 exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de linguagens de programação",
                                    "Vídeo curto de 2 min sobre Python"
                                  ],
                                  "tips": "Inclua analogia: linguagem de programação como 'idioma do computador'.",
                                  "learningObjective": "Formular uma definição precisa diferenciando de linguagens naturais.",
                                  "commonMistakes": [
                                    "Definir como 'qualquer código'",
                                    "Ignorar aspecto executável por máquinas"
                                  ]
                                }
                              ],
                              "practicalExample": "Compare instruções para fazer um sanduíche em português ('pegue pão, corte, etc.') com pseudocódigo: 'INICIO; leia ingredientes; se tem queijo ENTAO adicione; FIM'. Note como o pseudocódigo elimina ambiguidades para um 'cozinheiro robô'.",
                              "finalVerifications": [
                                "Defina linguagem de programação em 1 frase precisa.",
                                "Dê 2 exemplos de ambiguidades em linguagem natural ausentes em programação.",
                                "Converta um algoritmo simples para pseudocódigo.",
                                "Explique por que computadores usam linguagens específicas.",
                                "Diferencie Python de Assembly em 1 característica.",
                                "Identifique se uma frase é linguagem natural ou formal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (inclui algoritmos e executabilidade).",
                                "Correta diferenciação de linguagens naturais.",
                                "Uso de exemplos relevantes e sem ambiguidades.",
                                "Compreensão de sintaxe e regras formais.",
                                "Capacidade de sintetizar conceito em pseudocódigo.",
                                "Identificação de limitações de linguagens naturais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal e algoritmos.",
                                "Língua Portuguesa: Análise de ambiguidades semânticas.",
                                "Física: Analogia com leis precisas da natureza.",
                                "História: Evolução de linguagens desde Babbage.",
                                "Artes: Criatividade na expressão de ideias precisas."
                              ],
                              "realWorldApplication": "Desenvolvedores usam linguagens como Python para criar apps como Instagram, traduzindo ideias em instruções executáveis por bilhões de dispositivos, resolvendo problemas reais como automação bancária ou análise de dados médicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Classificar tipos de linguagens",
                            "description": "Identificar e descrever tipos de linguagens de programação, como de alto nível (ex: C++, Python), baixo nível (assembly) e procedimentais, com exemplos de cada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os critérios básicos de classificação de linguagens de programação",
                                  "subSteps": [
                                    "Pesquise a definição de linguagem de programação e sua importância na computação.",
                                    "Estude os níveis de abstração: alto nível (próximo ao humano) e baixo nível (próximo ao hardware).",
                                    "Identifique paradigmas principais, como procedural, focando em suas características.",
                                    "Crie um quadro comparativo simples com colunas para nível e paradigma.",
                                    "Anote exemplos iniciais de cada categoria para fixação."
                                  ],
                                  "verification": "Crie um quadro com pelo menos 3 critérios de classificação e 2 exemplos por categoria.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Bloco de notas ou editor de texto",
                                    "Vídeos introdutórios sobre linguagens (ex: Khan Academy)"
                                  ],
                                  "tips": "Use diagramas visuais para diferenciar níveis de abstração; comece com fontes confiáveis como Wikipedia ou tutoriais oficiais.",
                                  "learningObjective": "Dominar os principais critérios usados para classificar linguagens de programação.",
                                  "commonMistakes": [
                                    "Confundir nível de abstração com paradigma de programação",
                                    "Ignorar exemplos históricos como Fortran para procedural"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar linguagens de alto nível",
                                  "subSteps": [
                                    "Defina linguagens de alto nível: fáceis de ler, portáteis, com alto nível de abstração.",
                                    "Estude exemplos: Python (interpretada, versátil), C++ (compilada, performática).",
                                    "Analise vantagens: rapidez de desenvolvimento, legibilidade.",
                                    "Execute um código simples em Python online (ex: print('Olá Mundo')).",
                                    "Compare sintaxe de Python vs. C++ em um snippet curto."
                                  ],
                                  "verification": "Liste 3 linguagens de alto nível com uma breve descrição e um exemplo de código simples para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Replit ou CodePen online",
                                    "Documentação oficial de Python e C++",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Priorize linguagens populares para facilitar compreensão futura; teste códigos em playgrounds online.",
                                  "learningObjective": "Identificar e descrever características de linguagens de alto nível com exemplos práticos.",
                                  "commonMistakes": [
                                    "Achar que todas alto nível são interpretadas (C++ é compilada)",
                                    "Não testar códigos para ver abstração na prática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar linguagens de baixo nível",
                                  "subSteps": [
                                    "Defina linguagens de baixo nível: próximas ao assembly do processador, dependentes de hardware.",
                                    "Estude assembly: sintaxe como MOV, ADD; exemplo em x86.",
                                    "Discuta desvantagens: complexidade, pouca portabilidade.",
                                    "Simule um programa simples em assembly usando um emulador online.",
                                    "Compare com alto nível: traduza um 'Olá Mundo' de Python para assembly conceitual."
                                  ],
                                  "verification": "Escreva um pseudocódigo assembly para somar dois números e explique sua dependência de hardware.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Emulador online como Godbolt ou Assembly Playground",
                                    "Tutoriais de assembly básico",
                                    "Comparador de linguagens"
                                  ],
                                  "tips": "Não precisa compilar; foque em entender instruções básicas como foco em registradores.",
                                  "learningObjective": "Reconhecer linguagens de baixo nível e suas limitações em relação ao hardware.",
                                  "commonMistakes": [
                                    "Confundir assembly com linguagens como C (C é médio/alto)",
                                    "Subestimar a complexidade sem exemplos visuais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar linguagens procedurais e praticar integração",
                                  "subSteps": [
                                    "Defina linguagens procedurais: baseadas em procedimentos/funções, fluxo sequencial (ex: C, Pascal).",
                                    "Classifique exemplos: C (procedural, médio nível), Python (multi-paradigma, mas suporta procedural).",
                                    "Crie uma tabela de classificação misturando níveis e paradigmas.",
                                    "Classifique 5 linguagens dadas: Python, Assembly, C++, Java, Fortran.",
                                    "Discuta casos híbridos, como C++ que evoluiu para OO."
                                  ],
                                  "verification": "Classifique corretamente 5 linguagens em uma tabela com nível e paradigma, justificando cada uma.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel",
                                    "Lista de linguagens comuns",
                                    "Referências online como Stack Overflow"
                                  ],
                                  "tips": "Use cores na tabela para visualizar: verde para alto, vermelho para baixo; revise exemplos múltiplas vezes.",
                                  "learningObjective": "Aplicar classificação integrada de tipos de linguagens com exemplos precisos.",
                                  "commonMistakes": [
                                    "Classificar Python só como OO (é multi-paradigma)",
                                    "Ignorar que procedurais podem ser alto ou médio nível"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado um projeto de automação simples, classifique Python (alto nível, multi-paradigma com suporte procedural) vs. Assembly (baixo nível, não procedural) para decidir qual usar: Python para protótipo rápido, Assembly para otimização extrema em embedded.",
                              "finalVerifications": [
                                "Liste e descreva 2 exemplos de linguagens de alto nível, 2 de baixo nível e 2 procedurais.",
                                "Crie uma tabela classificando Python, C++, Assembly, C e Fortran.",
                                "Explique a diferença entre nível de abstração e paradigma procedural.",
                                "Identifique um caso onde uma linguagem procedural de alto nível é preferível.",
                                "Simule a classificação de uma nova linguagem como Rust (alto nível, multi-paradigma)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de níveis de abstração (alto/baixo).",
                                "Correta descrição de paradigmas procedurais com exemplos relevantes.",
                                "Uso de exemplos concretos e sintaxe básica em classificações.",
                                "Capacidade de criar tabelas ou diagramas claros para comparação.",
                                "Justificativa lógica para classificações em cenários práticos.",
                                "Identificação de erros comuns, como confusões entre categorias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica sequencial e algoritmos em fluxogramas.",
                                "História: Evolução das linguagens desde Fortran (procedural) até modernas.",
                                "Língua Portuguesa: Análise descritiva de textos técnicos sobre programação.",
                                "Física: Analogia com hardware (circuitos e registradores em assembly)."
                              ],
                              "realWorldApplication": "Na engenharia de software, classificar linguagens ajuda a escolher a ideal para projetos: alto nível como Python para IA rápida, baixo nível como assembly para sistemas embarcados em IoT, e procedurais como C para kernels de SO eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Relacionar algoritmo e programa",
                            "description": "Explicar como uma linguagem de programação traduz um algoritmo (descrição lógica de passos) em um programa (sequência de instruções executáveis).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Algoritmo",
                                  "subSteps": [
                                    "Defina algoritmo como uma sequência finita de passos lógicos para resolver um problema.",
                                    "Identifique características: precisão, finitude, definitividade e efetividade.",
                                    "Diferencie de receitas ou instruções cotidianas, enfatizando a abstração lógica.",
                                    "Represente um algoritmo simples em pseudocódigo.",
                                    "Discuta exemplos como 'encontrar o maior número em uma lista'."
                                  ],
                                  "verification": "Escreva uma definição clara e liste 3 características principais do algoritmo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de pseudocódigo online"
                                  ],
                                  "tips": "Use fluxogramas para visualizar a sequência de passos.",
                                  "learningObjective": "Dominar a definição e propriedades de um algoritmo.",
                                  "commonMistakes": [
                                    "Confundir com código executável",
                                    "Omitir finitude ou efetividade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de Programa",
                                  "subSteps": [
                                    "Defina programa como a implementação concreta de um algoritmo em uma linguagem de programação.",
                                    "Explique sintaxe, semântica e execução por máquina.",
                                    "Compare com algoritmo: programa é 'tradução' para instruções executáveis.",
                                    "Identifique componentes: variáveis, loops, condicionais.",
                                    "Discuta compilação ou interpretação."
                                  ],
                                  "verification": "Descreva como um programa difere de um algoritmo e dê um exemplo de sintaxe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Documentação de Python básica"
                                  ],
                                  "tips": "Pense no programa como 'idioma da máquina' para o algoritmo.",
                                  "learningObjective": "Entender programa como representação executável de lógica algorítmica.",
                                  "commonMistakes": [
                                    "Achar que programa é só código sem lógica",
                                    "Ignorar dependência de linguagem específica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Algoritmo para Programa",
                                  "subSteps": [
                                    "Escolha um algoritmo simples (ex: soma de dois números).",
                                    "Quebre em pseudocódigo: entrada, processamento, saída.",
                                    "Traduza cada passo para sintaxe de uma linguagem (ex: Python).",
                                    "Mapeie estruturas: sequência → linhas de código; decisão → if; repetição → loop.",
                                    "Verifique correspondência um-a-um entre passos lógicos e instruções."
                                  ],
                                  "verification": "Crie um mapeamento lado a lado: pseudocódigo vs código fonte.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente Python online (Replit)",
                                    "Pseudocódigo impresso"
                                  ],
                                  "tips": "Mantenha nomes de variáveis intuitivos para facilitar a tradução.",
                                  "learningObjective": "Aprender a processar a tradução direta de lógica para código.",
                                  "commonMistakes": [
                                    "Alterar lógica durante tradução",
                                    "Esquecer tratamento de entrada/saída"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, Testar e Analisar a Tradução",
                                  "subSteps": [
                                    "Execute o programa e valide saídas com entradas esperadas.",
                                    "Compare tempo de execução e eficiência com o algoritmo abstrato.",
                                    "Identifique erros de tradução (bugs lógicos vs sintaxe).",
                                    "Refatore o código para otimizar sem mudar o algoritmo.",
                                    "Documente lições: o que o programa ganhou/perdeu do algoritmo."
                                  ],
                                  "verification": "Registre 3 testes com entradas/saídas e análise de acertos/erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Interpretador Python",
                                    "Planilha para testes"
                                  ],
                                  "tips": "Use print() para depurar passos intermediários.",
                                  "learningObjective": "Validar a fidelidade da tradução algoritmo-programa.",
                                  "commonMistakes": [
                                    "Não testar casos extremos",
                                    "Confundir erro de sintaxe com falha lógica"
                                  ]
                                }
                              ],
                              "practicalExample": "Algoritmo: 1. Receba dois números A e B. 2. Calcule S = A + B. 3. Mostre S. Programa em Python: a = float(input('A: ')); b = float(input('B: ')); s = a + b; print('Soma:', s). Isso traduz lógica sequencial em instruções executáveis.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre algoritmo e programa.",
                                "Traduza um novo algoritmo simples para código sem erros.",
                                "Identifique 3 correspondências entre pseudocódigo e programa.",
                                "Execute programa e confirme saída esperada para 5 entradas.",
                                "Descreva o papel da linguagem na tradução."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de algoritmo e programa (80%+ acerto).",
                                "Qualidade do mapeamento lógico-código (sem desvios).",
                                "Correção na execução e testes (100% pass rate).",
                                "Profundidade na análise de diferenças/semelhanças.",
                                "Clareza na documentação e exemplos fornecidos.",
                                "Criatividade em conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica sequencial e estruturas condicionais.",
                                "Língua Portuguesa: Redação clara e precisa de instruções.",
                                "Física: Modelagem de processos e fluxos causais.",
                                "Artes: Representação visual via fluxogramas."
                              ],
                              "realWorldApplication": "Desenvolvedores usam isso para transformar ideias lógicas (algoritmos) em apps funcionais, como sistemas de recomendação no Netflix ou navegação GPS, garantindo que soluções abstratas se tornem softwares executáveis eficientes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Ferramentas de Tradução: Compilador e Lógica de Programação",
                        "description": "Entender o papel do compilador na conversão de código fonte para instruções de máquina e os princípios básicos de lógica de programação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Descrever função do compilador",
                            "description": "Explicar o processo de compilação, desde o código fonte em linguagem de alto nível até o código objeto executável, incluindo software básico como compiladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Básico de Compilador e Código Fonte",
                                  "subSteps": [
                                    "Defina o que é um compilador: um programa que traduz código fonte em linguagem de alto nível para código de máquina.",
                                    "Explique código fonte: texto escrito por programadores em linguagens como C, Java ou Python.",
                                    "Diferencie linguagem de alto nível (próxima à humana) de baixo nível (próxima à máquina).",
                                    "Identifique o objetivo principal: transformar código legível em executável eficiente.",
                                    "Pesquise exemplos de compiladores famosos, como GCC para C/C++."
                                  ],
                                  "verification": "Escreva uma definição clara do compilador em suas próprias palavras e liste 3 exemplos de linguagens de alto nível.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial do GCC (gcc.gnu.org)",
                                    "Vídeo introdutório sobre compiladores no YouTube (canal freeCodeCamp)"
                                  ],
                                  "tips": "Use analogias como 'tradutor' para fixar o conceito.",
                                  "learningObjective": "Compreender o papel fundamental do compilador na ponte entre humano e máquina.",
                                  "commonMistakes": "Confundir compilador com interpretador; lembre-se que compilador gera código objeto completo antes da execução."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar as Fases Principais do Processo de Compilação",
                                  "subSteps": [
                                    "Descreva a fase de pré-processamento: expansão de macros e inclusão de headers.",
                                    "Explique a compilação propriamente dita: análise léxica, sintática, semântica e geração de código intermediário.",
                                    "Detalhe a montagem (assembly): conversão de código assembly para código objeto.",
                                    "Aborde o linking: combinação de código objeto com bibliotecas para formar o executável.",
                                    "Diagrame o fluxo: código fonte → pré-processado → assembly → objeto → executável."
                                  ],
                                  "verification": "Desenhe um fluxograma das 4 fases principais e rotule cada uma corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação como Draw.io",
                                    "Artigo 'How Compilers Work' no site ExplainingComputers"
                                  ],
                                  "tips": "Execute 'gcc -v' em um comando para ver as fases em ação.",
                                  "learningObjective": "Mapear o pipeline de compilação passo a passo.",
                                  "commonMistakes": "Ignorar o pré-processamento; é crucial para entender erros de inclusão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Saída: Código Objeto e Executável",
                                  "subSteps": [
                                    "Defina código objeto: formato binário intermediário (.o ou .obj) específico da plataforma.",
                                    "Explique o executável: arquivo final (.exe no Windows, ELF no Linux) pronto para rodar.",
                                    "Discuta relocação e resolução de símbolos durante o linking.",
                                    "Compare tamanhos: código fonte pequeno gera executável maior devido a bibliotecas.",
                                    "Use ferramentas como 'objdump' para inspecionar código objeto."
                                  ],
                                  "verification": "Compile um código simples e use 'file' ou 'objdump' para verificar o tipo de saída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Instalador do GCC/MinGW",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Sempre compile com flags como -S para ver assembly intermediário.",
                                  "learningObjective": "Diferenciar produtos finais do processo de compilação.",
                                  "commonMistakes": "Achar que código objeto é diretamente executável; requer linking."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conhecimento com um Exemplo Prático",
                                  "subSteps": [
                                    "Escreva um programa C simples: 'Hello World'.",
                                    "Compile passo a passo: gcc -E (pré), gcc -S (assembly), gcc -c (objeto), gcc (link).",
                                    "Execute e observe o processo completo.",
                                    "Identifique erros comuns como sintaxe e depure.",
                                    "Documente o que acontece em cada fase."
                                  ],
                                  "verification": "Registre logs de cada comando de compilação e explique diferenças nos arquivos gerados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal/CMD com GCC instalado",
                                    "Código fonte exemplo salvo como hello.c"
                                  ],
                                  "tips": "Use flags verbose (-v) para visibilidade total do processo.",
                                  "learningObjective": "Executar e observar o compilador em ação real.",
                                  "commonMistakes": "Esquecer de incluir <stdio.h>; teste pré-processamento primeiro."
                                }
                              ],
                              "practicalExample": "Escreva e compile um programa C 'hello.c': #include <stdio.h> int main() { printf('Olá, Compilador!'); return 0; }. Use gcc hello.c -o hello para gerar executável, então execute ./hello, observando a transformação de texto fonte para binário rodável.",
                              "finalVerifications": [
                                "Pode listar e ordenar corretamente as 4 fases de compilação?",
                                "Consegue explicar a diferença entre código objeto e executável?",
                                "Identifica pelo menos 3 funções de um compilador?",
                                "Desenha um fluxograma preciso do processo?",
                                "Compila um programa simples sem erros e explica cada saída?",
                                "Diferencia compilador de interpretador em um parágrafo?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das fases (90% correto)",
                                "Uso correto de terminologia técnica (compilador, linking, etc.)",
                                "Capacidade de diagramação clara do processo",
                                "Demonstração prática via compilação de exemplo",
                                "Identificação de erros comuns e soluções",
                                "Explicação coesa do fluxo fonte → executável"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Autômatos e linguagens formais na análise léxica/sintática",
                                "Hardware: Arquitetura de computadores para entender código de máquina",
                                "Física: Analogia com transdutores em processamento de sinais",
                                "Lógica: Circuitos lógicos booleanos no assembly"
                              ],
                              "realWorldApplication": "No desenvolvimento de software, compiladores como GCC ou Clang otimizam apps mobile (Android NDK), jogos (Unity C#) e sistemas operacionais (Linux kernel), permitindo execução eficiente em hardware variado e depuração de performance em indústrias como finanças e IA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Aplicar lógica de programação básica",
                            "description": "Identificar elementos fundamentais da lógica de programação, como sequências de comandos e fluxos lógicos para resolver problemas computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de algoritmo e pseudocódigo",
                                  "subSteps": [
                                    "Defina o que é um algoritmo: uma sequência finita de instruções bem definidas para resolver um problema.",
                                    "Aprenda pseudocódigo: linguagem simplificada para representar lógica sem sintaxe de programação específica.",
                                    "Identifique componentes básicos: entrada (input), processamento e saída (output).",
                                    "Pratique escrevendo um pseudocódigo simples para somar dois números.",
                                    "Diferencie algoritmo de programa: algoritmo é o plano lógico, programa é a implementação em código."
                                  ],
                                  "verification": "Escreva um pseudocódigo correto para calcular a área de um retângulo e explique cada parte.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples (como Bloco de Notas)"
                                  ],
                                  "tips": "Use setas ou numeração para mostrar fluxo; mantenha simples e legível.",
                                  "learningObjective": "Entender e representar logicamente um problema simples usando pseudocódigo.",
                                  "commonMistakes": [
                                    "Confundir input com output",
                                    "Esquecer passos de processamento",
                                    "Usar linguagem de programação real em vez de pseudocódigo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar sequências lineares de comandos",
                                  "subSteps": [
                                    "Escreva comandos sequenciais: execute um após o outro sem ramificações.",
                                    "Inclua variáveis: declare e atribua valores (ex: numero1 ← 5).",
                                    "Realize operações básicas: soma, subtração, multiplicação.",
                                    "Teste a sequência manualmente: simule a execução passo a passo.",
                                    "Aplique em um problema: calcular o perímetro de um quadrado."
                                  ],
                                  "verification": "Crie e simule um pseudocódigo sequencial para converter Celsius para Fahrenheit.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para verificação manual"
                                  ],
                                  "tips": "Sempre leia os comandos na ordem; trace valores das variáveis em uma tabela.",
                                  "learningObjective": "Construir fluxos lineares precisos para processar dados sequencialmente.",
                                  "commonMistakes": [
                                    "Pular declarações de variáveis",
                                    "Erros de ordem nos comandos",
                                    "Não simular execução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar estruturas condicionais (decisões)",
                                  "subSteps": [
                                    "Introduza 'SE' (if): execute bloco se condição verdadeira.",
                                    "Adicione 'SENÃO' (else): alternativa para condição falsa.",
                                    "Use operadores lógicos: >, <, =, AND, OR.",
                                    "Crie pseudocódigo com decisão: verificar se um número é par ou ímpar.",
                                    "Teste múltiplos cenários: valores verdadeiros e falsos."
                                  ],
                                  "verification": "Escreva pseudocódigo para aprovar/reprovar aluno baseado em nota (média >= 7).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos impressos de condicionais"
                                  ],
                                  "tips": "Escreva condições claras; use parênteses para complexidade.",
                                  "learningObjective": "Aplicar lógica de decisão para ramificar fluxos baseados em condições.",
                                  "commonMistakes": [
                                    "Confundir = com == para comparação",
                                    "Esquecer 'SENÃO'",
                                    "Condições mal formadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Utilizar estruturas de repetição (loops)",
                                  "subSteps": [
                                    "Aprenda 'ENQUANTO' (while): repita enquanto condição verdadeira.",
                                    "Use 'REPETIR até' (do-while): execute pelo menos uma vez.",
                                    "Controle contadores: inicialize, incremente/decremente.",
                                    "Aplique em soma de série: somar números de 1 a N.",
                                    "Combine com condicionais: loop com decisão interna."
                                  ],
                                  "verification": "Crie pseudocódigo para imprimir tabela de multiplicação de um número.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para simulação"
                                  ],
                                  "tips": "Sempre inicialize contadores; evite loops infinitos testando condições.",
                                  "learningObjective": "Controlar repetições para automatizar tarefas iterativas.",
                                  "commonMistakes": [
                                    "Loops infinitos por falta de incremento",
                                    "Condição errada no while",
                                    "Não quebrar loop quando necessário"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Resolver problema completo integrando todas as estruturas",
                                  "subSteps": [
                                    "Escolha problema: calcular média de notas e classificar (Aprovado, Recuperação, Reprovado).",
                                    "Planeje: entrada de notas em loop, cálculo sequencial, decisão final.",
                                    "Escreva pseudocódigo completo.",
                                    "Simule execução com dados de teste variados.",
                                    "Refatore: otimize e corrija erros identificados."
                                  ],
                                  "verification": "Apresente pseudocódigo funcional para o problema de média de notas com classificação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Computador para diagrama de fluxo opcional"
                                  ],
                                  "tips": "Desenhe fluxograma primeiro; divida em módulos reutilizáveis.",
                                  "learningObjective": "Integrar sequências, condicionais e loops em solução lógica coesa.",
                                  "commonMistakes": [
                                    "Misturar estruturas sem planejamento",
                                    "Erros de escopo em variáveis",
                                    "Não testar casos extremos"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolver um pseudocódigo para um caixa eletrônico simples: ler PIN (condicional para validar), ler valor saque (loop para múltiplos saques), calcular saldo restante (sequencial) e exibir mensagem final.",
                              "finalVerifications": [
                                "Escrever pseudocódigo correto para problemas lineares, condicionais e com loops.",
                                "Simular execução manual sem erros lógicos.",
                                "Identificar e corrigir fluxos lógicos incorretos em exemplos dados.",
                                "Explicar verbalmente o raciocínio por trás de cada estrutura usada.",
                                "Criar fluxograma equivalente ao pseudocódigo.",
                                "Aplicar lógica em problema novo sem orientação."
                              ],
                              "assessmentCriteria": [
                                "Precisão lógica: ausência de erros em fluxos e condições.",
                                "Clareza e legibilidade: uso de pseudocódigo padronizado.",
                                "Completude: inclusão de input, processamento e output.",
                                "Eficiência: minimalismo sem redundâncias.",
                                "Testabilidade: cobertura de cenários variados.",
                                "Criatividade: soluções inovadoras para problemas propostos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: operadores relacionais e lógicos.",
                                "Lógica e Filosofia: raciocínio dedutivo e algoritmos.",
                                "Ciências: método científico (hipótese, teste, iteração).",
                                "Língua Portuguesa: redação clara e estruturada de instruções.",
                                "Educação Financeira: simulações de cálculos em loops."
                              ],
                              "realWorldApplication": "Desenvolver scripts para automação de tarefas diárias, como processamento de planilhas no Excel, criação de bots simples em apps ou base para programação em jogos e aplicativos móveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Comandos e Estruturas em Linguagens Procedimentais",
                        "description": "Explorar comandos básicos e estruturas avançadas em linguagens procedimentais, incluindo tipos de dados, subprogramas e tratamento de exceções.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Identificar comandos básicos",
                            "description": "Descrever comandos procedimentais como atribuição, entrada/saída, condicionais (if-else), repetitivos (loops) e seletivos, com exemplos em pseudocódigo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Comandos de Atribuição e Entrada/Saída",
                                  "subSteps": [
                                    "Estude a sintaxe básica de atribuição em pseudocódigo: variável ← valor.",
                                    "Pratique exemplos simples como nome ← 'João' e idade ← 20.",
                                    "Aprenda entrada: LEIA variável e saída: ESCREVA expressão.",
                                    "Crie pseudocódigos que combinem atribuição com entrada e saída.",
                                    "Teste com cenários reais, como ler nome do usuário e exibi-lo."
                                  ],
                                  "verification": "Crie um pseudocódigo que leia dois números, some-os via atribuição e exiba o resultado. Execute mentalmente sem erros.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples",
                                    "Referência de pseudocódigo"
                                  ],
                                  "tips": "Sempre use setas ← para atribuição para evitar confusão com igualdade.",
                                  "learningObjective": "Identificar e descrever corretamente comandos de atribuição, entrada e saída em pseudocódigo.",
                                  "commonMistakes": [
                                    "Confundir atribuição (←) com comparação (==)",
                                    "Esquecer de declarar variáveis antes da atribuição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturas Condicionais (if-else)",
                                  "subSteps": [
                                    "Entenda a estrutura: SE condição ENTAO ... SENAO ... FIM-SE.",
                                    "Pratique condições simples como idade > 18.",
                                    "Adicione blocos else para alternativas.",
                                    "Teste com expressões compostas: idade >= 18 E nota >= 7.",
                                    "Construa um pseudocódigo que classifique aprovação baseado em nota."
                                  ],
                                  "verification": "Escreva um pseudocódigo que leia uma nota e imprima 'Aprovado' ou 'Reprovado' usando if-else.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto",
                                    "Exemplos de pseudocódigo condicional"
                                  ],
                                  "tips": "Use parênteses em condições complexas para clareza.",
                                  "learningObjective": "Reconhecer e exemplificar estruturas condicionais if-else em pseudocódigo.",
                                  "commonMistakes": [
                                    "Esquecer FIM-SE",
                                    "Usar atribuição em vez de comparação na condição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estruturas Repetitivas (Loops)",
                                  "subSteps": [
                                    "Aprenda ENQUANTO condição FACA ... FIM-ENQUANTO para loops indeterminados.",
                                    "Estude PARA i DE 1 ATÉ 10 FACA ... FIM-PARA para loops determinados.",
                                    "Pratique contadores e acumuladores dentro de loops.",
                                    "Crie exemplos como somar números de 1 a 10 usando loop.",
                                    "Identifique quando usar cada tipo de loop."
                                  ],
                                  "verification": "Desenvolva um pseudocódigo que use um loop para calcular a soma de 10 números lidos do usuário.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto",
                                    "Tabela de loops em pseudocódigo"
                                  ],
                                  "tips": "Inicialize contadores antes do loop para evitar loops infinitos.",
                                  "learningObjective": "Identificar e descrever loops while e for em pseudocódigo com exemplos.",
                                  "commonMistakes": [
                                    "Condição de parada incorreta levando a loop infinito",
                                    "Incremento esquecido no final do loop"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estruturas Seletivas e Síntese",
                                  "subSteps": [
                                    "Estude ESCOLHA variável CASO 1: ... CASO 2: ... OUTRO: ... FIM-ESCOLHA.",
                                    "Compare seletivas com múltiplos if-else aninhados.",
                                    "Integre todos comandos em um pseudocódigo complexo, como menu interativo.",
                                    "Analise pseudocódigos mistos e identifique cada comando.",
                                    "Descreva verbalmente o fluxo de execução."
                                  ],
                                  "verification": "Crie um pseudocódigo de menu com opções usando ESCOLHA, incluindo loops e condicionais.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto",
                                    "Exemplos avançados de pseudocódigo"
                                  ],
                                  "tips": "Use ESCOLHA para múltiplas opções discretas em vez de if-else encadeados.",
                                  "learningObjective": "Sintetizar identificação de comandos básicos, incluindo seletivas, em contextos integrados.",
                                  "commonMistakes": [
                                    "Não cobrir caso 'OUTRO' em ESCOLHA",
                                    "Confundir seletiva com condicional simples"
                                  ]
                                }
                              ],
                              "practicalExample": "Pseudocódigo de calculadora simples: LEIA opcao; ESCOLHA opcao CASO 1: LEIA a,b; resultado ← a+b; ESCREVA resultado; ... FIM-ESCOLHA dentro de um ENQUANTO para repetir.",
                              "finalVerifications": [
                                "Identificar corretamente atribuição em 5 exemplos aleatórios.",
                                "Descrever fluxo de um if-else com entrada/saída.",
                                "Explicar diferença entre while e for com pseudocódigo.",
                                "Analisar um pseudocódigo misto e listar todos comandos.",
                                "Criar pseudocódigo funcional com todos tipos de comandos.",
                                "Verificar ausência de erros comuns em auto-avaliação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cada comando (atribuição, I/O, if-else, loops, seletivas).",
                                "Uso correto de sintaxe em pseudocódigo nos exemplos.",
                                "Descrições claras e completas de funcionalidades.",
                                "Integração lógica em exemplos compostos.",
                                "Ausência de erros comuns identificados.",
                                "Criatividade em aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional em condicionais.",
                                "Língua Portuguesa: Estrutura textual e fluxogramas.",
                                "Física: Modelagem de processos repetitivos (loops).",
                                "Artes: Visualização de fluxos com diagramas."
                              ],
                              "realWorldApplication": "Esses comandos são fundamentais para automação de tarefas em planilhas (Excel VBA), desenvolvimento de apps simples (como calculadoras em Python) e scripts de jogos básicos, permitindo controle de fluxo em softwares do dia a dia como sites interativos e robótica educacional."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Explicar tipos de dados e estruturas",
                            "description": "Diferenciar tipos escalares (int, float) e estruturados (arrays, structs), e seu uso em linguagens como C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Tipos de Dados Escalares (int e float)",
                                  "subSteps": [
                                    "Defina tipo int como inteiro sem decimais, usado para contagens e índices.",
                                    "Defina tipo float como número de ponto flutuante, para valores com decimais e precisão aproximada.",
                                    "Explique diferenças: int é exato para inteiros, float pode ter erros de arredondamento.",
                                    "Aprenda declaração em C++: int idade = 25; float altura = 1.75;"
                                  ],
                                  "verification": "Escreva 3 exemplos de declarações corretas de int e float e explique um uso cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou IDE como Visual Studio Code)",
                                    "Referência C++ types (cppreference.com)"
                                  ],
                                  "tips": "Use int para contagens exatas; float para medidas reais, mas valide precisão.",
                                  "learningObjective": "Diferenciar e declarar tipos escalares corretamente em C++.",
                                  "commonMistakes": [
                                    "Usar float para contagens exatas (perda de precisão)",
                                    "Esquecer inicialização de variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Tipos Estruturados: Arrays",
                                  "subSteps": [
                                    "Defina array como coleção de elementos do mesmo tipo, acessados por índice.",
                                    "Aprenda sintaxe em C++: int notas[5] = {90, 85, 78, 92, 88};",
                                    "Entenda alocação fixa vs dinâmica (new/delete para arrays dinâmicos).",
                                    "Pratique acesso: notas[0] para primeiro elemento.",
                                    "Discuta limites: índices de 0 a tamanho-1."
                                  ],
                                  "verification": "Crie e inicialize um array de 4 floats, acesse o terceiro elemento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE C++ com debugger",
                                    "Exemplos de código array C++"
                                  ],
                                  "tips": "Sempre inicialize arrays para evitar lixo de memória.",
                                  "learningObjective": "Declarar, inicializar e acessar arrays em C++.",
                                  "commonMistakes": [
                                    "Acessar índice fora dos limites (buffer overflow)",
                                    "Confundir com variáveis únicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Tipos Estruturados: Structs",
                                  "subSteps": [
                                    "Defina struct como coleção de campos de tipos diferentes, modelando objetos reais.",
                                    "Sintaxe em C++: struct Aluno { string nome; int idade; float media; };",
                                    "Crie instância: Aluno aluno1; aluno1.nome = \"João\";",
                                    "Acesse membros com ponto (.) ou seta (->) para ponteiros.",
                                    "Compare com classes: struct é mais simples, sem métodos por padrão."
                                  ],
                                  "verification": "Defina um struct Pessoa com 3 campos e crie uma instância preenchida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Documentação struct C++"
                                  ],
                                  "tips": "Use struct para agrupar dados relacionados logicamente.",
                                  "learningObjective": "Definir e usar structs para dados compostos em C++.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula após struct",
                                    "Não inicializar todos os campos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Escalares de Estruturados e Aplicações em C++",
                                  "subSteps": [
                                    "Compare: escalares armazenam um valor; estruturados armazenam múltiplos.",
                                    "Discuta usos: escalares para cálculos simples; arrays para listas; structs para entidades.",
                                    "Exemplo integrado: programa com int/float, array e struct.",
                                    "Aborde memória: escalares fixos; arrays contíguos; structs agregados.",
                                    "Pratique compilação e execução de código misto."
                                  ],
                                  "verification": "Escreva um programa C++ usando todos os tipos e explique escolhas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Terminal para compilar g++ main.cpp -o main",
                                    "Exemplos de código completo"
                                  ],
                                  "tips": "Pense na representação de dados reais antes de escolher o tipo.",
                                  "learningObjective": "Aplicar e diferenciar tipos em contextos reais de programação.",
                                  "commonMistakes": [
                                    "Usar struct quando array basta",
                                    "Ignorar overhead de memória em structs"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa C++ para gerenciar alunos: use int para ID, float para nota média, array<int,5> para notas parciais, e struct Aluno {int id; float media; int notas[5]; string nome;};. Preencha 2 alunos, calcule médias e imprima.",
                              "finalVerifications": [
                                "Lista corretamente int/float como escalares e arrays/structs como estruturados.",
                                "Explica diferenças de uso e memória com exemplos em C++.",
                                "Declara e usa todos os tipos sem erros de sintaxe.",
                                "Identifica quando usar cada tipo em cenários reais.",
                                "Compila e executa programa integrado sem erros.",
                                "Discute limitações como precisão de float e limites de array."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas: 30%)",
                                "Exemplos de código C++ válidos e compiláveis (30%)",
                                "Compreensão de usos práticos e diferenças (20%)",
                                "Identificação de erros comuns e soluções (10%)",
                                "Clareza na explicação escrita/oral (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas com int/float e vetores (arrays).",
                                "Física: Modelagem de grandezas escalares (float) e vetoriais (arrays).",
                                "Banco de Dados: Structs semelhantes a registros em tabelas relacionais.",
                                "Engenharia: Abstração de sistemas complexos com structs."
                              ],
                              "realWorldApplication": "Em jogos, int/float para posições e velocidades (escalares), arrays para trilhas de partículas, structs para personagens. Em sistemas empresariais, structs para clientes com múltiplos campos, arrays para histórico de transações, otimizando armazenamento e processamento eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Compreender subprogramação",
                            "description": "Descrever funções, passagem de parâmetros por valor e referência, escopo de variáveis, recursividade e ponteiros em linguagens procedimentais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Definição e Uso Básico de Funções",
                                  "subSteps": [
                                    "Estude a sintaxe para declarar uma função: tipo de retorno, nome, parâmetros e corpo.",
                                    "Implemente uma função simples que retorne um valor calculado, como soma de dois números.",
                                    "Chame a função no programa principal e observe o fluxo de execução.",
                                    "Analise como o programa principal passa o controle para a função e retorna.",
                                    "Teste com diferentes entradas para verificar o comportamento."
                                  ],
                                  "verification": "Implemente e execute uma função simples que calcule e retorne a soma de dois inteiros, confirmando o resultado no main.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador C (ex: GCC), editor de texto (VS Code), documentação de sintaxe de funções em C.",
                                  "tips": "Sempre declare funções antes de usá-las ou use protótipos para evitar erros de linker.",
                                  "learningObjective": "Dominar a declaração, chamada e retorno de funções básicas em linguagens procedimentais.",
                                  "commonMistakes": "Esquecer o ponto e vírgula após a declaração da função; não retornar valor em funções não-void."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Passagem de Parâmetros por Valor e por Referência",
                                  "subSteps": [
                                    "Implemente uma função que recebe parâmetros por valor e observe que mudanças internas não afetam variáveis originais.",
                                    "Modifique para passagem por referência usando ponteiros e verifique alterações nas variáveis originais.",
                                    "Compare saídas de ambos os métodos com printf para visualizar diferenças.",
                                    "Crie exemplos com arrays (passados por referência implícita) versus escalares por valor.",
                                    "Documente as implicações em termos de cópia de dados e performance."
                                  ],
                                  "verification": "Crie duas funções idênticas, uma por valor e outra por referência, altere o parâmetro dentro delas e confirme que apenas a por referência modifica o original.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Compilador C, exemplos de código online sobre pass by value/reference.",
                                  "tips": "Em C, use * e & para referência; lembre que arrays decay para ponteiros.",
                                  "learningObjective": "Explicar e demonstrar como parâmetros por valor copiam dados versus referência modifica originais.",
                                  "commonMistakes": "Confundir sintaxe de ponteiros (*p vs &var); dereferenciar ponteiros nulos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender Escopo de Variáveis",
                                  "subSteps": [
                                    "Declare variáveis locais dentro de funções e acesse-as apenas no escopo da função.",
                                    "Use variáveis globais e observe acessibilidade em múltiplas funções.",
                                    "Teste shadowing: declare variável local com mesmo nome que global.",
                                    "Analise static variables para persistência de valor entre chamadas.",
                                    "Compile e depure erros de escopo indefinido ou múltiplas declarações."
                                  ],
                                  "verification": "Implemente um programa com local, global e static vars, imprimindo valores em diferentes funções para confirmar escopos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador C, debugger (GDB), referência de escopo em C.",
                                  "tips": "Prefira escopo local para evitar side-effects; use static para contadores.",
                                  "learningObjective": "Identificar e gerenciar visibilidade e lifetime de variáveis em diferentes escopos.",
                                  "commonMistakes": "Acessar variável local fora do escopo; poluição global desnecessária."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Recursividade em Funções",
                                  "subSteps": [
                                    "Implemente fatorial recursivo e trace chamadas na pilha.",
                                    "Adicione condição base para evitar stack overflow.",
                                    "Compare com versão iterativa para medir eficiência.",
                                    "Crie função recursiva para Fibonacci e otimize com memoization básica.",
                                    "Teste com entradas grandes e observe limites de recursão."
                                  ],
                                  "verification": "Execute fatorial recursivo para n=5, trace manualmente a pilha e confirme resultado 120.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Compilador C, calculadora para verificação manual, vídeo sobre recursão.",
                                  "tips": "Sempre inclua caso base; visualize pilha com desenhos.",
                                  "learningObjective": "Implementar e debugar funções recursivas com condição de parada.",
                                  "commonMistakes": "Esquecer caso base levando a loop infinito; recursão profunda causando overflow."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Dominar Ponteiros em Subprogramas",
                                  "subSteps": [
                                    "Declare ponteiros e passe-os como parâmetros para swap de valores.",
                                    "Use ponteiros para arrays dinâmicos em funções.",
                                    "Implemente função que aloca memória via malloc e retorna ponteiro.",
                                    "Gerencie desalocação com free para evitar leaks.",
                                    "Teste dereferenciamento inválido para entender segmentation faults."
                                  ],
                                  "verification": "Crie função swap usando ponteiros que troque dois inteiros no main, confirmando troca.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "Compilador C com Valgrind para leaks, documentação de ponteiros em C.",
                                  "tips": "Desenhe setas para visualizar ponteiros; inicialize sempre com NULL.",
                                  "learningObjective": "Usar ponteiros para passagem por referência e manipulação de memória.",
                                  "commonMistakes": "Dangling pointers; não checar NULL antes de dereferenciar."
                                }
                              ],
                              "practicalExample": "Em C, crie um programa que use uma função recursiva 'fatorial' por referência (ponteiro para resultado), com variáveis locais e globais para contagem de chamadas. Exemplo: int main() { int res; fatorial(5, &res); printf(\"Fatorial: %d\\n\", res); } void fatorial(int n, int* res) { static int calls = 0; calls++; if(n<=1) {*res=1; return;} ... } Demonstra todos os conceitos integrados.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença entre pass by value e reference com exemplo.",
                                "Implementar função recursiva sem overflow para n=10.",
                                "Identificar escopo de todas variáveis em um código fornecido.",
                                "Criar swap usando ponteiros que funcione corretamente.",
                                "Debugar um código com ponteiro dangling e corrigi-lo.",
                                "Traçar pilha de recursão para Fibonacci(4)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de todos os conceitos (funções, params, escopo, recursão, ponteiros).",
                                "Códigos funcionais sem erros de compilação ou runtime.",
                                "Explicações claras de diferenças e implicações.",
                                "Uso correto de verificações de segurança (NULL checks, base cases).",
                                "Eficiência: evitar recursão desnecessária profunda.",
                                "Integração: exemplo prático combinando múltiplos conceitos.",
                                "Documentação de código com comentários explicativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recursão ligada a sequências recursivas como Fibonacci.",
                                "Lógica: Escopo e parâmetros semelhantes a escopo em provas matemáticas.",
                                "Física/Engenharia: Ponteiros para simulação de estruturas dinâmicas (ex: partículas).",
                                "Algoritmos: Subprogramação essencial para divide-and-conquer.",
                                "Inglês Técnico: Leitura de docs de linguagens procedimentais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, subprogramação permite código modular e reutilizável, como funções recursivas em parsing de árvores (compiladores), ponteiros em gerenciamento de memória de jogos (Unity subjacente em C), e pass by ref para eficiência em bancos de dados ou simulações científicas, reduzindo tempo de execução em 50-90% em grandes datasets."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.4",
                            "name": "Reconhecer tratamento de exceções",
                            "description": "Explicar mecanismos para tratamento de exceções e erros em tempo de execução em linguagens de programação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Exceções e Erros em Tempo de Execução",
                                  "subSteps": [
                                    "Defina exceções como eventos anormais que interrompem o fluxo normal de execução do programa.",
                                    "Diferencie erros de compilação (sintaxe) de erros em tempo de execução (runtime).",
                                    "Identifique exemplos comuns: divisão por zero, acesso a índice inválido em array, arquivo não encontrado.",
                                    "Explique por que tratar exceções é essencial para robustez do software.",
                                    "Compare exceções com retornos de erro tradicionais em linguagens procedimentais."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo exceções e liste 3 exemplos de runtime errors.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (ex: Python exceptions docs)",
                                    "Vídeo introdutório sobre erros de programação (5-10 min)"
                                  ],
                                  "tips": "Use analogias cotidianas, como 'tentar dirigir sem gasolina' para runtime errors.",
                                  "learningObjective": "Reconhecer exceções como interrupções controláveis no fluxo de programa.",
                                  "commonMistakes": [
                                    "Confundir exceções com bugs de lógica",
                                    "Ignorar que nem todo erro é exceção tratável"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Sintaxe Básica de Tratamento de Exceções (Try-Except)",
                                  "subSteps": [
                                    "Estude a estrutura try-except em linguagens como Python: try {código} except TipoExcecao: {tratamento}.",
                                    "Escreva um código simples que gera uma exceção (ex: divisão por zero) sem tratamento.",
                                    "Adicione try-except para capturar e imprimir uma mensagem personalizada.",
                                    "Teste o código executando e observe o comportamento com e sem tratamento.",
                                    "Adapte para linguagens procedurais como C (usando setjmp/longjmp ou errno)."
                                  ],
                                  "verification": "Execute um código com try-except e confirme que o programa continua rodando após exceção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou IDLE)",
                                    "Referência de sintaxe try-except da linguagem escolhida"
                                  ],
                                  "tips": "Sempre teste com input inválido para simular exceções reais.",
                                  "learningObjective": "Implementar estrutura básica para capturar e tratar exceções genéricas.",
                                  "commonMistakes": [
                                    "Esquecer indentação no bloco except",
                                    "Capturar exceções muito genéricas como Exception sem especificar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Tipos Específicos de Exceções e Tratamentos Diferenciados",
                                  "subSteps": [
                                    "Liste tipos comuns de exceções: ZeroDivisionError, IndexError, FileNotFoundError.",
                                    "Modifique o código para tratar exceções específicas com múltiplos except blocks.",
                                    "Inclua blocos else (executa se sem exceção) e finally (sempre executa, ex: fechar arquivos).",
                                    "Crie um programa que valida input do usuário e trata exceções de conversão (ValueError).",
                                    "Analise stack trace para identificar origem da exceção."
                                  ],
                                  "verification": "Crie e execute código que trata 3 tipos diferentes de exceções corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de exceções built-in da linguagem",
                                    "Debugger integrado no IDE"
                                  ],
                                  "tips": "Use 'except Exception as e: print(e)' para inspecionar detalhes da exceção.",
                                  "learningObjective": "Diferenciar e tratar exceções específicas para respostas precisas.",
                                  "commonMistakes": [
                                    "Não usar finally para limpar recursos",
                                    "Tratar todas exceções da mesma forma"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Tratamento de Exceções em Programas Completos e Boas Práticas",
                                  "subSteps": [
                                    "Integre tratamento de exceções em um programa maior, como calculadora ou leitor de arquivos.",
                                    "Implemente logging de exceções em vez de só imprimir.",
                                    "Evite exceções desnecessárias com validações prévias (ex: if denominator != 0).",
                                    "Teste cenários edge cases: inputs vazios, arquivos corrompidos.",
                                    "Refatore código para hierarquia de exceções personalizadas se aplicável."
                                  ],
                                  "verification": "Desenvolva um programa funcional que não crasha em nenhum erro runtime testado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de código open-source com exception handling",
                                    "Ferramenta de teste unitário básica"
                                  ],
                                  "tips": "Princípio: 'É melhor prevenir do que remediar', mas sempre tenha fallback.",
                                  "learningObjective": "Incorporar tratamento de exceções como prática padrão em desenvolvimento.",
                                  "commonMistakes": [
                                    "Suprimir exceções silenciosamente sem log",
                                    "Exagerar validações e complicar código"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma função calculadora em Python que realiza operações (+, -, *, /). Use try-except para tratar ZeroDivisionError (divisão por zero), ValueError (operação inválida) e TypeError (tipos incompatíveis). Inclua finally para logar o resultado final. Exemplo: def calculadora(a, b, op): try: ... except ZeroDivisionError: print('Erro: Divisão por zero!') finally: print('Cálculo concluído.'). Teste com 10/0, 'a'+2, etc.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito a diferença entre try, except, else e finally.",
                                "Identificar e corrigir 5 linhas de código com exceções não tratadas.",
                                "Executar programa com 10 cenários de erro e confirmar tratamento correto.",
                                "Listar 3 vantagens de tratar exceções vs. deixar programa crashar.",
                                "Criar diagrama de fluxo mostrando desvio por exceção.",
                                "Comparar implementação em Python vs. C (errno/checks)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos de exceções (90%+ acerto).",
                                "Código funcional sem crashes em testes runtime (100% uptime).",
                                "Explicações claras e concisas dos mecanismos (sem jargões desnecessários).",
                                "Uso adequado de blocos else/finally em exemplos.",
                                "Incorporação de boas práticas como logging e validação prévia.",
                                "Criatividade em exemplos práticos e edge cases."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tratamento de operações indefinidas como divisão por zero.",
                                "Lógica e Algoritmos: Fluxo de controle alternativo via exceções.",
                                "Engenharia de Software: Princípios de robustez e resiliência de sistemas.",
                                "Depuração e Testes: Análise de stack traces como debugging.",
                                "Design de UX: Mensagens de erro amigáveis para usuários finais."
                              ],
                              "realWorldApplication": "Em sistemas bancários, tratamento de exceções previne perda de transações durante falhas de rede ou inputs inválidos, garantindo continuidade e auditoria via logs; em apps mobile, evita crashes por bateria baixa ou GPS indisponível, melhorando experiência do usuário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Compilador",
                    "description": "Função do compilador na conversão de código-fonte em código máquina.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Código-Fonte",
                        "description": "Código escrito por programadores em linguagens de programação de alto nível, como C++ ou Python, que é legível por humanos e expressa a lógica do algoritmo de forma estruturada.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Identificar código-fonte",
                            "description": "Reconhecer exemplos de código-fonte em linguagens procedimentais, diferenciando-o de código máquina ou binário, com base em comandos como atribuição, entrada/saída e condicionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de código-fonte",
                                  "subSteps": [
                                    "Ler a definição de código-fonte como texto legível escrito em linguagens de programação de alto nível",
                                    "Estudar exemplos de linguagens procedimentais como C, Pascal ou BASIC",
                                    "Identificar que o código-fonte é interpretado por humanos e processado por compiladores",
                                    "Comparar brevemente com níveis mais baixos de abstração",
                                    "Anotar as principais características em um caderno"
                                  ],
                                  "verification": "Escrever um resumo de 3-5 frases definindo código-fonte e suas linguagens associadas",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Texto introdutório sobre linguagens de programação",
                                    "Exemplos impressos ou digitais de código em C/Pascal"
                                  ],
                                  "tips": "Use analogias como 'receita de bolo' para código-fonte vs. 'bolo pronto' para executável",
                                  "learningObjective": "Definir código-fonte e distinguir seu nível de abstração de outros códigos",
                                  "commonMistakes": [
                                    "Confundir código-fonte com o programa executável final",
                                    "Ignorar que é legível por humanos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer elementos característicos do código-fonte procedimental",
                                  "subSteps": [
                                    "Identificar comandos de atribuição (ex: x = 5; ou LET x = 5)",
                                    "Localizar estruturas de entrada/saída (ex: printf(), input(), readln())",
                                    "Observar condicionais (ex: if-then-else, IF statement)",
                                    "Analisar loops simples (ex: while, for)",
                                    "Destacar palavras-chave legíveis como variáveis e funções"
                                  ],
                                  "verification": "Listar 5 elementos encontrados em um exemplo fornecido de código-fonte",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Snippets de código em linguagens procedimentais",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Procure por texto em inglês ou palavras legíveis, não por números aleatórios",
                                  "learningObjective": "Identificar comandos típicos que marcam código-fonte procedimental",
                                  "commonMistakes": [
                                    "Confundir variáveis com números binários",
                                    "Não notar a sintaxe legível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar código-fonte de código máquina e binário",
                                  "subSteps": [
                                    "Estudar código máquina: sequências de instruções em assembly (ex: MOV AX, 5)",
                                    "Analisar código binário: strings de 0s e 1s (ex: 10110000 01100001)",
                                    "Comparar visualmente: legibilidade humana vs. máquina",
                                    "Criar uma tabela de diferenças (legibilidade, abstração, exemplos)",
                                    "Testar identificação em pares de exemplos misturados"
                                  ],
                                  "verification": "Classificar corretamente 3 pares de códigos como fonte/máquina/binário com justificativa",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de assembly e binário",
                                    "Tabela comparativa em branco"
                                  ],
                                  "tips": "Código-fonte tem palavras como 'if' ou 'print'; binário só tem 0/1",
                                  "learningObjective": "Distinguir código-fonte de formas de código de baixo nível",
                                  "commonMistakes": [
                                    "Achar assembly como fonte por ser 'texto'",
                                    "Ignorar ausência de comandos legíveis no binário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar a identificação em exemplos reais",
                                  "subSteps": [
                                    "Analisar 5-7 snippets variados (fonte, máquina, binário)",
                                    "Explicar por que cada um é ou não código-fonte",
                                    "Criar um fluxograma de decisão para identificação",
                                    "Autoavaliar acertos e revisar erros",
                                    "Discutir com um par ou tutor um exemplo desafiador"
                                  ],
                                  "verification": "Acertar 90% em um quiz de 10 itens misturados",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Quiz com 10 exemplos anonimizados",
                                    "Fluxograma em papel ou digital"
                                  ],
                                  "tips": "Sempre pergunte: 'É legível e editável por programadores?'",
                                  "learningObjective": "Aplicar critérios de identificação de forma autônoma",
                                  "commonMistakes": [
                                    "Ser influenciado por extensão de arquivo",
                                    "Não verificar todos os comandos"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo de código-fonte em C (procedimental):\n#include <stdio.h>\nint main() {\n    int x = 10;\n    if (x > 5) {\n        printf(\"Maior que 5\");\n    }\n    return 0;\n}\n\nCompare com código binário: 01001000 01101001 01101110 01100011 01101000 01101001\n\nO primeiro é fonte (atribuição, if, printf); o segundo é binário ilegível.",
                              "finalVerifications": [
                                "Classificar corretamente 9/10 exemplos misturados",
                                "Explicar diferenças com base em comandos legíveis",
                                "Criar tabela comparativa precisa",
                                "Identificar em código real sem dicas",
                                "Autoavaliar erros comuns evitados",
                                "Discutir aplicação em compiladores"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação (90%+ acertos)",
                                "Justificativas baseadas em comandos específicos",
                                "Uso correto de termos (atribuição, condicionais)",
                                "Diferenciação clara de níveis de abstração",
                                "Criatividade em fluxogramas ou tabelas",
                                "Tempo de resposta eficiente"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em condicionais",
                                "Língua Portuguesa: Análise sintática de estruturas textuais",
                                "Física: Analogia com níveis de energia/abstração em sistemas",
                                "História da Computação: Evolução de linguagens"
                              ],
                              "realWorldApplication": "Desenvolvedores de software identificam código-fonte diariamente para revisar, depurar e colaborar em projetos open-source, como no GitHub, evitando confusões com binários em análises de segurança ou reverse engineering."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Explicar características do código-fonte",
                            "description": "Descrever as propriedades do código-fonte, incluindo sua legibilidade humana, uso de tipos escalares/estruturados e estruturas como loops e condicionais, relacionando com lógica de programação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de código-fonte e sua legibilidade humana",
                                  "subSteps": [
                                    "Definir código-fonte como texto escrito em linguagem de programação legível por humanos, destinado a ser processado por compiladores ou interpretadores.",
                                    "Explicar a importância da legibilidade: uso de indentação, espaçamento, nomes de variáveis descritivos e comentários.",
                                    "Analisar exemplos simples de código legível versus ilegível, destacando diferenças.",
                                    "Discutir como a legibilidade facilita a depuração, manutenção e colaboração em equipes.",
                                    "Relacionar legibilidade com princípios de boas práticas de programação, como PEP8 para Python."
                                  ],
                                  "verification": "Escrever uma definição de código-fonte e reescrever um trecho de código ilegível para torná-lo legível, justificando as mudanças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código-fonte em Python ou JavaScript (legível e ilegível)",
                                    "Guia de estilo PEP8 ou similar"
                                  ],
                                  "tips": "Use nomes de variáveis que descrevam o propósito, como 'total_soma' em vez de 'x'.",
                                  "learningObjective": "Entender o que é código-fonte e dominar fatores que garantem sua legibilidade humana.",
                                  "commonMistakes": [
                                    "Confundir código-fonte com código executável/binário.",
                                    "Subestimar o papel de comentários e indentação.",
                                    "Usar abreviações obscuras em nomes de variáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e descrever tipos escalares e estruturados no código-fonte",
                                  "subSteps": [
                                    "Definir tipos escalares: inteiros (int), ponto flutuante (float), strings e booleanos (bool), com exemplos de declaração.",
                                    "Explicar tipos estruturados: arrays/listas, dicionários/objetos, structs/classes, e suas diferenças em relação aos escalares.",
                                    "Analisar como tipos são declarados e usados em trechos de código, identificando inferência de tipos em linguagens dinâmicas.",
                                    "Discutir impacto na legibilidade: tipagem explícita versus implícita e documentação de tipos.",
                                    "Comparar uso em linguagens como Python (dinâmica) e C (estática)."
                                  ],
                                  "verification": "Classificar todos os tipos de dados em um trecho de código fornecido e explicar seu propósito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Trechos de código com tipos mistos em Python e C",
                                    "Tabela de tipos de dados comuns"
                                  ],
                                  "tips": "Sempre anote o tipo esperado em comentários quando não for explícito para melhorar legibilidade.",
                                  "learningObjective": "Diferenciar e exemplificar tipos escalares e estruturados, relacionando-os à estrutura do código-fonte.",
                                  "commonMistakes": [
                                    "Confundir escalares com primitivos sem contexto.",
                                    "Ignorar tipos estruturados como arrays em análises superficiais.",
                                    "Não considerar o contexto da linguagem ao classificar tipos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar estruturas de controle como loops e condicionais",
                                  "subSteps": [
                                    "Descrever condicionais (if/else, switch): como controlam fluxo baseado em condições booleanas.",
                                    "Explicar loops (for, while, do-while): iteração sobre dados ou condições repetitivas.",
                                    "Identificar sintaxe e exemplos em código-fonte, destacando blocos e indentação.",
                                    "Analisar aninhamento de estruturas e seu impacto na legibilidade do código.",
                                    "Discutir otimizações comuns, como break/continue, e boas práticas para evitar loops infinitos."
                                  ],
                                  "verification": "Anotar todas as estruturas de controle em um código exemplo e descrever seu fluxo de execução.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Códigos de exemplo com loops e condicionais em JavaScript ou Java",
                                    "Diagrama de fluxo de controle"
                                  ],
                                  "tips": "Desenhe fluxogramas para visualizar o fluxo antes de codificar estruturas complexas.",
                                  "learningObjective": "Reconhecer e descrever o papel de loops e condicionais na organização do código-fonte.",
                                  "commonMistakes": [
                                    "Confundir sintaxe de diferentes linguagens.",
                                    "Não explicar o fluxo lógico além da sintaxe.",
                                    "Esquecer condições de parada em loops."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar características do código-fonte com lógica de programação",
                                  "subSteps": [
                                    "Explicar lógica sequencial: execução linha a linha.",
                                    "Conectar condicionais à lógica de seleção e loops à iteração.",
                                    "Integrar tipos de dados à lógica: operações em escalares e manipulação em estruturas.",
                                    "Analisar como legibilidade reflete clareza lógica, usando decomposição em funções.",
                                    "Sintetizar: como o código-fonte implementa algoritmos lógicos de forma humana-legível."
                                  ],
                                  "verification": "Explicar logicamente um algoritmo completo, mapeando características do código à sua lógica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Algoritmo simples como cálculo de fatorial ou busca linear",
                                    "Ferramenta de debug como VS Code"
                                  ],
                                  "tips": "Pense em 'o que o código faz?' antes de 'como é escrito?'.",
                                  "learningObjective": "Integrar legibilidade, tipos e estruturas à lógica geral de programação.",
                                  "commonMistakes": [
                                    "Focar só em sintaxe sem lógica subjacente.",
                                    "Não relacionar tipos à eficiência lógica.",
                                    "Ignorar exceções ou casos edge na lógica."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o código Python: def eh_par(numero: int) -> bool: if numero % 2 == 0: return True else: return False. Explique: legibilidade (nomes claros, tipagem), tipos (int, bool), estruturas (if/else condicional), e lógica (seleção baseada em resto da divisão). Reescreva para maior legibilidade adicionando comentários.",
                              "finalVerifications": [
                                "Define corretamente código-fonte e lista 3 fatores de legibilidade.",
                                "Classifica tipos escalares e estruturados em exemplos reais.",
                                "Identifica e descreve loops/condicionais com fluxos precisos.",
                                "Relaciona todas as características à lógica de programação.",
                                "Analisa um código completo com todas as propriedades.",
                                "Sugere melhorias de legibilidade em código dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição de cada característica.",
                                "Uso de exemplos concretos e relevantes do código-fonte.",
                                "Clareza e organização na explicação (linguagem acessível).",
                                "Correta relação entre elementos (tipos, estruturas, lógica).",
                                "Identificação de boas práticas e erros comuns.",
                                "Capacidade de análise crítica e sugestões de melhoria."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em condicionais e operações aritméticas em tipos escalares.",
                                "Língua Portuguesa: Redação clara e estrutura textual para legibilidade do código.",
                                "Física/Engenharia: Modelagem de processos sequenciais e iterativos como fluxos reais.",
                                "Artes: Design visual aplicado à indentação e formatação de código.",
                                "Filosofia: Lógica dedutiva e indutiva na programação."
                              ],
                              "realWorldApplication": "Em equipes de software, explicar características do código-fonte é essencial para code reviews, refatoração, documentação técnica e treinamento de juniors, reduzindo erros em projetos como apps web ou sistemas empresariais."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Relacionar código-fonte com programa",
                            "description": "Explicar como o código-fonte representa um programa computacional, implementando algoritmos através de comandos procedimentais e subprogramação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Código-Fonte",
                                  "subSteps": [
                                    "Defina código-fonte como texto escrito em linguagem de programação legível por humanos.",
                                    "Identifique componentes básicos: variáveis, comandos procedimentais (sequenciais, condicionais, repetitivos).",
                                    "Explique que o código-fonte descreve algoritmos de forma textual.",
                                    "Distinga código-fonte de pseudocódigo.",
                                    "Examine um exemplo simples de código-fonte em uma linguagem como Python."
                                  ],
                                  "verification": "Escreva uma definição clara do código-fonte e identifique seus componentes em um snippet fornecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE simples (ex: VS Code)",
                                    "Exemplos de código-fonte básicos em PDF ou online"
                                  ],
                                  "tips": "Sempre leia o código linha por linha para entender a intenção do programador.",
                                  "learningObjective": "Dominar a definição e estrutura fundamental do código-fonte.",
                                  "commonMistakes": [
                                    "Confundir código-fonte com o executável final",
                                    "Ignorar comentários no código"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Programa Computacional Executável",
                                  "subSteps": [
                                    "Defina programa como instruções em linguagem de máquina executáveis pela CPU.",
                                    "Explique que o programa resulta da tradução do código-fonte.",
                                    "Descreva diferenças: código-fonte (humano) vs. programa (máquina).",
                                    "Discuta formatos como .exe ou binários.",
                                    "Visualize o fluxo: fonte → compilado/interpretação → execução."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando código-fonte virando programa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Vídeo curto sobre compiladores (ex: YouTube)"
                                  ],
                                  "tips": "Pense no programa como a 'versão traduzida' que o computador entende diretamente.",
                                  "learningObjective": "Diferenciar código-fonte de programa executável e seu propósito.",
                                  "commonMistakes": [
                                    "Achar que código-fonte é diretamente executável",
                                    "Confundir interpretação com compilação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Processo de Transformação (Compilação/Interpretação)",
                                  "subSteps": [
                                    "Descreva compiladores: traduzem todo código-fonte para binário de uma vez.",
                                    "Descreva interpretadores: executam linha por linha.",
                                    "Relacione com o contexto: como o compilador gera o programa a partir do fonte.",
                                    "Simule o processo com um exemplo: escreva código e 'compile' mentalmente.",
                                    "Identifique erros comuns no processo (sintaxe, semântica)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os passos de compilação de um código simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador online (ex: Replit, Python IDLE)",
                                    "Exemplos de código com erros intencionais"
                                  ],
                                  "tips": "Use ferramentas online para ver erros de compilação em tempo real.",
                                  "learningObjective": "Compreender como código-fonte se torna programa via ferramentas de tradução.",
                                  "commonMistakes": [
                                    "Ignorar diferenças entre compilado e interpretado",
                                    "Não testar código com erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implementação de Algoritmos via Comandos e Subprogramação",
                                  "subSteps": [
                                    "Identifique comandos procedimentais: sequenciais, if-else, loops.",
                                    "Explique subprogramação: funções, procedimentos, módulos.",
                                    "Relacione ao algoritmo: como o código-fonte implementa passos lógicos.",
                                    "Trace um algoritmo completo: entrada → processamento → saída.",
                                    "Compare código-fonte com o comportamento do programa executado."
                                  ],
                                  "verification": "Analise um código-fonte fornecido, trace sua execução e descreva o programa resultante.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código-fonte exemplo com algoritmo (ex: cálculo de fatorial)",
                                    "Debugger simples ou print statements"
                                  ],
                                  "tips": "Use 'dry-run' (execução mental) para mapear código ao programa.",
                                  "learningObjective": "Relacionar estruturas do código-fonte aos algoritmos executados no programa.",
                                  "commonMistakes": [
                                    "Não mapear subprogramas corretamente",
                                    "Perder o fluxo lógico do algoritmo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código-fonte em Python: def somar(a, b): return a + b; resultado = somar(3, 5); print(resultado). Esse fonte implementa um algoritmo de soma via subprograma (função somar) e comandos procedimentais (chamada e print). Ao compilar/executar, vira um programa que exibe '8' na tela.",
                              "finalVerifications": [
                                "Explica corretamente a relação código-fonte → programa.",
                                "Identifica comandos procedimentais e subprogramas em um código dado.",
                                "Descreve o processo de compilação/interpretação.",
                                "Traça execução de um algoritmo simples do fonte ao output.",
                                "Diferencia fonte legível por humanos de binário da máquina.",
                                "Simula erros comuns e suas correções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de conceitos (código-fonte vs. programa).",
                                "Completude na descrição do processo de transformação.",
                                "Profundidade na análise de algoritmos e subprogramação.",
                                "Clareza em diagramas ou traces de execução.",
                                "Capacidade de identificar e evitar erros comuns.",
                                "Relevância das conexões com exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos e lógica sequencial/condicional.",
                                "Língua Portuguesa: Leitura e interpretação de textos técnicos (código).",
                                "Física: Analogia com máquinas e instruções executáveis.",
                                "Artes: Fluxogramas e visualização de processos."
                              ],
                              "realWorldApplication": "Desenvolvedores leem código-fonte de colegas para debugar ou estender programas reais, como apps de banco ou jogos, garantindo que algoritmos sejam corretamente implementados antes da execução em produção."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Código Máquina",
                        "description": "Representação do programa em linguagem de máquina, composta por instruções binárias ou em assembly, diretamente executáveis pelo hardware do processador.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Descrever o formato do código máquina",
                            "description": "Explicar que o código máquina é específico da arquitetura do processador, utilizando instruções em binário (0s e 1s) que controlam operações como carga, soma e saltos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos do Código Máquina",
                                  "subSteps": [
                                    "Defina código máquina como instruções em binário (0s e 1s) específicas da arquitetura do processador.",
                                    "Diferencie código máquina de assembly (mnemônicos) e linguagens de alto nível.",
                                    "Identifique operações comuns: carga (load), soma (add), saltos (jump).",
                                    "Explique que o formato varia por processador (ex: x86, ARM, MIPS).",
                                    "Estude um diagrama genérico de instrução: opcode + operandos."
                                  ],
                                  "verification": "Escreva uma definição de 3 frases e liste 3 operações comuns com exemplos binários simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Vídeo introdutório sobre código máquina (YouTube), diagrama de instrução binária.",
                                  "tips": "Comece com exemplos visuais de binário para fixar a representação.",
                                  "learningObjective": "Entender a essência binária e arquitetura-dependente do código máquina.",
                                  "commonMistakes": "Confundir código máquina com código assembly humano-legível."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Estrutura Geral de uma Instrução de Máquina",
                                  "subSteps": [
                                    "Descreva os componentes principais: opcode (identifica operação), operandos (registradores, imediatos, endereços).",
                                    "Aprenda formatos comuns: R-type (registrador), I-type (imediato), J-type (salto).",
                                    "Estude o tamanho fixo ou variável das instruções (ex: 32 bits em MIPS).",
                                    "Divida uma instrução em campos: bits para opcode, rs, rt, rd, etc.",
                                    "Pratique convertendo decimal para binário para operandos."
                                  ],
                                  "verification": "Desenhe o layout de uma instrução de 32 bits e rotule os campos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação MIPS simplificada (PDF), conversor binário online.",
                                  "tips": "Use tabelas de opcodes para associar binário a operações.",
                                  "learningObjective": "Dominar a divisão de bits em componentes funcionais.",
                                  "commonMistakes": "Ignorar alinhamento de bits ou confundir operandos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Exemplos Detalhados de Formato",
                                  "subSteps": [
                                    "Analise instrução ADD em MIPS: 000000 ssstttrrdd dsssss fffff (opcode=0, funct=100000).",
                                    "Decodifique binário exemplo: 000000 00010 00011 00001 00000 100000 (add $1,$2,$3).",
                                    "Descreva cada campo: opcode (6 bits), rs/rt/rd (5 bits cada), shamt (5 bits), funct (6 bits).",
                                    "Compare com LOAD: formato I-type (opcode 100011, rs 5bits, rt 5bits, address 16bits).",
                                    "Registre variações por arquitetura (ex: x86 variável)."
                                  ],
                                  "verification": "Decodifique 2 instruções binárias e descreva seu formato verbalmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador MIPS online (ex: MARS), tabela de opcodes MIPS.",
                                  "tips": "Copie binários em papel e divida com régua para visualizar campos.",
                                  "learningObjective": "Aplicar conhecimento para descrever formatos reais.",
                                  "commonMistakes": "Erros na contagem de bits ou atribuição errada de campos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Descrição Completa e Verificação",
                                  "subSteps": [
                                    "Escreva uma descrição textual completa de uma instrução: 'O formato consiste em...'.",
                                    "Crie um diagrama anotado de 3 instruções diferentes.",
                                    "Explique controle de hardware: como opcode ativa ALUs, registradores.",
                                    "Teste com salto: J-type (opcode 000010, address 26 bits).",
                                    "Resuma diferenças entre arquiteturas CISC (x86) e RISC (ARM)."
                                  ],
                                  "verification": "Produza um relatório de 1 página descrevendo 3 formatos com diagramas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de desenho (Draw.io), exemplos de código máquina de processadores reais.",
                                  "tips": "Use cores para diferenciar campos no diagrama.",
                                  "learningObjective": "Sintetizar e comunicar o formato de forma clara e precisa.",
                                  "commonMistakes": "Descrições vagas sem referência a bits específicos."
                                }
                              ],
                              "practicalExample": "Considere a instrução MIPS 'add $8, $9, $10' em binário: 000000 01001 01010 01000 00000 100000. Descreva: Opcode (bits 31-26: 000000 indica R-type), rs (bits 25-21: 01001 = $9), rt (bits 20-16: 01010 = $10), rd (bits 15-11: 01000 = $8), shamt (bits 10-6: 00000), funct (bits 5-0: 100000 = add). Essa estrutura controla soma de registradores.",
                              "finalVerifications": [
                                "Pode decodificar uma instrução binária aleatória corretamente.",
                                "Explica a função de cada campo em uma instrução tipo R, I e J.",
                                "Lista 3 diferenças entre formatos de x86 e MIPS.",
                                "Desenha diagrama preciso de instrução sem erros de bits.",
                                "Descreve verbalmente o fluxo de execução de uma instrução soma."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de campos e bits (90% correto).",
                                "Completude da descrição (todos componentes cobertos).",
                                "Clareza e uso de exemplos concretos na explicação.",
                                "Correção de erros comuns como contagem de bits.",
                                "Capacidade de comparar formatos entre arquiteturas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão binário-decimal e operações lógicas.",
                                "Física: Representação em circuitos lógicos e portas.",
                                "Engenharia: Design de processadores e otimização de instruções.",
                                "Programação: Geração de código máquina por compiladores."
                              ],
                              "realWorldApplication": "Em desenvolvimento de compiladores, depuração de firmware embarcado ou engenharia reversa de malware, onde descrever formatos de código máquina permite otimizar software para hardware específico, como em smartphones ARM ou servidores x86."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Diferenciar código máquina de código-fonte",
                            "description": "Comparar código máquina (não legível por humanos, dependente do hardware) com código-fonte (abstrato e portátil), destacando a necessidade de tradução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Código-Fonte",
                                  "subSteps": [
                                    "Defina código-fonte como texto escrito em linguagens de programação de alto nível, legível por humanos.",
                                    "Identifique exemplos comuns como Python, Java ou C++.",
                                    "Liste características principais: abstrato, portátil (independente de hardware específico), usa sintaxe legível.",
                                    "Escreva um exemplo simples de código-fonte, como 'print(\"Hello World\")' em Python.",
                                    "Explique como o código-fonte é editado em editores de texto ou IDEs."
                                  ],
                                  "verification": "Escreva uma definição precisa e um exemplo de código-fonte, explicando por que é portátil.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE como VS Code",
                                    "Documentação de linguagens como Python.org"
                                  ],
                                  "tips": [
                                    "Use analogia: código-fonte é como uma receita em linguagem humana, fácil de ler e adaptar."
                                  ],
                                  "learningObjective": "Compreender código-fonte como representação abstrata e legível de instruções.",
                                  "commonMistakes": [
                                    "Confundir com código compilado",
                                    "Achar que código-fonte roda diretamente no hardware"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Conceito de Código Máquina",
                                  "subSteps": [
                                    "Defina código máquina como instruções binárias (0s e 1s) ou assembly legível por máquina, específicas do hardware.",
                                    "Identifique formatos: binário puro, hexadecimal ou assembly (ex: MOV AX, 1).",
                                    "Liste características: não legível por humanos sem ferramentas, dependente da arquitetura (x86, ARM), executado diretamente pela CPU.",
                                    "Pesquise um exemplo de código máquina para 'Hello World' em assembly.",
                                    "Explique por que requer decodificação para humanos entenderem."
                                  ],
                                  "verification": "Descreva código máquina com exemplo e justifique sua dependência de hardware.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de assembly viewer como Godbolt.org",
                                    "Documentação de arquitetura x86"
                                  ],
                                  "tips": [
                                    "Pense no código máquina como 'idioma nativo' da CPU, como Morse para máquinas."
                                  ],
                                  "learningObjective": "Reconhecer código máquina como forma de baixo nível, hardware-específica.",
                                  "commonMistakes": [
                                    "Achar que código máquina é universal",
                                    "Confundir assembly com código-fonte high-level"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Código-Fonte e Código Máquina",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: legibilidade, portabilidade, nível de abstração, execução.",
                                    "Analise diferenças chave: código-fonte precisa de tradução; código máquina é direto.",
                                    "Discuta vantagens/desvantagens: código-fonte facilita desenvolvimento; máquina é eficiente.",
                                    "Converta um código-fonte simples para visualização de máquina usando compilador online.",
                                    "Identifique por que tradução (compilação) é necessária."
                                  ],
                                  "verification": "Preencha tabela comparativa e explique 3 diferenças principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador online como Compiler Explorer (godbolt.org)",
                                    "Planilha ou papel para tabela"
                                  ],
                                  "tips": [
                                    "Compare com tradução de idiomas: código-fonte é inglês, máquina é binário local."
                                  ],
                                  "learningObjective": "Diferenciar claramente as propriedades e usos de cada tipo de código.",
                                  "commonMistakes": [
                                    "Ignorar portabilidade do código-fonte",
                                    "Subestimar complexidade do código máquina"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o Processo de Tradução",
                                  "subSteps": [
                                    "Descreva o papel do compilador: traduz código-fonte para código máquina.",
                                    "Trace o fluxo: código-fonte → pré-processamento → compilação → link → executável.",
                                    "Execute um exemplo: compile 'Hello World' em C e visualize saída em assembly.",
                                    "Discuta interpretadores vs compiladores para reforçar diferenças.",
                                    "Reflita sobre implicações para desenvolvedores (abstração permite foco em lógica)."
                                  ],
                                  "verification": "Desenhe diagrama do processo de compilação e compile um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GCC ou clang instalado",
                                    "Online compiler como replit.com"
                                  ],
                                  "tips": [
                                    "Use flags como -S no GCC para gerar assembly e ver a tradução."
                                  ],
                                  "learningObjective": "Entender a necessidade e mecanismo de tradução entre os dois códigos.",
                                  "commonMistakes": [
                                    "Confundir compilador com interpretador",
                                    "Achar que todo código-fonte vira binário idêntico"
                                  ]
                                }
                              ],
                              "practicalExample": "Pegue o código-fonte Python: print('Hello, World!'). Compile um equivalente C para assembly via godbolt.org e compare: fonte é legível e portátil; assembly é opaco e x86-específico, mostrando tradução necessária.",
                              "finalVerifications": [
                                "Explique em 1 frase a diferença principal entre código-fonte e máquina.",
                                "Identifique 3 características únicas de cada um.",
                                "Descreva o que acontece sem compilador.",
                                "Diferencie portabilidade com exemplo de hardware diferente.",
                                "Traduza mentalmente um print simples para instruções máquina básicas.",
                                "Justifique por que programadores usam high-level."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de cada tipo (80% correto).",
                                "Compreensão clara de diferenças chave (portabilidade, legibilidade).",
                                "Capacidade de traçar processo de compilação.",
                                "Uso correto de analogias ou tabelas comparativas.",
                                "Identificação de erros comuns evitados.",
                                "Aplicação em exemplo prático compilado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação binária e lógica booleana.",
                                "Linguística: Analogia de tradução entre linguagens humanas e máquina.",
                                "Engenharia: Dependência de arquitetura de hardware.",
                                "História da Computação: Evolução de assembly para high-level.",
                                "Física: Operações lógicas na CPU como circuitos."
                              ],
                              "realWorldApplication": "Desenvolvedores usam código-fonte para criar apps portáteis (ex: apps mobile rodam em Android/iOS via compilação); engenheiros de sistemas otimizam código máquina para performance em embedded systems como carros autônomos."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Exemplificar execução de código máquina",
                            "description": "Ilustrar como o processador interpreta e executa instruções de código máquina diretamente, sem necessidade de tradução adicional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e compreender um exemplo simples de código máquina",
                                  "subSteps": [
                                    "Escolha uma arquitetura simples, como MIPS ou uma CPU hipotética de 8 bits.",
                                    "Defina um programa básico: carregar valor 5 no registrador R1, valor 3 no R2 e somar em R3.",
                                    "Traduza para código máquina: ex. 0x10000005 (LOAD R1,5), 0x20000003 (LOAD R2,3), 0x00211820 (ADD R3,R1,R2).",
                                    "Identifique opcode, registradores e operandos usando tabela de instruções.",
                                    "Anote o estado inicial da memória e registradores (todos zerados exceto PC=0)."
                                  ],
                                  "verification": "Lista completa das instruções em hex/bin com decodificação e estados iniciais documentados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de instruções MIPS ou x86 simplificada",
                                    "Papel e caneta ou editor de texto",
                                    "Simulador online como MARS para MIPS (opcional)"
                                  ],
                                  "tips": "Use uma arquitetura RISC simples para evitar complexidade; comece com 3 instruções no máximo.",
                                  "learningObjective": "Identificar e decodificar componentes de instruções máquina (opcode, registradores, imediatos).",
                                  "commonMistakes": [
                                    "Confundir código assembly com máquina",
                                    "Ignorar o Program Counter (PC) inicial",
                                    "Esquecer de alinhar endereços de memória"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o ambiente de simulação do processador",
                                  "subSteps": [
                                    "Desenhe uma tabela com colunas: PC, Instrução (hex), Registradores (R1,R2,R3), Memória, Flags.",
                                    "Inicialize: PC=0, todos registradores=0, memória com dados se necessário.",
                                    "Explique o ciclo básico: Fetch (buscar), Decode (decodificar), Execute (executar).",
                                    "Prepare diagramas de fluxo para cada fase do ciclo de instrução.",
                                    "Teste configuração executando um ciclo manual vazio para validar."
                                  ],
                                  "verification": "Tabela de estados iniciais criada e ciclo básico descrito em diagrama.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabela de estados",
                                    "Ferramentas de desenho como Draw.io ou papel",
                                    "Documentação de ciclo de instrução Harvard/von Neumann"
                                  ],
                                  "tips": "Mantenha a simulação em papel primeiro para compreensão intuitiva antes de ferramentas digitais.",
                                  "learningObjective": "Configurar estados iniciais do processador e preparar para simulação passo a passo.",
                                  "commonMistakes": [
                                    "Não inicializar PC corretamente",
                                    "Confundir registradores com memória",
                                    "Omitir flags de status como Zero/Overflow"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular a execução passo a passo do código máquina",
                                  "subSteps": [
                                    "Fetch: PC <- memória[PC], PC += 4 (palavra de 32 bits).",
                                    "Decode: Analise opcode para LOAD R1,5 -> R1=5.",
                                    "Execute: Atualize registradores/memória, avance PC.",
                                    "Repita para LOAD R2,3 (R2=3) e ADD R3,R1,R2 (R3=8).",
                                    "Registre mudanças em cada ciclo em uma linha da tabela."
                                  ],
                                  "verification": "Tabela preenchida com todos os ciclos mostrando evolução dos registradores até R3=8.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de estados do step 2",
                                    "Calculadora para operações binárias/hex",
                                    "Simulador MIPS para validação opcional"
                                  ],
                                  "tips": "Anote o binário/hex em cada fetch para reforçar a interpretação direta pelo processador.",
                                  "learningObjective": "Executar o ciclo fetch-decode-execute manualmente para instruções sequenciais.",
                                  "commonMistakes": [
                                    "Incrementar PC errado (ex. +1 byte em vez de +4)",
                                    "Executar decode sem fetch prévio",
                                    "Não atualizar PC após execute"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e ilustrar o processo completo",
                                  "subSteps": [
                                    "Compare estado final: R3 deve conter 8 (0x00000008).",
                                    "Crie um fluxograma visual do fetch-decode-execute para todo o programa.",
                                    "Explique por que não há tradução: processador lê binário diretamente.",
                                    "Discuta variações: branches ou interrupções (sem implementar).",
                                    "Documente em um relatório curto com diagramas."
                                  ],
                                  "verification": "Fluxograma e relatório mostrando execução correta e resultado final validado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (Draw.io, Lucidchart)",
                                    "Relatório em Markdown ou Word"
                                  ],
                                  "tips": "Use cores no fluxograma: verde para fetch, amarelo decode, vermelho execute.",
                                  "learningObjective": "Visualizar e comunicar o fluxo de execução de código máquina de forma clara.",
                                  "commonMistakes": [
                                    "Parar sem validar resultado final",
                                    "Adicionar elementos de alto nível como compilador",
                                    "Ignorar o papel direto do hardware"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa soma simples em MIPS machine code: [0x20010005 (addi $1,$0,5), 0x20020003 (addi $2,$0,3), 00210820 (add $3,$1,$2)]. Execução: Após 3 ciclos, $3=8. Simule em tabela: Instrução 1: Fetch PC=0, Decode addi, Execute $1=5, PC=4; etc. Resultado final demonstra soma direta sem assembly intermediário.",
                              "finalVerifications": [
                                "Simula corretamente o ciclo fetch-decode-execute para 3 instruções.",
                                "Registradores finais correspondem ao esperado (ex. R3=8).",
                                "Explica ausência de tradução: binário é linguagem nativa do CPU.",
                                "Identifica opcode e operandos em pelo menos 80% das instruções.",
                                "Cria fluxograma reproduzível por outro aluno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação e execução (sem erros em registradores/PC).",
                                "Detalhe nos subpassos e verificações (cobertura completa de 3-5 substeps por step).",
                                "Clareza visual nos diagramas e tabelas (legível e lógico).",
                                "Compreensão conceitual: diferencia código máquina de assembly/compilado.",
                                "Criatividade na ilustração prática (exemplo realista e minimalista)."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica Digital: Ciclo de clock e portas lógicas no ALU.",
                                "Matemática: Operações binárias e aritmética modular.",
                                "Programação: Base para assembly e otimização low-level.",
                                "Física: Analogia com circuitos elétricos interpretando sinais binários."
                              ],
                              "realWorldApplication": "Em desenvolvimento de firmware para microcontroladores (ex. Arduino em assembly), reverse engineering de malwares, depuração de crashes em sistemas embarcados e otimização de performance em jogos ou IA onde ciclos de CPU são críticos."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Função e Processo do Compilador",
                        "description": "Software básico que converte código-fonte em linguagem de alto nível para código máquina executável, passando por fases como análise léxica, sintática, semântica e geração de código.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Definir o compilador",
                            "description": "Descrever o compilador como um tradutor automático de código-fonte para código máquina, essencial para a execução de programas em computadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender código-fonte e código máquina",
                                  "subSteps": [
                                    "Pesquise o conceito de código-fonte: texto escrito em linguagens de alto nível como C, Java ou Python.",
                                    "Defina código máquina: instruções binárias (0s e 1s) diretamente executáveis pelo processador do computador.",
                                    "Compare os dois: código-fonte é legível por humanos, código máquina é legível apenas pela máquina.",
                                    "Crie uma tabela comparativa com exemplos simples.",
                                    "Analise por que o computador não entende diretamente o código-fonte."
                                  ],
                                  "verification": "Escreva definições curtas e uma tabela comparativa em um documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet para vídeos introdutórios (ex: Khan Academy sobre linguagens de programação)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use a analogia de 'idioma humano vs. idioma da máquina' para facilitar a compreensão.",
                                  "learningObjective": "Diferenciar código-fonte de código máquina e entender a incompatibilidade natural entre eles.",
                                  "commonMistakes": "Confundir código-fonte com código assembly (que é intermediário, não máquina puro)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o compilador como tradutor automático",
                                  "subSteps": [
                                    "Defina compilador: software que traduz automaticamente código-fonte para código máquina.",
                                    "Identifique características: processa todo o código de uma vez, gera arquivo executável.",
                                    "Liste exemplos reais: GCC para C/C++, Javac para Java.",
                                    "Explique o termo 'automático': não requer intervenção humana no processo de tradução.",
                                    "Escreva uma definição completa em suas palavras."
                                  ],
                                  "verification": "Formule uma definição oral ou escrita que inclua 'tradutor automático de código-fonte para código máquina'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação oficial do GCC (gcc.gnu.org)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Pense no compilador como um 'Google Tradutor' para computadores, mas que produz um executável final.",
                                  "learningObjective": "Formular uma definição precisa do compilador enfatizando sua função de tradução automática.",
                                  "commonMistakes": "Chamar o compilador de 'interpretador', que executa código linha a linha sem gerar executável."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o processo básico de compilação",
                                  "subSteps": [
                                    "Descreva as fases principais: análise léxica (tokens), sintática (estrutura), semântica (significado) e geração de código.",
                                    "Simule o processo com um exemplo simples de código 'Hello World' em C.",
                                    "Execute um comando de compilação em um compilador online (ex: gcc -o programa programa.c).",
                                    "Observe a saída: arquivo executável gerado.",
                                    "Registre as diferenças entre fonte e executável."
                                  ],
                                  "verification": "Compile um programa simples e descreva as fases observadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador online como Replit ou Godbolt.org",
                                    "Código-fonte exemplo: #include <stdio.h> int main() { printf('Hello World'); return 0; }"
                                  ],
                                  "tips": "Use ferramentas online para evitar instalação; foque em observar o 'antes e depois'.",
                                  "learningObjective": "Descrever o fluxo de tradução do compilador de forma simplificada.",
                                  "commonMistakes": "Ignorar erros de compilação como parte essencial do processo de verificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer a essencialidade do compilador para execução de programas",
                                  "subSteps": [
                                    "Explique por que o compilador é essencial: computadores só executam código máquina.",
                                    "Discuta cenários sem compilador: programas não rodariam em hardware.",
                                    "Relacione com linguagens compiladas vs. interpretadas.",
                                    "Crie um fluxograma: código-fonte → compilador → código máquina → execução.",
                                    "Reflita sobre impacto em desenvolvimento de software."
                                  ],
                                  "verification": "Desenhe um fluxograma e explique verbalmente a essencialidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online como Draw.io",
                                    "Vídeo sobre ciclo de vida de um programa"
                                  ],
                                  "tips": "Enfatize que sem compilador, o código-fonte é 'inútil' para a máquina.",
                                  "learningObjective": "Justificar a indispensabilidade do compilador na execução de programas.",
                                  "commonMistakes": "Subestimar o papel, achando que 'qualquer software faz isso'."
                                }
                              ],
                              "practicalExample": "Usando o GCC, compile um programa C simples 'Hello World': digite o código-fonte, execute 'gcc hello.c -o hello', rode './hello' e observe a tradução automática para código máquina executável no terminal.",
                              "finalVerifications": [
                                "O aluno define compilador como tradutor de código-fonte para máquina.",
                                "Explica corretamente pelo menos 3 fases do processo de compilação.",
                                "Diferencia compilador de interpretador.",
                                "Cria um fluxograma preciso do processo.",
                                "Compila e executa um exemplo prático sem erros.",
                                "Justifica a essencialidade com argumentos lógicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da definição (80% exata): 4 pontos",
                                "Detalhe no processo de compilação (fases cobertas): 3 pontos",
                                "Exemplo prático demonstrado: 2 pontos",
                                "Diferenciação conceitual clara: 2 pontos",
                                "Fluxograma ou diagrama bem estruturado: 2 pontos",
                                "Justificativa da importância convincente: 2 pontos",
                                "Ausência de confusões comuns: 1 ponto"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e algoritmos na análise semântica.",
                                "Física: Funcionamento de processadores e execução de instruções binárias.",
                                "Linguagens: Analogia com gramática e tradução de idiomas naturais.",
                                "História da Computação: Evolução desde assemblers para compiladores modernos."
                              ],
                              "realWorldApplication": "Compiladores como GCC e Clang são usados diariamente por desenvolvedores para criar aplicativos, jogos, sistemas operacionais e até IA, permitindo que linguagens amigáveis como C++ sejam executadas em qualquer hardware, impulsionando indústrias de software global."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.1",
                              "10.1.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Explicar o processo de compilação",
                            "description": "Detalhar as etapas principais do compilador: análise léxica (tokens), sintática (estrutura), semântica (significado), otimização e geração de código objeto/máquina.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise Léxica (Tokenização)",
                                  "subSteps": [
                                    "Identificar o que são tokens: unidades mínimas de código como palavras-chave, identificadores, operadores e literais.",
                                    "Explicar como o lexer (scanner) lê o código fonte caractere por caractere e agrupa em tokens.",
                                    "Diferenciar tokens de elementos ignorados, como espaços em branco e comentários.",
                                    "Analisar um exemplo simples de código para listar seus tokens.",
                                    "Entender o papel dos autômatos finitos na implementação do lexer."
                                  ],
                                  "verification": "Listar corretamente todos os tokens de um trecho de código fonte fornecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de código fonte em C ou Java",
                                    "Diagrama de autômato finito para lexer",
                                    "Ferramenta online como JLex ou Flex demo"
                                  ],
                                  "tips": "Ignore whitespaces e comentários durante a tokenização para focar nos elementos significativos.",
                                  "learningObjective": "Compreender como o código fonte é dividido em tokens reconhecíveis pelo compilador.",
                                  "commonMistakes": "Confundir identificadores com palavras-chave ou tratar literais como operadores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise Sintática (Parsing)",
                                  "subSteps": [
                                    "Definir gramática formal e árvore de sintaxe abstrata (AST).",
                                    "Explicar como o parser verifica se os tokens seguem as regras gramaticais da linguagem.",
                                    "Diferenciar parsers descendente (top-down) e ascendente (bottom-up).",
                                    "Construir manualmente uma AST simples a partir de tokens.",
                                    "Identificar erros sintáticos comuns, como chaves desbalanceadas."
                                  ],
                                  "verification": "Construir uma AST correta para uma expressão aritmética simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de tokens do passo anterior",
                                    "Gramática BNF de uma linguagem simples",
                                    "Ferramenta como ANTLR ou yacc demo"
                                  ],
                                  "tips": "Use diagramas de árvore para visualizar a estrutura hierárquica da sintaxe.",
                                  "learningObjective": "Dominar a verificação da estrutura gramatical do código.",
                                  "commonMistakes": "Ignorar precedência de operadores ou confundir expressões com declarações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise Semântica",
                                  "subSteps": [
                                    "Explicar verificações de tipo, escopo de variáveis e declarações.",
                                    "Verificar compatibilidade de tipos e regras de sobrecarga.",
                                    "Analisar fluxo de controle e acessibilidade de símbolos.",
                                    "Anotar a AST com informações semânticas.",
                                    "Detectar erros semânticos como uso de variável não declarada."
                                  ],
                                  "verification": "Identificar e corrigir erros semânticos em um código com AST anotada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "AST do passo anterior",
                                    "Tabela de símbolos exemplo",
                                    "Compilador com flags de warning semântico"
                                  ],
                                  "tips": "Mantenha uma tabela de símbolos atualizada durante a análise para rastrear escopos.",
                                  "learningObjective": "Garantir que o código tenha significado válido além da sintaxe.",
                                  "commonMistakes": "Confundir verificação de tipo com inferência automática."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimização de Código",
                                  "subSteps": [
                                    "Listar técnicas comuns: eliminação de código morto, propagação de constantes e loop unrolling.",
                                    "Explicar representações intermediadas como IR (Intermediate Representation).",
                                    "Aplicar otimizações em uma AST ou IR simples.",
                                    "Medir impacto de otimizações em performance.",
                                    "Diferenciar otimizações locais e globais."
                                  ],
                                  "verification": "Aplicar pelo menos duas otimizações em um código IR e comparar antes/depois.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código IR LLVM simples",
                                    "Ferramenta opt do LLVM",
                                    "Exemplos de before/after otimização"
                                  ],
                                  "tips": "Comece com otimizações locais para ganhos rápidos antes de globais complexas.",
                                  "learningObjective": "Melhorar eficiência do código gerado sem alterar seu comportamento.",
                                  "commonMistakes": "Aplicar otimizações que alteram o semântico do programa."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Geração de Código Objeto/Máquina",
                                  "subSteps": [
                                    "Descrever conversão de IR otimizado para assembly ou código máquina.",
                                    "Explicar alocação de registradores e gerenciamento de pilha.",
                                    "Discutir linkers e loaders para código objeto final.",
                                    "Gerar assembly a partir de uma AST/IR simples.",
                                    "Comparar código fonte, assembly e binário."
                                  ],
                                  "verification": "Gerar e explicar assembly equivalente a um programa simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador com -S flag (ex: gcc -S)",
                                    "Exemplo de assembly x86/ARM",
                                    "Ferramenta objdump"
                                  ],
                                  "tips": "Use flags de debug para mapear código fonte ao assembly gerado.",
                                  "learningObjective": "Compreender a tradução final para executável.",
                                  "commonMistakes": "Ignorar alinhamento de dados ou convenções de chamada de função."
                                }
                              ],
                              "practicalExample": "Compile o programa C simples 'int main() { int x = 5 + 3; return x; }'. Trace: lexer gera tokens (int, main, (, ), {, etc.); parser constrói AST; semântica verifica tipos; otimização propaga constante (x=8); gera assembly com MOV e RET.",
                              "finalVerifications": [
                                "Descrever as 5 fases principais com exemplos de entrada/saída.",
                                "Trace completo de um programa pequeno através de todas as fases.",
                                "Identificar erros em cada fase para um código inválido.",
                                "Explicar diferenças entre compilador e interpretador.",
                                "Listar ferramentas reais usadas em cada fase (ex: Flex, Bison, LLVM).",
                                "Comparar otimização em tempo de compilação vs JIT."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição de cada fase (80% cobertura).",
                                "Capacidade de traçar um exemplo prático end-to-end.",
                                "Correta identificação de erros em fases específicas.",
                                "Uso de terminologia técnica adequada (tokens, AST, IR).",
                                "Conexão clara entre fases e impacto no código final.",
                                "Criatividade em exemplos e analogias para clareza."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos finitos e gramáticas formais (Teoria da Computação).",
                                "Lógica: Verificação de tipos e análise semântica (Lógica Matemática).",
                                "Engenharia: Otimização e alocação de recursos (Engenharia de Sistemas).",
                                "Física: Analogia com processamento de sinais (Análise Léxica).",
                                "Linguística: Estruturas sintáticas em linguagens naturais vs programação."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, entender o processo permite debugar erros de compilação (ex: GCC warnings), otimizar performance em apps mobile/games (LLVM/Clang), e criar compiladores personalizados para DSLs em empresas como Google (TensorFlow) ou Microsoft (Roslyn para C#)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.2",
                              "10.1.1.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Relacionar compilador com linguagens de programação",
                            "description": "Explicar como compiladores habilitam o uso de linguagens procedimentais (ex.: C++), lidando com atribuições, condicionais, repetições e subprogramas para produzir executáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os elementos básicos das linguagens procedimentais",
                                  "subSteps": [
                                    "Identificar atribuições como x = 5, que armazenam valores em variáveis.",
                                    "Explicar condicionais (if-else) para decisões baseadas em condições lógicas.",
                                    "Descrever repetições (loops como for, while) para execução iterativa.",
                                    "Analisar subprogramas (funções) para modularidade e reutilização de código.",
                                    "Relacionar esses elementos à programação sequencial e estruturada."
                                  ],
                                  "verification": "Listar e exemplificar cada elemento com código C++ simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto, documentação de C++ básica.",
                                  "tips": "Use exemplos visuais como fluxogramas para representar o fluxo de controle.",
                                  "learningObjective": "Dominar os conceitos fundamentais que o compilador processará.",
                                  "commonMistakes": "Confundir linguagens procedurais com orientadas a objetos; focar apenas em sintaxe sem semântica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o papel do compilador na tradução de código",
                                  "subSteps": [
                                    "Explicar que o compilador converte código fonte de alto nível (C++) em código máquina legível pela CPU.",
                                    "Descrever fases principais: análise léxica, sintática, semântica, otimização e geração de código.",
                                    "Discutir como o compilador interpreta instruções abstratas em binário.",
                                    "Comparar com interpretadores, destacando a produção de executáveis independentes.",
                                    "Identificar ferramentas como GCC para C++."
                                  ],
                                  "verification": "Desenhar um diagrama simples do processo de compilação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama em papel ou ferramenta como Draw.io, instalador GCC.",
                                  "tips": "Pense no compilador como um tradutor que otimiza o código para eficiência.",
                                  "learningObjective": "Compreender o compilador como ponte entre linguagem humana e máquina.",
                                  "commonMistakes": "Achar que compilador executa o código; ignorar fases intermediárias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear estruturas linguísticas para instruções de máquina",
                                  "subSteps": [
                                    "Analisar como atribuições viram instruções MOV (move) em assembly.",
                                    "Explicar condicionais como comparações CMP e saltos JMP baseados em flags.",
                                    "Detalhar loops como estruturas com saltos condicionais para iterações.",
                                    "Mostrar subprogramas como chamadas CALL/RET com gerenciamento de pilha.",
                                    "Simular com pseudocódigo assembly gerado por compilador."
                                  ],
                                  "verification": "Converter um trecho de código C++ simples em pseudocódigo assembly.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador GCC com flag -S para gerar assembly, visualizador de assembly.",
                                  "tips": "Use flags como g++ -S programa.cpp para ver o assembly real.",
                                  "learningObjective": "Relacionar sintaxe de alto nível com operações de baixo nível.",
                                  "commonMistakes": "Sobrestimar abstrações; não conectar lógica de controle a instruções reais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar e analisar a produção de executável",
                                  "subSteps": [
                                    "Escrever um programa C++ com atribuição, if, loop e função.",
                                    "Compilar com g++ para gerar executável (.exe ou binário).",
                                    "Executar e observar o resultado, comparando com comportamento esperado.",
                                    "Usar ferramentas como objdump para inspecionar o binário.",
                                    "Discutir linkagem estática/dinâmica na formação do executável final."
                                  ],
                                  "verification": "Gerar e executar um executável funcional, explicando cada transformação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ambiente Linux/Windows com GCC, terminal.",
                                  "tips": "Teste erros de compilação para entender validações do compilador.",
                                  "learningObjective": "Aplicar o conhecimento na prática para validar o processo completo.",
                                  "commonMistakes": "Ignorar erros de compilação; não debugar o executável."
                                }
                              ],
                              "practicalExample": "Escreva um programa C++ que lê um número, usa um loop for para somar de 1 ao número (com if para números pares), e chama uma função para imprimir o resultado. Compile com 'g++ programa.cpp -o programa' e execute './programa'. Analise o assembly gerado com 'g++ -S programa.cpp' para ver como if, for e função viram instruções JMP e CALL.",
                              "finalVerifications": [
                                "Explicar verbalmente como uma atribuição se torna instrução MOV.",
                                "Desenhar fluxo de um loop compilado com saltos condicionais.",
                                "Compilar um código com erro e identificar a fase de falha.",
                                "Comparar executável de C++ com equivalente em assembly manual.",
                                "Discutir por que C++ precisa de compilador para rodar em hardware.",
                                "Relacionar subprogramas à pilha de chamadas no executável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das transformações de alto para baixo nível (40%)",
                                "Uso correto de exemplos práticos e compilação real (30%)",
                                "Clareza em diagramas e explicações lógicas (15%)",
                                "Identificação de erros comuns e otimizações (10%)",
                                "Conexão integral entre linguagem e executável (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em condicionais e fluxos algorítmicos.",
                                "Física: Simulações computacionais em C++ para modelagem de sistemas.",
                                "Linguagens: Análise sintática comparada a gramáticas formais.",
                                "Engenharia: Otimização de código para eficiência energética em hardware."
                              ],
                              "realWorldApplication": "Desenvolvedores usam compiladores como GCC para criar softwares de alto desempenho em C++, como navegadores (Chrome), jogos (Unreal Engine), sistemas operacionais (Linux kernel) e aplicativos embarcados em dispositivos IoT, transformando lógica procedural em executáveis otimizados que rodam em bilhões de máquinas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.4",
                            "name": "Identificar exemplos de compiladores",
                            "description": "Citar compiladores como GCC para C/C++ e relacioná-los com bibliografia, como Mizrahi (Treinamento em Linguagem C++) e Mokarzel/Soma (Introdução à Ciência da Computação).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e função de um compilador",
                                  "subSteps": [
                                    "Leia a definição de compilador como um programa que traduz código fonte de alto nível para código máquina.",
                                    "Estude o processo básico: análise léxica, sintática, semântica, otimização e geração de código.",
                                    "Compare com interpretadores para destacar diferenças (compilador gera executável standalone).",
                                    "Anote exemplos iniciais de linguagens que usam compiladores (C, C++, Java).",
                                    "Revise diagramas de fluxo de compilação em recursos online."
                                  ],
                                  "verification": "Escreva um parágrafo explicando o que é um compilador e sua função principal em suas próprias palavras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro 'Introdução à Ciência da Computação' de Mokarzel/Soma (capítulo sobre compiladores)",
                                    "Vídeos introdutórios no YouTube sobre ciclo de compilação"
                                  ],
                                  "tips": [
                                    "Use diagramas visuais para memorizar o fluxo; foque em analogias como 'tradutor humano'.",
                                    "Evite pular a comparação com interpretadores para clareza."
                                  ],
                                  "learningObjective": "Dominar o conceito fundamental de compilador e seu papel na computação.",
                                  "commonMistakes": [
                                    "Confundir compilador com interpretador.",
                                    "Ignorar etapas intermediárias do processo de compilação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar e listar exemplos comuns de compiladores",
                                  "subSteps": [
                                    "Busque compiladores para linguagens populares: GCC para C/C++, Javac para Java, Clang para C/C++.",
                                    "Registre pelo menos 5 exemplos com linguagem associada e características principais.",
                                    "Classifique por open-source (GCC) vs proprietários (Microsoft Visual C++).",
                                    "Crie uma tabela comparativa simples com colunas: Nome, Linguagem, Plataformas suportadas.",
                                    "Verifique fontes confiáveis como sites oficiais do GCC e documentação da LLVM."
                                  ],
                                  "verification": "Produza uma lista ou tabela com 5+ compiladores identificados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Site oficial do GCC (gcc.gnu.org)",
                                    "Wikipedia página de compiladores (seção exemplos)",
                                    "Notebook ou planilha digital"
                                  ],
                                  "tips": [
                                    "Priorize compiladores amplamente usados; use busca avançada para filtrar por 'compiladores populares 2023'.",
                                    "Faça anotações em formato tabular para revisão rápida."
                                  ],
                                  "learningObjective": "Identificar e categorizar múltiplos exemplos de compiladores por linguagem e tipo.",
                                  "commonMistakes": [
                                    "Listar apenas um exemplo (ex: só GCC).",
                                    "Confundir assemblers ou linkers com compiladores."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o GCC como exemplo principal para C/C++",
                                  "subSteps": [
                                    "Instale o GCC em seu ambiente (via MinGW no Windows ou apt no Linux).",
                                    "Compile um programa simples 'Hello World' em C++ usando comando 'g++ hello.cpp -o hello'.",
                                    "Analise flags comuns: -o (output), -Wall (warnings), -std=c++11 (padrão).",
                                    "Execute o binário gerado e observe o processo de tradução.",
                                    "Leia documentação básica do GCC para entender suporte multiplataforma."
                                  ],
                                  "verification": "Compile e execute com sucesso um programa C++ usando GCC, capturando saída do terminal.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GCC instalado",
                                    "Editor de texto como VS Code",
                                    "Livro 'Treinamento em Linguagem C++' de Mizrahi (seção compilação)"
                                  ],
                                  "tips": [
                                    "Teste em terminal real, não simulador; comece com código mínimo para evitar erros.",
                                    "Salve comandos em um script para reutilização."
                                  ],
                                  "learningObjective": "Aplicar GCC na prática e entender seu uso em desenvolvimento C/C++.",
                                  "commonMistakes": [
                                    "Erros de instalação (use gerenciadores de pacotes).",
                                    "Omitir flags essenciais levando a falhas de compilação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar exemplos com bibliografia e sintetizar conhecimento",
                                  "subSteps": [
                                    "Localize referências no livro de Mizrahi sobre uso de compiladores em C++ (ex: menções ao GCC).",
                                    "No livro de Mokarzel/Soma, identifique seções sobre compiladores e exemplos citados.",
                                    "Crie um mapa mental conectando GCC aos livros e conceitos de computação básica.",
                                    "Resuma como esses recursos validam o uso de compiladores como GCC.",
                                    "Discuta com um colega ou anote 3 insights dos livros."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras ligando GCC às bibliografias especificadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Livros Mizrahi e Mokarzel/Soma (físico ou PDF)",
                                    "Ferramenta de mind mapping como XMind ou papel"
                                  ],
                                  "tips": [
                                    "Marque páginas relevantes nos livros para referência futura.",
                                    "Use citações diretas para precisão acadêmica."
                                  ],
                                  "learningObjective": "Conectar exemplos práticos de compiladores à literatura recomendada.",
                                  "commonMistakes": [
                                    "Não citar páginas ou edições específicas.",
                                    "Ignorar contexto dos livros além de menções superficiais."
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um programa C++ simples que calcula a soma de dois números usando GCC: escreva o código, execute 'g++ soma.cpp -o soma', rode './soma' e verifique a saída correta, relacionando ao exemplo de compilação no livro de Mizrahi.",
                              "finalVerifications": [
                                "Citar corretamente pelo menos 5 exemplos de compiladores com linguagens associadas.",
                                "Explicar o processo de compilação com GCC em um programa real.",
                                "Referenciar trechos específicos dos livros Mizrahi e Mokarzel/Soma sobre compiladores.",
                                "Demonstrar compilação bem-sucedida de código C/C++ via terminal.",
                                "Diferenciar compiladores de outros tradutores de código.",
                                "Listar 3 flags úteis do GCC com propósitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de exemplos (mínimo 80% corretos).",
                                "Profundidade na conexão com bibliografia (citações diretas).",
                                "Sucesso prático na compilação com GCC (sem erros).",
                                "Clareza na explicação de conceitos (linguagem acessível e precisa).",
                                "Completude do mapa mental ou tabela comparativa.",
                                "Criatividade em exemplos reais além do básico."
                              ],
                              "crossCurricularConnections": [
                                "História da Computação: Evolução de compiladores desde FORTRAN até GCC moderno.",
                                "Matemática: Teoria da Computação (autômatos e linguagens formais no processo de análise).",
                                "Engenharia de Software: Integração de compiladores em pipelines CI/CD.",
                                "Linguística: Analogia com tradução de idiomas naturais (análise sintática)."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, engenheiros usam GCC diariamente para compilar código C/C++ em projetos open-source como Linux Kernel, otimizando performance em servidores e embedded systems, garantindo portabilidade multiplataforma."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Software Básico para Computadores",
                    "description": "Conceitos de software essencial, incluindo sistemas operacionais e utilitários básicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Conceitos Fundamentais de Software",
                        "description": "Definições básicas de algoritmo, programa, linguagem de programação e compilador, essenciais para entender o software básico em computadores.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Identificar um algoritmo",
                            "description": "Reconhecer e descrever um algoritmo como uma sequência finita de instruções bem definidas e não ambíguas para resolver um problema específico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição básica de algoritmo",
                                  "subSteps": [
                                    "Leia a definição formal: uma sequência finita de instruções bem definidas e não ambíguas para resolver um problema específico.",
                                    "Anote os elementos chave: finitude, definitude, não-ambiguidade e foco em um problema.",
                                    "Compare com exemplos cotidianos, como uma receita de bolo.",
                                    "Reescreva a definição com suas próprias palavras.",
                                    "Discuta com um colega ou anote dúvidas."
                                  ],
                                  "verification": "Você consegue explicar a definição em 1 minuto sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a um dicionário de termos computacionais online"
                                  ],
                                  "tips": "Use analogias simples como 'receita de cozinha' para fixar o conceito.",
                                  "learningObjective": "Internalizar a definição essencial de algoritmo.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com programa",
                                    "Ignorar a finitude (sequência infinita não é algoritmo)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as propriedades fundamentais de um algoritmo",
                                  "subSteps": [
                                    "Liste as 5 propriedades principais: entrada, saída, definitude, finitude e efetividade.",
                                    "Para cada propriedade, crie um exemplo curto.",
                                    "Analise um pseudocódigo simples e marque quais propriedades ele atende.",
                                    "Identifique o que falta em uma sequência que não é algoritmo.",
                                    "Crie um fluxograma básico representando essas propriedades."
                                  ],
                                  "verification": "Crie uma tabela comparativa com propriedades atendidas ou não em um exemplo dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para fluxograma",
                                    "Editor de texto simples ou ferramenta online como Draw.io"
                                  ],
                                  "tips": "Lembre-se: propriedades garantem que o algoritmo sempre termine e funcione corretamente.",
                                  "learningObjective": "Reconhecer as características que definem um algoritmo válido.",
                                  "commonMistakes": [
                                    "Omitir a efetividade (deve produzir resultado correto)",
                                    "Confundir entrada com saída"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos reais de algoritmos e não-algoritmos",
                                  "subSteps": [
                                    "Examine 3 exemplos de algoritmos: soma de números, busca linear, receita de café.",
                                    "Para cada um, destaque sequência finita, instruções claras e resolução de problema.",
                                    "Analise 3 não-algoritmos: instruções vagas como 'faça o melhor', loops infinitos.",
                                    "Classifique novos exemplos em 'algoritmo' ou 'não-algoritmo' com justificativa.",
                                    "Debata com um parceiro por que um exemplo falha."
                                  ],
                                  "verification": "Classifique corretamente 5 exemplos mistos com explicações escritas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de exemplos impressa ou digital",
                                    "Planilha para classificação"
                                  ],
                                  "tips": "Pergunte sempre: 'Isso termina? É claro? Resolve o problema?'",
                                  "learningObjective": "Diferenciar algoritmos de sequências comuns por meio de análise prática.",
                                  "commonMistakes": [
                                    "Aceitar instruções ambíguas como 'adicione sal a gosto'",
                                    "Ignorar falta de finitude"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever e identificar algoritmos em contextos variados",
                                  "subSteps": [
                                    "Escolha um problema cotidiano (ex: lavar louça) e escreva como algoritmo.",
                                    "Converta uma descrição narrativa em pseudocódigo sequencial.",
                                    "Identifique algoritmos em códigos simples (ex: Bubble Sort).",
                                    "Revise seu algoritmo com as propriedades aprendidas.",
                                    "Teste executando mentalmente ou com um exemplo numérico."
                                  ],
                                  "verification": "Produza e valide um algoritmo próprio para um problema dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de exemplos online",
                                    "Papel para rascunhos"
                                  ],
                                  "tips": "Comece com problemas simples para construir confiança.",
                                  "learningObjective": "Aplicar o reconhecimento de algoritmos em descrições e criações próprias.",
                                  "commonMistakes": [
                                    "Incluir passos condicionais sem estrutura clara",
                                    "Esquecer saída explícita"
                                  ]
                                }
                              ],
                              "practicalExample": "Algoritmo para calcular a média de 3 notas: 1. Leia nota1. 2. Leia nota2. 3. Leia nota3. 4. Some nota1 + nota2 + nota3 = soma. 5. Divida soma por 3 = media. 6. Exiba media. (Entrada: 3 números; Saída: um número; Finito e definitivo).",
                              "finalVerifications": [
                                "Defina algoritmo corretamente com todos os elementos chave.",
                                "Classifique 80% de exemplos como algoritmo ou não-algoritmo.",
                                "Descreva propriedades em um algoritmo dado.",
                                "Crie um algoritmo simples para um problema novo.",
                                "Explique por que uma sequência não é algoritmo.",
                                "Identifique entrada/saída em pseudocódigo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (100% dos elementos incluídos).",
                                "Capacidade de diferenciar algoritmos de não-algoritmos (acurácia >90%).",
                                "Descrição clara de propriedades com exemplos.",
                                "Algoritmo criado atende todas as propriedades.",
                                "Análise lógica sem ambiguidades.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e processos lógicos.",
                                "Língua Portuguesa: Redação clara e não ambígua de instruções.",
                                "Física: Modelagem de processos experimentais passo a passo.",
                                "Artes: Criação de fluxogramas visuais."
                              ],
                              "realWorldApplication": "Algoritmos são usados em GPS para rotas (sequência de direções finitas), redes sociais para feeds (ordenação de posts) e bancos para cálculos de juros, garantindo eficiência e precisão em soluções automatizadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Diferenciar programa de algoritmo",
                            "description": "Explicar a diferença entre algoritmo (descrição abstrata) e programa (implementação concreta em uma linguagem de programação).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de algoritmo",
                                  "subSteps": [
                                    "Leia a definição: algoritmo é uma sequência finita de instruções lógicas e abstratas para resolver um problema.",
                                    "Identifique características principais: independência de linguagem, foco em passos lógicos, entrada/saída definidas.",
                                    "Analise exemplos simples, como receita de bolo ou passos para lavar louça.",
                                    "Registre em um diagrama de fluxo os componentes básicos (início, passos, fim)."
                                  ],
                                  "verification": "Criar um diagrama simples de um algoritmo cotidiano e explicá-lo oralmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta, acesso a internet para exemplos visuais",
                                  "tips": "Use analogias do dia a dia para fixar o conceito abstrato.",
                                  "learningObjective": "Definir algoritmo e listar suas características essenciais.",
                                  "commonMistakes": "Confundir algoritmo com código; lembrar que é abstrato, não em linguagem específica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de programa",
                                  "subSteps": [
                                    "Leia a definição: programa é a implementação concreta de um algoritmo em uma linguagem de programação específica.",
                                    "Identifique características: sintaxe da linguagem, compilação/execução, dependência de ambiente (IDE, compilador).",
                                    "Observe exemplos: pseudocódigo vs. código Python ou Java para o mesmo problema.",
                                    "Teste um programa simples em um editor online para ver execução.",
                                    "Anote diferenças iniciais entre abstração e concretude."
                                  ],
                                  "verification": "Executar um programa simples e descrever o que acontece na tela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor online como Replit ou CodePen, computador",
                                  "tips": "Comece com linguagens simples como Python para evitar complexidade desnecessária.",
                                  "learningObjective": "Definir programa e contrastar com sua dependência de linguagem.",
                                  "commonMistakes": "Achar que todo algoritmo é programa; programa requer sintaxe exata."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar algoritmo e programa",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para algoritmo (abstrato, lógico) e programa (concreto, sintático).",
                                    "Discuta similaridades: ambos resolvem problemas via passos sequenciais.",
                                    "Destaque diferenças chave: portabilidade (algoritmo sim, programa depende da linguagem), legibilidade humana vs. máquina.",
                                    "Debata cenários: quando usar um sem o outro (algoritmo para planejamento)."
                                  ],
                                  "verification": "Preencher tabela comparativa com pelo menos 5 diferenças e 2 similaridades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha ou papel para tabela",
                                  "tips": "Use setas ou ícones na tabela para visualização rápida das diferenças.",
                                  "learningObjective": "Listar e explicar 5 diferenças principais entre os dois conceitos.",
                                  "commonMistakes": "Ignorar que algoritmo precede o programa; sequência é planejamento primeiro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a diferenciação em exemplos práticos",
                                  "subSteps": [
                                    "Escolha um problema simples (ex: calcular média de notas).",
                                    "Escreva o algoritmo em pseudocódigo.",
                                    "Converta para programa em Python.",
                                    "Compare os dois lado a lado e execute o programa.",
                                    "Reflita: o que muda se trocar de linguagem (ex: para JavaScript)?"
                                  ],
                                  "verification": "Apresentar algoritmo e programa correspondente, executando o último com sucesso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código online, papel para pseudocódigo",
                                  "tips": "Mantenha o algoritmo simples para focar na distinção conceitual.",
                                  "learningObjective": "Criar e comparar um par algoritmo-programa funcional.",
                                  "commonMistakes": "Implementar lógica errada no programa; valide o algoritmo antes."
                                }
                              ],
                              "practicalExample": "Problema: Somar dois números. Algoritmo (pseudocódigo): 1. Receba A e B; 2. Calcule S = A + B; 3. Mostre S. Programa (Python): a = int(input('A: ')); b = int(input('B: ')); s = a + b; print(s). Note: algoritmo é legível em qualquer lugar; programa roda só em Python.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença principal sem hesitação.",
                                "Converter um algoritmo dado em programa simples.",
                                "Identificar em um texto qual é algoritmo e qual é programa.",
                                "Criar tabela comparativa precisa.",
                                "Discutir por que algoritmo é pré-requisito para programa.",
                                "Executar programa derivado de algoritmo sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de algoritmo (abstração vs. lógica).",
                                "Clareza na distinção de programa (concreto e linguagem-específico).",
                                "Uso correto de exemplos comparativos.",
                                "Completude da tabela ou diagrama comparativo.",
                                "Capacidade de aplicação em novo contexto.",
                                "Ausência de confusões comuns (ex: tratar algoritmo como código)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica sequencial e fluxogramas.",
                                "Língua Portuguesa: Redação clara e precisa de instruções.",
                                "Física: Modelos abstratos vs. implementações experimentais.",
                                "Artes: Diagramação visual de fluxos."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, engenheiros usam algoritmos para planejar soluções eficientes antes de codificar programas, evitando erros caros em projetos como apps de delivery ou sistemas bancários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Compreender linguagens de programação e compiladores",
                            "description": "Descrever o papel de linguagens de programação procedimentais e o funcionamento de um compilador para transformar código fonte em executável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender linguagens de programação procedimentais",
                                  "subSteps": [
                                    "Defina o que é uma linguagem de programação procedimental, como C ou Pascal.",
                                    "Identifique características principais: sequências de comandos, estruturas de controle (if, loops) e funções.",
                                    "Compare com linguagens declarativas, destacando o foco em 'como' executar tarefas.",
                                    "Pesquise exemplos históricos, como o desenvolvimento do C por Dennis Ritchie.",
                                    "Liste 3 linguagens procedimentais comuns e seus usos iniciais."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o papel das linguagens procedimentais e cite 2 exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notebook ou computador",
                                    "Acesso à internet para Wikipedia e tutoriais de C",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use analogias cotidianas, como uma receita de bolo que segue passos sequenciais.",
                                  "learningObjective": "Compreender o conceito e o papel das linguagens procedimentais na programação.",
                                  "commonMistakes": "Confundir procedimental com orientado a objetos; assumir que todas as linguagens são procedimentais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar código fonte de executável",
                                  "subSteps": [
                                    "Explique código fonte: texto legível por humanos escrito em linguagem de alto nível.",
                                    "Descreva executável: arquivo binário legível pela máquina (linguagem de máquina).",
                                    "Discuta por que o código fonte não roda diretamente no hardware.",
                                    "Visualize a hierarquia: alto nível → assembly → binário.",
                                    "Crie um exemplo simples de código fonte em pseudocódigo."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando código fonte vs executável e anote diferenças chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Visualizador de arquivos binários como HxD (opcional)"
                                  ],
                                  "tips": "Pense no código fonte como uma carta em inglês e o executável como Morse para máquinas.",
                                  "learningObjective": "Distinguir e relacionar código fonte legível por humanos com executável de máquina.",
                                  "commonMistakes": "Achar que código fonte é executável; ignorar a necessidade de tradução."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o funcionamento de um compilador",
                                  "subSteps": [
                                    "Descreva as fases principais: análise léxica, sintática, semântica, geração de código e otimização.",
                                    "Explique análise léxica: quebra em tokens (palavras-chave, operadores).",
                                    "Detalhe análise sintática: verifica gramática e constrói árvore de sintaxe.",
                                    "Aborde geração de código: traduz para assembly ou binário direto.",
                                    "Mencione linkers e loaders para arquivos finais."
                                  ],
                                  "verification": "Liste as 5 fases do compilador com uma frase explicando cada uma.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Vídeo tutorial sobre compiladores (ex: YouTube 'How Compilers Work')",
                                    "Diagrama impresso de pipeline de compilador"
                                  ],
                                  "tips": "Assista a animações interativas para visualizar o fluxo de dados.",
                                  "learningObjective": "Mapear e descrever as etapas do processo de compilação.",
                                  "commonMistakes": "Confundir compilador com interpretador; pular fases de análise."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar conceitos compilando um programa simples",
                                  "subSteps": [
                                    "Escreva um programa 'Hello World' em C (linguagem procedimental).",
                                    "Instale GCC (compilador) e compile via terminal: gcc hello.c -o hello.",
                                    "Execute o binário gerado e examine seu tamanho vs fonte.",
                                    "Gere erros intencionais (sintaxe) e observe mensagens do compilador.",
                                    "Compare o executável com o fonte usando ferramentas como file ou objdump."
                                  ],
                                  "verification": "Compile e execute com sucesso, capturando screenshots de cada etapa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com Linux/Mac ou WSL no Windows",
                                    "GCC instalado",
                                    "Editor como VS Code ou Vim"
                                  ],
                                  "tips": "Use flags como -Wall para ver warnings e aprender de erros.",
                                  "learningObjective": "Praticar a transformação de código fonte em executável via compilador.",
                                  "commonMistakes": "Esquecer de salvar o arquivo .c; não usar extensão correta; ignorar erros de compilação."
                                }
                              ],
                              "practicalExample": "Escreva e compile um programa C simples que imprima 'Olá, Mundo!' usando GCC: crie hello.c com #include <stdio.h> e main() { printf(\"Olá, Mundo!\\n\"); }, compile com gcc hello.c -o hello, execute ./hello. Observe o compilador processar léxico, sintático e gerar o executável binário.",
                              "finalVerifications": [
                                "Descreva verbalmente as fases de um compilador sem consultar notas.",
                                "Explique a diferença entre código fonte procedimental e executável para um colega.",
                                "Compile um programa C com erro e corrija baseado na mensagem.",
                                "Identifique C como linguagem procedimental e dê 2 razões.",
                                "Desenhe o fluxo completo: fonte → compilador → executável.",
                                "Liste 3 linguagens procedimentais e um compilador para cada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das fases do compilador (80% das etapas corretas).",
                                "Capacidade de compilar e debugar um programa simples sem ajuda.",
                                "Uso correto de terminologia (procedimental, léxica, sintática).",
                                "Diagrama claro mostrando transformação de fonte para executável.",
                                "Explicação coerente do papel das linguagens procedimentais.",
                                "Identificação de erros comuns em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e estruturas de controle semelhantes a algoritmos.",
                                "Física: Representação binária de dados no hardware (transistores).",
                                "Língua Portuguesa: Análise sintática paralela à gramática da programação.",
                                "História: Evolução da computação desde Fortran até C moderno."
                              ],
                              "realWorldApplication": "Desenvolvedores usam compiladores diariamente para criar apps, jogos e sistemas operacionais (ex: Linux kernel em C compilado com GCC), otimizando código para performance em smartphones, servidores e IoT."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Lógica de Programação Básica",
                        "description": "Comandos fundamentais de uma linguagem procedimental, incluindo atribuição, entrada/saída, estruturas condicionais, repetitivas e seletivas, além de tratamento de exceções.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Utilizar comandos de atribuição, entrada e saída",
                            "description": "Aplicar comandos básicos como atribuição de valores a variáveis, leitura de entrada do usuário e exibição de saída na tela em uma linguagem procedimental.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e aplicar comandos de atribuição de valores a variáveis",
                                  "subSteps": [
                                    "Explicar o conceito de variável como um 'espaço na memória' para armazenar dados.",
                                    "Identificar a sintaxe em Portugol: declaração com 'var' e atribuição com '<-' (ex: nome: caractere; nome <- \"João\").",
                                    "Praticar atribuindo valores de diferentes tipos: inteiro (idade <- 25), real (altura <- 1.75), caractere (letra <- 'A'), lógico (aprovado <- verdadeiro).",
                                    "Experimentar reatribuição: alterar o valor de uma variável múltiplas vezes no código.",
                                    "Declarar múltiplas variáveis em uma seção 'var'."
                                  ],
                                  "verification": "Criar e executar um algoritmo simples que atribua valores a 3 variáveis diferentes e exiba-as, confirmando valores corretos na saída.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Visualg ou Portugol Studio",
                                    "Documentação de sintaxe Portugol"
                                  ],
                                  "tips": "Use nomes descritivos para variáveis para facilitar a leitura do código.",
                                  "learningObjective": "Dominar a sintaxe e aplicação de atribuição para inicializar e modificar variáveis.",
                                  "commonMistakes": [
                                    "Esquecer a declaração 'var' antes da atribuição",
                                    "Usar '=' em vez de '<-'",
                                    "Omitir aspas em valores de caractere"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar comandos de leitura de entrada do usuário",
                                  "subSteps": [
                                    "Entender o comando 'leia(variavel)' como forma de capturar dados digitados pelo usuário.",
                                    "Declarar a variável antes de usar 'leia' para evitar erros de compilação.",
                                    "Testar leitura de diferentes tipos: inteiro, real e caractere.",
                                    "Posicionar 'leia' após prompts informativos (usando escreva antes para guiar o usuário).",
                                    "Verificar comportamento com entradas inválidas (ex: letras em inteiro)."
                                  ],
                                  "verification": "Executar um algoritmo que leia nome e idade, atribuindo a variáveis, e exiba confirmação da entrada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Visualg ou Portugol Studio",
                                    "Teclado para simular entradas"
                                  ],
                                  "tips": "Sempre informe o usuário o que digitar com um 'escreva' antes do 'leia'.",
                                  "learningObjective": "Capturar e armazenar dados interativos do usuário de forma segura.",
                                  "commonMistakes": [
                                    "Ler variável não declarada",
                                    "Não tratar tipos de dados incompatíveis",
                                    "Esquecer ponto e vírgula após 'leia'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar comandos de exibição de saída na tela",
                                  "subSteps": [
                                    "Aprender a sintaxe 'escreva(\"texto\")' para saída simples e 'escrevaln(\"texto\")' para nova linha.",
                                    "Concatenar variáveis com texto: escreva(\"Olá \", nome).",
                                    "Exibir múltiplas saídas em sequência para formar mensagens completas.",
                                    "Testar formatação com diferentes tipos de dados (números sem aspas).",
                                    "Usar 'escrevaln' para separar saídas visualmente."
                                  ],
                                  "verification": "Criar um snippet que exiba valores atribuídos e lidos, verificando formatação correta no console.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Visualg ou Portugol Studio"
                                  ],
                                  "tips": "Use aspas duplas para strings e evite espaços extras indesejados na concatenação.",
                                  "learningObjective": "Gerar saídas claras e formatadas para comunicação com o usuário.",
                                  "commonMistakes": [
                                    "Concatenar sem vírgula entre string e variável",
                                    "Usar aspas em números",
                                    "Esquecer 'ln' quando necessário para quebras de linha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar atribuição, entrada e saída em um programa completo",
                                  "subSteps": [
                                    "Estruturar um algoritmo completo: 'algoritmo', 'var', 'inicio', comandos, 'fimalgoritmo'.",
                                    "Combinar os comandos: atribuir valores iniciais, ler entradas e exibir resultados processados.",
                                    "Adicionar comentários explicativos em cada seção.",
                                    "Testar o programa com múltiplas entradas variadas.",
                                    "Depurar erros comuns identificados nos passos anteriores."
                                  ],
                                  "verification": "Executar o programa integrado, confirmando que processa entradas corretamente e gera saídas esperadas sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Visualg ou Portugol Studio",
                                    "Papel para esboçar o fluxograma"
                                  ],
                                  "tips": "Planeje o fluxo sequencial antes de codificar: entrada -> processamento -> saída.",
                                  "learningObjective": "Construir programas interativos básicos usando os três comandos fundamentais.",
                                  "commonMistakes": [
                                    "Ordem incorreta dos comandos (exibir antes de ler)",
                                    "Falta de estrutura 'inicio/fim'",
                                    "Variáveis não inicializadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um algoritmo em Portugol que leia o nome e a idade do usuário, atribua a uma variável de saudação inicial ('Olá'), e exiba: 'Olá [nome], você tem [idade] anos e é bem-vindo!'. Teste com entradas como 'Maria' e 30.",
                              "finalVerifications": [
                                "O algoritmo compila sem erros de sintaxe no Visualg.",
                                "Solicita entradas corretamente e armazena em variáveis.",
                                "Exibe saída concatenada e formatada precisamente.",
                                "Funciona com entradas de diferentes tipos e tamanhos.",
                                "Não apresenta erros de runtime ao executar múltiplas vezes.",
                                "Inclui comentários explicando cada comando usado."
                              ],
                              "assessmentCriteria": [
                                "Correta declaração e atribuição de todas as variáveis.",
                                "Uso preciso dos comandos 'leia' e 'escreva' com sintaxe adequada.",
                                "Integração lógica sequencial sem falhas no fluxo.",
                                "Concatenação correta de strings e variáveis na saída.",
                                "Tratamento básico de tipos de dados compatíveis.",
                                "Estrutura completa do algoritmo com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Preparação para operações aritméticas com variáveis numéricas.",
                                "Língua Portuguesa: Construção de frases claras e gramaticalmente corretas nas saídas.",
                                "Ética e Cidadania: Consideração de privacidade ao lidar com dados pessoais do usuário.",
                                "Artes: Design de interfaces textuais intuitivas e visualmente organizadas."
                              ],
                              "realWorldApplication": "Esses comandos são a base para interfaces de usuário em aplicativos como calculadoras bancárias (entrada de valores, saída de resultados), sistemas de cadastro (leitura de dados pessoais, exibição de confirmação) e chatbots simples que interagem com clientes em e-commerces ou suporte técnico."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Implementar estruturas condicionais e seletivas",
                            "description": "Construir lógica com estruturas if-else e switch para decisões baseadas em condições booleanas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e implementar estruturas if simples",
                                  "subSteps": [
                                    "Estude o conceito de condições booleanas (true/false).",
                                    "Aprenda a sintaxe básica do if em Python: if condicao: ...",
                                    "Escreva um programa que verifica se um número é positivo.",
                                    "Teste o programa com diferentes entradas.",
                                    "Analise o fluxo de execução com print statements."
                                  ],
                                  "verification": "O programa imprime mensagem apenas quando a condição é verdadeira e ignora quando falsa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (VS Code ou IDLE), Python instalado",
                                  "tips": "Use indentação correta (4 espaços) para o bloco if.",
                                  "learningObjective": "Compreender como o if executa código baseado em condições verdadeiras.",
                                  "commonMistakes": "Esquecer os dois pontos (:) após a condição; usar = em vez de == para comparação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar estruturas if-else para decisões binárias",
                                  "subSteps": [
                                    "Revise o if simples e adicione else para o caso falso.",
                                    "Escreva sintaxe: if condicao: ... else: ...",
                                    "Crie um programa que classifica um número como par ou ímpar.",
                                    "Execute com múltiplos testes (par, ímpar, zero).",
                                    "Adicione comentários explicando cada parte."
                                  ],
                                  "verification": "O programa responde corretamente para ambos os casos (verdadeiro e falso).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de código, Python, terminal para execução",
                                  "tips": "Sempre teste o caminho else para evitar lógica falha.",
                                  "learningObjective": "Dominar decisões binárias com if-else para cobrir todos os cenários.",
                                  "commonMistakes": "Indentação inconsistente no else; confundir atribuição (=) com comparação (==)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar estruturas de seleção múltipla com if-elif-else e match-case",
                                  "subSteps": [
                                    "Aprenda if-elif-else para múltiplas condições mutuamente exclusivas.",
                                    "Estude match-case (Python 3.10+) como alternativa ao switch.",
                                    "Implemente um programa que classifica nota escolar (A, B, C, D, F).",
                                    "Converta o if-elif para match-case e compare.",
                                    "Teste com notas de borda (ex: 59, 60)."
                                  ],
                                  "verification": "O programa classifica corretamente todas as notas testadas sem sobreposições.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python 3.10+, editor de código",
                                  "tips": "Ordene condições de mais específicas para gerais em if-elif.",
                                  "learningObjective": "Aplicar seleções múltiplas para cenários com mais de duas opções.",
                                  "commonMistakes": "Esquecer elif e usar múltiplos ifs aninhados desnecessariamente; não cobrir todos os casos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar condicionais em um programa prático e depurar",
                                  "subSteps": [
                                    "Combine if-else e elif em um menu simples de calculadora.",
                                    "Adicione validação de entrada do usuário.",
                                    "Use match-case para opções de menu.",
                                    "Depure erros comuns com try-except básico.",
                                    "Otimize o código para legibilidade."
                                  ],
                                  "verification": "O programa roda interativamente, responde corretamente a inputs válidos e inválidos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código, Python",
                                  "tips": "Use input() com int() e valide com condicionais.",
                                  "learningObjective": "Construir lógica condicional complexa em aplicações reais.",
                                  "commonMistakes": "Não tratar entradas inválidas; aninhamento excessivo de ifs."
                                }
                              ],
                              "practicalExample": "Crie um validador de idade para entrada em eventos: if idade < 18: print('Menor de idade'); elif idade < 65: print('Adulto'); else: print('Idoso'). Use match para dia da semana: match dia: case 'segunda': print('Início da semana').",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe.",
                                "Todas as condições testadas produzem saídas esperadas.",
                                "Casos de borda (ex: valores iguais) são tratados corretamente.",
                                "Entrada inválida é gerenciada graciosamente.",
                                "Comentários explicam a lógica condicional.",
                                "Programa é legível com indentação adequada."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: condições booleanas bem avaliadas.",
                                "Cobertura completa: todos os cenários possíveis.",
                                "Eficiência: evita redundâncias e aninhamentos desnecessários.",
                                "Legibilidade: uso de nomes claros e comentários.",
                                "Testabilidade: inclui testes para verdadeiro/falso/bordas.",
                                "Adaptabilidade: código funciona com múltiplas entradas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operadores lógicos e booleanos.",
                                "Lógica e Filosofia: Raciocínio dedutivo e condicionais.",
                                "Negócios: Tomada de decisões baseadas em regras.",
                                "Design de Jogos: Condições para mecânicas de jogo."
                              ],
                              "realWorldApplication": "Em sistemas de e-commerce para verificar estoque e aplicar descontos; apps bancários para aprovar transações por saldo; jogos para respostas a ações do jogador; validação de formulários web."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Aplicar estruturas repetitivas",
                            "description": "Usar loops como for, while e do-while para repetição controlada de instruções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Estruturas Repetitivas",
                                  "subSteps": [
                                    "Explicar o que são loops e sua importância para evitar repetição manual de código.",
                                    "Identificar cenários cotidianos onde repetição controlada é necessária (ex: somar números sequenciais).",
                                    "Diferenciar repetição finita (número conhecido) de indefinida (até condição).",
                                    "Revisar pseudocódigo básico: for, while e do-while.",
                                    "Discutir condições de parada para evitar loops infinitos."
                                  ],
                                  "verification": "Escrever uma definição curta e listar 3 exemplos de uso de loops em problemas reais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Relacione loops a tarefas diárias como lavar pratos até acabarem.",
                                  "learningObjective": "Entender a necessidade e os tipos básicos de estruturas repetitivas.",
                                  "commonMistakes": [
                                    "Confundir loops com estruturas condicionais if-else",
                                    "Ignorar a importância da condição de parada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Loop For para Repetições com Contador Conhecido",
                                  "subSteps": [
                                    "Estudar sintaxe: for i from 1 to 10 { instruções }.",
                                    "Escrever código para imprimir números de 1 a 10.",
                                    "Modificar para calcular e imprimir soma de 1 a 10 (resultado: 55).",
                                    "Testar variando o limite e adicionar incremento personalizado (ex: de 2 em 2).",
                                    "Executar e validar saída no console."
                                  ],
                                  "verification": "Código executa corretamente e produz soma exata de 55 para 1-10.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Computador com Python ou IDE online (Replit/CodePen)",
                                    "Pseudocódigo impresso"
                                  ],
                                  "tips": "Sempre inicialize, teste condição e incremente no final.",
                                  "learningObjective": "Aplicar loop for em cenários com número fixo de iterações.",
                                  "commonMistakes": [
                                    "Esquecer o incremento levando a loop infinito",
                                    "Usar condição errada no range"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Loop While para Repetições Condicionais",
                                  "subSteps": [
                                    "Estudar sintaxe: while (condição) { instruções }.",
                                    "Escrever código para somar números até o usuário digitar 0.",
                                    "Adicionar validação de entrada e contador de iterações.",
                                    "Testar com múltiplos inputs e verificar soma acumulada.",
                                    "Simular cenários com condição falsa inicial (não executa)."
                                  ],
                                  "verification": "Programa soma corretamente inputs até 0 e para adequadamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Computador com Python ou IDE online",
                                    "Lista de números para teste"
                                  ],
                                  "tips": "Verifique a condição antes de cada iteração e atualize variáveis dentro do loop.",
                                  "learningObjective": "Controlar repetições baseadas em condições variáveis.",
                                  "commonMistakes": [
                                    "Não atualizar variável da condição dentro do loop",
                                    "Loop infinito por condição sempre verdadeira"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Loop Do-While para Execução Mínima Garantida",
                                  "subSteps": [
                                    "Estudar sintaxe: do { instruções } while (condição).",
                                    "Escrever código para validar input até ser número positivo (executa pelo menos uma vez).",
                                    "Adicionar mensagem de erro e repetir até sucesso.",
                                    "Testar com input inválido inicial e validar parada.",
                                    "Comparar com while em um exemplo idêntico."
                                  ],
                                  "verification": "Executa pelo menos uma vez e para corretamente após input válido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Computador com Python (simular com while True e break)",
                                    "Pseudocódigo de do-while"
                                  ],
                                  "tips": "Ideal para menus ou validações que precisam de uma tentativa inicial.",
                                  "learningObjective": "Usar do-while quando a primeira execução é obrigatória.",
                                  "commonMistakes": [
                                    "Confundir ordem: teste após execução",
                                    "Não quebrar em simulações Python"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Integração, Debugging e Escolha de Loops",
                                  "subSteps": [
                                    "Resolver problema: imprimir tabuada de um número usando for.",
                                    "Converter para while e simular do-while em um menu de opções.",
                                    "Introduzir break/continue e debugar loop infinito intencional.",
                                    "Comparar eficiência entre loops em 3 problemas diferentes.",
                                    "Otimizar código e documentar escolhas."
                                  ],
                                  "verification": "Resolver 3 problemas com loops corretos e sem erros de execução.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE online",
                                    "Problemas de prática impressos"
                                  ],
                                  "tips": "Escolha for para contadores, while/do-while para condições dinâmicas.",
                                  "learningObjective": "Integrar loops, debugar e selecionar o tipo adequado.",
                                  "commonMistakes": [
                                    "Escolher loop errado para o problema",
                                    "Aninhar loops sem necessidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Criar um programa que usa for para gerar tabuada de 5 (5x1=5 até 5x10=50), while para somar números pares até 100, e do-while para validar se o usuário quer continuar executando.",
                              "finalVerifications": [
                                "Implementa corretamente for, while e do-while em códigos funcionais.",
                                "Identifica e corrige loops infinitos em códigos fornecidos.",
                                "Explica diferenças entre os loops com exemplos próprios.",
                                "Aplica loops em problemas não triviais sem erros lógicos.",
                                "Documenta código com comentários sobre escolhas de loop.",
                                "Testa edge cases como zero iterações ou uma iteração."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática e lógica dos loops (sem erros de compilação/execução).",
                                "Adequação do tipo de loop ao problema (for para finito, etc.).",
                                "Eficiência e ausência de loops desnecessários ou infinitos.",
                                "Uso correto de variáveis de controle e condições de parada.",
                                "Clareza do código com comentários e indentação.",
                                "Capacidade de debugar e otimizar loops fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de sequências aritméticas e somas com loops.",
                                "Física: Simulações de trajetórias repetitivas ou iterações numéricas.",
                                "Artes: Geração de padrões fractais ou gráficos repetitivos.",
                                "Língua Portuguesa: Processamento de textos com repetições condicionais."
                              ],
                              "realWorldApplication": "Automação de tarefas repetitivas em software, como processar listas de dados em planilhas (for), aguardar eventos em servidores (while), validar formulários em apps (do-while), ou em jogos para animações contínuas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.4",
                            "name": "Tratar exceções básicas",
                            "description": "Implementar tratamento de erros e exceções para tornar programas mais robustos contra entradas inválidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos básicos de exceções",
                                  "subSteps": [
                                    "Defina o que é uma exceção: um evento que interrompe o fluxo normal de um programa devido a erros como divisão por zero ou entrada inválida.",
                                    "Classifique exceções em built-in (ex: ValueError, ZeroDivisionError) e customizadas.",
                                    "Explique por que tratar exceções: para evitar crashes e fornecer feedback amigável ao usuário.",
                                    "Analise um exemplo de código sem tratamento que falha.",
                                    "Discuta o impacto de exceções não tratadas em programas reais."
                                  ],
                                  "verification": "Resuma em suas palavras o que é uma exceção e liste 3 exemplos comuns, comprovando com um diagrama simples de fluxo de programa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de exceções em Python (ou linguagem escolhida)",
                                    "Editor de código como VS Code ou Replit"
                                  ],
                                  "tips": "Use analogias do dia a dia, como 'exceção é como um guarda de trânsito parando um carro com problema'.",
                                  "learningObjective": "Compreender o papel das exceções na robustez de programas.",
                                  "commonMistakes": [
                                    "Confundir exceções com erros de sintaxe",
                                    "Ignorar que exceções podem ser úteis para controle de fluxo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe básica de try-except",
                                  "subSteps": [
                                    "Escreva a estrutura básica: try: ... except ExceptionType: ...",
                                    "Teste com um código simples que tenta converter string para int e capture ValueError.",
                                    "Adicione um bloco else: executado se não houver exceção.",
                                    "Inclua finally: sempre executado, útil para cleanup.",
                                    "Execute e observe o comportamento com inputs válidos e inválidos."
                                  ],
                                  "verification": "Crie e execute um snippet que usa try-except-else-finally corretamente, sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente de programação Python online (Replit ou Jupyter)",
                                    "Exemplos de código de try-except da documentação oficial"
                                  ],
                                  "tips": "Sempre especifique o tipo de exceção em vez de usar 'except:' genérico para evitar mascarar erros.",
                                  "learningObjective": "Dominar a sintaxe fundamental para capturar e gerenciar exceções.",
                                  "commonMistakes": [
                                    "Esquecer indentação no bloco try",
                                    "Usar except sem tipo, capturando tudo inclusive erros graves"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar tratamento para exceções comuns",
                                  "subSteps": [
                                    "Identifique exceções típicas: ValueError (input inválido), ZeroDivisionError, FileNotFoundError.",
                                    "Crie um programa que lê dois números do usuário, divide e trata divisão por zero e input não numérico.",
                                    "Adicione mensagens de erro personalizadas e peça input novamente em loop.",
                                    "Teste com casos: números válidos, zero no divisor, letras como input.",
                                    "Refatore para múltiplos except em ordem hierárquica."
                                  ],
                                  "verification": "O programa roda sem crashar em 5 testes variados e fornece mensagens claras.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para inputs interativos"
                                  ],
                                  "tips": "Use input() em loop while True com break no sucesso para re-tentar inputs inválidos.",
                                  "learningObjective": "Aplicar tratamento de exceções em cenários reais de input do usuário.",
                                  "commonMistakes": [
                                    "Não tratar todas as exceções possíveis",
                                    "Colocar lógica crítica dentro do except"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar boas práticas e testar robustez",
                                  "subSteps": [
                                    "Levante exceções personalizadas com raise para validações específicas.",
                                    "Log exceções não tratadas usando print ou logging básico.",
                                    "Otimize código: evite try-except em loops desnecessários.",
                                    "Teste edge cases: inputs vazios, muito grandes, caracteres especiais.",
                                    "Revise o código para clareza e documente com comentários."
                                  ],
                                  "verification": "Revise o código final com um peer ou auto-checklist, confirmando zero crashes em 10 testes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de testes unitários simples",
                                    "Ferramenta de linting como pylint"
                                  ],
                                  "tips": "Prefira falhar rápido (fail-fast) com raise em validações iniciais.",
                                  "learningObjective": "Incorporar práticas profissionais para exceções robustas.",
                                  "commonMistakes": [
                                    "Overusing try-except em todo lugar, impactando performance",
                                    "Ignorar finally para fechar arquivos ou conexões"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa de calculadora simples que pede dois números e uma operação (+, -, *, /). Trate ValueError para inputs não numéricos, ZeroDivisionError para divisão por zero, e exiba erro amigável pedindo retry. Exemplo: input 'abc' -> 'Entrada inválida, tente números.'; 10/0 -> 'Divisão por zero não permitida.'",
                              "finalVerifications": [
                                "Programa executa sem crashes em inputs inválidos (letras, zero divisor, vazios).",
                                "Mensagens de erro são claras e instrutivas para o usuário.",
                                "Blocos else e finally são usados corretamente onde aplicável.",
                                "Código trata pelo menos 3 tipos de exceções comuns.",
                                "Testes cobrem 80% dos casos edge (excesso de cenários falhos).",
                                "Código é legível com comentários explicando tratamentos."
                              ],
                              "assessmentCriteria": [
                                "Correção: 0 crashes em testes variados (40%).",
                                "Cobertura: Trata exceções relevantes sem genéricos excessivos (20%).",
                                "Usabilidade: Mensagens amigáveis e retry automático (15%).",
                                "Estrutura: Sintaxe try-except-else-finally bem aplicada (15%).",
                                "Eficiência: Sem try desnecessários ou loops ineficientes (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tratamento de erros em cálculos numéricos e validação de dados.",
                                "Lógica e Debug: Similar a identificação de falhas em experimentos científicos.",
                                "Design de UX: Melhoria de interfaces com feedback de erro humano.",
                                "Segurança da Informação: Prevenção de exploits via inputs maliciosos."
                              ],
                              "realWorldApplication": "Em aplicativos web como formulários de login (tratar senhas inválidas), jogos (inputs de movimento inválidos), ou sistemas bancários (evitar crashes em transações falhas), garantindo estabilidade e experiência positiva do usuário."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Estruturas e Subprogramação",
                        "description": "Tipos de dados escalares e estruturados, subprogramas como funções, passagem de parâmetros, escopo de variáveis, recursividade e ponteiros.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Manipular tipos escalares e estruturados",
                            "description": "Declarar e usar tipos primitivos (int, float, char) e estruturados (arrays, structs) em programas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Declarar Tipos Esculares (Primitivos)",
                                  "subSteps": [
                                    "Estude a definição de tipos escalares: int para inteiros, float para decimais, char para caracteres.",
                                    "Escreva declarações simples: int idade; float altura; char inicial;",
                                    "Compile um programa vazio com essas declarações para verificar sintaxe.",
                                    "Experimente tamanhos típicos: sizeof(int), sizeof(float), sizeof(char).",
                                    "Inicialize variáveis: int idade = 25; float altura = 1.75; char inicial = 'A';"
                                  ],
                                  "verification": "Compilar sem erros um programa que declara e inicializa 3 variáveis escalares diferentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Compilador C (ex: GCC ou online como Replit)",
                                    "Documentação de tipos em C"
                                  ],
                                  "tips": [
                                    "Sempre use ponto-e-vírgula no final das declarações.",
                                    "Lembre-se: float usa notação decimal, int não."
                                  ],
                                  "learningObjective": "Declarar corretamente variáveis de tipos int, float e char com inicialização.",
                                  "commonMistakes": [
                                    "Esquecer ; no final.",
                                    "Usar aspas duplas em char em vez de simples.",
                                    "Confundir float com double."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Usar Tipos Esculares em Operações e Entrada/Saída",
                                  "subSteps": [
                                    "Realize operações aritméticas: soma, subtração, multiplicação com int e float.",
                                    "Use scanf/printf para entrada e saída: leia idade e altura, exiba média.",
                                    "Converta tipos implicitamente: int para float em divisão.",
                                    "Trate entrada de char: leia e exiba um caractere.",
                                    "Crie um programa que calcule IMC usando float altura e int peso."
                                  ],
                                  "verification": "Executar programa que lê dois floats, calcula soma e média, e imprime corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Exemplos de scanf/printf"
                                  ],
                                  "tips": [
                                    "Use %f para float, %d para int, %c para char em printf/scanf.",
                                    "Evite divisão inteira acidental com casts."
                                  ],
                                  "learningObjective": "Manipular tipos escalares em expressões, I/O e conversões.",
                                  "commonMistakes": [
                                    "Não incluir <stdio.h> para I/O.",
                                    "Esquecer & em scanf para variáveis.",
                                    "Divisão int resultando em truncamento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar, Inicializar e Manipular Arrays",
                                  "subSteps": [
                                    "Declare arrays: int numeros[5]; float notas[10];",
                                    "Inicialize: int numeros[5] = {1,2,3,4,5};",
                                    "Acesse elementos: numeros[0] = 10; printf(\"%d\", numeros[2]);",
                                    "Use loops for para percorrer e somar elementos de um array.",
                                    "Crie programa que lê 5 notas em array float e calcula média."
                                  ],
                                  "verification": "Programa que declara array de 5 ints, inicializa, soma via loop e imprime total.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Notas sobre índices de array (0-based)"
                                  ],
                                  "tips": [
                                    "Índices começam em 0, máximo é size-1.",
                                    "Use sizeof(array)/sizeof(array[0]) para tamanho dinâmico."
                                  ],
                                  "learningObjective": "Gerenciar arrays como estruturas de dados homogêneas com acesso e iteração.",
                                  "commonMistakes": [
                                    "Acessar array[5] em array[5] (out-of-bounds).",
                                    "Confundir inicialização {} com atribuição."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir, Declarar e Usar Structs",
                                  "subSteps": [
                                    "Defina struct: struct Aluno { int id; float nota; char nome[20]; };",
                                    "Declare: struct Aluno a1;",
                                    "Inicialize: a1.id = 1; strcpy(a1.nome, \"João\"); a1.nota = 8.5;",
                                    "Acesse membros em arrays de structs ou funções.",
                                    "Crie programa com array de 3 structs Aluno, leia dados e encontre maior nota."
                                  ],
                                  "verification": "Compilar e executar programa que cria 2 structs, atribui valores e imprime campos.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "<string.h> para strcpy"
                                  ],
                                  "tips": [
                                    "Use ponto . para acessar membros.",
                                    "Structs agrupam dados heterogêneos."
                                  ],
                                  "learningObjective": "Criar e manipular tipos estruturados compostos para dados relacionados.",
                                  "commonMistakes": [
                                    "Esquecer ; após definição de struct.",
                                    "Usar = para arrays em structs sem strcpy."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa em C que gerencia uma turma: use struct Aluno com id (int), nome (char[20]), notas[3] (float array). Leia dados de 3 alunos, calcule média por aluno (usando loops em array) e encontre o melhor aluno.",
                              "finalVerifications": [
                                "Compilar sem erros um programa combinando escalares, arrays e structs.",
                                "Executar I/O correto para múltiplas variáveis e estruturas.",
                                "Calcular e exibir resultados precisos (ex: médias sem truncamento).",
                                "Acessar corretamente elementos de arrays e membros de structs.",
                                "Identificar e corrigir erros comuns como out-of-bounds.",
                                "Explicar diferença entre escalar e estruturado em código comentado."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática em declarações e usos (100% compilável).",
                                "Precisão em operações e I/O (resultados exatos).",
                                "Eficiência em loops e acessos (sem desperdício).",
                                "Modularidade: structs bem definidas e usadas.",
                                "Tratamento de erros comuns (casts, bounds).",
                                "Comentários claros explicando cada tipo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas com int/float para cálculos estatísticos.",
                                "Física: Structs para modelar partículas (posição float[3], massa float).",
                                "Biologia: Arrays/structs para sequências genéticas ou dados de espécimes.",
                                "Economia: Arrays de floats para séries temporais de preços."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, tipos escalares gerenciam dados simples como idades/salários; arrays armazenam listas como histórico de transações; structs modelam entidades complexas como perfis de usuário em apps bancários ou jogos (personagem com vida int, posição float[2], itens array)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Criar funções e gerenciar parâmetros",
                            "description": "Definir funções, passar parâmetros por valor e por referência, e entender escopo de variáveis locais e globais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir funções básicas sem parâmetros",
                                  "subSteps": [
                                    "Abra um editor de código e inicie um novo arquivo Python.",
                                    "Escreva a sintaxe básica de uma função usando 'def nome_funcao():'.",
                                    "Adicione uma instrução simples dentro da função, como imprimir uma mensagem.",
                                    "Chame a função no corpo principal do script.",
                                    "Execute o código para testar a execução."
                                  ],
                                  "verification": "A função executa corretamente e produz a saída esperada ao ser chamada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code ou IDLE)",
                                    "Python instalado"
                                  ],
                                  "tips": "Sempre use indentação correta (4 espaços) para o corpo da função.",
                                  "learningObjective": "Compreender a sintaxe e execução de funções básicas sem parâmetros.",
                                  "commonMistakes": [
                                    "Esquecer os dois pontos após o nome da função.",
                                    "Chamar a função antes de defini-la.",
                                    "Erro de indentação no corpo da função."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Passar parâmetros por valor",
                                  "subSteps": [
                                    "Modifique a função para aceitar um parâmetro, ex: 'def saudacao(nome):'.",
                                    "Use o parâmetro dentro da função, como imprimir 'Olá, ' + nome.",
                                    "Chame a função passando um argumento literal, ex: saudacao('João').",
                                    "Teste com diferentes argumentos para verificar reutilização.",
                                    "Analise o comportamento: o parâmetro é copiado, não alterado fora da função."
                                  ],
                                  "verification": "A função recebe e usa corretamente diferentes valores passados como argumentos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python instalado"
                                  ],
                                  "tips": "Parâmetros por valor criam uma cópia local; alterações dentro da função não afetam o original.",
                                  "learningObjective": "Dominar a passagem de parâmetros por valor e sua imutabilidade.",
                                  "commonMistakes": [
                                    "Confundir parâmetro (dentro da função) com argumento (valor passado).",
                                    "Passar número incorreto de argumentos.",
                                    "Tentar modificar números ou strings dentro da função esperando mudança fora."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Passar parâmetros por referência (mutáveis)",
                                  "subSteps": [
                                    "Crie uma função que receba uma lista como parâmetro, ex: 'def adicionar_item(lista, item):'.",
                                    "Modifique a lista dentro da função usando métodos como append().",
                                    "Chame a função passando uma lista e verifique se a modificação persiste fora dela.",
                                    "Compare com passagem por valor testando com strings ou inteiros.",
                                    "Documente o comportamento em comentários no código."
                                  ],
                                  "verification": "Alterações na lista dentro da função refletem fora dela; objetos mutáveis são passados por referência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python instalado"
                                  ],
                                  "tips": "Em Python, listas e dicionários são mutáveis (referência); use .copy() se quiser evitar mudanças.",
                                  "learningObjective": "Entender passagem por referência em objetos mutáveis e suas implicações.",
                                  "commonMistakes": [
                                    "Achar que todos os tipos são passados por valor.",
                                    "Modificar acidentalmente estruturas de dados compartilhadas.",
                                    "Não testar com tipos imutáveis para comparação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar escopo de variáveis locais e globais",
                                  "subSteps": [
                                    "Defina uma variável global fora de qualquer função.",
                                    "Crie uma função que declare uma variável local com o mesmo nome.",
                                    "Acesse e modifique ambas dentro e fora da função.",
                                    "Tente acessar a global dentro da função sem 'global' e observe o erro.",
                                    "Use 'global nome_var' para modificar a global dentro da função e teste."
                                  ],
                                  "verification": "Variáveis locais sombreiam globais; 'global' permite modificação correta da global.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python instalado"
                                  ],
                                  "tips": "Prefira escopo local para evitar efeitos colaterais; use globais com cautela.",
                                  "learningObjective": "Diferenciar e gerenciar escopos local e global de variáveis.",
                                  "commonMistakes": [
                                    "Modificar global sem declarar 'global' dentro da função.",
                                    "Confundir nomes de variáveis locais com globais.",
                                    "Criar dependências desnecessárias em variáveis globais."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma função 'calcula_area_retangulo(largura, altura)' que retorna largura * altura (por valor). Outra função 'modifica_dimensoes(dims)' que adiciona 1cm a uma lista de dimensões [largura, altura] por referência. Use uma variável global 'total_areas = 0' atualizada dentro de funções com 'global'.",
                              "finalVerifications": [
                                "Executar todas as funções sem erros de sintaxe ou escopo.",
                                "Parâmetros por valor não alteram originais; por referência sim (testar com lista).",
                                "Variáveis locais não interferem em globais sem declaração explícita.",
                                "Código é modular e reutilizável com diferentes entradas.",
                                "Saídas correspondem aos cálculos esperados em exemplos múltiplos.",
                                "Nenhum aviso de 'UnboundLocalError' ao acessar variáveis."
                              ],
                              "assessmentCriteria": [
                                "Correta definição e chamada de funções com parâmetros variados.",
                                "Demonstração clara de passagem por valor vs. referência com testes.",
                                "Uso adequado de escopo local/global sem erros.",
                                "Código limpo, comentado e indentado corretamente.",
                                "Reutilização de funções em um programa maior.",
                                "Identificação e correção de erros comuns de escopo/parâmetros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções como mapeamento de entradas para saídas (funções matemáticas).",
                                "Lógica: Conceitos de modularidade semelhantes a provas por casos.",
                                "Física/Engenharia: Modelagem de sistemas com sub-rotinas (ex: simulações).",
                                "Língua Portuguesa: Nomenclatura clara de funções como redação técnica."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, funções com parâmetros permitem código modular e reutilizável, como em apps web (APIs com parâmetros), jogos (movimentos de personagens por referência) ou análise de dados (funções que modificam datasets globais), reduzindo redundância e facilitando manutenção em equipes."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Implementar recursividade e ponteiros",
                            "description": "Desenvolver funções recursivas para problemas como fatorial e compreender ponteiros para manipulação de endereços de memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Recursividade",
                                  "subSteps": [
                                    "Estude a definição de recursão: uma função que chama a si mesma.",
                                    "Identifique o caso base (condição de parada) e o caso recursivo.",
                                    "Analise exemplos simples como soma de números de 1 a n.",
                                    "Desenhe o fluxo de chamadas recursivas em papel.",
                                    "Compare recursão com iteração para entender trade-offs."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é recursão, identificando caso base e recursivo em um exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Papel e caneta para diagramas",
                                    "Documentação de C sobre funções"
                                  ],
                                  "tips": "Sempre comece pelo caso base para evitar loops infinitos.",
                                  "learningObjective": "Dominar os fundamentos teóricos da recursividade para implementação segura.",
                                  "commonMistakes": [
                                    "Esquecer o caso base",
                                    "Não considerar o tamanho da pilha de chamadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Função Recursiva para Fatorial",
                                  "subSteps": [
                                    "Escreva a assinatura da função: int fatorial(int n).",
                                    "Implemente o caso base: se n <= 1, retorne 1.",
                                    "Adicione a chamada recursiva: return n * fatorial(n-1).",
                                    "Teste com valores pequenos (0 a 5) no main().",
                                    "Compile e execute, verificando saídas esperadas."
                                  ],
                                  "verification": "Código compila e produz resultados corretos para n=0,1,3,5.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Compilador C (GCC)",
                                    "Editor como VS Code ou Dev-C++"
                                  ],
                                  "tips": "Use printf para debugar chamadas recursivas e ver a pilha.",
                                  "learningObjective": "Desenvolver e testar uma função recursiva prática.",
                                  "commonMistakes": [
                                    "Retornar 0 no caso base",
                                    "Chamar fatorial(n) em vez de fatorial(n-1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introdução aos Conceitos de Ponteiros",
                                  "subSteps": [
                                    "Aprenda a sintaxe: int *p; para declarar ponteiro.",
                                    "Entenda endereço (&) e desreferência (*).",
                                    "Escreva código para atribuir endereço de uma variável a um ponteiro.",
                                    "Modifique valor via ponteiro e observe mudanças.",
                                    "Explore aritmética de ponteiros (p++)."
                                  ],
                                  "verification": "Crie programa que altera valor de variável via ponteiro e imprime antes/depois.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Debugger como GDB opcional"
                                  ],
                                  "tips": "Visualize memória com diagramas: var | endereço | ponteiro.",
                                  "learningObjective": "Compreender manipulação de endereços de memória via ponteiros.",
                                  "commonMistakes": [
                                    "Desreferenciar ponteiro não inicializado",
                                    "Confundir & e *"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Recursividade com Ponteiros",
                                  "subSteps": [
                                    "Modifique fatorial para usar ponteiro de saída: void fatorial(int n, int *resultado).",
                                    "No caso base: *resultado = 1.",
                                    "No recursivo: chame fatorial(n-1, resultado); *resultado *= n.",
                                    "Teste passando endereço de variável no main().",
                                    "Analise pilha de chamadas com ponteiros."
                                  ],
                                  "verification": "Função altera valor via ponteiro corretamente para múltiplos testes.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Exemplos de código anteriores"
                                  ],
                                  "tips": "Ponteiros evitam cópias desnecessárias em funções recursivas profundas.",
                                  "learningObjective": "Aplicar ponteiros em contextos recursivos para manipulação eficiente de memória.",
                                  "commonMistakes": [
                                    "Passar valor em vez de endereço",
                                    "Não desreferenciar corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma função recursiva que calcule o fatorial de um número inteiro positivo e armazene o resultado em um ponteiro fornecido, evitando overflow com verificações básicas. Teste com entrada 5, esperando saída 120.",
                              "finalVerifications": [
                                "Explica corretamente caso base e recursivo em funções.",
                                "Implementa fatorial recursivo sem erros de compilação ou runtime.",
                                "Manipula ponteiros para alterar variáveis externamente.",
                                "Integra recursão e ponteiros em função funcional.",
                                "Identifica e corrige stack overflow em recursão profunda.",
                                "Debuga código recursivo usando prints ou debugger."
                              ],
                              "assessmentCriteria": [
                                "Código compila sem warnings em C padrão.",
                                "Saídas corretas para casos de teste (0-10).",
                                "Eficiência: evita recursão infinita e overflow básico.",
                                "Comentários claros explicando recursão e ponteiros.",
                                "Modularidade: funções bem definidas e reutilizáveis.",
                                "Tratamento de erros: valida entrada n >= 0."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de fatorial e sequências.",
                                "Algoritmos: Comparação recursivo vs. iterativo.",
                                "Estruturas de Dados: Preparação para árvores e grafos recursivos.",
                                "Sistemas Operacionais: Gerenciamento de pilha de execução.",
                                "Lógica: Raciocínio indutivo em provas recursivas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, recursão com ponteiros é usada em parsing de árvores (compiladores), busca em grafos (redes sociais), gerenciamento de memória dinâmica (jogos e simulações), e algoritmos de divide-and-conquer como quicksort otimizado."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Lógica de Programação",
                "description": "Introduz os princípios da lógica de programação como base para o desenvolvimento de soluções computacionais.",
                "totalSkills": 59,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Definição de Algoritmo e Programa",
                    "description": "Conceitos fundamentais de algoritmo como sequência lógica de passos, programa como implementação em linguagem de programação, e papel do compilador.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Algoritmo",
                        "description": "Conceito fundamental de um algoritmo como uma sequência lógica, finita e ordenada de instruções ou passos bem definidos para resolver um problema específico, independentemente de uma linguagem de programação.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Definir algoritmo",
                            "description": "Explicar as características principais de um algoritmo: finitude (passos limitados), definitividade (instruções precisas), efetividade (passos executáveis) e presença de entradas e saídas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de algoritmo",
                                  "subSteps": [
                                    "Ler a definição formal de algoritmo como uma sequência de instruções para resolver um problema.",
                                    "Identificar exemplos cotidianos de algoritmos, como receitas de cozinha ou instruções de montagem.",
                                    "Diferenciar algoritmo de um programa de computador.",
                                    "Anotar a importância dos algoritmos na computação.",
                                    "Discutir em voz alta ou escrever por que algoritmos são fundamentais na lógica de programação."
                                  ],
                                  "verification": "Escrever uma definição pessoal de algoritmo em 2-3 frases e compará-la com a definição padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook e caneta",
                                    "Vídeo introdutório sobre algoritmos (ex: Khan Academy)",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Use analogias do dia a dia para fixar o conceito, como 'receita de bolo'.",
                                  "learningObjective": "Reconhecer o algoritmo como uma sequência lógica de passos para resolver problemas.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com código de programação",
                                    "Pensar que algoritmos são infinitos ou vagos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a característica de finitude",
                                  "subSteps": [
                                    "Definir finitude como o número limitado de passos para terminar a execução.",
                                    "Analisar exemplos onde falta finitude leva a loops infinitos.",
                                    "Criar um exemplo simples de algoritmo finito, como somar dois números.",
                                    "Contar os passos em uma receita e verificar se é finita.",
                                    "Explicar consequências de algoritmos não finitos."
                                  ],
                                  "verification": "Listar 3 exemplos de processos finitos e 1 infinito, justificando.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Exemplos impressos de receitas"
                                  ],
                                  "tips": "Sempre pergunte: 'O processo para?' para verificar finitude.",
                                  "learningObjective": "Identificar e justificar a finitude como propriedade essencial de um algoritmo.",
                                  "commonMistakes": [
                                    "Ignorar loops condicionais como potencialmente infinitos",
                                    "Achar que mais passos = menos finito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar definitividade e efetividade",
                                  "subSteps": [
                                    "Definir definitividade: cada passo deve ser preciso e sem ambiguidades.",
                                    "Exemplificar efetividade: cada passo deve ser simples e executável por humanos ou máquinas.",
                                    "Reescrever instruções vagas para torná-las definitivas, ex: 'cozinhe' → 'cozinhe por 10 minutos a 180°C'.",
                                    "Testar efetividade simulando execução manual de um algoritmo.",
                                    "Comparar algoritmos definitivos vs. indefinidos em cenários reais."
                                  ],
                                  "verification": "Reescrever 2 instruções vagas em definitivas e efetivas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de instruções vagas (preparada)",
                                    "Cronômetro para simulação"
                                  ],
                                  "tips": "Pergunte 'O que isso significa exatamente?' para cada passo.",
                                  "learningObjective": "Aplicar definitividade e efetividade na construção de instruções precisas.",
                                  "commonMistakes": [
                                    "Usar termos subjetivos como 'bem' ou 'rápido'",
                                    "Subestimar simplicidade na efetividade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar entradas, saídas e sintetizar a definição",
                                  "subSteps": [
                                    "Explicar entradas como dados iniciais necessários e saídas como resultados finais.",
                                    "Mapear entradas/saídas em um exemplo, como 'entrada: números a,b; saída: soma'.",
                                    "Criar um fluxograma simples mostrando entradas, passos e saídas.",
                                    "Sintetizar todas as características em uma definição completa.",
                                    "Validar com um colega ou autoavaliação."
                                  ],
                                  "verification": "Desenhar fluxograma de um algoritmo simples com entradas/saídas rotuladas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma online (ex: Draw.io)",
                                    "Exemplos de fluxogramas"
                                  ],
                                  "tips": "Sempre rotule entradas no início e saídas no fim.",
                                  "learningObjective": "Integrar entradas/saídas às características principais para uma definição holística.",
                                  "commonMistakes": [
                                    "Omitir entradas/saídas",
                                    "Confundir saídas intermediárias com finais"
                                  ]
                                }
                              ],
                              "practicalExample": "Algoritmo para calcular a média de duas notas: 1. Entrada: nota1, nota2. 2. Soma = nota1 + nota2 (definitivo e efetivo). 3. Média = Soma / 2. 4. Saída: Média. (Finito: 4 passos limitados).",
                              "finalVerifications": [
                                "Listar corretamente as quatro características principais: finitude, definitividade, efetividade, entradas/saídas.",
                                "Explicar cada característica com um exemplo pessoal.",
                                "Identificar entradas e saídas em um algoritmo dado.",
                                "Diferenciar algoritmo válido de inválido justificando.",
                                "Criar um algoritmo simples atendendo todas as características.",
                                "Desenhar fluxograma básico de um algoritmo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição das características (100% cobertura).",
                                "Uso de exemplos concretos e relevantes.",
                                "Capacidade de identificar falhas em algoritmos incompletos.",
                                "Clareza na explicação oral ou escrita.",
                                "Aplicação correta de entradas/saídas.",
                                "Criatividade em analogias cotidianas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências lógicas e resolução de problemas passo a passo.",
                                "Língua Portuguesa: Redação técnica clara e sem ambiguidades.",
                                "Ciências: Métodos experimentais com hipóteses, procedimentos e resultados.",
                                "Artes: Criação de fluxogramas visuais.",
                                "História: Evolução de instruções em civilizações antigas (ex: receitas egípcias)."
                              ],
                              "realWorldApplication": "Algoritmos definem rotas em apps de GPS (entradas: origem/destino; saídas: trajeto otimizado), receitas em culinária profissional e processos automatizados em fábricas, garantindo eficiência e precisão em indústrias como software e logística."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Identificar propriedades de um algoritmo",
                            "description": "Reconhecer e listar as propriedades essenciais de um algoritmo, como independência de linguagem e capacidade de ser representado em pseudocódigo ou fluxogramas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição básica de algoritmo",
                                  "subSteps": [
                                    "Leia a definição formal de algoritmo: uma sequência finita de instruções bem definidas para resolver um problema.",
                                    "Identifique os elementos chave: entrada, processamento e saída.",
                                    "Compare com exemplos cotidianos, como uma receita de bolo.",
                                    "Anote a importância da finitude e definitude.",
                                    "Discuta por que algoritmos são fundamentais na computação."
                                  ],
                                  "verification": "Escreva uma definição pessoal de algoritmo em suas próprias palavras e compare com fontes confiáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Lógica de Programação",
                                    "Vídeo introdutório sobre algoritmos (YouTube ou Khan Academy)",
                                    "Caderno para anotações"
                                  ],
                                  "tips": [
                                    "Use analogias simples como 'receita de cozinha' para fixar o conceito.",
                                    "Evite confundir algoritmo com programa pronto."
                                  ],
                                  "learningObjective": "Entender o que constitui um algoritmo e seus elementos essenciais.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com código em linguagem específica.",
                                    "Ignorar a finitude das instruções.",
                                    "Pensar que algoritmos são apenas para computadores."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar e memorizar propriedades essenciais",
                                  "subSteps": [
                                    "Liste as propriedades principais: finitude, definitude, eficácia, entradas/saídas finitas, independência de linguagem.",
                                    "Explique cada uma: finitude (passos terminam), definitude (instruções claras), etc.",
                                    "Crie um quadro comparativo com exemplos de propriedades violadas.",
                                    "Repita a lista verbalmente 3 vezes.",
                                    "Teste-se com flashcards personalizados."
                                  ],
                                  "verification": "Recite as 5 propriedades principais sem consultar notas e forneça um exemplo para cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Flashcards (app como Anki ou papel)",
                                    "Quadro branco ou papel para tabela",
                                    "Referência: slide ou PDF sobre propriedades de algoritmos"
                                  ],
                                  "tips": [
                                    "Associe cada propriedade a uma cor para memorização visual.",
                                    "Use mnemônicos como 'FDEFI' para finitude, definitude, eficácia, finitas I/O, independência."
                                  ],
                                  "learningObjective": "Memorizar e explicar as propriedades fundamentais de um algoritmo.",
                                  "commonMistakes": [
                                    "Omitir a independência de linguagem.",
                                    "Confundir eficácia com eficiência.",
                                    "Listar propriedades irrelevantes como 'velocidade'."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar representações de algoritmos",
                                  "subSteps": [
                                    "Estude pseudocódigo: escreva um exemplo simples para somar dois números.",
                                    "Desenhe um fluxograma para o mesmo exemplo usando símbolos padrão.",
                                    "Compare as duas representações e note semelhanças.",
                                    "Converta um fluxograma dado em pseudocódigo.",
                                    "Identifique como essas representações destacam as propriedades."
                                  ],
                                  "verification": "Crie pseudocódigo e fluxograma para um problema simples e verifique se ambos exibem todas as propriedades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma online (Draw.io ou Lucidchart)",
                                    "Editor de texto para pseudocódigo",
                                    "Exemplos de fluxogramas impressos"
                                  ],
                                  "tips": [
                                    "Comece com problemas triviais para praticar.",
                                    "Use setas claras no fluxograma para mostrar fluxo."
                                  ],
                                  "learningObjective": "Reconhecer como algoritmos podem ser representados independentemente de linguagens.",
                                  "commonMistakes": [
                                    "Usar sintaxe de programação real no pseudocódigo.",
                                    "Fluxogramas confusos sem símbolos padrão.",
                                    "Ignorar loops ou decisões nas representações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em exemplos reais",
                                  "subSteps": [
                                    "Analise 3 exemplos de algoritmos: busca linear, ordenação borbulha, receita simples.",
                                    "Para cada um, liste as propriedades presentes.",
                                    "Identifique exemplos que NÃO são algoritmos (ex: instruções infinitas) e justifique.",
                                    "Crie um algoritmo próprio simples e autoavalie suas propriedades.",
                                    "Discuta com um par ou grave uma explicação.",
                                    "verification]: "
                                  ]
                                }
                              ],
                              "estimatedTime": "35 minutos",
                              "materials": [
                                "Exemplos de algoritmos impressos ou digitais",
                                "Ferramenta de desenho para fluxogramas",
                                "Gravador de áudio para autoexplicação"
                              ],
                              "tips": [
                                "Escolha exemplos variados: computacionais e não-computacionais.",
                                "Sempre pergunte: 'Isso termina? É claro? Independente?'"
                              ],
                              "learningObjective": "Aplicar o conhecimento para identificar propriedades em contextos variados.",
                              "commonMistakes": [
                                "Classificar programas como algoritmos sem verificar propriedades.",
                                "Não justificar ausências de propriedades.",
                                "Overcomplicar exemplos simples."
                              ]
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Exemplificar algoritmos cotidianos",
                            "description": "Fornecer e analisar exemplos simples de algoritmos na vida diária, como passos para escovar os dentes ou calcular a média de notas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de algoritmo e sua relação com rotinas diárias",
                                  "subSteps": [
                                    "Defina algoritmo como uma sequência finita de instruções bem definidas para resolver um problema.",
                                    "Discuta características: finitude, definitividade, efetividade e entrada/saída.",
                                    "Identifique rotinas diárias como potenciais algoritmos (ex: preparar café).",
                                    "Compare com receitas de cozinha ou instruções de montagem.",
                                    "Anote 2-3 exemplos pessoais de rotinas diárias."
                                  ],
                                  "verification": "Escreva uma definição curta e liste 3 exemplos cotidianos que se encaixem no conceito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto simples"
                                  ],
                                  "tips": "Use analogias simples como 'receita de bolo' para fixar o conceito.",
                                  "learningObjective": "Compreender os elementos fundamentais de um algoritmo e reconhecê-los em atividades cotidianas.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com programa de computador; ignorar a necessidade de sequencialidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e decompor uma atividade cotidiana em passos sequenciais",
                                  "subSteps": [
                                    "Escolha uma atividade simples (ex: escovar os dentes ou calcular média de notas).",
                                    "Liste todos os passos envolvidos, do início ao fim.",
                                    "Ordene os passos logicamente, garantindo sequencialidade.",
                                    "Identifique entradas (ex: dentes sujos, notas) e saídas (ex: dentes limpos, média calculada).",
                                    "Revise para eliminar ambiguidades ou passos desnecessários."
                                  ],
                                  "verification": "Crie uma lista numerada de pelo menos 5 passos claros para a atividade escolhida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel, caneta ou ferramenta digital como Google Docs"
                                  ],
                                  "tips": "Pense como se estivesse explicando para uma criança de 5 anos: seja explícito.",
                                  "learningObjective": "Decompor tarefas reais em sequências lógicas de ações.",
                                  "commonMistakes": [
                                    "Pular passos implícitos; incluir decisões condicionais prematuramente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar a atividade como um algoritmo formal",
                                  "subSteps": [
                                    "Escreva o algoritmo em pseudocódigo ou lista numerada.",
                                    "Inclua entradas, processamento e saídas explicitamente.",
                                    "Desenhe um fluxograma simples se possível (caixas para ações, setas para fluxo).",
                                    "Teste o algoritmo simulando a execução passo a passo.",
                                    "Ajuste com base no teste para garantir completude."
                                  ],
                                  "verification": "Produza um pseudocódigo ou fluxograma executável sem erros para o exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online como Draw.io ou papel quadriculado"
                                  ],
                                  "tips": "Mantenha simples: evite loops ou condições complexas no primeiro exemplo.",
                                  "learningObjective": "Formalizar rotinas cotidianas em representações algorítmicas padronizadas.",
                                  "commonMistakes": [
                                    "Esquecer saídas; fazer passos vagos ou não sequenciais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o algoritmo criado",
                                  "subSteps": [
                                    "Avalie precisão: todos os passos levam à saída correta?",
                                    "Verifique eficiência: há passos redundantes?",
                                    "Identifique possíveis melhorias ou variações.",
                                    "Compare com outro exemplo para destacar semelhanças/diferenças.",
                                    "Documente a análise em 3-5 pontos chave."
                                  ],
                                  "verification": "Escreva um relatório curto de análise com prós, contras e sugestões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documento de texto para análise"
                                  ],
                                  "tips": "Pergunte: 'O que acontece se um passo for pulado?' para testar robustez.",
                                  "learningObjective": "Desenvolver habilidades críticas de análise algorítmica em contextos reais.",
                                  "commonMistakes": [
                                    "Análise superficial; ignorar cenários de erro."
                                  ]
                                }
                              ],
                              "practicalExample": "Algoritmo para calcular a média de 3 notas: 1. Entrada: nota1, nota2, nota3. 2. Soma = nota1 + nota2 + nota3. 3. Média = Soma / 3. 4. Saída: exiba Média. Análise: Preciso e eficiente para notas fixas; pode ser otimizado para mais notas com loop.",
                              "finalVerifications": [
                                "Pode listar e decompor pelo menos 3 atividades cotidianas em algoritmos.",
                                "Cria representações claras (pseudocódigo ou fluxograma) sem ambiguidades.",
                                "Analisa corretamente precisão, eficiência e melhorias possíveis.",
                                "Explica verbalmente um exemplo para um colega sem hesitação.",
                                "Identifica entradas/saídas em qualquer rotina diária proposta."
                              ],
                              "assessmentCriteria": [
                                "Clareza e sequencialidade dos passos (nota 1-5).",
                                "Completude: inclusão de entradas/saídas e verificações.",
                                "Precisão na análise: identificação de forças e fraquezas.",
                                "Criatividade nos exemplos cotidianos escolhidos.",
                                "Capacidade de formalização (pseudocódigo/fluxograma legível)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e operações aritméticas básicas.",
                                "Língua Portuguesa: Redação clara e instrucional de passos.",
                                "Ciências: Processos biológicos como digestão (algoritmo natural).",
                                "Educação Física: Rotinas de exercícios em sequências lógicas."
                              ],
                              "realWorldApplication": "Modelar processos empresariais (ex: fluxo de caixa), automação de tarefas domésticas via apps ou desenvolvimento de software que simula comportamentos humanos cotidianos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Programa",
                        "description": "Implementação concreta de um algoritmo utilizando comandos de uma linguagem de programação específica, resultando em código executável pelo computador.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Definir programa de computador",
                            "description": "Descrever um programa como a tradução de um algoritmo para sintaxe de uma linguagem de programação, incluindo código-fonte e sua execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a relação entre algoritmo e programa",
                                  "subSteps": [
                                    "Revise a definição de algoritmo como uma sequência finita de instruções lógicas para resolver um problema.",
                                    "Identifique que um programa é a implementação prática desse algoritmo em uma linguagem de programação.",
                                    "Compare exemplos simples: algoritmo em pseudocódigo vs. programa em código real.",
                                    "Anote as diferenças principais: abstração vs. sintaxe específica.",
                                    "Discuta por que a tradução é necessária para execução em máquina."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a relação e forneça um exemplo simples de algoritmo e seu programa equivalente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno, acesso a documentação básica de algoritmos, exemplos de pseudocódigo online.",
                                  "tips": "Use diagramas de fluxo para visualizar a transição de algoritmo para programa.",
                                  "learningObjective": "Entender conceitualmente como um programa é a concretização de um algoritmo.",
                                  "commonMistakes": "Confundir algoritmo com programa, ignorando a necessidade de sintaxe específica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar sintaxe de uma linguagem de programação",
                                  "subSteps": [
                                    "Escolha uma linguagem simples como Python e revise elementos básicos: variáveis, funções, loops, condicionais.",
                                    "Estude regras de sintaxe: indentação, ponto e vírgula, declarações de função.",
                                    "Compare sintaxe de Python com pseudocódigo de um algoritmo conhecido.",
                                    "Pratique escrevendo trechos de código que sigam sintaxe correta sem lógica completa.",
                                    "Identifique compiladores/interpretes que validam a sintaxe."
                                  ],
                                  "verification": "Escreva 3 linhas de código Python válidas para declarar variáveis e uma função simples, sem erros de sintaxe.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código online (Replit ou Python IDLE), documentação oficial do Python.",
                                  "tips": "Sempre teste sintaxe em um interpretador para feedback imediato.",
                                  "learningObjective": "Dominar os fundamentos da sintaxe para traduzir algoritmos com precisão.",
                                  "commonMistakes": "Ignorar regras de indentação ou usar palavras reservadas incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Traduzir algoritmo em código-fonte e descrever execução",
                                  "subSteps": [
                                    "Selecione um algoritmo simples, como calcular soma de dois números.",
                                    "Traduza passo a passo para código-fonte: def soma(a, b): return a + b; print(soma(3,5)).",
                                    "Explique o código-fonte: estrutura, comentários e lógica.",
                                    "Descreva execução: carregamento na memória, interpretação linha a linha, saída.",
                                    "Execute o código e anote o fluxo de execução."
                                  ],
                                  "verification": "Produza código-fonte completo de um algoritmo simples e descreva sua execução em 5-7 frases.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Computador com Python instalado, editor de código, debugger simples.",
                                  "tips": "Adicione comentários no código para mapear cada parte do algoritmo.",
                                  "learningObjective": "Capacitar a criação de código-fonte funcional a partir de algoritmos.",
                                  "commonMistakes": "Traduzir literalmente sem adaptar à sintaxe, causando erros de runtime."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a definição completa de programa de computador",
                                  "subSteps": [
                                    "Integre conceitos: programa = tradução de algoritmo + sintaxe + código-fonte + execução.",
                                    "Escreva uma definição formal em 100-150 palavras.",
                                    "Crie um fluxograma mostrando o processo completo.",
                                    "Compare com exemplos reais de programas (ex: calculadora em app).",
                                    "Revise e refine a definição para clareza e precisão."
                                  ],
                                  "verification": "Apresente uma definição escrita e um fluxograma que cubram todos os elementos chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de fluxograma (Draw.io ou papel), rascunho anterior.",
                                  "tips": "Use linguagem acessível, evitando jargões desnecessários.",
                                  "learningObjective": "Formular uma definição abrangente e precisa de programa de computador.",
                                  "commonMistakes": "Omitir a fase de execução ou focar só no código sem contexto algorítmico."
                                }
                              ],
                              "practicalExample": "Algoritmo: 1. Receba dois números. 2. Calcule soma. 3. Mostre resultado. Código-fonte Python: def calcular_soma(a, b): return a + b; resultado = calcular_soma(5, 3); print('Soma:', resultado). Execução: Interpretador lê def, armazena função; chama com 5 e 3, computa 8, imprime 'Soma: 8'.",
                              "finalVerifications": [
                                "Pode definir programa incluindo tradução de algoritmo?",
                                "Explica corretamente código-fonte e sintaxe?",
                                "Descreve processo de execução passo a passo?",
                                "Fornece exemplo prático funcional?",
                                "Diferencia programa de algoritmo claramente?",
                                "Integra todos os elementos em uma definição coesa?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na definição (90% alinhado com descrição oficial).",
                                "Qualidade da tradução algoritmo-código (sem erros de sintaxe).",
                                "Detalhe na descrição de execução (fluxo lógico completo).",
                                "Clareza e estrutura na explicação escrita.",
                                "Uso de exemplo relevante e executável.",
                                "Profundidade nos passos de aprendizado (substeps completos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de algoritmos numéricos em código.",
                                "Língua Portuguesa: Redação clara de definições e comentários em código.",
                                "Física: Simulação de processos computacionais como execução sequencial.",
                                "Artes: Criação de fluxogramas visuais para processos."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, engenheiros traduzem requisitos de negócios (algoritmos) em código-fonte executável, como apps de banco que calculam juros ou jogos que processam física em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Diferenciar algoritmo de programa",
                            "description": "Comparar algoritmo (abstração lógica) com programa (implementação técnica), destacando que o algoritmo precede o programa e é independente de hardware.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de Algoritmo",
                                  "subSteps": [
                                    "Ler a definição formal de algoritmo como uma sequência finita de instruções lógicas para resolver um problema.",
                                    "Identificar características principais: finitude, definitividade, efetividade e independência de linguagem ou hardware.",
                                    "Analisar exemplos cotidianos, como uma receita de bolo.",
                                    "Escrever uma definição em palavras próprias.",
                                    "Listar 3 propriedades essenciais de um algoritmo."
                                  ],
                                  "verification": "Capaz de explicar o que é um algoritmo e listar suas propriedades sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeo introdutório sobre algoritmos (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias do dia a dia, como navegação por GPS, para fixar o conceito.",
                                  "learningObjective": "Dominar a definição e propriedades fundamentais de um algoritmo.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com código executável",
                                    "Ignorar a independência de hardware"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a definição de Programa",
                                  "subSteps": [
                                    "Ler a definição de programa como a implementação concreta de um algoritmo em uma linguagem de programação específica.",
                                    "Identificar características: dependência de hardware/software, sintaxe rigorosa e executabilidade em máquina.",
                                    "Comparar com exemplos, como código Python para calcular média de notas.",
                                    "Escrever uma definição em palavras próprias.",
                                    "Listar 3 diferenças iniciais em relação ao algoritmo."
                                  ],
                                  "verification": "Capaz de descrever um programa e sua relação com hardware sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Exemplos de códigos básicos online"
                                  ],
                                  "tips": "Lembre-se: programa é o 'como fazer na prática' em uma linguagem específica.",
                                  "learningObjective": "Entender o programa como implementação técnica de um algoritmo.",
                                  "commonMistakes": [
                                    "Achar que programa e algoritmo são sinônimos",
                                    "Subestimar a dependência de linguagem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar as Principais Diferenças",
                                  "subSteps": [
                                    "Criar uma tabela comparativa: algoritmo (abstração lógica) vs programa (implementação técnica).",
                                    "Destacar: algoritmo precede o programa; algoritmo é independente de hardware; programa requer compilação/execução.",
                                    "Discutir sequência: planejar algoritmo → codificar programa.",
                                    "Preencher tabela com pelo menos 5 diferenças.",
                                    "Explicar verbalmente para um parceiro ou gravar áudio."
                                  ],
                                  "verification": "Tabela comparativa completa e precisa com pelo menos 5 diferenças corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Infográfico comparativo impresso"
                                  ],
                                  "tips": "Foque na hierarquia: algoritmo é o 'plano', programa é a 'execução'.",
                                  "learningObjective": "Diferenciar claramente algoritmo de programa em aspectos chave.",
                                  "commonMistakes": [
                                    "Inverter a ordem: achar que programa precede algoritmo",
                                    "Ignorar abstração do algoritmo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Exemplos Práticos",
                                  "subSteps": [
                                    "Escolher um problema simples (ex: somar dois números).",
                                    "Escrever o algoritmo em pseudocódigo.",
                                    "Implementar o mesmo como programa em pseudolinguagem ou Python básico.",
                                    "Comparar os dois lado a lado.",
                                    "Analisar o que muda ao passar de algoritmo para programa."
                                  ],
                                  "verification": "Produzir algoritmo e programa para o mesmo problema, destacando diferenças.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Pseudocódigo template",
                                    "Ambiente online como Replit para teste"
                                  ],
                                  "tips": "Mantenha o exemplo simples para focar na diferenciação, não na complexidade.",
                                  "learningObjective": "Aplicar diferenciação em um caso concreto.",
                                  "commonMistakes": [
                                    "Misturar sintaxe de programação no algoritmo",
                                    "Criar programa sem base algorítmica"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Calcular o troco em uma compra. Algoritmo: 1. Receber valor pago e total; 2. Subtrair total de pago; 3. Retornar diferença. Programa: Em Python - def calcular_troco(pago, total): return pago - total (executável em máquina específica).",
                              "finalVerifications": [
                                "Explicar em 1 minuto a diferença principal entre algoritmo e programa.",
                                "Listar 4 características exclusivas de cada um.",
                                "Converter um algoritmo simples em programa e vice-versa.",
                                "Identificar em um texto qual é algoritmo e qual é programa.",
                                "Criar tabela comparativa sem erros.",
                                "Responder quiz com 90% de acerto sobre conceitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem confusões conceituais).",
                                "Correta ênfase na precedência do algoritmo sobre o programa.",
                                "Identificação clara da independência de hardware no algoritmo.",
                                "Uso de exemplos relevantes e comparativos.",
                                "Compreensão da abstração lógica vs implementação técnica.",
                                "Capacidade de aplicar em novos contextos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica sequencial e estruturas condicionais.",
                                "Língua Portuguesa: Redação clara de instruções em pseudocódigo.",
                                "Física: Modelagem de processos passo a passo em experimentos.",
                                "Artes: Fluxogramas como representação visual de algoritmos."
                              ],
                              "realWorldApplication": "No desenvolvimento de apps, engenheiros primeiro criam algoritmos para otimizar rotas (ex: Google Maps) antes de codificar em linguagens como Java, garantindo eficiência independente de dispositivos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Relacionar programa com lógica de programação",
                            "description": "Explicar como a lógica de programação serve de ponte entre algoritmo e programa, utilizando estruturas como sequenciais, condicionais e repetitivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e Diferenciar Conceitos Fundamentais",
                                  "subSteps": [
                                    "Pesquise definições de algoritmo, lógica de programação e programa.",
                                    "Crie um diagrama comparativo destacando semelhanças e diferenças.",
                                    "Explique verbalmente ou por escrito como a lógica atua como ponte.",
                                    "Identifique exemplos cotidianos para cada conceito.",
                                    "Registre notas sobre a sequência: algoritmo → lógica → programa."
                                  ],
                                  "verification": "Diagrama completo e explicação escrita ou gravada sem erros conceituais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, caneta ou ferramenta digital como Draw.io; acesso a internet para referências.",
                                  "tips": "Use analogias como receita (algoritmo), instruções claras (lógica) e livro de receitas pronto (programa).",
                                  "learningObjective": "Compreender as diferenças e a relação hierárquica entre algoritmo, lógica de programação e programa.",
                                  "commonMistakes": "Confundir algoritmo com programa ou ignorar o papel intermediário da lógica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Estruturas da Lógica de Programação",
                                  "subSteps": [
                                    "Estude estruturas sequenciais: execução linear de comandos.",
                                    "Analise condicionais: if-else para decisões.",
                                    "Examine repetitivas: loops como while e for para iterações.",
                                    "Crie fluxogramas simples para cada estrutura.",
                                    "Compare como essas estruturas resolvem problemas reais."
                                  ],
                                  "verification": "Fluxogramas corretos para pelo menos uma estrutura de cada tipo, com legendas explicativas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de fluxograma (Lucidchart ou papel); exemplos de pseudocódigo.",
                                  "tips": "Comece com problemas simples como 'verificar se número é par' para condicionais.",
                                  "learningObjective": "Identificar e descrever as três estruturas principais da lógica de programação.",
                                  "commonMistakes": "Misturar condicionais com repetitivas ou esquecer fluxos de decisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Lógica para Sintaxe de Programa",
                                  "subSteps": [
                                    "Escolha uma linguagem simples como Python ou pseudocódigo.",
                                    "Traduza um fluxograma sequencial para código.",
                                    "Converta estruturas condicionais e repetitivas em sintaxe real.",
                                    "Compare o pseudocódigo lógico com o código final.",
                                    "Teste o código para validar a tradução."
                                  ],
                                  "verification": "Códigos funcionais para cada estrutura, com comentários explicando a ponte lógica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código online (Replit ou VS Code); documentação de Python básica.",
                                  "tips": "Use print statements para visualizar o fluxo durante testes.",
                                  "learningObjective": "Traduzir estruturas lógicas em elementos sintáticos de um programa.",
                                  "commonMistakes": "Erros de indentação em loops ou esquecer condições booleanas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Conceitos em um Exemplo Completo",
                                  "subSteps": [
                                    "Desenvolva um algoritmo para um problema como 'calcular média de notas'.",
                                    "Escreva a lógica com todas as estruturas.",
                                    "Implemente como programa executável.",
                                    "Documente a ponte em um relatório curto.",
                                    "Execute e depure o programa."
                                  ],
                                  "verification": "Programa funcional com relatório explicando a relação algoritmo-lógica-programa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código; papel para esboço inicial.",
                                  "tips": "Inclua entrada de usuário para tornar interativo.",
                                  "learningObjective": "Aplicar a relação completa em um caso prático.",
                                  "commonMistakes": "Pular depuração, levando a programas que não refletem a lógica corretamente."
                                }
                              ],
                              "practicalExample": "Desenvolver um programa que calcula a média de 3 notas de um aluno, usando sequência para entrada/saída, condicional para aprovar/reprovar (média >=7) e repetitivo para validar notas entre 0-10.",
                              "finalVerifications": [
                                "Explicar verbalmente a ponte lógica entre algoritmo e programa.",
                                "Desenhar fluxograma correto para um problema com todas as estruturas.",
                                "Executar um programa que reflita fielmente uma lógica descrita.",
                                "Identificar erros em um código que não segue a lógica pretendida.",
                                "Comparar pseudocódigo com código real sem discrepâncias.",
                                "Aplicar o conceito a um novo problema simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na definição da ponte lógica (peso 25%).",
                                "Correta identificação e uso de estruturas sequenciais, condicionais e repetitivas (peso 30%).",
                                "Qualidade da tradução lógica para sintaxe de programa (peso 20%).",
                                "Clareza em diagramas, códigos e explicações (peso 15%).",
                                "Criatividade e correção no exemplo prático (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e estruturas algébricas.",
                                "Língua Portuguesa: Redação de pseudocódigo claro e documentação.",
                                "Física: Modelagem de processos sequenciais em experimentos.",
                                "Artes: Criação de fluxogramas visuais."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, como apps de e-commerce que usam lógica para processar pedidos (sequencial para itens, condicional para estoque, repetitivo para descontos), garantindo que algoritmos sejam implementados corretamente em código executável."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Linguagem de Programação e Compilador",
                        "description": "Linguagem de programação como conjunto de regras e comandos para escrever programas; compilador como ferramenta que traduz o código-fonte em linguagem de máquina executável.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Definir linguagem de programação",
                            "description": "Identificar linguagens de programação (ex.: C++, Python) como ferramentas formais para expressar algoritmos em forma de programas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de linguagem de programação",
                                  "subSteps": [
                                    "Leia a definição básica: uma linguagem de programação é um conjunto formal de instruções para computadores.",
                                    "Analise os componentes principais: sintaxe, semântica e pragmática.",
                                    "Estude a evolução histórica breve (ex.: Fortran em 1950s).",
                                    "Identifique o propósito: traduzir ideias humanas em comandos executáveis.",
                                    "Anote os elementos chave em um diagrama mental."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e compare com fontes confiáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook, acesso à internet para artigos introdutórios (ex.: Wikipedia 'Linguagem de programação')",
                                  "tips": "Use analogias como 'idioma para computadores' para fixar o conceito.",
                                  "learningObjective": "Entender linguagem de programação como ferramenta formal de instrução computacional.",
                                  "commonMistakes": "Confundir com software ou aplicativos; foque na formalidade sintática."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar linguagem de programação de linguagens naturais",
                                  "subSteps": [
                                    "Liste características das linguagens naturais: ambiguidade, contexto cultural.",
                                    "Compare com linguagens de programação: precisão, ausência de ambiguidade, regras rígidas.",
                                    "Crie uma tabela comparativa com 4-5 critérios (ex.: interpretabilidade por humanos vs. máquinas).",
                                    "Discuta exemplos: 'correr' em PT natural vs. 'run()' em programação.",
                                    "Reflita sobre por que a precisão é essencial em programação."
                                  ],
                                  "verification": "Preencha a tabela comparativa e explique verbalmente a diferença para um colega.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta ou planilha digital (Google Sheets)",
                                  "tips": "Pense em mal-entendidos em conversas cotidianas para contrastar com código.",
                                  "learningObjective": "Distinguir formalidade e precisão das linguagens formais vs. naturais.",
                                  "commonMistakes": "Ignorar a rigidez sintática; lembre que erros de sintaxe impedem execução."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e classificar exemplos de linguagens de programação",
                                  "subSteps": [
                                    "Liste 5 linguagens populares: Python, C++, Java, JavaScript, C#.",
                                    "Pesquise paradigmas: imperativo (C++), orientado a objetos (Java), funcional (Haskell).",
                                    "Classifique por uso: web (JavaScript), dados (Python), sistemas (C++).",
                                    "Instale um interpretador simples (ex.: Python online via Replit).",
                                    "Execute um 'Hello World' em duas linguagens diferentes."
                                  ],
                                  "verification": "Crie uma lista classificada e rode os códigos de exemplo sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Navegador web, plataformas online como Replit ou CodePen",
                                  "tips": "Comece com Python por sua sintaxe simples e legível.",
                                  "learningObjective": "Reconhecer linguagens específicas e suas aplicações iniciais.",
                                  "commonMistakes": "Confundir linguagens com frameworks; foque no núcleo da linguagem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar linguagens de programação com algoritmos e programas",
                                  "subSteps": [
                                    "Revise definição de algoritmo: sequência finita de instruções.",
                                    "Explique como linguagem expressa algoritmo em código fonte.",
                                    "Descreva o processo: código -> compilação/interpretação -> execução.",
                                    "Crie um pseudocódigo simples e traduza para Python.",
                                    "Discuta compiladores vs. interpretadores com exemplos."
                                  ],
                                  "verification": "Traduza um algoritmo simples (ex.: soma de números) para código executável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto online (Replit), pseudocódigo impresso",
                                  "tips": "Use fluxogramas para visualizar a transição de algoritmo para programa.",
                                  "learningObjective": "Conectar linguagens como ponte entre algoritmos abstratos e programas concretos.",
                                  "commonMistakes": "Esquecer o papel do compilador; sempre teste a execução."
                                }
                              ],
                              "practicalExample": "Pegue o algoritmo de calcular a média de 3 notas: some as notas e divida por 3. Em Python: notas = [7, 8, 9]; media = sum(notas) / 3; print(media). Isso expressa o algoritmo formalmente.",
                              "finalVerifications": [
                                "Defina corretamente linguagem de programação em 1 frase precisa.",
                                "Liste e classifique 3 linguagens com exemplos de uso.",
                                "Diferencie linguagem natural de programação com tabela comparativa.",
                                "Traduza um algoritmo simples para código em Python ou C++.",
                                "Explique o papel de compilador/interpretador em 2 frases.",
                                "Identifique 2 paradigmas de programação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (formalidade e propósito: 25%)",
                                "Correta diferenciação de linguagens naturais (20%)",
                                "Identificação precisa de exemplos e classificações (20%)",
                                "Correta relação com algoritmos/programas (20%)",
                                "Execução prática sem erros (10%)",
                                "Clareza na comunicação escrita/oral (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal e estruturas algébricas.",
                                "Língua Portuguesa: Análise sintática e semântica de textos formais.",
                                "Física: Analogia com leis precisas e experimentação controlada.",
                                "História: Evolução tecnológica desde os anos 1950."
                              ],
                              "realWorldApplication": "Desenvolvedores usam Python para criar apps de IA no Google ou sites em JavaScript para e-commerces como Amazon, transformando algoritmos em soluções cotidianas como recomendações personalizadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Explicar o papel do compilador",
                            "description": "Descrever o processo de compilação: análise léxica, sintática, semântica e geração de código objeto, transformando programa em executável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico e o Papel Geral do Compilador",
                                  "subSteps": [
                                    "Defina o que é um compilador: um programa que traduz código fonte de alto nível para código máquina executável.",
                                    "Compare compilador com interpretador: compilador gera executável uma vez, interpretador executa linha por linha.",
                                    "Explique o objetivo principal: transformar programa legível por humanos em instruções para CPU.",
                                    "Identifique entradas (código fonte) e saídas (código objeto/executável).",
                                    "Descreva o fluxo geral: pré-processamento, compilação, montagem e ligação."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o papel do compilador e liste 3 diferenças para interpretador.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de fases de compilação (imagem ou vídeo online)",
                                    "Artigo introdutório sobre compiladores (ex: Wikipedia - Compiler)"
                                  ],
                                  "tips": "Use analogias como 'tradutor' para código humano-máquina para fixar o conceito.",
                                  "learningObjective": "Entender o propósito fundamental do compilador no ciclo de desenvolvimento de software.",
                                  "commonMistakes": "Confundir compilador com interpretador ou achar que compilador executa o código diretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Análise Léxica (Scanner)",
                                  "subSteps": [
                                    "Descreva a análise léxica: divide o código fonte em tokens (palavras-chave, identificadores, operadores).",
                                    "Explique tokens: unidades mínimas como 'int', 'variavel', '+'.",
                                    "Discuta tabela de símbolos: armazena identificadores encontrados.",
                                    "Identifique erros léxicos: caracteres inválidos ou comentários malformados.",
                                    "Simule com exemplo: código 'int x = 5;' → tokens: int, x, =, 5, ;."
                                  ],
                                  "verification": "Analise um trecho de código simples e liste os tokens gerados manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto com realce de sintaxe",
                                    "Ferramenta online de lexer (ex: Lex/Flex demo)"
                                  ],
                                  "tips": "Pense na análise léxica como 'quebrar texto em palavras' em uma língua natural.",
                                  "learningObjective": "Dominar como o compilador tokeniza o código fonte.",
                                  "commonMistakes": "Ignorar espaços ou comentários como parte dos tokens."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Análise Sintática (Parser)",
                                  "subSteps": [
                                    "Defina análise sintática: verifica se os tokens seguem a gramática da linguagem (estrutura válida).",
                                    "Explique árvore de sintaxe abstrata (AST): representação hierárquica do código.",
                                    "Discuta regras gramaticais: expressões, blocos, funções.",
                                    "Identifique erros sintáticos: chaves não fechadas, ponto e vírgula faltando.",
                                    "Simule: tokens de 'if (x > 0) { y = 1; }' → AST com nó if-condição-bloco."
                                  ],
                                  "verification": "Construa manualmente uma AST simples para um trecho de código e identifique um erro sintático intencional.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de parsing online (ex: ANTLR ou parser generator demo)",
                                    "Gramática BNF de uma linguagem simples como C"
                                  ],
                                  "tips": "Visualize como 'verificar se a frase faz sentido gramaticalmente após tokenização'.",
                                  "learningObjective": "Compreender a verificação de estrutura gramatical do código.",
                                  "commonMistakes": "Confundir erros sintáticos com semânticos (ex: estrutura ok, mas lógica errada)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar a Análise Semântica",
                                  "subSteps": [
                                    "Descreva análise semântica: verifica significado e consistência (tipos, escopo, declarações).",
                                    "Explique verificações: compatibilidade de tipos, variáveis declaradas, sobrecarga de funções.",
                                    "Discuta anotação da AST: adicionar tipos e escopos aos nós.",
                                    "Identifique erros semânticos: uso de variável não declarada, soma de string e int.",
                                    "Simule: em 'int x; x = \"hello\";' → erro de tipo incompatível."
                                  ],
                                  "verification": "Identifique e corrija 3 erros semânticos em um código fornecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código com erros semânticos em C ou Java",
                                    "Documentação de type checking"
                                  ],
                                  "tips": "Foque no 'significado lógico' além da forma: o código faz sentido?",
                                  "learningObjective": "Aprender a validar o significado contextual do código.",
                                  "commonMistakes": "Achar que sintaxe cobre semântica ou ignorar escopo de variáveis."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Compreender a Geração de Código Objeto e Transformação em Executável",
                                  "subSteps": [
                                    "Explique geração de código intermediário: de AST para código assembly ou bytecode.",
                                    "Descreva otimização: eliminar código morto, loop unrolling.",
                                    "Discuta montagem e ligação: assembly para objeto, ligar bibliotecas em executável.",
                                    "Identifique formato final: ELF/PE para executáveis.",
                                    "Simule processo: gcc -S (assembly), gcc -c (objeto), gcc (executável)."
                                  ],
                                  "verification": "Compile um programa simples com flags verbose e descreva cada saída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador GCC/Clang instalado",
                                    "Programa Hello World em C",
                                    "Ferramenta objdump para inspecionar binários"
                                  ],
                                  "tips": "Execute 'gcc -v' para ver fases reais do compilador.",
                                  "learningObjective": "Entender como o código fonte vira executável pronto para rodar.",
                                  "commonMistakes": "Confundir código objeto com executável final ou ignorar linking."
                                }
                              ],
                              "practicalExample": "Usando GCC para compilar 'hello.c': 1) gcc lê código → léxica (tokens: #include, main, printf), 2) sintática (AST válida), 3) semântica (tipos ok), 4) gera hello.o (objeto), 5) linka com libc → a.out executável. Rode './a.out' e use 'objdump -d a.out' para ver assembly.",
                              "finalVerifications": [
                                "Liste e descreva as 4 fases principais da compilação com exemplos.",
                                "Explique diferença entre análise léxica, sintática e semântica.",
                                "Simule tokenização e parsing de um código simples.",
                                "Identifique erros em cada fase em um programa fornecido.",
                                "Descreva o processo completo de código fonte a executável usando GCC.",
                                "Compare compilador com interpretador em termos de performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das fases (100% cobertura: léxica, sintática, semântica, geração).",
                                "Uso correto de terminologia técnica (tokens, AST, type checking).",
                                "Capacidade de identificar e classificar erros por fase.",
                                "Explicação clara do fluxo completo com exemplos práticos.",
                                "Demonstração de compreensão via simulação manual ou ferramenta.",
                                "Conexão entre teoria e prática (ex: uso de compilador real)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos finitos para análise léxica (teoria da computação).",
                                "Arquitetura de Computadores: Código gerado mapeia para instruções ISA da CPU.",
                                "Lógica de Programação: Entender como algoritmos viram código máquina.",
                                "Engenharia de Software: Importância de compiladores em pipelines CI/CD."
                              ],
                              "realWorldApplication": "Compiladores como GCC (Linux), Clang (Apple), Javac (Java) são essenciais no desenvolvimento de apps, jogos, sistemas operacionais e IA, permitindo que programadores escrevam em linguagens high-level que rodam eficientemente em hardware variado."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Diferenciar compilador e interpretador",
                            "description": "Comparar compilador (traduza todo o código antes da execução) com interpretador (executa linha a linha), focando no contexto de programas compilados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito e processo de um compilador",
                                  "subSteps": [
                                    "Ler a definição: um compilador traduz todo o código-fonte de uma linguagem de alto nível para código de máquina ou bytecode antes da execução.",
                                    "Identificar as principais fases do processo: análise léxica (tokens), análise sintática (estrutura), análise semântica (significado), otimização e geração de código.",
                                    "Visualizar um diagrama do fluxo de compilação, destacando que resulta em um executável independente.",
                                    "Pesquisar exemplos de compiladores como GCC para C/C++."
                                  ],
                                  "verification": "Desenhar e rotular um fluxograma simples das fases de compilação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto introdutório sobre compiladores (ex: Wikipedia ou livro de programação)",
                                    "Vídeo tutorial de 5 minutos sobre processo de compilação"
                                  ],
                                  "tips": [
                                    "Pense no compilador como um tradutor completo que entrega um 'livro final' pronto para ler.",
                                    "Compare com tradução humana de um livro inteiro antes de publicar."
                                  ],
                                  "learningObjective": "Dominar as fases e características fundamentais de um compilador.",
                                  "commonMistakes": [
                                    "Confundir fases de compilação com execução do programa",
                                    "Acreditar que o compilador executa o código (ele só traduz)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito e processo de um interpretador",
                                  "subSteps": [
                                    "Ler a definição: um interpretador executa o código-fonte linha por linha, traduzindo e executando simultaneamente, sem gerar executável separado.",
                                    "Identificar as características: leitura sequencial, detecção de erros em tempo de execução e dependência do interpretador para rodar.",
                                    "Visualizar um diagrama do fluxo de interpretação, enfatizando a execução imediata.",
                                    "Pesquisar exemplos de interpretadores como CPython para Python ou Node.js para JavaScript."
                                  ],
                                  "verification": "Desenhar um fluxograma mostrando execução linha a linha com detecção de erro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto sobre interpretadores (ex: documentação Python)",
                                    "Vídeo comparativo compilador vs interpretador"
                                  ],
                                  "tips": [
                                    "Imagine o interpretador como um leitor que traduz e age frase por frase em tempo real.",
                                    "Ideal para depuração rápida, pois erros param na linha exata."
                                  ],
                                  "learningObjective": "Dominar o funcionamento dinâmico e as peculiaridades de um interpretador.",
                                  "commonMistakes": [
                                    "Pensar que interpretador gera executável (não gera)",
                                    "Confundir com compilador just-in-time (JIT, híbrido)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar compiladores e interpretadores lado a lado",
                                  "subSteps": [
                                    "Listar diferenças chave: compilador (traduz tudo antes, executável standalone, erros detectados cedo) vs interpretador (executa linha a linha, dependente do runtime, erros em runtime).",
                                    "Criar uma tabela comparativa com colunas: velocidade, detecção de erros, portabilidade, tamanho do executável.",
                                    "Analisar vantagens/desvantagens: compilador (performance alta, mas tempo de build); interpretador (desenvolvimento rápido, mas mais lento).",
                                    "Discutir cenários de uso: compilado para apps de sistema, interpretado para scripts."
                                  ],
                                  "verification": "Preencher e explicar uma tabela comparativa criada manualmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Artigos comparativos online"
                                  ],
                                  "tips": [
                                    "Use mnemônicos: 'Compilador = Completo antes', 'Interpretador = Imediato linha a linha'.",
                                    "Foque em performance vs produtividade."
                                  ],
                                  "learningObjective": "Identificar e articular diferenças precisas entre os dois.",
                                  "commonMistakes": [
                                    "Ignorar que alguns interpretadores usam JIT (ex: V8 no JS)",
                                    "Generalizar todas linguagens como puramente uma ou outra"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conhecimento com exemplos práticos",
                                  "subSteps": [
                                    "Escrever um programa 'Olá Mundo' em C (compilado) e compilar/executar com gcc.",
                                    "Escrever o mesmo em Python (interpretado) e executar diretamente.",
                                    "Comparar tempos: compilação + execução vs execução direta, notando velocidades.",
                                    "Testar um erro intencional em ambos e observar quando/detalhe do erro aparece."
                                  ],
                                  "verification": "Registrar tempos, erros e diferenças em um relatório curto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ambiente com gcc instalado (Linux/Mac) ou online como Replit",
                                    "Python instalado ou online IDE"
                                  ],
                                  "tips": [
                                    "Use timers para medir objetivamente.",
                                    "Note portabilidade: executável C roda sem compilador, Python precisa dele."
                                  ],
                                  "learningObjective": "Experenciar diferenças na prática para fixação conceitual.",
                                  "commonMistakes": [
                                    "Não medir tempos corretamente (use repetições)",
                                    "Confundir ambientes online que mascaram diferenças"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um programa simples de soma de números em C: compile com 'gcc soma.c -o soma' (gera executável), execute './soma'. Em Python: 'python soma.py' (executa direto). Note: C demora no build inicial mas roda ultra-rápido; Python inicia instantâneo mas mais lento em loops intensos.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença principal entre compilador e interpretador.",
                                "Liste 3 linguagens compiladas (ex: C, Java) e 3 interpretadas (ex: Python, Ruby).",
                                "Descreva o que acontece com um erro de sintaxe no início vs fim do código em cada.",
                                "Crie uma tabela resumida de 5 diferenças chave.",
                                "Identifique se uma dada linguagem (ex: JavaScript) é compilada ou interpretada e justifique."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (correção das definições e processos: 30%)",
                                "Completude da comparação (tabela/diferenças cobertas: 25%)",
                                "Uso de exemplos práticos relevantes (20%)",
                                "Clareza na explicação verbal/escrita (15%)",
                                "Identificação correta de vantagens/desvantagens e usos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal e autômatos na análise léxica/sintática.",
                                "Língua Portuguesa: Analogia com tradução de textos (completa vs incremental).",
                                "História da Computação: Evolução de linguagens assembly para alto nível.",
                                "Física: Conceitos de processamento sequencial vs batch em sistemas.",
                                "Inglês Técnico: Vocabulário específico como 'lexical analysis', 'runtime'."
                              ],
                              "realWorldApplication": "Em engenharia de software, compiladores são usados em apps de alta performance como jogos (C++) ou sistemas operacionais, enquanto interpretadores aceleram prototipagem em data science (Python) ou web dev (JavaScript), influenciando escolhas de stack tecnológico em projetos reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Comandos Básicos",
                    "description": "Atribuição de valores, entrada e saída de dados em linguagens procedimentais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Atribuição de Valores",
                        "description": "Operação básica em linguagens procedimentais para associar um valor ou expressão a uma variável, permitindo o armazenamento e manipulação de dados durante a execução do programa.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar a sintaxe de atribuição",
                            "description": "Reconhecer e diferenciar a sintaxe padrão de atribuição em pseudocódigo (ex: variavel ← valor) e linguagens como C (ex: variavel = valor), incluindo o uso do operador de atribuição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe de atribuição em pseudocódigo",
                                  "subSteps": [
                                    "Explicar o conceito de atribuição como 'associar um valor a uma variável'",
                                    "Identificar o operador padrão ← (seta para a esquerda) usado em pseudocódigo",
                                    "Analisar exemplos simples como 'idade ← 25' e 'nome ← \"João\"'",
                                    "Diferenciar atribuição de operações matemáticas",
                                    "Praticar reescrevendo declarações em pseudocódigo"
                                  ],
                                  "verification": "Criar e listar 3 exemplos corretos de atribuição em pseudocódigo sem erros",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de referência de pseudocódigo",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Pense em ← como 'variável recebe o valor à direita'",
                                  "learningObjective": "Reconhecer e aplicar o operador ← corretamente em pseudocódigo",
                                  "commonMistakes": [
                                    "Usar = em vez de ←",
                                    "Confundir com operador de igualdade",
                                    "Esquecer aspas em strings"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a sintaxe de atribuição em linguagens como C",
                                  "subSteps": [
                                    "Explicar o uso do operador = em linguagens imperativas como C",
                                    "Analisar exemplos como 'int idade = 25;' e 'char nome[] = \"João\";'",
                                    "Comparar declaração e inicialização separadas, ex: 'int x; x = 10;'",
                                    "Identificar regras de tipos (int, float, char) na atribuição",
                                    "Testar em um compilador online para validar sintaxe"
                                  ],
                                  "verification": "Escrever 3 atribuições válidas em C e compilar sem erros",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador online como Replit ou IDE C",
                                    "Referência de sintaxe C"
                                  ],
                                  "tips": "Sempre declare o tipo antes da atribuição em C",
                                  "learningObjective": "Aplicar o operador = corretamente em contextos de C",
                                  "commonMistakes": [
                                    "Usar ← em C",
                                    "Atribuir string sem ponteiro ou array",
                                    "Ignorar ponto e vírgula"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar sintaxes entre pseudocódigo e linguagens reais",
                                  "subSteps": [
                                    "Listar diferenças chave: ← vs = e ausência de tipos em pseudocódigo",
                                    "Criar uma tabela comparativa com 5 exemplos lado a lado",
                                    "Identificar em trechos de código mistos qual sintaxe está sendo usada",
                                    "Converter um exemplo de pseudocódigo para C e vice-versa",
                                    "Discutir por que pseudocódigo usa ← para clareza algorítmica"
                                  ],
                                  "verification": "Preencher uma tabela comparativa com 100% de acurácia",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos de código impressos"
                                  ],
                                  "tips": "Pseudocódigo prioriza legibilidade; linguagens priorizam execução",
                                  "learningObjective": "Diferenciar operadores de atribuição por contexto",
                                  "commonMistakes": [
                                    "Assumir = em pseudocódigo",
                                    "Misturar tipos de C em pseudo",
                                    "Ignorar contexto do código"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em cenários reais e mistos",
                                  "subSteps": [
                                    "Analisar 5 trechos de código aleatórios (pseudo e C) e rotular o operador",
                                    "Corrigir erros intencionais em atribuições, ex: mudar ← para =",
                                    "Explicar o impacto de usar o operador errado em cada contexto",
                                    "Criar um quiz pessoal com 10 perguntas de identificação",
                                    "Aplicar em um mini-algoritmo completo"
                                  ],
                                  "verification": "Resolver um quiz de 10 itens com no mínimo 90% de acertos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de trechos de código",
                                    "Quiz template"
                                  ],
                                  "tips": "Leia o cabeçalho ou comentário para identificar o paradigma",
                                  "learningObjective": "Identificar sintaxe de atribuição de forma rápida e precisa",
                                  "commonMistakes": [
                                    "Pressa em não verificar contexto",
                                    "Confundir com += ou outros operadores",
                                    "Erros de digitação em quizzes"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o código misto: 'salario ← 3000.50' (pseudocódigo) e 'double salario = 3000.50;' (C). Identifique: No primeiro, use ← para atribuir salário em algoritmo; no segundo, = inicializa variável double em C. Converta um para o outro.",
                              "finalVerifications": [
                                "Identificar corretamente operador em 10 exemplos mistos",
                                "Converter 5 atribuições de pseudo para C sem erros",
                                "Explicar diferenças em uma tabela comparativa",
                                "Corrigir 100% de erros em um conjunto de códigos fornecidos",
                                "Aplicar em um algoritmo simples com múltiplas atribuições"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do operador (100%)",
                                "Correta diferenciação por contexto (pseudo vs C)",
                                "Capacidade de conversão sem erros sintáticos",
                                "Explicação clara das diferenças",
                                "Velocidade e confiança em exemplos mistos",
                                "Ausência de confusão com operadores relacionados (==, +=)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceito de variáveis e expressões algébricas",
                                "Lógica: Fluxo de dados e atribuição em diagramas",
                                "Português/Inglês: Leitura de documentação técnica de sintaxe",
                                "Física/Engenharia: Modelagem de variáveis em simulações"
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, identificar rapidamente a sintaxe de atribuição ao revisar código-fonte colaborativo, debuggar inicializações de variáveis ou migrar algoritmos de pseudocódigo para implementação em C, evitando erros em sistemas como controle de estoque ou cálculos financeiros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Realizar atribuições simples",
                            "description": "Executar atribuições de valores constantes ou expressões aritméticas simples a variáveis escalares, como inteiros ou reais, em um programa básico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variáveis e atribuição",
                                  "subSteps": [
                                    "Estude a definição de variável como um espaço na memória para armazenar valores.",
                                    "Aprenda a sintaxe básica de atribuição em Python: nome_variavel = valor.",
                                    "Identifique tipos escalares: int para inteiros e float para reais.",
                                    "Diferencie declaração implícita de atribuição explícita.",
                                    "Analise exemplos de atribuição de constantes como x = 10 ou y = 3.14."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que acontece na memória ao executar uma atribuição.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE como VS Code",
                                    "Documentação Python básica sobre variáveis"
                                  ],
                                  "tips": "Sempre leia a atribuição da direita para a esquerda: o valor à direita é calculado primeiro.",
                                  "learningObjective": "Entender o papel das variáveis e a mecânica da atribuição em programação.",
                                  "commonMistakes": [
                                    "Confundir '=' de atribuição com '=' de igualdade matemática.",
                                    "Esquecer de usar tipos apropriados para reais (use float)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar atribuições de valores constantes",
                                  "subSteps": [
                                    "Crie um programa simples declarando uma variável inteira e atribuindo um valor constante como idade = 25.",
                                    "Adicione uma variável real como salario = 2500.50.",
                                    "Use print() para exibir os valores atribuídos.",
                                    "Modifique os valores e reexecute para observar mudanças.",
                                    "Teste com múltiplas variáveis no mesmo programa."
                                  ],
                                  "verification": "Execute o código e confirme que os valores são exibidos corretamente sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "Terminal ou Jupyter Notebook"
                                  ],
                                  "tips": "Use nomes descritivos para variáveis para facilitar a leitura do código.",
                                  "learningObjective": "Executar atribuições simples de constantes a variáveis escalares.",
                                  "commonMistakes": [
                                    "Usar vírgulas em vez de pontos para decimais em reais.",
                                    "Esquecer parênteses em print()."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar atribuições com expressões aritméticas simples",
                                  "subSteps": [
                                    "Defina variáveis com expressões como soma = 5 + 3.",
                                    "Crie expressões mais complexas como media = (10 + 20) / 2.0.",
                                    "Combine variáveis: a = 4; b = 2; produto = a * b.",
                                    "Inclua operações básicas: +, -, *, /, e precedência com parênteses.",
                                    "Exiba o resultado final com print(resultado)."
                                  ],
                                  "verification": "Verifique se o resultado da expressão é computado corretamente ao executar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo ambiente Python do step anterior"
                                  ],
                                  "tips": "Lembre-se da ordem de operações (PEMDAS: parênteses, expoentes, multiplicação/divisão, adição/subtração).",
                                  "learningObjective": "Atribuir resultados de expressões aritméticas simples a variáveis.",
                                  "commonMistakes": [
                                    "Dividir inteiros resultando em truncamento (use float para divisão exata).",
                                    "Ignorar precedência de operadores."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar atribuições em um programa básico e depurar",
                                  "subSteps": [
                                    "Construa um programa completo: atribua valores a variáveis de entrada e calcule uma saída.",
                                    "Adicione comentários explicando cada atribuição.",
                                    "Teste com diferentes valores de entrada.",
                                    "Identifique e corrija erros comuns como sintaxe ou tipos errados.",
                                    "Salve e execute o programa final."
                                  ],
                                  "verification": "O programa roda sem erros e produz saídas esperadas para múltiplos testes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python IDE",
                                    "Lista de casos de teste pré-definidos"
                                  ],
                                  "tips": "Sempre teste com valores extremos como zero ou negativos.",
                                  "learningObjective": "Combinar atribuições simples em um fluxo de programa funcional.",
                                  "commonMistakes": [
                                    "Reatribuir variáveis sem intenção.",
                                    "Erros de digitação em nomes de variáveis (case-sensitive)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: largura = 5; altura = 3.0; area = largura * altura; print('Área do retângulo:', area)  # Saída: Área do retângulo: 15.0",
                              "finalVerifications": [
                                "Programa executa sem erros de sintaxe.",
                                "Valores constantes são atribuídos corretamente a variáveis int/float.",
                                "Expressões aritméticas simples são avaliadas e atribuídas com precisão.",
                                "Saídas via print() refletem os valores atribuídos.",
                                "Múltiplos testes com diferentes valores funcionam.",
                                "Comentários explicam cada atribuição."
                              ],
                              "assessmentCriteria": [
                                "Correção na sintaxe de atribuição (uso de =).",
                                "Uso apropriado de tipos escalares (int/float).",
                                "Avaliação precisa de expressões aritméticas.",
                                "Integração lógica em programa básico.",
                                "Ausência de erros comuns e depuração eficaz.",
                                "Clareza no código com nomes e comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de aritmética básica e ordem de operações.",
                                "Física: Cálculo de grandezas simples como velocidade = distancia / tempo.",
                                "Economia: Atribuições para saldos ou médias financeiras."
                              ],
                              "realWorldApplication": "Em planilhas Excel (atribuição de fórmulas como =A1+B1), configurações de software (variáveis de ambiente), ou scripts de automação para cálculos diários como conversão de unidades."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Inicializar variáveis",
                            "description": "Aplicar atribuição para inicializar variáveis no início do programa, evitando valores indefinidos e compreendendo a importância para a lógica de programação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Inicialização de Variáveis",
                                  "subSteps": [
                                    "Defina o que é uma variável em programação: um espaço na memória para armazenar dados.",
                                    "Explique inicialização como atribuir um valor inicial à variável antes de usá-la.",
                                    "Discuta consequências de variáveis não inicializadas: valores indefinidos ou lixo na memória.",
                                    "Compare com exemplos cotidianos, como preparar uma prancheta vazia antes de anotar.",
                                    "Identifique sintaxe básica de atribuição em pseudocódigo: variavel = valor;"
                                  ],
                                  "verification": "Resuma em suas palavras o que é inicialização e por que é necessária, sem erros conceituais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notebook e caneta para anotações",
                                    "Documentação de sintaxe de atribuição (ex: Python ou pseudocódigo)"
                                  ],
                                  "tips": "Use analogias simples como 'encher um copo com água antes de beber' para fixar o conceito.",
                                  "learningObjective": "Entender o propósito e a necessidade de inicializar variáveis para evitar erros lógicos.",
                                  "commonMistakes": [
                                    "Confundir inicialização com declaração",
                                    "Achar que variáveis têm valor zero por padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Necessidade de Inicialização em Programas",
                                  "subSteps": [
                                    "Analise um código simples com variáveis não inicializadas e identifique erros potenciais.",
                                    "Trace o fluxo de execução: onde a variável é usada pela primeira vez?",
                                    "Liste cenários comuns: contadores, acumuladores, flags booleanas.",
                                    "Crie um fluxograma simples mostrando o ponto de inicialização no início do programa.",
                                    "Pratique spotting em códigos de exemplo fornecidos."
                                  ],
                                  "verification": "Marque corretamente 5 exemplos de código onde inicialização é necessária.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE básica (ex: VS Code)",
                                    "5 exemplos de códigos curtos com e sem inicialização"
                                  ],
                                  "tips": "Sempre pergunte: 'Essa variável é lida antes de ser escrita?'",
                                  "learningObjective": "Reconhecer situações onde variáveis devem ser inicializadas para lógica correta.",
                                  "commonMistakes": [
                                    "Ignorar loops ou condicionais que podem pular atribuições",
                                    "Assumir valor padrão como zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Atribuição e Inicialização em Código",
                                  "subSteps": [
                                    "Escreva código para inicializar variáveis numéricas, strings e booleanas.",
                                    "Use atribuição múltipla se suportado pela linguagem (ex: a = b = 0).",
                                    "Teste o código executando e verificando valores iniciais com print/debug.",
                                    "Modifique valores após inicialização e observe mudanças.",
                                    "Crie 3 snippets independentes para prática."
                                  ],
                                  "verification": "Execute código sem erros de variável indefinida e confirme valores iniciais via output.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE ou interpretador online (ex: Replit para Python)",
                                    "Templates de código vazios"
                                  ],
                                  "tips": "Inicialize no topo do programa para visibilidade e manutenção fácil.",
                                  "learningObjective": "Aplicar sintaxe de atribuição para inicializar corretamente diferentes tipos de variáveis.",
                                  "commonMistakes": [
                                    "Usar = em expressões condicionais em vez de == para comparação",
                                    "Esquecer ponto e vírgula em linguagens como C"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Inicialização em Programa Completo e Depurar",
                                  "subSteps": [
                                    "Construa um programa simples (ex: calculadora de média) inicializando soma e contador.",
                                    "Introduza deliberadamente variáveis não inicializadas e depure os erros.",
                                    "Refatore o código para boas práticas: inicialização explícita e comentários.",
                                    "Teste edge cases: zero iterações, valores negativos.",
                                    "Documente o impacto da inicialização na lógica."
                                  ],
                                  "verification": "Programa roda sem warnings/erros de undefined e produz resultados corretos em testes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE completa",
                                    "Conjunto de testes de input/output"
                                  ],
                                  "tips": "Use nomes descritivos para variáveis como totalSoma = 0 para clareza.",
                                  "learningObjective": "Integrar inicialização em programas reais, depurando e otimizando lógica.",
                                  "commonMistakes": [
                                    "Inicializar dentro de loops desnecessariamente",
                                    "Reatribuir acidentalmente valor inicial"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa para calcular a média de 3 notas: inicialize soma = 0 e contador = 0 no início. Em loop: soma += nota; contador += 1. Média = soma / contador. Sem inicialização, soma poderia ser indefinida, causando NaN ou erro.",
                              "finalVerifications": [
                                "Todas as variáveis usadas são inicializadas antes do primeiro uso.",
                                "Execução sem erros de 'undefined variable' ou valores inesperados.",
                                "Valores iniciais corretos confirmados via debug/print.",
                                "Programa funciona em cenários edge (zero itens, valores extremos).",
                                "Código comentado explicando inicializações.",
                                "Refatoração remove redundâncias de inicialização."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explica corretamente por quê inicializar (90%+ acerto).",
                                "Aplicação prática: códigos sem erros de inicialização (100% testes passam).",
                                "Depuração: identifica e corrige 4/4 casos de não-inicialização.",
                                "Boas práticas: inicializações no escopo correto e nomeação clara.",
                                "Análise: discute impacto na lógica em relatório curto.",
                                "Criatividade: aplica em exemplo próprio além dos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Variáveis como incógnitas algébricas com valores iniciais.",
                                "Lógica: Evita falácias por premissas indefinidas, similar a silogismos.",
                                "Física/Engenharia: Inicialização como condição inicial em simulações.",
                                "Língua Portuguesa: Clareza na nomenclatura de variáveis como redação técnica."
                              ],
                              "realWorldApplication": "Em apps bancários, inicializar saldo = 0 evita transações com valores fantasma; em jogos, pontuacao = 0 previne scores aleatórios; em sistemas de estoque, totalItens = 0 garante relatórios precisos desde o boot."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Entrada de Dados",
                        "description": "Comandos utilizados para capturar dados fornecidos pelo usuário ou de fontes externas, como teclado, armazenando-os em variáveis para processamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Usar comando de entrada básica",
                            "description": "Implementar comandos de entrada em pseudocódigo (ex: leia variavel) ou C (ex: scanf), lendo um valor único e atribuindo a uma variável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e Propósito do Comando de Entrada",
                                  "subSteps": [
                                    "Defina entrada de dados como a captura de informações do usuário via teclado.",
                                    "Identifique exemplos reais, como ler nome ou idade em um formulário.",
                                    "Explique o fluxo: prompt opcional → usuário digita → programa armazena em variável.",
                                    "Diferencie entrada de saída de dados e inicialização de variáveis.",
                                    "Discuta tipos de dados suportados (inteiro, string, float)."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o conceito e dê 2 exemplos de uso.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Documentação básica de pseudocódigo"
                                  ],
                                  "tips": [
                                    "Visualize o programa como uma conversa: você pergunta, usuário responde."
                                  ],
                                  "learningObjective": "Entender o papel fundamental da entrada na interatividade de programas.",
                                  "commonMistakes": [
                                    "Confundir entrada com atribuição fixa (ex: var = 10)",
                                    "Ignorar tipos de dados do input"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Comando de Entrada em Pseudocódigo",
                                  "subSteps": [
                                    "Escreva a sintaxe básica: 'leia variavel'.",
                                    "Crie um exemplo lendo um inteiro: leia idade.",
                                    "Adapte para string: leia nome.",
                                    "Inclua prompt: escreva 'Digite sua idade: '; leia idade.",
                                    "Teste logicamente com inputs simulados (ex: input 25 → idade=25)."
                                  ],
                                  "verification": "Produza 3 blocos de pseudocódigo válidos para diferentes tipos de dados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto simples (Notepad ou VS Code)",
                                    "Referência de sintaxe de pseudocódigo"
                                  ],
                                  "tips": [
                                    "Sempre use nomes de variáveis descritivos para clareza."
                                  ],
                                  "learningObjective": "Dominar a sintaxe de entrada em pseudocódigo de forma independente.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula ou aspas em prompts",
                                    "Não especificar tipo implícito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Comando de Entrada em Linguagem C com scanf",
                                  "subSteps": [
                                    "Inclua a biblioteca: #include <stdio.h>.",
                                    "Declare variável: int idade; ou char nome[50];.",
                                    "Use scanf: scanf('%d', &idade); ou scanf('%s', nome);.",
                                    "Adicione printf para prompt: printf('Digite sua idade: ');.",
                                    "Compile mentalmente: verifique & para endereço de memória."
                                  ],
                                  "verification": "Escreva um programa C completo que leia e armazene um valor único.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C online (repl.it ou CodeBlocks)",
                                    "Referência scanf man page"
                                  ],
                                  "tips": [
                                    "Lembre-se: & é essencial para variáveis escalares, exceto strings."
                                  ],
                                  "learningObjective": "Aplicar corretamente scanf para leitura segura de um valor único.",
                                  "commonMistakes": [
                                    "Esquecer & no scanf (causa lixo na variável)",
                                    "Não limpar buffer após scanf"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Validar a Implementação",
                                  "subSteps": [
                                    "Compile o código: gcc programa.c -o programa.",
                                    "Execute e teste com inputs variados: números, strings, inválidos.",
                                    "Verifique atribuição: imprima a variável lida.",
                                    "Depure erros comuns: segfault ou valores incorretos.",
                                    "Adicione validação básica: if para checar range."
                                  ],
                                  "verification": "Execute o programa 5 vezes com inputs diferentes e registre saídas corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal ou IDE com C",
                                    "Lista de inputs de teste"
                                  ],
                                  "tips": [
                                    "Use printf para debugar valores de variáveis."
                                  ],
                                  "learningObjective": "Garantir robustez do código de entrada através de testes.",
                                  "commonMistakes": [
                                    "Não testar edge cases como input zero ou negativo",
                                    "Ignorar warnings do compilador"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa em C: #include <stdio.h> int main() { int idade; printf('Digite sua idade: '); scanf('%d', &idade); printf('Voce tem %d anos.', idade); return 0; } Teste com input 25: saída 'Voce tem 25 anos.'",
                              "finalVerifications": [
                                "O programa compila sem erros ou warnings.",
                                "Lê corretamente um valor único e atribui à variável.",
                                "Funciona com múltiplos tipos (int, float, string).",
                                "Não trava com inputs inválidos básicos.",
                                "Valor lido é exibido ou usado corretamente em saída.",
                                "Uso correto de & em scanf para não-strings."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa em pseudocódigo e C.",
                                "Correta referência de endereço (&) no scanf.",
                                "Inclusão de prompt para usabilidade.",
                                "Testes demonstram atribuição bem-sucedida.",
                                "Código limpo, indentado e comentado.",
                                "Tratamento básico de erros ou validação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Correspondência de tipos numéricos (int/float).",
                                "Língua Portuguesa: Interpretação de prompts e inputs textuais.",
                                "Ética e Cidadania: Privacidade de dados pessoais lidos.",
                                "Física/Engenharia: Modelagem de sistemas interativos reais."
                              ],
                              "realWorldApplication": "Captura de dados em apps de cadastro (ex: formulários de login), jogos (nome do jogador), calculadoras científicas (coeficientes) ou sistemas bancários (valores de transação)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Ler múltiplos dados",
                            "description": "Capturar entrada de múltiplas variáveis em uma única linha ou sequência, utilizando formatação adequada para tipos escalares como inteiros e strings.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de entrada múltipla de dados",
                                  "subSteps": [
                                    "Explique por que ler múltiplos dados em uma linha é eficiente comparado a leituras separadas.",
                                    "Identifique cenários onde múltiplas variáveis escalares (inteiros, strings) são necessárias de uma vez.",
                                    "Diferencie tipos de dados: inteiros (ex: 25) vs strings (ex: 'João').",
                                    "Analise exemplos de input como: 'João 25 1500.50' em uma única linha.",
                                    "Discuta formatação esperada para evitar erros de parsing."
                                  ],
                                  "verification": "Resuma em suas palavras os benefícios e tipos suportados, com um exemplo de input.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de lógica de programação básica",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Sempre pense no formato do input do usuário antes de codificar.",
                                  "learningObjective": "Entender a motivação e os tipos de dados envolvidos na leitura múltipla.",
                                  "commonMistakes": [
                                    "Confundir inteiros com strings sem aspas",
                                    "Ignorar espaços como separadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe básica para leitura múltipla",
                                  "subSteps": [
                                    "Estude a sintaxe em pseudocódigo/Portugol: leia(nome, idade, salario).",
                                    "Pratique declarando variáveis antes: cadeia nome; inteiro idade; real salario.",
                                    "Teste input simples: digite 'Ana 30' e verifique atribuição.",
                                    "Experimente com três variáveis: nome, idade, cidade.",
                                    "Compare com leitura única: leia(nome) vs leia múltipla."
                                  ],
                                  "verification": "Escreva e execute um código que leia duas variáveis e imprima-as corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador online Portugol (ex: Portugol Studio)",
                                    "Exemplos de código prontos"
                                  ],
                                  "tips": "Use variáveis declaradas com tipos corretos para evitar erros de compilação.",
                                  "learningObjective": "Dominar a sintaxe exata para capturar múltiplas entradas em uma linha.",
                                  "commonMistakes": [
                                    "Esquecer vírgulas entre variáveis",
                                    "Não declarar variáveis previamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar exemplos com inteiros e mistos",
                                  "subSteps": [
                                    "Crie código para ler dois inteiros: largura e altura de um retângulo.",
                                    "Calcule área e perímetro para validar input.",
                                    "Adicione strings: leia(nome, nota1, nota2) e calcule média.",
                                    "Teste inputs variados: 'Pedro 8 9', 'Maria 7.5 8.5' (note falhas em reais).",
                                    "Ajuste para tipos reais se necessário: real nota1, nota2."
                                  ],
                                  "verification": "Execute o programa com 3 inputs diferentes e confirme saídas corretas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador Portugol",
                                    "Papel para esboçar cálculos"
                                  ],
                                  "tips": "Sempre imprima as variáveis lidas para debug imediato.",
                                  "learningObjective": "Aplicar leitura múltipla em cálculos simples com diferentes tipos.",
                                  "commonMistakes": [
                                    "Misturar inteiros e reais sem conversão",
                                    "Inputs com aspas em strings numéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratar erros comuns e validar entradas",
                                  "subSteps": [
                                    "Identifique erros: input com letras em inteiros causa falha.",
                                    "Adicione verificações básicas: se idade < 0, exiba erro.",
                                    "Pratique formatação: use espaços como separadores, evite vírgulas em input.",
                                    "Teste edge cases: strings vazias, números negativos, múltiplas linhas.",
                                    "Melhore com mensagem de erro personalizada."
                                  ],
                                  "verification": "Teste 5 casos de erro e confirme que o programa não trava.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador com console",
                                    "Lista de testes pré-definidos"
                                  ],
                                  "tips": "Use condicionais simples para validar após leitura.",
                                  "learningObjective": "Garantir robustez na captura de múltiplos dados.",
                                  "commonMistakes": [
                                    "Não tratar inputs inválidos",
                                    "Assumir input sempre correto"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de cadastro de aluno: leia(nome, idade, matricula); escreva('Bem-vindo ', nome, ' de ', idade, ' anos. Matrícula: ', matricula); Input exemplo: 'João 20 2023001' – Saída: 'Bem-vindo João de 20 anos. Matrícula: 2023001'.",
                              "finalVerifications": [
                                "Programa lê corretamente 3 variáveis de input em uma linha única.",
                                "Tipos de dados (int, string) são atribuídos sem erros de tipo.",
                                "Cálculos baseados nas variáveis produzem resultados esperados.",
                                "Inputs inválidos são detectados e tratados.",
                                "Saída reflete fielmente os dados lidos.",
                                "Código compila e executa sem crashes."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe de leitura múltipla (100% precisão).",
                                "Adequação dos tipos de variáveis aos dados esperados.",
                                "Presença de validação básica para inputs errôneos.",
                                "Eficiência: evita leituras desnecessárias.",
                                "Clareza no código com comentários explicativos.",
                                "Testes demonstram funcionalidade com múltiplos cenários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de variáveis numéricas em cálculos.",
                                "Português: Tratamento de strings para nomes e textos.",
                                "Ética Digital: Validação de dados para evitar erros em sistemas reais."
                              ],
                              "realWorldApplication": "Em sistemas de cadastro como apps de delivery (ler nome, endereço, telefone em formulário), jogos (ler posição x,y do jogador) ou planilhas automatizadas (importar dados CSV em batch)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Tratar entrada com prompts",
                            "description": "Combinar saída de mensagem orientadora (prompt) com entrada de dados para melhorar a usabilidade do programa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Prompts e Entrada de Dados",
                                  "subSteps": [
                                    "Definir prompt como mensagem orientadora exibida antes da entrada do usuário.",
                                    "Explicar a função de print() para exibir o prompt e input() para capturar a entrada em Python.",
                                    "Analisar exemplos de prompts ruins (vagos) versus bons (específicos e claros).",
                                    "Discutir como prompts melhoram a usabilidade, reduzindo confusão do usuário.",
                                    "Identificar cenários comuns onde prompts são essenciais, como cadastros ou cálculos interativos."
                                  ],
                                  "verification": "Escrever um resumo de 3 frases explicando o papel dos prompts na programação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação oficial do Python sobre input() e print()",
                                    "Exemplos de código simples em um editor de texto"
                                  ],
                                  "tips": "Sempre imagine o usuário como iniciante e sem contexto prévio.",
                                  "learningObjective": "Entender como prompts facilitam a interação humano-computador em programas.",
                                  "commonMistakes": [
                                    "Confundir print() com input(), achando que print captura dados",
                                    "Ignorar a importância da clareza, usando prompts genéricos como 'Digite:'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Entrada Simples com Prompt",
                                  "subSteps": [
                                    "Abrir um editor de código como IDLE, VSCode ou PyCharm.",
                                    "Escrever um print('Digite seu nome completo: ') seguido de nome = input().",
                                    "Adicionar uma saída que use a entrada, como print(f'Olá, {nome}! Bem-vindo(a).').",
                                    "Executar o programa no terminal ou console.",
                                    "Testar com diferentes entradas para observar o comportamento."
                                  ],
                                  "verification": "O programa exibe o prompt, captura o input e responde corretamente com o nome fornecido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python instalado (versão 3.x)",
                                    "Editor de código com suporte a Python"
                                  ],
                                  "tips": "Use f-strings para formatação moderna e legível de strings.",
                                  "learningObjective": "Criar um programa básico que combine prompt, entrada e saída orientada.",
                                  "commonMistakes": [
                                    "Esquecer as aspas no print() ou input()",
                                    "Não strip() espaços extras na entrada, causando saídas mal formatadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Tratar Entradas de Diferentes Tipos com Prompts Informativos",
                                  "subSteps": [
                                    "Criar prompt para entrada numérica: print('Digite sua idade: '); idade = int(input()).",
                                    "Adicionar prompt para múltiplas entradas, como nome e idade em sequência.",
                                    "Processar os dados: calcular ano de nascimento (2023 - idade).",
                                    "Exibir resultado formatado: print(f'Seu ano de nascimento aproximado é {2023 - idade}').",
                                    "Testar com entradas variadas, incluindo não-numéricas para observar erros."
                                  ],
                                  "verification": "O programa converte string para int corretamente e realiza cálculo simples com a entrada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmos do step anterior",
                                    "Notebook para anotar testes de erro"
                                  ],
                                  "tips": "Sempre especifique o tipo esperado no prompt, ex: 'Digite um número inteiro'",
                                  "learningObjective": "Manipular e converter tipos de dados de entrada com prompts guiados.",
                                  "commonMistakes": [
                                    "Não usar int() ou float(), causando erro TypeError em cálculos",
                                    "Prompts vagos que não indicam o formato esperado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Melhorar Usabilidade com Validação e Prompts de Erro",
                                  "subSteps": [
                                    "Implementar loop while para validar: while True: prompt idade; try: idade = int(input()); break except: print('Erro: digite número válido')",
                                    "Adicionar prompt inicial claro e mensagem de erro específica.",
                                    "Combinar com entrada de string: validar se nome não está vazio.",
                                    "Testar cenários: input válido, inválido (letras em idade), vazio.",
                                    "Refatorar código com comentários explicativos."
                                  ],
                                  "verification": "Programa rejeita inputs inválidos, repete prompt até sucesso e processa corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para testes iterativos"
                                  ],
                                  "tips": "Use try-except para robustez sem quebrar o programa.",
                                  "learningObjective": "Desenvolver programas resilientes com validação via prompts interativos.",
                                  "commonMistakes": [
                                    "Loops infinitos sem break",
                                    "Mensagens de erro genéricas que não orientam o usuário"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Testar Programa Completo com Múltiplas Entradas",
                                  "subSteps": [
                                    "Criar programa que peça nome, idade e cidade com prompts sequenciais.",
                                    "Validar idade (>0 e <150) e cidade (não vazia).",
                                    "Calcular e exibir: saudação personalizada + 'Você mora em [cidade]'.",
                                    "Executar testes completos: casos felizes, erros, edge cases (idade 0, strings vazias).",
                                    "Documentar o código com comentários sobre cada prompt."
                                  ],
                                  "verification": "Programa completo roda sem crashes, valida entradas e produz saída usável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Todos os anteriores",
                                    "Lista de testes pré-planejados"
                                  ],
                                  "tips": "Planeje testes antes de codificar para cobrir 80% dos casos.",
                                  "learningObjective": "Construir um programa usável e validado usando prompts de forma integrada.",
                                  "commonMistakes": [
                                    "Validações incompletas, permitindo dados absurdos",
                                    "Código sem comentários, dificultando manutenção"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa de cadastro simples: exiba 'Digite seu nome: '; capture e valide não vazio; 'Digite sua idade (número): '; valide inteiro >0; 'Digite sua cidade: '; capture. Saída: 'Cadastro realizado: [nome], [idade] anos, [cidade].' Use loops e try-except para prompts de erro.",
                              "finalVerifications": [
                                "Prompts são exibidos antes de cada input e são claros/descritivos.",
                                "Todas as entradas são capturadas e processadas corretamente (strings e números).",
                                "Validações rejeitam inputs inválidos com prompts de erro orientadores.",
                                "Programa não trava com erros de usuário e repete prompts quando necessário.",
                                "Saída final usa todas as entradas de forma personalizada e formatada.",
                                "Código inclui comentários explicando o uso de prompts."
                              ],
                              "assessmentCriteria": [
                                "Clareza e especificidade dos prompts (escala 1-5).",
                                "Correção na captura e conversão de tipos de entrada (1-5).",
                                "Implementação eficaz de validação com loops/try-except (1-5).",
                                "Melhoria na usabilidade demonstrada em testes (1-5).",
                                "Robustez contra erros comuns de input (1-5).",
                                "Qualidade de comentários e estrutura do código (1-5)."
                              ],
                              "crossCurricularConnections": [
                                "Língua Portuguesa: redação clara e persuasiva nos prompts para comunicação eficaz.",
                                "Matemática: uso de operações aritméticas com entradas numéricas validadas.",
                                "Design/UX: princípios de interfaces intuitivas e user-friendly.",
                                "Ética em Computação: tratamento respeitoso de erros do usuário."
                              ],
                              "realWorldApplication": "Em ferramentas CLI como gerenciadores de senhas, calculadoras interativas, cadastros em sistemas empresariais, chatbots e validação de formulários em apps web/mobile, onde prompts guiam usuários leigos para entradas precisas e evitam erros custosos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Saída de Dados",
                        "description": "Comandos para exibir valores de variáveis, resultados de expressões ou mensagens no dispositivo de saída padrão, como tela, facilitando a comunicação com o usuário.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Implementar saída básica",
                            "description": "Utilizar comandos de saída em pseudocódigo (ex: escreva variavel) ou C (ex: printf), exibindo valores constantes ou de variáveis simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e implementar saída de constantes em pseudocódigo",
                                  "subSteps": [
                                    "Estude o comando padrão de saída em pseudocódigo, como 'escreva(\"texto\")' ou 'imprima \"texto\"'.",
                                    "Identifique cenários onde constantes são usadas, como mensagens fixas.",
                                    "Escreva um programa simples que exiba uma constante, ex: 'escreva(\"Olá, Mundo!\")'.",
                                    "Execute o pseudocódigo manualmente ou em simulador para visualizar a saída.",
                                    "Analise a formatação básica da saída."
                                  ],
                                  "verification": "O programa exibe corretamente a mensagem constante sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou simulador de pseudocódigo (ex: Pseudocode IDE)",
                                    "Documentação de comandos de pseudocódigo"
                                  ],
                                  "tips": [
                                    "Use aspas duplas para strings e evite vírgulas extras.",
                                    "Teste com diferentes mensagens para praticar."
                                  ],
                                  "learningObjective": "Dominar a sintaxe de saída para valores constantes em pseudocódigo.",
                                  "commonMistakes": [
                                    "Esquecer as aspas nas strings",
                                    "Usar variáveis em vez de constantes",
                                    "Adicionar ponto e vírgula desnecessário"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar saída de variáveis simples em pseudocódigo",
                                  "subSteps": [
                                    "Declare uma variável simples, ex: inteiro idade = 25.",
                                    "Use o comando de saída com variável, ex: 'escreva(idade)'.",
                                    "Crie um programa que combine constante e variável, ex: 'escreva(\"Idade: \", idade)'.",
                                    "Simule a execução alterando o valor da variável e observe mudanças na saída.",
                                    "Pratique com tipos diferentes: string, inteiro, real."
                                  ],
                                  "verification": "A saída reflete corretamente o valor da variável ao ser alterado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de pseudocódigo",
                                    "Folha de exercícios com declarações de variáveis"
                                  ],
                                  "tips": [
                                    "Sempre declare a variável antes de usá-la na saída.",
                                    "Use concatenação para mensagens claras."
                                  ],
                                  "learningObjective": "Aplicar comandos de saída com variáveis para exibir dados dinâmicos.",
                                  "commonMistakes": [
                                    "Não declarar a variável",
                                    "Confundir nomes de variáveis",
                                    "Misturar tipos sem conversão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Migrar para implementação em C usando printf",
                                  "subSteps": [
                                    "Estude a sintaxe do printf: #include <stdio.h> e printf(\"texto %d\", variavel);",
                                    "Traduza um programa de pseudocódigo para C exibindo constante: printf(\"Olá, Mundo!\\n\");",
                                    "Implemente saída de variável: int idade = 25; printf(\"Idade: %d\\n\", idade);",
                                    "Compile e execute no terminal usando gcc.",
                                    "Teste com múltiplos argumentos e especifadores (%s, %f)."
                                  ],
                                  "verification": "O programa C compila e executa produzindo a saída esperada no console.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador GCC ou IDE como Code::Blocks",
                                    "Referência de printf da stdio.h"
                                  ],
                                  "tips": [
                                    "Sempre inclua \\n para nova linha.",
                                    "Combine %d para inteiros e %s para strings."
                                  ],
                                  "learningObjective": "Implementar saída básica em C, comparando com pseudocódigo.",
                                  "commonMistakes": [
                                    "Esquecer #include <stdio.h>",
                                    "Número incorreto de argumentos no printf",
                                    "Falta de ; no final"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e integrar saídas básicas",
                                  "subSteps": [
                                    "Crie um programa completo com múltiplas saídas: constantes e variáveis.",
                                    "Introduza erros intencionais (ex: sintaxe errada) e depure.",
                                    "Compare saídas de pseudocódigo e C lado a lado.",
                                    "Adicione formatação básica, como alinhamento com printf.",
                                    "Documente o código com comentários explicando cada saída."
                                  ],
                                  "verification": "Programa integrado roda sem erros e atende a todos os requisitos de saída.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com depurador",
                                    "Exemplos de programas de teste"
                                  ],
                                  "tips": [
                                    "Use printf para debug temporário.",
                                    "Valide saídas com entradas variadas."
                                  ],
                                  "learningObjective": "Integrar e depurar comandos de saída em contextos reais.",
                                  "commonMistakes": [
                                    "Ignorar quebras de linha",
                                    "Sobrecarregar printf com muitos argumentos",
                                    "Não compilar antes de executar"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa em pseudocódigo e C que declare string nome = \"João\"; int idade = 30; e exiba: \"Olá, João! Você tem 30 anos.\". Em C: #include <stdio.h> int main() { char nome[] = \"João\"; int idade = 30; printf(\"Olá, %s! Você tem %d anos.\\n\", nome, idade); return 0; }",
                              "finalVerifications": [
                                "Programa em pseudocódigo simula saída correta para constantes e variáveis.",
                                "Programa C compila sem warnings ou erros.",
                                "Saídas exibem valores exatos, incluindo formatação e quebras de linha.",
                                "Alteração de variáveis reflete na saída.",
                                "Código está comentado e indentado corretamente.",
                                "Depuração resolve erros comuns introduzidos."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe em pseudocódigo e C (100% acerto).",
                                "Uso apropriado de especifadores de formato no printf.",
                                "Capacidade de combinar constantes e variáveis na saída.",
                                "Eficiência e clareza do código (sem código desnecessário).",
                                "Habilidade de depuração e verificação de saídas.",
                                "Documentação adequada com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração de expressões aritméticas em saídas (ex: printf(\"Soma: %d\", a+b)).",
                                "Língua Portuguesa: Construção de mensagens claras e formatadas.",
                                "Física/Engenharia: Saídas em simulações de experimentos.",
                                "Artes: Design básico de prompts de usuário no console."
                              ],
                              "realWorldApplication": "Desenvolvimento de interfaces de console em jogos simples, logs de sistemas em softwares empresariais, relatórios iniciais em automação industrial e protótipos de aplicativos desktop."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Formatar saída de dados",
                            "description": "Aplicar formatação em saídas para controlar precisão decimal, alinhamento e inclusão de texto, como em printf com especificadores %d, %f.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do printf e especificadores básicos",
                                  "subSteps": [
                                    "Estude a sintaxe geral do printf: printf(\"string de formato\", argumentos);",
                                    "Identifique os componentes da string de formato: texto literal e especificadores como %d para inteiros e %f para floats.",
                                    "Inclua a biblioteca necessária: #include <stdio.h>.",
                                    "Compile e execute um programa simples com printf sem formatação.",
                                    "Liste pelo menos 5 especificadores comuns (%d, %i, %f, %s, %c)."
                                  ],
                                  "verification": "Escreva e execute um programa que imprima 'Idade: 25' usando %d, confirmando saída correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C (GCC ou online como Replit)",
                                    "Editor de texto (VS Code ou Notepad++)",
                                    "Documentação printf do C"
                                  ],
                                  "tips": [
                                    "Sempre termine com ; e use \\n para nova linha.",
                                    "Teste em ambiente online para rapidez."
                                  ],
                                  "learningObjective": "Dominar a sintaxe básica do printf e reconhecer especificadores essenciais.",
                                  "commonMistakes": [
                                    "Esquecer #include <stdio.h>",
                                    "Confundir %d com %f",
                                    "Não compilar antes de executar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar formatação para números inteiros (%d) com alinhamento e largura",
                                  "subSteps": [
                                    "Aprenda flags de largura: %5d (largura mínima 5 caracteres).",
                                    "Use flags de alinhamento: %-5d (alinhado à esquerda), %5d (à direita).",
                                    "Combine com zero padding: %05d (preenche com zeros).",
                                    "Crie um loop para imprimir números de 1 a 10 alinhados em tabela.",
                                    "Teste variações com números negativos."
                                  ],
                                  "verification": "Gere saída alinhada: '1   2   3' em colunas uniformes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Exemplos de código de referência"
                                  ],
                                  "tips": [
                                    "Largura é mínima; números maiores expandem o campo.",
                                    "Use tabulação para visualizar alinhamento."
                                  ],
                                  "learningObjective": "Controlar apresentação visual de inteiros com precisão.",
                                  "commonMistakes": [
                                    "Confundir largura com precisão",
                                    "Esquecer sinal para negativos",
                                    "Alinhamento invertido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formatar números de ponto flutuante (%f) com precisão decimal",
                                  "subSteps": [
                                    "Entenda %f padrão (6 casas decimais) e especifique precisão: %.2f (2 decimais).",
                                    "Aplique largura e alinhamento: %8.2f ou %-8.2f.",
                                    "Use arredondamento e flags como + para sinal sempre visível.",
                                    "Crie programa para calcular e formatar média de notas com 2 decimais.",
                                    "Teste com valores extremos (muito pequenos ou grandes)."
                                  ],
                                  "verification": "Imprima 3.14159 como '3.14' com alinhamento correto em tabela.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Calculadora para validação manual"
                                  ],
                                  "tips": [
                                    "Precisão é após o ., largura antes.",
                                    "Arredonda automaticamente; valide manualmente."
                                  ],
                                  "learningObjective": "Gerenciar precisão e formatação de floats para saídas profissionais.",
                                  "commonMistakes": [
                                    "Excesso de decimais sem especificar",
                                    "Confundir precisão com largura",
                                    "Perda de precisão em cálculos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar formatações avançadas com texto e criar saídas complexas",
                                  "subSteps": [
                                    "Integre múltiplos especificadores em uma string: \"Nome: %s, Nota: %.2f\". ",
                                    "Aplique escape sequences: \\t para tabulação, %% para literal %.",
                                    "Crie uma tabela completa com cabeçalhos, alinhamentos e mistos de tipos.",
                                    "Adicione variáveis dinâmicas via input do usuário com scanf.",
                                    "Debugue erros comuns como argumentos insuficientes."
                                  ],
                                  "verification": "Produza uma tabela formatada de 3 alunos com nome, idade (%d) e média (%.2f) alinhados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Amostras de tabelas reais (ex: Excel export)"
                                  ],
                                  "tips": [
                                    "Conte os % e argumentos para matching.",
                                    "Use printf para debug temporário."
                                  ],
                                  "learningObjective": "Construir saídas formatadas profissionais combinando todos os elementos.",
                                  "commonMistakes": [
                                    "Mismatch de argumentos",
                                    "Escape sequences esquecidas",
                                    "Sobrecarga de formatação"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa que leia nome, idade (int) e salário (float) de um funcionário e imprima em formato de relatório: \"Funcionário: João Silva | Idade:  30 | Salário: R$1,250.50\", com alinhamento à direita para números, precisão de 2 decimais e separadores visuais.",
                              "finalVerifications": [
                                "Pode formatar %d com largura 5 e alinhamento direito?",
                                "Consegue limitar %f a 3 decimais sem trailing zeros?",
                                "Cria tabela de 5 linhas com colunas alinhadas perfeitamente?",
                                "Integra texto, %d e %f em uma única printf sem erros?",
                                "Debuga saída incorreta alterando flags de formatação?",
                                "Valida precisão em cálculos reais como médias?"
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: Sem warnings de compilação ou runtime errors.",
                                "Precisão de formatação: Decimais exatos, alinhamentos uniformes.",
                                "Visual appeal: Saída legível como tabela ou relatório profissional.",
                                "Flexibilidade: Adapta a diferentes tamanhos de dados.",
                                "Eficiência: Usa mínimo de printf calls sem repetições desnecessárias.",
                                "Documentação: Comentários explicando cada especificador usado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Controle de precisão numérica e arredondamento.",
                                "Design Gráfico: Princípios de alinhamento e legibilidade visual.",
                                "Língua Portuguesa: Estruturação de textos informativos formatados.",
                                "Banco de Dados: Formatação para exportação de relatórios SQL.",
                                "Física: Apresentação de medidas com unidades e precisão."
                              ],
                              "realWorldApplication": "Em sistemas de relatórios empresariais (ex: folha de pagamento com salários formatados), jogos (scores alinhados em leaderboards), aplicativos científicos (resultados experimentais com precisão decimal) e interfaces de usuário em software embarcado para displays legíveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Exibir resultados de expressões",
                            "description": "Mostrar o resultado de operações aritméticas ou atribuições combinadas com saída, integrando múltiplos comandos em um programa simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender expressões aritméticas básicas",
                                  "subSteps": [
                                    "Identifique operadores aritméticos: +, -, *, /, // (divisão inteira), % (módulo), ** (potência).",
                                    "Pratique avaliação de expressões simples como 2 + 3 ou 10 / 2.",
                                    "Entenda precedência de operadores (PEMDAS: parênteses, expoentes, multiplicação/divisão, adição/subtração).",
                                    "Use parênteses para alterar precedência quando necessário."
                                  ],
                                  "verification": "Avalie manualmente 5 expressões e compare com resultados esperados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou calculadora para verificação manual",
                                    "Documentação de operadores aritméticos"
                                  ],
                                  "tips": "Sempre use parênteses para clareza, mesmo quando não obrigatório.",
                                  "learningObjective": "Reconhecer e calcular corretamente expressões aritméticas simples.",
                                  "commonMistakes": "Esquecer precedência, confundir / com //."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Exibir resultados de expressões simples com print",
                                  "subSteps": [
                                    "Escreva um comando print() com uma expressão direta, ex: print(5 * 3).",
                                    "Execute o código e observe a saída no console.",
                                    "Teste expressões com diferentes operadores, incluindo divisão e módulo.",
                                    "Experimente expressões com parênteses para agrupamento."
                                  ],
                                  "verification": "O console mostra o resultado numérico correto da expressão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente de programação Python (IDLE, VS Code, Replit)",
                                    "Calculadora para validar resultados"
                                  ],
                                  "tips": "Formate expressões longas em múltiplas linhas com parênteses para legibilidade.",
                                  "learningObjective": "Executar e visualizar saída de expressões aritméticas puras.",
                                  "commonMistakes": "Esquecer parênteses no print(), usar aspas em números."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar variáveis e atribuições com expressões em print",
                                  "subSteps": [
                                    "Declare variáveis com valores numéricos, ex: a = 10; b = 3.",
                                    "Crie expressões envolvendo variáveis, ex: print(a + b).",
                                    "Combine múltiplas operações, ex: print((a * b) / 2).",
                                    "Atualize variáveis e reimprima para ver mudanças."
                                  ],
                                  "verification": "Saída reflete cálculos corretos com valores das variáveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo ambiente de programação",
                                    "Lista de exemplos de variáveis"
                                  ],
                                  "tips": "Nomeie variáveis de forma descritiva para facilitar depuração.",
                                  "learningObjective": "Usar variáveis em expressões exibidas via print.",
                                  "commonMistakes": "Reatribuir sem usar nova variável, erros de digitação em nomes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir programa simples com múltiplos comandos de saída",
                                  "subSteps": [
                                    "Estruture um programa com várias linhas: variáveis, cálculos e múltiplos print().",
                                    "Exemplo: calcular perímetro e área de um retângulo e exibir ambos.",
                                    "Adicione comentários explicando cada print.",
                                    "Teste com inputs diferentes alterando valores das variáveis."
                                  ],
                                  "verification": "Programa executa sem erros e exibe todos os resultados esperados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente de programação",
                                    "Papel para esboçar lógica do programa"
                                  ],
                                  "tips": "Ordene prints logicamente para narrativa clara na saída.",
                                  "learningObjective": "Integrar expressões, variáveis e saídas em programa coeso.",
                                  "commonMistakes": "Falta de indentação em blocos, prints fora de ordem."
                                }
                              ],
                              "practicalExample": "Programa que calcula e exibe o IMC: peso = 70; altura = 1.75; imc = peso / (altura ** 2); print('IMC:', imc); print('Classificação:', 'Normal' if imc < 25 else 'Acima').",
                              "finalVerifications": [
                                "Programa executa sem erros de sintaxe.",
                                "Todas as expressões produzem resultados numéricos corretos.",
                                "Saídas incluem tanto cálculos simples quanto compostos.",
                                "Código possui comentários explicando expressões.",
                                "Testes com valores alterados mantêm precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das expressões (100% correto).",
                                "Uso adequado de print() com expressões e variáveis.",
                                "Estrutura lógica do programa com múltiplos comandos.",
                                "Clareza e legibilidade do código (comentários, nomes de variáveis).",
                                "Capacidade de depuração de erros comuns em expressões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reforça operações aritméticas e álgebra básica.",
                                "Física: Aplicações em fórmulas como velocidade = distância / tempo.",
                                "Economia: Cálculos de juros simples ou médias.",
                                "Estatística: Exibição de médias e desvios."
                              ],
                              "realWorldApplication": "Em dashboards de software, relatórios financeiros ou apps de fitness que exibem resultados de cálculos em tempo real para usuários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3.1",
                              "10.1.2.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.4",
                            "name": "Combinar entrada e saída",
                            "description": "Criar um programa que leia dados, processe com atribuições e exiba resultados formatados, demonstrando fluxo básico de um algoritmo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar o fluxo do programa",
                                  "subSteps": [
                                    "Identificar as entradas necessárias (ex: nome, números)",
                                    "Definir variáveis para armazenar dados lidos",
                                    "Planejar processamento com atribuições (ex: cálculos simples)",
                                    "Especificar formato da saída (ex: mensagens personalizadas)",
                                    "Esboçar pseudocódigo ou fluxograma"
                                  ],
                                  "verification": "Pseudocódigo ou fluxograma escrito e revisado, cobrindo input, process e output",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel/caneta",
                                    "Editor de texto",
                                    "Referência de sintaxe da linguagem (ex: Python docs)"
                                  ],
                                  "tips": "Desenhe setas para mostrar o fluxo: input → atribuição → processamento → output",
                                  "learningObjective": "Mapear o fluxo básico de um algoritmo com entrada e saída",
                                  "commonMistakes": "Ignorar tipos de dados nas variáveis, levando a erros de conversão"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar leitura de entrada e atribuições",
                                  "subSteps": [
                                    "Configurar ambiente de programação (IDE ou terminal)",
                                    "Escrever comandos de input (ex: input() em Python)",
                                    "Atribuir valores lidos a variáveis (ex: nome = input('Digite seu nome: '))",
                                    "Realizar atribuições adicionais (ex: num1 = float(input(...)))",
                                    "Adicionar comentários explicando cada linha"
                                  ],
                                  "verification": "Código roda sem erros de sintaxe e lê inputs corretamente no console",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDE como VS Code ou PyCharm",
                                    "Python instalado"
                                  ],
                                  "tips": "Use input() para strings e float/int() para números para evitar erros",
                                  "learningObjective": "Capturar e armazenar dados do usuário em variáveis",
                                  "commonMistakes": "Esquecer de converter string para número, causando erro em cálculos"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar dados e formatar saída",
                                  "subSteps": [
                                    "Executar cálculos ou processamentos com variáveis (ex: media = (a + b) / 2)",
                                    "Usar formatação de strings (ex: f'Sua média: {media:.2f}')",
                                    "Combinar múltiplas saídas formatadas em uma mensagem coerente",
                                    "Testar formatação com dados de exemplo",
                                    "Adicionar print() para exibir resultados"
                                  ],
                                  "verification": "Saída exibida no console com formatação correta para inputs de teste",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmos da etapa anterior",
                                    "Exemplos de dados de teste"
                                  ],
                                  "tips": "Use f-strings em Python para formatação simples e legível",
                                  "learningObjective": "Transformar dados processados em saídas legíveis e formatadas",
                                  "commonMistakes": "Não limitar casas decimais, resultando em saídas bagunçadas"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar o programa completo",
                                  "subSteps": [
                                    "Executar o programa com múltiplos conjuntos de input",
                                    "Verificar se outputs correspondem aos esperados",
                                    "Identificar e corrigir erros (ex: ValueError em inputs inválidos)",
                                    "Adicionar validação básica de input se necessário",
                                    "Documentar testes realizados"
                                  ],
                                  "verification": "Programa executa corretamente para 5+ casos de teste variados",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal/IDE para execução",
                                    "Lista de casos de teste"
                                  ],
                                  "tips": "Teste com inputs extremos (0, negativos, strings longas)",
                                  "learningObjective": "Garantir robustez básica do fluxo input-process-output",
                                  "commonMistakes": "Testar apenas com dados 'perfeitos', ignorando edge cases"
                                }
                              ],
                              "practicalExample": "Programa em Python: \nnome = input('Digite seu nome: ')\nn1 = float(input('Nota 1: '))\nn2 = float(input('Nota 2: '))\nmedia = (n1 + n2) / 2\nprint(f'Olá {nome}, sua média é {media:.2f}!')  # Lê nome/notas, calcula média e exibe formatada.",
                              "finalVerifications": [
                                "Programa lê todos os inputs sem crashes",
                                "Variáveis são atribuídas e processadas corretamente",
                                "Saída é formatada e personalizada",
                                "Fluxo completo demonstra algoritmo básico",
                                "Executa em menos de 5 segundos por teste",
                                "Sem warnings ou erros no console"
                              ],
                              "assessmentCriteria": [
                                "Correção do fluxo input-atribuição-output (40%)",
                                "Formatação precisa da saída (25%)",
                                "Tratamento de tipos de dados (20%)",
                                "Clareza do código com comentários (10%)",
                                "Robustez em testes variados (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas e formatação numérica",
                                "Língua Portuguesa: Construção de frases formatadas e legíveis",
                                "Ética Digital: Considerações sobre privacidade de dados de input"
                              ],
                              "realWorldApplication": "Desenvolvimento de formulários web simples (ex: calculadora de IMC em apps de saúde), relatórios automatizados em planilhas empresariais ou chatbots que processam respostas de usuários."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.2",
                              "10.1.2.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Estruturas de Controle",
                    "description": "Comandos condicionais, repetitivos e seletivos para controle de fluxo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Comandos Condicionais",
                        "description": "Estruturas que permitem a execução seletiva de blocos de código com base na avaliação de expressões booleanas, como if, else e if-else, controlando o fluxo do programa conforme condições específicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Implementar estrutura if simples",
                            "description": "Criar e utilizar o comando if para executar um bloco de código apenas quando uma condição booleana é verdadeira, identificando cenários onde uma única verificação é suficiente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de estrutura if simples",
                                  "subSteps": [
                                    "Estude o que é uma condição booleana (verdadeiro ou falso).",
                                    "Identifique situações do dia a dia onde uma única decisão é tomada com base em uma condição.",
                                    "Diferencie if simples de estruturas mais complexas como if-else.",
                                    "Analise exemplos de fluxogramas com if simples.",
                                    "Explique verbalmente para si mesmo quando usar if simples."
                                  ],
                                  "verification": "Resuma em uma frase o propósito do if simples e dê um exemplo pessoal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre condicionais",
                                    "Papel e caneta para fluxogramas"
                                  ],
                                  "tips": "Use analogias cotidianas, como 'se chover, pegue guarda-chuva'.",
                                  "learningObjective": "Entender o papel do if simples em controlar o fluxo de execução baseado em uma condição única.",
                                  "commonMistakes": [
                                    "Confundir com if-else",
                                    "Ignorar que if simples não tem ação para falso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe do comando if simples",
                                  "subSteps": [
                                    "Memorize a estrutura: if (condição) { bloco de código }.",
                                    "Pratique escrevendo sintaxe em pseudocódigo.",
                                    "Identifique elementos obrigatórios: palavra-chave 'if', parênteses, condição booleana, chaves.",
                                    "Compare sintaxe em linguagens como Python (if condição:) e JavaScript.",
                                    "Escreva 3 variações de sintaxe vazia."
                                  ],
                                  "verification": "Escreva corretamente a sintaxe de um if simples sem olhar referências.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Referência de sintaxe de pseudocódigo",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Sempre use indentação para o bloco de código para melhor legibilidade.",
                                  "learningObjective": "Dominar a forma exata de escrever o comando if simples em pseudocódigo.",
                                  "commonMistakes": [
                                    "Esquecer parênteses ou chaves",
                                    "Colocar ponto e vírgula após a condição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar um if simples em um programa",
                                  "subSteps": [
                                    "Escolha um problema simples, como verificar se um número é maior que 10.",
                                    "Defina variáveis de entrada (ex: número).",
                                    "Escreva a condição booleana (ex: numero > 10).",
                                    "Adicione o bloco de código a ser executado se verdadeiro (ex: imprimir 'Maior').",
                                    "Teste manualmente com valores verdadeiros e falsos."
                                  ],
                                  "verification": "Execute o código com entrada verdadeira e confirme que o bloco roda; com falsa, não roda.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente de programação online (Repl.it ou similar)",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Comece com condições simples como comparações numéricas (> , < , ==).",
                                  "learningObjective": "Criar um programa funcional usando if simples para uma decisão única.",
                                  "commonMistakes": [
                                    "Usar = em vez de == para comparação",
                                    "Não declarar variáveis corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar cenários adequados para if simples e testar",
                                  "subSteps": [
                                    "Liste 5 cenários reais onde if simples basta (sem necessidade de else).",
                                    "Refatore um programa sem condicional para usar if simples.",
                                    "Teste o programa com múltiplas entradas.",
                                    "Registre resultados em uma tabela (entrada, condição, saída esperada).",
                                    "Avalie se o if simples resolve o problema sem complexidade extra."
                                  ],
                                  "verification": "Crie e teste um programa com if simples para um cenário novo, documentando resultados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha para testes",
                                    "Exemplos de problemas reais"
                                  ],
                                  "tips": "Pergunte: 'Há apenas uma ação possível quando verdadeiro?' Se sim, use if simples.",
                                  "learningObjective": "Reconhecer quando if simples é suficiente e validar seu uso.",
                                  "commonMistakes": [
                                    "Usar if simples quando else é necessário",
                                    "Ignorar casos de borda como zero ou nulos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de verificação de idade para compra: if (idade >= 18) { imprimir('Pode comprar'); } – Executa apenas se a pessoa for maior de idade, ignorando menores.",
                              "finalVerifications": [
                                "O bloco de código executa SOMENTE quando a condição é verdadeira.",
                                "Condição booleana está corretamente formada (usa operadores como >, <, ==).",
                                "Sintaxe está 100% correta sem erros de compilação.",
                                "Testes com valores verdadeiros e falsos produzem saídas esperadas.",
                                "Programa identifica corretamente cenários de uso único.",
                                "Código é legível com indentação adequada."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe do if simples (obrigatório).",
                                "Condição booleana válida e lógica.",
                                "Execução seletiva do bloco apenas na condição verdadeira.",
                                "Identificação precisa de cenários adequados para if simples.",
                                "Testes documentados com múltiplas entradas.",
                                "Código limpo e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações relacionais e lógicas (>, <, ==).",
                                "Lógica: Raciocínio dedutivo em decisões binárias.",
                                "Português: Leitura e escrita clara de condições descritivas.",
                                "Ciências: Modelagem de experimentos com hipóteses únicas."
                              ],
                              "realWorldApplication": "Validação de senhas em apps (if senhaCorreta: acessar), alertas de temperatura em termostatos (if tempAlta: ativar ventilador), ou filtros em e-commerces (if estoque > 0: mostrar produto)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Utilizar if-else para decisões binárias",
                            "description": "Desenvolver estruturas if-else para executar blocos alternativos de código dependendo se a condição é verdadeira ou falsa, aplicando em problemas com duas possibilidades mutuamente exclusivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe básica do if-else",
                                  "subSteps": [
                                    "Estude a estrutura geral: if (condição) { bloco verdadeiro } else { bloco falso }",
                                    "Identifique os componentes: palavra-chave 'if', parênteses para condição, chaves para blocos",
                                    "Compare com fluxograma: setas para verdadeiro/falso",
                                    "Leia exemplos em pseudocódigo ou Python",
                                    "Anote as regras de indentação e uso obrigatório de chaves"
                                  ],
                                  "verification": "Escreva a sintaxe vazia do if-else sem consultar referências e verifique se está correta",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação de lógica de programação",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Sempre use chaves {} mesmo para blocos de uma linha para evitar erros futuros",
                                  "learningObjective": "Dominar a estrutura sintática do if-else para decisões binárias",
                                  "commonMistakes": [
                                    "Esquecer parênteses na condição",
                                    "Omitir 'else'",
                                    "Erro de indentação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir expressões condicionais booleanas simples",
                                  "subSteps": [
                                    "Revise operadores relacionais: ==, !=, >, <, >=, <=",
                                    "Crie condições com variáveis numéricas, como idade > 18",
                                    "Teste condições em console ou calculadora para verificar verdadeiro/falso",
                                    "Pratique com strings: nome == 'João'",
                                    "Combine com NOT (!condição) para inverter"
                                  ],
                                  "verification": "Liste 5 condições diferentes e avalie manualmente se são verdadeiras ou falsas para valores de teste",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou console interativo",
                                    "Papel e caneta para fluxogramas"
                                  ],
                                  "tips": "Use valores de borda como 0, 1, -1 para testar condições numéricas",
                                  "learningObjective": "Criar condições booleanas precisas para ramificações binárias",
                                  "commonMistakes": [
                                    "Confundir == com =",
                                    "Ignorar maiúsculas/minúsculas em strings",
                                    "Erro em operadores compostos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar um programa completo com if-else",
                                  "subSteps": [
                                    "Defina um problema binário: ex. verificar se número é par ou ímpar",
                                    "Declare variáveis de entrada (input do usuário)",
                                    "Escreva o if-else com condição (numero % 2 == 0)",
                                    "Adicione saídas (print) nos blocos if e else",
                                    "Execute o programa com pelo menos 3 entradas diferentes"
                                  ],
                                  "verification": "O programa produz saída correta para entradas pares e ímpares",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex. VS Code, Replit)",
                                    "Interpretador Python ou pseudocódigo"
                                  ],
                                  "tips": "Use input() para tornar interativo e teste com números negativos",
                                  "learningObjective": "Integrar if-else em um programa funcional para decisões mutuamente exclusivas",
                                  "commonMistakes": [
                                    "Não converter input para int",
                                    "Erro no operador módulo %",
                                    "Bloco else vazio"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e refinar o código",
                                  "subSteps": [
                                    "Crie tabela de testes: entradas esperadas vs. reais",
                                    "Execute com casos edge: 0, números grandes, inválidos",
                                    "Identifique bugs e corrija (ex. divisão por zero implícita)",
                                    "Adicione comentários explicando a lógica",
                                    "Refatore para maior clareza, como variáveis descritivas"
                                  ],
                                  "verification": "Todos os testes passam e código está comentado",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de testes em planilha",
                                    "Debugger do editor"
                                  ],
                                  "tips": "Registre prints de debug temporários para rastrear fluxo",
                                  "learningObjective": "Garantir robustez do if-else através de testes sistemáticos",
                                  "commonMistakes": [
                                    "Não testar casos falsos",
                                    "Ignorar entradas inválidas",
                                    "Deixar código sem comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa em Python que verifica elegibilidade para voto: idade = int(input('Idade: ')); if idade >= 18: print('Pode votar'); else: print('Não pode votar'). Teste com 16 e 20 anos.",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe",
                                "Bloco if ativa corretamente para condição verdadeira",
                                "Bloco else ativa para condição falsa",
                                "Programa lida com múltiplas entradas sem falhas",
                                "Saídas são claras e corretas",
                                "Lógica é mutuamente exclusiva (não sobrepõe)"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe do if-else 100% correta",
                                "Condições booleanas precisas e sem ambiguidades",
                                "Blocos de código funcionais e indentados",
                                "Tratamento adequado de entradas do usuário",
                                "Testes cobrem cenários verdadeiro e falso",
                                "Código legível com comentários"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operadores relacionais e lógica booleana",
                                "Língua Portuguesa: Estruturas condicionais em narrativas (se-então)",
                                "Ciências: Tomada de decisões em experimentos (hipótese verdadeira/falsa)",
                                "Educação Financeira: Verificar saldo suficiente para compra"
                              ],
                              "realWorldApplication": "Em aplicativos de e-commerce, verificar se estoque > 0 para permitir compra (if) ou mostrar 'indisponível' (else); ou em jogos, se vida > 0 continua jogando, senão game over."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Construir condicionais aninhadas",
                            "description": "Aninhar múltiplos comandos if-else para lidar com condições complexas e múltiplas ramificações lógicas, garantindo a correta indentação e precedência de avaliações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender condicionais básicas e a necessidade de aninhamento",
                                  "subSteps": [
                                    "Revise a sintaxe de comandos if, else if e else em uma linguagem de programação como Python ou JavaScript.",
                                    "Analise exemplos simples onde uma única condição não basta, como verificar idade e depois categoria.",
                                    "Desenhe um fluxograma representando decisões sequenciais dependentes.",
                                    "Identifique cenários reais que exigem ramificações múltiplas, como classificação de usuários.",
                                    "Compare aninhamento com uso de operadores lógicos AND/OR para entender diferenças."
                                  ],
                                  "verification": "Crie um fluxograma manual ou digital de um cenário com condições dependentes e explique oralmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (ex: VS Code)",
                                    "Papel e caneta para fluxograma",
                                    "Documentação da linguagem escolhida"
                                  ],
                                  "tips": "Comece sempre pelo caso mais restritivo para evitar redundâncias.",
                                  "learningObjective": "Reconhecer quando condicionais simples são insuficientes e aninhamento é necessário.",
                                  "commonMistakes": [
                                    "Confundir aninhamento com condições paralelas usando && ou ||",
                                    "Ignorar precedência de condições externas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir aninhamentos simples de dois níveis",
                                  "subSteps": [
                                    "Escreva um if externo com uma condição básica (ex: idade >= 18).",
                                    "Dentro do bloco if, adicione um if interno para uma condição dependente (ex: possui_cnh == true).",
                                    "Adicione blocos else correspondentes em cada nível.",
                                    "Teste o código com entradas variadas para validar o fluxo.",
                                    "Verifique e corrija a indentação para garantir legibilidade."
                                  ],
                                  "verification": "Execute o código com 4 cenários de teste diferentes e confirme saídas corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com interpretador (ex: Python IDLE ou Replit)",
                                    "Conjunto de dados de teste pré-definidos"
                                  ],
                                  "tips": "Use print statements temporários para rastrear o fluxo de execução.",
                                  "learningObjective": "Implementar corretamente aninhamentos de dois níveis com indentação adequada.",
                                  "commonMistakes": [
                                    "Esquecer de indentar blocos internos",
                                    "Colocar else no nível errado",
                                    "Não testar casos de borda como idade == 18"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir para aninhamentos múltiplos e chains de else-if",
                                  "subSteps": [
                                    "Adicione um terceiro nível de aninhamento ou converta para chain de else-if (ex: else if idade < 16).",
                                    "Incorpore múltiplas ramificações lógicas com operadores de comparação (> , < , ==).",
                                    "Priorize a ordem de avaliação para otimizar precedência (condições mais específicas primeiro).",
                                    "Refatore código existente para usar aninhamento eficiente, evitando profundidade excessiva.",
                                    "Adicione comentários explicando a lógica de cada ramificação."
                                  ],
                                  "verification": "Refatore um código fornecido com 3+ níveis e demonstre redução de complexidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código de exemplo inicial com falhas",
                                    "Ferramenta de linting para indentação (ex: pylint)"
                                  ],
                                  "tips": "Limite aninhamento a 3 níveis; use funções para lógica complexa.",
                                  "learningObjective": "Manipular estruturas condicionais complexas com chains e múltiplos níveis.",
                                  "commonMistakes": [
                                    "Ordem incorreta de condições levando a avaliações desnecessárias",
                                    "Excesso de aninhamento tornando código ilegível",
                                    "Erro em operadores lógicos misturados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Depurar, testar e otimizar condicionais aninhadas",
                                  "subSteps": [
                                    "Introduza erros propositais (ex: indentação errada, condição invertida) e depure usando debugger.",
                                    "Crie testes unitários para todos os caminhos lógicos possíveis.",
                                    "Meça cobertura de código e identifique caminhos não testados.",
                                    "Otimize para performance, priorizando condições rápidas no topo.",
                                    "Documente o código final com fluxograma atualizado."
                                  ],
                                  "verification": "Gere relatório de testes mostrando 100% de cobertura de caminhos condicionais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de debugging (ex: pdb no Python)",
                                    "Framework de testes (ex: unittest)",
                                    "Gerador de fluxogramas online"
                                  ],
                                  "tips": "Use rubber duck debugging: explique o código para um objeto inanimado.",
                                  "learningObjective": "Garantir robustez e eficiência em condicionais aninhadas através de depuração.",
                                  "commonMistakes": [
                                    "Não testar caminhos else raros",
                                    "Ignorar warnings de linting",
                                    "Sobre-otimizar prematuramente"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa em Python que classifica um motorista: se idade >= 18 e possui_cnh: se experiencia > 2 anos: 'Profissional'; else: 'Aprendiz'; else if idade >= 16: 'Pode tirar CNH'; else: 'Menor de idade restrito'. Teste com entradas: (20, true, 3), (17, false, 0), (15, true, 1).",
                              "finalVerifications": [
                                "O código executa sem erros de sintaxe ou runtime para todos os cenários de teste.",
                                "Indentação está consistente em todos os níveis (4 espaços por nível).",
                                "Todos os caminhos lógicos produzem saídas corretas conforme especificação.",
                                "Fluxograma corresponde exatamente ao código implementado.",
                                "Código é legível com comentários em cada ramificação principal.",
                                "Cobertura de testes atinge pelo menos 90% dos caminhos condicionais."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: todas as condições precedem e ramificam adequadamente (30%).",
                                "Qualidade de código: indentação, comentários e nomenclatura clara (25%).",
                                "Cobertura de testes: variedade de casos incluindo bordas (20%).",
                                "Eficiência: ordem otimizada de avaliações sem redundâncias (15%).",
                                "Documentação: fluxograma e explicação da precedência (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores de decisão e lógica proposicional (aninhamentos como implicações condicionais).",
                                "Língua Portuguesa: Estruturação de textos argumentativos com premissas dependentes.",
                                "Ciências Humanas: Tomada de decisões éticas em cenários ramificados (ex: dilemas morais).",
                                "Matemática Aplicada: Algoritmos de classificação em estatística.",
                                "Artes: Fluxogramas como representação visual de narrativas condicionais."
                              ],
                              "realWorldApplication": "Em sistemas de e-commerce para verificar elegibilidade de frete grátis (região > valor > tipo de usuário); em jogos para níveis de dificuldade baseados em score > itens > fase; ou em apps de saúde para alertas condicionais (idade > sintomas > risco)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Comandos Repetitivos",
                        "description": "Estruturas de repetição que executam blocos de código múltiplas vezes enquanto uma condição é satisfeita, incluindo loops while, do-while e for, para automação de tarefas iterativas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Aplicar loop while",
                            "description": "Implementar o loop while para repetir instruções enquanto uma condição booleana permanecer verdadeira, controlando o número de iterações com variáveis de controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito e a estrutura do loop while",
                                  "subSteps": [
                                    "Estude a definição: o loop while repete um bloco de código enquanto uma condição booleana for verdadeira.",
                                    "Identifique os componentes principais: condição inicial, corpo do loop e ausência de contador automático.",
                                    "Compare com loop for: while é ideal para repetições indefinidas baseadas em condições dinâmicas.",
                                    "Analise diagramas de fluxo para visualizar o ciclo de verificação-condição-execução.",
                                    "Pratique mentalmente cenários onde while é necessário, como aguardar input válido."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os componentes do while e dê um exemplo simples de uso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de fluxo do loop while (impresso ou digital)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Sempre pense na condição de parada para evitar loops infinitos.",
                                  "learningObjective": "Entender quando e por que usar o loop while em vez de outras estruturas.",
                                  "commonMistakes": [
                                    "Confundir com loop for",
                                    "Ignorar a necessidade de alterar a condição dentro do loop"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a sintaxe básica do loop while",
                                  "subSteps": [
                                    "Escreva a sintaxe padrão: while (condicao): bloco_de_codigo",
                                    "Implemente uma condição booleana simples, como 'contador < 5'.",
                                    "Adicione indentação correta no corpo do loop.",
                                    "Teste um loop while simples que imprima 'Olá' 3 vezes.",
                                    "Experimente alterar a condição para observar o impacto no número de iterações."
                                  ],
                                  "verification": "Execute o código e confirme que imprime exatamente 3 vezes sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Replit)",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Use print() dentro do loop para depurar e ver iterações.",
                                  "learningObjective": "Escrever sintaxe correta e funcional do loop while.",
                                  "commonMistakes": [
                                    "Esquecer os dois pontos após a condição",
                                    "Indentação incorreta levando a SyntaxError"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar controle de iterações com variáveis",
                                  "subSteps": [
                                    "Inicialize uma variável de controle antes do loop (ex: contador = 0).",
                                    "Inclua atualização da variável no corpo do loop (ex: contador += 1).",
                                    "Use a variável na condição (ex: while contador < 10).",
                                    "Adicione lógica adicional, como somar valores em cada iteração.",
                                    "Teste com diferentes valores iniciais para validar o controle."
                                  ],
                                  "verification": "O loop executa exatamente o número esperado de iterações e produz saída correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python instalado ou online IDE"
                                  ],
                                  "tips": "Sempre atualize a variável de controle para garantir parada.",
                                  "learningObjective": "Controlar precisamente o número de repetições usando variáveis.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar a variável",
                                    "Não atualizar a variável causando loop infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e depurar loops while em problemas reais",
                                  "subSteps": [
                                    "Resolva um problema: some números pares de 1 a 20 usando while.",
                                    "Identifique e corrija loops infinitos propositalmente induzidos.",
                                    "Adicione break para saída condicional antecipada.",
                                    "Otimize o código adicionando comentários e variáveis descritivas.",
                                    "Compare performance com loop for equivalente."
                                  ],
                                  "verification": "Código soma corretamente (soma = 110) e executa sem loops infinitos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Documentação Python while loop"
                                  ],
                                  "tips": "Use debugger ou prints para rastrear valores da variável de controle.",
                                  "learningObjective": "Aplicar while em cenários práticos e depurar erros comuns.",
                                  "commonMistakes": [
                                    "Usar break desnecessariamente",
                                    "Condições lógicas incorretas"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa em Python que peça números ao usuário até que ele digite 0, somando todos os números inseridos. Use while com variável soma inicializada em 0 e input() na condição: numero = int(input('Digite um número (0 para parar):')); while numero != 0: soma += numero; numero = int(input('Digite um número (0 para parar):')); print('Soma total:', soma).",
                              "finalVerifications": [
                                "O loop inicia corretamente com a condição verdadeira.",
                                "Cada iteração executa o bloco de código esperado.",
                                "A condição torna-se falsa no momento certo, parando o loop.",
                                "Nenhuma iteração extra ou infinita ocorre.",
                                "Variáveis de controle são atualizadas adequadamente.",
                                "Saída final reflete o controle preciso de iterações."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe e indentação (sem erros de compilação).",
                                "Condição booleana lógica e variável de controle funcional.",
                                "Número exato de iterações conforme especificado.",
                                "Ausência de loops infinitos ou saídas prematuras.",
                                "Código legível com comentários explicativos.",
                                "Eficiência e simplicidade na implementação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Condições booleanas e desigualdades.",
                                "Física: Simulações de processos repetitivos (ex: movimento uniforme).",
                                "Matemática Computacional: Algoritmos iterativos para séries.",
                                "Lógica: Raciocínio dedutivo em verificação de condições."
                              ],
                              "realWorldApplication": "Em jogos, loops while controlam animações até colisão (ex: mover personagem enquanto não bater na parede); em apps bancários, processam transações enquanto saldo positivo; em automação industrial, repetem verificações de sensores até condição de segurança atendida."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Utilizar loop do-while",
                            "description": "Criar loops do-while que garantem pelo menos uma execução do bloco antes de verificar a condição, ideal para validações de entrada de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe e o funcionamento do loop do-while",
                                  "subSteps": [
                                    "Estude a sintaxe básica: do { bloco de código } while (condição);",
                                    "Analise o fluxo: o bloco executa primeiro, depois a condição é verificada.",
                                    "Compare com o loop while: do-while garante pelo menos uma execução.",
                                    "Identifique usos ideais, como validações de entrada que precisam de uma tentativa inicial.",
                                    "Leia exemplos em pseudocódigo ou na linguagem escolhida (ex: C, Java, Python)."
                                  ],
                                  "verification": "Explique por escrito ou verbalmente a diferença entre do-while e while, com um diagrama de fluxo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem de programação",
                                    "Editor de texto ou IDE",
                                    "Vídeo tutorial curto sobre loops"
                                  ],
                                  "tips": [
                                    "Sempre inclua o ponto e vírgula após a condição.",
                                    "Desenhe o fluxo de execução no papel para fixar."
                                  ],
                                  "learningObjective": "Dominar a sintaxe e o fluxo lógico do loop do-while.",
                                  "commonMistakes": [
                                    "Esquecer o ';' após while(condição)",
                                    "Confundir o ordem de execução com while tradicional",
                                    "Usar do-while quando while seria suficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar um loop do-while simples para contagem",
                                  "subSteps": [
                                    "Crie um programa que inicialize uma variável contador = 1.",
                                    "Use do { imprimir(contador); contador++; } while (contador <= 5);",
                                    "Execute o programa e verifique a saída (deve imprimir 1 a 5).",
                                    "Modifique para contagem regressiva (ex: de 5 a 1).",
                                    "Teste alterando a condição para observar o impacto."
                                  ],
                                  "verification": "Confirme que o programa imprime exatamente 5 números e para corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE ou editor de código online (ex: Replit, CodePen)",
                                    "Compilador da linguagem"
                                  ],
                                  "tips": [
                                    "Use variáveis com nomes descritivos como 'contador' para clareza.",
                                    "Adicione prints de debug para rastrear o valor da variável."
                                  ],
                                  "learningObjective": "Construir e testar um loop do-while básico com incremento.",
                                  "commonMistakes": [
                                    "Incrementar a variável fora do loop",
                                    "Condição errada levando a loop infinito",
                                    "Não inicializar a variável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar do-while em validação de entrada de dados",
                                  "subSteps": [
                                    "Desenvolva um programa que solicite uma idade ao usuário.",
                                    "Use do { ler idade; } while (idade < 0 || idade > 150);",
                                    "Adicione mensagem de erro no loop para inputs inválidos.",
                                    "Teste com entradas inválidas (negativas, muito altas) e válidas.",
                                    "Integre com uma ação final, como imprimir 'Idade válida: X anos'."
                                  ],
                                  "verification": "Insira valores inválidos várias vezes e confirme que só para com valor válido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Console ou interface de input/output",
                                    "Exemplos de input de teste pré-definidos"
                                  ],
                                  "tips": [
                                    "Use funções de input robustas que tratem strings como números.",
                                    "Limite tentativas extras para evitar frustração no teste."
                                  ],
                                  "learningObjective": "Utilizar do-while para garantir entrada válida com pelo menos uma tentativa.",
                                  "commonMistakes": [
                                    "Não converter string para int/float",
                                    "Loop infinito por input não numérico",
                                    "Condição lógica invertida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Debugar, otimizar e praticar cenários avançados",
                                  "subSteps": [
                                    "Identifique e corrija um código com loop infinito intencional.",
                                    "Crie um menu interativo: do { mostrar menu; ler opção; } while (opção != 0);",
                                    "Otimize adicionando break para condições especiais.",
                                    "Teste com múltiplos cenários e registre erros encontrados.",
                                    "Refatore o código para maior legibilidade."
                                  ],
                                  "verification": "O menu responde corretamente a opções e sai apenas com 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Códigos de exemplo com erros comuns",
                                    "Ferramentas de debug (breakpoints)"
                                  ],
                                  "tips": [
                                    "Use logs condicionais para monitorar iterações.",
                                    "Planeje a condição de saída clara desde o início."
                                  ],
                                  "learningObjective": "Debugar loops do-while e aplicá-los em estruturas interativas.",
                                  "commonMistakes": [
                                    "Falta de break em casos especiais",
                                    "Variáveis não resetadas entre iterações",
                                    "Menu sem opções claras"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa de validação de senha: do { printf('Digite a senha: '); scanf('%s', senha); } while (strcmp(senha, '123456') != 0); printf('Acesso concedido!'); – Garante pelo menos uma tentativa de digitação.",
                              "finalVerifications": [
                                "O loop executa pelo menos uma vez, independentemente da condição inicial.",
                                "O programa sai corretamente quando a condição se torna falsa.",
                                "Não há loop infinito em testes com condições falsas.",
                                "Inputs inválidos são tratados sem crash.",
                                "Saída final reflete o resultado esperado.",
                                "Código é legível e comentado."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta do do-while com ';' final.",
                                "Condição lógica precisa e sem ambiguidades.",
                                "Execução garantida de pelo menos uma iteração.",
                                "Tratamento adequado de erros de input.",
                                "Eficiência: evita loops desnecessários.",
                                "Código testado com casos edge (ex: input zero, negativo)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e condições compostas.",
                                "Português: Documentação de código com comentários claros.",
                                "Física/Engenharia: Modelagem de processos iterativos em simulações.",
                                "Ética: Validação de dados para segurança em sistemas."
                              ],
                              "realWorldApplication": "Validação de formulários em aplicativos web/mobile (ex: senhas, emails), menus de jogos que exigem escolha inicial, sistemas de login bancários que pedem PIN até acertar, e automação de testes que rodam pelo menos uma vez."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Implementar loop for",
                            "description": "Desenvolver loops for com inicialização, condição e incremento para iterações conhecidas, como percorrer arrays ou contar de 1 a N.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe e componentes do loop for",
                                  "subSteps": [
                                    "Identificar a inicialização da variável de controle (ex: i = 0)",
                                    "Explicar a condição de parada (ex: i < 10)",
                                    "Descrever o incremento/decremento (ex: i++)",
                                    "Entender o corpo do loop onde as ações são executadas",
                                    "Visualizar o fluxo com um diagrama simples"
                                  ],
                                  "verification": "Desenhar e explicar um diagrama de fluxo do loop for com todos os componentes",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama online (ex: draw.io)",
                                    "Editor de código simples"
                                  ],
                                  "tips": "Sempre leia o loop como: 'inicie i em 0; enquanto i menor que 10; incremente i'",
                                  "learningObjective": "Dominar os quatro componentes essenciais do loop for: inicialização, condição, incremento e corpo",
                                  "commonMistakes": [
                                    "Confundir inicialização com condição",
                                    "Esquecer o incremento, causando loop infinito",
                                    "Colocar o incremento fora do corpo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar loop for para contagem simples",
                                  "subSteps": [
                                    "Escrever código para imprimir números de 1 a 10",
                                    "Testar o código executando e verificando saída",
                                    "Modificar para contar de 5 a 15 com passo 2 (ex: i += 2)",
                                    "Adicionar uma ação no corpo, como somar os números",
                                    "Debugar se o loop não para corretamente"
                                  ],
                                  "verification": "O programa imprime exatamente os números esperados sem erros ou loops infinitos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Replit)",
                                    "Pseudocódigo ou linguagem como Python/JS"
                                  ],
                                  "tips": "Use console.log/print para visualizar o valor de i em cada iteração",
                                  "learningObjective": "Criar e executar loops for para iterações conhecidas com contagem linear",
                                  "commonMistakes": [
                                    "Iniciar em 0 em vez de 1 quando pedido",
                                    "Incremento incorreto levando a skips ou overshoot",
                                    "Condição que nunca falha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar loop for para percorrer arrays",
                                  "subSteps": [
                                    "Declarar um array de exemplo (ex: [10, 20, 30])",
                                    "Escrever loop for usando length do array como condição (ex: for i=0; i<array.length; i++)",
                                    "Acessar elementos com array[i] e imprimir/somar",
                                    "Modificar para arrays maiores e com diferentes tipos de dados",
                                    "Adicionar filtro simples (ex: somar apenas pares)"
                                  ],
                                  "verification": "O loop acessa todos os elementos corretamente e produz saída esperada",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Arrays de teste pré-definidos"
                                  ],
                                  "tips": "Sempre use array.length para evitar hardcoding e erros em mudanças de tamanho",
                                  "learningObjective": "Iterar sobre coleções de dados usando índice controlado por loop for",
                                  "commonMistakes": [
                                    "Acessar array[i] com i >= length causando erro",
                                    "Usar for sem índice para arrays inicialmente",
                                    "Ignorar off-by-one errors no limite"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar loop for com lógica e resolver problemas reais",
                                  "subSteps": [
                                    "Resolver problema: somar elementos de array até encontrar zero",
                                    "Adicionar validações (ex: array vazio)",
                                    "Otimizar com break ou continue",
                                    "Testar com múltiplos cenários (arrays vazios, negativos)",
                                    "Refatorar código para reutilização"
                                  ],
                                  "verification": "Código resolve problema corretamente em todos os casos de teste",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Conjunto de testes unitários simples"
                                  ],
                                  "tips": "Inclua comentários explicando a lógica da condição e incremento",
                                  "learningObjective": "Integrar loop for em soluções de problemas com controle de fluxo adicional",
                                  "commonMistakes": [
                                    "Loop infinito em arrays vazios",
                                    "Uso incorreto de break/continue",
                                    "Não tratar edge cases como array vazio"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Debuggar e otimizar loops for",
                                  "subSteps": [
                                    "Identificar loops infinitos comuns e corrigi-los",
                                    "Medir performance comparando com outros loops",
                                    "Converter loop for em for-of ou range-based se aplicável",
                                    "Adicionar logs para tracing",
                                    "Realizar code review simulada"
                                  ],
                                  "verification": "Código otimizado executa sem erros e com eficiência",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas de debug (breakpoints no editor)",
                                    "Profiler simples"
                                  ],
                                  "tips": "Use debugger para pausar e inspecionar i em cada iteração",
                                  "learningObjective": "Diagnosticar e melhorar loops for para robustez e performance",
                                  "commonMistakes": [
                                    "Ignorar performance em grandes arrays",
                                    "Não limpar variáveis de controle pós-loop",
                                    "Sobre-otimizar prematuramente"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um loop for para calcular e imprimir a soma dos primeiros 10 números pares: resultado deve ser 110 (2+4+...+20). Código exemplo em pseudocódigo: soma = 0; for i=2 to 20 step 2 { soma += i } print(soma).",
                              "finalVerifications": [
                                "O loop executa exatamente o número esperado de iterações sem infinitos",
                                "Variável de controle inicia, incrementa e para corretamente",
                                "Corpo do loop processa dados sem erros de índice",
                                "Saída corresponde aos valores esperados em testes múltiplos",
                                "Código lida com edge cases como N=0 ou array vazio"
                              ],
                              " ": [
                                "realWorldApplication realWorldApplication "
                              ],
                              ":[": [
                                "Matemática: Cálculo de somatórios, séries aritméticas e iterações em sequências",
                                "Estatística: Processamento de datasets iterativos para médias e somas",
                                "Física: Simulações de movimento com passos temporais discretos",
                                "Economia: Cálculos repetitivos em planilhas financeiras (ex: juros compostos)",
                                "Design: Geração procedural de padrões repetitivos em gráficos"
                              ]
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.4",
                            "name": "Controlar loops com break e continue",
                            "description": "Inserir comandos break para sair prematuramente de um loop e continue para pular iterações, otimizando o fluxo em estruturas repetitivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de break e continue",
                                  "subSteps": [
                                    "Estudar a definição de break: comando que interrompe imediatamente a execução do loop mais interno.",
                                    "Estudar a definição de continue: comando que pula o restante da iteração atual e vai para a próxima.",
                                    "Comparar break e continue com exemplos visuais de fluxogramas.",
                                    "Identificar diferenças em loops for e while.",
                                    "Analisar quando NÃO usar esses comandos para evitar lógica incorreta."
                                  ],
                                  "verification": "Explicar em voz alta ou por escrito a diferença entre break e continue com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code ou Replit)",
                                    "Documentação oficial da linguagem (Python ou similar)"
                                  ],
                                  "tips": "Desenhe fluxogramas para visualizar o fluxo de controle antes de codificar.",
                                  "learningObjective": "Diferenciar conceitualmente break e continue e seus impactos no fluxo de loops.",
                                  "commonMistakes": [
                                    "Confundir break com exit() do programa inteiro",
                                    "Pensar que continue para o loop todo",
                                    "Usar em contextos aninhados sem cuidado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o comando break em loops simples",
                                  "subSteps": [
                                    "Criar um loop while que simule busca em uma lista até encontrar um valor específico.",
                                    "Inserir break condicionalmente quando o valor for encontrado.",
                                    "Testar o código com valores presentes e ausentes na lista.",
                                    "Modificar para loop for e verificar comportamento.",
                                    "Adicionar prints para observar o ponto de interrupção."
                                  ],
                                  "verification": "Executar o código e confirmar que o loop para exatamente após encontrar o item alvo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente de programação interativo (ex: Jupyter Notebook)",
                                    "Lista de números ou strings para teste"
                                  ],
                                  "tips": "Use print('Saindo do loop!') logo após break para depuração visual.",
                                  "learningObjective": "Aplicar break para otimizar loops de busca e evitar processamento desnecessário.",
                                  "commonMistakes": [
                                    "Esquecer a condição if antes do break",
                                    "Break sem condição levando a loop infinito",
                                    "Não testar casos onde break não é acionado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o comando continue em loops para pular iterações",
                                  "subSteps": [
                                    "Criar um loop for que itere sobre números de 1 a 20.",
                                    "Usar continue para pular números pares ou múltiplos de 3.",
                                    "Adicionar contadores para verificar quantas iterações foram puladas.",
                                    "Testar com diferentes condições de skip.",
                                    "Combinar com prints seletivos para itens processados."
                                  ],
                                  "verification": "Verificar que apenas itens não pulados são processados e contados corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Calculadora para validar contagens manuais"
                                  ],
                                  "tips": "Coloque continue no início da iteração para evitar código desnecessário após ele.",
                                  "learningObjective": "Usar continue para filtrar iterações indesejadas eficientemente.",
                                  "commonMistakes": [
                                    "Colocar continue após todo o código da iteração, tornando-o inútil",
                                    "Confundir com break em filtros",
                                    "Incremento manual afetado incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar break e continue em loops complexos com validações",
                                  "subSteps": [
                                    "Desenvolver um loop que processe uma lista de transações bancárias.",
                                    "Usar continue para pular transações inválidas (ex: valor negativo).",
                                    "Usar break se encontrar uma transação fraudulenta (ex: valor > 10000).",
                                    "Adicionar logs e tratamento de exceções básicas.",
                                    "Refatorar para cenários aninhados (loop dentro de loop)."
                                  ],
                                  "verification": "Rodar com dados de teste variados e inspecionar logs para confirmar saídas e pulos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de dados simulados em arquivo JSON ou array",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Sempre valide condições com ifs claros e use comentários explicativos.",
                                  "learningObjective": "Integrar break e continue para controle avançado de fluxo em aplicações reais.",
                                  "commonMistakes": [
                                    "Aninhamento levando a break/continue no loop errado",
                                    "Lógica condicional mal indentada",
                                    "Falta de testes edge-case"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de login, use um loop while para tentar senhas: continue pula tentativas com senha vazia; break sai se acertar ou exceder 3 tentativas, evitando brute-force infinito.",
                              "finalVerifications": [
                                "Explica a diferença entre break e continue sem hesitação.",
                                "Escreve código funcional com ambos comandos em menos de 5 minutos.",
                                "Identifica e corrige erros em códigos alheios usando break/continue.",
                                "Aplica em loops aninhados corretamente.",
                                "Otimiza um loop ineficiente substituindo por break/continue.",
                                "Testa cenários edge-case sem bugs."
                              ],
                              "assessmentCriteria": [
                                "Código executa sem erros de sintaxe ou runtime.",
                                "Break interrompe o loop no ponto exato esperado.",
                                "Continue pula iterações corretamente sem afetar o contador.",
                                "Eficiência: reduz iterações desnecessárias em pelo menos 20%.",
                                "Código legível com comentários e indentação adequada.",
                                "Funciona em for, while e loops aninhados.",
                                "Tratamento de casos inválidos ou vazios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e séries, otimizando somas parciais com break.",
                                "Lógica Matemática: Condicionais e fluxogramas para modelar controle de fluxo.",
                                "Engenharia de Software: Boas práticas de otimização e legibilidade de código.",
                                "Análise de Dados: Filtragem de datasets com continue em loops de processamento."
                              ],
                              "realWorldApplication": "Em processamento de logs de servidores, use continue para ignorar linhas malformadas e break para parar ao detectar erro crítico, economizando recursos e tempo em grandes volumes de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Comandos Seletivos",
                        "description": "Estruturas que selecionam uma entre múltiplas opções baseadas no valor de uma expressão, como switch-case, facilitando decisões multi-ramificadas sem aninhamentos excessivos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Implementar estrutura switch-case",
                            "description": "Criar comandos switch para mapear valores discretos de uma variável a ações específicas, incluindo o caso default para valores não previstos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe e estrutura do switch-case",
                                  "subSteps": [
                                    "Analise a sintaxe geral: switch (variavel) { case valor1: acoes; break; case valor2: acoes; break; ... default: acoes; }",
                                    "Identifique componentes obrigatórios e opcionais: expressão de controle, cases, break e default",
                                    "Compare com if-else aninhado para entender vantagens em valores discretos",
                                    "Estude exemplos em pseudocódigo ou linguagem alvo (ex: C, JavaScript)",
                                    "Anote diferenças: switch requer valores exatos e compatíveis (inteiros, chars, strings em algumas linguagens)"
                                  ],
                                  "verification": "Escreva a sintaxe completa de um switch-case simples e explique cada parte em voz alta ou por escrito",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem de programação",
                                    "Editor de texto ou IDE para anotar exemplos",
                                    "Vídeo tutorial curto sobre switch-case"
                                  ],
                                  "tips": [
                                    "Sempre inclua 'break' para evitar execução de cases subsequentes",
                                    "Use switch para valores finitos e conhecidos, não para ranges"
                                  ],
                                  "learningObjective": "Dominar a sintaxe e os componentes essenciais do switch-case",
                                  "commonMistakes": [
                                    "Esquecer o 'break' causando fall-through",
                                    "Usar switch com variáveis de tipo inadequado (ex: floats)",
                                    "Confundir com if-else para condições complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar um switch-case simples com um case",
                                  "subSteps": [
                                    "Declare uma variável de controle discreta (ex: int dia = 1;)",
                                    "Escreva o switch com um case específico: case 1: printf('Segunda'); break;",
                                    "Compile e execute o código para testar o case único",
                                    "Adicione um print fora do switch para confirmar fluxo",
                                    "Modifique o valor da variável e verifique se ignora cases inexistentes"
                                  ],
                                  "verification": "Execute o programa com valor do case e valor diferente; confirme saída correta sem erros",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE ou compilador online (ex: Replit, CodePen)",
                                    "Pseudocódigo de exemplo"
                                  ],
                                  "tips": [
                                    "Teste imediatamente após codificar para identificar erros de sintaxe cedo",
                                    "Use valores pequenos para prototipagem rápida"
                                  ],
                                  "learningObjective": "Criar e executar um switch-case básico funcional",
                                  "commonMistakes": [
                                    "Falta de ponto e vírgula após break",
                                    "Erro de digitação no case value",
                                    "Não declarar a variável corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar múltiplos cases e o case default",
                                  "subSteps": [
                                    "Expanda com 3-4 cases adicionais (ex: case 2: 'Terça'; break; etc.)",
                                    "Inclua default: default: printf('Dia inválido');",
                                    "Teste todos os cases e o default com inputs variados",
                                    "Adicione fall-through intencional em um case se aplicável (ex: case 1: case 2: ação comum; break;)",
                                    "Refatore para garantir ordem lógica dos cases"
                                  ],
                                  "verification": "Registre saídas para 5 valores de teste: 3 válidos, 1 duplicado e 1 inválido",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador/interpretador",
                                    "Planilha para registrar testes de input/output"
                                  ],
                                  "tips": [
                                    "Coloque default no final para capturar todos os não previstos",
                                    "Cases podem compartilhar código com fall-through controlado"
                                  ],
                                  "learningObjective": "Construir switch-case robusto com cobertura completa de cenários",
                                  "commonMistakes": [
                                    "Default ausente levando a saídas vazias",
                                    "Cases fora de ordem afetando legibilidade",
                                    "Break faltando em múltiplos cases"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar switch-case em um programa maior e depurar",
                                  "subSteps": [
                                    "Incorpore o switch em um loop ou função (ex: menu interativo com input do usuário)",
                                    "Adicione validação de input antes do switch",
                                    "Teste cenários de erro: valores inválidos, edge cases",
                                    "Depure usando debugger ou prints para rastrear fluxo",
                                    "Otimize: remova redundâncias e melhore legibilidade com comentários"
                                  ],
                                  "verification": "Execute programa completo 10 vezes com inputs variados; todas saídas corretas sem crashes",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com debugger (ex: VS Code, Eclipse)",
                                    "Conjunto de testes pré-definidos"
                                  ],
                                  "tips": [
                                    "Use scanner/input para tornar interativo",
                                    "Comente cada case para clareza"
                                  ],
                                  "learningObjective": "Aplicar switch-case em contexto real e garantir robustez",
                                  "commonMistakes": [
                                    "Input não convertido corretamente para tipo do switch",
                                    "Loop infinito sem break/return",
                                    "Ignorar edge cases como valores extremos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa de menu de restaurante: leia um número (1-5) para pratos (1: Pizza - R$20; 2: Hambúrguer - R$15; ... default: 'Opção inválida'). Some ao total da conta e exiba.",
                              "finalVerifications": [
                                "Switch compila e executa sem erros de sintaxe",
                                "Todos os cases produzem saída correta",
                                "Default captura e trata valores não previstos adequadamente",
                                "Break statements previnem fall-through indesejado",
                                "Programa testa múltiplos cenários incluindo inputs inválidos",
                                "Código é legível com comentários explicativos"
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe e uso apropriado de break/default (40%)",
                                "Cobertura completa de cases e testes (30%)",
                                "Integração fluida em programa maior (15%)",
                                "Eficiência e legibilidade do código (10%)",
                                "Tratamento robusto de erros/edge cases (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Mapeamento de conjuntos discretos e funções de peça",
                                "Lógica Matemática: Árvores de decisão e fluxogramas",
                                "Design de Interfaces: Criação de menus e navegação por opções",
                                "Análise de Dados: Categorização de valores categóricos"
                              ],
                              "realWorldApplication": "Em aplicativos de menu (ex: apps de delivery com opções de pagamento), roteadores de rede (seleção de protocolos por porta), jogos (comandos de jogador por tecla pressionada) e validadores de formulários web (ações por tipo de input)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.4"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Combinar switch com estruturas condicionais",
                            "description": "Integrar switch-case com if-else dentro de cases para lidar com condições adicionais, criando fluxos de controle híbridos eficientes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Switch e If-Else",
                                  "subSteps": [
                                    "Analise a sintaxe básica do switch-case, incluindo cases, break e default.",
                                    "Revise a estrutura if-else, focando em condições aninhadas e múltiplas.",
                                    "Compare switch (para valores discretos) vs if-else (para ranges ou complexos).",
                                    "Identifique limitações do switch puro, como falta de condições booleanas.",
                                    "Estude exemplos simples de cada estrutura em pseudocódigo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças e limitações de cada estrutura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem de programação",
                                    "Exemplos de código básicos em um editor online como Replit"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o comportamento do switch com fall-through opcional.",
                                  "learningObjective": "Compreender os pré-requisitos para integração híbrida de estruturas condicionais.",
                                  "commonMistakes": [
                                    "Esquecer 'break' no switch causando fall-through indesejado",
                                    "Confundir switch com if para condições não-exatas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenários para Uso Híbrido",
                                  "subSteps": [
                                    "Liste situações onde switch seleciona categoria principal e if lida com sub-condições.",
                                    "Exemplo: switch por tipo de usuário, if por nível de acesso dentro de cada case.",
                                    "Avalie eficiência: switch para dispatch rápido, if para lógica adicional.",
                                    "Desenhe fluxogramas híbridos em papel ou ferramenta como Draw.io.",
                                    "Discuta vantagens como legibilidade e performance sobre if-else puro."
                                  ],
                                  "verification": "Crie um fluxograma simples de um cenário híbrido e justifique sua escolha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de fluxogramas gratuita (Draw.io, Lucidchart)",
                                    "Pseudocódigo de exemplos"
                                  ],
                                  "tips": "Priorize switch para enums ou strings finitas para otimizar performance.",
                                  "learningObjective": "Reconhecer quando estruturas híbridas melhoram o fluxo de controle.",
                                  "commonMistakes": [
                                    "Usar switch para muitas condições complexas, preferindo if-else",
                                    "Ignorar default case em switch"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Switch com If-Else Integrado",
                                  "subSteps": [
                                    "Escreva um switch básico com um if-else dentro de um case específico.",
                                    "Teste o código com inputs variados para cobrir todos os branches.",
                                    "Adicione múltiplos ifs em cases diferentes para complexidade.",
                                    "Inclua validações de input antes do switch.",
                                    "Refatore para garantir que breaks evitem vazamentos lógicos."
                                  ],
                                  "verification": "Execute o código com 5 cenários de teste e confirme saídas esperadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, CodePen)",
                                    "Compilador/interpretação online"
                                  ],
                                  "tips": "Use console.log para debuggar branches internos do if.",
                                  "learningObjective": "Construir fluxos de controle híbridos funcionais e corretos.",
                                  "commonMistakes": [
                                    "Colocar if-else fora do case correto",
                                    "Variáveis de escopo incorretas entre estruturas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Otimizar e Documentar o Código Híbrido",
                                  "subSteps": [
                                    "Crie testes unitários para cada case e sub-condição.",
                                    "Meça performance com loops simulando inputs reais.",
                                    "Otimize removendo redundâncias ou usando operadores ternários em ifs simples.",
                                    "Adicione comentários explicando por que o híbrido é superior.",
                                    "Simule erros comuns e corrija-os."
                                  ],
                                  "verification": "Código passa em todos os testes e roda sem warnings/erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas de teste (Jest para JS, JUnit para Java)",
                                    "Profiler básico da linguagem"
                                  ],
                                  "tips": "Considere polimorfismo como alternativa avançada para cenários muito complexos.",
                                  "learningObjective": "Garantir robustez, eficiência e manutenibilidade em fluxos híbridos.",
                                  "commonMistakes": [
                                    "Testes insuficientes em branches raros",
                                    "Sobre-otimização prematura"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de menu de restaurante: switch(dishType) { case 'pizza': if(size === 'large') { price = 25; } else if(size === 'medium') { price = 18; } else { price = 12; } break; case 'burger': if(withFries) { price += 5; } break; default: price = 0; } Isso lida com categoria via switch e variações via if de forma eficiente.",
                              "finalVerifications": [
                                "Código compila/executa sem erros em todos os cases.",
                                "Todos os branches híbridos produzem saídas corretas.",
                                "Performance é otimizada (switch dispatch rápido).",
                                "Documentação cobre lógica híbrida.",
                                "Testes cobrem 100% dos cenários.",
                                "Código é legível com comentários.",
                                "Não há vazamentos lógicos (ex: fall-through)"
                              ],
                              "assessmentCriteria": [
                                "Correção lógica em todos os fluxos híbridos (90%+ cobertura).",
                                "Eficiência: uso apropriado de switch para dispatch principal.",
                                "Legibilidade: estrutura clara, nomes descritivos.",
                                "Robustez: tratamento de edge cases e validações.",
                                "Otimização: ausência de redundâncias desnecessárias.",
                                "Documentação: explicação da escolha híbrida."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e árvores de decisão.",
                                "Design de Sistemas: Fluxos de usuário em UX/UI.",
                                "Engenharia de Software: Padrões de design como Strategy.",
                                "Análise de Dados: Processamento condicional de categorias.",
                                "Física/Engenharia: Controle de processos automatizados."
                              ],
                              "realWorldApplication": "Em aplicativos de e-commerce para processar pedidos (switch por categoria de produto + if por estoque/região), jogos para menus de opções (switch por ação + if por nível do jogador), ou APIs backend para roteamento de requisições com validações adicionais, melhorando escalabilidade e manutenibilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3.1",
                              "10.1.2.3.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Tipos de Dados e Exceções",
                    "description": "Tipos escalares e estruturados, além de tratamento de exceções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Tipos de Dados Escalares",
                        "description": "Tipos de dados primitivos que representam valores únicos e indivisíveis, como inteiros (int), números reais (float/double), caracteres (char) e lógicos (bool), fundamentais para armazenar e manipular informações básicas em algoritmos e programas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar tipos escalares comuns",
                            "description": "Reconhecer e classificar os principais tipos escalares (inteiro, real, caractere, lógico) em linguagens de programação procedimentais, entendendo seu tamanho em memória e intervalos de valores suportados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de tipos escalares",
                                  "subSteps": [
                                    "Defina o que são tipos de dados escalares em programação.",
                                    "Liste os quatro tipos principais: inteiro, real, caractere e lógico.",
                                    "Explique a diferença entre escalar e composto.",
                                    "Identifique linguagens procedimentais comuns como C e Pascal.",
                                    "Pesquise definições em documentação oficial."
                                  ],
                                  "verification": "Escreva uma tabela resumindo os quatro tipos e suas definições básicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de linguagens como C (man pages ou online), caderno para anotações.",
                                  "tips": "Use analogias do dia a dia: inteiro como contagem de maçãs, real como peso.",
                                  "learningObjective": "Reconhecer os tipos escalares comuns e sua distinção de outros tipos.",
                                  "commonMistakes": "Confundir escalares com agregados como arrays."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar características de cada tipo escalar",
                                  "subSteps": [
                                    "Analise o tipo inteiro: variações (short, long), intervalos típicos (-2^31 a 2^31-1 para 32 bits).",
                                    "Examine o tipo real: float e double, precisão e intervalos (ex: 1.2E-38 a 3.4E+38 para float).",
                                    "Descreva caractere: ASCII/Unicode, tamanho 1 byte, valores 0-255.",
                                    "Detalhe lógico: true/false, geralmente 1 byte, valores 0/1.",
                                    "Compare sintaxe de declaração em C: int x; float y; char z; bool w;."
                                  ],
                                  "verification": "Crie flashcards com um tipo por carta, incluindo definição e exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Flashcards digitais (Anki) ou papel, referências de tipos em C/Pascal.",
                                  "tips": "Memorize com mnemônicos: 'IRCL' (Inteiro, Real, Caractere, Lógico).",
                                  "learningObjective": "Classificar cada tipo com suas propriedades fundamentais.",
                                  "commonMistakes": "Ignorar variações como signed/unsigned para inteiros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar tamanhos em memória e intervalos de valores",
                                  "subSteps": [
                                    "Aprenda o conceito de bytes e bits em representação de dados.",
                                    "Use sizeof() em C para medir: sizeof(int), sizeof(float), etc.",
                                    "Liste intervalos: int (4 bytes, -2147483648 a 2147483647), char (1 byte, 0-255).",
                                    "Discuta portabilidade: tamanhos podem variar por compilador/plataforma.",
                                    "Calcule exemplos de overflow/underflow para cada tipo."
                                  ],
                                  "verification": "Compile e execute um programa C que imprima tamanhos e intervalos usando limites.h.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C (GCC online ou local), header <limits.h> e <stdio.h>.",
                                  "tips": "Sempre inclua <limits.h> para INT_MIN/MAX, etc.",
                                  "learningObjective": "Entender alocação de memória e limites para evitar erros de range.",
                                  "commonMistakes": "Assumir tamanhos fixos sem verificar com sizeof()."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e classificação em cenários reais",
                                  "subSteps": [
                                    "Analise trechos de código em C/Pascal e identifique tipos declarados.",
                                    "Classifique variáveis por tipo, tamanho e intervalo possível.",
                                    "Crie um programa que declare todos os tipos e exiba seus valores/tamanhos.",
                                    "Resolva exercícios: 'Qual tipo para armazenar temperatura? Por quê?'",
                                    "Compare com pseudocódigo para generalização."
                                  ],
                                  "verification": "Submeta 5 exercícios resolvidos corretamente, com justificativas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Editor de código (VS Code), compilador, exercícios impressos/online.",
                                  "tips": "Teste edge cases como valores mínimos/máximos.",
                                  "learningObjective": "Aplicar conhecimento para identificar tipos em código procedural.",
                                  "commonMistakes": "Confundir real com inteiro em operações matemáticas."
                                }
                              ],
                              "practicalExample": "Em C, crie um programa: #include <stdio.h> #include <limits.h> int main() { printf('int: %zu bytes, %d a %d\\n', sizeof(int), INT_MIN, INT_MAX); /* Similar para float (FLT_MIN/MAX), char, _Bool */ return 0; } Compile e execute para ver: int ~4 bytes, etc.",
                              "finalVerifications": [
                                "Liste corretamente os 4 tipos escalares com uma declaração em C.",
                                "Informe tamanhos típicos em memória para cada tipo.",
                                "Descreva intervalos de valores para int e float.",
                                "Explique diferença entre char e int em termos de memória.",
                                "Identifique tipo lógico e seu uso em condicionais.",
                                "Diferencie signed/unsigned integers."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação dos 4 tipos (100% correto).",
                                "Correta associação de tamanhos em bytes (erro <1 byte).",
                                "Exatidão nos intervalos de valores citados.",
                                "Capacidade de justificar escolhas de tipo por cenário.",
                                "Demonstração prática via código compilável.",
                                "Identificação de potenciais erros de overflow."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conjuntos numéricos (inteiros, reais) e lógica booleana.",
                                "Física: Representação binária e limites de precisão em medições.",
                                "Matemática Computacional: Análise de complexidade e otimização de memória.",
                                "Lógica: Tabelas-verdade para tipos lógicos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software embarcado (IoT), escolher int de 16 bits economiza memória em microcontroladores; em simulações científicas, float/double gerencia precisão sem overflow em cálculos físicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Declarar e inicializar variáveis escalares",
                            "description": "Escrever declarações corretas de variáveis com tipos escalares e atribuir valores iniciais, utilizando sintaxe de linguagens como C++ ou pseudocódigo, considerando regras de inicialização implícita e explícita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Tipos Escalares Comuns em C++",
                                  "subSteps": [
                                    "Estude os tipos escalares básicos: int (inteiros), float e double (ponto flutuante), char (caractere), bool (booleano).",
                                    "Memorize os intervalos aproximados: int (-2^31 a 2^31-1), float (aprox. 6 dígitos precisão), double (15 dígitos).",
                                    "Anote exemplos de valores válidos para cada tipo: int=42, float=3.14, char='A', bool=true.",
                                    "Compare tamanhos em bytes: sizeof(int), sizeof(float), etc., usando código simples.",
                                    "Crie uma tabela resumindo tipo, tamanho e exemplo."
                                  ],
                                  "verification": "Liste corretamente 5 tipos escalares com um exemplo de valor cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação C++ (cppreference.com/types)",
                                    "Editor de código como VS Code ou Code::Blocks"
                                  ],
                                  "tips": [
                                    "Use sizeof() para verificar tamanhos em tempo de compilação.",
                                    "Priorize double sobre float para maior precisão em cálculos."
                                  ],
                                  "learningObjective": "Compreender os tipos escalares e seus usos fundamentais.",
                                  "commonMistakes": [
                                    "Confundir float com double em precisão.",
                                    "Usar char para strings (use para single char apenas)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Sintaxe de Declaração de Variáveis",
                                  "subSteps": [
                                    "Escreva a sintaxe básica: tipo nomeVariavel; (ex: int x;).",
                                    "Declare múltiplas variáveis na mesma linha: int a, b, c;.",
                                    "Evite nomes inválidos: comece com letra ou _, sem espaços ou palavras reservadas.",
                                    "Pratique declarando 10 variáveis de tipos diferentes sem inicialização.",
                                    "Compile um programa simples apenas com declarações para verificar erros."
                                  ],
                                  "verification": "Compilar um código com 5 declarações diferentes sem erros de sintaxe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou online como repl.it)",
                                    "Template de main() vazio"
                                  ],
                                  "tips": [
                                    "Use camelCase ou snake_case para nomes legíveis.",
                                    "Sempre declare no escopo correto (global ou local)."
                                  ],
                                  "learningObjective": "Escrever declarações sintaticamente corretas sem inicialização.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula (;).",
                                    "Usar nomes de palavras-chave como int (inválido)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Inicialização Explícita e Avançada",
                                  "subSteps": [
                                    "Use inicialização explícita com {}: int x{10}; char c{'A'};.",
                                    "Teste lista de inicialização: int nums[] = {1,2,3}; (para arrays simples).",
                                    "Compare comportamentos: valor zero para não-inicializados vs explícito.",
                                    "Escreva código misturando implícita e explícita, compilando e testando.",
                                    "Debug erros como narrow matching em {} (ex: int{3.14} falha)."
                                  ],
                                  "verification": "Programa com 3 inicializações explícitas compila e executa sem warnings.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador com flags -Wall -Wextra",
                                    "Referência C++11 initialization"
                                  ],
                                  "tips": [
                                    "{} previne erros de truncamento automático.",
                                    "Use para uniformidade em C++ moderno."
                                  ],
                                  "learningObjective": "Diferenciar e usar inicializações implícita e explícita.",
                                  "commonMistakes": [
                                    "Ignorar warnings de truncamento em inicializações.",
                                    "Confundir = com {} em structs (futuro)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Verificar Declarações Completas",
                                  "subSteps": [
                                    "Crie um programa com 8 variáveis de todos tipos, declaradas e inicializadas.",
                                    "Adicione cout para exibir todas, compilando e executando.",
                                    "Introduza e corrija 3 erros propositais (ex: char='AB').",
                                    "Refatore para usar {} onde possível.",
                                    "Documente o código com comentários explicando escolhas."
                                  ],
                                  "verification": "Programa completo compila, executa e produz saída esperada sem erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor completo",
                                    "Compilador g++"
                                  ],
                                  "tips": [
                                    "Teste incremental: compile após cada adição.",
                                    "Use namespace std; para simplificar."
                                  ],
                                  "learningObjective": "Integrar declaração e inicialização em código funcional.",
                                  "commonMistakes": [
                                    "Variáveis não inicializadas causando valores garbage.",
                                    "Misturar tipos em atribuições sem cast."
                                  ]
                                }
                              ],
                              "practicalExample": "Em C++: #include <iostream> int main() { int idade{25}; float altura = 1.75f; char inicial = 'J'; bool estudante = true; std::cout << idade << ' ' << altura << ' ' << inicial << ' ' << estudante; return 0; } // Saída: 25 1.75 J 1",
                              "finalVerifications": [
                                "Compilar código sem erros ou warnings de sintaxe.",
                                "Executar e verificar valores impressos corretos.",
                                "Explicar verbalmente diferença entre int x=5; e int x{5};.",
                                "Identificar e corrigir 3 erros comuns em código fornecido.",
                                "Listar 5 tipos escalares com exemplos válidos.",
                                "Demonstrar uso de sizeof() em código compilado."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática em todas declarações (100%).",
                                "Uso apropriado de tipos para valores dados (ex: não float para int puro).",
                                "Mistura correta de inicializações implícita e explícita.",
                                "Ausência de warnings de compilador (com -Wall).",
                                "Clareza nos nomes de variáveis e comentários.",
                                "Funcionalidade completa do programa de teste."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação numérica e precisão em float/double.",
                                "Lógica: Uso de bool em expressões condicionais futuras.",
                                "Física/Engenharia: Armazenar medidas (altura em float, constantes como PI).",
                                "Linguagem Natural: Char como base para processamento de texto.",
                                "Algoritmos: Variáveis como blocos fundamentais de estruturas de dados."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, variáveis escalares armazenam dados essenciais como idade de usuários em apps de e-commerce, coordenadas em jogos (float x,y), status de login (bool autenticado) ou códigos de erro (int), garantindo eficiência e correção em sistemas bancários, simuladores ou IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Realizar operações com tipos escalares",
                            "description": "Executar operações aritméticas, lógicas e de comparação entre variáveis escalares, identificando precedência de operadores e potenciais erros de overflow ou underflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender operações aritméticas básicas com escalares",
                                  "subSteps": [
                                    "Identifique os tipos escalares comuns: inteiros (int), números de ponto flutuante (float) e caracteres.",
                                    "Aprenda operadores aritméticos: +, -, *, /, %, ** (exponenciação).",
                                    "Pratique atribuições como: a = 5 + 3; b = 10.0 / 2;",
                                    "Execute exemplos em um interpretador ou editor de código.",
                                    "Observe resultados e tipos resultantes das operações."
                                  ],
                                  "verification": "Execute 5 operações aritméticas diferentes e confirme os resultados esperados no console.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (ex: VS Code com Python), interpretador Python ou pseudocódigo online.",
                                  "tips": "Use print() para visualizar resultados imediatamente após cada operação.",
                                  "learningObjective": "Dominar execução de operações aritméticas básicas e compreensão de tipos resultantes.",
                                  "commonMistakes": "Confundir divisão inteira (//) com divisão float (/); ignorar perda de precisão em floats."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar operações lógicas e de comparação",
                                  "subSteps": [
                                    "Estude operadores de comparação: ==, !=, >, <, >=, <=",
                                    "Aprenda operadores lógicos: and, or, not.",
                                    "Crie expressões como: (a > 5) and (b <= 10)",
                                    "Teste com valores verdadeiros e falsos.",
                                    "Atribua resultados booleanos a variáveis e imprima-os."
                                  ],
                                  "verification": "Crie e teste 4 expressões lógicas/comparativas, verificando saídas booleanas corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo editor e interpretador do step 1; tabela verdade impressa.",
                                  "tips": "Use parênteses para agrupar expressões e evitar ambiguidades.",
                                  "learningObjective": "Aplicar operadores lógicos e de comparação corretamente em variáveis escalares.",
                                  "commonMistakes": "Confundir == (igualdade) com = (atribuição); esquecer precedência de 'not' sobre 'and/or'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e aplicar precedência de operadores",
                                  "subSteps": [
                                    "Memorize a ordem: parênteses > exponenciação > * / % > + - > comparações > not > and > or.",
                                    " Reescreva expressões sem parênteses para prever resultados.",
                                    "Teste expressões ambíguas com e sem parênteses, como 2 + 3 * 4.",
                                    "Use ferramentas online de precedência para validar.",
                                    "Corrija expressões erradas baseadas em precedência."
                                  ],
                                  "verification": "Avalie 6 expressões com precedência mista e explique o resultado passo a passo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabela de precedência de operadores (impressa ou online), editor de código.",
                                  "tips": "Sempre use parênteses para explicitar intenção, mesmo quando não necessário.",
                                  "learningObjective": "Prever e controlar resultados de expressões usando regras de precedência.",
                                  "commonMistakes": "Tratar todas as operações da esquerda para direita; ignorar precedência de multiplicação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar e mitigar erros de overflow e underflow",
                                  "subSteps": [
                                    "Entenda overflow (ex: int max +1) e underflow (ex: min -1).",
                                    "Teste limites em inteiros: em Python, use sys.maxsize; em C, INT_MAX.",
                                    "Observe comportamentos em diferentes linguagens (wrap-around vs erro).",
                                    "Use tipos maiores (long, float) ou verificações condicionais para prevenir.",
                                    "Implemente checks como if (resultado > limite): erro."
                                  ],
                                  "verification": "Simule 3 cenários de overflow/underflow e implemente detecção com saída de erro.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Documentação de limites de tipos (Python: sys module; C: limits.h), editor.",
                                  "tips": "Em linguagens seguras como Python, prefira exceções; em C, use tipos unsigned quando apropriado.",
                                  "learningObjective": "Identificar riscos de overflow/underflow e aplicar estratégias preventivas.",
                                  "commonMistakes": "Assumir que linguagens dinâmicas como Python não têm limites; ignorar precisão em floats."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Combinar operações em expressões complexas",
                                  "subSteps": [
                                    "Crie expressões mistas: aritméticas + lógicas + comparações.",
                                    "Inclua verificações de overflow em expressões.",
                                    "Debugue expressões com erros intencionais de precedência.",
                                    "Otimize expressões para legibilidade.",
                                    "Teste com conjunto de dados variados."
                                  ],
                                  "verification": "Desenvolva e debugue 3 expressões complexas completas sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Todos os materiais anteriores; debugger integrado no editor.",
                                  "tips": "Divida expressões complexas em variáveis intermediárias para depuração.",
                                  "learningObjective": "Integrar todas as operações escalares em cenários realistas.",
                                  "commonMistakes": "Sobrecarregar expressões sem parênteses; não testar bordas como zero ou negativos."
                                }
                              ],
                              "practicalExample": "Em um programa de cálculo de IMC: peso = 70.5; altura = 1.75; imc = peso / (altura ** 2); if imc > 25 and imc < 30: print('Sobrepeso'); Verifique overflow se peso for muito grande e precedência em altura ** 2.",
                              "finalVerifications": [
                                "Executa corretamente 10 operações aritméticas mistas sem erros.",
                                "Avalia expressões lógicas e de comparação com 100% de acerto.",
                                "Explica precedência em 5 expressões ambíguas.",
                                "Detecta e previne overflow/underflow em testes de limite.",
                                "Combina operações em um mini-programa funcional.",
                                "Debuga erros comuns em expressões fornecidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas operações básicas (90%+ correto).",
                                "Correto uso de precedência e parênteses (sem ambiguidades).",
                                "Detecção consistente de riscos numéricos (overflow/underflow).",
                                "Legibilidade e boas práticas em expressões complexas.",
                                "Eficiência na depuração e verificação de resultados.",
                                "Aplicação integrada em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra básica e precedência de operações.",
                                "Lógica Matemática: Tabelas-verdade para operadores booleanos.",
                                "Física/Engenharia: Cálculos numéricos com limites reais (ex: medidas).",
                                "Estatística: Operações em dados escalares para médias e desvios."
                              ],
                              "realWorldApplication": "Desenvolvimento de software para finanças (cálculos de juros com overflow checks), validação de formulários web (comparações lógicas em inputs), simulações científicas (operações precisas em floats evitando underflow)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.4",
                            "name": "Aplicar conversão de tipos escalares",
                            "description": "Realizar casting explícito e implícito entre tipos escalares (ex.: int para float), entendendo perdas de precisão e utilizando funções de conversão em linguagens específicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos de conversão implícita e explícita",
                                  "subSteps": [
                                    "Defina conversão implícita (coerção automática pelo compilador/interpretação)",
                                    "Defina conversão explícita (casting manual usando funções ou operadores)",
                                    "Identifique tipos escalares comuns: int, float, string, bool",
                                    "Explique diferenças entre linguagens (ex: Python vs C++)",
                                    "Estude exemplos teóricos de cada tipo de conversão"
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre implícita e explícita, com um exemplo por tipo",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de Python (int(), float()), Notas de aula sobre tipos de dados"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar quando cada tipo ocorre",
                                  "learningObjective": "Compreender os fundamentos teóricos das conversões de tipos escalares",
                                  "commonMistakes": [
                                    "Confundir implícita com explícita",
                                    "Ignorar que strings requerem tratamento especial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar conversões implícitas em código",
                                  "subSteps": [
                                    "Escreva código que some int + float e observe promoção automática",
                                    "Teste conversão implícita em operações aritméticas (divisão, multiplicação)",
                                    "Execute em Python: print(5 + 3.14) e analise o tipo resultante",
                                    "Compare resultados em diferentes linguagens se possível (ex: Java)",
                                    "Registre o tipo de dados antes e depois da operação"
                                  ],
                                  "verification": "Código roda sem erros e produz float como resultado esperado",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Replit), Console Python"
                                  ],
                                  "tips": "Use type() em Python para inspecionar tipos dinamicamente",
                                  "learningObjective": "Executar e analisar conversões implícitas em operações básicas",
                                  "commonMistakes": [
                                    "Esquecer de verificar o tipo resultante",
                                    "Assumir que divisão int/int é float"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar conversões explícitas com funções de casting",
                                  "subSteps": [
                                    "Use int() para converter float para int (observe truncamento)",
                                    "Use float() para converter int ou string para float",
                                    "Converta string numérica para int/float: int('123'), float('3.14')",
                                    "Teste bool() para conversões lógicas (não-vazio=True)",
                                    "Escreva um script que valide e converta input de usuário"
                                  ],
                                  "verification": "Todas as conversões produzem os tipos corretos sem exceções",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python interpreter, Exemplos de inputs variados (strings com decimais)"
                                  ],
                                  "tips": "Sempre trate ValueError para strings inválidas com try-except",
                                  "learningObjective": "Dominar funções de casting explícito em Python",
                                  "commonMistakes": [
                                    "Não capturar exceções em conversões de string",
                                    "Ignorar arredondamento em float para int"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar perdas de precisão e aplicações práticas",
                                  "subSteps": [
                                    "Compare float(3.999) vs int(3.999) para ver perda de precisão",
                                    "Calcule área de círculo: pi * r**2 com r int vs float",
                                    "Crie função que converte temperatura C para F com tipos mistos",
                                    "Debugue código com perda de dados (ex: divisão inteira acidental)",
                                    "Otimize código para preservar precisão onde necessário"
                                  ],
                                  "verification": "Identifique e corrija 3 exemplos de perda de precisão em códigos fornecidos",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Códigos de exemplo com erros, Calculadora para validação manual"
                                  ],
                                  "tips": "Prefira float para cálculos precisos; use Decimal para finanças",
                                  "learningObjective": "Gerenciar riscos de precisão em conversões e aplicar em cenários reais",
                                  "commonMistakes": [
                                    "Usar int para valores fracionários sem intenção",
                                    "Não testar edge cases como 0.999"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de conversão de temperatura, leia Celsius como string do usuário, converta para float explicitamente (float(input())), some 32 e multiplique por 1.8 (conversão implícita para float), depois exiba como int se inteiro ou float.",
                              "finalVerifications": [
                                "Converte corretamente int para float sem perda",
                                "Lida com string para int/float capturando erros",
                                "Identifica quando usar implícito vs explícito",
                                "Explica perdas de precisão em 3 exemplos",
                                "Escreve função completa de conversão com validação",
                                "Debuga código com TypeError ou ValueError"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas conversões (sem truncamentos indesejados)",
                                "Tratamento de exceções em inputs inválidos",
                                "Uso correto de type() para verificação",
                                "Eficiência no código (evita conversões desnecessárias)",
                                "Comentários explicando escolhas de casting",
                                "Testes com edge cases (zero, negativos, decimais)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Precisão numérica e arredondamento",
                                "Física: Conversão de unidades (ex: m/s para km/h)",
                                "Finanças: Cálculos monetários com float/Decimal",
                                "Banco de Dados: Casting em queries SQL (CAST como float)"
                              ],
                              "realWorldApplication": "Em aplicativos de e-commerce, converter preços de string (do banco) para float em cálculos de desconto; em jogos, castar scores int para float em interpolação suave de animações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Tipos de Dados Estruturados",
                        "description": "Tipos de dados compostos que organizam múltiplos elementos relacionados, como arrays (vetores), strings e estruturas (structs), permitindo manipulação eficiente de coleções de dados em lógica de programação.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Declarar e inicializar arrays",
                            "description": "Definir arrays unidimensionais e multidimensionais com tamanho fixo ou dinâmico, inicializando-os com valores constantes ou em loop, em contextos de linguagens procedimentais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos e Declarar Arrays Unidimensionais Fixos",
                                  "subSteps": [
                                    "Estude a definição de array unidimensional como uma coleção de elementos do mesmo tipo com índices sequenciais.",
                                    "Diferencie arrays de tamanho fixo (declarados com tamanho constante) de dinâmicos (alocados em runtime).",
                                    "Pratique a sintaxe de declaração em linguagens procedimentais, ex: int arr[10]; em C.",
                                    "Identifique o índice inicial (geralmente 0) e o cálculo de limites.",
                                    "Escreva declarações para diferentes tipos (int, float, char)."
                                  ],
                                  "verification": "Escreva 5 declarações corretas de arrays unidimensionais fixos e explique cada uma.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE como Code::Blocks",
                                    "Documentação de C/Pascal",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Sempre especifique o tipo e o tamanho; visualize o array como uma fileira de caixas numeradas.",
                                  "learningObjective": "Dominar a declaração básica de arrays unidimensionais com tamanho fixo.",
                                  "commonMistakes": [
                                    "Esquecer o ponto e vírgula",
                                    "Usar tamanho variável sem alocação",
                                    "Confundir tipo do array com tipo dos elementos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar Arrays Unidimensionais com Valores Constantes",
                                  "subSteps": [
                                    "Aprenda a sintaxe de inicialização estática, ex: int arr[5] = {1,2,3,4,5};",
                                    "Teste inicialização parcial, onde o compilador preenche o resto com zeros.",
                                    "Declare e inicialize em uma linha única versus separadamente.",
                                    "Verifique o tamanho implícito na inicialização, ex: int arr[] = {1,2,3};",
                                    "Compile e execute um programa simples para imprimir o array."
                                  ],
                                  "verification": "Crie e compile um programa que declara e inicializa um array de 10 elementos e imprime-os.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C (GCC)",
                                    "IDE com debugger",
                                    "Exemplos de código online"
                                  ],
                                  "tips": "Use chaves {} para listas; conte os elementos para evitar erros de tamanho.",
                                  "learningObjective": "Inicializar arrays 1D estaticamente com valores constantes.",
                                  "commonMistakes": [
                                    "Número de valores diferente do tamanho declarado",
                                    "Esquecer chaves de inicialização",
                                    "Inicializar com tipos incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar Arrays Unidimensionais Usando Loops",
                                  "subSteps": [
                                    "Implemente um loop for para inicializar elementos individualmente, ex: for(int i=0; i<size; i++) arr[i] = i*2;",
                                    "Pratique inicialização dinâmica com alocação (malloc em C) para tamanhos variáveis.",
                                    "Combine declaração dinâmica: int *arr = malloc(size * sizeof(int));",
                                    "Inicialize com valores calculados ou de entrada do usuário em loop.",
                                    "Adicione verificação de bounds no loop para evitar overflows."
                                  ],
                                  "verification": "Escreva um programa que lê o tamanho do usuário, aloca, inicializa com loop e imprime.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador com suporte a stdlib.h",
                                    "Calculadora para tamanhos",
                                    "Debugger para rastrear loops"
                                  ],
                                  "tips": "Sempre libere memória com free(); use sizeof para portabilidade.",
                                  "learningObjective": "Inicializar arrays 1D dinamicamente via loops.",
                                  "commonMistakes": [
                                    "Acessar além dos limites (buffer overflow)",
                                    "Esquecer free() causando leaks",
                                    "Loop off-by-one (i<size vs i<=size)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Declarar e Inicializar Arrays Multidimensionais",
                                  "subSteps": [
                                    "Entenda arrays 2D como array de arrays, ex: int matrix[3][4];",
                                    "Inicialize estaticamente: int matrix[2][2] = {{1,2},{3,4}};",
                                    "Use loops aninhados para inicialização dinâmica, ex: for(int i=0; i<rows; i++) for(int j=0; j<cols; j++) matrix[i][j] = i+j;",
                                    "Pratique alocação dinâmica 2D com vetores de ponteiros.",
                                    "Teste impressão em formato de matriz usando loops."
                                  ],
                                  "verification": "Crie um programa que declara uma matriz 3x3, inicializa com loop e imprime como tabela.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com suporte a matrizes",
                                    "Papel para desenhar matrizes",
                                    "Referências de sintaxe multidimensional"
                                  ],
                                  "tips": "Pense em linhas e colunas; use printf com formatadores para visualização clara.",
                                  "learningObjective": "Manipular declaração e inicialização de arrays multidimensionais.",
                                  "commonMistakes": [
                                    "Índices invertidos (linhas vs colunas)",
                                    "Inicialização irregular em multidim",
                                    "Não inicializar todos os elementos"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa em C que declara uma matriz 4x5 para notas de 4 alunos em 5 provas, inicializa com valores fixos { {85,90,78,92,88}, {76,82,95,88,90}, {92,87,84,91,89}, {88,85,93,87,94} }, usa loops para calcular e imprimir a média por aluno.",
                              "finalVerifications": [
                                "Declara corretamente arrays 1D e 2D fixos e dinâmicos.",
                                "Inicializa estaticamente com listas de valores sem erros.",
                                "Usa loops para inicializar todos os elementos uniformemente.",
                                "Evita erros de bounds e memória em execuções múltiplas.",
                                "Imprime arrays de forma legível e verifica valores.",
                                "Libera memória corretamente em casos dinâmicos."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe 100% correta em todas as declarações e inicializações.",
                                "Compilação e execução sem warnings ou erros de runtime.",
                                "Inicialização completa e precisa de todos os elementos.",
                                "Eficiência nos loops (sem off-by-one ou overflows).",
                                "Comentários claros explicando cada seção de código.",
                                "Aplicação correta de conceitos em exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores e matrizes lineares para operações algébricas.",
                                "Física: Arrays para dados de sensores (ex: temperaturas em grid).",
                                "Estatística: Armazenamento de datasets para cálculos de médias e desvios.",
                                "Banco de Dados: Estruturas semelhantes a tabelas relacionais."
                              ],
                              "realWorldApplication": "Em software de gerenciamento de vendas, arrays unidimensionais armazenam preços de produtos e multidimensionais representam estoque por filial e categoria, permitindo inicialização rápida via loops para processar milhares de itens eficientemente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Acessar e modificar elementos de estruturas",
                            "description": "Utilizar índices para ler e alterar elementos em arrays e strings, compreendendo limites de array (bounds checking) e iteração com laços repetitivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender arrays e strings como estruturas indexadas",
                                  "subSteps": [
                                    "Defina o que são arrays e strings em programação.",
                                    "Explique que arrays armazenam múltiplos valores do mesmo tipo com índices numéricos.",
                                    "Descreva strings como arrays de caracteres.",
                                    "Identifique que índices iniciam em 0 e vão até length-1.",
                                    "Diferencie arrays mutáveis de strings imutáveis em linguagens como Python ou Java."
                                  ],
                                  "verification": "Responda corretamente a um quiz com 5 perguntas sobre conceitos básicos de índices.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de arrays em Python/Java",
                                    "Editor de código online como Replit"
                                  ],
                                  "tips": [
                                    "Lembre-se: o primeiro elemento é índice 0, não 1."
                                  ],
                                  "learningObjective": "Entender a estrutura indexada de arrays e strings.",
                                  "commonMistakes": [
                                    "Confundir índice inicial como 1",
                                    "Ignorar diferença entre arrays e strings"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Acessar elementos usando índices",
                                  "subSteps": [
                                    "Crie um array simples com 5 elementos.",
                                    "Acesse o primeiro, último e um elemento intermediário usando notação de colchetes [].",
                                    "Acesse caracteres específicos em uma string.",
                                    "Imprima os valores acessados para confirmação.",
                                    "Teste acesso em diferentes posições."
                                  ],
                                  "verification": "Execute código que acesse e imprima elementos corretos de um array e string fornecidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código prontos para teste"
                                  ],
                                  "tips": [
                                    "Use print() para verificar o valor acessado imediatamente."
                                  ],
                                  "learningObjective": "Ler elementos de arrays e strings via índices.",
                                  "commonMistakes": [
                                    "Usar índice maior que length-1",
                                    "Esquecer colchetes []"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar elementos usando índices",
                                  "subSteps": [
                                    "Crie um array mutável e altere um elemento no índice específico.",
                                    "Modifique múltiplos elementos em sequência.",
                                    "Teste modificação em strings (se suportado, ou crie nova string).",
                                    "Verifique a alteração imprimindo antes e depois.",
                                    "Aplique em um array de números ou textos realistas."
                                  ],
                                  "verification": "Altere valores em um array e demonstre a mudança com prints antes/depois.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Arrays de exemplo como notas de alunos"
                                  ],
                                  "tips": [
                                    "Sempre verifique o índice antes de modificar para evitar erros."
                                  ],
                                  "learningObjective": "Alterar elementos de estruturas indexadas.",
                                  "commonMistakes": [
                                    "Tentar modificar strings imutáveis sem recriar",
                                    "Índice inválido causando erro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar bounds checking e iteração com laços",
                                  "subSteps": [
                                    "Explique bounds checking: verificar se índice está entre 0 e length-1.",
                                    "Adicione condicionais if para validar índices antes de acessar/modificar.",
                                    "Use laços for ou while para iterar sobre todos elementos.",
                                    "Combine iteração com acesso e modificação (ex: dobrar valores).",
                                    "Teste casos de erro como índice negativo ou excessivo."
                                  ],
                                  "verification": "Código que itera um array, modifica elementos com bounds check e trata erros graciosamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de loops e exceções",
                                    "Editor com depurador"
                                  ],
                                  "tips": [
                                    "Use len(array) para obter o tamanho dinamicamente."
                                  ],
                                  "learningObjective": "Aplicar verificações de limites e iteração segura.",
                                  "commonMistakes": [
                                    "IndexError por falta de check",
                                    "Loop infinito em while"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um array de notas de alunos: notas = [7.5, 8.0, 6.5, 9.0]. Acesse a nota do índice 2 (6.5), modifique para 7.0 com bounds check, e itere para calcular média, imprimindo apenas notas acima de 7.",
                              "finalVerifications": [
                                "Acessa corretamente elementos por índice sem erros.",
                                "Modifica valores e confirma alterações.",
                                "Implementa bounds checking evitando IndexError.",
                                "Itera arrays/strings com laços sem falhas.",
                                "Manipula exemplos reais como listas de dados.",
                                "Explica conceitos em palavras próprias."
                              ],
                              "assessmentCriteria": [
                                "Código executa sem erros de runtime (100% acertos).",
                                "Uso correto de índices e bounds checking.",
                                "SubSteps seguidos com precisão em exemplos.",
                                "Eficiência na iteração (O(n) tempo).",
                                "Clareza no código com comentários.",
                                "Aplicação correta em practicalExample."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e vetores indexados.",
                                "Estatística: Manipulação de listas de dados para cálculos.",
                                "Língua Portuguesa: Análise de strings como texto indexado.",
                                "Física: Arrays de medidas experimentais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps, acessar/modificar listas de usuários em bancos de dados, processar strings em buscas de texto, ou iterar dados em planilhas para relatórios empresariais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Manipular strings como estruturas",
                            "description": "Tratar strings como arrays de caracteres, realizando operações como concatenação, busca de subcadeias e comparação, com atenção a terminadores nulos em C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender strings como arrays de caracteres com terminador nulo",
                                  "subSteps": [
                                    "Declare uma string como array de char em C++ (ex: char str[100] = \"Hello\";).",
                                    "Identifique o terminador nulo (\\0) no final da string usando um loop para imprimir cada char.",
                                    "Explique a diferença entre strings C-style e std::string, focando em manipulação manual.",
                                    "Calcule manualmente o comprimento de uma string contando chars até \\0.",
                                    "Teste o que acontece ao acessar além do \\0 (comportamento indefinido)."
                                  ],
                                  "verification": "Escreva e execute um programa que imprime cada char de uma string e seu \\0, confirmando o terminador.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C++ (g++), editor de texto (VS Code), documentação C++ strings.",
                                  "tips": "Sempre inicialize arrays para evitar lixo de memória.",
                                  "learningObjective": "Entender a representação interna de strings como arrays terminados por \\0.",
                                  "commonMistakes": "Esquecer o \\0 ao inicializar, causando loops infinitos ou overflows."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Acessar e modificar caracteres individuais",
                                  "subSteps": [
                                    "Acesse chars por índice (str[0], str[1], etc.) e imprima-os.",
                                    "Modifique chars específicos (ex: str[0] = 'h'; para lowercase).",
                                    "Implemente uma função para inverter uma string trocando chars.",
                                    "Adicione verificação de bounds para evitar acesso inválido.",
                                    "Teste com strings vazias ou com apenas \\0."
                                  ],
                                  "verification": "Crie um programa que converte uma string para uppercase manipulando cada char.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C++, exemplos de código online (cppreference.com).",
                                  "tips": "Use strlen() para obter comprimento seguro antes de acessar.",
                                  "learningObjective": "Manipular strings como arrays mutáveis com controle de índices.",
                                  "commonMistakes": "Acessar str[length] que é o \\0, ou além, causando crashes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar concatenação manual de strings",
                                  "subSteps": [
                                    "Calcule o espaço necessário para duas strings (len1 + len2 + 1 para \\0).",
                                    "Copie a primeira string para o buffer de destino usando loop.",
                                    "Adicione a segunda string após a primeira.",
                                    "Adicione \\0 no final manualmente.",
                                    "Teste com diferentes tamanhos e overflow intencional para depuração."
                                  ],
                                  "verification": "Escreva uma função strcat manual que concatena duas strings e testa com \"Hello\" + \"World\".",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Compilador C++, debugger (gdb).",
                                  "tips": "Sempre verifique se o buffer destino tem espaço suficiente.",
                                  "learningObjective": "Implementar concatenação sem funções prontas, gerenciando memória.",
                                  "commonMistakes": "Esquecer de copiar \\0 ou sobrescrever buffer, causando garbage ou segfault."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar busca de subcadeias",
                                  "subSteps": [
                                    "Para cada posição na string principal, compare com o início da subcadeia.",
                                    "Use loop aninhado para matching char por char.",
                                    "Retorne a posição da primeira ocorrência ou -1 se não encontrada.",
                                    "Otimize parando no fim da string principal ou subcadeia.",
                                    "Teste casos: subcadeia no início, meio, fim, não existente, vazia."
                                  ],
                                  "verification": "Crie função strstr manual e teste encontrando \"world\" em \"Hello world!\".",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Compilador C++, papel para pseudocódigo.",
                                  "tips": "Comece com versão simples sem otimizações como KMP.",
                                  "learningObjective": "Desenvolver algoritmo de busca linear em strings.",
                                  "commonMistakes": "Não tratar subcadeia vazia (deve retornar 0), ou loops infinitos sem checks."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar strings caractere por caractere",
                                  "subSteps": [
                                    "Compare char por char até \\0 ou diferença.",
                                    "Retorne 0 se iguais, negativo se primeira < segunda, positivo caso contrário.",
                                    "Ignore case convertendo para uppercase durante comparação.",
                                    "Teste com strings de tamanhos diferentes.",
                                    "Implemente versão case-insensitive."
                                  ],
                                  "verification": "Escreva strcmp manual e teste ordenando array de strings.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C++, biblioteca <algorithm> para verificação.",
                                  "tips": "Use int para retorno como na libc strcmp.",
                                  "learningObjective": "Realizar comparações lexicográficas manuais.",
                                  "commonMistakes": "Parar na primeira diferença sem considerar ordem ASCII, ou ignorar \\0."
                                }
                              ],
                              "practicalExample": "Implemente um validador de palíndromos em C++: leia uma string do usuário, ignore espaços e case, verifique se é palíndromo manipulando chars individualmente, usando loops para comparação reversa, respeitando \\0.",
                              "finalVerifications": [
                                "Pode declarar e inicializar char arrays corretamente com \\0.",
                                "Manipula chars por índice sem overflows.",
                                "Concatena strings manualmente sem memory leaks.",
                                "Encontra subcadeias com função customizada.",
                                "Compara strings retornando valores corretos.",
                                "Depura programas que crasham por manipulação errada de strings."
                              ],
                              "assessmentCriteria": [
                                "Precisão na manipulação de terminadores nulos (sem crashes).",
                                "Eficiência dos loops (O(n) para operações básicas).",
                                "Tratamento de edge cases (strings vazias, tamanhos desiguais).",
                                "Código limpo com verificações de bounds.",
                                "Correção em concatenação, busca e comparação vs. funções std.",
                                "Explicação verbal da representação interna de strings."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos de busca linear e complexidade O(n^2).",
                                "Linguística: Processamento de texto e padrões linguísticos.",
                                "Engenharia: Gerenciamento de memória e buffers seguros.",
                                "Lógica: Condicionais e loops aninhados para matching."
                              ],
                              "realWorldApplication": "Desenvolvimento de parsers para protocolos de rede (ex: HTTP headers), validadores de input em sistemas embarcados, ou ferramentas de grep customizadas em C++ para performance crítica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.4",
                            "name": "Definir estruturas personalizadas",
                            "description": "Criar structs para agrupar dados heterogêneos (ex.: aluno com nome, idade e nota), acessando membros via ponto ou seta, e inicializando instâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de estruturas personalizadas (structs)",
                                  "subSteps": [
                                    "Identificar dados heterogêneos que precisam ser agrupados, como nome (string), idade (int) e nota (float) de um aluno.",
                                    "Explicar a limitação de arrays (dados homogêneos) e por que structs são ideais para dados relacionados mas de tipos diferentes.",
                                    "Analisar exemplos reais: um aluno, um ponto 2D (x, y) ou um retângulo (largura, altura, cor).",
                                    "Diferenciar acesso via ponto (.) para variáveis e seta (->) para ponteiros.",
                                    "Discutir benefícios: organização de código, legibilidade e reutilização."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo em palavras próprias o que é uma struct e sua utilidade, comparando com arrays.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação de structs em C (ex.: man pages ou tutoriais online)",
                                    "Bloco de notas para anotações"
                                  ],
                                  "tips": "Use analogias do dia a dia, como uma 'ficha de aluno' física para visualizar o agrupamento.",
                                  "learningObjective": "Entender a necessidade e os conceitos fundamentais de structs para modelar entidades compostas.",
                                  "commonMistakes": [
                                    "Confundir structs com classes de linguagens OO",
                                    "Achar que structs só servem para números",
                                    "Ignorar a diferença entre dados homogêneos e heterogêneos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a sintaxe de uma struct personalizada",
                                  "subSteps": [
                                    "Escrever a declaração: 'struct NomeStruct { tipo1 membro1; tipo2 membro2; };'.",
                                    "Criar exemplo: 'struct Aluno { char nome[50]; int idade; float nota; };'.",
                                    "Testar compilação isolada da definição em um arquivo .c vazio.",
                                    "Explorar typedef para apelidos: 'typedef struct Aluno Aluno;'.",
                                    "Verificar regras: nomes sem espaços, ponto e vírgula final obrigatório."
                                  ],
                                  "verification": "Compilar um código com apenas a definição da struct sem erros de sintaxe usando gcc.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Code::Blocks)",
                                    "Compilador C (GCC instalado)"
                                  ],
                                  "tips": "Comece com membros simples e adicione complexidade gradualmente; use typedef para simplificar declarações futuras.",
                                  "learningObjective": "Dominar a sintaxe precisa para definir structs customizadas.",
                                  "commonMistakes": [
                                    "Esquecer o ponto e vírgula após a chave }",
                                    "Usar nomes de membros com espaços ou palavras reservadas",
                                    "Misturar tipos incompatíveis sem entender ponteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar, inicializar e usar instâncias de structs",
                                  "subSteps": [
                                    "Declarar variável: 'struct Aluno a1;' ou 'Aluno a1;' com typedef.",
                                    "Inicializar: 'a1.idade = 20; strcpy(a1.nome, \"João\"); a1.nota = 8.5;' ou inicializador: 'Aluno a2 = {\"Maria\", 19, 9.0};'.",
                                    "Criar ponteiro: 'Aluno *p = &a1;' e inicializar via ponteiro.",
                                    "Imprimir valores: 'printf(\"%s tem %d anos e nota %.1f\", a1.nome, a1.idade, a1.nota);'.",
                                    "Testar em main() completa com múltiplas instâncias."
                                  ],
                                  "verification": "Executar programa que declara, inicializa duas instâncias e imprime corretamente todos os membros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor com suporte a C (com debugger opcional)"
                                  ],
                                  "tips": "Sempre inclua <string.h> para strcpy; inicializadores designados facilitam: a1 = {.idade=20, .nota=8.5};.",
                                  "learningObjective": "Saber criar e popular instâncias de structs de forma segura e eficiente.",
                                  "commonMistakes": [
                                    "Não incluir #include <string.h> para strcpy",
                                    "Acessar ponteiro sem alocação (&)",
                                    "Inicializar char array sem limite de tamanho"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Acessar, modificar membros e aplicar em contextos práticos",
                                  "subSteps": [
                                    "Acessar via . : 'printf(\"%s\", aluno.nome);' e modificar: 'aluno.nota += 0.5;'.",
                                    "Acessar via -> para ponteiros: 'p->idade = 21;'.",
                                    "Passar struct para função: void imprimirAluno(Aluno a); e por referência: void alterarNota(Aluno *a, float novaNota);.",
                                    "Criar array de structs: 'Aluno turma[5];' e iterar com loop.",
                                    "Compilar e testar cenários com entrada/saída do usuário."
                                  ],
                                  "verification": "Programa funcional que cria array de 3 alunos, modifica notas via função e imprime lista atualizada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Exemplos de código de iterações anteriores"
                                  ],
                                  "tips": "Passe structs por ponteiro em funções para evitar cópias desnecessárias; use loops for para arrays de structs.",
                                  "learningObjective": "Aplicar structs em fluxos reais, manipulando membros dinamicamente.",
                                  "commonMistakes": [
                                    "Confundir . com -> em ponteiros",
                                    "Passar struct grande por valor causando overhead",
                                    "Buffer overflow em strcpy sem checagem"
                                  ]
                                }
                              ],
                              "practicalExample": "#include <stdio.h>\n#include <string.h>\ntypedef struct {\n    char nome[50];\n    int idade;\n    float nota;\n} Aluno;\n\nvoid imprimir(Aluno a) {\n    printf(\"%s, %d anos, nota %.1f\\n\", a.nome, a.idade, a.nota);\n}\n\nint main() {\n    Aluno aluno1 = {\"João\", 20, 8.5};\n    Aluno *p = &aluno1;\n    strcpy(p->nome, \"João Silva\");\n    p->nota += 1.0;\n    imprimir(aluno1);\n    return 0;\n}\n/* Saída: João Silva, 20 anos, nota 9.5 */",
                              "finalVerifications": [
                                "Define struct sem erros de sintaxe e com typedef opcional.",
                                "Inicializa instâncias via atribuição direta, inicializador ou strcpy.",
                                "Acessa membros corretamente com . e -> em variáveis e ponteiros.",
                                "Programa compila e executa imprimindo valores esperados.",
                                "Manipula múltiplas instâncias em array ou funções sem crashes.",
                                "Evita erros comuns como buffer overflow ou ponteiros não inicializados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe de definição e declaração (100% sem warnings).",
                                "Correta inicialização e acesso a todos os membros (testes unitários passam).",
                                "Eficiência no uso de ponteiros vs. cópias (sem overhead desnecessário).",
                                "Legibilidade do código: nomes claros e comentários onde complexo.",
                                "Robustez: trata strings com strcpy seguro e limites.",
                                "Criatividade: aplica em exemplo além do 'Aluno' fornecido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de vetores/estruturas como tuplas ou registros em álgebra.",
                                "Banco de Dados: Equivalente a tabelas com registros (campos fixos).",
                                "Física/Engenharia: Representação de partículas (posição, velocidade, massa).",
                                "Design de Sistemas: Abstração de entidades em UML/classes."
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento escolar (cadastro de alunos), jogos (personagens com atributos como vida, posição), simulações científicas (partículas com coordenadas e propriedades) ou ERPs (clientes com nome, CPF, saldo), organizando dados complexos de forma eficiente e escalável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Tratamento de Exceções",
                        "description": "Técnicas para capturar e gerenciar erros em tempo de execução (exceções), utilizando blocos try-catch para manter a robustez do programa, evitando crashes abruptos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Identificar causas comuns de exceções",
                            "description": "Reconhecer situações que geram exceções, como divisão por zero, acesso inválido a memória, entrada inválida ou overflow, em fluxos de programas procedimentais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de exceções e suas causas gerais",
                                  "subSteps": [
                                    "Defina o que é uma exceção em programação procedural: interrupção inesperada no fluxo normal do programa.",
                                    "Classifique exceções em erros de runtime, como aritméticos e de acesso.",
                                    "Liste causas comuns: divisão por zero, overflow, acesso inválido a memória e entrada inválida.",
                                    "Analise o impacto: programa para ou gera saída de erro.",
                                    "Revise exemplos teóricos sem código."
                                  ],
                                  "verification": "Escreva uma definição curta e liste 4 causas comuns corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de linguagem procedural (ex: C ou Python), caderno de anotações.",
                                  "tips": "Use analogias do dia a dia, como tentar dividir ovos por zero galinhas.",
                                  "learningObjective": "Entender exceções como falhas previsíveis em fluxos procedurais.",
                                  "commonMistakes": "Confundir exceções com erros de sintaxe (compilação)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar exceções aritméticas: divisão por zero e overflow",
                                  "subSteps": [
                                    "Estude divisão por zero: ocorre quando denominador é 0 em operações como a / b.",
                                    "Simule em pseudocódigo: se b == 0, exceção; senão resultado = a / b.",
                                    "Explore overflow: valor excede limite do tipo (ex: int em C > 2^31-1).",
                                    "Teste com valores extremos em um editor simples.",
                                    "Registre sintomas: SIGFPE em C ou ZeroDivisionError em Python."
                                  ],
                                  "verification": "Crie 2 snippets de código que causem cada exceção e execute-os.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code), compilador/interpretação (gcc ou Python).",
                                  "tips": "Use debugger para pausar antes da exceção e inspecionar variáveis.",
                                  "learningObjective": "Reconhecer padrões aritméticos que geram exceções.",
                                  "commonMistakes": "Ignorar limites de tipo de dados em cálculos grandes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar exceções de acesso e entrada: memória inválida e input inválido",
                                  "subSteps": [
                                    "Analise acesso inválido a memória: dereferenciar ponteiro nulo ou array out-of-bounds.",
                                    "Exemplo: int* p = NULL; *p = 5; // Segmentation Fault.",
                                    "Estude entrada inválida: ler string em int sem validação (ex: scanf('%d', &x) com 'abc').",
                                    "Crie cenários com input do usuário e valide falhas.",
                                    "Diferencie: entrada causa falha de parsing; memória causa crash."
                                  ],
                                  "verification": "Implemente e execute 3 casos: ponteiro nulo, array bounds, input string em int.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, terminal para input/output, documentação de funções como scanf.",
                                  "tips": "Sempre inicialize variáveis e use bounds checking em loops.",
                                  "learningObjective": "Detectar violações de memória e falhas de input em fluxos procedurais.",
                                  "commonMistakes": "Assumir input sempre válido sem testar edge cases."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação em fluxos de programas completos",
                                  "subSteps": [
                                    "Construa um programa procedural simples: calculadora com input de usuário.",
                                    "Insira causas intencionais de exceções em diferentes pontos do fluxo.",
                                    "Execute, observe crashes e mapeie causa à exceção.",
                                    "Documente o fluxo: diagrama com pontos de falha potenciais.",
                                    "Refatore minimamente para isolar, sem tratar ainda."
                                  ],
                                  "verification": "Analise um programa de 20-30 linhas e liste todas exceções potenciais com causas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Editor completo, debugger (gdb para C), exemplos de código procedural.",
                                  "tips": "Trace o programa linha por linha com printfs para simular debug.",
                                  "learningObjective": "Integrar identificação de causas em programas procedurais reais.",
                                  "commonMistakes": "Focar só em uma seção, ignorando fluxos condicionais."
                                }
                              ],
                              "practicalExample": "Em um programa de cálculo de média de notas: usuário insere 3 notas, mas número de alunos é 0, causando divisão por zero. Ou insere 'abc' para número de notas, gerando input inválido. Overflow se notas somam > INT_MAX. Acesso inválido se array de notas excede tamanho alocado.",
                              "finalVerifications": [
                                "Lista corretamente 4 causas comuns com exemplos.",
                                "Identifica divisão por zero em snippet de código fornecido.",
                                "Explica overflow com limites de tipos de dados.",
                                "Simula acesso inválido a memória sem crashar o ambiente.",
                                "Detecta entrada inválida em função de parsing.",
                                "Mapeia exceções em um fluxo procedural completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de causas (90%+ acerto em testes).",
                                "Explicação clara de mecanismos (aritmético vs. memória).",
                                "Uso de exemplos concretos e reproduzíveis.",
                                "Análise de fluxos: considera condicionais e loops.",
                                "Diferenciação entre tipos de exceções sem confusão.",
                                "Documentação de verificações e erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas e limites numéricos (overflow).",
                                "Lógica: Condicionais para validação de inputs e bounds checking.",
                                "Física/Engenharia: Analogia com falhas em sistemas reais (divisão por zero em fórmulas).",
                                "Estatística: Tratamento de dados inválidos em conjuntos de entrada."
                              ],
                              "realWorldApplication": "Em sistemas bancários, identificar divisão por zero em cálculo de juros sobre saldo zero evita crashes; em jogos, acesso inválido a array de níveis previne falhas; apps de e-commerce validam input para carrinho vazio ou overflow em totais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Implementar blocos try-catch",
                            "description": "Estruturar código com try, catch e finally (quando aplicável), capturando exceções específicas e genéricas em linguagens como C++ (try-catch) ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe e propósito dos blocos try-catch",
                                  "subSteps": [
                                    "Estude a estrutura básica: try executa código suscetível a erros, catch captura exceções, finally executa sempre (cleanup).",
                                    "Identifique cenários comuns de exceções: divisão por zero, acesso a índice inválido, input inválido.",
                                    "Compare sintaxes: Python (try-except-finally), C++ (try-catch).",
                                    "Analise fluxogramas de execução com e sem exceções.",
                                    "Liste exceções genéricas (Exception) vs. específicas (ZeroDivisionError em Python)."
                                  ],
                                  "verification": "Descreva em um parágrafo os papéis de try, catch e finally, com um diagrama simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Python (docs.python.org), Documentação C++ (cppreference.com)",
                                    "Editor de texto ou papel para fluxogramas"
                                  ],
                                  "tips": "Visualize o fluxo: try → possível erro → catch ou finally.",
                                  "learningObjective": "Dominar os componentes fundamentais e o fluxo de execução do bloco try-catch.",
                                  "commonMistakes": [
                                    "Confundir catch com if-else",
                                    "Ignorar finally para limpeza de recursos",
                                    "Usar catch genérico sem necessidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar try-catch básico para exceções genéricas",
                                  "subSteps": [
                                    "Crie um script Python simples: resultado = 10 / int(input('Divisor: ')).",
                                    "Envolva o código arriscado em try: try: ...",
                                    "Adicione except Exception as e: print(f'Erro: {e}').",
                                    "Teste com input válido (5) e inválido (0).",
                                    "Execute e observe o comportamento."
                                  ],
                                  "verification": "O programa captura divisão por zero, imprime mensagem de erro e continua execução sem crash.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Terminal para execução Python"
                                  ],
                                  "tips": "Sempre imprima a exceção (e) para depuração inicial.",
                                  "learningObjective": "Construir e testar um bloco try-catch que previne crashes por exceções genéricas.",
                                  "commonMistakes": [
                                    "Esquecer de tratar input como int()",
                                    "Colocar todo o programa dentro de try",
                                    "Não testar casos de falha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Capturar exceções específicas com múltiplos catches",
                                  "subSteps": [
                                    "Modifique o código para capturar ZeroDivisionError e ValueError separadamente.",
                                    "Estrutura: try: ... except ZeroDivisionError: ... except ValueError: ... except Exception: ...",
                                    "Adicione validação de input: peça número inteiro para divisão.",
                                    "Teste: input '0' (ZeroDivisionError), 'abc' (ValueError), número válido.",
                                    "Registre logs ou mensagens específicas para cada tipo."
                                  ],
                                  "verification": "Execuções mostram mensagens corretas para cada tipo de exceção, sem sobreposição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo editor e terminal do step anterior",
                                    "Lista de exceções built-in do Python"
                                  ],
                                  "tips": "Ordene catches do mais específico para o genérico para evitar captura prematura.",
                                  "learningObjective": "Diferenciar e tratar exceções específicas, melhorando precisão do handler.",
                                  "commonMistakes": [
                                    "Catch genérico primeiro, mascarando específicas",
                                    "Não usar 'as e' para detalhes da exceção",
                                    "Ignorar exceções não previstas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar finally e aplicar boas práticas",
                                  "subSteps": [
                                    "Adicione finally: print('Cleanup realizado') ou feche arquivos/conexões.",
                                    "Refatore para função: def divide_safely(a, b): try... finally...",
                                    "Adicione else (Python): executa se sem exceção.",
                                    "Teste cenários completos: erro, sucesso, cleanup.",
                                    "Documente o código com comentários sobre exceções esperadas."
                                  ],
                                  "verification": "Finally executa em todos os casos (sucesso/erro), else só em sucesso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código com arquivos para simular cleanup"
                                  ],
                                  "tips": "Use finally para liberar recursos como arquivos ou locks, nunca para lógica principal.",
                                  "learningObjective": "Garantir cleanup robusto e estrutura completa com else/finally.",
                                  "commonMistakes": [
                                    "Colocar cleanup no catch (pula se sucesso)",
                                    "Excesso de try-catch aninhados",
                                    "Não documentar exceções tratadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Função Python para divisão segura com input: def safe_divide(): try: num = int(input('Numerador: ')); den = int(input('Denominador: ')); result = num / den; print(f'Resultado: {result}'); except ValueError as e: print(f'Input inválido: {e}'); except ZeroDivisionError: print('Divisão por zero!'); else: print('Cálculo bem-sucedido.'); finally: print('Sessão encerrada.'). Teste com '10', '0' → captura ZeroDivisionError e executa finally.",
                              "finalVerifications": [
                                "Código executa sem crashes em todos os cenários testados (sucesso, erros específicos, genéricos).",
                                "Mensagens de erro são claras, específicas e incluem detalhes da exceção.",
                                "Bloco finally executa consistentemente, simulando cleanup.",
                                "Else executa apenas em casos de sucesso sem exceção.",
                                "Código é modular (função) e comentado.",
                                "Testes cobrem pelo menos 5 casos: sucesso, ValueError, ZeroDivisionError, outra exceção."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta de try-catch-else-finally (100% precisa).",
                                "Captura hierárquica: específicas antes de genéricas.",
                                "Tratamento informativo: usa 'as e' e mensagens úteis.",
                                "Robustez: previne crashes e gerencia recursos via finally.",
                                "Eficiência: sem redundâncias ou catches desnecessários.",
                                "Clareza: código legível com comentários e estrutura lógica."
                              ],
                              "crossCurricularConnections": [
                                "Lógica de Programação: Fluxo condicional avançado similar a switch-case.",
                                "Matemática: Tratamento de operações indefinidas (divisão por zero).",
                                "Engenharia de Software: Princípios de robustez e defensive programming.",
                                "Segurança da Informação: Mitigação de erros por inputs maliciosos."
                              ],
                              "realWorldApplication": "Em aplicativos de e-commerce para validar carrinhos de compra (evitar divisão por zero em descontos), servidores web tratando falhas de banco de dados sem derrubar o serviço, ou jogos processando inputs de usuário para prevenir freezes por valores inválidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Lançar exceções personalizadas",
                            "description": "Usar throw para lançar exceções customizadas baseadas em condições de validação, propagando erros de forma controlada através de chamadas de funções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir uma classe de exceção personalizada",
                                  "subSteps": [
                                    "Crie uma nova classe que estenda `Exception` ou `RuntimeException`",
                                    "Adicione um construtor padrão sem parâmetros",
                                    "Adicione um construtor que receba uma mensagem de erro como `String`",
                                    "Adicione um construtor que receba uma causa (`Throwable`)",
                                    "Torne a classe `public` para uso em outros pacotes"
                                  ],
                                  "verification": "Compilar a classe sem erros e instanciar um objeto dela em um teste simples",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE (IntelliJ, Eclipse ou VS Code com extensão Java)",
                                    "JDK 8 ou superior"
                                  ],
                                  "tips": "Prefira `RuntimeException` para exceções não obrigatórias a serem tratadas (unchecked)",
                                  "learningObjective": "Compreender a herança de classes de exceção e criar exceções reutilizáveis",
                                  "commonMistakes": [
                                    "Esquecer de chamar `super(message)` no construtor",
                                    "Não declarar a classe como `public`",
                                    "Estender `Throwable` diretamente em vez de `Exception`"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e definir condições de validação",
                                  "subSteps": [
                                    "Analise os requisitos da função para identificar cenários inválidos (ex: valor negativo, nulo)",
                                    "Defina variáveis booleanas ou expressões condicionais para essas validações",
                                    "Documente cada condição com comentários explicativos",
                                    "Priorize validações críticas que impactam a lógica de negócio",
                                    "Teste logicamente as condições com valores de borda (edge cases)"
                                  ],
                                  "verification": "Escreva testes unitários manuais ou com JUnit para verificar se as condições detectam entradas inválidas",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com suporte a debugging",
                                    "Exemplos de dados de teste (planilha ou notas)"
                                  ],
                                  "tips": "Use asserts temporários para validar condições durante o desenvolvimento",
                                  "learningObjective": "Desenvolver lógica condicional robusta para validação de dados",
                                  "commonMistakes": [
                                    "Ignorar valores nulos ou vazios",
                                    "Não considerar casos de borda como zero ou máximo",
                                    "Validações redundantes que mascaram erros reais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o lançamento da exceção com throw",
                                  "subSteps": [
                                    "Dentro da função, use `if` para checar condições inválidas",
                                    "Crie uma instância da exceção personalizada com mensagem descritiva",
                                    "Use a palavra-chave `throw` para lançar a exceção",
                                    "Posicione o `throw` antes de qualquer código que dependa da validação",
                                    "Adicione logging opcional antes do throw para depuração"
                                  ],
                                  "verification": "Execute a função com entrada inválida e confirme que a exceção é lançada com a mensagem correta",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE",
                                    "Console ou debugger para capturar stack trace"
                                  ],
                                  "tips": "Mensagens de erro devem ser claras e incluir o valor inválido, ex: 'Saldo insuficiente: 10.0'",
                                  "learningObjective": "Aplicar `throw` para interromper fluxo e propagar erros de forma controlada",
                                  "commonMistakes": [
                                    "Usar `return` em vez de `throw`",
                                    "Lançar exceções genéricas como `Exception` em vez de customizadas",
                                    "Colocar throw após código que pode causar NullPointerException"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar propagação e tratamento da exceção",
                                  "subSteps": [
                                    "Chame a função de uma função superior sem try-catch para observar propagação",
                                    "Adicione try-catch na função chamadora para capturar e logar a exceção",
                                    "Teste cenários onde a exceção é propagada através de múltiplas chamadas",
                                    "Verifique o stack trace para confirmar a origem correta",
                                    "Refatore para re-lançar (`throw e`) se necessário em camadas superiores"
                                  ],
                                  "verification": "Confirme que a exceção propaga corretamente e é tratada sem crashar o programa",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JUnit ou TestNG para testes automatizados",
                                    "Debugger da IDE"
                                  ],
                                  "tips": "Use `finally` para cleanup de recursos mesmo em exceções",
                                  "learningObjective": "Entender o fluxo de propagação automática de exceções e seu tratamento hierárquico",
                                  "commonMistakes": [
                                    "Capturar exceções muito amplas como `Exception`",
                                    "Ignorar exceções com empty catch blocks",
                                    "Não testar propagação em chamadas aninhadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema bancário, crie `InsufficientFundsException`. Na função `sacar(Conta conta, double valor)`, valide se `valor > conta.getSaldo()` e lance `throw new InsufficientFundsException(\"Saldo insuficiente: \" + conta.getSaldo());`. Chame de `realizarTransacao()` que captura e loga o erro, exibindo mensagem ao usuário.",
                              "finalVerifications": [
                                "A classe de exceção compila e é instanciável",
                                "Exceção é lançada corretamente em condições inválidas",
                                "Mensagem da exceção inclui detalhes relevantes",
                                "Exceção propaga através de chamadas de funções sem ser capturada prematuramente",
                                "Stack trace aponta para a linha exata do throw",
                                "Tratamento em try-catch loga ou exibe adequadamente"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta de classe de exceção e uso de throw",
                                "Condições de validação cobrem todos os casos críticos",
                                "Mensagens de erro claras e informativas",
                                "Propagação controlada sem vazamento de exceções desnecessárias",
                                "Testes demonstram lançamento e captura efetivos",
                                "Código segue boas práticas (nomenclatura, comentários)"
                              ],
                              "crossCurricularConnections": [
                                "Lógica de Programação: Condicionais if-else e booleanos",
                                "Engenharia de Software: Design de APIs robustas e validação de input",
                                "Depuração: Análise de stack traces e logging",
                                "Matemática: Lógica booleana e validação numérica"
                              ],
                              "realWorldApplication": "Em aplicações web/bancárias, lançar `InvalidUserInputException` para validar formulários impede processamento de dados corrompidos, melhorando segurança e UX ao fornecer feedback preciso ao usuário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Subprogramação",
                    "description": "Funções, passagem de parâmetros por valor e referência, escopo de variáveis e recursividade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Funções",
                        "description": "Definição, declaração, chamada e retorno de valores em funções como subprogramas modulares para reutilização de código.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Identificar componentes de uma função",
                            "description": "Reconhecer e descrever os elementos essenciais de uma função: cabeçalho (nome, parâmetros, tipo de retorno), corpo e chamada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito geral de uma função",
                                  "subSteps": [
                                    "Ler e anotar a definição de função: bloco de código nomeado que realiza uma tarefa específica e pode ser reutilizado.",
                                    "Identificar os benefícios: modularidade, reutilização de código e melhoria na legibilidade.",
                                    "Visualizar os três componentes principais: cabeçalho (definição externa), corpo (lógica interna) e chamada (invocação).",
                                    "Comparar função com estruturas semelhantes, como procedimentos sem retorno.",
                                    "Discutir exemplos cotidianos para fixar o conceito."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito os três componentes principais de uma função e seu propósito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação básica de funções em pseudocódigo ou Python",
                                    "Vídeo introdutório curto (5 minutos) sobre funções"
                                  ],
                                  "tips": "Use analogias como uma 'caixa preta': entradas (parâmetros), processamento (corpo) e saída (retorno).",
                                  "learningObjective": "Entender o papel fundamental das funções na programação modular.",
                                  "commonMistakes": [
                                    "Confundir função com laços ou condicionais.",
                                    "Acreditar que toda função deve retornar um valor."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dissecar o cabeçalho da função",
                                  "subSteps": [
                                    "Localizar a palavra-chave de declaração (ex: 'def', 'function', 'FUNÇÃO').",
                                    "Identificar o nome da função e suas convenções (snake_case, camelCase).",
                                    "Analisar parâmetros: lista entre parênteses, com tipos e nomes.",
                                    "Reconhecer o tipo de retorno: indicado após seta (->) ou dois pontos.",
                                    "Anotar sintaxe completa do cabeçalho em um exemplo."
                                  ],
                                  "verification": "Dado um código, destacar e rotular cada elemento do cabeçalho corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de cabeçalhos variados em diferentes linguagens (pseudocódigo, Python)",
                                    "Editor de texto para markup"
                                  ],
                                  "tips": "Nomes de funções devem ser descritivos e começar com verbos no infinitivo (ex: calcularArea).",
                                  "learningObjective": "Reconhecer e descrever precisamente os elementos do cabeçalho.",
                                  "commonMistakes": [
                                    "Omitir o tipo de retorno na análise.",
                                    "Confundir parâmetros com variáveis globais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o corpo da função",
                                  "subSteps": [
                                    "Identificar delimitadores: chaves {}, indentação ou palavras-chave.",
                                    "Mapear instruções sequenciais, condicionais ou loops dentro do corpo.",
                                    "Localizar a instrução de retorno (return, RETORNE) e seu valor.",
                                    "Diferenciar variáveis locais dos parâmetros recebidos.",
                                    "Explicar o fluxo de execução linha por linha."
                                  ],
                                  "verification": "Descrever o que o corpo faz, passo a passo, sem erros lógicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Códigos-fonte com corpos simples e complexos",
                                    "Ferramenta de depuração básica ou simulador"
                                  ],
                                  "tips": "Mantenha o corpo curto (máximo 10-15 linhas); divida funções longas.",
                                  "learningObjective": "Compreender a lógica interna e o processamento do corpo.",
                                  "commonMistakes": [
                                    "Acessar variáveis externas sem parâmetros.",
                                    "Esquecer ou posicionar mal a instrução de retorno."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e analisar chamadas de funções",
                                  "subSteps": [
                                    "Localizar o nome da função seguido de parênteses em um código maior.",
                                    "Verificar argumentos passados: ordem, número e tipos compatíveis.",
                                    "Observar atribuição do retorno a uma variável ou uso direto.",
                                    "Identificar chamadas aninhadas ou em contextos variados.",
                                    "Simular a execução de uma chamada completa."
                                  ],
                                  "verification": "Marcar todas as chamadas em um programa e explicar seus efeitos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Programa completo com múltiplas funções e chamadas",
                                    "Simulador de execução de código"
                                  ],
                                  "tips": "Sempre valide: número de argumentos == número de parâmetros.",
                                  "learningObjective": "Reconhecer como funções são invocadas e interagem.",
                                  "commonMistakes": [
                                    "Passar argumentos errados em ordem ou tipo.",
                                    "Chamar função antes de sua declaração."
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo em pseudocódigo:\n\nFUNÇÃO calcularMedia(nota1: real, nota2: real, nota3: real) -> real:\n    soma = nota1 + nota2 + nota3\n    media = soma / 3\n    RETORNE media\n\nChamada no programa principal:\nmediaAluno = calcularMedia(7.5, 8.0, 9.2)\n\n- Cabeçalho: FUNÇÃO calcularMedia(nota1: real, nota2: real, nota3: real) -> real\n- Corpo: soma = ...; media = ...; RETORNE media\n- Chamada: calcularMedia(7.5, 8.0, 9.2)",
                              "finalVerifications": [
                                "Identificar corretamente o cabeçalho completo em qualquer função dada.",
                                "Listar parâmetros, tipos e tipo de retorno sem omissões.",
                                "Explicar o propósito e fluxo do corpo linha por linha.",
                                "Localizar e descrever todas as chamadas, incluindo argumentos.",
                                "Diferenciar função de variáveis, loops ou condicionais.",
                                "Simular execução de uma função completa com entrada/saída."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os componentes (100% corretos).",
                                "Descrições claras e uso correto de terminologia técnica.",
                                "Explicação lógica das interações entre cabeçalho, corpo e chamada.",
                                "Análise sem erros conceituais em exemplos variados.",
                                "Capacidade de aplicar em código novo ou modificado.",
                                "Demonstração de compreensão via simulação ou diagrama."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com funções matemáticas f(x, y) = resultado.",
                                "Língua Portuguesa: Análise sintática de estruturas complexas.",
                                "Ciências: Modelos de sistemas com entrada, processamento e saída.",
                                "Artes: Composição modular de elementos em projetos criativos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software real, como apps de e-commerce, identificar componentes de funções permite depurar erros em cálculos de frete (parâmetros: peso, distância; corpo: fórmula; chamada: no checkout), refatorar código legado e colaborar em equipes, reduzindo tempo de manutenção em projetos empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Criar uma função simples",
                            "description": "Escrever uma função que receba parâmetros, execute cálculos e retorne um valor, sem passagem por referência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar a estrutura da função",
                                  "subSteps": [
                                    "Identifique o propósito da função: o que ela deve fazer?",
                                    "Defina os parâmetros de entrada necessários e seus tipos esperados",
                                    "Determine o valor de retorno e seu tipo",
                                    "Esboce a lógica principal em pseudocódigo ou fluxograma simples",
                                    "Verifique se a função será autônoma, sem alterar variáveis externas"
                                  ],
                                  "verification": "Esboço escrito ou diagrama confirmando entradas, processamento e saída",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou quadro branco"
                                  ],
                                  "tips": "Pense na função como uma 'caixa preta': entradas vão, saída sai, sem efeitos colaterais",
                                  "learningObjective": "Compreender os componentes fundamentais de uma função simples",
                                  "commonMistakes": [
                                    "Ignorar tipos de parâmetros e retorno",
                                    "Incluir lógica desnecessária ou dependente de variáveis globais",
                                    "Confundir função com procedimento (sem retorno)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a assinatura da função",
                                  "subSteps": [
                                    "Escreva a declaração da função: def nome_funcao(parametro1, parametro2):",
                                    "Adicione uma docstring explicando propósito, parâmetros e retorno",
                                    "Especifique o tipo de retorno com '-> tipo' (em Python tipado) ou comentário",
                                    "Garanta que parâmetros sejam passados por valor (imutáveis internamente)",
                                    "Valide sintaxe básica compilando ou checando erros"
                                  ],
                                  "verification": "Assinatura compila sem erros e docstring está presente",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, PyCharm)"
                                  ],
                                  "tips": "Use nomes descritivos para função e parâmetros para clareza",
                                  "learningObjective": "Dominar a sintaxe de declaração de funções com parâmetros e retorno",
                                  "commonMistakes": [
                                    "Esquecer os dois pontos (:) após parâmetros",
                                    "Usar passagem por referência acidental (ex: listas mutáveis)",
                                    "Omitir docstring, dificultando reutilização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o corpo da função",
                                  "subSteps": [
                                    "Implemente os cálculos ou lógica dentro do corpo da função",
                                    "Use apenas parâmetros recebidos, sem variáveis externas",
                                    "Adicione a instrução return com o valor calculado",
                                    "Inclua tratamento básico de erros (ex: verificação de valores negativos)",
                                    "Mantenha o código conciso, com no máximo 10 linhas"
                                  ],
                                  "verification": "Código roda sem erros de sintaxe e retorna valor placeholder",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Documentação da linguagem (ex: Python docs)"
                                  ],
                                  "tips": "Teste mentalmente com valores exemplo antes de codificar",
                                  "learningObjective": "Executar operações lógicas internas e retornar resultados corretamente",
                                  "commonMistakes": [
                                    "Esquecer a palavra 'return'",
                                    "Modificar parâmetros mutáveis (violando 'sem referência')",
                                    "Adicionar prints ou side-effects desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a função",
                                  "subSteps": [
                                    "Crie chamadas de teste com inputs variados (normais, borda, inválidos)",
                                    "Execute e compare saídas esperadas vs. reais",
                                    "Depure erros usando print ou debugger",
                                    "Refatore para melhorar legibilidade se necessário",
                                    "Documente testes em comentários"
                                  ],
                                  "verification": "Todos os testes passam com saídas corretas",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código com terminal",
                                    "Valores de teste pré-definidos"
                                  ],
                                  "tips": "Use asserts para automação: assert funcao(5,3) == 15",
                                  "learningObjective": "Garantir robustez e correção da função por meio de testes",
                                  "commonMistakes": [
                                    "Testar apenas um caso feliz",
                                    "Ignorar casos de borda como zero ou negativos",
                                    "Não depurar exceções adequadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma função calcular_area_retangulo(comprimento: float, largura: float) -> float que retorna a área (comprimento * largura). Exemplo de uso: resultado = calcular_area_retangulo(5.0, 3.0)  # Deve retornar 15.0. Teste com 0 e negativos para validar.",
                              "finalVerifications": [
                                "Função executa sem erros de sintaxe ou runtime",
                                "Retorna valor correto para múltiplos inputs de teste",
                                "Não altera variáveis fora do escopo da função",
                                "Docstring explica uso corretamente",
                                "Código é legível e conciso",
                                "Passa em asserts automatizados"
                              ],
                              "assessmentCriteria": [
                                "Assinatura completa com parâmetros, retorno e docstring (30%)",
                                "Lógica interna correta e sem side-effects (30%)",
                                "Testes abrangentes com casos variados (20%)",
                                "Código limpo, com comentários e boas práticas (10%)",
                                "Autonomia: função reutilizável independentemente (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de operações aritméticas básicas",
                                "Lógica: Desenvolvimento de algoritmos sequenciais",
                                "Português/Inglês: Redação de docstrings claras",
                                "Ética em Computação: Modularidade para código reutilizável e mantível"
                              ],
                              "realWorldApplication": "Funções simples são usadas em softwares reais para modularizar código, como calcular descontos em e-commerces, validar formas em apps de design ou processar dados em planilhas automatizadas, promovendo eficiência e escalabilidade em equipes de desenvolvimento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Chamar funções com argumentos",
                            "description": "Invocar funções passando argumentos posicionais ou nomeados e capturar valores de retorno em variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e praticar argumentos posicionais",
                                  "subSteps": [
                                    "Leia a definição de argumentos posicionais: a ordem importa.",
                                    "Defina uma função simples que recebe dois argumentos posicionais, como soma(a, b).",
                                    "Chame a função passando valores na ordem correta: soma(3, 5).",
                                    "Teste alterando a ordem para observar o erro.",
                                    "Registre o resultado impresso na tela."
                                  ],
                                  "verification": "Execute o código e confirme que o resultado é correto (ex: 8 para soma(3,5)) sem erros de ordem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou Replit), Python instalado",
                                  "tips": "Sempre liste os parâmetros da função antes de chamar para lembrar a ordem.",
                                  "learningObjective": "Compreender que argumentos posicionais dependem da posição exata.",
                                  "commonMistakes": "Confundir a ordem dos argumentos, levando a resultados inesperados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar argumentos nomeados",
                                  "subSteps": [
                                    "Modifique a função para incluir parâmetros com valores padrão.",
                                    "Chame a função usando nomes: soma(a=3, b=5).",
                                    "Teste chamadas parciais: soma(b=5) se a tiver padrão.",
                                    "Misture posicionais e nomeados: soma(3, b=5).",
                                    "Verifique erros ao repetir nomes ou ordem inválida."
                                  ],
                                  "verification": "Código roda sem erros e aceita combinações de argumentos nomeados e posicionais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo editor e Python; documentação Python sobre funções",
                                  "tips": "Use nomes para clareza em funções com muitos parâmetros.",
                                  "learningObjective": "Dominar argumentos nomeados para flexibilidade na ordem.",
                                  "commonMistakes": "Passar argumento posicional após nomeado, causando SyntaxError."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Capturar valores de retorno em variáveis",
                                  "subSteps": [
                                    "Crie uma função que retorna um valor: def multiplica(x, y): return x * y.",
                                    "Chame e capture: resultado = multiplica(4, 6).",
                                    "Use a variável em outra operação: print(resultado + 10).",
                                    "Teste funções sem return (None) e capture para entender.",
                                    "Pratique com funções built-in como len() ou input()."
                                  ],
                                  "verification": "Variável recebe o valor correto e pode ser usada em expressões subsequentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código; exemplos de funções built-in do Python",
                                  "tips": "Sempre atribua o retorno a uma variável se precisar reutilizar.",
                                  "learningObjective": "Capturar e manipular valores retornados por funções.",
                                  "commonMistakes": "Esquecer o 'return' na função ou não atribuir o resultado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar conceitos em um exemplo prático",
                                  "subSteps": [
                                    "Crie uma função complexa: calcular área de retângulo com args nomeados e return.",
                                    "Chame com args posicionais, nomeados e capture retorno.",
                                    "Aninhe chamadas: area = calc_area(10, 20); total = area * 2.",
                                    "Teste cenários de erro e corrija.",
                                    "Escreva um pequeno script usando múltiplas chamadas."
                                  ],
                                  "verification": "Script completo executa corretamente com mistura de argumentos e retornos capturados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor; papel para diagramar fluxos",
                                  "tips": "Comente o código explicando cada chamada para reforçar aprendizado.",
                                  "learningObjective": "Aplicar todos os conceitos em um fluxo integrado.",
                                  "commonMistakes": "Não capturar retornos em chains de funções."
                                }
                              ],
                              "practicalExample": "Defina def saudacao(nome, idade=18): return f'Olá {nome}, você tem {idade} anos.'\nChame: msg = saudacao('Ana', 25); print(msg)  # positional\nOu: msg2 = saudacao(nome='João', idade=30); print(msg2)  # named\nResultado: Olá Ana, você tem 25 anos. e Olá João, você tem 30 anos.",
                              "finalVerifications": [
                                "Código chama funções com argumentos posicionais sem erros.",
                                "Argumentos nomeados são usados corretamente em qualquer ordem.",
                                "Valores de retorno são capturados e utilizados em variáveis.",
                                "Mistura de positional e named funciona.",
                                "Funções sem return retornam None corretamente.",
                                "Não há SyntaxError ou TypeError em chamadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na ordem de argumentos posicionais (100% correto).",
                                "Flexibilidade com argumentos nomeados (pelo menos 3 variações testadas).",
                                "Captura de retornos em 80% das chamadas.",
                                "Código limpo com comentários explicativos.",
                                "Tratamento de erros comuns demonstrado.",
                                "Exemplo prático funcional e realista."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções como mapeamento de entradas para saídas.",
                                "Física: Modelagem de cálculos com parâmetros (ex: velocidade = distancia/tempo).",
                                "Língua Portuguesa: Argumentos nomeados melhoram legibilidade como boas práticas de escrita.",
                                "Artes: Parâmetros em funções geradoras de padrões gráficos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como calcular descontos em e-commerces (preco, desconto_pct), processar dados em apps (nome_usuario, email), ou APIs onde funções recebem parâmetros dinâmicos para personalização de serviços."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Passagem de Parâmetros por Valor e Referência",
                        "description": "Diferenças entre passagem por valor (cópia) e por referência (alias), impactos na modificação de variáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Diferenciar passagem por valor e referência",
                            "description": "Explicar como a passagem por valor cria cópias imutáveis para o chamador e por referência permite alterações no original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Passagem por Valor",
                                  "subSteps": [
                                    "Defina passagem por valor: o valor do parâmetro é copiado para a função, criando uma variável local independente.",
                                    "Analise o fluxo: alterações na cópia não afetam o original no chamador.",
                                    "Estude um exemplo simples com tipos primitivos como inteiros.",
                                    "Simule o processo em pseudocódigo: procedure somaValor(x: integer) { x := x + 1 }",
                                    "Verifique com diagrama de memória mostrando duas caixas separadas."
                                  ],
                                  "verification": "Escreva um pseudocódigo e explique por que o valor original permanece inalterado após a chamada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo editor",
                                    "Papel e caneta para diagramas de memória"
                                  ],
                                  "tips": "Sempre desenhe diagramas de pilha para visualizar cópias.",
                                  "learningObjective": "Explicar o mecanismo de cópia na passagem por valor e sua imutabilidade para o chamador.",
                                  "commonMistakes": [
                                    "Achar que qualquer alteração afeta o original",
                                    "Confundir com atribuição de variáveis locais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Passagem por Referência",
                                  "subSteps": [
                                    "Defina passagem por referência: o endereço da variável é passado, permitindo acesso direto ao original.",
                                    "Analise o fluxo: alterações na função modificam o dado original no chamador.",
                                    "Estude exemplo com estruturas ou arrays que precisam ser alterados.",
                                    "Simule em pseudocódigo: procedure somaRef(var x: integer) { x := x + 1 }",
                                    "Desenhe diagrama de memória mostrando ponteiro para a mesma caixa."
                                  ],
                                  "verification": "Modifique um pseudocódigo por referência e confirme que o original muda após a chamada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo editor",
                                    "Ferramenta de desenho para diagramas"
                                  ],
                                  "tips": "Pense em 'endereço' como um atalho para a casa original.",
                                  "learningObjective": "Descrever como a referência permite mutação do dado original.",
                                  "commonMistakes": [
                                    "Confundir com cópia de endereço sem mutação",
                                    "Ignorar o 'var' ou '&' na sintaxe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Passagem por Valor e Referência",
                                  "subSteps": [
                                    "Liste diferenças chave: cópia vs endereço, imutável vs mutável.",
                                    "Crie tabela comparativa: impacto em primitivos, objetos, performance.",
                                    "Teste cenários: quando usar cada uma (valor para segurança, ref para eficiência).",
                                    "Analise trade-offs: por valor consome mais memória, por ref pode causar efeitos colaterais.",
                                    "Discuta linguagens: Java sempre por ref para objetos, C++ opções explícitas."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e identifique 3 cenários para cada tipo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em editor de texto"
                                  ],
                                  "tips": "Use exemplos idênticos para comparação lado a lado.",
                                  "learningObjective": "Diferenciar comportamentos e escolher o tipo adequado por caso.",
                                  "commonMistakes": [
                                    "Achar que objetos sempre por valor",
                                    "Ignorar performance em grandes dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Testar as Diferenças",
                                  "subSteps": [
                                    "Escreva função que incrementa um inteiro por valor e por referência.",
                                    "Chame ambas e imprima resultados antes/depois.",
                                    "Repita com array/lista para ver diferenças claras.",
                                    "Debugue um erro comum: função não altera esperado.",
                                    "Refatore código usando o tipo correto para otimizar."
                                  ],
                                  "verification": "Execute código com prints e confirme resultados esperados em ambos os casos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador ou interpretador (ex: Pascal, C++)",
                                    "Editor de código"
                                  ],
                                  "tips": "Sempre teste com dados grandes para notar performance.",
                                  "learningObjective": "Implementar e validar diferenças em código real.",
                                  "commonMistakes": [
                                    "Esquecer sintaxe de referência",
                                    "Não limpar variáveis entre testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma função incrementa(n: integer): por valor, chama incrementa(5) resulta em n=5 original; por referência, incrementa(var n: integer) altera para 6 no chamador. Para lista: por valor copia lista inteira (lento), por ref modifica elementos originais.",
                              "finalVerifications": [
                                "Explicar verbalmente por que por valor é 'segura' mas ineficiente para structs.",
                                "Converter código por valor para ref e prever mudança no original.",
                                "Identificar bug em código onde função não altera array passado.",
                                "Desenhar diagramas corretos para ambos os tipos.",
                                "Escolher tipo correto para função que modifica lista de usuários.",
                                "Discutir quando evitar ref para prevenir bugs colaterais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: define cópia vs endereço corretamente.",
                                "Uso de exemplos: fornece código/diagramas funcionais.",
                                "Compreensão de impactos: discute memória, performance e bugs.",
                                "Aplicação prática: escolhe tipo adequado em cenários.",
                                "Análise comparativa: tabela ou lista clara de diferenças.",
                                "Correção em testes: resultados de código batem com teoria."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Memória em Sistemas Operacionais: alocação de pilha vs heap.",
                                "Programação Orientada a Objetos: passagem de objetos por ref em Java/Python.",
                                "Algoritmos e Estruturas: eficiência em listas vs primitivos.",
                                "Engenharia de Software: design de APIs imutáveis vs mutáveis."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps, usar ref em funções que atualizam bancos de dados ou listas de usuários evita cópias desnecessárias e bugs; por valor em cálculos puros previne alterações acidentais, comum em games (posições imutáveis) e finanças (cálculos seguros)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Implementar passagem por valor",
                            "description": "Criar funções onde parâmetros são passados por valor e verificar que mudanças internas não afetam variáveis externas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de passagem por valor",
                                  "subSteps": [
                                    "Leia a definição: na passagem por valor, a função recebe uma cópia do valor da variável, não a referência dela.",
                                    "Compare com passagem por referência: na por valor, alterações internas não afetam o original.",
                                    "Estude diagramas visuais de memória: desenhe como a cópia é criada na pilha.",
                                    "Analise exemplos em pseudocódigo: func(int x) { x = x + 1; } não altera o x original.",
                                    "Discuta por que isso garante imutabilidade e evita efeitos colaterais."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre cópia e referência, com um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagem (ex: Python ou C)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogia: como fotocopiar um papel antes de editar.",
                                  "learningObjective": "Identificar e explicar o mecanismo de cópia na passagem por valor.",
                                  "commonMistakes": [
                                    "Confundir com passagem por referência",
                                    "Achar que sempre copia objetos complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar uma função básica com passagem por valor",
                                  "subSteps": [
                                    "Defina uma função simples: def dobrar(x): return x * 2",
                                    "Declare uma variável fora: numero = 5",
                                    "Chame a função: resultado = dobrar(numero)",
                                    "Imprima o valor original: print(numero)  # Deve ser 5",
                                    "Teste o retorno: print(resultado)  # Deve ser 10"
                                  ],
                                  "verification": "Execute o código e confirme que numero permanece inalterado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Replit)",
                                    "Interpretador Python ou C"
                                  ],
                                  "tips": "Comece com tipos primitivos como int ou float para clareza.",
                                  "learningObjective": "Implementar uma função que usa passagem por valor sem alterar parâmetros externos.",
                                  "commonMistakes": [
                                    "Esquecer de retornar o valor modificado",
                                    "Usar print dentro da função sem retorno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar parâmetros internos e testar isolamento",
                                  "subSteps": [
                                    "Altere a função para modificar o parâmetro: def incrementar(x): x += 1; return x",
                                    "Chame múltiplas vezes: a = 10; b = incrementar(a); c = incrementar(a)",
                                    "Imprima todos: print(a, b, c)  # Esperado: 10 11 11",
                                    "Adicione asserts: assert a == 10",
                                    "Registre saídas em log para análise."
                                  ],
                                  "verification": "Confirme via asserts ou prints que a variável original não muda após chamadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Biblioteca de asserts (unittest em Python)"
                                  ],
                                  "tips": "Use múltiplas chamadas para demonstrar independência.",
                                  "learningObjective": "Demonstrar que modificações locais não propagam para fora.",
                                  "commonMistakes": [
                                    "Confundir com listas/mutáveis em Python",
                                    "Não usar asserts para verificação automatizada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em um exemplo prático e debugar",
                                  "subSteps": [
                                    "Crie função para calcular área: def area_quadrado(lado): lado *= 2; return lado * lado",
                                    "Teste: comprimento = 3; area = area_quadrado(comprimento)",
                                    "Verifique: print(comprimento)  # 3, não 6",
                                    "Adicione tratamento de erro para valores inválidos (ex: if lado < 0)",
                                    "Escreva testes unitários completos."
                                  ],
                                  "verification": "Todos os testes passam e variável externa permanece inalterada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Framework de testes (pytest)"
                                  ],
                                  "tips": "Integre com cálculo matemático para reforçar.",
                                  "learningObjective": "Integrar passagem por valor em função realista com validação.",
                                  "commonMistakes": [
                                    "Modificar globalmente por engano",
                                    "Ignorar validações de entrada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: def modificar_copia(valor): valor = valor + 10; print('Interno:', valor)\noriginal = 5\nmodificar_copia(original)\nprint('Externo:', original)  # Saída: Interno: 15, Externo: 5",
                              "finalVerifications": [
                                "Variável original não altera após modificações na função.",
                                "Função retorna valor correto sem side-effects.",
                                "Múltiplas chamadas com mesmo argumento produzem cópias independentes.",
                                "Asserts ou testes unitários passam 100%.",
                                "Código roda sem erros em diferentes entradas."
                              ],
                              "assessmentCriteria": [
                                "Código demonstra cópia explícita (90% precisão).",
                                "Testes cobrem casos normais e edge cases (80% cobertura).",
                                "Explicação escrita correta do conceito (clareza total).",
                                "Ausência de efeitos colaterais comprovada.",
                                "Eficiência: tempo de execução O(1) para primitivos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de funções e variáveis independentes.",
                                "Lógica: Evitar mutações inesperadas em raciocínio algorítmico.",
                                "Física: Modelagem de sistemas isolados (energia conservada).",
                                "Inglês: Leitura de documentação técnica de linguagens."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, garante funções puras em APIs (ex: calculadoras financeiras onde saldos não são alterados acidentalmente), bibliotecas matemáticas e microsserviços para previsibilidade e debugabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Implementar passagem por referência",
                            "description": "Usar referências ou ponteiros para passar parâmetros modificáveis e demonstrar alterações propagadas ao chamador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Passagem de Parâmetros por Valor",
                                  "subSteps": [
                                    "Escreva uma função simples que recebe dois parâmetros inteiros por valor (ex: void increment(int x, int y))",
                                    "Modifique os parâmetros dentro da função (ex: x++; y += 10;)",
                                    "No main(), chame a função passando variáveis e imprima seus valores antes e depois da chamada",
                                    "Observe que as modificações não afetam as variáveis originais",
                                    "Compile e execute para confirmar o comportamento"
                                  ],
                                  "verification": "Execute o programa e verifique que as variáveis no main() permanecem inalteradas após a chamada da função.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou IDE como Code::Blocks)",
                                    "Editor de código (VS Code ou similar)"
                                  ],
                                  "tips": [
                                    "Use printf ou cout para imprimir valores antes e depois; sempre compile com -Wall para detectar warnings."
                                  ],
                                  "learningObjective": "Compreender que passagem por valor cria cópias locais, isolando mudanças da variável original.",
                                  "commonMistakes": [
                                    "Esquecer de imprimir valores antes/depois",
                                    "Confundir parâmetros com variáveis globais",
                                    "Não compilar e testar o código"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Ponteiros e Endereços de Memória",
                                  "subSteps": [
                                    "Declare uma variável inteira e um ponteiro para ela (ex: int var = 5; int* ptr = &var;)",
                                    "Imprima o endereço da variável (&var) e o valor do ponteiro (ptr)",
                                    "Acesse e modifique o valor via ponteiro (*ptr = 10;)",
                                    "Imprima a variável original para confirmar a mudança propagada",
                                    "Teste desreferenciando e comparando valores (*ptr == var)"
                                  ],
                                  "verification": "Modifique o valor via ponteiro e confirme que a variável original reflete a alteração ao imprimir.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Editor de código",
                                    "Documentação de ponteiros em C++ (opcional: cppreference.com)"
                                  ],
                                  "tips": [
                                    "Lembre-se: & obtém endereço, * acessa valor; evite ponteiros não inicializados.",
                                    "Use um debugger como gdb para visualizar memória."
                                  ],
                                  "learningObjective": "Dominar declaração, inicialização e uso de ponteiros para acessar e modificar memória indiretamente.",
                                  "commonMistakes": [
                                    "Usar ponteiro sem & na inicialização",
                                    "Confundir ptr com *ptr",
                                    "Dereferenciar ponteiro nulo (nullptr)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Função com Passagem por Ponteiro",
                                  "subSteps": [
                                    "Defina uma função void swap(int* a, int* b) que recebe ponteiros para inteiros",
                                    "Implemente a troca de valores dentro da função (ex: int temp = *a; *a = *b; *b = temp;)",
                                    "No main(), declare duas variáveis, passe seus endereços (&x, &y) para a função",
                                    "Imprima os valores antes e depois da chamada para demonstrar a troca",
                                    "Adicione comentários explicando o uso de * e &"
                                  ],
                                  "verification": "Execute e confirme que os valores das variáveis no main() foram efetivamente trocados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Editor de código"
                                  ],
                                  "tips": [
                                    "Use variável temporária para swap seguro; teste com valores diferentes (positivos, negativos)."
                                  ],
                                  "learningObjective": "Criar funções que modificam variáveis originais via ponteiros, demonstrando propagação de alterações.",
                                  "commonMistakes": [
                                    "Passar valores em vez de endereços (swap(x, y) ao invés de swap(&x, &y))",
                                    "Esquecer asterisco (*) na função",
                                    "Não usar temp na troca"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Comparar e Refatorar",
                                  "subSteps": [
                                    "Crie uma versão da função swap por valor e compare com a por ponteiro",
                                    "Teste casos extremos (valores zero, grandes números, variáveis locais)",
                                    "Use um debugger para inspecionar endereços e valores durante execução",
                                    "Refatore o código adicionando validações (verificar se ponteiros são nullptr)",
                                    "Documente diferenças entre por valor e por referência em comentários"
                                  ],
                                  "verification": "Todos os testes passam: swap funciona, comparação mostra isolamento por valor vs propagação por ponteiro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C++ com suporte a debugger (gdb ou IDE integrada)",
                                    "Editor de código"
                                  ],
                                  "tips": [
                                    "Execute múltiplas vezes com inputs variados; considere performance (cópia vs referência)."
                                  ],
                                  "learningObjective": "Validar implementação, identificar bugs comuns e otimizar código para uso real.",
                                  "commonMistakes": [
                                    "Ignorar checagem de ponteiro nulo",
                                    "Não testar edge cases",
                                    "Confundir saídas das duas versões de swap"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma função swap(int* a, int* b) em C++ para trocar valores de duas variáveis inteiras. No main(): int x=10, y=20; printf(\"Antes: x=%d, y=%d\\n\", x, y); swap(&x, &y); printf(\"Depois: x=%d, y=%d\\n\", x, y); Saída esperada: Antes: x=10, y=20 Depois: x=20, y=10. Demonstre que uma versão por valor (swap(int a, int b)) não altera x e y.",
                              "finalVerifications": [
                                "Código compila sem erros ou warnings",
                                "Função swap por ponteiro troca valores corretamente em múltiplos testes",
                                "Versão por valor não propaga mudanças",
                                "Ponteiros são inicializados e não causam segfault",
                                "Saídas impressas confirmam propagação",
                                "Código está comentado e legível"
                              ],
                              "assessmentCriteria": [
                                "Uso correto e consistente de & (endereço) e * (dereferência)",
                                "Modificações na função propagam ao chamador",
                                "Implementação eficiente sem cópias desnecessárias",
                                "Tratamento de edge cases e validações",
                                "Código limpo, comentado e com testes integrados",
                                "Compreensão demonstrada na comparação por valor vs referência"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Ponteiros como funções de mapeamento de endereços (algebrado de memória)",
                                "Física: Analogia com vetores posição e modificação remota de estados",
                                "Engenharia de Software: Otimização de performance e gerenciamento de recursos",
                                "Lógica Matemática: Recursão e indireção em estruturas de dados"
                              ],
                              "realWorldApplication": "Em jogos para atualizar posições de entidades (ex: player.x via ponteiro sem recópia); em bancos de dados para modificar saldos de contas atomicamente; em simuladores científicos para alterar arrays grandes sem duplicação de memória."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Escopo de Variáveis",
                        "description": "Regras de visibilidade e vida útil de variáveis: local, global, estática e sombreamento em subprogramas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Identificar escopo local e global",
                            "description": "Determinar onde variáveis declaradas dentro ou fora de funções são acessíveis e sua inicialização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de variáveis e escopo",
                                  "subSteps": [
                                    "Defina o que é uma variável: um espaço nomeado na memória para armazenar dados.",
                                    "Explique o que é escopo: a região do código onde uma variável pode ser acessada.",
                                    "Diferencie declaração (criação) de inicialização (atribuição de valor).",
                                    "Identifique funções como blocos delimitadores de escopo em linguagens como Python ou JavaScript.",
                                    "Revise exemplos simples de código sem funções para entender acessibilidade universal."
                                  ],
                                  "verification": "Responda corretamente a um quiz com 5 perguntas sobre definições básicas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto ou IDE online (Replit, CodePen), documentação de Python sobre variáveis.",
                                  "tips": "Use analogias como 'escopo é como uma sala: dentro dela, você vê tudo local, mas globais são visíveis de fora'.",
                                  "learningObjective": "Dominar definições fundamentais para contextualizar escopos local e global.",
                                  "commonMistakes": "Confundir declaração com inicialização; achar que toda variável é global por padrão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o escopo global",
                                  "subSteps": [
                                    "Declare uma variável fora de qualquer função e atribua um valor inicial.",
                                    "Acesse essa variável dentro e fora de funções para observar acessibilidade.",
                                    "Teste modificação da variável global dentro de uma função (usando 'global' em Python).",
                                    "Observe o comportamento em múltiplas funções.",
                                    "Verifique erros ao tentar acessar sem declaração prévia."
                                  ],
                                  "verification": "Execute código com variável global acessada em 3 funções diferentes sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE com Python (ex: Google Colab), exemplos de código prontos para edição.",
                                  "tips": "Sempre inicialize globais antes de usar; evite abusar para não poluir o namespace.",
                                  "learningObjective": "Identificar e manipular variáveis acessíveis em todo o programa.",
                                  "commonMistakes": "Modificar global sem keyword 'global' (em Python), causando criação de local acidental."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o escopo local",
                                  "subSteps": [
                                    "Declare uma variável dentro de uma função e atribua valor.",
                                    "Acesse-a dentro da função e tente fora para ver NameError.",
                                    "Crie variáveis locais em funções aninhadas para entender hierarquia.",
                                    "Teste shadowing: variável local com mesmo nome que global.",
                                    "Analise inicialização: erro se usada antes de atribuir valor."
                                  ],
                                  "verification": "Código roda sem erros dentro da função, mas falha fora dela ao acessar local.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo IDE, snippets de código com funções aninhadas.",
                                  "tips": "Locais promovem modularidade; use nomes únicos para evitar shadowing indesejado.",
                                  "learningObjective": "Reconhecer limitações de acessibilidade e inicialização em escopos locais.",
                                  "commonMistakes": "Achar que locais persistem após função terminar; ignorar shadowing."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e depuração de escopos",
                                  "subSteps": [
                                    "Analise códigos mistos com globais e locais, prevendo saídas.",
                                    "Corrija erros de escopo em códigos bugados fornecidos.",
                                    "Crie seu próprio código com 3 funções testando acessos.",
                                    "Compare acessos globais vs locais em termos de boas práticas.",
                                    "Documente diferenças em um diagrama de escopo."
                                  ],
                                  "verification": "Resolva 80% dos exercícios de depuração corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exercícios impressos ou online (LeetCode, HackerRank), papel para diagramas.",
                                  "tips": "Trace o código linha por linha com debugger para visualizar escopos.",
                                  "learningObjective": "Aplicar conhecimento para identificar e corrigir problemas de escopo.",
                                  "commonMistakes": "Prever acessibilidade errada em funções aninhadas; não inicializar locais."
                                }
                              ],
                              "practicalExample": "Em Python:\nglobal_var = 10\ndef func_externa():\n    local_externa = 20\n    def func_interna():\n        local_interna = 30\n        print(global_var)  # 10 (global)\n        print(local_externa)  # 20 (local externa)\n        print(local_interna)  # 30\n    func_interna()\n    print(local_interna)  # NameError!\nfunc_externa()",
                              "finalVerifications": [
                                "Explica corretamente a diferença entre escopo local e global com exemplos.",
                                "Prevê saída de código com variáveis em diferentes escopos sem erros.",
                                "Corrige um código com erro de NameError causado por escopo local.",
                                "Identifica shadowing em código fornecido.",
                                "Desenha diagrama de escopo para função aninhada.",
                                "Discute inicialização obrigatória em locais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de escopos (90% acerto em testes).",
                                "Capacidade de depuração de erros de escopo em <5 minutos.",
                                "Uso correto de keywords como 'global' quando necessário.",
                                "Explicação clara de shadowing e hierarquia de escopos.",
                                "Aplicação em códigos próprios sem violações de escopo.",
                                "Compreensão de boas práticas (priorizar locais)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com variáveis em funções matemáticas (domínio de validade).",
                                "Lógica: Regras de visibilidade semelhantes a quantificadores (∀, ∃).",
                                "Física: Modelagem de sistemas com variáveis locais (ex: simulações confinadas).",
                                "Inglês: Leitura de documentação oficial sobre escopos em linguagens."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, entender escopo evita bugs caros como sobrescrita acidental de dados em apps web (ex: variáveis de sessão em e-commerce) e promove código modular em equipes, facilitando manutenção em projetos como jogos ou APIs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Resolver conflitos de escopo",
                            "description": "Detectar e corrigir sombreamento de variáveis com nomes iguais em escopos aninhados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de escopo e sombreamento de variáveis",
                                  "subSteps": [
                                    "Defina escopo como a região do código onde uma variável é acessível.",
                                    "Explique sombreamento (shadowing) como a declaração de uma variável com o mesmo nome em um escopo interno, ocultando a externa.",
                                    "Diferencie escopo global, local e aninhado com diagramas de blocos.",
                                    "Analise um exemplo simples de escopo sem conflito para fixar o básico.",
                                    "Liste regras de visibilidade de variáveis em linguagens comuns como Python ou JavaScript."
                                  ],
                                  "verification": "Crie um diagrama manual de escopos aninhados e explique verbalmente ou por escrito como o sombreamento afeta o acesso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto, papel e caneta para diagramas, documentação de escopo em Python/JavaScript.",
                                  "tips": "Use cores diferentes para representar escopos em diagramas para visualização clara.",
                                  "learningObjective": "Dominar definições e diferenças entre escopo e sombreamento.",
                                  "commonMistakes": "Confundir sombreamento com redeclaração ilegal; assumir que escopos internos sempre acessam externos diretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar conflitos de escopo em código existente",
                                  "subSteps": [
                                    "Examine o código linha por linha, identificando declarações de variáveis.",
                                    "Trace o fluxo de execução e anote onde cada variável é referenciada.",
                                    "Marque instâncias de sombreamento comparando nomes em escopos pai e filho.",
                                    "Use ferramentas de depuração ou print/debug para observar valores reais durante execução.",
                                    "Compile uma lista de todos os conflitos potenciais com linha e escopo afetado."
                                  ],
                                  "verification": "Anote todos os sombreamentos em um código de teste e execute para confirmar valores inesperados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código com depurador (VS Code, PyCharm), código de exemplo com conflitos intencionais.",
                                  "tips": "Adicione comentários inline no código para mapear escopos durante a análise.",
                                  "learningObjective": "Identificar precisamente locais de sombreamento em códigos complexos.",
                                  "commonMistakes": "Ignorar escopos condicionais (if/else); não diferenciar referências de leitura vs. escrita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Corrigir conflitos de escopo usando refatoração",
                                  "subSteps": [
                                    "Renomeie variáveis internas para nomes únicos e descritivos.",
                                    "Alternativamente, reestruture o código movendo declarações para escopos apropriados.",
                                    "Atualize todas as referências afetadas para usar os novos nomes.",
                                    "Verifique se a lógica do programa permanece inalterada após mudanças.",
                                    "Aplique convenções de nomenclatura como prefixos para escopos (ex: local_ ou outer_)."
                                  ],
                                  "verification": "Execute o código corrigido e compare saídas com o original esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código com suporte a refatoração automática, testes unitários simples.",
                                  "tips": "Use 'find and replace' com cuidado, sempre seguido de testes manuais.",
                                  "learningObjective": "Aplicar técnicas de refatoração para eliminar sombreamento sem alterar comportamento.",
                                  "commonMistakes": "Renomear apenas uma referência, deixando outras inconsistentes; introduzir novos conflitos durante refatoração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a resolução completa",
                                  "subSteps": [
                                    "Crie casos de teste cobrindo acessos em diferentes escopos.",
                                    "Execute testes em cenários normais, edge cases e com depuração passo a passo.",
                                    "Analise métricas como cobertura de código e ausência de warnings de escopo.",
                                    "Documente a refatoração em comentários ou changelog.",
                                    "Revise o código com uma checklist de boas práticas de escopo."
                                  ],
                                  "verification": "Todos os testes passam e não há warnings de linter relacionados a escopo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Framework de testes (unittest em Python), linter (pylint ou ESLint).",
                                  "tips": "Automatize testes para rodar sempre após edições.",
                                  "learningObjective": "Garantir robustez da correção através de validação sistemática.",
                                  "commonMistakes": "Testar apenas o caminho feliz; esquecer de testar acessos em loops ou funções aninhadas."
                                }
                              ],
                              "practicalExample": "Em Python: def outer(): x = 10; def inner(): x = 20; print(x)  # Imprime 20, sombreando x externo. Correção: def outer(): x_outer = 10; def inner(): x_inner = 20; print(x_inner)  # Agora claro e sem conflito.",
                              "finalVerifications": [
                                "Código executa sem erros ou warnings de escopo.",
                                "Valores de variáveis correspondem ao esperado em todos os escopos.",
                                "Refatoração mantém lógica original intacta.",
                                "Documentação de mudanças está presente.",
                                "Linter confirma ausência de sombreamentos.",
                                "Testes unitários passam 100%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de todos os sombreamentos (100% identificados).",
                                "Correção eficaz sem introduzir novos bugs.",
                                "Eficiência da refatoração (mínimas mudanças).",
                                "Clareza e legibilidade do código pós-correção.",
                                "Documentação completa das alterações.",
                                "Cobertura de testes adequada aos cenários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de conjuntos e inclusão/exclusão (análoga a escopos).",
                                "Língua Portuguesa: Nomenclatura precisa e sem ambiguidades.",
                                "Física: Hierarquias de sistemas (ex: campos gravitacionais aninhados).",
                                "Ética: Boas práticas de código para colaboração em equipe."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, resolver conflitos de escopo previne bugs sutis em funções aninhadas, comuns em aplicações web com closures (JavaScript) ou decoradores (Python), garantindo manutenibilidade em projetos colaborativos como APIs empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Usar variáveis estáticas",
                            "description": "Implementar variáveis com escopo local mas vida útil estendida para manter valores entre chamadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de escopo e vida útil de variáveis",
                                  "subSteps": [
                                    "Diferencie escopo local (visível apenas na função) de escopo global (visível em todo o programa).",
                                    "Explique a vida útil: variáveis automáticas são destruídas ao sair da função; estáticas persistem.",
                                    "Analise um exemplo simples de variável local comum para observar perda de valor entre chamadas.",
                                    "Compare com variáveis globais, destacando riscos de poluição do namespace.",
                                    "Registre em um diagrama o ciclo de vida de cada tipo de variável."
                                  ],
                                  "verification": "O aluno explica verbalmente ou por escrito a diferença entre escopo local e vida útil estendida, com um diagrama correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou papel para diagramas",
                                    "Documentação de referência da linguagem (ex: C/C++)"
                                  ],
                                  "tips": "Use analogias como 'variável local é como um bloco de notas descartado após uso; estática é um caderno guardado'.",
                                  "learningObjective": "Diferenciar escopo e lifetime de variáveis locais, automáticas e estáticas.",
                                  "commonMistakes": [
                                    "Confundir static com global (static é local ao arquivo/função)",
                                    "Achar que static é reinicializada toda vez"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e inicializar variáveis estáticas em uma função",
                                  "subSteps": [
                                    "Escreva uma função simples que declare uma variável static int com inicialização (ex: static int contador = 0;).",
                                    "Modifique o valor da variável dentro da função (ex: contador++).",
                                    "Retorne ou imprima o valor para observar o comportamento.",
                                    "Compile e execute o código chamando a função uma vez.",
                                    "Verifique se a sintaxe está correta sem erros de compilação."
                                  ],
                                  "verification": "Código compila sem erros e exibe valor inicial correto na primeira chamada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C/C++ (ex: GCC online ou IDE como Code::Blocks)",
                                    "Editor de código"
                                  ],
                                  "tips": "Sempre inicialize explicitamente para evitar valores indefinidos na primeira execução.",
                                  "learningObjective": "Implementar corretamente a declaração de variável static com escopo local.",
                                  "commonMistakes": [
                                    "Esquecer o 'static' keyword",
                                    "Inicializar fora da declaração (não permitido em standards modernos)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar persistência de valores entre múltiplas chamadas",
                                  "subSteps": [
                                    "Chame a função múltiplas vezes (ex: 5 chamadas) em main() e imprima o retorno cada vez.",
                                    "Observe que o valor persiste e incrementa (1,2,3,...).",
                                    "Compare executando o mesmo com variável não-static para ver reset a cada chamada.",
                                    "Adicione printf para rastrear o valor antes/depois da modificação.",
                                    "Teste em loop para simular chamadas repetidas."
                                  ],
                                  "verification": "Ao executar, a função retorna valores incrementais corretos (ex: 1ª:1, 2ª:2), confirmados por saída no console.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador e terminal para execução",
                                    "Código base do step anterior"
                                  ],
                                  "tips": "Use loops for para automatizar chamadas e facilitar testes.",
                                  "learningObjective": "Verificar empiricamente a vida útil estendida da variável static entre chamadas.",
                                  "commonMistakes": [
                                    "Não chamar a função múltiplas vezes",
                                    "Confundir saída com variável global"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar variáveis estáticas em um programa prático",
                                  "subSteps": [
                                    "Crie um programa com função que simula um contador de acessos a um menu (ex: cada chamada incrementa visitas).",
                                    "Incorpore a static em uma função de logging que acumula erros.",
                                    "Teste chamando funções em sequência e verifique persistência.",
                                    "Refatore um código existente substituindo global por static local.",
                                    "Documente o código com comentários explicando o uso da static."
                                  ],
                                  "verification": "Programa executa corretamente, mantendo contagens persistentes sem usar globais, com comentários adequados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE completo",
                                    "Exemplos de código de referência"
                                  ],
                                  "tips": "Evite overuse; static é ideal para estado privado de função, não para dados compartilhados.",
                                  "learningObjective": "Integrar variáveis estáticas em cenários reais de programação.",
                                  "commonMistakes": [
                                    "Usar static em loops internos (torna loop dependente)",
                                    "Expor static via ponteiros acidentalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C: int contarChamadas() { static int contador = 0; contador++; return contador; } No main: printf(\"%d\\n\", contarChamadas()); //1 printf(\"%d\\n\", contarChamadas()); //2. Isso mantém o contador entre chamadas, útil para logs ou IDs sequenciais.",
                              "finalVerifications": [
                                "Código compila e executa sem warnings sobre variáveis não-inicializadas.",
                                "Valores persistem corretamente em pelo menos 10 chamadas consecutivas.",
                                "Comparação com versão não-static mostra reset de valores.",
                                "Diagrama de escopo/lifetime desenhado corretamente.",
                                "Programa prático usa static sem poluição global.",
                                "Comentários explicam o propósito da static."
                              ],
                              "assessmentCriteria": [
                                "Precisão na declaração e uso da keyword 'static' (obrigatório).",
                                "Demonstração clara de persistência via testes múltiplos (mínimo 5 chamadas).",
                                "Ausência de variáveis globais desnecessárias.",
                                "Explicação conceitual correta em relatório ou comentários.",
                                "Aplicação criativa em exemplo prático funcional.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Contadores cumulativos semelhantes a somas parciais em séries.",
                                "Física: Simulação de contadores em loops de tempo discreto (ex: ticks de relógio).",
                                "Estatística: Acumulação de dados em funções de amostragem repetida.",
                                "Banco de Dados: Conceito similar a variáveis de sessão persistentes."
                              ],
                              "realWorldApplication": "Em sistemas embarcados, contadores de falhas em funções de diagnóstico mantêm totais sem globais; em servidores web, geradores de IDs de sessão únicos por requisição; em jogos, placares privados por nível que persistem entre execuções."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.4",
                        "name": "Recursividade",
                        "description": "Chamada de função dentro de si mesma, casos base, pilha de chamadas e limitações práticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.4.1",
                            "name": "Entender recursão básica",
                            "description": "Explicar recursão com exemplos como fatorial ou Fibonacci, identificando caso base e chamada recursiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de recursão",
                                  "subSteps": [
                                    "Estude a definição: recursão é uma técnica onde uma função chama a si mesma para resolver subproblemas menores.",
                                    "Analise analogias práticas, como bonecas russas (cada uma contém uma menor) ou espelhos frente a frente (imagem infinita).",
                                    "Identifique os dois pilares: caso base (condição de parada) e chamada recursiva (chamada para si mesma).",
                                    "Discuta riscos: sem caso base, ocorre estouro de pilha (stack overflow).",
                                    "Escreva uma definição em suas próprias palavras."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é recursão, incluindo uma analogia e os riscos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre recursão (ex: YouTube - 'Recursão para Iniciantes')",
                                    "Papel e caneta para anotações",
                                    "Notebook para testes mentais"
                                  ],
                                  "tips": "Sempre pense em 'dividir para conquistar': problema grande vira problemas menores idênticos.",
                                  "learningObjective": "Dominar a definição e intuição de recursão como auto-referência controlada.",
                                  "commonMistakes": [
                                    "Confundir recursão com loops iterativos",
                                    "Ignorar a necessidade absoluta de um caso base",
                                    "Pensar que recursão é sempre mais eficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar componentes essenciais em funções recursivas",
                                  "subSteps": [
                                    "Analise estrutura genérica: if (caso_base) return valor; else return f(n-1) ou similar.",
                                    "Marque em pseudocódigo: destaque o 'caso base' e a 'chamada recursiva'.",
                                    "Compare com iteração: recursão usa pilha de chamadas, iteração usa loop.",
                                    "Desenhe o 'desenrolar' da recursão em uma árvore de chamadas.",
                                    "Identifique em exemplos simples, como soma de números de 1 a n."
                                  ],
                                  "verification": "Anote os componentes em um pseudocódigo dado e desenhe a árvore de chamadas para n=3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo impresso ou digital",
                                    "Ferramenta de desenho (ex: Draw.io ou papel)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Pense na recursão como uma pilha de pratos: cada chamada empilha, caso base desempilha.",
                                  "learningObjective": "Reconhecer e nomear caso base e chamada recursiva em qualquer função recursiva.",
                                  "commonMistakes": [
                                    "Não distinguir caso base de chamada recursiva",
                                    "Desenhar árvore de chamadas incorretamente",
                                    "Confundir profundidade de recursão com iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar recursão para cálculo de fatorial",
                                  "subSteps": [
                                    "Lembre fórmula: n! = n * (n-1)! , com 0! = 1 (caso base).",
                                    "Escreva função em Python: def fatorial(n): if n <= 1: return 1 else: return n * fatorial(n-1)",
                                    "Teste manualmente: trace fatorial(4) = 4*3*2*1*1 = 24.",
                                    "Execute no interpretador e verifique com função built-in math.factorial.",
                                    "Meça profundidade: para n=5, 5 chamadas."
                                  ],
                                  "verification": "Código roda corretamente para n=0 a 5, com trace escrito mostrando chamadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python instalado ou online (Replit/Google Colab)",
                                    "Documentação Python básica",
                                    "Papel para trace"
                                  ],
                                  "tips": "Sempre teste casos base primeiro: n=0 e n=1.",
                                  "learningObjective": "Codificar e debugar uma função recursiva clássica como fatorial.",
                                  "commonMistakes": [
                                    "Esquecer return no caso recursivo",
                                    "Usar n < 0 sem tratamento",
                                    "Loop infinito por erro no caso base"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar recursão em sequência de Fibonacci e sintetizar",
                                  "subSteps": [
                                    "Defina Fibonacci: fib(0)=0, fib(1)=1, fib(n)=fib(n-1)+fib(n-2).",
                                    "Implemente: def fib(n): if n <= 1: return n else: return fib(n-1) + fib(n-2)",
                                    "Trace fib(4): 3+2 = 3+(2+1)=3+(1+1)=3+2=5.",
                                    "Compare eficiência com fatorial: nota árvore exponencial.",
                                    "Explique quando usar recursão vs iteração."
                                  ],
                                  "verification": "Função fib(5) retorna 5, com trace completo e discussão de limitações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmo ambiente Python",
                                    "Gráfico de crescimento Fibonacci",
                                    "Calculadora para verificação"
                                  ],
                                  "tips": "Para Fibonacci simples, ok; para grandes n, use memoização (avançado).",
                                  "learningObjective": "Generalizar recursão para múltiplos exemplos e identificar limitações.",
                                  "commonMistakes": [
                                    "Caso base errado (fib(0) e fib(1))",
                                    "Não notar explosão de chamadas",
                                    "Confundir com fatorial"
                                  ]
                                }
                              ],
                              "practicalExample": "Cálculo de fatorial(5): fact(5) chama fact(4) → fact(3) → fact(2) → fact(1) = 1 → sobe: 2*1=2 → 3*2=6 → 4*6=24 → 5*24=120. Código Python: def fact(n): if n <= 1: return 1; return n * fact(n-1); print(fact(5)) # 120",
                              "finalVerifications": [
                                "Explica recursão sem hesitação, com analogia.",
                                "Identifica caso base e recursiva em código alheio.",
                                "Implementa fatorial e Fibonacci sem erros.",
                                "Traça chamadas para n=4 em ambos exemplos.",
                                "Discute risco de stack overflow.",
                                "Compara recursão com iteração em termos de pilha."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação conceitual (80% acerto).",
                                "Precisão na identificação de componentes (100% em exemplos).",
                                "Código funcional e trace correto (sem bugs).",
                                "Uso de analogias e visualizações eficazes.",
                                "Compreensão de limitações e quando evitar.",
                                "Criatividade em exemplos adicionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: sequências recursivas como Fibonacci em padrões naturais.",
                                "Biologia: modelagem de árvores genealógicas ou ramificações em plantas.",
                                "Linguística: gramáticas recursivas em análise sintática de frases.",
                                "Física: simulações de fractais como curvas de Koch.",
                                "Artes: geração procedural de padrões infinitos em design gráfico."
                              ],
                              "realWorldApplication": "Recursão é usada em parsing de estruturas hierárquicas como XML/JSON, travessia de árvores em sistemas de arquivos, algoritmos de divide-and-conquer (quick sort, merge sort), jogos (labirintos), e IA (busca em grafos para pathfinding)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.5.4.2",
                            "name": "Implementar função recursiva simples",
                            "description": "Codificar uma função recursiva para calcular fatorial ou potência, testando com entradas pequenas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da recursão",
                                  "subSteps": [
                                    "Defina recursão como uma função que chama a si mesma para resolver problemas menores.",
                                    "Identifique o 'caso base': condição que para a recursão (ex: n=0 ou n=1).",
                                    "Explique o 'caso recursivo': chama a função com entrada reduzida (ex: n-1).",
                                    "Desenhe um diagrama de pilha para fatorial(3): mostra chamadas aninhadas.",
                                    "Discuta o risco de recursão infinita sem caso base."
                                  ],
                                  "verification": "Crie um fluxograma ou pseudocódigo explicando caso base e recursivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                  "tips": "Sempre pergunte: 'Quando para?' para identificar o caso base.",
                                  "learningObjective": "Diferenciar caso base de caso recursivo em funções recursivas.",
                                  "commonMistakes": "Confundir recursão com iteração; esquecer que cada chamada usa memória na pilha."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a função recursiva para fatorial",
                                  "subSteps": [
                                    "Escreva pseudocódigo: se n == 0 ou n == 1, retorne 1; senão, retorne n * factorial(n-1).",
                                    "Calcule manualmente fatorial(3): 3*2*1 = 6, traçando chamadas.",
                                    "Defina restrições: entradas pequenas (n <= 10) para evitar estouro de pilha.",
                                    "Planeje testes: n=0 (1), n=1 (1), n=5 (120).",
                                    "Considere potência como variação: base^exp = base * base^(exp-1)."
                                  ],
                                  "verification": "Pseudocódigo cobre casos base e recursivo sem ambiguidades.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto para pseudocódigo",
                                  "tips": "Use indentação no pseudocódigo para visualizar profundidade recursiva.",
                                  "learningObjective": "Projetar lógica recursiva para problema matemático simples como fatorial.",
                                  "commonMistakes": "Esquecer multiplicação por n no caso recursivo; não tratar n=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a função em Python",
                                  "subSteps": [
                                    "Abra um editor Python e defina def factorial(n):.",
                                    "Implemente if n <= 1: return 1 else: return n * factorial(n-1).",
                                    "Adicione verificação de entrada: if n < 0: raise ValueError.",
                                    "Escreva função similar para potencia(base, exp).",
                                    "Salve como recursive_functions.py."
                                  ],
                                  "verification": "Execute factorial(0), factorial(1), factorial(5) no interpretador; resultados corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python 3 instalado, VS Code ou IDLE",
                                  "tips": "Teste incrementalmente: rode o caso base primeiro.",
                                  "learningObjective": "Codificar função recursiva funcional em Python.",
                                  "commonMistakes": "Erro de sintaxe em recursão (falta parênteses); usar loop em vez de recursão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a função",
                                  "subSteps": [
                                    "Crie script de testes: print(factorial(5) == 120), etc., para n=0 a 10.",
                                    "Monitore profundidade de recursão com print(n) em cada chamada.",
                                    "Teste potência: potencia(2,3) == 8.",
                                    "Depure erros: use debugger ou try-except para StackOverflowError.",
                                    "Documente limitações: recursão profunda causa OverflowError."
                                  ],
                                  "verification": "Todos os testes passam sem erros ou loops infinitos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Terminal Python para execução de testes",
                                  "tips": "Use assert para automação: assert factorial(5) == 120.",
                                  "learningObjective": "Validar e depurar funções recursivas com testes unitários.",
                                  "commonMistakes": "Testar apenas casos felizes; ignorar n negativo ou grande."
                                }
                              ],
                              "practicalExample": "Implemente def factorial(n): que calcula 5! = 120. Teste: print(factorial(5)) deve outputar 120. Varie para potencia(3,2) = 9.",
                              "finalVerifications": [
                                "factorial(0) retorna 1",
                                "factorial(5) retorna 120 sem erros",
                                "Nenhuma recursão infinita detectada em testes",
                                "Função lida com n=1 corretamente",
                                "Testes para potencia(base, exp) passam para entradas pequenas",
                                "Sem OverflowError para n<=10"
                              ],
                              "assessmentCriteria": [
                                "Caso base implementado corretamente",
                                "Chamada recursiva reduz problema adequadamente",
                                "Código executa sem erros para entradas válidas",
                                "Testes cobrem casos base, recursivos e limites",
                                "Documentação explica lógica recursiva",
                                "Eficiência conceitual: O(n) chamadas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de fatorial em combinatória",
                                "Algoritmos: Padrão divide-e-conquista",
                                "Estruturas de Dados: Simulação de pilha de chamadas",
                                "Lógica: Provas por indução matemática"
                              ],
                              "realWorldApplication": "Recursão para calcular combinações em jogos (ex: permutações), traversar estruturas hierárquicas como árvores de arquivos ou JSON, e algoritmos como Hanoi ou Fibonacci otimizado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.4.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.4.3",
                            "name": "Analisar profundidade de recursão",
                            "description": "Prever estouro de pilha em recursões profundas e converter para iterativa quando necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o mecanismo de pilha de chamadas na recursão",
                                  "subSteps": [
                                    "Estude o conceito de pilha de chamadas (call stack) em linguagens de programação.",
                                    "Visualize como cada chamada recursiva adiciona um frame à pilha.",
                                    "Analise um exemplo simples de recursão, como fatorial.",
                                    "Desenhe o estado da pilha para 5 chamadas iniciais.",
                                    "Compare com execução iterativa para destacar a diferença."
                                  ],
                                  "verification": "Desenhar e explicar um diagrama da pilha para fatorial(5).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (Python ou C++), papel e caneta para diagramas.",
                                  "tips": "Pense na pilha como uma pilha de pratos: cada chamada empilha um novo.",
                                  "learningObjective": "Entender como a recursão consome memória da pilha.",
                                  "commonMistakes": "Confundir ordem de execução (LIFO) com fila (FIFO)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a profundidade máxima de recursão",
                                  "subSteps": [
                                    "Identifique a profundidade teórica para funções recursivas lineares e em árvore.",
                                    "Implemente uma função auxiliar para medir profundidade atual durante execução.",
                                    "Teste com exemplos como Fibonacci recursivo e traversia de árvore binária.",
                                    "Calcule limite analítico: profundidade = altura da árvore ou n para linear.",
                                    "Registre a profundidade máxima alcançada em execuções controladas."
                                  ],
                                  "verification": "Implementar e executar código que imprima profundidade máxima para factorial(10).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "IDE com depurador (VS Code, PyCharm), linguagem com suporte a recursão (Python).",
                                  "tips": "Use um contador global ou parâmetro para rastrear profundidade.",
                                  "learningObjective": "Dominar cálculo preciso de profundidade recursiva.",
                                  "commonMistakes": "Ignorar overhead de chamadas ou confundir profundidade com número de chamadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar riscos de estouro de pilha (stack overflow)",
                                  "subSteps": [
                                    "Pesquise limites típicos de pilha em linguagens (ex: 1000 frames em Python).",
                                    "Execute recursões profundas até observar erro de stack overflow.",
                                    "Compare profundidade calculada com limite da plataforma.",
                                    "Analise fatores agravantes: tamanho do frame, otimização do compilador.",
                                    "Crie uma tabela de previsão: input vs. profundidade vs. risco."
                                  ],
                                  "verification": "Prever e demonstrar stack overflow para recursão de profundidade > 1000.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ambiente de execução com sys.setrecursionlimit() em Python, documentação de limites.",
                                  "tips": "Aumente limite temporariamente para testes, mas monitore memória.",
                                  "learningObjective": "Prever quando recursão falhará por overflow.",
                                  "commonMistakes": "Subestimar profundidade em recursões em árvore desbalanceadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Converter recursão para implementação iterativa",
                                  "subSteps": [
                                    "Escolha estratégia: pilha manual para simular recursão ou loop otimizado.",
                                    "Converta recursão linear (ex: fatorial) para loop simples.",
                                    "Converta recursão em árvore (ex: pré-ordem) usando pilha explícita.",
                                    "Teste equivalência: entradas iguais produzem saídas iguais.",
                                    "Meça performance: tempo e memória vs. recursiva."
                                  ],
                                  "verification": "Executar versão iterativa para input que causava overflow e confirmar sucesso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmos do step 2, mais ferramenta de profiling (timeit em Python).",
                                  "tips": "Mantenha ordem de processamento idêntica à recursiva.",
                                  "learningObjective": "Transformar recursão problemática em iteração eficiente.",
                                  "commonMistakes": "Perder casos-base ou alterar ordem de traversia."
                                }
                              ],
                              "practicalExample": "Implemente factorial recursivo e teste com n=10000 (causa stack overflow). Calcule profundidade (n chamadas), identifique risco, converta para loop iterativo: resultado = 1; for i in 1 to n: resultado *= i. Execute e compare.",
                              "finalVerifications": [
                                "Prever corretamente profundidade para Fibonacci(30) recursivo.",
                                "Detectar stack overflow em traversia de árvore de altura 2000.",
                                "Converter com sucesso fatorial(10000) para iterativo sem erro.",
                                "Verificar equivalência de saídas entre recursivo e iterativo.",
                                "Medir redução de uso de memória na versão iterativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de profundidade máxima (±5%).",
                                "Detecção correta de overflow em 90% dos casos testados.",
                                "Código iterativo funcional e equivalente à recursiva.",
                                "Explicação clara de trade-offs (leitura vs. performance).",
                                "Uso adequado de estruturas de dados para simulação de pilha.",
                                "Documentação de testes com inputs extremos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de complexidade em árvores e grafos recursivos.",
                                "Engenharia de Software: Otimização de algoritmos e gerenciamento de memória.",
                                "Ciência da Computação: Estruturas de dados (pilhas e filas).",
                                "Física Computacional: Simulações recursivas em fractais e caos."
                              ],
                              "realWorldApplication": "Em navegadores web, parsers de JSON/XML recursivos podem crashar em documentos grandes; conversão iterativa garante estabilidade em apps como editores de código ou processadores de dados em big data."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.4.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.6",
                    "name": "Ponteiros",
                    "description": "Conceito e uso de ponteiros em programação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.6.1",
                        "name": "Conceito Básico de Ponteiros",
                        "description": "Compreender o que são ponteiros, sua relação com endereços de memória e a diferença entre valor de uma variável e seu endereço.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.1.1",
                            "name": "Identificar o endereço de memória de uma variável",
                            "description": "Usar o operador de endereço (&) para obter e exibir o endereço de memória de variáveis escalares em linguagens como C ou C++, entendendo que ponteiros armazenam esses endereços.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de endereço de memória",
                                  "subSteps": [
                                    "Leia sobre a organização da memória RAM em computadores.",
                                    "Entenda que cada variável ocupa um endereço único na memória.",
                                    "Diferencie endereço de memória do valor armazenado na variável.",
                                    "Visualize a memória como uma rua com casas numeradas (endereços).",
                                    "Estude representação hexadecimal de endereços."
                                  ],
                                  "verification": "Explique em suas palavras o que é um endereço de memória e dê um exemplo analógico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação sobre memória em C (ex: tutorial online)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use analogias cotidianas para fixar o conceito.",
                                    "Desenhe um diagrama simples da memória."
                                  ],
                                  "learningObjective": "Compreender que variáveis têm endereços únicos na memória RAM.",
                                  "commonMistakes": [
                                    "Confundir endereço com o valor da variável.",
                                    "Achar que endereços são fixos entre execuções."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o operador de endereço (&)",
                                  "subSteps": [
                                    "Estude a sintaxe do operador & em C/C++.",
                                    "Veja exemplos de uso com variáveis int, char e float.",
                                    "Entenda que &var retorna o endereço da variável var.",
                                    "Diferencie & de * (futuramente ponteiros).",
                                    "Pratique mentalmente: &x para x=10."
                                  ],
                                  "verification": "Identifique corretamente o operador para obter endereço em um snippet de código dado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Referência da linguagem C (man page ou online)",
                                    "Exemplos de código básicos"
                                  ],
                                  "tips": [
                                    "Lembre: & é 'endereço de'.",
                                    "Não use & em constantes ou literais."
                                  ],
                                  "learningObjective": "Dominar a sintaxe e propósito do operador &.",
                                  "commonMistakes": [
                                    "Usar & em expressões aritméticas.",
                                    "Confundir com operador bitwise &."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar código para obter e exibir endereço",
                                  "subSteps": [
                                    "Crie um programa C simples declarando uma variável escalar.",
                                    "Use & para obter o endereço e armazene em um ponteiro.",
                                    "Inclua <stdio.h> e use printf com %p para exibir.",
                                    "Compile com gcc e execute no terminal.",
                                    "Observe a saída hexadecimal do endereço."
                                  ],
                                  "verification": "Execute o código e capture a saída mostrando um endereço válido (ex: 0x7ffd... ).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "Editor de texto (VS Code ou nano)",
                                    "Terminal Linux/Windows"
                                  ],
                                  "tips": [
                                    "Use (void*) para cast em printf se necessário.",
                                    "Execute múltiplas vezes para ver endereços variando."
                                  ],
                                  "learningObjective": "Escrever e executar código que exibe endereço de variável.",
                                  "commonMistakes": [
                                    "Esquecer #include <stdio.h>.",
                                    "Usar %x em vez de %p para ponteiros."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e conectar com ponteiros",
                                  "subSteps": [
                                    "Analise saídas de múltiplas execuções e variáveis.",
                                    "Declare um ponteiro e atribua &var a ele.",
                                    "Exiba *ptr para ver o valor via ponteiro.",
                                    "Compare endereço de ptr e &ptr.",
                                    "Documente observações em um relatório curto."
                                  ],
                                  "verification": "Explique a relação entre variável, seu endereço e ponteiro apontando para ele.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do step 3 expandido",
                                    "Papel ou documento para anotações"
                                  ],
                                  "tips": [
                                    "Endereços mudam por execução devido à ASLR.",
                                    "Ponteiro armazena endereço, não valor."
                                  ],
                                  "learningObjective": "Conectar operador & com conceito de ponteiros básicos.",
                                  "commonMistakes": [
                                    "Desreferenciar ponteiro nulo.",
                                    "Achar que endereço é previsível."
                                  ]
                                }
                              ],
                              "practicalExample": "Programa C: #include <stdio.h> int main() { int x = 42; int *ptr = &x; printf('Valor de x: %d\\n', x); printf('Endereço de x: %p\\n', &x); printf('Valor via ptr: %d\\n', *ptr); printf('Endereço de ptr: %p\\n', &ptr); return 0; } Saída exemplo: Valor: 42, Endereço: 0x7ffdee123456, etc.",
                              "finalVerifications": [
                                "Explicar diferença entre valor e endereço de uma variável.",
                                "Escrever código correto usando & e %p.",
                                "Executar programa e interpretar saída hexadecimal.",
                                "Identificar operador & em código fornecido.",
                                "Relacionar & com declaração de ponteiros.",
                                "Prever mudança de endereços entre execuções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação conceitual (80%+ correto).",
                                "Código compila e executa sem erros.",
                                "Interpretação correta da saída (endereços vs valores).",
                                "Uso adequado de %p e cast se necessário.",
                                "Identificação de pelo menos 3 erros comuns evitados.",
                                "Conexão clara com ponteiros básicos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas numéricos (hexadecimal).",
                                "Física: Conceitos de hardware e memória RAM.",
                                "Engenharia: Otimização de alocação de memória.",
                                "Lógica: Abstração de referências em programação funcional."
                              ],
                              "realWorldApplication": "Em debugging de software (ex: Valgrind para vazamentos), alocação dinâmica (malloc/free), sistemas embarcados (controle preciso de memória), jogos (gerenciamento de assets via ponteiros)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.2",
                            "name": "Diferenciar valor e endereço de uma variável",
                            "description": "Explicar conceitualmente a distinção entre o conteúdo (valor) de uma variável e seu local na memória (endereço), ilustrando com exemplos simples de declaração de variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de uma variável",
                                  "subSteps": [
                                    "Defina o que é uma variável em programação: um nome simbólico para um local na memória.",
                                    "Explique que o valor é o conteúdo armazenado nesse local.",
                                    "Discuta como declarar uma variável, ex: int numero = 10;",
                                    "Identifique que o valor pode mudar, mas o nome da variável permanece o mesmo.",
                                    "Reflita sobre por que usamos variáveis: para armazenar e manipular dados dinamicamente."
                                  ],
                                  "verification": "Explique em suas próprias palavras a diferença entre o nome da variável e seu valor, com um exemplo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Documentação de linguagem C ou similar"
                                  ],
                                  "tips": "Pense na variável como uma caixa etiquetada: a etiqueta é o nome, o conteúdo é o valor.",
                                  "learningObjective": "Entender que uma variável representa um espaço na memória que armazena um valor mutável.",
                                  "commonMistakes": [
                                    "Confundir o nome da variável com o valor armazenado",
                                    "Achar que variáveis são valores fixos como literais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o conceito de endereço de memória",
                                  "subSteps": [
                                    "Descreva a memória do computador como uma grande array de bytes, cada um com um endereço único.",
                                    "Explique que toda variável tem um endereço fixo alocado durante a execução.",
                                    "Use analogia: endereço como o número da casa, variável como o morador.",
                                    "Discuta como linguagens de programação gerenciam endereços automaticamente na maioria dos casos.",
                                    "Visualize um diagrama simples de memória com endereços e valores."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando uma variável com seu endereço e valor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Ferramenta online de visualização de memória (ex: Python Tutor)"
                                  ],
                                  "tips": "Lembre-se: o endereço é como um CEP único; não muda enquanto a variável existe.",
                                  "learningObjective": "Compreender que o endereço é a localização física na memória RAM.",
                                  "commonMistakes": [
                                    "Confundir endereço com o tamanho da variável",
                                    "Pensar que endereço muda quando valor muda"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar valor e endereço na prática",
                                  "subSteps": [
                                    "Escreva código para imprimir valor e endereço: int x = 42; printf(\"Valor: %d, Endereço: %p\", x, &x);",
                                    "Compile e execute o código, observando a saída (valor numérico vs. hexadecimal do endereço).",
                                    "Modifique o valor (x = 100;) e execute novamente, notando que endereço permanece igual.",
                                    "Compare saídas antes/depois para reforçar a distinção.",
                                    "Explique o operador & (endereço de) versus o valor direto."
                                  ],
                                  "verification": "Execute o código e descreva o que mudou (ou não) no endereço ao alterar o valor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C (GCC ou online como Replit)",
                                    "Terminal ou IDE"
                                  ],
                                  "tips": "Use %p para imprimir endereços; eles variam a cada execução devido à ASLR.",
                                  "learningObjective": "Distinguir conceitualmente e praticamente valor (conteúdo) de endereço (localização).",
                                  "commonMistakes": [
                                    "Interpretar endereço como um valor utilizável diretamente",
                                    "Esquecer o & para obter endereço"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reforçar com exercícios e analogias",
                                  "subSteps": [
                                    "Crie duas variáveis e imprima seus valores e endereços, comparando-os.",
                                    "Responda perguntas: 'O que acontece com o endereço se eu reatribuir a variável?'.",
                                    "Use analogia de biblioteca: livro (valor) em prateleira fixa (endereço).",
                                    "Discuta implicações para ponteiros (introdução breve).",
                                    "Registre observações em um relatório curto."
                                  ],
                                  "verification": "Responda corretamente a 3 perguntas sobre distinções observadas no código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo ambiente de código do step 3",
                                    "Folha de exercícios impressa"
                                  ],
                                  "tips": "Anote endereços reais de execuções para comparar; eles são únicos por run.",
                                  "learningObjective": "Aplicar a distinção em cenários práticos e fixar o conceito.",
                                  "commonMistakes": [
                                    "Achar que endereços próximos significam algo especial",
                                    "Ignorar que valores e endereços são tipos diferentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C: int idade = 25; printf(\"Idade (valor): %d\\n\", idade); printf(\"Endereço de idade: %p\\n\", &idade); Saída: Idade: 25, Endereço: 0x7ffd12345678. Alterar idade=30; endereço permanece o mesmo.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre valor e endereço sem hesitação.",
                                "Identificar corretamente valor e endereço em uma saída de printf.",
                                "Desenhar diagrama de memória com pelo menos duas variáveis.",
                                "Prever o que muda (valor) vs. não muda (endereço) em reatribuição.",
                                "Diferenciar operador & de acesso direto à variável.",
                                "Aplicar conceito a uma variável de tipo diferente (ex: char)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre valor e endereço (80% peso).",
                                "Uso correto de terminologia: 'endereço', 'memória', '&' operator.",
                                "Demonstração prática: código executado com saídas corretas.",
                                "Visualizações/diagramas: precisos e legíveis.",
                                "Respostas a verificações: todas corretas sem erros comuns.",
                                "Profundidade: inclui analogias e implicações para ponteiros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: endereços como coordenadas em um espaço unidimensional de memória.",
                                "Física: localização de partículas em um espaço (endereço) vs. propriedades (valor).",
                                "Banco de Dados: chaves primárias como identificadores únicos semelhantes a endereços.",
                                "Redes: endereços IP/MAC como locais lógicos/físicos para dados."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, ponteiros usam endereços para otimizar memória (ex: listas ligadas); em sistemas embarcados, gerenciamento manual de endereços evita vazamentos; em debugging, ferramentas como GDB inspecionam valores por endereço."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.3",
                            "name": "Reconhecer ponteiros como variáveis especiais",
                            "description": "Descrever ponteiros como variáveis que guardam endereços de outras variáveis, destacando sua importância para manipulação eficiente de memória em programação de baixo nível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender endereços de memória",
                                  "subSteps": [
                                    "Explicar o conceito de memória RAM como um conjunto de células endereçadas",
                                    "Demonstrar que cada variável ocupa uma ou mais células com endereços únicos",
                                    "Usar o operador & em uma linguagem como C para obter o endereço de uma variável",
                                    "Visualizar a memória como uma tabela com colunas de endereço e conteúdo",
                                    "Executar um código simples para imprimir o endereço de uma variável"
                                  ],
                                  "verification": "Executar código que imprime o endereço de uma variável e explicar o resultado",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C (ex: GCC)",
                                    "Editor de código (ex: VS Code)"
                                  ],
                                  "tips": "Pense na memória como uma rua: endereços são números das casas e valores são os moradores",
                                  "learningObjective": "Identificar e visualizar endereços de memória como identificadores únicos",
                                  "commonMistakes": [
                                    "Confundir o valor da variável com seu endereço",
                                    "Acreditar que endereços são fixos em todas as execuções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir ponteiros como variáveis especiais",
                                  "subSteps": [
                                    "Descrever ponteiro como uma variável que armazena o endereço de outra variável",
                                    "Comparar com variáveis normais: ponteiro guarda 'onde' está o dado, não o dado em si",
                                    "Explicar a notação * para declarar ponteiro (ex: int *p;)",
                                    "Discutir que ponteiros permitem acesso indireto à memória",
                                    "Realçar que ponteiros não são os dados, mas referências a eles"
                                  ],
                                  "verification": "Escrever uma definição escrita de ponteiro e diferenciá-lo de uma variável comum",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel para diagrama",
                                    "Documentação de C sobre ponteiros"
                                  ],
                                  "tips": "Desenhe setas: variável -> endereço -> ponteiro aponta para endereço",
                                  "learningObjective": "Reconhecer ponteiros como armazenadores de endereços",
                                  "commonMistakes": [
                                    "Tratar ponteiro como o valor da variável",
                                    "Esquecer o * na declaração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar e usar ponteiros básicos",
                                  "subSteps": [
                                    "Declarar uma variável inteira e um ponteiro para inteiro",
                                    "Atribuir o endereço da variável ao ponteiro usando &",
                                    "Acessar o valor apontado pelo ponteiro com *p",
                                    "Compilar e executar código para verificar endereço e valor",
                                    "Modificar o valor via ponteiro e observar mudança na variável original"
                                  ],
                                  "verification": "Executar código funcional que imprime endereço e valor via ponteiro",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente de programação C online (ex: Replit)",
                                    "Exemplos de código prontos"
                                  ],
                                  "tips": "Sempre inicialize ponteiros para evitar ponteiros selvagens (valores garbage)",
                                  "learningObjective": "Manipular ponteiros para acessar e modificar memória indiretamente",
                                  "commonMistakes": [
                                    "Usar ponteiro não inicializado",
                                    "Confundir & (endereço) com * (conteúdo)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender a importância para manipulação de memória",
                                  "subSteps": [
                                    "Explicar eficiência: ponteiros evitam cópias desnecessárias de dados grandes",
                                    "Discutir uso em programação de baixo nível (C/C++) para controle direto de memória",
                                    "Relacionar com alocação dinâmica (malloc/free)",
                                    "Comparar com linguagens high-level que abstraem ponteiros (Java, Python)",
                                    "Analisar riscos: dangling pointers e memory leaks"
                                  ],
                                  "verification": "Explicar em 3 frases por que ponteiros são cruciais em sistemas embarcados",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo curto sobre ponteiros em C (YouTube)",
                                    "Artigo sobre gerenciamento de memória"
                                  ],
                                  "tips": "Ponteiros são como GPS: te levam ao local exato dos dados",
                                  "learningObjective": "Justificar o uso de ponteiros para eficiência e controle de memória",
                                  "commonMistakes": [
                                    "Ignorar riscos de segurança como buffer overflow",
                                    "Subestimar complexidade em iniciantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C: int idade = 25; int *ptr = &idade; printf(\"Idade: %d (endereço: %p)\\n\", *ptr, ptr); // Saída: Idade: 25 (endereço: 0x7ffd12345678). Alterar *ptr = 30; muda idade para 30.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre uma variável e um ponteiro",
                                "Escrever código correto declarando e usando um ponteiro",
                                "Identificar o endereço e valor em uma saída de printf com ponteiro",
                                "Desenhar diagrama memória: variável, endereço e ponteiro",
                                "Listar 2 vantagens de ponteiros para memória",
                                "Detectar erro em código com ponteiro não inicializado"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ponteiro como armazenador de endereço",
                                "Correção na sintaxe de declaração e uso (& e *)",
                                "Compreensão de acesso indireto via *",
                                "Identificação de importância para eficiência de memória",
                                "Detecção de erros comuns como ponteiros nulos",
                                "Capacidade de diagramação conceitual"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: aritmética de ponteiros como operações em vetores e offsets",
                                "Arquitetura de Computadores: modelo von Neumann e acesso à memória",
                                "Física: representação binária de endereços em registradores",
                                "Engenharia: otimização de memória em sistemas embarcados",
                                "Lógica: abstrações de referências em programação funcional"
                              ],
                              "realWorldApplication": "Ponteiros são essenciais em C/C++ para estruturas de dados dinâmicas como listas ligadas em jogos (Unity engine), gerenciamento de memória em sistemas operacionais (Linux kernel) e processamento de imagens em software como Photoshop, permitindo alocação eficiente sem desperdício."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.2",
                        "name": "Declaração e Inicialização de Ponteiros",
                        "description": "Aprender a declarar, inicializar e operar com ponteiros usando operadores de referência (*) e endereço (&).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.2.1",
                            "name": "Declarar uma variável ponteiro",
                            "description": "Escrever a sintaxe correta para declarar ponteiros em C/C++, como 'int *p;', especificando o tipo de dado apontado e diferenciando de variáveis comuns.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de variáveis e memória",
                                  "subSteps": [
                                    "Explique o que é uma variável em C/C++ e seu papel em armazenar dados.",
                                    "Descreva como as variáveis ocupam espaço na memória com um endereço único.",
                                    "Identifique a diferença entre o valor da variável e seu endereço de memória.",
                                    "Use o operador & para obter o endereço de uma variável simples.",
                                    "Compile um código simples com printf para imprimir endereço de uma variável."
                                  ],
                                  "verification": "Escreva e compile um programa que declare uma variável int x = 10; e imprima seu endereço com &x.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C/C++ (GCC ou IDE como Code::Blocks)",
                                    "Editor de texto (VS Code)"
                                  ],
                                  "tips": [
                                    "Pense na memória como uma rua com casas numeradas; endereço é o número da casa.",
                                    "Sempre inicialize variáveis para evitar lixo na memória.",
                                    "Use hexadecimal para visualizar endereços (%p no printf)."
                                  ],
                                  "learningObjective": "Compreender a relação entre variáveis, valores e endereços de memória.",
                                  "commonMistakes": [
                                    "Confundir valor da variável com seu endereço.",
                                    "Esquecer de incluir <stdio.h> para printf.",
                                    "Não compilar antes de testar."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe básica de declaração de ponteiro",
                                  "subSteps": [
                                    "Estude a sintaxe geral: tipo_dado *nome_ponteiro; onde * indica ponteiro.",
                                    "Declare um ponteiro para inteiro: int *p; sem inicializar.",
                                    "Explique que o ponteiro armazena um endereço, não um valor diretamente.",
                                    "Diferencie int x; (variável) de int *p; (ponteiro para int).",
                                    "Anote exemplos para float *fptr; e double *dptr;."
                                  ],
                                  "verification": "Escreva 3 declarações de ponteiros para tipos diferentes sem erros de sintaxe.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Referência de sintaxe C/C++ (site cppreference.com)",
                                    "Bloco de notas para anotações"
                                  ],
                                  "tips": [
                                    "O * fica entre o tipo e o nome para clareza.",
                                    "Evite nomes confusos como 'int* p' vs 'int *p' – ambos funcionam, mas siga convenção.",
                                    "Ponteiro não aponta para nada até inicializado."
                                  ],
                                  "learningObjective": "Dominar a sintaxe exata para declarar um ponteiro especificando o tipo apontado.",
                                  "commonMistakes": [
                                    "Colocar * após o nome (int p*; inválido).",
                                    "Declarar sem tipo ( *p; erro).",
                                    "Confundir com arrays (int arr[5];)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar declaração em contexto de código",
                                  "subSteps": [
                                    "Crie um programa que declare uma variável int num = 42; e um ponteiro int *ptr;.",
                                    "Atribua o endereço: ptr = &num; usando operador &.",
                                    "Compile e execute para verificar sem erros.",
                                    "Declare ponteiros para char e string (char *str = \"Olá\";).",
                                    "Teste múltiplas declarações em um único escopo."
                                  ],
                                  "verification": "Compile um código com pelo menos 2 ponteiros declarados e atribuídos corretamente, sem warnings.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador online (repl.it ou ideone.com)",
                                    "Exemplos de código de referência"
                                  ],
                                  "tips": [
                                    "Sempre use const se o ponteiro não mudar.",
                                    "Verifique warnings do compilador como 'uninitialized'.",
                                    "Pratique com tipos primitivos primeiro."
                                  ],
                                  "learningObjective": "Aplicar declaração de ponteiros em códigos funcionais, diferenciando de variáveis comuns.",
                                  "commonMistakes": [
                                    "Atribuir valor direto ao ponteiro (ptr = 10; sem &).",
                                    "Esquecer ponto-e-vírgula após declaração.",
                                    "Misturar tipos (int* para float)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar ponteiros de variáveis comuns e verificar",
                                  "subSteps": [
                                    "Compare: int x = 5; (valor 5) vs int *p = &x; (endereço de x).",
                                    "Escreva um programa que imprima valor (*p), endereço (p) e endereço de x (&x).",
                                    "Identifique erros comuns em declarações mistas.",
                                    "Crie uma tabela comparativa: variável vs ponteiro (tamanho, uso, sintaxe).",
                                    "Teste desreferenciamento seguro com if (p != NULL)."
                                  ],
                                  "verification": "Explique oralmente ou por escrito a diferença e demonstre com código compilado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela comparativa",
                                    "Compilador para testes finais"
                                  ],
                                  "tips": [
                                    "Use *p para acessar o valor apontado (desreferenciamento).",
                                    "Ponteiros têm tamanho fixo (geralmente 8 bytes em 64-bit).",
                                    "Evite ponteiros dangling."
                                  ],
                                  "learningObjective": "Distinguir claramente ponteiros de variáveis comuns e validar declarações.",
                                  "commonMistakes": [
                                    "Tratar ponteiro como valor (* ausente).",
                                    "Ignorar NULL pointers.",
                                    "Confundir declaração com inicialização."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de gerenciamento de estoque, declare int estoque = 100; e int *ptrEstoque = &estoque; para permitir modificações eficientes via funções sem passar cópias.",
                              "finalVerifications": [
                                "Declara corretamente int *p; sem erros de sintaxe.",
                                "Diferencia ponteiro de variável comum em explicação escrita.",
                                "Compila código com múltiplos ponteiros para tipos variados.",
                                "Identifica o tipo apontado em qualquer declaração.",
                                "Usa & corretamente para atribuir endereço.",
                                "Evita erros comuns como inicialização direta."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa com * no local correto (100%).",
                                "Especificação clara do tipo de dado apontado.",
                                "Diferenciação explícita de variáveis normais.",
                                "Código compila sem warnings ou erros.",
                                "Exemplos práticos corretos e variados.",
                                "Compreensão conceitual via tabela ou diagrama."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços de memória como números hexadecimais e aritmética de ponteiros.",
                                "Física: Analogia de ponteiros com vetores de posição e referências espaciais.",
                                "Lógica de Programação: Abstração de referências e indireção em algoritmos.",
                                "Engenharia de Software: Gerenciamento de memória em sistemas embarcados."
                              ],
                              "realWorldApplication": "Ponteiros são fundamentais em linguagens de baixo nível para otimizar memória em jogos (acesso rápido a texturas), bancos de dados (estruturas ligadas) e sistemas operacionais (alocação dinâmica), permitindo eficiência sem cópias desnecessárias de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.2",
                            "name": "Inicializar ponteiro com endereço válido",
                            "description": "Atribuir um endereço de memória a um ponteiro usando '&variavel', evitando ponteiros nulos ou inválidos, e testar com printf para verificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar variável e ponteiro",
                                  "subSteps": [
                                    "Abra um editor de código e crie um arquivo .c novo.",
                                    "Declare uma variável inteira, ex: int numero = 42;",
                                    "Declare um ponteiro para inteiro, ex: int *ptr;",
                                    "Compile e execute um esboço básico para garantir que não há erros de sintaxe.",
                                    "Adicione um comentário explicando o papel de cada declaração."
                                  ],
                                  "verification": "O código compila sem erros e a variável é declarada corretamente sem warnings.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou similar)",
                                    "Compilador GCC",
                                    "Terminal"
                                  ],
                                  "tips": "Use typedef para tipos personalizados no futuro, mas foque em int* por agora.",
                                  "learningObjective": "Entender a sintaxe básica de declaração de variáveis e ponteiros em C.",
                                  "commonMistakes": [
                                    "Esquecer o asterisco (*) na declaração do ponteiro.",
                                    "Declarar ponteiro sem tipo compatível (ex: char* para int)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar ponteiro com endereço válido",
                                  "subSteps": [
                                    "Atribua um valor à variável declarada, ex: numero = 100;",
                                    "Inicialize o ponteiro com o endereço da variável usando '&', ex: ptr = &numero;",
                                    "Evite inicializações inválidas como ptr = NULL ou ptr = 0.",
                                    "Adicione printf(\"Endereço: %p\\n\", (void*)ptr); para visualizar o endereço.",
                                    "Compile e execute para confirmar a inicialização."
                                  ],
                                  "verification": "printf exibe um endereço de memória válido (não 0x0) e o código roda sem segmentation fault.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Sempre use (void*) ao imprimir %p para evitar warnings.",
                                  "learningObjective": "Dominar a sintaxe '&variavel' para obter endereços válidos e atribuí-los a ponteiros.",
                                  "commonMistakes": [
                                    "Usar ptr = numero em vez de &numero (atribui valor, não endereço).",
                                    "Inicializar com NULL sem verificação posterior."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Acessar e verificar valor via ponteiro",
                                  "subSteps": [
                                    "Use dereferência (*) para acessar o valor: printf(\"Valor: %d\\n\", *ptr);",
                                    "Modifique o valor via ponteiro: *ptr = 200;",
                                    "Imprima a variável original para confirmar alteração: printf(\"Numero: %d\\n\", numero);",
                                    "Execute e observe que numero agora é 200.",
                                    "Adicione verificação if(ptr != NULL) antes de dereferenciar."
                                  ],
                                  "verification": "Os prints mostram o valor correto (100 inicialmente, 200 após modificação) e numero reflete a mudança.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "Terminal"
                                  ],
                                  "tips": "Lembre-se: *ptr acessa o valor no endereço, ptr acessa o endereço.",
                                  "learningObjective": "Verificar funcionalidade de ponteiros inicializados corretamente com dereferência segura.",
                                  "commonMistakes": [
                                    "Dereferenciar ponteiro sem inicializar (causa undefined behavior).",
                                    "Confundir ptr com *ptr nos prints."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e evitar ponteiros inválidos",
                                  "subSteps": [
                                    "Crie um ponteiro não inicializado: int *ptrInvalido;",
                                    "Tente dereferenciar e compile com -Wall para ver warnings.",
                                    "Compare com versão válida e note diferenças em gdb ou valgrind.",
                                    "Implemente uma função para checar validade básica (não NULL).",
                                    "Documente lições em comentários no código."
                                  ],
                                  "verification": "Código com ponteiro inválido gera warning ou crash; versão válida roda limpa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC com flags -Wall -Wextra",
                                    "GDB ou Valgrind opcional"
                                  ],
                                  "tips": "Use ferramentas como Valgrind para detectar acessos inválidos em runtime.",
                                  "learningObjective": "Identificar e evitar ponteiros nulos ou não inicializados através de testes.",
                                  "commonMistakes": [
                                    "Ignorar warnings do compilador sobre variáveis não inicializadas.",
                                    "Assumir que ponteiro local é automaticamente válido."
                                  ]
                                }
                              ],
                              "practicalExample": "int main() {\n    int numero = 42;\n    int *ptr = &numero;  // Inicialização válida\n    printf(\"Endereco: %p, Valor: %d\\n\", (void*)ptr, *ptr);\n    *ptr = 100;\n    printf(\"Novo valor de numero: %d\\n\", numero);\n    return 0;\n}\n// Saída esperada: Endereço válido, 42, depois 100",
                              "finalVerifications": [
                                "Programa compila sem warnings sobre ponteiros não inicializados.",
                                "printf exibe endereço válido (não NULL) e valor correto da variável.",
                                "Modificação via *ptr altera a variável original.",
                                "Teste com ponteiro NULL gera erro ou é evitado por checagem.",
                                "Valgrind (se usado) reporta no leaks ou invalid reads.",
                                "Código roda consistentemente em múltiplas execuções."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta de '&variavel' para inicialização.",
                                "Uso seguro de dereferência com verificação NULL.",
                                "Compreensão demonstrada via modificação indireta.",
                                "Identificação de erros comuns em testes inválidos.",
                                "Código limpo com comentários explicativos.",
                                "Execução sem crashes ou undefined behavior."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços de memória como coordenadas em um espaço numérico.",
                                "Física: Analogia de ponteiro como 'apontador' para localização de partículas.",
                                "Lógica: Conceitos de referência e indireção semelhantes a funções compostas.",
                                "Engenharia: Gerenciamento de recursos limitados como memória RAM."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, ponteiros inicializados corretamente são essenciais para estruturas dinâmicas como listas ligadas em bancos de dados, alocação dinâmica em jogos (ex: Unity com C++), e sistemas operacionais para gerenciamento de processos sem vazamentos de memória."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.6.2.3",
                            "name": "Acessar valor indireto via ponteiro",
                            "description": "Utilizar o operador de dereferência (*) para acessar e modificar o valor armazenado no endereço apontado por um ponteiro, com exemplos de leitura e escrita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Dereferência",
                                  "subSteps": [
                                    "Revise a declaração de um ponteiro: int *ptr;",
                                    "Entenda que & obtém o endereço de uma variável, e ptr recebe esse endereço via ptr = &var;",
                                    "Aprenda que *ptr acessa o conteúdo no endereço armazenado em ptr, não o endereço em si",
                                    "Diferencie ptr (endereço) de *ptr (valor indireto)",
                                    "Visualize com diagrama mental: variável -> endereço -> ponteiro -> * desvia para valor"
                                  ],
                                  "verification": "Explique em voz alta ou anote a diferença entre ptr e *ptr com um exemplo simples",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto, papel para diagramas, documentação de C sobre ponteiros",
                                  "tips": "Sempre pense em * como 'vá ao endereço e pegue/modifique o valor lá'",
                                  "learningObjective": "Diferenciar endereço de ponteiro do valor dereferenciado",
                                  "commonMistakes": "Confundir * na declaração (tipo) com * na dereferência (uso)"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ler Valor Indireto via Ponteiro",
                                  "subSteps": [
                                    "Declare uma variável inteira: int num = 42;",
                                    "Crie ponteiro e aponte: int *ptr = &num;",
                                    "Use printf para imprimir *ptr e confirme que mostra 42",
                                    "Compare com printf de num e &num para validar",
                                    "Teste com múltiplas variáveis para reforçar"
                                  ],
                                  "verification": "Programa compila e imprime o valor correto da variável via *ptr",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Compilador C (GCC), terminal para compilar e executar",
                                  "tips": "Use %d para inteiros; teste com valores variados como negativos ou zero",
                                  "learningObjective": "Implementar leitura segura de valores via operador *",
                                  "commonMistakes": "Esquecer de inicializar ponteiro, causando garbage values"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar Valor Indireto via Ponteiro",
                                  "subSteps": [
                                    "Inicie com setup similar: int num = 10; int *ptr = &num;",
                                    "Modifique via ponteiro: *ptr = 100;",
                                    "Imprima num e *ptr para ver mudança propagada",
                                    "Teste atribuição de variáveis: *ptr = outra_var;",
                                    "Experimente em função: passe ponteiro e modifique original"
                                  ],
                                  "verification": "Valor da variável original muda após *ptr = novo_valor",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador C, debugger simples como gdb",
                                  "tips": "Lembre: ponteiro modifica o original, não uma cópia",
                                  "learningObjective": "Usar * para escrita indireta e entender passagem por referência",
                                  "commonMistakes": "Modificar ponteiro (ptr = ...) em vez de dereferenciar (*ptr = ...)"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Depurar Acessos via Ponteiro",
                                  "subSteps": [
                                    "Escreva função swap usando ponteiros para trocar valores",
                                    "Introduza ponteiro NULL e teste *ptr (deve crash, aprenda segfault)",
                                    "Use printf para debug: imprima ptr, *ptr, &var em cada etapa",
                                    "Crie array de ponteiros e acesse elementos via *",
                                    "Compile com warnings (-Wall) e corrija issues"
                                  ],
                                  "verification": "Função swap funciona; programa lida com NULL sem crash indefinido",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C com flags de warning, debugger gdb",
                                  "tips": "Sempre cheque if (ptr != NULL) antes de *ptr",
                                  "learningObjective": "Aplicar dereferência em cenários reais com depuração",
                                  "commonMistakes": "Dereferenciar ponteiro não inicializado ou NULL"
                                }
                              ],
                              "practicalExample": "int main() { int x = 5; int *p = &x; printf('Valor direto: %d\\n', x); printf('Via ponteiro: %d\\n', *p); *p = 10; printf('Modificado: %d\\n', x); return 0; } // Saída: 5, 5, 10",
                              "finalVerifications": [
                                "Programa compila sem warnings sobre ponteiros não inicializados",
                                "Leitura via *ptr retorna valor exato da variável",
                                "Modificação via *ptr altera a variável original",
                                "Não há segfaults ou garbage em execuções múltiplas",
                                "Função de swap via ponteiros troca valores corretamente",
                                "Debugger mostra endereços e valores consistentes"
                              ],
                              "assessmentCriteria": [
                                "Correta distinção entre ptr e *ptr em explicações (80%)",
                                "Códigos funcionam sem erros de dereferência (100%)",
                                "Exemplos incluem leitura e escrita indireta (completo)",
                                "Tratamento de casos edge como NULL (avançado)",
                                "Eficiência: código limpo, sem leaks óbvios",
                                "Compreensão demonstrada em testes práticos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como funções de mapeamento (funções hash básicas)",
                                "Algoritmos: Base para linked lists e árvores dinâmicas",
                                "Engenharia de Software: Gerenciamento de memória dinâmica",
                                "Física Computacional: Modelagem de partículas via ponteiros para structs"
                              ],
                              "realWorldApplication": "Em sistemas embarcados, ponteiros dereferenciados otimizam acesso a sensores (ex: modificar leituras de temperatura em tempo real); em jogos, para manipular posições de objetos dinamicamente sem copiar dados pesados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.2.1",
                              "10.1.2.6.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.3",
                        "name": "Uso de Ponteiros em Funções",
                        "description": "Aplicar ponteiros para passagem de parâmetros por referência em subprogramas, permitindo modificação de variáveis originais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.3.1",
                            "name": "Passar ponteiros como parâmetros para funções",
                            "description": "Implementar funções que recebem ponteiros como argumentos, comparando com passagem por valor e demonstrando como ponteiros permitem alterações no escopo chamador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Passagem por Valor e Introduzir Ponteiros como Parâmetros",
                                  "subSteps": [
                                    "Explique o conceito de passagem por valor: cópia da variável é passada, alterações não afetam original.",
                                    "Discuta limitações: funções não podem modificar variáveis do chamador.",
                                    "Introduza ponteiros como parâmetros: endereço da variável é passado, permitindo acesso direto à memória original.",
                                    "Escreva um exemplo simples de função que recebe int* e imprime o valor dereferenciado."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre passagem por valor e por ponteiro, com exemplo de código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Code::Blocks)",
                                    "Compilador GCC",
                                    "Documentação de C sobre ponteiros"
                                  ],
                                  "tips": "Sempre use * para declarar parâmetro ponteiro e & para passar endereço.",
                                  "learningObjective": "Compreender por que ponteiros são necessários para modificar dados no escopo chamador.",
                                  "commonMistakes": [
                                    "Confundir & (endereço) com * (dereferência)",
                                    "Esquecer de dereferenciar o ponteiro dentro da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e Definir Funções com Parâmetros Ponteiro",
                                  "subSteps": [
                                    "Declare uma função prototype: void modificarValor(int *ptr);",
                                    "Defina a função: use *ptr para acessar e alterar o valor.",
                                    "No main, declare variáveis, passe &variavel para a função.",
                                    "Compile e execute para verificar declaração correta."
                                  ],
                                  "verification": "Código compila sem erros de sintaxe relacionados a ponteiros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "Terminal para compilar (gcc arquivo.c -o exec)"
                                  ],
                                  "tips": "Use typedef para tipos ponteiro complexos, mas comece simples com int*.",
                                  "learningObjective": "Dominar sintaxe para funções que recebem ponteiros como argumentos.",
                                  "commonMistakes": [
                                    "Declarar função como int* ptr sem void retorno se não necessário",
                                    "Passar variável sem & no chamador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Função que Modifica Dados via Ponteiro",
                                  "subSteps": [
                                    "Crie função swap(int *a, int *b): dereferencie ambos e troque valores.",
                                    "No main, inicialize duas variáveis, chame swap(&x, &y), imprima antes/depois.",
                                    "Adicione função incremento(int *valor): *valor += 10;",
                                    "Teste chamando incremento(&numero) e verifique alteração."
                                  ],
                                  "verification": "Valores são alterados corretamente após chamada da função, comprovado por printf.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com debugger (CLion ou VS Code com C/C++ extension)",
                                    "Exemplos de código de referência"
                                  ],
                                  "tips": "Use printf(\"%p\", ptr) para visualizar endereços e confirmar passagem correta.",
                                  "learningObjective": "Implementar funções que alteram dados originais usando ponteiros.",
                                  "commonMistakes": [
                                    "Dereferenciar ponteiro nulo ou inválido causando segfault",
                                    "Esquecer asterisco em *a = *b no swap"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Comportamentos e Aplicar em Cenário Complexo",
                                  "subSteps": [
                                    "Implemente swap por valor e compare: crie void swapValor(int a, int b).",
                                    "Chame ambas versões e mostre diferenças nos outputs.",
                                    "Estenda para array: void dobrarArray(int *arr, int size) modificando elementos.",
                                    "Teste com array de 5 ints, imprima antes/depois."
                                  ],
                                  "verification": "Outputs mostram que por valor não altera, por ponteiro altera; array dobrado corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Debugger para inspecionar memória",
                                    "Referências online: GeeksforGeeks Ponteiros em C"
                                  ],
                                  "tips": "Evite aritmética de ponteiros aqui; foque em parâmetros simples.",
                                  "learningObjective": "Comparar passagem por valor vs ponteiro e aplicar em estruturas como arrays.",
                                  "commonMistakes": [
                                    "Modificar cópia em vez de original por erro de sintaxe",
                                    "Off-by-one em loops de array com ponteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Debugar e Otimizar Uso de Ponteiros em Funções",
                                  "subSteps": [
                                    "Introduza verificação de ponteiro nulo: if(ptr == NULL) return;",
                                    "Adicione const int* para parâmetros de leitura apenas.",
                                    "Teste cenários de erro: passe NULL, verifique handling.",
                                    "Otimize: use ponteiros para evitar cópias em structs grandes."
                                  ],
                                  "verification": "Programa roda sem crashes, lida com NULL, const previne alterações indevidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Valgrind para detectar memory leaks (opcional)",
                                    "Documentação const correctness"
                                  ],
                                  "tips": "Sempre valide ponteiros antes de dereferenciar.",
                                  "learningObjective": "Aplicar boas práticas de segurança e otimização com ponteiros.",
                                  "commonMistakes": [
                                    "Não checar NULL levando a segmentation fault",
                                    "Usar ponteiro não-const em dados imutáveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma função void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; }. No main: int x=5, y=10; printf(\"Antes: %d %d\\n\", x,y); swap(&x,&y); printf(\"Depois: %d %d\\n\", x,y); // Saída: Depois: 10 5. Compare com versão por valor que não altera.",
                              "finalVerifications": [
                                "Código compila e executa sem erros ou warnings.",
                                "Funções por ponteiro modificam variáveis originais corretamente.",
                                "Funções por valor não alteram dados do chamador.",
                                "Testes com arrays mostram modificações in-place.",
                                "Tratamento de ponteiro NULL previne crashes.",
                                "Uso de const em parâmetros de leitura funciona."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: ponteiros declarados e usados adequadamente (30%).",
                                "Funcionalidade: alterações via ponteiro ocorrem, por valor não (30%).",
                                "Comparação explícita demonstrada em código e output (15%).",
                                "Boas práticas: validação NULL, const correctness (15%).",
                                "Clareza: comentários explicando diferenças (5%).",
                                "Eficiência: sem cópias desnecessárias (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética de ponteiros como operações em endereços (multiplicação por sizeof).",
                                "Física: Analogia de ponteiros com endereços físicos na memória RAM.",
                                "Inglês: Documentar funções com comentários em inglês padrão.",
                                "Lógica: Raciocínio sobre escopos e referências indiretas."
                              ],
                              "realWorldApplication": "Em algoritmos de ordenação como quicksort, ponteiros permitem swaps in-place em arrays grandes sem copiar dados, otimizando memória e performance em aplicações como bancos de dados e jogos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.2.3"
                            ]
                          },
                          {
                            "id": "10.1.2.6.3.2",
                            "name": "Modificar variáveis via ponteiros em funções",
                            "description": "Criar exemplos de funções que alteram valores de variáveis passadas por referência usando ponteiros, como troca de valores entre duas variáveis (swap).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Ponteiros e Passagem por Referência",
                                  "subSteps": [
                                    "Explicar o que é um ponteiro: variável que armazena endereço de memória.",
                                    "Diferenciar passagem por valor (cópia) de passagem por referência (endereço).",
                                    "Aprender sintaxe: declaração (int *p), operador endereço (&var) e dereferência (*p).",
                                    "Criar código simples para imprimir endereço e valor de uma variável.",
                                    "Executar e observar diferenças na memória."
                                  ],
                                  "verification": "Escrever e executar um programa que imprime endereço e valor de uma variável antes e após alteração via ponteiro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C (GCC ou online como Replit)",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Use %p para imprimir endereços e compare com valores para visualizar indireção.",
                                  "learningObjective": "Dominar fundamentos de ponteiros para modificação indireta de variáveis.",
                                  "commonMistakes": [
                                    "Confundir & (endereço) com * (valor no endereço)",
                                    "Esquecer de inicializar ponteiro, causando dereferência nula"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e Definir Função com Parâmetros Ponteiro",
                                  "subSteps": [
                                    "Escrever protótipo de função: void modificar(int *p, int novoValor).",
                                    "Implementar corpo: *p = novoValor; para alterar valor original.",
                                    "Chamar função no main: modificar(&var, 100);",
                                    "Adicionar prints para verificar mudança fora da função.",
                                    "Compilar e testar com diferentes valores."
                                  ],
                                  "verification": "Programa altera valor de variável no main via função e imprime confirmação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de código"
                                  ],
                                  "tips": "Sempre passe & para enviar endereço; use * dentro da função para acessar.",
                                  "learningObjective": "Criar funções que modificam variáveis externas via ponteiros.",
                                  "commonMistakes": [
                                    "Passar variável sem & (passagem por valor não altera original)",
                                    "Falta de * na atribuição dentro da função"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Função de Troca (Swap) Usando Ponteiros",
                                  "subSteps": [
                                    "Declarar função: void swap(int *a, int *b).",
                                    "Criar variável temporária: int temp = *a;.",
                                    "Trocar valores: *a = *b; *b = temp;.",
                                    "Integrar no main com duas variáveis e prints antes/depois.",
                                    "Testar com valores iniciais diferentes."
                                  ],
                                  "verification": "Executar programa e confirmar que valores foram trocados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de código"
                                  ],
                                  "tips": "Visualize fluxograma: temp guarda A, A recebe B, B recebe temp.",
                                  "learningObjective": "Desenvolver função swap eficiente sem retornar múltiplos valores.",
                                  "commonMistakes": [
                                    "Esquecer temp, causando perda de dados",
                                    "Usar swap por valor (não funciona)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Expandir a Função Swap",
                                  "subSteps": [
                                    "Adicionar testes com variáveis negativas ou zero.",
                                    "Usar debugger (gdb) para inspecionar endereços e valores passo a passo.",
                                    "Expandir para swap de floats ou structs simples.",
                                    "Escrever comentários explicando cada uso de * e &.",
                                    "Compilar com warnings (-Wall) e corrigir."
                                  ],
                                  "verification": "Todos testes passam; explicar depuração em relatório curto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador C com gdb",
                                    "Editor com suporte a debug"
                                  ],
                                  "tips": "Use assert() para validações automáticas em testes.",
                                  "learningObjective": "Garantir robustez e compreensão profunda via testes.",
                                  "commonMistakes": [
                                    "Não testar edge cases como valores iguais",
                                    "Ignorar warnings do compilador"
                                  ]
                                }
                              ],
                              "practicalExample": "#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 10, y = 20;\n    printf(\"Antes: x=%d (endereço: %p), y=%d (endereço: %p)\\n\", x, &x, y, &y);\n    swap(&x, &y);\n    printf(\"Depois: x=%d, y=%d\\n\", x, y);\n    return 0;\n}\n/* Saída esperada: valores trocados, endereços iguais. */",
                              "finalVerifications": [
                                "Programa compila sem erros ou warnings.",
                                "Valores das variáveis são efetivamente trocados após swap.",
                                "Endereços permanecem os mesmos antes/depois.",
                                "Explicação oral/escrita correta do mecanismo de ponteiros.",
                                "Testes com múltiplos pares de valores passam.",
                                "Função funciona com tipos diferentes (ex: float)."
                              ],
                              "assessmentCriteria": [
                                "Correta sintaxe de ponteiros em parâmetros e dereferência.",
                                "Lógica de swap sem perda de dados (uso de temp).",
                                "Chamada da função com & no main.",
                                "Saídas de teste confirmam modificação por referência.",
                                "Código comentado e limpo, sem vazamentos.",
                                "Capacidade de debugar e explicar erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de endereços como operações aritméticas (aritmética de ponteiros).",
                                "Algoritmos: Otimização de passagem de parâmetros para estruturas grandes.",
                                "Engenharia de Software: Gerenciamento eficiente de memória em sistemas embarcados.",
                                "Física: Analogia de ponteiros com referências a locais físicos na memória RAM."
                              ],
                              "realWorldApplication": "Essa técnica é crucial em kernels de SO (ex: Linux para swap de páginas), jogos (troca de buffers de vídeo sem cópia), bibliotecas gráficas (manipulação de texturas) e bancos de dados (atualização de registros sem duplicação de dados)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Comandos de Linguagem Procedimental",
                "description": "Cobre comandos essenciais como atribuição, entrada e saída, estruturas condicionais, repetitivas e seletivas.",
                "totalSkills": 42,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Comando de Atribuição",
                    "description": "Atribuição de valores a variáveis em linguagens procedimentais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Variáveis e sua Declaração",
                        "description": "Compreender o conceito de variáveis como armazenadores de dados e a necessidade de declará-las antes da atribuição em linguagens procedimentais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Identificar o propósito de uma variável",
                            "description": "Explicar que variáveis são espaços na memória para armazenar valores mutáveis, diferenciando-as de constantes, com exemplos em pseudocódigo ou C.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de memória e armazenamento de dados",
                                  "subSteps": [
                                    "Estude o que é memória de um computador: um espaço temporário para guardar dados durante a execução de um programa.",
                                    "Aprenda que programas precisam armazenar valores que mudam, como contadores ou resultados de cálculos.",
                                    "Visualize a memória como caixas numeradas onde cada caixa pode guardar um valor.",
                                    "Entenda que sem armazenamento, o programa não conseguiria reter informações entre instruções.",
                                    "Pratique desenhando um diagrama simples de memória com posições e valores."
                                  ],
                                  "verification": "Desenhe um diagrama da memória mostrando pelo menos 3 posições com valores diferentes e explique verbalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeo introdutório sobre memória de computador (ex: Khan Academy)"
                                  ],
                                  "tips": "Pense na memória como uma geladeira: cada prateleira guarda algo que você pode trocar depois.",
                                  "learningObjective": "Identificar a memória como repositório dinâmico de dados em um programa.",
                                  "commonMistakes": [
                                    "Confundir memória com disco rígido (persistente vs temporário)",
                                    "Achar que memória é infinita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar variáveis de constantes",
                                  "subSteps": [
                                    "Defina variável: espaço na memória cujo valor pode ser alterado durante a execução.",
                                    "Defina constante: espaço na memória cujo valor é fixo e não muda após definição.",
                                    "Compare: variáveis para dados mutáveis (ex: idade de uma pessoa que aumenta), constantes para dados imutáveis (ex: PI = 3.14).",
                                    "Crie uma tabela comparativa com colunas: Nome, Mutável?, Exemplo.",
                                    "Discuta por que usar constantes evita erros em valores fixos."
                                  ],
                                  "verification": "Crie uma tabela comparando 3 variáveis e 3 constantes com exemplos reais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Documentação básica de linguagens como C"
                                  ],
                                  "tips": "Lembre: 'variável' vem de 'variar', muda; 'constante' é sempre a mesma.",
                                  "learningObjective": "Distinguir claramente o propósito mutável das variáveis versus fixo das constantes.",
                                  "commonMistakes": [
                                    "Usar variável para valor fixo (ex: definir PI como variável)",
                                    "Achar que todas as declarações são variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos em pseudocódigo",
                                  "subSteps": [
                                    "Escreva pseudocódigo simples: idadesoma ← 0; idadesoma ← idadesoma + 25.",
                                    "Identifique: idadesoma é variável porque seu valor muda (propósito: acumular soma).",
                                    "Outro exemplo: PI ← 3.14; (constante, propósito: valor fixo matemático).",
                                    "Trace a execução passo a passo, mostrando mudanças na memória.",
                                    "Crie seu próprio pseudocódigo com 2 variáveis e 1 constante, identificando propósitos."
                                  ],
                                  "verification": "Explique o propósito de cada identificador no seu pseudocódigo traçado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Folha para tracing de execução"
                                  ],
                                  "tips": "Use setas para mostrar como o valor 'flui' para a memória da variável.",
                                  "learningObjective": "Reconhecer o propósito de variáveis em fluxos de pseudocódigo.",
                                  "commonMistakes": [
                                    "Não notar a seta de atribuição indicando mutabilidade",
                                    "Confundir nome da variável com seu valor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar conceitos em código C e identificar propósitos",
                                  "subSteps": [
                                    "Compile e execute código C: int contador = 0; contador = contador + 1; (propósito: contar iterações).",
                                    "Compare com const float PI = 3.14; (propósito: referência fixa).",
                                    "Modifique o código trocando variável por constante e observe erro lógico.",
                                    "Analise código real: identifique variáveis como 'saldo' em banco (mutável) vs 'taxa' (constante).",
                                    "Escreva um programa C curto usando 3 variáveis, declarando seus propósitos em comentários."
                                  ],
                                  "verification": "Execute seu programa C e liste o propósito de cada variável usada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador C online (ex: Replit, CodeBlocks)",
                                    "Exemplos de código C básicos"
                                  ],
                                  "tips": "Sempre pergunte: 'Este valor precisa mudar? Se sim, variável; senão, constante.'",
                                  "learningObjective": "Identificar propósitos de variáveis em sintaxe real de C.",
                                  "commonMistakes": [
                                    "Esquecer #include e int main()",
                                    "Não inicializar variáveis levando a lixo na memória"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de calculadora simples em C: int resultado = 0; resultado = 5 + 3; printf('%d', resultado); Aqui, 'resultado' é uma variável cujo propósito é armazenar o valor mutável do cálculo para exibição posterior.",
                              "finalVerifications": [
                                "Explicar verbalmente o que é uma variável e dê 2 exemplos de propósitos.",
                                "Diferenciar variável de constante com um exemplo de cada em pseudocódigo.",
                                "Trace a execução de um código C simples identificando mudanças em variáveis.",
                                "Criar um diagrama de memória para um programa com 3 variáveis.",
                                "Identificar incorretamente uma constante como variável em um código dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de variável como espaço mutável na memória (100%).",
                                "Correta diferenciação de variáveis vs constantes com exemplos (90%).",
                                "Capacidade de tracing e identificação de propósitos em pseudocódigo/C (85%).",
                                "Uso correto de termos técnicos como 'declaração', 'atribuição' (80%).",
                                "Criatividade em exemplos práticos e diagramas claros (75%).",
                                "Ausência de confusões comuns como mutabilidade errada (70%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Variáveis como incógnitas em equações algébricas.",
                                "Física: Modelagem de grandezas mutáveis como posição ou velocidade em simulações.",
                                "Lógica: Propósitos semelhantes a placeholders em raciocínio dedutivo.",
                                "Português: Analogia com substantivos próprios (constantes) vs comuns (variáveis)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps bancários, variáveis como 'saldoConta' armazenam valores mutáveis atualizados por transações, enquanto constantes como 'taxaJurosAnual' mantêm valores fixos para cálculos consistentes, evitando erros em sistemas financeiros reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Declarar variáveis com tipos escalares",
                            "description": "Escrever declarações corretas de variáveis inteiras, reais e lógicas, especificando o tipo de dado conforme convenções de linguagens procedimentais como C ou Pascal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Tipos Esculares Básicos",
                                  "subSteps": [
                                    "Estude a definição de tipo inteiro (int): números inteiros como 5, -3, sem decimais.",
                                    "Aprenda tipo real (real/float): números com decimais como 3.14, -2.5.",
                                    "Entenda tipo lógico (boolean/logical): valores true/false ou verdadeiro/falso.",
                                    "Compare tamanhos e usos: int para contagens, real para medidas, lógico para condições.",
                                    "Revise convenções: Pascal usa 'integer', 'real', 'boolean'; C usa 'int', 'float', 'bool'."
                                  ],
                                  "verification": "Liste corretamente 3 exemplos de cada tipo sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de Pascal e C (online ou PDF), caderno de anotações.",
                                  "tips": "Use mnemônicos: INT para Inteiros, REAL para decimais reais, BOOL para Verdadeiro/Falso.",
                                  "learningObjective": "Identificar e diferenciar tipos escalares por uso e representação.",
                                  "commonMistakes": "Confundir real com inteiro (ex: 3.0 como int); ignorar que lógicos não são strings."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Sintaxe de Declaração em Pascal",
                                  "subSteps": [
                                    "Escreva declaração de variável única: var nome: tipo; (ex: var idade: integer;).",
                                    "Declare múltiplas variáveis: var nome1, nome2: tipo;.",
                                    "Pratique com tipos: var pi: real; var ativo: boolean;.",
                                    "Posicione corretamente na seção 'var' antes do 'begin'.",
                                    "Teste em um editor: compile um snippet simples."
                                  ],
                                  "verification": "Compile um programa Pascal com 3 declarações sem erros de sintaxe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor como Free Pascal Online ou Lazarus IDE.",
                                  "tips": "Sempre termine com ';' e use letras minúsculas para nomes de variáveis.",
                                  "learningObjective": "Escrever declarações válidas seguindo sintaxe exata de Pascal.",
                                  "commonMistakes": "Esquecer ';' após declaração; usar ':' em vez de '=' para inicialização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Sintaxe de Declaração em C",
                                  "subSteps": [
                                    "Escreva declaração: tipo nome; (ex: int idade;).",
                                    "Declare e inicialize: tipo nome = valor; (ex: float pi = 3.14;).",
                                    "Use múltiplas: int a, b; bool ativo = true;.",
                                    "Posicione no início da função (ex: main).",
                                    "Compile com gcc para verificar."
                                  ],
                                  "verification": "Compile um programa C com declarações de int, float e bool sem warnings.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador GCC online (repl.it ou IDEOne), editor de texto.",
                                  "tips": "Prefira nomes descritivos; inclua #include <stdbool.h> para bool em C padrão.",
                                  "learningObjective": "Aplicar sintaxe precisa de C para declarações escalares.",
                                  "commonMistakes": "Esquecer ';' no final; usar float sem .0 para literais decimais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Declarações Integradas e Verificar Erros",
                                  "subSteps": [
                                    "Crie um programa que declara e imprime variáveis de todos os tipos em Pascal e C.",
                                    "Introduza erros propositais (ex: tipo errado) e corrija-os.",
                                    "Compare declarações entre linguagens em uma tabela.",
                                    "Teste inicialização: var x: integer = 10; vs int x = 10;.",
                                    "Compile e execute para confirmar valores corretos."
                                  ],
                                  "verification": "Execute programas em ambas linguagens mostrando saídas corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDEs online para Pascal e C, lista de testes de erros.",
                                  "tips": "Use printf/ writeln para visualizar valores e depurar.",
                                  "learningObjective": "Integrar conhecimentos e debugar declarações comuns.",
                                  "commonMistakes": "Inicializar lógico com número; declarar fora de escopo válido."
                                }
                              ],
                              "practicalExample": "Em C: #include <stdio.h> int main() { int idade = 25; float altura = 1.75; bool maior = true; printf(\"Idade: %d, Altura: %.2f, Maior: %d\\n\", idade, altura, maior); return 0; } Em Pascal: program Exemplo; var idade: integer; altura: real; maior: boolean; begin idade := 25; altura := 1.75; maior := true; writeln('Idade: ', idade, ', Altura: ', altura:0:2, ', Maior: ', maior); end.",
                              "finalVerifications": [
                                "Declara corretamente variáveis int, float/real e bool em C e Pascal sem erros de compilação.",
                                "Inicializa variáveis com valores apropriados para cada tipo.",
                                "Identifica e corrige 5 erros comuns de declaração.",
                                "Explica diferenças de sintaxe entre Pascal e C.",
                                "Cria um programa funcional com 3 variáveis declaradas.",
                                "Usa convenções de nomenclatura (camelCase ou snake_case)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da sintaxe: 100% das declarações compilam sem erros.",
                                "Variedade de tipos: Inclui pelo menos um de cada tipo escalar.",
                                "Correção de inicialização: Valores compatíveis com o tipo.",
                                "Clareza de nomes: Variáveis com nomes descritivos e sem palavras reservadas.",
                                "Eficiência: Evita declarações redundantes ou desnecessárias.",
                                "Documentação: Comenta o código explicando cada declaração.",
                                "Testes: Programa executa e produz saída esperada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação numérica de inteiros e reais (precisão e arredondamento).",
                                "Lógica: Uso de booleanos em expressões condicionais.",
                                "Física: Declaração de variáveis para medidas reais como velocidade ou massa.",
                                "Português: Nomenclatura clara e descritiva de variáveis.",
                                "Ética em Computação: Boas práticas de declaração para código legível."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, declarar variáveis corretamente é essencial para apps como calculadoras financeiras (int para moedas, real para juros), jogos (bool para estados como 'vivo'), ou sistemas embarcados em engenharia (controle de sensores com tipos precisos), evitando erros de runtime e otimizando memória em projetos reais como IoT ou automação industrial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Reconhecer escopo de variáveis",
                            "description": "Diferenciar escopo local e global de variáveis, entendendo que a atribuição só ocorre após declaração no escopo apropriado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Básico de Escopo de Variáveis",
                                  "subSteps": [
                                    "Defina escopo como a região do código onde uma variável pode ser acessada.",
                                    "Identifique que variáveis declaradas fora de funções têm escopo global.",
                                    "Explique que variáveis dentro de funções ou blocos têm escopo local.",
                                    "Note que o escopo determina quando e onde a atribuição é permitida após declaração.",
                                    "Discuta visibilidade: locais não acessíveis de fora, globais acessíveis em todo lugar."
                                  ],
                                  "verification": "Escreva uma definição curta de escopo e dê um exemplo simples de global vs local.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Use diagramas de blocos de código para visualizar regiões de escopo.",
                                  "learningObjective": "Compreender o que é escopo e suas implicações básicas na acessibilidade de variáveis.",
                                  "commonMistakes": [
                                    "Confundir escopo com tipo de variável",
                                    "Achar que todas variáveis são globais por padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Escopo Global",
                                  "subSteps": [
                                    "Declare uma variável fora de qualquer função (global).",
                                    "Acesse e atribua valor à variável em diferentes partes do programa principal.",
                                    "Tente acessá-la dentro de uma função sem redeclarar.",
                                    "Observe que atribuição só ocorre após declaração no fluxo de execução.",
                                    "Teste com código: declare global, use em main e função."
                                  ],
                                  "verification": "Execute um código simples onde uma variável global é usada em múltiplos locais sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código online (ex: Replit)",
                                    "Pseudocódigo ou linguagem procedimental como Pascal"
                                  ],
                                  "tips": "Sempre declare antes de usar; ordem importa no escopo global.",
                                  "learningObjective": "Reconhecer como variáveis globais são acessíveis e atribuídas em todo o programa.",
                                  "commonMistakes": [
                                    "Atribuir antes de declarar",
                                    "Re-declarar global dentro de função por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Escopo Local",
                                  "subSteps": [
                                    "Declare uma variável dentro de uma função (local).",
                                    "Acesse e atribua valor apenas dentro dessa função.",
                                    "Tente acessar a variável local de fora da função e observe erro.",
                                    "Compare com global: crie funções que usam tanto local quanto global.",
                                    "Verifique regra: atribuição só após declaração no escopo local."
                                  ],
                                  "verification": "Código roda sem erros dentro da função, mas falha ao acessar local de fora.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Documentação de linguagem procedimental"
                                  ],
                                  "tips": "Use nomes descritivos para evitar confusão entre local e global.",
                                  "learningObjective": "Diferenciar escopo local, entendendo sua limitação à função ou bloco.",
                                  "commonMistakes": [
                                    "Acessar local fora do escopo",
                                    "Confundir com parâmetros de função"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e Praticar Escopos com Exemplos Mistos",
                                  "subSteps": [
                                    "Crie um programa com variáveis global e local no mesmo escopo.",
                                    "Identifique erros comuns: atribuição prematura ou acesso indevido.",
                                    "Debugue códigos com erros de escopo fornecidos.",
                                    "Escreva um programa que demonstre regras de declaração e atribuição.",
                                    "Compare comportamentos em fluxogramas."
                                  ],
                                  "verification": "Corrija e execute 3 códigos com erros de escopo mistos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código com erros"
                                  ],
                                  "tips": "Trace o fluxo de execução passo a passo com setas.",
                                  "learningObjective": "Aplicar diferenciação entre local e global em cenários reais de código.",
                                  "commonMistakes": [
                                    "Ignorar ordem de declaração",
                                    "Assumir shadowing sem entender"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa pseudocódigo:\nVAR globalVar: inteiro;\nINICIO\n  globalVar := 10;  // OK, após declaração\n  funcaoExemplo();\nFIM\nfuncaoExemplo()\nVAR localVar: inteiro;\nINICIO\n  localVar := globalVar + 5;  // OK, local após declaração, usa global\nFIM\n// Fora: globalVar OK, localVar ERRO",
                              "finalVerifications": [
                                "Explique verbalmente ou por escrito a diferença entre escopo local e global.",
                                "Identifique o escopo de 5 variáveis em um código fornecido.",
                                "Corrija um código com 3 erros de escopo e atribuição.",
                                "Crie um programa simples usando ambos escopos corretamente.",
                                "Trace o valor de variáveis em um fluxograma com funções aninhadas.",
                                "Responda quiz: 'Onde pode atribuir após declarar?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de escopos (100% correto).",
                                "Correção de erros sem introduzir novos.",
                                "Explicações claras e concisas dos conceitos.",
                                "Uso correto de declaração antes de atribuição.",
                                "Demonstração prática via código executável.",
                                "Compreensão de visibilidade em cenários mistos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com domínios de funções (onde válidas).",
                                "Lógica: Hierarquias de regras como em silogismos.",
                                "Física: Escopos como campos de força limitados.",
                                "Língua Portuguesa: Escopo como contexto semântico de palavras."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, entender escopos previne bugs caros, como em sistemas bancários onde variáveis locais protegem dados sensíveis de serem alteradas acidentalmente por outras partes do código, garantindo modularidade e segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Sintaxe do Comando de Atribuição Simples",
                        "description": "Dominar a sintaxe básica do operador de atribuição para associar valores iniciais ou computados a variáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Escrever atribuição de valor literal",
                            "description": "Utilizar a sintaxe 'variável = valor;' para atribuir literais numéricos, strings ou lógicos, identificando erros comuns como atribuição antes da declaração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes da sintaxe de atribuição de valor literal",
                                  "subSteps": [
                                    "Identificar o que é uma variável: um nome simbólico para armazenar dados.",
                                    "Reconhecer literais: valores fixos como números (10), strings ('Olá') ou lógicos (true/false).",
                                    "Analisar a sintaxe básica: 'variável = valor;' onde '=' é o operador de atribuição e ';' finaliza a instrução.",
                                    "Diferenciar atribuição de igualdade matemática (==)."
                                  ],
                                  "verification": "Escrever 3 exemplos de componentes isolados (variável, literal, sintaxe completa) sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Folha de referência de sintaxe de atribuição"
                                  ],
                                  "tips": "Lembre-se: '=' atribui valor à variável, não compara.",
                                  "learningObjective": "Dominar os elementos fundamentais da sintaxe de atribuição literal.",
                                  "commonMistakes": [
                                    "Confundir '=' com '==' para comparação.",
                                    "Esquecer o ';' no final da instrução."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar atribuições com literais numéricos, strings e lógicos",
                                  "subSteps": [
                                    "Escrever atribuições para literais numéricos: ex. idade = 25;",
                                    "Escrever atribuições para strings: ex. nome = 'Maria';",
                                    "Escrever atribuições para lógicos: ex. ativo = true;",
                                    "Combinar em um bloco de código com múltiplas atribuições."
                                  ],
                                  "verification": "Executar ou validar sintaticamente 5 atribuições variadas em um interpretador ou validador online.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Interpretador online (ex. Replit para pseudocódigo/Python)",
                                    "Lista de exemplos modelo"
                                  ],
                                  "tips": "Use aspas duplas ou simples consistentemente para strings.",
                                  "learningObjective": "Aplicar corretamente a sintaxe para todos os tipos de literais.",
                                  "commonMistakes": [
                                    "Usar aspas para números (ex. idade = '25;'), causando erro de tipo.",
                                    "Escrever true sem minúsculas em algumas linguagens."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e corrigir erros comuns em atribuições",
                                  "subSteps": [
                                    "Simular erro de atribuição antes da declaração: ex. x = 5; antes de int x;",
                                    "Corrigir falta de ';': adicionar no final.",
                                    "Detectar atribuição inválida: ex. 5 = x;",
                                    "Testar em um ambiente para ver mensagens de erro."
                                  ],
                                  "verification": "Listar 4 erros comuns, corrigi-los e explicar por que falham.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador/interpretador com feedback de erros",
                                    "Lista de erros comuns pré-definida"
                                  ],
                                  "tips": "Sempre declare variáveis antes de atribuir em linguagens tipadas estáticas.",
                                  "learningObjective": "Reconhecer e debugar erros típicos de sintaxe de atribuição.",
                                  "commonMistakes": [
                                    "Atribuir a um literal: 5 = valor;",
                                    "Omitir operador '=': variável valor;"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever um programa simples usando atribuições literais",
                                  "subSteps": [
                                    "Planejar um programa: atribuir idade, nome e status a variáveis.",
                                    "Escrever o código completo com 4-5 atribuições.",
                                    "Executar e imprimir valores para verificar.",
                                    "Modificar valores e reexecutar."
                                  ],
                                  "verification": "Programa roda sem erros e exibe valores atribuídos corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente de programação completo (ex. VS Code com extensão)",
                                    "Template de programa base"
                                  ],
                                  "tips": "Inicialize variáveis no início do programa para clareza.",
                                  "learningObjective": "Integrar atribuições em um contexto programático funcional.",
                                  "commonMistakes": [
                                    "Reatribuir sem necessidade, confundindo estado inicial.",
                                    "Ignorar sensibilidade a maiúsculas/minúsculas em nomes de variáveis."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de perfil de usuário: nome = 'João Silva'; idade = 30; emailVerificado = true; saldo = 100.50; // Agora, imprimir ou usar essas variáveis em lógica.",
                              "finalVerifications": [
                                "Escreve atribuições sem erros sintáticos para numéricos, strings e lógicos.",
                                "Identifica e corrige atribuição antes da declaração.",
                                "Valida sintaxe com ';' e operador '=' correto.",
                                "Executa programa simples com múltiplas atribuições.",
                                "Explica diferença entre literais e variáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão da sintaxe (100% sem erros).",
                                "Diversidade de tipos de literais usados (pelo menos 3 tipos).",
                                "Correção de erros identificados (todas as correções válidas).",
                                "Clareza e legibilidade do código escrito.",
                                "Compreensão demonstrada em explicações verbais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação numérica e operações básicas.",
                                "Língua Portuguesa: Construção de strings como frases.",
                                "Lógica: Uso de valores booleanos para condições verdadeiras/falsas.",
                                "Física: Atribuição de valores iniciais em simulações (ex. velocidade = 0;)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, atribuições literais inicializam configurações de apps (ex. nomeApp = 'MeuApp'; versão = 1.0; debug = false;), dados de usuário em bancos ou valores padrão em jogos e sistemas embarcados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Atribuir valor de outra variável",
                            "description": "Realizar atribuições como 'a = b;' onde b já possui valor, compreendendo a cópia de conteúdo e não de referência em tipos escalares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Atribuição de Variável para Variável",
                                  "subSteps": [
                                    "Defina o que é uma variável em programação: um espaço na memória com um nome e valor associado.",
                                    "Explique a diferença entre declaração (int a;) e atribuição (a = 10;).",
                                    "Discuta que em tipos escalares (int, float, char), a atribuição copia o valor, não a referência.",
                                    "Compare com tipos compostos (futuramente), onde pode haver referência.",
                                    "Visualize com diagrama: b tem valor 5, a = b copia 5 para a."
                                  ],
                                  "verification": "Resuma em suas palavras a diferença entre cópia de valor e referência, com exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama de memória impresso ou ferramenta online como Python Tutor adaptada para C.",
                                  "tips": "Use desenhos à mão para visualizar a memória antes de codificar.",
                                  "learningObjective": "Entender que atribuição em escalares resulta em cópia independente de valores.",
                                  "commonMistakes": "Confundir com passagem por referência; achar que alterar uma muda a outra."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Sintaxe Correta",
                                  "subSteps": [
                                    "Escreva a sintaxe: variável_destino = variável_origem;",
                                    "Declare ambas as variáveis com tipos compatíveis (ex: int a, b; b=10; a=b;).",
                                    "Teste em um compilador: inclua <stdio.h>, use printf para mostrar valores.",
                                    "Experimente tipos diferentes: float, char, garantindo compatibilidade.",
                                    "Evite erros comuns como esquecer ponto e vírgula ou usar = em expressões condicionais."
                                  ],
                                  "verification": "Compile e execute um código simples sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code ou Replit), compilador C (GCC online).",
                                  "tips": "Sempre declare variáveis antes de usar; compile incrementalmente.",
                                  "learningObjective": "Aplicar sintaxe precisa para atribuições entre variáveis escalares.",
                                  "commonMistakes": "Usar == em vez de =; atribuir sem declarar; mismatch de tipos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Atribuições em Exercícios Simples",
                                  "subSteps": [
                                    "Crie programa: declare x=5, y=x, altere y=10, imprima ambos (x deve ser 5).",
                                    "Repita com float: pi=3.14, raio=pi, imprima.",
                                    "Faça cadeia: a=1, b=a, c=b, altere a=99, verifique independência.",
                                    "Inclua input: leia valor para b, atribua a b, imprima.",
                                    "Teste edge cases: zero, negativo, char 'A'."
                                  ],
                                  "verification": "Execute 3 exercícios, confirmando que alterações em uma não afetam a outra.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE online (CodePen ou JDoodle para C), papel para planejar.",
                                  "tips": "Use printf(\"%d\", var) para depuração rápida.",
                                  "learningObjective": "Executar atribuições práticas demonstrando cópia de valor.",
                                  "commonMistakes": "Reatribuir origem após cópia e esperar mudança na destino; overflow em tipos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Verificar Comportamento",
                                  "subSteps": [
                                    "Compare antes/depois: imprima valores pré e pós-atribuição e modificação.",
                                    "Discuta por que escalares copiam: eficiência e independência.",
                                    "Teste múltiplas atribuições em loop simples.",
                                    "Registre resultados em tabela: variável | valor inicial | após atribuição | após mudança origem.",
                                    "Reflita: quando usar isso vs calcular novo valor."
                                  ],
                                  "verification": "Gere tabela de resultados de testes comprovando cópia independente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha ou tabela Markdown, código-fonte salvo.",
                                  "tips": "Salve versões do código com comentários para revisão.",
                                  "learningObjective": "Validar empiricamente a semântica de cópia em escalares.",
                                  "commonMistakes": "Ignorar warnings de compilador; não testar casos limite."
                                }
                              ],
                              "practicalExample": "Em um programa de cálculo de média: int nota1 = 8; int nota2 = nota1; nota2 = 9; printf(\"Nota1: %d, Nota2: %d\", nota1, nota2); // Saída: Nota1: 8, Nota2: 9 – prova cópia, não referência.",
                              "finalVerifications": [
                                "Código compila e executa sem erros.",
                                "Alteração em variável origem não afeta destino após atribuição.",
                                "Valores impressos confirmam cópia exata em tipos escalares.",
                                "Testado com pelo menos 3 tipos diferentes (int, float, char).",
                                "Tabela de resultados documentada.",
                                "Explicação escrita da diferença cópia vs referência."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: 100% sem erros de compilação.",
                                "Compreensão conceitual: explica cópia em escalares.",
                                "Prática: 5+ exemplos executados corretamente.",
                                "Análise: identifica independência de valores pós-atribuição.",
                                "Documentação: código comentado e tabela de testes.",
                                "Criatividade: aplica em contexto simples real."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: atribuição como operação de igualdade algébrica.",
                                "Lógica: compreensão de estados independentes em fluxogramas.",
                                "Física: modelagem de grandezas escalares independentes.",
                                "Inglês: leitura de documentação de sintaxe em specs de linguagem."
                              ],
                              "realWorldApplication": "Em software de finanças, copiar saldo de conta origem para destino em transações sem afetar o original até confirmação; ou em jogos, duplicar pontuação inicial para múltiplos jogadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Interpretar o fluxo de execução da atribuição",
                            "description": "Analisar o ordem de avaliação: lado direito primeiro, depois atribuição no lado esquerdo, com exemplos passo a passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Reconhecer a estrutura básica do comando de atribuição",
                                  "subSteps": [
                                    "Identifique o símbolo de atribuição (ex: := ou =) que separa o lado esquerdo do lado direito.",
                                    "Localize o lado esquerdo: deve ser uma variável simples ou l-value válido.",
                                    "Localize o lado direito: uma expressão que será avaliada.",
                                    "Confirme que não há ambiguidade na sintaxe, como operadores mal posicionados.",
                                    "Anote os componentes em um diagrama simples."
                                  ],
                                  "verification": "Desenhe um diagrama da atribuição separando esquerdo e direito corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples",
                                  "tips": "Sempre leia da esquerda para a direita primeiro para mapear os lados.",
                                  "learningObjective": "Entender a divisão fundamental entre l-value e r-value.",
                                  "commonMistakes": "Confundir o símbolo de atribuição com igualdade; assumir avaliação de ambos os lados simultaneamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a expressão no lado direito seguindo a ordem de precedência",
                                  "subSteps": [
                                    "Liste todos os operadores na expressão e sua precedência (ex: * antes de +).",
                                    "Calcule subexpressões internas primeiro, substituindo valores passo a passo.",
                                    "Registre valores intermediários para cada operação.",
                                    "Verifique parênteses que alteram a ordem.",
                                    "Substitua a expressão completa por seu valor final."
                                  ],
                                  "verification": "Mostre cálculos intermediários resultando no valor final do lado direito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora simples ou papel para cálculos",
                                  "tips": "Use PEMDAS/BODMAS como lembrete: Parênteses, Expoentes, Multiplicação/Divisão, Adição/Subtração.",
                                  "learningObjective": "Dominar a avaliação sequencial de expressões independentes da atribuição.",
                                  "commonMistakes": "Avaliar lado esquerdo antes; ignorar precedência de operadores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e preparar o lado esquerdo para receber o valor",
                                  "subSteps": [
                                    "Confirme que o lado esquerdo é uma variável válida (não uma constante ou expressão).",
                                    "Verifique o tipo de dado compatível com o resultado do lado direito.",
                                    "Simule o 'espaço de memória' da variável, limpando valor anterior se aplicável.",
                                    "Prepare para a transferência: o valor direito substituirá o atual.",
                                    "Note qualquer conversão implícita de tipos se necessário."
                                  ],
                                  "verification": "Descreva o estado da variável antes e após, confirmando compatibilidade.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Diagrama de memória desenhado à mão",
                                  "tips": "Pense no lado esquerdo como uma 'caixa vazia' aguardando preenchimento.",
                                  "learningObjective": "Compreender o papel passivo do l-value na atribuição.",
                                  "commonMistakes": "Tentar avaliar o lado esquerdo como expressão; ignorar mismatches de tipo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar a atribuição completa e validar o fluxo",
                                  "subSteps": [
                                    "Transfira o valor final do lado direito para o lado esquerdo.",
                                    "Simule a execução linha por linha em um exemplo com múltiplas atribuições.",
                                    "Trace o fluxo: avaliação direita → atribuição esquerda.",
                                    "Teste com um interpretador ou simulador se disponível.",
                                    "Registre o estado final das variáveis envolvidas."
                                  ],
                                  "verification": "Execute um exemplo e confirme o valor final da variável atribuída.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código ou interpretador online (ex: Python REPL)",
                                  "tips": "Sempre trace com setas: → avaliar direita → atribuir esquerda.",
                                  "learningObjective": "Integrar avaliação e atribuição em um fluxo coeso.",
                                  "commonMistakes": "Atribuir antes de avaliar completamente; confundir com atribuições múltiplas."
                                }
                              ],
                              "practicalExample": "Considere: x := 5 + 3 * 2;\n1. Avalie 3*2=6 (precedência).\n2. 5+6=11.\n3. Atribua 11 a x. Resultado: x=11.",
                              "finalVerifications": [
                                "Pode decompor qualquer atribuição simples em avaliação direita seguida de atribuição esquerda.",
                                "Trace corretamente valores intermediários em expressões complexas.",
                                "Identifica erros de precedência em exemplos dados.",
                                "Simula execução em papel com 100% de acerto.",
                                "Explica o fluxo para um colega sem hesitação.",
                                "Aplica em código real sem bugs de ordem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na ordem de avaliação (100% correto em testes).",
                                "Detalhamento de passos intermediários em expressões.",
                                "Correta distinção entre l-value e r-value.",
                                "Uso consistente de precedência de operadores.",
                                "Capacidade de debugar fluxos incorretos.",
                                "Clareza na explicação escrita ou oral."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Ordem de operações (PEMDAS).",
                                "Lógica: Sequenciamento de instruções em algoritmos.",
                                "Física: Modelagem de estados em simulações.",
                                "Linguagem: Análise sintática em gramáticas formais."
                              ],
                              "realWorldApplication": "Em programação de software, entender esse fluxo previne bugs em cálculos financeiros (ex: juros compostos), jogos (pontuações), e sistemas embarcados (controle de sensores), garantindo que variáveis recebam valores computados corretamente antes de uso subsequente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Expressões e Operadores Compostos de Atribuição",
                        "description": "Aplicar expressões aritméticas e operadores compostos para atribuições complexas e eficientes.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Construir expressões aritméticas na atribuição",
                            "description": "Escrever atribuições como 'soma = a + b;' ou 'media = (a + b) / 2;', respeitando precedência de operadores e tipos compatíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar operadores aritméticos básicos",
                                  "subSteps": [
                                    "Liste os operadores aritméticos principais: +, -, *, /, %.",
                                    "Explique o que cada operador faz com exemplos numéricos simples (ex: 5 + 3 = 8).",
                                    "Pratique com variáveis: a = 10; b = 2; escreva a + b.",
                                    "Identifique quando usar divisão inteira vs. real."
                                  ],
                                  "verification": "Liste corretamente pelo menos 5 operadores e dê um exemplo para cada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Documentação da linguagem (ex: C ou Python)"
                                  ],
                                  "tips": [
                                    "Lembre-se: / em inteiros pode truncar; use float para precisão."
                                  ],
                                  "learningObjective": "Reconhecer e exemplificar operadores aritméticos em contextos de atribuição.",
                                  "commonMistakes": [
                                    "Confundir * com x (multiplicação sempre com *).",
                                    "Ignorar % para resto da divisão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender precedência e associatividade de operadores",
                                  "subSteps": [
                                    "Memorize a ordem: () > * / % > + -.",
                                    "Teste expressões sem parênteses: 2 + 3 * 4 (deve ser 14).",
                                    "Adicione associatividade: operadores da mesma precedência vão da esquerda para direita.",
                                    "Escreva atribuições como resultado = 10 / 2 + 3; (8)."
                                  ],
                                  "verification": "Avalie 3 expressões e explique o resultado passo a passo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de precedência impressa",
                                    "Calculadora para verificação"
                                  ],
                                  "tips": [
                                    "Sempre use parênteses para clareza, mesmo quando não obrigatório."
                                  ],
                                  "learningObjective": "Aplicar regras de precedência para avaliar expressões corretamente.",
                                  "commonMistakes": [
                                    "Avaliar da esquerda para direita ignorando precedência.",
                                    "Esquecer parênteses em divisões."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir expressões aritméticas simples em atribuições",
                                  "subSteps": [
                                    "Escreva soma: soma = a + b;",
                                    "Teste subtração: diferenca = a - b;",
                                    "Multiplicação: produto = a * b;",
                                    "Divisão: quociente = a / b; (considere tipos).",
                                    "Compile e execute cada uma com valores de teste."
                                  ],
                                  "verification": "Execute 4 atribuições simples sem erros de sintaxe ou runtime.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador/Interpretador (ex: GCC para C, Python IDLE)"
                                  ],
                                  "tips": [
                                    "Declare variáveis antes: int a=5, b=3;"
                                  ],
                                  "learningObjective": "Escrever atribuições com operadores unários ou binários simples.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula no final.",
                                    "Usar variáveis não declaradas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir expressões compostas e verificar compatibilidade de tipos",
                                  "subSteps": [
                                    "Combine operadores: media = (a + b) / 2;",
                                    "Use múltiplos: area = largura * (altura + profundidade);",
                                    "Verifique tipos: não misture int e float sem cast (ex: (float)a / b).",
                                    "Teste com valores mistos e corrija erros.",
                                    "Debugue erros comuns como divisão por zero."
                                  ],
                                  "verification": "Crie e execute 3 expressões compostas sem warnings ou erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor com linting (ex: VS Code com extensões)",
                                    "Valores de teste variados"
                                  ],
                                  "tips": [
                                    "Parênteses evitam ambiguidades e facilitam leitura."
                                  ],
                                  "learningObjective": "Criar expressões complexas respeitando precedência e tipos.",
                                  "commonMistakes": [
                                    "Divisão int resultando em truncamento inesperado.",
                                    "Ignorar overflow em somas grandes."
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a média ponderada de notas em um programa escolar: int nota1=8, nota2=9, nota3=7; float media = (nota1 * 0.3 + nota2 * 0.3 + nota3 * 0.4); // Resultado: 8.1",
                              "finalVerifications": [
                                "Lista corretamente operadores aritméticos e precedências.",
                                "Escreve atribuição simples como soma = 5 + 3;",
                                "Constrói expressão com parênteses: media = (a + b)/2;",
                                "Identifica e corrige incompatibilidade de tipos (int/float).",
                                "Executa programa sem erros de compilação ou runtime.",
                                "Explica resultado de 2 + 3 * 4 = 14."
                              ],
                              "assessmentCriteria": [
                                "Expressão sintaticamente correta e compilável.",
                                "Respeita precedência de operadores sem ambiguidades.",
                                "Usa parênteses adequadamente em expressões compostas.",
                                "Garante compatibilidade de tipos (casts quando necessário).",
                                "Resultados numéricos precisos e sem truncamentos indesejados.",
                                "Código legível com variáveis bem nomeadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Construção de expressões algébricas e avaliação.",
                                "Física: Cálculos de grandezas compostas (velocidade = distancia / tempo).",
                                "Economia: Cálculos financeiros (total = preco * qtd + impostos).",
                                "Estatística: Médias e desvios em dados numéricos."
                              ],
                              "realWorldApplication": "Em aplicativos de finanças pessoais, calcular saldo atualizado: saldo = saldoAnterior + deposito - (saque * taxa); garantindo precisão em transações bancárias e evitando erros de arredondamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Utilizar operadores compostos",
                            "description": "Aplicar operadores como +=, -=, *= em linguagens como C++, exemplificando 'contador += 1;' equivalente a 'contador = contador + 1;'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Operadores Compostos",
                                  "subSteps": [
                                    "Revise operadores de atribuição simples como '=' em C++.",
                                    "Identifique a diferença: 'x = x + 1' vs 'x += 1'.",
                                    "Analise como o operador composto combina atribuição e operação em um passo.",
                                    "Estude a sintaxe geral: variável OP= expressão.",
                                    "Compare com linguagens semelhantes para reforço."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a equivalência de 'contador += 1' com 'contador = contador + 1'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE como Code::Blocks",
                                    "Documentação C++ sobre operadores (cppreference.com)"
                                  ],
                                  "tips": "Visualize o operador composto como uma abreviação para evitar repetição de variáveis.",
                                  "learningObjective": "Entender que operadores compostos otimizam código procedural sem alterar lógica.",
                                  "commonMistakes": [
                                    "Confundir com operadores unários como ++",
                                    "Esquecer precedência em expressões complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar Operadores Compostos Principais",
                                  "subSteps": [
                                    "Liste operadores: +=, -=, *=, /=, %=, >>=, <<=, &=, |=, ^=.",
                                    "Para cada um, escreva a forma expandida (ex: x *= 2 é x = x * 2).",
                                    "Teste mentalmente: 'saldo -= 10;' significa subtrair 10 do saldo.",
                                    "Pratique com variáveis inteiras e float para ver tipos suportados.",
                                    "Note limitações: não funciona com strings sem overload."
                                  ],
                                  "verification": "Escreva uma tabela com 5 operadores e suas equivalências sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou bloco de notas",
                                    "Compilador C++ online como Replit"
                                  ],
                                  "tips": "Use mnemônicos: '+=' para acumular, '-=' para deduzir.",
                                  "learningObjective": "Dominar sintaxe e semântica de pelo menos 5 operadores compostos.",
                                  "commonMistakes": [
                                    "Usar em tipos incompatíveis como char com %=",
                                    "Ignorar overflow em inteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar em Código Simples",
                                  "subSteps": [
                                    "Crie um programa com int contador = 0; e use contador += 1 em um loop for(10).",
                                    "Adicione múltiplos: score *= 2; lives -= 1;",
                                    "Compile e execute para imprimir valores finais.",
                                    "Refatore código expandido para usar compostos e compare linhas.",
                                    "Teste edge cases: divisão por zero em /=."
                                  ],
                                  "verification": "Código compila e produz saída correta (ex: contador=10 após loop).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE C++ (Visual Studio Code com extensão C++)",
                                    "Terminal para compilar g++"
                                  ],
                                  "tips": "Sempre inicialize variáveis antes de usar operadores compostos.",
                                  "learningObjective": "Aplicar operadores compostos em expressões atribuídas corretamente.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula",
                                    "Usar em constantes como 5 += 1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Otimizar em Programa Realista",
                                  "subSteps": [
                                    "Desenvolva um programa de calculadora de média com soma += nota; e count += 1;.",
                                    "Otimize um loop de soma de array usando i += 1 e total += array[i].",
                                    "Debugue erros intencionais como usar += em string sem concatenação.",
                                    "Meça performance: compile com -O2 e compare tempos (opcional).",
                                    "Documente código com comentários explicando cada operador composto."
                                  ],
                                  "verification": "Programa calcula média corretamente e código usa pelo menos 3 operadores compostos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador g++",
                                    "Exemplos de código de loops em C++"
                                  ],
                                  "tips": "Em loops, operadores compostos reduzem digitação e melhoram legibilidade.",
                                  "learningObjective": "Integrar operadores compostos em fluxos procedurais complexos.",
                                  "commonMistakes": [
                                    "Precedência errada em expressões como x *= y + 1",
                                    "Não tratar underflow em -= grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um jogo simples: int pontos = 0; // ... pontos += 10; // Equivalente a pontos = pontos + 10; Após 5 acertos, pontos=50.",
                              "finalVerifications": [
                                "Converta 5 atribuições simples em compostas sem alterar lógica.",
                                "Explique diferença entre x++ e x += 1.",
                                "Escreva e compile um loop usando *= para potências de 2.",
                                "Identifique e corrija bugs em código com /= e %=.",
                                "Compare comprimento de código antes/depois da refatoração."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe de todos operadores compostos testados.",
                                "Compreensão demonstrada via equivalências expandidas corretas.",
                                "Eficiência: código otimizado sem redundâncias.",
                                "Ausência de erros de compilação ou runtime.",
                                "Criatividade em aplicações reais além de exemplos básicos.",
                                "Documentação clara explicando escolhas de operadores."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas e álgebra elementar.",
                                "Lógica: Otimização de expressões booleanas com &= e |=.",
                                "Física/Engenharia: Acúmulo de forças ou velocidades em simulações (v += a * dt).",
                                "Economia: Cálculos de saldo com += depósitos e -= saques."
                              ],
                              "realWorldApplication": "Em software embarcado (ex: Arduino), contadores de sensores usam += para eficiência; em jogos, scores e vidas; em bancos, atualizações de saldos transacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Debugar erros em atribuições complexas",
                            "description": "Identificar e corrigir erros como divisão por zero, incompatibilidade de tipos ou atribuição múltipla inválida em expressões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Reproduzir e Capturar o Erro",
                                  "subSteps": [
                                    "Execute o código completo em um ambiente de desenvolvimento.",
                                    "Registre a mensagem de erro exata, incluindo linha e traceback.",
                                    "Salve o código original em um arquivo para referência.",
                                    "Identifique o contexto da atribuição complexa (ex: expressões com operadores compostos).",
                                    "Anote variáveis envolvidas na atribuição falha."
                                  ],
                                  "verification": "O erro foi reproduzido consistentemente e a mensagem foi copiada verbatim.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, PyCharm)",
                                    "Interpretador da linguagem (ex: Python IDLE)"
                                  ],
                                  "tips": "Sempre execute em modo debug se disponível para pausar na falha.",
                                  "learningObjective": "Aprender a isolar o erro reproduzindo-o de forma controlada.",
                                  "commonMistakes": [
                                    "Ignorar tracebacks parciais",
                                    "Modificar o código antes de registrar o erro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Mensagem de Erro",
                                  "subSteps": [
                                    "Leia a mensagem de erro linha por linha, focando em palavras-chave como 'ZeroDivisionError', 'TypeError'.",
                                    "Identifique o tipo de erro: divisão por zero, incompatibilidade de tipos ou atribuição inválida.",
                                    "Localize a linha exata apontada no traceback.",
                                    "Mapeie o erro para causas comuns em atribuições (ex: variável zero em denominador).",
                                    "Pesquise o erro específico no Stack Overflow ou documentação oficial."
                                  ],
                                  "verification": "Uma lista de 3 possíveis causas foi anotada com base na mensagem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação da linguagem",
                                    "Buscador web para referências de erros"
                                  ],
                                  "tips": "Mensagens de erro em Python são descritivas; leia do final para o início do traceback.",
                                  "learningObjective": "Desenvolver habilidade em interpretar mensagens de erro para diagnóstico rápido.",
                                  "commonMistakes": [
                                    "Assumir o erro sem ler o traceback completo",
                                    "Confundir sintomas com causas raiz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar e Isolar o Problema no Código",
                                  "subSteps": [
                                    "Insira print statements antes e depois da linha problemática para inspecionar valores.",
                                    "Use um debugger para pausar e examinar variáveis passo a passo.",
                                    "Teste expressões isoladas em um console interativo.",
                                    "Verifique tipos de dados com funções como type() ou isinstance().",
                                    "Simule cenários de entrada que causem o erro (ex: valor zero)."
                                  ],
                                  "verification": "Valores de variáveis foram impressos e o ponto exato da falha foi isolado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Debugger integrado (ex: pdb em Python)",
                                    "Console REPL"
                                  ],
                                  "tips": "Comece com prints simples: print(f'valor de x: {x}') para visibilidade imediata.",
                                  "learningObjective": "Dominar técnicas de inspeção para pinpointar falhas em expressões compostas.",
                                  "commonMistakes": [
                                    "Não testar com dados de borda",
                                    "Esquecer de verificar tipos dinamicamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Corrigir o Erro e Validar",
                                  "subSteps": [
                                    "Aplique a correção específica: adicione verificação if para zero, casting de tipos ou reescreva atribuição.",
                                    "Remova prints temporários e limpe o código.",
                                    "Execute testes com múltiplos inputs, incluindo casos edge.",
                                    "Confirme que a atribuição complexa agora funciona sem erros.",
                                    "Documente a correção em um comentário no código."
                                  ],
                                  "verification": "Código executa sem erros e produz saídas esperadas em 5 testes variados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Suite de testes simples",
                                    "Editor de código"
                                  ],
                                  "tips": "Sempre prefira prevenção (ex: if denominator != 0) a try-except para debugging inicial.",
                                  "learningObjective": "Aplicar correções precisas e validar robustez em atribuições.",
                                  "commonMistakes": [
                                    "Corrigir sintoma sem causa raiz",
                                    "Não testar regressões"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refatorar para Prevenir Erros Futuros",
                                  "subSteps": [
                                    "Adicione validações proativas em atribuições complexas.",
                                    "Crie funções auxiliares para expressões comuns propensas a erros.",
                                    "Implemente testes unitários para a seção corrigida.",
                                    "Revise o código inteiro por padrões similares.",
                                    "Compartilhe o caso em um log de lições aprendidas."
                                  ],
                                  "verification": "Código refatorado passa em testes unitários e tem comentários preventivos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Framework de testes (ex: unittest em Python)"
                                  ],
                                  "tips": "Use assertions para documentar suposições: assert denominator != 0.",
                                  "learningObjective": "Evoluir de correção reativa para código defensivo.",
                                  "commonMistakes": [
                                    "Parar após correção única",
                                    "Ignorar refatoração para escalabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: total = (a + b) / (c - d); erro ZeroDivisionError se c == d. Correção: if (c - d) != 0: total = (a + b) / (c - d) else: total = 0. Para TypeError: resultado = int('abc') + 5 → use try: int('abc') except ValueError: resultado = 0.",
                              "finalVerifications": [
                                "Código executa sem erros em todos os cenários testados.",
                                "Mensagens de erro originais foram eliminadas.",
                                "Resultados das atribuições correspondem aos esperados.",
                                "Validações preventivas foram adicionadas.",
                                "Testes unitários passam com cobertura de edge cases.",
                                "Documentação da correção está no código."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do tipo de erro (100% match).",
                                "Eficiência das subSteps (conclusão em tempo estimado).",
                                "Qualidade das correções (sem introduzir novos erros).",
                                "Uso correto de ferramentas de debug.",
                                "Profundidade das verificações e testes.",
                                "Clareza na documentação e refatoração."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Entender operações aritméticas e exceções numéricas.",
                                "Lógica: Aplicar raciocínio dedutivo para diagnóstico de falhas.",
                                "Inglês Técnico: Interpretar mensagens de erro em inglês.",
                                "Gestão de Projetos: Documentar bugs para equipes."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, debugging de atribuições previne crashes em apps bancários (evitar divisão por zero em cálculos financeiros) ou e-commerces (type mismatches em carrinhos de compra), economizando tempo e reduzindo custos de manutenção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Comandos de Entrada e Saída",
                    "description": "Leitura de dados de entrada e exibição de resultados de saída.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Comandos de Entrada de Dados",
                        "description": "Conceitos fundamentais sobre a leitura de dados fornecidos pelo usuário em linguagens procedimentais, utilizando comandos como 'leia' em pseudocódigo ou 'scanf/input' em C/Python.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar a necessidade de comandos de entrada",
                            "description": "Reconhecer situações em algoritmos onde é essencial capturar dados do usuário para processamento, diferenciando de valores fixos ou constantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Valores Fixos e Entrada de Usuário",
                                  "subSteps": [
                                    "Defina valores fixos (constantes) como dados pré-definidos no algoritmo, como π = 3.14.",
                                    "Defina comandos de entrada como mecanismos para capturar dados variáveis do usuário durante a execução.",
                                    "Compare exemplos: soma de 5 + 3 (fixo) vs. soma de dois números informados pelo usuário.",
                                    "Discuta cenários onde fixos são adequados (cálculos universais) e onde entrada é essencial (dados personalizados).",
                                    "Crie um fluxograma simples diferenciando os dois."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença com 2 exemplos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, quadro branco ou editor de texto simples.",
                                  "tips": "Use analogias cotidianas, como receita com ingredientes fixos vs. quantidades escolhidas pelo cozinheiro.",
                                  "learningObjective": "Diferenciar valores fixos de entradas de usuário em contextos algorítmicos.",
                                  "commonMistakes": "Confundir variáveis internas com entradas de usuário; assumir que toda variável precisa de input."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Algoritmos Simples para Identificar Necessidade de Entrada",
                                  "subSteps": [
                                    "Examine pseudocódigo de um algoritmo de cálculo de média: identifique se notas são fixas ou precisam de input.",
                                    "Marque linhas onde dados do usuário são necessários, como 'idade = input()'.",
                                    "Classifique algoritmos: fixos (ex: fatorial de 5) vs. interativos (ex: IMC com peso/altura do usuário).",
                                    "Crie uma tabela comparativa com 3 algoritmos, justificando a necessidade de input.",
                                    "Discuta por que inputs evitam rigidez em algoritmos reutilizáveis."
                                  ],
                                  "verification": "Tabela comparativa preenchida corretamente para 3 algoritmos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pseudocódigos impressos ou digitais, planilha simples (Excel/Google Sheets).",
                                  "tips": "Procure por 'dados variáveis' ou 'personalizáveis' como gatilhos para input.",
                                  "learningObjective": "Reconhecer padrões em pseudocódigo que demandam comandos de entrada.",
                                  "commonMistakes": "Ignorar reutilização: achar que inputs só são para jogos, não para cálculos práticos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Identificação em Cenários Reais",
                                  "subSteps": [
                                    "Analise 5 algoritmos variados (ex: conversor de temperatura, verificador de paridade, calculadora de descontos).",
                                    "Para cada um, decida: 'input necessário? Por quê?' e reescreva com input se aplicável.",
                                    "Simule execução mental: o que acontece sem input? (falha ou resultado fixo?).",
                                    "Agrupe cenários por tipo: pessoais (idade), medidas (dimensões), escolhas (opções de menu).",
                                    "Debata em duplas: valide decisões uns dos outros."
                                  ],
                                  "verification": "Relatório com 5 análises corretas, incluindo justificativas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Lista de 5 pseudocódigos exemplo, timer para simulação.",
                                  "tips": "Pergunte: 'O algoritmo funciona para múltiplos usuários sem alterar código?' Se sim, input é chave.",
                                  "learningObjective": "Aplicar identificação de inputs em algoritmos diversificados.",
                                  "commonMistakes": "Sobrestimar inputs: adicionar desnecessariamente em cálculos puramente matemáticos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Testar Conhecimento com Exercícios Avançados",
                                  "subSteps": [
                                    "Resolva 4 exercícios: identifique erros em códigos sem inputs onde necessários.",
                                    "Crie um algoritmo próprio (ex: calculadora de gorjeta) e justifique uso de inputs.",
                                    "Compare sua versão com uma fixa: discuta limitações.",
                                    "Autoavalie usando checklist: 'Diferenciei corretamente? Justifiquei?'",
                                    "Revise erros comuns dos steps anteriores."
                                  ],
                                  "verification": "Algoritmo próprio com inputs justificados e checklist completo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de pseudocódigo online (ex: Pseudocode.js), checklist impresso.",
                                  "tips": "Pense em escalabilidade: inputs tornam algoritmos 'universais'.",
                                  "learningObjective": "Consolidar habilidade criando e validando algoritmos com inputs apropriados.",
                                  "commonMistakes": "Não justificar: listar inputs sem explicar necessidade."
                                }
                              ],
                              "practicalExample": "Em um algoritmo para calcular o IMC (Índice de Massa Corporal), peso e altura devem ser capturados via input('Digite seu peso:') e input('Digite sua altura:'), pois variam por usuário, diferentemente de uma constante como gravidade (9.8 m/s²). Sem inputs, o algoritmo só serviria para um caso fixo, perdendo utilidade prática.",
                              "finalVerifications": [
                                "Explica corretamente a diferença entre valores fixos e inputs em 3 exemplos.",
                                "Identifica necessidade de input em 90% de 10 pseudocódigos testados.",
                                "Justifica decisões com foco em variabilidade e reutilização.",
                                "Cria um algoritmo simples com inputs apropriados sem erros.",
                                "Diferencia cenários interativos de computacionais puros.",
                                "Simula execução de algoritmo com e sem input, prevendo resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 80%+ acertos em análises.",
                                "Justificativas claras e lógicas (mínimo 2 razões por caso).",
                                "Uso correto de terminologia (input, constante, variável).",
                                "Criatividade em exemplos próprios relevantes.",
                                "Compreensão de impactos: discute limitações sem input.",
                                "Eficiência: completa steps no tempo estimado com qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reconhece variáveis em equações (ex: funções com parâmetros).",
                                "Lógica e Filosofia: Discute interatividade vs. determinismo em processos.",
                                "Estatística: Inputs para dados empíricos vs. valores teóricos fixos.",
                                "Design de UX: Necessidade de interação humana em sistemas.",
                                "Negócios: Personalização de software para usuários finais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps como calculadoras financeiras (input de salário para simular investimentos), jogos (input de nome/jogadas), ou sistemas de saúde (input de sintomas para triagem), onde dados do usuário tornam o software dinâmico e aplicável a múltiplos cenários reais, evitando hardcoding que limita escalabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Aplicar sintaxe básica de leitura de variáveis simples",
                            "description": "Escrever comandos de entrada para ler um valor inteiro ou real em uma variável, utilizando pseudocódigo (ex: leia N) ou equivalentes em C (scanf) e Python (input).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de variáveis e entrada de dados",
                                  "subSteps": [
                                    "Defina o que é uma variável e seus tipos básicos (inteiro e real/float).",
                                    "Explique a diferença entre entrada de dados e saída.",
                                    "Identifique cenários onde a entrada é necessária (ex: dados do usuário).",
                                    "Diferencie variáveis simples de compostas.",
                                    "Revise declaração de variáveis em diferentes linguagens."
                                  ],
                                  "verification": "Resuma em suas palavras o propósito da entrada de dados e liste 2 exemplos de tipos de variáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook ou papel para anotações",
                                    "Documentação básica de pseudocódigo, C e Python"
                                  ],
                                  "tips": "Sempre associe o conceito a um exemplo real, como ler a idade de uma pessoa.",
                                  "learningObjective": "Entender o papel das variáveis e comandos de entrada no fluxo de um programa.",
                                  "commonMistakes": [
                                    "Confundir entrada com saída",
                                    "Ignorar tipos de dados (int vs float)",
                                    "Não declarar variável antes de ler"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar sintaxe em pseudocódigo",
                                  "subSteps": [
                                    "Escreva a sintaxe básica: 'leia N' ou 'entrada N'.",
                                    "Pratique declarando variável primeiro: 'inteiro N; leia N'.",
                                    "Teste com valores inteiros e reais: 'real X; leia X'.",
                                    "Inclua prompt: 'escreva \"Digite um número: \"; leia N'.",
                                    "Compile mentalmente um fluxograma simples com entrada."
                                  ],
                                  "verification": "Escreva 3 exemplos corretos de leitura em pseudocódigo e valide com um colega ou online.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Ferramenta de fluxograma online (ex: Lucidchart)"
                                  ],
                                  "tips": "Use pseudocódigo para planejar antes de codificar em linguagens reais.",
                                  "learningObjective": "Aplicar sintaxe padrão de entrada em pseudocódigo de forma precisa.",
                                  "commonMistakes": [
                                    "Omitir declaração da variável",
                                    "Usar 'escreva' em vez de 'leia'",
                                    "Não especificar tipo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar sintaxe em C com scanf",
                                  "subSteps": [
                                    "Inclua <stdio.h> e declare main().",
                                    "Declare variável: int N; ou float X;.",
                                    "Escreva scanf(\"%d\", &N); para int e scanf(\"%f\", &X); para float.",
                                    "Adicione printf para prompt: printf(\"Digite: \"); scanf(...);.",
                                    "Compile e execute com gcc para testar."
                                  ],
                                  "verification": "Compile e rode um programa que leia um inteiro, sem erros ou warnings.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C (gcc ou online como Replit)",
                                    "Editor como VS Code"
                                  ],
                                  "tips": "Sempre use & antes da variável em scanf para passar o endereço.",
                                  "learningObjective": "Escrever e depurar comandos scanf corretos para variáveis simples.",
                                  "commonMistakes": [
                                    "Esquecer & na variável",
                                    "Usar %d para float",
                                    "Não incluir <stdio.h>",
                                    "Falta de ;"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar sintaxe em Python com input",
                                  "subSteps": [
                                    "Use input() básico: N = input().",
                                    "Converta para tipos: N = int(input()) ou X = float(input()).",
                                    "Adicione prompt: N = int(input('Digite um número: ')).",
                                    "Trate erros com try-except para entradas inválidas.",
                                    "Execute e teste com diferentes inputs."
                                  ],
                                  "verification": "Execute um script Python que leia e processe um valor real corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python instalado ou online (Google Colab)",
                                    "Editor como IDLE ou VS Code"
                                  ],
                                  "tips": "Lembre-se: input() sempre retorna string; converta explicitamente.",
                                  "learningObjective": "Utilizar input() com conversão de tipos de forma segura e eficiente.",
                                  "commonMistakes": [
                                    "Não converter string para int/float",
                                    "Ignorar ValueError em inputs inválidos",
                                    "Falta de prompt claro"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar integração e depuração",
                                  "subSteps": [
                                    "Crie um programa completo que leia 2 valores e some-os.",
                                    "Teste em pseudocódigo, C e Python.",
                                    "Depure erros comuns como tipos errados.",
                                    "Compare as sintaxes entre linguagens.",
                                    "Registre tempo de execução e inputs de teste."
                                  ],
                                  "verification": "Produza 3 programas funcionais (pseudo, C, Python) que leem e processam dados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Todos os materiais anteriores",
                                    "Lista de casos de teste (int, float, inválido)"
                                  ],
                                  "tips": "Teste com edge cases: 0, negativos, decimais.",
                                  "learningObjective": "Integrar comandos de entrada em programas funcionais e depurá-los.",
                                  "commonMistakes": [
                                    "Não testar com múltiplos inputs",
                                    "Misturar sintaxes de linguagens",
                                    "Ignorar tratamento de erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um programa que solicite a idade (inteiro) e altura (real) do usuário, armazene em variáveis e imprima: 'Você tem X anos e Y metros de altura.' Teste em pseudocódigo, C e Python.",
                              "finalVerifications": [
                                "Escreve corretamente 'leia N' em pseudocódigo.",
                                "Implementa scanf(\"%d\", &N) sem erros de compilação.",
                                "Usa N = int(input()) em Python e converte adequadamente.",
                                "Programa lê valores int e float corretamente em testes.",
                                "Trata prompts e erros básicos.",
                                "Compara sintaxes entre linguagens com precisão."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe em todas as linguagens (100%).",
                                "Adequação de tipos de dados (int/float).",
                                "Presença de prompts claros e tratamento de erros.",
                                "Compilação/execução sem falhas.",
                                "Eficiência e legibilidade do código.",
                                "Capacidade de depuração autônoma."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reconhecimento de números inteiros e reais.",
                                "Lógica: Fluxo de dados e processamento sequencial.",
                                "Português: Redação de prompts claros e instrutivos.",
                                "Física/Engenharia: Leitura de medidas reais em simulações."
                              ],
                              "realWorldApplication": "Em aplicativos interativos como calculadoras financeiras (ler valores monetários), sistemas de cadastro de usuários (idade, salário), jogos (pontuação do jogador) e ferramentas de análise de dados (input de parâmetros)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Ler múltiplas entradas em uma linha",
                            "description": "Implementar leitura de vários valores de entrada em uma única instrução, como múltiplos scanf ou input.split() em Python, associando a variáveis específicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o formato de entrada múltipla em uma linha",
                                  "subSteps": [
                                    "Analise exemplos de entrada como '10 20 30' onde valores são separados por espaços.",
                                    "Identifique que funções como input().split() em Python ou scanf em C leem até espaços ou quebras de linha.",
                                    "Diferencie entrada única de múltipla, notando que múltipla requer separadores.",
                                    "Pratique digitando entradas manuais em um editor para visualizar o formato.",
                                    "Estude documentação oficial de input() em Python ou scanf em C."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como uma linha '5 10.5 João' é parseada em três variáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Documentação Python/C online",
                                    "Terminal para testes"
                                  ],
                                  "tips": "Sempre considere espaços extras ou tabs como separadores comuns.",
                                  "learningObjective": "Entender o mecanismo de separação de entradas em uma única linha de input.",
                                  "commonMistakes": [
                                    "Confundir vírgulas com espaços como separadores",
                                    "Ignorar quebras de linha prematuras",
                                    "Assumir que input() lê tudo automaticamente sem split()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar leitura de múltiplos valores do mesmo tipo (ex: inteiros)",
                                  "subSteps": [
                                    "Escreva código Python: valores = list(map(int, input().split()))",
                                    "Atribua a variáveis específicas: a, b = map(int, input().split())",
                                    "Teste com input '3 7' e imprima os valores para confirmação.",
                                    "Adapte para C: scanf('%d %d', &a, &b); e compile/executar.",
                                    "Registre saídas em diferentes cenários de input."
                                  ],
                                  "verification": "Execute o código com input '10 20' e confirme que variáveis recebem valores corretos via print/printf.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como PyCharm ou VS Code",
                                    "Compilador C (opcional)",
                                    "Terminal"
                                  ],
                                  "tips": "Use map() para conversão automática em Python para evitar loops manuais.",
                                  "learningObjective": "Dominar sintaxe para ler e converter múltiplos inteiros de uma linha.",
                                  "commonMistakes": [
                                    "Esquecer map(int, ...) causando strings em vez de ints",
                                    "Não usar & em scanf para variáveis locais",
                                    "Não lidar com número errado de inputs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ler múltiplas entradas de tipos mistos (int, float, string)",
                                  "subSteps": [
                                    "Modifique código para input misto: nome, idade, nota = input().split(); idade = int(idade); nota = float(nota)",
                                    "Teste com 'João 25 8.5' e valide tipos com type() ou printf.",
                                    "Implemente em C: scanf('%s %d %f', nome, &idade, &nota);",
                                    "Adicione prints para exibir valores lidos corretamente.",
                                    "Experimente inputs inválidos para observar comportamentos."
                                  ],
                                  "verification": "Confirme que string, int e float são lidos corretamente de 'Ana 30 9.2' sem erros de tipo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com depurador",
                                    "Documentação de tipos de formatação scanf",
                                    "Amostras de input em arquivo .txt"
                                  ],
                                  "tips": "Em Python, split() retorna strings; converta explicitamente após.",
                                  "learningObjective": "Aplicar leitura e conversão para tipos heterogêneos em uma linha.",
                                  "commonMistakes": [
                                    "Usar %d para float em scanf",
                                    "Esquecer conversão float() para decimais",
                                    "Strings com espaços quebrando split()"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar entradas e integrar em um programa funcional",
                                  "subSteps": [
                                    "Adicione try-except em Python para inputs inválidos: try: a, b = map(int, input().split()) except: print('Erro')",
                                    "Em C, verifique retorno de scanf == número esperado de itens.",
                                    "Crie programa completo: leia 3 valores e processe (ex: soma ou média).",
                                    "Teste edge cases: inputs vazios, extras, não-numéricos.",
                                    "Depure e refine com base em erros observados."
                                  ],
                                  "verification": "Programa lida corretamente com 5 testes válidos e 3 inválidos, exibindo mensagens apropriadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script de testes .txt com casos variados",
                                    "Depurador IDE"
                                  ],
                                  "tips": "Sempre valide o número de itens lidos com len(split()) ou scanf return.",
                                  "learningObjective": "Incorporar validação robusta à leitura múltipla para uso prático.",
                                  "commonMistakes": [
                                    "Não tratar ValueError em Python",
                                    "Ignorar retorno de scanf < esperado",
                                    "Assumir input sempre perfeito"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de cadastro de aluno, leia em uma linha: 'Maria 20 7.5 9.0' para nome (string), idade (int), nota1 (float), nota2 (float). Calcule e imprima a média das notas.",
                              "finalVerifications": [
                                "Programa lê corretamente 4 valores mistos de uma linha sem erros.",
                                "Valores são convertidos para tipos corretos e exibidos.",
                                "Edge cases (ex: input inválido) são tratados com mensagens de erro.",
                                "Número exato de itens é validado.",
                                "Código funciona em múltiplas execuções com inputs variados.",
                                "Não há crashes ou loops infinitos."
                              ],
                              "assessmentCriteria": [
                                "Correção na sintaxe de split() e map() ou scanf.",
                                "Adequada conversão de tipos e atribuição a variáveis.",
                                "Presença de validação básica para inputs inválidos.",
                                "Eficiência: sem loops desnecessários para leitura simples.",
                                "Clareza: código comentado e variáveis nomeadas semanticamente.",
                                "Robustez: lida com espaços extras ou tabs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: parsing de dados numéricos e operações aritméticas pós-leitura.",
                                "Lógica e Algoritmos: tratamento de exceções e fluxos condicionais.",
                                "Inglês Técnico: leitura de documentação de funções input/scanf.",
                                "Design de Software: princípios de input validation em interfaces."
                              ],
                              "realWorldApplication": "Em ferramentas CLI como scripts de automação (ex: ler argumentos de configuração em linha única), parsers de logs, formulários web backend ou jogos que leem comandos jogador como 'mover 5 norte'."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Comandos de Saída de Dados",
                        "description": "Conceitos sobre a exibição de resultados processados para o usuário, usando comandos como 'escreva' em pseudocódigo ou 'printf/print' em C/Python.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Entender o propósito dos comandos de saída",
                            "description": "Diferenciar saída de resultados computados de entrada, identificando seu uso para apresentar informações formatadas ao usuário final.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de comandos de saída",
                                  "subSteps": [
                                    "Defina 'saída' como a ação de enviar dados processados do programa para o usuário via tela, arquivo ou dispositivo.",
                                    "Identifique que comandos de saída exibem resultados computados, não dados brutos de entrada.",
                                    "Revise exemplos simples como 'print' em Python ou 'cout' em C++.",
                                    "Note que a saída é unidirecional: do programa para o usuário.",
                                    "Discuta como a saída usa formatação para clareza (ex: quebras de linha, alinhamento)."
                                  ],
                                  "verification": "Escreva uma definição de 2-3 frases sobre comandos de saída e compartilhe com um colega para feedback.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE simples (ex: VS Code, IDLE)",
                                    "Documentação de sintaxe básica de print/printf"
                                  ],
                                  "tips": "Use analogia: saída é como falar com o público após processar pensamentos.",
                                  "learningObjective": "Definir precisamente o papel dos comandos de saída em um programa.",
                                  "commonMistakes": "Confundir saída com processamento interno (variáveis não exibidas não são saída)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar comandos de saída de comandos de entrada",
                                  "subSteps": [
                                    "Liste características da entrada: captura dados do usuário (ex: input(), scanf()).",
                                    "Liste características da saída: envia dados formatados para o usuário (ex: print(), printf()).",
                                    "Crie uma tabela comparativa: direção do fluxo, propósito, exemplos.",
                                    "Analise um fluxograma simples de programa: entrada → processamento → saída.",
                                    "Teste conceitualmente: 'O que acontece sem saída? O programa \"funciona\", mas usuário não vê resultados.'"
                                  ],
                                  "verification": "Preencha uma tabela comparativa e explique verbalmente a diferença em 1 minuto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela",
                                    "Exemplos de código com input/print lado a lado"
                                  ],
                                  "tips": "Lembre: entrada = 'escutar', saída = 'falar'.",
                                  "learningObjective": "Distinguir entrada de saída por fluxo de dados e função.",
                                  "commonMistakes": "Achar que saída modifica variáveis (ela só exibe)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar usos dos comandos de saída para apresentação formatada",
                                  "subSteps": [
                                    "Explore opções de formatação: strings, números decimais, alinhamento.",
                                    "Identifique propósitos: debug (mostrar variáveis), relatórios (tabelas), interatividade (mensagens).",
                                    "Analise código real: como print formata soma de números.",
                                    "Discuta por que formatação importa: legibilidade para usuário final.",
                                    "Pratique mentalmente: 'Como formatar uma lista de notas para relatório escolar?'"
                                  ],
                                  "verification": "Descreva 3 usos formatados de saída em cenários cotidianos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Amostras de código com formatação (ex: f-strings em Python)",
                                    "Calculadora para simular dados"
                                  ],
                                  "tips": "Sempre pergunte: 'Isso é legível para um não-programador?'",
                                  "learningObjective": "Reconhecer como saída apresenta informações de forma acessível.",
                                  "commonMistakes": "Ignorar formatação, resultando em saída bagunçada (ex: números colados)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o entendimento em um exemplo integrado",
                                  "subSteps": [
                                    "Escreva um programa simples: entrada de dois números, soma, saída formatada.",
                                    "Execute e observe: entrada captura, saída mostra resultado.",
                                    "Modifique para diferentes formatos (ex: 'Soma: 10' vs tabela).",
                                    "Explique o fluxo: 'Entrada alimenta processamento, saída informa usuário.'",
                                    "Reflita: 'Sem saída, usuário ignora o resultado computado.'"
                                  ],
                                  "verification": "Execute o programa e capture screenshot da saída formatada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com linguagem procedural (Python ou C)",
                                    "Dois números de teste"
                                  ],
                                  "tips": "Comece simples; adicione formatação só após funcionalidade básica.",
                                  "learningObjective": "Integrar conceito de saída em um programa completo.",
                                  "commonMistakes": "Esquecer de processar dados antes de saída (ex: imprimir inputs diretamente)."
                                }
                              ],
                              "practicalExample": "Em um programa de calculadora simples: use input() para capturar dois números do usuário, compute a soma no processamento, e use print('A soma de {} e {} é {}') para exibir o resultado formatado, permitindo que o usuário veja claramente o output computado.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre entrada e saída em menos de 1 minuto.",
                                "Identificar corretamente o comando de saída em um trecho de código fornecido.",
                                "Descrever 3 propósitos de formatação em saída.",
                                "Executar um programa teste e confirmar que saída mostra resultados processados.",
                                "Criar uma tabela comparativa precisa de entrada vs saída.",
                                "Explicar por que saída é essencial para o usuário final."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta sem confusões com entrada/processamento (30%).",
                                "Profundidade de diferenciação: tabela ou explicação clara de entrada vs saída (25%).",
                                "Compreensão de formatação: exemplos relevantes de uso prático (20%).",
                                "Aplicação prática: programa executável com saída correta (15%).",
                                "Reflexão: identificação de erros comuns evitados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Formatação de resultados numéricos (ex: decimais, porcentagens).",
                                "Comunicação: Criação de mensagens claras e acessíveis para públicos leigos.",
                                "Design de Interfaces: Princípios básicos de UI para apresentação de dados.",
                                "Lógica: Fluxo de dados em algoritmos (entrada-processamento-saída)."
                              ],
                              "realWorldApplication": "Em aplicativos como caixas eletrônicos (ATMs), que recebem PIN (entrada), processam saldo e exibem extrato formatado (saída); ou em relatórios de vendas de e-commerce, mostrando totais calculados de forma legível para clientes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Implementar saída básica de variáveis",
                            "description": "Utilizar comandos para exibir o valor de uma variável simples, como escreva(N) em pseudocódigo, printf em C ou print em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de saída de variáveis",
                                  "subSteps": [
                                    "Leia a definição de 'saída de variáveis': exibir o valor armazenado em uma variável usando comandos específicos da linguagem.",
                                    "Compare exemplos: escreva(N) em pseudocódigo, printf(\"%d\", N) em C, print(N) em Python.",
                                    "Identifique a diferença entre saída de texto fixo e saída de variável.",
                                    "Anote em um caderno: 'Saída de variável permite mostrar dados dinâmicos processados pelo programa.'",
                                    "Pesquise documentação rápida da linguagem escolhida (ex: Python print)."
                                  ],
                                  "verification": "Resuma em 2 frases o que aprendeu e compartilhe com um colega ou anote corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação da linguagem (Python/C/pseudocódigo)",
                                    "Caderno ou editor de texto"
                                  ],
                                  "tips": "Use analogia: variável é como uma caixa com um valor; saída é abrir a caixa para mostrar o conteúdo.",
                                  "learningObjective": "Compreender o propósito e sintaxe básica de comandos de saída de variáveis.",
                                  "commonMistakes": [
                                    "Confundir saída de variável com saída de string fixa",
                                    "Ignorar que variáveis precisam ser declaradas antes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e inicializar uma variável simples",
                                  "subSteps": [
                                    "Escolha uma linguagem (ex: Python).",
                                    "Abra um editor de código (ex: VS Code, IDLE).",
                                    "Declare uma variável: nome = valor (ex: idade = 25).",
                                    "Salve o arquivo como 'saida_variavel.py'.",
                                    "Teste digitando o nome da variável no interpretador para ver o valor."
                                  ],
                                  "verification": "A variável é reconhecida sem erros ao acessá-la isoladamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Interpretador Python instalado"
                                  ],
                                  "tips": "Use nomes descritivos como 'numero' em vez de 'x' para clareza.",
                                  "learningObjective": "Criar uma variável com valor atribuído corretamente.",
                                  "commonMistakes": [
                                    "Esquecer aspas em strings",
                                    "Usar = em vez de == para atribuição (em C)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o comando de saída da variável",
                                  "subSteps": [
                                    "Adicione o comando de saída após a declaração: print(idade) em Python.",
                                    "Para C: inclua #include <stdio.h>, main() { int idade=25; printf(\"%d\\n\", idade); }.",
                                    "Em pseudocódigo: escreva(idade).",
                                    "Comente o código explicando cada linha.",
                                    "Salve e revise sintaxe."
                                  ],
                                  "verification": "Código completo sem erros de sintaxe visíveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Referência de sintaxe da linguagem"
                                  ],
                                  "tips": "Sempre termine print com parênteses e vírgula se múltiplos argumentos.",
                                  "learningObjective": "Integrar comando de saída com variável de forma sintaticamente correta.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em print",
                                    "Usar aspas duplas em vez de especificador %d em printf"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, depurar e verificar a saída",
                                  "subSteps": [
                                    "Execute o programa: python saida_variavel.py ou gcc arquivo.c -o exec && ./exec.",
                                    "Observe a saída no terminal: deve mostrar '25'.",
                                    "Altere o valor da variável e reexecute para confirmar mudança.",
                                    "Se erro, identifique (ex: NameError) e corrija.",
                                    "Capture screenshot da saída correta."
                                  ],
                                  "verification": "Saída exibe exatamente o valor da variável sem erros extras.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal ou IDE com executor",
                                    "Captura de tela"
                                  ],
                                  "tips": "Use print('Valor:', idade) para saída mais legível.",
                                  "learningObjective": "Executar programa e validar saída de variável dinamicamente.",
                                  "commonMistakes": [
                                    "Não salvar arquivo antes de executar",
                                    "Ignorar quebras de linha em printf"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\nidade = 25\nprint('Minha idade é:', idade)\nSaída esperada: Minha idade é: 25\n\nEm C:\n#include <stdio.h>\nint main() {\n    int idade = 25;\n    printf(\"Minha idade é: %d\\n\", idade);\n    return 0;\n}",
                              "finalVerifications": [
                                "Programa compila/executa sem erros de sintaxe.",
                                "Saída exibe o valor exato da variável declarada.",
                                "Alteração no valor da variável reflete na saída.",
                                "Comentários explicam o código.",
                                "Screenshot ou log da execução salva.",
                                "Testado em pelo menos duas linguagens (pseudocódigo e Python/C)."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe do comando de saída 100% correta.",
                                "Variável declarada e inicializada antes da saída.",
                                "Saída clara e sem lixo (ex: aspas extras).",
                                "Código comentado e indentado.",
                                "Execução bem-sucedida com valor dinâmico.",
                                "Depuração de pelo menos um erro comum demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de valores numéricos em variáveis.",
                                "Língua Portuguesa: Formatação clara de mensagens de saída.",
                                "Física/Engenharia: Saída de dados em simulações (ex: velocidade).",
                                "Artes: Design de interfaces de saída legíveis.",
                                "Estatística: Exibição de resultados de cálculos."
                              ],
                              "realWorldApplication": "Em aplicativos reais, como exibir saldo em apps bancários (print(saldo)), logs de erros em sistemas (printf(error_code)), ou relatórios em dashboards web (console.log(variavel)), permitindo feedback imediato ao usuário ou desenvolvedor."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Formatar saídas com texto e múltiplas variáveis",
                            "description": "Combinar textos literais com valores de variáveis em uma saída formatada, utilizando placeholders como %d em printf ou f-strings em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de formatação de saídas",
                                  "subSteps": [
                                    "Identificar strings literais como texto fixo na saída.",
                                    "Reconhecer placeholders como %d para inteiros, %s para strings e %f para floats.",
                                    "Diferenciar formatação em linguagens procedimentais (ex: printf em C) de modernas (ex: f-strings em Python).",
                                    "Analisar exemplos simples de substituição de uma variável única.",
                                    "Listar vantagens da formatação sobre concatenação direta."
                                  ],
                                  "verification": "Resuma em uma tabela os tipos de placeholders comuns e seus usos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação de printf ou f-strings (online)",
                                    "Bloco de notas para anotações"
                                  ],
                                  "tips": "Comece com exemplos visuais comparando saída formatada vs. não formatada.",
                                  "learningObjective": "Dominar os fundamentos de placeholders e strings literais para preparar formatações complexas.",
                                  "commonMistakes": "Confundir tipos de placeholders (ex: usar %d para string causa erro de compilação)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender sintaxe de formatação com texto literal e uma variável",
                                  "subSteps": [
                                    "Estudar a sintaxe básica: printf(\"Texto %d\", variavel); ou print(f\"Texto {variavel}\").",
                                    "Escrever código para formatar uma string com um inteiro (ex: \"Idade: %d\", idade).",
                                    "Testar com diferentes tipos: string, float e inteiro.",
                                    "Compilar/executar e observar a saída no console.",
                                    "Modificar o texto literal para incluir vírgulas ou pontos."
                                  ],
                                  "verification": "Produza saídas corretas para 3 exemplos com um placeholder cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou IDLE)",
                                    "Compilador C/GCC ou interpretador Python"
                                  ],
                                  "tips": "Use aspas duplas para strings e inclua \\n para quebras de linha.",
                                  "learningObjective": "Aplicar sintaxe básica para combinar texto fixo com uma variável única.",
                                  "commonMistakes": "Esquecer a vírgula após a string ou não passar argumentos suficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar formatação com múltiplas variáveis",
                                  "subSteps": [
                                    "Definir múltiplas variáveis (ex: nome string, idade int, altura float).",
                                    "Construir string com vários placeholders: \"Olá %s, %d anos, %.2f m\".",
                                    "Passar argumentos na ordem correta para printf ou f-string.",
                                    "Experimentar alinhamento e precisão (ex: %10s para largura fixa).",
                                    "Executar e ajustar para saídas alinhadas."
                                  ],
                                  "verification": "Gere saída formatada corretamente com pelo menos 3 variáveis diferentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Numere os placeholders mentalmente para garantir ordem correta dos argumentos.",
                                  "learningObjective": "Manipular múltiplos placeholders e variáveis em uma única saída formatada.",
                                  "commonMistakes": "Invertendo a ordem dos argumentos, causando dados incorretos na saída."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, debugar e otimizar formatações complexas",
                                  "subSteps": [
                                    "Criar programa com input de usuário para variáveis.",
                                    "Formatar saída dinâmica com texto e 4+ variáveis.",
                                    "Identificar erros comuns como mismatch de tipos ou overflows.",
                                    "Usar debuggers ou prints intermediários para verificar.",
                                    "Otimizar para legibilidade (espaçamentos, casas decimais)."
                                  ],
                                  "verification": "Programa roda sem erros e produz saída formatada personalizada para inputs variados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor com debugger",
                                    "Exemplos de código testados"
                                  ],
                                  "tips": "Sempre teste com valores extremos (0, negativos, decimais longos).",
                                  "learningObjective": "Garantir robustez em formatações com múltiplas variáveis via testes e correções.",
                                  "commonMistakes": "Não especificar precisão em floats, resultando em saídas bagunçadas."
                                }
                              ],
                              "practicalExample": "Escreva um programa em C ou Python que leia nome (string), idade (int), salário (float) e anos de empresa (int), e imprima: \"Funcionário: [nome], Idade: [idade] anos, Salário: R$ [salário com 2 decimais], Tempo: [anos] anos na empresa.\" Exemplo de saída: \"Funcionário: João Silva, Idade: 30 anos, Salário: R$ 2500.50, Tempo: 5 anos na empresa.\"",
                              "finalVerifications": [
                                "Saída exata combina texto literal com valores de todas as variáveis sem erros de formatação.",
                                "Programa aceita inputs variados e mantém formatação consistente (alinhamento, decimais).",
                                "Nenhum erro de compilação/execução ou warning sobre tipos de placeholders.",
                                "Substituição correta de múltiplos placeholders na ordem esperada.",
                                "Saída inclui quebras de linha ou espaçamentos para legibilidade quando aplicável.",
                                "Testes com valores edge cases (ex: nome com espaços, float zero) funcionam perfeitamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe de placeholders e ordem de argumentos (100% correto).",
                                "Integração fluida de texto literal com variáveis formatadas.",
                                "Tratamento adequado de diferentes tipos de dados (string, int, float).",
                                "Legibilidade da saída final (alinhamento, precisão de decimais).",
                                "Robustez: ausência de crashes ou saídas incorretas em testes variados.",
                                "Eficiência: código limpo sem redundâncias ou concatenações desnecessárias.",
                                "Criatividade: uso opcional de formatações avançadas como largura ou precisão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Controle de precisão em números decimais e alinhamento numérico.",
                                "Língua Portuguesa: Construção de frases coerentes com texto literal e variáveis.",
                                "Artes/Design: Formatação visual para saídas estéticas e legíveis.",
                                "Lógica/Algoritmos: Sequênciação de argumentos e tratamento de erros.",
                                "Comunicação: Geração de relatórios personalizados e claros."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software para gerar relatórios personalizados (ex: extratos bancários com nome, saldo e data), logs de sistemas com timestamps e valores variáveis, interfaces de usuário em apps/games mostrando scores e nomes de jogadores, ou automação de emails/SMS com dados dinâmicos de clientes."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.4",
                            "name": "Exibir saídas em múltiplas linhas",
                            "description": "Controlar quebras de linha e múltiplas instruções de saída para apresentar resultados organizados, como em relatórios simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender saídas em linha única e necessidade de múltiplas linhas",
                                  "subSteps": [
                                    "Execute um programa simples com print de múltiplos dados em uma única linha e observe o resultado desorganizado.",
                                    "Analise exemplos de relatórios reais (como lista de alunos) que precisam de formatação em linhas separadas.",
                                    "Identifique problemas comuns: texto corrido, difícil leitura e falta de estrutura.",
                                    "Discuta em pseudocódigo ou Python como uma saída única falha para dados múltiplos.",
                                    "Registre observações em um diário de aprendizado."
                                  ],
                                  "verification": "Você pode explicar verbalmente ou por escrito por que saídas em uma linha só são inadequadas para relatórios.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor de código (ex: IDLE ou VS Code)",
                                    "Navegador para exemplos de relatórios"
                                  ],
                                  "tips": "Use exemplos do dia a dia, como listas de compras, para visualizar melhor.",
                                  "learningObjective": "Reconhecer limitações de saídas lineares e justificar uso de múltiplas linhas.",
                                  "commonMistakes": [
                                    "Ignorar legibilidade em relatórios reais",
                                    "Confundir com formatação horizontal (espaços)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar quebras de linha com caractere de escape \\n",
                                  "subSteps": [
                                    "Aprenda a sintaxe: print('Linha1\\nLinha2') em Python ou equivalente em linguagens procedimentais.",
                                    "Escreva e execute um código com 3-4 linhas de texto usando \\n em uma única instrução print.",
                                    "Teste variações: múltiplos \\n, texto com variáveis (ex: print('Nome: ' + nome + '\\nIdade: ' + idade)).",
                                    "Adicione espaços ou tabs para alinhamento básico após quebras.",
                                    "Salve o código e compare saída com expectativa."
                                  ],
                                  "verification": "A saída no console mostra texto claramente separado em múltiplas linhas sem erros de sintaxe.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Ambiente de programação Python",
                                    "Documentação de print (help(print))"
                                  ],
                                  "tips": "Escape \\n corretamente; teste em console interativo para feedback imediato.",
                                  "learningObjective": "Dominar o uso de \\n para controlar quebras em uma única instrução de saída.",
                                  "commonMistakes": [
                                    "Esquecer as aspas duplas no \\n",
                                    "Usar /n em vez de \\n",
                                    "Não concatenar variáveis corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Utilizar múltiplas instruções de saída para maior controle",
                                  "subSteps": [
                                    "Escreva um programa com 3-5 comandos print separados, cada um para uma linha específica.",
                                    "Inclua variáveis dinâmicas em cada print (ex: print('Total: ', total)).",
                                    "Experimente print() vazio para linhas em branco intencionais.",
                                    "Compare com método \\n: discuta vantagens (facilidade de edição, modularidade).",
                                    "Adicione loops simples para gerar múltiplas linhas dinâmicas (ex: lista de itens)."
                                  ],
                                  "verification": "Execute o código e confirme que cada print produz uma linha distinta, com formatação limpa.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Lista de dados de teste (ex: nomes e notas)"
                                  ],
                                  "tips": "Mantenha indentação consistente no código para facilitar manutenção futura.",
                                  "learningObjective": "Aplicar múltiplos prints para saídas modulares e escaláveis.",
                                  "commonMistakes": [
                                    "Adicionar ; no final de print em Python (sintaxe errada)",
                                    "Esquecer print() para linhas vazias",
                                    "Não alinhar texto entre linhas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar e refinar um relatório simples completo",
                                  "subSteps": [
                                    "Desenhe um relatório modelo (ex: cabeçalho, dados, rodapé) em papel.",
                                    "Implemente combinando \\n e múltiplos prints com variáveis e cálculos simples.",
                                    "Teste com dados variados e ajuste formatação (alinhamento com espaços).",
                                    "Depure erros comuns como quebras indesejadas ou desalinhamento.",
                                    "Documente o código com comentários explicando escolhas de formatação."
                                  ],
                                  "verification": "O relatório gerado é legível, organizado em múltiplas linhas e reflete dados corretamente.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Papel para esboço",
                                    "Dados fictícios em arquivo TXT"
                                  ],
                                  "tips": "Use f-strings em Python moderno para formatação fácil: print(f'Nome: {nome}').",
                                  "learningObjective": "Integrar técnicas para produzir saídas profissionais e organizadas.",
                                  "commonMistakes": [
                                    "Formatação inconsistente entre linhas",
                                    "Ignorar testes com dados longos",
                                    "Misturar métodos sem propósito claro"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa em Python que gere um relatório de aluno: print('RELATÓRIO DE ALUNO'); print('Nome: Maria Silva'); print('Nota1: 8.5'); print('Nota2: 7.0'); print('Média: 7.75'); print('\\nAprovada!') ou usando \\n: print('RELATÓRIO DE ALUNO\\nNome: Maria Silva\\nNota1: 8.5\\nNota2: 7.0\\nMédia: 7.75\\n\\nAprovada!'). Execute e observe a saída organizada em linhas.",
                              "finalVerifications": [
                                "Saída exibe pelo menos 4 linhas distintas sem texto corrido.",
                                "Quebras de linha são controladas intencionalmente (\\n ou múltiplos prints).",
                                "Variáveis são integradas corretamente sem erros de concatenação.",
                                "Formatação visual é limpa, com alinhamento opcional.",
                                "Programa roda sem erros de sintaxe ou runtime.",
                                "Relatório simula uso real, como lista de itens."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe de comandos de saída (100% correto).",
                                "Organização e legibilidade da saída gerada (nota visual).",
                                "Eficiência: equilíbrio entre \\n e múltiplos prints.",
                                "Integração de variáveis e cálculos simples.",
                                "Ausência de erros comuns e depuração demonstrada.",
                                "Criatividade na formatação para relatórios."
                              ],
                              "crossCurricularConnections": [
                                "Língua Portuguesa: Estrutura de textos e parágrafos claros.",
                                "Design Gráfico: Layout e alinhamento visual em documentos.",
                                "Matemática: Formatação de tabelas e cálculos em relatórios.",
                                "Comunicação: Apresentação organizada de informações."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software para gerar logs de erros em múltiplas linhas, relatórios consolidados em consoles de servidores, interfaces de texto em aplicativos bancários ou sistemas de ponto de venda que imprimem recibos formatados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Estruturas Condicionais",
                    "description": "Comandos if-else para execução condicional de blocos de código.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Comando if simples",
                        "description": "Estrutura condicional básica que executa um bloco de código apenas se uma condição booleana for verdadeira.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Identificar a sintaxe do comando if",
                            "description": "Reconhecer a estrutura sintática do comando if em linguagens procedimentais, incluindo a palavra-chave 'if', a condição entre parênteses e o bloco de código delimitado por chaves ou indentação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Componentes Essenciais da Sintaxe if",
                                  "subSteps": [
                                    "Identificar a palavra-chave 'if' como o início do comando.",
                                    "Reconhecer a condição lógica colocada entre parênteses '()'.",
                                    "Localizar o bloco de código executado se a condição for verdadeira, delimitado por chaves {} ou indentação."
                                  ],
                                  "verification": "Liste verbalmente ou por escrito os três componentes principais em um exemplo dado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de código em Python e C",
                                    "Editor de texto simples"
                                  ],
                                  "tips": [
                                    "Sempre comece procurando pela palavra 'if' minúscula.",
                                    "Lembre-se: condições usam operadores como >, ==, &&."
                                  ],
                                  "learningObjective": "Reconhecer e nomear os três elementos fundamentais da sintaxe if.",
                                  "commonMistakes": [
                                    "Confundir 'if' com 'else' ou 'while'.",
                                    "Ignorar a obrigatoriedade dos parênteses em linguagens como C/Java."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Variações de Sintaxe em Diferentes Linguagens",
                                  "subSteps": [
                                    "Examinar sintaxe com chaves em C/Java: if (condição) { código; }",
                                    "Estudar sintaxe com indentação em Python: if condição: código indentado",
                                    "Comparar delimitadores: chaves vs. indentação de 4 espaços."
                                  ],
                                  "verification": "Destaque as diferenças entre um exemplo de C e Python.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de Python e C",
                                    "Snippets de código pré-prontos"
                                  ],
                                  "tips": [
                                    "Teste colando código em um interpretador para ver erros de sintaxe.",
                                    "Note que Python é sensível a indentação."
                                  ],
                                  "learningObjective": "Diferenciar sintaxes de if em linguagens procedimentais comuns.",
                                  "commonMistakes": [
                                    "Usar chaves em Python.",
                                    "Esquecer ponto e vírgula em C após condição."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Identificação em Códigos Reais",
                                  "subSteps": [
                                    "Ler um código fonte e circular todos os comandos if.",
                                    "Identificar condição e bloco para cada if encontrado.",
                                    "Anotar se usa chaves ou indentação."
                                  ],
                                  "verification": "Apresente um código anotado com pelo menos 3 ifs identificados corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Códigos de exemplo de programas simples (hello world com if)",
                                    "Marcador ou editor com highlight"
                                  ],
                                  "tips": [
                                    "Ignore comentários e foque em estruturas executáveis.",
                                    "Leia linha por linha sequencialmente."
                                  ],
                                  "learningObjective": "Aplicar reconhecimento de sintaxe if em trechos de código autênticos.",
                                  "commonMistakes": [
                                    "Marcar estruturas aninhadas como separadas.",
                                    "Confundir if com funções que têm parênteses."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Corrigir Sintaxes Incorretas",
                                  "subSteps": [
                                    "Analisar códigos com erros comuns, como if sem parênteses.",
                                    "Corrigir adicionando delimitadores faltantes.",
                                    "Verificar se o código corrigido compila ou roda sem erros de sintaxe."
                                  ],
                                  "verification": "Corrija 3 exemplos errados e explique as mudanças.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de 5 códigos if com erros propositais",
                                    "Compilador online como Replit ou IDE"
                                  ],
                                  "tips": [
                                    "Use ferramentas de linting para validar correções.",
                                    "Erros de sintaxe param a compilação - teste sempre."
                                  ],
                                  "learningObjective": "Detectar e corrigir violações da sintaxe if.",
                                  "commonMistakes": [
                                    "Adicionar else prematuramente.",
                                    "Confundir sintaxe de atribuição (=) com comparação (==)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: if (idade >= 18): print('Maior de idade'); else: print('Menor'); Em C: if (idade >= 18) { printf(\"Maior de idade\"); } else { printf(\"Menor\"); } - Identifique: 'if', (condição), bloco { ou indentado }.",
                              "finalVerifications": [
                                "Identifica corretamente 'if', condição e bloco em 5 exemplos variados.",
                                "Diferencia sintaxe com chaves vs. indentação.",
                                "Corrige 80% de erros sintáticos em códigos dados.",
                                "Explica verbalmente a estrutura para um par.",
                                "Passa em quiz de 10 questões sobre sintaxe if."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação dos 3 componentes (100%).",
                                "Correta distinção entre linguagens (90%).",
                                "Capacidade de correção de erros (85%).",
                                "Explicação clara e concisa da sintaxe.",
                                "Aplicação em contextos reais sem hesitação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expressões booleanas e lógica proposicional.",
                                "Língua Portuguesa: Leitura e interpretação de textos técnicos.",
                                "Física/Engenharia: Modelagem de decisões condicionais em simulações.",
                                "Artes: Visualização de fluxogramas para estruturas if."
                              ],
                              "realWorldApplication": "Em apps de e-commerce, if verifica estoque: if (estoque > 0) { processa_pedido(); } evitando vendas sem produto; essencial em automação de decisões como autenticação de usuários ou controles de tráfego em sistemas embarcados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Escrever um programa com if simples",
                            "description": "Criar um algoritmo e código fonte simples que utilize o comando if para executar uma ação condicional, como verificar se um número é positivo e exibir uma mensagem apropriada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de estrutura condicional if simples",
                                  "subSteps": [
                                    "Estude a sintaxe básica do comando if em uma linguagem procedural como Python: if condição: ação",
                                    "Identifique que o if executa o bloco de código apenas se a condição for verdadeira (True)",
                                    "Diferencie if simples de if-else, focando em execução condicional sem alternativa obrigatória",
                                    "Analise exemplos básicos, como if idade >= 18: print('Maior de idade')",
                                    "Pratique mentalmente condições comuns: maior que (>), menor que (<), igual (==)"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a sintaxe e propósito do if simples com um exemplo próprio",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de Python sobre if (oficial ou tutorial online)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Visualize o fluxo com setas: Condição verdadeira → executa bloco; falsa → pula",
                                  "learningObjective": "Dominar a sintaxe e lógica fundamental do if simples",
                                  "commonMistakes": [
                                    "Confundir == com =",
                                    "Esquecer os dois pontos (:) após a condição",
                                    "Indentação incorreta no bloco if"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar o algoritmo usando pseudocódigo ou fluxograma",
                                  "subSteps": [
                                    "Defina o problema: entrada (número), processamento (verificar se > 0), saída (mensagem)",
                                    "Escreva pseudocódigo: ler número; se número > 0 então exibir 'positivo' senão 'não positivo'",
                                    "Desenhe um fluxograma simples: início → input → decisão (num > 0?) → sim/não → output → fim",
                                    "Valide o algoritmo manualmente com 3 valores de teste: positivo (5), negativo (-3), zero (0)",
                                    "Ajuste o pseudocódigo para incluir mensagem apropriada para cada caso"
                                  ],
                                  "verification": "Pseudocódigo ou fluxograma completo e validado com testes manuais sem erros lógicos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta online como draw.io para fluxograma",
                                    "Modelo de pseudocódigo"
                                  ],
                                  "tips": "Sempre inclua entradas, processamento e saídas no planejamento para evitar omissões",
                                  "learningObjective": "Desenvolver habilidade de decompor problemas em algoritmos condicionais",
                                  "commonMistakes": [
                                    "Ignorar casos de borda como zero",
                                    "Não especificar tipos de dados (int/float)",
                                    "Fluxograma sem caminhos para todas as condições"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever o código fonte completo",
                                  "subSteps": [
                                    "Abra um editor de código (ex: VS Code, IDLE) e configure o ambiente Python",
                                    "Implemente a entrada: num = float(input('Digite um número: '))",
                                    "Adicione a estrutura if: if num > 0: print('O número é positivo.') else: print('O número não é positivo.')",
                                    "Inclua comentários explicando cada linha",
                                    "Salve o arquivo como 'verifica_positivo.py'"
                                  ],
                                  "verification": "Código salvo sem erros de sintaxe ao executar python verifica_positivo.py",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python instalado (versão 3.x)",
                                    "Editor de código como VS Code ou PyCharm Community"
                                  ],
                                  "tips": "Use input() com float() para números decimais; teste indentação com 4 espaços",
                                  "learningObjective": "Traduzir pseudocódigo em código executável com if simples",
                                  "commonMistakes": [
                                    "Erro de sintaxe nos dois pontos ou indentação",
                                    "Usar print sem parênteses em Python 2",
                                    "Não tratar input como string inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e documentar o programa",
                                  "subSteps": [
                                    "Execute o programa 5 vezes com inputs variados: positivos, negativos, zero, decimais",
                                    "Registre saídas esperadas vs. reais em uma tabela simples",
                                    "Corrija bugs identificados (ex: lógica de zero)",
                                    "Adicione docstring no topo: 'Programa verifica se número é positivo'",
                                    "Compartilhe o código em um repositório ou envie para revisão"
                                  ],
                                  "verification": "Programa passa em todos os testes com saídas corretas e documentação incluída",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal ou prompt de comando",
                                    "Planilha para tabela de testes"
                                  ],
                                  "tips": "Use print() extras temporários para depurar valores de variáveis",
                                  "learningObjective": "Garantir robustez do código através de testes sistemáticos",
                                  "commonMistakes": [
                                    "Não testar casos de borda",
                                    "Ignorar mensagens de erro do interpretador",
                                    "Documentação incompleta"
                                  ]
                                }
                              ],
                              "practicalExample": "```python\n# Programa: Verifica se um número é positivo\nnum = float(input('Digite um número: '))\nif num > 0:\n    print('O número é positivo.')\nelse:\n    print('O número não é positivo (zero ou negativo).')\n```\nExemplo de execução:\nInput: 5 → Output: O número é positivo.\nInput: -2 → Output: O número não é positivo (zero ou negativo).",
                              "finalVerifications": [
                                "Programa executa sem erros de sintaxe ou runtime para múltiplos inputs",
                                "Condição if avalia corretamente números positivos (>0)",
                                "Mensagem apropriada exibida para números não positivos (≤0)",
                                "Entrada aceita números inteiros e decimais",
                                "Código inclui comentários e docstring explicativos",
                                "Testes manuais documentados com pelo menos 5 casos"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe do if simples correta (condição, :, indentação)",
                                "Lógica condicional implementa verificação exata do problema",
                                "Entrada/saída funcionam conforme especificado",
                                "Código limpo, legível com comentários adequados",
                                "Tratamento implícito de casos de borda (zero, negativos)",
                                "Eficiência: código simples sem loops ou estruturas desnecessárias"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Compreensão de desigualdades (>0) e números reais",
                                "Lógica: Proposições condicionais e tabelas-verdade básicas",
                                "Língua Portuguesa: Redação clara de mensagens de saída",
                                "Ética em Computação: Validação de inputs para evitar crashes"
                              ],
                              "realWorldApplication": "Validação de formulários web (ex: idade para cadastro), controle de estoque (ex: se saldo > 0, permitir venda), jogos simples (ex: se pontos > 100, nível up), automação residencial (ex: se temperatura > 30, ligar ventilador)"
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Depurar erros em comandos if simples",
                            "description": "Identificar e corrigir erros comuns em estruturas if, como falta de parênteses na condição, chaves ausentes ou operadores lógicos incorretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a sintaxe correta do comando if simples",
                                  "subSteps": [
                                    "Estude a estrutura padrão: if (condição) { bloco de código }",
                                    "Identifique componentes obrigatórios: parênteses na condição, chaves delimitando o bloco",
                                    "Revise operadores lógicos comuns: && (AND), || (OR), ! (NOT)",
                                    "Anote exemplos válidos em um editor de texto",
                                    "Compare com documentação da linguagem para confirmação"
                                  ],
                                  "verification": "Recite verbalmente ou escreva a sintaxe correta sem consultar materiais",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação da linguagem (ex: manual de C ou Python)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Sempre inclua parênteses na condição, mesmo se opcionais em algumas linguagens",
                                  "learningObjective": "Compreender e memorizar a sintaxe exata do if simples",
                                  "commonMistakes": [
                                    "Omitir parênteses na condição",
                                    "Confundir chaves {} com ponto e vírgula",
                                    "Usar operadores bitwise (&, |) em vez de lógicos (&&, ||)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a condição do if para erros comuns",
                                  "subSteps": [
                                    "Execute o código e anote a mensagem de erro exibida",
                                    "Verifique se há parênteses ausentes ou mal posicionados na condição",
                                    "Inspecione operadores lógicos: substitua temporariamente por valores booleanos para testar",
                                    "Procure variáveis indefinidas ou tipos incorretos na condição",
                                    "Registre cada erro encontrado em uma lista numerada"
                                  ],
                                  "verification": "Liste todos os erros na condição identificados, com citação exata do código",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código com depurador (ex: VS Code)",
                                    "Exemplos de código com erros preparados"
                                  ],
                                  "tips": "Use print() ou console.log() para testar valores intermediários na condição",
                                  "learningObjective": "Identificar erros sintáticos e semânticos específicos na condição do if",
                                  "commonMistakes": [
                                    "Ignorar erros de sintaxe como 'and' em vez de '&&'",
                                    "Não testar com valores de borda (true/false)",
                                    "Confundir = (atribuição) com == (comparação)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar e corrigir a estrutura do bloco if",
                                  "subSteps": [
                                    "Confirme presença de chaves de abertura e fechamento { }",
                                    "Verifique indentação e alinhamento do código dentro do bloco",
                                    "Assegure que todas as statements no bloco terminem com ; se requerido",
                                    "Corrija chaves ausentes adicionando-as ao redor do bloco",
                                    "Reexecute o código após cada correção parcial para validar"
                                  ],
                                  "verification": "O código compila/executa sem erros de sintaxe no bloco",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador ou interpretador online (ex: Replit, CodePen)",
                                    "Lista de verificação impressa"
                                  ],
                                  "tips": "Use um linter (ex: ESLint) para destacar erros de estrutura automaticamente",
                                  "learningObjective": "Corrigir erros estruturais no corpo do comando if",
                                  "commonMistakes": [
                                    "Esquecer chave de fechamento {}",
                                    "Misturar indentação com tabs e espaços",
                                    "Colocar ; após a chave de fechamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a correção completa e validar lógica",
                                  "subSteps": [
                                    "Execute o código corrigido com múltiplos inputs de teste",
                                    "Verifique se o fluxo condicional age como esperado (ramo if executa corretamente)",
                                    "Compare saída real vs. esperada em uma tabela de testes",
                                    "Ajuste operadores lógicos se a lógica estiver incorreta",
                                    "Documente o processo de depuração em comentários no código"
                                  ],
                                  "verification": "Todos os casos de teste passam sem erros ou saídas inesperadas",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Conjunto de casos de teste pré-definidos",
                                    "Ferramenta de debugging (breakpoints)"
                                  ],
                                  "tips": "Crie testes unitários simples para automação futura",
                                  "learningObjective": "Validar que o if depurado funciona logicamente em cenários reais",
                                  "commonMistakes": [
                                    "Não testar casos negativos (condição falsa)",
                                    "Ignorar warnings do compilador",
                                    "Alterar lógica acidentalmente durante correções"
                                  ]
                                }
                              ],
                              "practicalExample": "Código com erros: if x > 5 and y < 10 { print('Alto'); }. Erros: falta de parênteses na condição, operador lógico 'and' (deve ser '&&' em C-like), falta de ; após print. Correção: if (x > 5 && y < 10) { print('Alto'); }. Teste com x=6, y=3: executa corretamente.",
                              "finalVerifications": [
                                "Depura independentemente 3 comandos if com erros mistos",
                                "Explica verbalmente o erro e correção para cada exemplo",
                                "Cria um if simples sem erros do zero",
                                "Identifica 5 erros comuns em código fornecido em <5 minutos",
                                "Usa depurador para pausar e inspecionar condição",
                                "Documenta processo de depuração de forma clara"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os erros (100%)",
                                "Correções sintáticas e lógicas corretas",
                                "Eficiência no tempo de depuração (<90 minutos total)",
                                "Explicação clara de causas e soluções",
                                "Testes abrangentes com casos de borda",
                                "Uso adequado de ferramentas e boas práticas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana e tabelas verdade",
                                "Resolução de problemas: Método científico (hipótese-teste)",
                                "Língua: Leitura técnica de erros e documentação",
                                "Física/Engenharia: Validações condicionais em simulações"
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, depurar ifs previne bugs críticos como acessos indevidos em sistemas bancários ou falhas em controles de tráfego aéreo, economizando horas de debug em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Comando if-else",
                        "description": "Estrutura condicional que executa um bloco de código se a condição for verdadeira (if) ou outro bloco se for falsa (else).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Reconhecer a sintaxe do if-else",
                            "description": "Diferenciar e identificar a sintaxe completa do if-else, incluindo a cláusula 'else' após o bloco if, em linguagens como C ou Pascal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes básicos da instrução if em C",
                                  "subSteps": [
                                    "Localize a palavra-chave 'if' no início da estrutura.",
                                    "Identifique os parênteses que envolvem a condição lógica (ex: (x > 0)).",
                                    "Reconheça o bloco de código entre chaves {} executado se a condição for verdadeira.",
                                    "Observe que o bloco pode ser uma única instrução sem chaves em casos simples.",
                                    "Diferencie de outras estruturas como while ou for pela ausência de repetição."
                                  ],
                                  "verification": "Anote e rotule os três componentes (if, condição, bloco) em um exemplo de código fornecido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto como VS Code",
                                    "Exemplos de código C impressos ou digitais",
                                    "Documentação oficial de sintaxe C"
                                  ],
                                  "tips": "Sempre verifique se há parênteses imediatamente após 'if'; sem eles, não é um if válido.",
                                  "learningObjective": "Reconhecer precisamente os elementos essenciais da sintaxe if simples.",
                                  "commonMistakes": [
                                    "Confundir parênteses com colchetes []",
                                    "Ignorar chaves opcionais em blocos de uma linha",
                                    "Misturar com estruturas de loop"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a cláusula else isolada",
                                  "subSteps": [
                                    "Identifique a palavra-chave 'else' que deve seguir imediatamente após o bloco if.",
                                    "Note que 'else' não tem condição; ela executa se o if for falso.",
                                    "Reconheça o bloco de código associado ao else, delimitado por chaves {}.",
                                    "Verifique que 'else' só aparece após um if, nunca sozinho.",
                                    "Compare com Pascal: 'else' após 'then' sem parênteses na condição."
                                  ],
                                  "verification": "Marque a posição exata onde 'else' deve ser colocado em um código if incompleto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de código C com if sem else",
                                    "Compilador online como Replit",
                                    "Folha de exercícios de identificação"
                                  ],
                                  "tips": "Lembre-se: else é opcional, mas quando presente, cola diretamente ao if sem ; no meio.",
                                  "learningObjective": "Distinguir a sintaxe e posicionamento correto da cláusula else.",
                                  "commonMistakes": [
                                    "Colocar ; após o bloco if antes do else",
                                    "Adicionar condição após else",
                                    "Usar else sem if precedente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a sintaxe completa do if-else",
                                  "subSteps": [
                                    "Combine if (condição) {bloco verdadeiro} else {bloco falso}.",
                                    "Verifique ausência de ponto e vírgula entre if e else.",
                                    "Identifique aninhamentos iniciais (if dentro de outro if).",
                                    "Compare sintaxe em Pascal: if condição then bloco1 else bloco2.",
                                    "Teste compilação de um exemplo completo para validar."
                                  ],
                                  "verification": "Escreva ou corrija um código if-else completo e confirme compilação sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C local ou online (GCC via Code::Blocks)",
                                    "Exemplos de código válidos e inválidos",
                                    "Referência de sintaxe C/Pascal PDF"
                                  ],
                                  "tips": "Use indentação para visualizar melhor a estrutura; ela não afeta sintaxe, mas ajuda na leitura.",
                                  "learningObjective": "Reconhecer a estrutura integrada if-else em sua forma completa.",
                                  "commonMistakes": [
                                    "Inserir ; após } do if",
                                    "Aninhar incorretamente sem chaves",
                                    "Confundir com switch"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar sintaxe correta de incorreta em exemplos reais",
                                  "subSteps": [
                                    "Examine códigos com erros comuns e identifique falhas na sintaxe if-else.",
                                    "Compare múltiplos exemplos em C e Pascal para generalizar.",
                                    "Crie variações: if simples, if-else, if-else if (bônus).",
                                    "Explique verbalmente por que um código é sintaticamente válido ou inválido.",
                                    "Pratique com 5-10 snippets variados."
                                  ],
                                  "verification": "Corrija 80% dos erros em um conjunto de 10 códigos de teste fornecidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de 10 códigos com erros (prontos ou gerados)",
                                    "Ferramenta de linting como cppcheck",
                                    "Quiz interativo online"
                                  ],
                                  "tips": "Procure sempre por 'if' seguido de ( ) e depois opcionalmente 'else'; qualquer desvio é erro.",
                                  "learningObjective": "Aplicar reconhecimento para validar ou invalidar sintaxe if-else.",
                                  "commonMistakes": [
                                    "Aceitar if sem parênteses",
                                    "Permitir else com condição",
                                    "Ignorar case sensitivity em Pascal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C, para verificar se um número é positivo ou não:\n\n#include <stdio.h>\nint main() {\n    int x = 5;\n    if (x > 0) {\n        printf(\"Positivo\\n\");\n    } else {\n        printf(\"Nao positivo\\n\");\n    }\n    return 0;\n}\n\nAqui, 'if (x > 0)' executa o primeiro printf se verdadeiro; 'else' executa o segundo se falso. Sem else, apenas 'Nao positivo' não seria impresso.",
                              "finalVerifications": [
                                "Identificar corretamente a cláusula else em 90% dos códigos apresentados.",
                                "Explicar a diferença entre if simples e if-else em termos de execução.",
                                "Corrigir sintaxe inválida adicionando/removendo else adequadamente.",
                                "Comparar sintaxe em C vs. Pascal sem erros.",
                                "Detectar e nomear 5 erros comuns de sintaxe if-else."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de 'if', condição e 'else' (peso 30%).",
                                "Capacidade de diferenciar sintaxe válida de inválida (peso 25%).",
                                "Explicação clara do fluxo de execução (peso 20%).",
                                "Correção de exemplos práticos sem introduzir novos erros (peso 15%).",
                                "Generalização para C e Pascal (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Lógica booleana e álgebra (Matemática).",
                                "Tomada de decisões em fluxogramas (Administração).",
                                "Estruturas lógicas em circuitos digitais (Eletrônica).",
                                "Condicionais em pseudocódigo algorítmico (Matemática Computacional)."
                              ],
                              "realWorldApplication": "Em software de engenharia, if-else controla validações em sistemas de login (ex: usuário autorizado ou não), em jogos para ações baseadas em colisões, ou em apps móveis para alternar temas claro/escuro baseado em preferências do usuário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Implementar decisões binárias com if-else",
                            "description": "Desenvolver programas que tomem decisões binárias, como classificar um número como par ou ímpar utilizando entrada do usuário, processamento condicional e saída de resultados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe e lógica do comando if-else",
                                  "subSteps": [
                                    "Estude a estrutura básica: if (condição) { ações } else { ações alternativas }",
                                    "Analise exemplos simples, como verificar se uma variável é maior que 10",
                                    "Identifique a condição booleana (true/false) que controla o fluxo",
                                    "Pratique escrevendo pseudocódigo para decisões binárias cotidianas",
                                    "Diferencie if simples de if-else"
                                  ],
                                  "verification": "Escreva 3 exemplos de pseudocódigo if-else corretos sem erros sintáticos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (ex: VS Code)",
                                    "Documentação de sintaxe da linguagem (Python ou C)"
                                  ],
                                  "tips": "Sempre use parênteses na condição e chaves para blocos, mesmo em linhas únicas",
                                  "learningObjective": "Dominar a estrutura sintática e lógica de decisões binárias",
                                  "commonMistakes": [
                                    "Esquecer else",
                                    "Condições não booleanas",
                                    "Falta de chaves em blocos múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Capturar e validar entrada do usuário",
                                  "subSteps": [
                                    "Aprenda a usar input() para ler dados do usuário (ex: número inteiro)",
                                    "Converta string para int/float com int() ou float()",
                                    "Adicione validação básica para entradas inválidas (opcional para este nível)",
                                    "Teste input com diferentes valores (positivos, negativos, zero)",
                                    "Armazene o valor em uma variável"
                                  ],
                                  "verification": "Crie um programa que leia um número e o exiba corretamente convertido",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com console (ex: PyCharm ou Replit)",
                                    "Teclado para testes"
                                  ],
                                  "tips": "Use input('Mensagem clara: ') para guiar o usuário",
                                  "learningObjective": "Capturar e processar dados de entrada de forma segura",
                                  "commonMistakes": [
                                    "Não converter tipo (string em vez de int)",
                                    "Ignorar erros de input inválido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a lógica condicional para decisão binária (par/ímpar)",
                                  "subSteps": [
                                    "Use o operador módulo % para verificar resto da divisão por 2 (== 0 para par)",
                                    "Escreva a condição: if (numero % 2 == 0)",
                                    "Defina ações no if (par) e else (ímpar)",
                                    "Integre a variável de input na condição",
                                    "Adicione comentários explicativos no código"
                                  ],
                                  "verification": "Execute o código com 3 números e confirme classificações corretas",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do step anterior",
                                    "Calculadora para verificar % manualmente"
                                  ],
                                  "tips": "Teste com 0 (par), 1 (ímpar), -2 (par) para edge cases",
                                  "learningObjective": "Aplicar operadores lógicos em decisões reais",
                                  "commonMistakes": [
                                    "Erro no operador % (usar /)",
                                    "Condição invertida (ímpar primeiro)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exibir resultados e testar o programa completo",
                                  "subSteps": [
                                    "Use print() para output claro: 'O número X é par/ímpar'",
                                    "Execute o programa com múltiplos inputs",
                                    "Registre saídas em um log ou screenshot",
                                    "Depure erros comuns (ex: ValueError em input)",
                                    "Refatore o código para reutilização"
                                  ],
                                  "verification": "Programa processa 10 inputs variados sem crashes e com outputs corretos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Console/terminal",
                                    "Lista de números de teste (pares, ímpares, negativos)"
                                  ],
                                  "tips": "Adicione try-except para inputs inválidos em versões avançadas",
                                  "learningObjective": "Integrar input, processamento e output em um fluxo completo",
                                  "commonMistakes": [
                                    "Print sem formatação",
                                    "Não testar edge cases como zero"
                                  ]
                                }
                              ],
                              "practicalExample": "```python\nnumero = int(input('Digite um número inteiro: '))\nif numero % 2 == 0:\n    print(f'O número {numero} é par.')\nelse:\n    print(f'O número {numero} é ímpar.')\n```\nExemplo de execução: Input 4 → Output 'O número 4 é par.'; Input 7 → 'O número 7 é ímpar.'",
                              "finalVerifications": [
                                "Programa compila/executa sem erros sintáticos ou runtime",
                                "Classifica corretamente pelo menos 10 números (pares, ímpares, zero, negativos)",
                                "Input é lido e processado adequadamente",
                                "Output é claro e informativo",
                                "Código inclui comentários explicando a lógica",
                                "Testes manuais cobrem casos edge"
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe if-else (100%)",
                                "Uso preciso do operador % para par/ímpar",
                                "Integração correta de input/output",
                                "Tratamento básico de tipos de dados",
                                "Clareza e legibilidade do código",
                                "Cobertura de testes variados"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações de resto (módulo) e propriedades de números pares/ímpares",
                                "Lógica: Construção de tabelas-verdade para condições binárias",
                                "Língua Portuguesa: Redação de mensagens claras e instrutivas no output",
                                "Ética em Computação: Validação de inputs para evitar crashes"
                              ],
                              "realWorldApplication": "Classificação de transações bancárias (aprovada/rejeitada), validação de senhas (correta/incorreta), categorização de produtos em e-commerces (disponível/esgotado), ou filtros em apps de streaming (idade permitida/não permitida)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Analisar fluxo de execução em if-else",
                            "description": "Traçar o caminho de execução de um programa com if-else, prevendo saídas para diferentes entradas e condições booleanas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica do comando if-else",
                                  "subSteps": [
                                    "Ler e analisar a sintaxe padrão do comando if-else em uma linguagem de programação procedimental.",
                                    "Identificar o bloco 'if' (condição verdadeira) e o bloco 'else' (condição falsa).",
                                    "Examinar a expressão booleana na cláusula 'if'.",
                                    "Desenhar um fluxograma simples representando o fluxo de execução.",
                                    "Explicar verbalmente ou por escrito o que acontece em cada ramo."
                                  ],
                                  "verification": "Criar um fluxograma manual ou digital do if-else básico e explicar seu funcionamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código ou papel e caneta para fluxograma",
                                    "Exemplo de código if-else simples"
                                  ],
                                  "tips": "Use setas no fluxograma para visualizar claramente o caminho de decisão.",
                                  "learningObjective": "Dominar a anatomia do if-else e seu impacto no fluxo de execução.",
                                  "commonMistakes": [
                                    "Ignorar a indentação que define os blocos de código.",
                                    "Confundir a condição 'if' com o bloco 'else'.",
                                    "Esquecer que o 'else' é opcional em alguns casos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar variáveis, entradas e condições booleanas",
                                  "subSteps": [
                                    "Listar todas as variáveis de entrada no programa.",
                                    "Avaliar as expressões booleanas (operadores como ==, >, <, &&, ||).",
                                    "Determinar valores possíveis para cada variável de entrada.",
                                    "Classificar condições como verdadeiras ou falsas para cenários hipotéticos.",
                                    "Mapear dependências entre variáveis e condições."
                                  ],
                                  "verification": "Criar uma tabela de variáveis, valores possíveis e resultados booleanos esperados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Código fonte do programa com if-else"
                                  ],
                                  "tips": "Teste condições com valores extremos (mínimo, máximo, zero) para cobrir bordas.",
                                  "learningObjective": "Analisar como entradas influenciam condições booleanas.",
                                  "commonMistakes": [
                                    "Esquecer operadores lógicos compostos (&&, ||).",
                                    "Não considerar valores nulos ou indefinidos.",
                                    "Confundir igualdade (==) com atribuição (=)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Traçar caminhos de execução para diferentes entradas",
                                  "subSteps": [
                                    "Selecionar 3-5 conjuntos de entradas diferentes.",
                                    "Simular passo a passo a avaliação da condição para cada entrada.",
                                    "Seguir o caminho 'if' ou 'else' e anotar o código executado.",
                                    "Registrar saídas parciais ou finais em cada ramo.",
                                    "Desenhar fluxogramas ramificados para todos os cenários."
                                  ],
                                  "verification": "Documentar fluxos em um diagrama com entradas específicas e caminhos destacados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (ex: Draw.io, papel)",
                                    "Código fonte anotado"
                                  ],
                                  "tips": "Comece com casos simples (true/false óbvios) antes de compostos.",
                                  "learningObjective": "Visualizar e documentar múltiplos fluxos de controle condicional.",
                                  "commonMistakes": [
                                    "Pular passos intermediários na simulação.",
                                    "Não cobrir casos de borda onde condição é falsa por pouco.",
                                    "Ignorar execução sequencial após o if-else."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever saídas finais e validar a análise",
                                  "subSteps": [
                                    "Prever a saída completa do programa para cada conjunto de entradas.",
                                    "Executar o código real com as entradas para comparar.",
                                    "Comparar previsões com resultados reais e corrigir erros.",
                                    "Analisar discrepâncias e refinar o traçado de fluxo.",
                                    "Resumir lições aprendidas sobre o comportamento do if-else."
                                  ],
                                  "verification": "Relatório comparativo: previsão vs. execução real para todos cenários.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE ou interpretador para execução",
                                    "Código fonte e entradas de teste"
                                  ],
                                  "tips": "Use debugger se disponível para pausar e inspecionar condições.",
                                  "learningObjective": "Validar análises teóricas com execução prática.",
                                  "commonMistakes": [
                                    "Não testar com entradas reais idênticas às simuladas.",
                                    "Atribuir erros de previsão a falhas no código em vez de análise.",
                                    "Esquecer saídas de console ou efeitos colaterais."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o código: int idade = 16; if (idade >= 18) { System.out.println('Adulto'); } else { System.out.println('Menor de idade'); }. Para idade=16: condição falsa -> executa else -> saída 'Menor de idade'. Para idade=20: condição verdadeira -> executa if -> saída 'Adulto'. Para idade=18: verdadeira -> 'Adulto'.",
                              "finalVerifications": [
                                "Traça corretamente o fluxo para pelo menos 5 cenários de entrada diferentes.",
                                "Previsões de saída coincidem com execução real em 100% dos casos testados.",
                                "Fluxograma cobre todos os ramos possíveis do if-else.",
                                "Identifica corretamente todas as condições booleanas e suas avaliações.",
                                "Explica verbalmente o raciocínio para um par de cenários opostos.",
                                "Documenta erros comuns evitados na análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão na avaliação de condições booleanas (90%+ acerto).",
                                "Completude dos fluxogramas e coberturas de cenários.",
                                "Clareza na documentação de passos e previsões.",
                                "Capacidade de identificar e corrigir discrepâncias.",
                                "Uso adequado de ferramentas e materiais.",
                                "Profundidade na análise de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Lógica matemática: proposições e tabelas-verdade booleanas.",
                                "Matemática: análise de desigualdades e operadores relacionais.",
                                "Ciências sociais: tomada de decisões condicionais em cenários éticos.",
                                "Física: modelagem de processos condicionais em experimentos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software para sistemas de autenticação (ex: login com verificação de senha), jogos (escolhas do jogador), automação industrial (controle de máquinas baseado em sensores) e aplicativos de e-commerce (validação de carrinho de compras)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Condicionais aninhadas e compostas",
                        "description": "Combinação de múltiplos comandos if-else aninhados ou uso de operadores lógicos para condições complexas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Construir condicionais aninhadas",
                            "description": "Criar estruturas if-else aninhadas para lidar com múltiplas condições, como verificar faixas etárias (criança, adulto, idoso) com entrada numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar condicionais básicas e introduzir aninhamento",
                                  "subSteps": [
                                    "Relembrar sintaxe de if simples e if-else",
                                    "Explicar aninhamento: um if dentro de outro",
                                    "Analisar exemplo simples: if (idade > 18) { if (idade < 60) { adulto } }",
                                    "Desenhar diagrama de fluxo para visualização",
                                    "Praticar com pseudocódigo"
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre condicional simples e aninhada, com exemplo correto",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (ex: VS Code)",
                                    "Papel e caneta para diagramas",
                                    "Documentação da linguagem de programação"
                                  ],
                                  "tips": [
                                    "Sempre use chaves {} para blocos, mesmo em single line",
                                    "Desenhe fluxogramas antes de codificar"
                                  ],
                                  "learningObjective": "Compreender a estrutura hierárquica de condicionais aninhadas",
                                  "commonMistakes": [
                                    "Omitir chaves em blocos aninhados",
                                    "Confundir aninhamento com condições paralelas (&& ||)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar a lógica para múltiplas condições",
                                  "subSteps": [
                                    "Definir faixas etárias: Criança (0-12), Adolescente (13-17), Adulto (18-59), Idoso (60+)",
                                    "Criar fluxograma sequencial de decisões aninhadas",
                                    "Listar condições em ordem: primeiro >12, depois >17, depois >59",
                                    "Considerar entrada inválida (idade <0 ou não numérica)",
                                    "Escrever pseudocódigo completo"
                                  ],
                                  "verification": "Fluxograma e pseudocódigo aprovados por auto-revisão ou peer review, cobrindo todas as faixas",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (ex: Draw.io, Lucidchart)",
                                    "Papel para rascunhos"
                                  ],
                                  "tips": [
                                    "Comece pela condição mais restritiva e avance para as amplas",
                                    "Teste mentalmente com idades 5, 15, 30, 65"
                                  ],
                                  "learningObjective": "Planejar lógica complexa de forma visual e sequencial",
                                  "commonMistakes": [
                                    "Sobrepor faixas etárias",
                                    "Esquecer condição para idades negativas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o código com condicionais aninhadas",
                                  "subSteps": [
                                    "Ler entrada numérica da idade (use parseInt ou similar)",
                                    "Escrever estrutura if-else aninhada seguindo o pseudocódigo",
                                    "Adicionar output específico para cada faixa",
                                    "Incluir tratamento para entrada inválida no else final",
                                    "Adicionar comentários explicando cada nível de aninhamento"
                                  ],
                                  "verification": "Código compila e executa sem erros sintáticos; output correto para idade 25 (Adulto)",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDE com suporte a linguagem procedimental (ex: Python IDLE, C++ Dev-C++)",
                                    "Console para testes"
                                  ],
                                  "tips": [
                                    "Mantenha indentação consistente (4 espaços)",
                                    "Use variáveis descritivas como 'idadeUsuario'"
                                  ],
                                  "learningObjective": "Traduzir planejamento em código funcional e comentado",
                                  "commonMistakes": [
                                    "Erro de indentação levando a lógica errada",
                                    "Usar = em vez de == para comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e otimizar",
                                  "subSteps": [
                                    "Testar com idades representativas de cada faixa: 5, 15, 30, 65, -1",
                                    "Verificar outputs e corrigir bugs",
                                    "Medir cobertura: todas condições executadas?",
                                    "Otimizar: adicionar mensagem de boas-vindas ou múltiplas entradas",
                                    "Documentar testes em tabela (input x expected x actual)"
                                  ],
                                  "verification": "Tabela de testes mostra 100% de acerto em 10 casos variados",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou tabela Markdown para testes",
                                    "Debugger da IDE"
                                  ],
                                  "tips": [
                                    "Use console.log/print para debugar valores intermediários",
                                    "Teste bordas: 12,13,17,18,59,60"
                                  ],
                                  "learningObjective": "Garantir robustez através de testes sistemáticos",
                                  "commonMistakes": [
                                    "Não testar bordas de faixas",
                                    "Ignorar entradas não-numéricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa em Python que leia a idade de uma pessoa via input() e imprima: 'Criança' se 0-12, 'Adolescente' se 13-17, 'Adulto' se 18-59, 'Idoso' se 60+, ou 'Idade inválida' caso contrário. Exemplo: input 25 → 'Adulto'. Código: idade = int(input('Digite sua idade: ')); if idade >= 0: if idade <= 12: print('Criança') elif idade <= 17: print('Adolescente') elif idade <= 59: print('Adulto') else: print('Idoso') else: print('Idade inválida')",
                              "finalVerifications": [
                                "Programa classifica corretamente todas as 4 faixas etárias com testes",
                                "Trata entradas inválidas (negativas ou não-numéricas) sem crash",
                                "Código possui indentação e comentários adequados",
                                "Executa em menos de 2 segundos para múltiplas rodadas",
                                "Fluxograma inicial corresponde ao código final",
                                "Tabela de testes cobre bordas e casos extremos"
                              ],
                              "assessmentCriteria": [
                                "Lógica de aninhamento correta e sem sobreposições",
                                "Tratamento completo de erros de entrada",
                                "Código limpo, indentado e comentado",
                                "Eficiência: O(n=1) com decisões constantes",
                                "Cobertura de testes ≥90%",
                                "Facilidade de manutenção (fácil adicionar nova faixa)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operadores relacionais e intervalos numéricos",
                                "Lógica: Árvores de decisão e tabelas de verdade",
                                "Ética e Sociedade: Privacidade em coleta de dados pessoais como idade",
                                "Design de Sistemas: User Experience em interfaces condicionais"
                              ],
                              "realWorldApplication": "Em aplicativos de e-commerce para aplicar descontos por faixa etária (ex: idosos ganham 20% off), sistemas de saúde para recomendações personalizadas de exercícios, ou jogos para restringir conteúdo por idade do jogador."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Utilizar operadores lógicos em condições",
                            "description": "Aplicar operadores AND (&&), OR (||) e NOT (!) em condições de if para expressões compostas, como validar login com usuário e senha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os operadores lógicos AND (&&), OR (||) e NOT (!)",
                                  "subSteps": [
                                    "Estudar a definição: AND (&&) é verdadeiro só se ambos os operandos forem verdadeiros.",
                                    "Analisar OR (||): verdadeiro se pelo menos um operando for verdadeiro.",
                                    "Explorar NOT (!): inverte o valor lógico do operando (true vira false e vice-versa).",
                                    "Consultar tabelas-verdade para AND, OR e NOT com 2-3 operandos.",
                                    "Identificar sinônimos cotidianos: 'e' para AND, 'ou' para OR, 'não' para NOT."
                                  ],
                                  "verification": "Explicar em voz alta ou por escrito o resultado de combinações como true && false, true || false e !true.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem de programação (ex: MDN para JS ou Python docs)",
                                    "Tabelas-verdade online ou impressas"
                                  ],
                                  "tips": "Use mnemônicos: AND requer 'ambos', OR basta 'um', NOT 'inverte tudo'.",
                                  "learningObjective": "Dominar o significado e comportamento booleano dos operadores lógicos.",
                                  "commonMistakes": [
                                    "Confundir AND (requer ambos) com OR (basta um)",
                                    "Esquecer que NOT aplica a um único valor",
                                    "Ignorar precedência sem parênteses"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar condições simples com AND (&&)",
                                  "subSteps": [
                                    "Criar variáveis booleanas ou condições simples (ex: idade >= 18, aprovado == true).",
                                    "Escrever if com &&: if (idade >= 18 && temCarteira) { entrar(); }.",
                                    "Adicionar else para caso falso e imprimir mensagens explicativas.",
                                    "Testar com console.log diferentes combinações de valores verdadeiros/falsos.",
                                    "Refatorar para um cenário prático como 'acesso liberado só se maior de idade E autorizado'."
                                  ],
                                  "verification": "Executar o código com 4 cenários de input e confirmar saídas corretas no console.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Replit ou CodePen)",
                                    "Console do navegador ou terminal"
                                  ],
                                  "tips": "Sempre teste extremos: todos true, um false, todos false.",
                                  "learningObjective": "Aplicar AND para condições que exigem múltiplas validações simultâneas.",
                                  "commonMistakes": [
                                    "Usar = em vez de == para comparação",
                                    "Esquecer parênteses em expressões complexas",
                                    "Não tratar o caso else"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar OR (||) e NOT (!) em condições compostas",
                                  "subSteps": [
                                    "Implementar OR: if (temChave || temSenha) { abrirPorta(); }.",
                                    "Incorporar NOT: if (!isBanido || isAdmin) { permitirAcesso(); }.",
                                    "Combinar com AND: if (idade >= 18 && (!isMenor || temPermissao)) {}.",
                                    "Testar variações lógicas alterando valores das variáveis.",
                                    "Debugar usando console.log para valores intermediários."
                                  ],
                                  "verification": "Rodar testes unitários manuais para pelo menos 6 combinações e validar lógica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código com depurador",
                                    "Ferramentas de teste como Jest (opcional para JS)"
                                  ],
                                  "tips": "Parênteses evitam erros de precedência: (A && B) || C != A && (B || C).",
                                  "learningObjective": "Usar OR para alternativas e NOT para negações em fluxos condicionais.",
                                  "commonMistakes": [
                                    "Confundir || com curto-circuito (avalia só até o primeiro true)",
                                    "Aplicar ! a expressões complexas sem parênteses",
                                    "Ignorar falsy values como 0 ou ''"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar operadores em validação de login realista",
                                  "subSteps": [
                                    "Definir variáveis: usuarioCorreto, senhaCorreta, isAtivo.",
                                    "Criar if: if (usuarioCorreto && senhaCorreta && isAtivo) { loginSucesso(); } else if (!usuarioCorreto || !senhaCorreta) { erroCredenciais(); }.",
                                    "Adicionar cenários: if (tentativas > 3 || !isAtivo) { bloquear(); }.",
                                    "Simular inputs via função ou prompt() e testar fluxo completo.",
                                    "Refinar com validações adicionais como !senhaVazia."
                                  ],
                                  "verification": "Simular 5 cenários de login (sucesso, erro user, erro senha, inativo, bloqueio) e verificar mensagens corretas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código de autenticação simples"
                                  ],
                                  "tips": "Priorize curto-circuito para eficiência: usuario && senha evita checar senha se user falhar.",
                                  "learningObjective": "Construir expressões lógicas compostas para cenários práticos como autenticação.",
                                  "commonMistakes": [
                                    "Excesso de aninhamentos sem operadores lógicos",
                                    "Não usar else if para fluxos mutuamente exclusivos",
                                    "Variáveis não inicializadas causando undefined"
                                  ]
                                }
                              ],
                              "practicalExample": "Função de login em JavaScript:\nfunction validarLogin(usuario, senha) {\n  const usuarioCorreto = usuario === 'admin';\n  const senhaCorreta = senha === '123456';\n  const contaAtiva = true;\n  if (usuarioCorreto && senhaCorreta && contaAtiva) {\n    console.log('Login bem-sucedido!');\n  } else if (!usuarioCorreto || !senhaCorreta) {\n    console.log('Credenciais inválidas!');\n  } else {\n    console.log('Conta inativa!');\n  }\n}\n// Testes: validarLogin('admin', '123456'); // Sucesso\n// validarLogin('user', '123456'); // Erro",
                              "finalVerifications": [
                                "Código executa sem erros sintáticos ou lógicos.",
                                "Todas as combinações de AND/OR/NOT produzem saídas esperadas.",
                                "Validação de login simula cenários reais corretamente.",
                                "Uso de parênteses garante precedência correta.",
                                "Testes cobrem casos edge (valores falsy, undefined).",
                                "Mensagens de erro são claras e condicionais apropriadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no uso de &&, || e ! sem inversões lógicas.",
                                "Estruturas if-else bem organizadas, sem redundâncias.",
                                "Cobertura completa de cenários via testes manuais.",
                                "Eficiência com curto-circuito e precedência respeitada.",
                                "Aplicação prática em contexto real como autenticação.",
                                "Clareza no código com variáveis descritivas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e tabelas-verdade.",
                                "Física: Portas lógicas em circuitos digitais (AND, OR, NOT).",
                                "Segurança da Informação: Validações em autenticação e autorização.",
                                "Matemática Computacional: Álgebra booleana."
                              ],
                              "realWorldApplication": "Validação de formulários em sites (ex: email válido && senha forte), autenticação em apps bancários (usuario correto && senha && 2FA), filtros em e-commerces (estoque > 0 || promocaoAtiva), sistemas de controle de acesso em empresas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Otimizar estruturas condicionais",
                            "description": "Refatorar códigos com condicionais redundantes ou aninhamentos excessivos para melhorar legibilidade e eficiência, evitando estruturas if desnecessárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o código existente",
                                  "subSteps": [
                                    "Leia o código completo para entender o fluxo lógico.",
                                    "Identifique condicionais aninhados (if dentro de if).",
                                    "Marque condicionais redundantes ou mutuamente exclusivos.",
                                    "Conte o número de níveis de aninhamento e condições desnecessárias.",
                                    "Anote impactos na legibilidade e eficiência."
                                  ],
                                  "verification": "Crie uma lista documentada dos problemas identificados no código.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Exemplo de código com condicionais problemáticos"
                                  ],
                                  "tips": "Use comentários inline para destacar problemas durante a análise.",
                                  "learningObjective": "Desenvolver habilidade para diagnosticar ineficiências em estruturas condicionais.",
                                  "commonMistakes": [
                                    "Ignorar condicionais em blocos else profundos",
                                    "Confundir redundância com lógica necessária",
                                    "Não considerar o contexto de performance"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar técnicas de otimização",
                                  "subSteps": [
                                    "Aprenda Guard Clauses (cláusulas de guarda com early returns).",
                                    "Estude consolidação de condições booleanas (&&, ||).",
                                    "Considere substituição por switch/case ou polimorfismo quando aplicável.",
                                    "Avalie remoção de condicionais desnecessários via reestruturação.",
                                    "Priorize técnicas baseadas na análise do step anterior."
                                  ],
                                  "verification": "Liste 2-3 técnicas escolhidas com justificativa para o código analisado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de refatoração (Martin Fowler's Refactoring book ou site)",
                                    "Exemplos de antes/depois online"
                                  ],
                                  "tips": "Comece com as técnicas mais simples para ganhos rápidos de legibilidade.",
                                  "learningObjective": "Selecionar refatorações apropriadas para cenários específicos de condicionais.",
                                  "commonMistakes": [
                                    "Aplicar técnica errada alterando lógica",
                                    "Esquecer de verificar equivalência lógica",
                                    "Over-optimizar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a refatoração",
                                  "subSteps": [
                                    "Aplique Guard Clauses para eliminar aninhamentos iniciais.",
                                    "Consolide condições redundantes em expressões únicas.",
                                    "Reescreva o código refatorado mantendo a lógica original.",
                                    "Adicione comentários explicando mudanças.",
                                    "Formate o código para máxima legibilidade (indentação mínima)."
                                  ],
                                  "verification": "Compare código original e refatorado linha por linha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código com diff tool",
                                    "Ferramenta de linting (ESLint ou Pylint)"
                                  ],
                                  "tips": "Faça refatorações em commits pequenos para facilitar rollback.",
                                  "learningObjective": "Executar refatorações práticas melhorando código sem alterar comportamento.",
                                  "commonMistakes": [
                                    "Alterar a lógica sem querer",
                                    "Aumentar complexidade em vez de reduzi-la",
                                    "Ignorar edge cases"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar melhorias",
                                  "subSteps": [
                                    "Escreva testes unitários para cenários originais.",
                                    "Execute testes no código original e refatorado.",
                                    "Meça métricas: linhas de código, ciclomática complexity, tempo de execução.",
                                    "Revise legibilidade com leitura em voz alta.",
                                    "Documente ganhos obtidos."
                                  ],
                                  "verification": "Todos os testes passam e métricas mostram melhoria.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Framework de testes (Jest para JS, pytest para Python)",
                                    "Ferramentas de análise estática (SonarQube)"
                                  ],
                                  "tips": "Use asserts para cada branch condicional.",
                                  "learningObjective": "Validar refatorações garantindo correção e eficiência.",
                                  "commonMistakes": [
                                    "Não testar todos os caminhos",
                                    "Confiar só em inspeção visual",
                                    "Ignorar performance em loops"
                                  ]
                                }
                              ],
                              "practicalExample": "Código original (Python):\n\ndef processar_usuario(idade, status, saldo):\n    if idade >= 18:\n        if status == 'premium':\n            if saldo > 0:\n                return 'acesso liberado'\n            else:\n                return 'sem saldo'\n        else:\n            return 'nao premium'\n    else:\n        return 'menor'\n\nCódigo otimizado:\n\ndef processar_usuario(idade, status, saldo):\n    if idade < 18:\n        return 'menor'\n    if status != 'premium':\n        return 'nao premium'\n    if saldo <= 0:\n        return 'sem saldo'\n    return 'acesso liberado'\n\nResultado: Redução de 10 para 7 linhas, eliminação de aninhamento.",
                              "finalVerifications": [
                                "Refatora código com 3+ níveis de if para estrutura plana.",
                                "Mantém 100% de equivalência lógica comprovada por testes.",
                                "Reduz complexidade ciclomática em pelo menos 20%.",
                                "Explica verbalmente as mudanças e benefícios.",
                                "Aplica otimização em código não visto anteriormente.",
                                "Identifica quando NÃO otimizar (ex: legibilidade vs performance)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de redundâncias (90%+).",
                                "Correção lógica pós-refatoração (testes passam).",
                                "Melhoria mensurável em legibilidade (menos indentação).",
                                "Eficiência computacional preservada ou melhorada.",
                                "Documentação clara das mudanças.",
                                "Criatividade na escolha de técnicas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Simplificação de expressões lógicas booleanas.",
                                "Design de Software: Princípios de Clean Code e SOLID.",
                                "Gestão de Projetos: Redução de dívida técnica em equipes.",
                                "Lógica e Filosofia: Análise de condições mutuamente exclusivas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de aplicativos empresariais, otimizar condicionais em código legado reduz tempo de manutenção em 30-50%, previne bugs em atualizações e facilita onboarding de novos desenvolvedores em equipes ágeis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Estruturas Repetitivas",
                    "description": "Loops como while, for e do-while para repetição controlada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Loop While",
                        "description": "Estrutura de repetição condicional que executa um bloco de comandos enquanto uma expressão booleana for verdadeira, verificando a condição no início de cada iteração.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Compreender a sintaxe do loop while",
                            "description": "Identificar e escrever corretamente a sintaxe do loop while em uma linguagem procedimental como C++, incluindo a declaração da condição booleana e o corpo do loop.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito e a sintaxe geral do loop while",
                                  "subSteps": [
                                    "Estude o conceito: o loop while executa um bloco de código repetidamente enquanto uma condição booleana for verdadeira.",
                                    "Memorize a sintaxe básica: while (condição) { // corpo do loop }",
                                    "Analise exemplos simples de documentação oficial do C++.",
                                    "Compare com loop do-while e for para diferenciar.",
                                    "Anote a importância da condição ser avaliada antes da execução."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a sintaxe geral e dar um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação C++ (cppreference.com)",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Sempre escreva a condição entre parênteses e use chaves para o corpo, mesmo se for uma linha.",
                                  "learningObjective": "Compreender o propósito e a estrutura fundamental do loop while em C++.",
                                  "commonMistakes": [
                                    "Confundir while com for (que tem inicialização e incremento)",
                                    "Esquecer os parênteses na condição",
                                    "Não usar chaves no corpo do loop"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e declarar a condição booleana corretamente",
                                  "subSteps": [
                                    "Revise expressões booleanas: operadores como ==, >, <, &&, ||.",
                                    "Pratique declarando variáveis booleanas ou expressões como (i < 10).",
                                    "Teste condições em um programa simples fora de loop para validar true/false.",
                                    "Evite condições sempre verdadeiras (loop infinito).",
                                    "Use variáveis de controle como contadores (int i = 0;)."
                                  ],
                                  "verification": "Criar e testar 3 expressões booleanas diferentes que retornem true/false esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C++ online como Replit ou Code::Blocks",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Inicialize variáveis de controle antes do loop para evitar lixo de memória.",
                                  "learningObjective": "Dominar a criação de condições booleanas precisas para controlar o loop while.",
                                  "commonMistakes": [
                                    "Usar = (atribuição) em vez de == (comparação)",
                                    "Condições que nunca mudam levando a loops infinitos",
                                    "Não inicializar variáveis usadas na condição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o corpo do loop while",
                                  "subSteps": [
                                    "Defina ações dentro do corpo: incrementos, cálculos ou saídas.",
                                    "Escreva o corpo com chaves { } e indentação para clareza.",
                                    "Inclua atualização da condição no final do corpo (ex: i++).",
                                    "Teste o corpo isoladamente em um if para validar lógica.",
                                    "Adicione break ou continue se necessário para controle fino."
                                  ],
                                  "verification": "Escrever um corpo de loop que execute uma ação simples 5 vezes manualmente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com depurador como Visual Studio Code com C++ extension",
                                    "Exemplos de código prontos"
                                  ],
                                  "tips": "Sempre atualize a variável de controle no corpo para evitar loops infinitos.",
                                  "learningObjective": "Construir blocos de código funcionais dentro do loop while.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar a condição no corpo",
                                    "Indentação incorreta confundindo estrutura",
                                    "Corpo vazio sem ação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar, compilar e depurar um loop while completo",
                                  "subSteps": [
                                    "Integre sintaxe, condição e corpo em um programa C++ completo.",
                                    "Compile e execute para observar comportamento.",
                                    "Use depurador para pausar e inspecionar variáveis a cada iteração.",
                                    "Corrija erros comuns como loop infinito ou saída incorreta.",
                                    "Modifique o loop para diferentes cenários e reteste."
                                  ],
                                  "verification": "Compilar e executar um programa com loop while sem erros e com saída esperada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador g++ ou IDE completa",
                                    "Terminal para comandos gcc"
                                  ],
                                  "tips": "Adicione cout para imprimir o valor da condição a cada iteração durante testes.",
                                  "learningObjective": "Integrar todos os elementos em um loop while funcional e depurável.",
                                  "commonMistakes": [
                                    "Loop infinito por falta de incremento",
                                    "Erros de compilação por sintaxe errada",
                                    "Variáveis não declaradas"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um programa em C++ que use um loop while para somar números de 1 a 10 e imprimir o resultado final: int soma = 0; int i = 1; while (i <= 10) { soma += i; i++; } cout << 'Soma: ' << soma << endl; // Saída: Soma: 55",
                              "finalVerifications": [
                                "Identificar corretamente a sintaxe do while em um código fornecido.",
                                "Escrever um loop while que itere exatamente 5 vezes com condição booleana adequada.",
                                "Detectar e corrigir um loop infinito em código dado.",
                                "Explicar o papel da condição e do corpo em um diagrama de fluxo.",
                                "Compilar e executar um programa com while sem erros.",
                                "Modificar um loop while existente para mudar o número de iterações."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa: parênteses na condição e chaves no corpo.",
                                "Condição booleana lógica e mutável para término correto.",
                                "Corpo do loop funcional com atualização adequada.",
                                "Ausência de loops infinitos ou erros de compilação.",
                                "Clareza no código com indentação e comentários.",
                                "Capacidade de depuração básica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expressões booleanas e lógica proposicional.",
                                "Algoritmos: Conceitos de repetição e controle de fluxo.",
                                "Lógica Computacional: Condições e avaliação de verdade.",
                                "Engenharia de Software: Boas práticas de codificação legível."
                              ],
                              "realWorldApplication": "Loops while são usados em validação de entrada de usuário (repete até input válido), processamento de arquivos até EOF, simulações contínuas em jogos (enquanto jogo rodando) e servidores que aguardam conexões indefinidamente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Implementar loop while para tarefas simples",
                            "description": "Criar um programa que utilize loop while para realizar tarefas como somar números consecutivos até atingir um limite ou ler entradas do usuário até uma condição de parada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe e lógica básica do loop while",
                                  "subSteps": [
                                    "Estude a estrutura geral: while condição: bloco de código",
                                    "Identifique os componentes essenciais: condição inicial, corpo do loop e atualização da variável de controle",
                                    "Analise exemplos simples, como contar de 1 a 5",
                                    "Explique em voz alta como o loop verifica a condição a cada iteração",
                                    "Diferencie while de outros loops como for"
                                  ],
                                  "verification": "Escreva a sintaxe correta do while e um exemplo que imprima números de 1 a 3 sem erros",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (ex: VS Code, PyCharm)",
                                    "Documentação oficial do Python sobre loops"
                                  ],
                                  "tips": [
                                    "Visualize o fluxo com um fluxograma simples para entender iterações"
                                  ],
                                  "learningObjective": "Dominar a estrutura sintática e lógica do loop while para evitar loops infinitos",
                                  "commonMistakes": [
                                    "Esquecer a indentação no bloco do loop",
                                    "Não inicializar a variável de controle",
                                    "Condição sempre verdadeira causando loop infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar uma tarefa simples para o loop while",
                                  "subSteps": [
                                    "Escolha uma tarefa: somar números consecutivos até um limite ou ler inputs até 'sair'",
                                    "Defina variáveis: inicialização (ex: soma = 0, contador = 1), condição (contador <= limite), atualização (contador += 1)",
                                    "Esboce o pseudocódigo passo a passo",
                                    "Considere casos edge: limite zero, inputs inválidos",
                                    "Desenhe um fluxograma da lógica"
                                  ],
                                  "verification": "Crie um pseudocódigo completo e valide com um colega ou auto-revisão",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para fluxograma",
                                    "Ferramenta online como draw.io"
                                  ],
                                  "tips": [
                                    "Sempre inclua atualização da variável dentro do loop para progredir"
                                  ],
                                  "learningObjective": "Planejar logicamente tarefas repetitivas para implementação eficiente",
                                  "commonMistakes": [
                                    "Condição mal definida que nunca termina",
                                    "Ignorar casos de entrada zero ou negativa",
                                    "Pseudocódigo vago sem variáveis específicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o código do loop while",
                                  "subSteps": [
                                    "Inicialize variáveis fora do loop",
                                    "Escreva a condição while e o corpo com operações necessárias",
                                    "Adicione atualização da variável no final do corpo",
                                    "Inclua print ou return para output visível",
                                    "Adicione comentários explicando cada parte"
                                  ],
                                  "verification": "Execute o código e confirme que produz o output esperado para input de teste",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "Terminal ou Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Use print dentro do loop temporariamente para debugar iterações"
                                  ],
                                  "learningObjective": "Escrever código funcional usando while para tarefas simples",
                                  "commonMistakes": [
                                    "Indentação incorreta causando SyntaxError",
                                    "Atualização fora do loop",
                                    "Variáveis não inicializadas levando a NameError"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e refinar o programa",
                                  "subSteps": [
                                    "Teste com múltiplos inputs: limite pequeno, grande, zero",
                                    "Identifique e corrija loops infinitos pressionando Ctrl+C",
                                    "Adicione validação de input se aplicável",
                                    "Meça performance para loops longos",
                                    "Refatore para maior legibilidade (ex: funções)"
                                  ],
                                  "verification": "O código passa em todos os testes sem erros ou loops infinitos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Inputs de teste pré-definidos em arquivo texto"
                                  ],
                                  "tips": [
                                    "Use debugger ou breakpoints para inspecionar variáveis por iteração"
                                  ],
                                  "learningObjective": "Garantir robustez e correção do código através de testes sistemáticos",
                                  "commonMistakes": [
                                    "Não testar casos edge",
                                    "Ignorar warnings do interpretador",
                                    "Deixar prints de debug no código final"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa que some números de 1 até um limite fornecido pelo usuário (ex: 10), imprimindo a soma final. Exemplo de código: limite = int(input('Limite: ')); soma = 0; i = 1; while i <= limite: soma += i; i += 1; print('Soma:', soma). Saída para 10: Soma: 55.",
                              "finalVerifications": [
                                "O loop termina corretamente sem intervenção manual",
                                "Resultado matemático é preciso para múltiplos testes",
                                "Código lida com input zero retornando soma 0",
                                "Não há loops infinitos em condições normais",
                                "Comentários explicam lógica claramente",
                                "Código é legível e segue convenções PEP8"
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: condição e atualização adequadas",
                                "Robustez: trata casos edge sem crash",
                                "Clareza: código comentado e indentado corretamente",
                                "Eficiência: sem operações desnecessárias no loop",
                                "Testabilidade: inclui prints ou testes explícitos",
                                "Extensibilidade: fácil adaptar para novas tarefas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de somas de séries aritméticas",
                                "Lógica e Raciocínio: Construção de fluxos condicionais",
                                "Engenharia: Design de algoritmos iterativos",
                                "Estatística: Loops para simulações de processos repetitivos"
                              ],
                              "realWorldApplication": "Em aplicativos de validação de login (ler senhas até correta), jogos (loops de turnos até fim), processamento de dados (ler arquivos linha a linha até EOF) ou automação de tarefas repetitivas como monitoramento de sensores em IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Evitar loops infinitos no while",
                            "description": "Analisar e corrigir condições que podem causar loops infinitos no while, garantindo que a condição booleana seja alterada dentro do loop para permitir a saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de loop infinito",
                                  "subSteps": [
                                    "Explicar o funcionamento básico de um loop while: executa repetidamente enquanto a condição booleana for verdadeira.",
                                    "Definir loop infinito: ocorre quando a condição nunca se torna falsa, fazendo o loop rodar indefinidamente.",
                                    "Exemplificar com pseudocódigo: while (verdadeiro) { imprimir('Olá'); }.",
                                    "Discutir consequências: consumo excessivo de CPU, travamento do programa e necessidade de força forçar saída (Ctrl+C).",
                                    "Relacionar com variáveis de controle que devem alterar a condição."
                                  ],
                                  "verification": "Resumir em 2-3 frases o que é um loop infinito e suas causas principais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação de loops while em Python ou pseudocódigo",
                                    "Vídeo curto sobre estruturas repetitivas"
                                  ],
                                  "tips": [
                                    "Sempre pergunte: 'O que torna a condição falsa?'",
                                    "Visualize o fluxo com setas no papel."
                                  ],
                                  "learningObjective": "Dominar a definição e as causas fundamentais de loops infinitos em estruturas while.",
                                  "commonMistakes": [
                                    "Confundir loop infinito com recursão infinita.",
                                    "Achar que qualquer loop longo é infinito."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar código para detectar loops infinitos",
                                  "subSteps": [
                                    "Ler o código completo, focando na estrutura while.",
                                    "Identificar a condição booleana do while e listar variáveis envolvidas.",
                                    "Verificar se há instruções dentro do loop que alteram essas variáveis.",
                                    "Rastrear o fluxo de execução: simular 3-5 iterações manualmente.",
                                    "Identificar padrões perigosos: condições sempre verdadeiras (True) ou variáveis não atualizadas."
                                  ],
                                  "verification": "Marcar no código a linha da condição problemática e explicar por quê.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Replit)",
                                    "Códigos de exemplo com loops while"
                                  ],
                                  "tips": [
                                    "Use papel para desenhar o estado das variáveis por iteração.",
                                    "Procure por 'while True' sem break.",
                                    "Teste com print() para depuração mental."
                                  ],
                                  "learningObjective": "Desenvolver habilidade para diagnosticar loops infinitos em código existente.",
                                  "commonMistakes": [
                                    "Ignorar condições compostas (and/or).",
                                    "Não considerar entradas do usuário que não alteram a condição."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Corrigir o loop adicionando lógica de saída",
                                  "subSteps": [
                                    "Definir uma variável de controle (ex: contador ou flag).",
                                    "Inicializar a variável antes do loop.",
                                    "Modificar a condição while para depender da variável de controle.",
                                    "Atualizar a variável dentro do loop (incremento, decremento ou mudança de flag).",
                                    "Adicionar alternativa: usar break com if condicional."
                                  ],
                                  "verification": "Executar o código corrigido e confirmar que termina em <10 iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código com depurador",
                                    "Exemplos de códigos com erros"
                                  ],
                                  "tips": [
                                    "Prefira contadores para loops com número conhecido de iterações.",
                                    "Sempre teste com valores extremos (0, 1, máximo)."
                                  ],
                                  "learningObjective": "Aplicar correções precisas para garantir terminação do loop.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar a variável de controle.",
                                    "Atualizar a variável fora do loop ou condicionalmente errada."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a correção",
                                  "subSteps": [
                                    "Executar o código corrigido com diferentes entradas.",
                                    "Usar depurador para observar mudanças na condição.",
                                    "Adicionar prints para rastrear iterações e variáveis.",
                                    "Testar casos edge: entrada zero, máxima, inválida.",
                                    "Documentar a correção com comentários no código."
                                  ],
                                  "verification": "Confirmar que o loop termina corretamente em todos os testes e sem saída infinita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente de execução (Python IDLE, online REPL)",
                                    "Lista de casos de teste"
                                  ],
                                  "tips": [
                                    "Automatize testes com asserts para condição pós-loop.",
                                    "Monitore tempo de execução para detectar infinitos ocultos."
                                  ],
                                  "learningObjective": "Garantir robustez da correção através de testes sistemáticos.",
                                  "commonMistakes": [
                                    "Testar só com um caso feliz.",
                                    "Ignorar overflows em contadores (ex: int max)."
                                  ]
                                }
                              ],
                              "practicalExample": "Código com erro: contador = 0; while (contador < 5) { imprimir('Olá'); } // Falta contador +=1\nCódigo corrigido: contador = 0; while (contador < 5) { imprimir('Olá'); contador += 1; } // Executa 5 vezes e para.",
                              "finalVerifications": [
                                "Identifica corretamente um loop infinito em código não visto anteriormente.",
                                "Explica verbalmente por que o loop é infinito e como corrigir.",
                                "Corrige um loop while adicionando variável de controle ou break.",
                                "Executa testes que provam a terminação do loop.",
                                "Discute prevenção em novos códigos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da causa (alteração ausente na condição).",
                                "Eficiência da correção (mínimas mudanças, sem introduzir novos bugs).",
                                "Cobertura de testes (pelo menos 3 casos: normal, edge, inválido).",
                                "Clareza na explicação oral ou escrita da análise.",
                                "Uso correto de depuração e verificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e indução em sequências.",
                                "Física: Modelagem de processos contínuos que precisam de critério de parada (simulações).",
                                "Design de Jogos: Loops de jogo principal que evitam travamentos.",
                                "Gestão de Projetos: Prevenção de deadlocks em fluxos de trabalho iterativos."
                              ],
                              "realWorldApplication": "Em aplicativos web, loops while processam requisições de usuários até completas, evitando crashes em servidores; em jogos, controlam animações até game over, garantindo fluidez sem congelamentos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Loop For",
                        "description": "Estrutura de repetição para executar um bloco de comandos um número pré-determinado de vezes, utilizando inicialização, condição e incremento em uma única linha.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Compreender a sintaxe do loop for",
                            "description": "Explicar e aplicar a sintaxe completa do loop for, incluindo variável de controle, condição de parada e modificador (incremento/decremento).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a estrutura geral da sintaxe do loop for",
                                  "subSteps": [
                                    "Analise a sintaxe básica: for (inicialização; condição; modificador) { corpo }",
                                    "Identifique as três partes principais: inicialização, condição de parada e modificador",
                                    "Compare com outras estruturas repetitivas como while",
                                    "Desenhe um fluxograma representando o fluxo do loop for",
                                    "Leia exemplos em documentação de linguagens procedimentais como C ou Pascal"
                                  ],
                                  "verification": "Desenhar corretamente o fluxograma e listar as três partes principais sem erros",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para fluxograma",
                                    "Documentação de sintaxe de loop for (ex: C ou Portugol)"
                                  ],
                                  "tips": "Sempre visualize o loop como um ciclo com entrada, verificação e saída controlada",
                                  "learningObjective": "Reconhecer e descrever os componentes fundamentais da sintaxe do loop for",
                                  "commonMistakes": [
                                    "Confundir com while (sem contador)",
                                    "Ignorar o papel do modificador",
                                    "Esquecer chaves ou blocos delimitadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a variável de controle e sua inicialização",
                                  "subSteps": [
                                    "Defina variável de controle como um contador (ex: int i = 0)",
                                    "Explique a inicialização: ocorre uma única vez no início do loop",
                                    "Teste inicializações diferentes: i = 1, i = 0, decremento inicial",
                                    "Declare o tipo da variável adequadamente (int, etc.)",
                                    "Verifique escopo: a variável é visível apenas no loop ou fora?"
                                  ],
                                  "verification": "Escrever 3 exemplos de inicialização correta e explicar seu propósito",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código simples (ex: Visualg ou Code::Blocks)",
                                    "Compilador ou interpretador online"
                                  ],
                                  "tips": "Use nomes descritivos para a variável, como 'indice' ou 'contador'",
                                  "learningObjective": "Dominar a declaração e inicialização da variável de controle",
                                  "commonMistakes": [
                                    "Reutilizar variável sem reinicializar",
                                    "Usar tipo errado (float para contador inteiro)",
                                    "Inicializar fora do for incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a condição de parada",
                                  "subSteps": [
                                    "Descreva a condição como uma expressão booleana (ex: i < 10)",
                                    "Teste condições verdadeiras/falsas e observe quando o loop para",
                                    "Modifique a condição e preveja o número de iterações",
                                    "Discuta condições para loops decrescentes (ex: i > 0)",
                                    "Evite condições infinitas testando com debugger"
                                  ],
                                  "verification": "Criar 3 loops com condições diferentes e contar iterações manualmente",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Debugger ou console para testes"
                                  ],
                                  "tips": "Sempre pergunte: 'Quando essa condição será falsa?' para evitar loops infinitos",
                                  "learningObjective": "Entender como a condição controla o término do loop",
                                  "commonMistakes": [
                                    "Condição sempre verdadeira (loop infinito)",
                                    "Operador lógico errado (== em vez de <)",
                                    "Não considerar o valor inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar o modificador (incremento/decremento) e sintaxe completa",
                                  "subSteps": [
                                    "Explique o modificador: executado no final de cada iteração (ex: i++)",
                                    "Teste incrementos (i++ , i += 2) e decrementos (i--)",
                                    "Monte um loop completo: inicialização + condição + modificador + corpo",
                                    "Execute e depure um exemplo somando 1 a 100",
                                    "Adapte para passos personalizados (ex: pares apenas)"
                                  ],
                                  "verification": "Escrever e executar um loop for que imprima números pares de 1 a 20",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código prontos para modificação"
                                  ],
                                  "tips": "Lembre: modificador vem DEPOIS da condição, no final do cabeçalho",
                                  "learningObjective": "Aplicar o modificador e compor a sintaxe completa do loop for",
                                  "commonMistakes": [
                                    "Esquecer o modificador (loop infinito)",
                                    "Posição errada do ++ (pré vs pós)",
                                    "Incremento incompatível com condição"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcular a soma dos números de 1 a 10: int soma = 0; for(int i = 1; i <= 10; i++) { soma += i; } printf(\"Soma: %d\", soma); // Resultado: 55",
                              "finalVerifications": [
                                "Explicar verbalmente os 3 componentes do for sem hesitação",
                                "Escrever sintaxe correta de um loop for simples sem erros",
                                "Prever e simular 5 iterações de um loop dado",
                                "Identificar e corrigir erros em códigos de loop for fornecidos",
                                "Criar um loop for personalizado para uma tarefa simples (ex: tabuada)",
                                "Comparar for com while em termos de sintaxe e uso"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação dos componentes (inicialização, condição, modificador)",
                                "Correção sintática em exemplos escritos (100% sem erros)",
                                "Capacidade de prever comportamento do loop (iterações corretas)",
                                "Explicação clara e concisa dos conceitos",
                                "Criatividade em adaptações (decremento, passos >1)",
                                "Detecção de erros comuns em códigos alheios"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências aritméticas e somas de séries",
                                "Lógica e Algoritmos: Fluxogramas e pseudocódigo",
                                "Física: Simulações de movimento uniforme (incrementos constantes)",
                                "Estatística: Processamento de listas de dados repetitivos"
                              ],
                              "realWorldApplication": "Loops for são essenciais em engenharia de software para processar arrays de dados (ex: filtrar listas de usuários em apps), gerar relatórios (somar vendas), animações em jogos (atualizar posições de sprites) e automação de tarefas repetitivas em sistemas empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Usar loop for para percorrer sequências",
                            "description": "Implementar loops for para iterar sobre faixas de números, como imprimir de 1 a 10 ou calcular fatorial, otimizando para cenários com número conhecido de repetições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a sintaxe básica do loop for",
                                  "subSteps": [
                                    "Estude a estrutura geral: for (inicialização; condição; incremento) { corpo } em linguagens como C ou for i in range(start, end) em Python.",
                                    "Identifique cada parte: inicialização define variável, condição verifica parada, incremento atualiza no final de cada iteração.",
                                    "Compare com loop while para entender quando usar for (número conhecido de repetições).",
                                    "Escreva pseudocódigo para um loop que itera de 1 a 5.",
                                    "Teste mentalmente: quantas vezes executa? (5 vezes)"
                                  ],
                                  "verification": "Escreva e explique a sintaxe em um papel ou comentário no código sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto, documentação de linguagem (ex: Python range() ou C for loop)",
                                  "tips": "Lembre-se: condição falsa no início para zero iterações.",
                                  "learningObjective": "Compreender componentes da sintaxe for para uso correto.",
                                  "commonMistakes": "Confundir incremento com condição; esquecer chaves em C."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar loop for para imprimir sequência simples",
                                  "subSteps": [
                                    "Crie um programa que imprima números de 1 a 10 usando for.",
                                    "Inclua inicialização i=1, condição i<=10, incremento i++ (C) ou range(1,11) (Python).",
                                    "Adicione print(i) dentro do loop.",
                                    "Compile e execute o código.",
                                    "Modifique para imprimir de 5 a 15 para praticar variação."
                                  ],
                                  "verification": "Saída no console mostra exatamente '1 2 3 ... 10' sem erros ou loops infinitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE ou editor com compilador/interpreter (VS Code + Python/C compiler)",
                                  "tips": "Use printf(\"%d\\n\", i); em C para formatação limpa.",
                                  "learningObjective": "Aplicar for para iteração básica sobre faixas numéricas.",
                                  "commonMistakes": "Usar i<10 em vez de i<=10; off-by-one errors."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Usar loop for em cálculos acumulativos",
                                  "subSteps": [
                                    "Implemente soma de 1 a 10: inicialize soma=0, adicione i na cada iteração.",
                                    "Teste e verifique: soma deve ser 55.",
                                    "Expanda para média: divida soma por 10.",
                                    "Debugue se resultado errado ajustando limites.",
                                    "Escreva versão para fatorial: inicialize fat=1, fat *= i de 1 a 5 (120)."
                                  ],
                                  "verification": "Código calcula e imprime soma=55 e fatorial=120 corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmos do step anterior, papel para cálculos manuais de verificação",
                                  "tips": "Para fatorial, comece de 1 e multiplique; evite fat=0.",
                                  "learningObjective": "Manipular variáveis acumuladoras dentro de loops for.",
                                  "commonMistakes": "Inicializar acumulador errado (ex: soma=1); multiplicar por 0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar e variar loops for para sequências",
                                  "subSteps": [
                                    "Crie loop com passo: de 1 a 20 pulando ímpares (i+=2).",
                                    "Otimize fatorial para n variável: use input para n.",
                                    "Compare performance mental: for vs while para 1000 iterações.",
                                    "Adicione break se i>15 para demonstração de controle.",
                                    "Refatore código anterior em função reutilizável."
                                  ],
                                  "verification": "Código imprime pares 2 4 ... 20 e fatorial de input (ex:5=120).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE com debugger",
                                  "tips": "Use range(1,21,2) em Python para passos.",
                                  "learningObjective": "Adaptar for para cenários otimizados e variáveis.",
                                  "commonMistakes": "Incremento errado causando loop infinito; esquecer input."
                                }
                              ],
                              "practicalExample": "Em Python: for i in range(1, 11): print(i)  # Imprime 1-10. Para fatorial: fact=1; for i in range(1,6): fact*=i; print(fact)  # 120. Em C equivalente com for(int i=1;i<=10;i++) printf(\"%d\\n\",i);",
                              "finalVerifications": [
                                "Loop executa número exato de iterações sem overflow.",
                                "Saídas numéricas batem com cálculos manuais (ex: soma 55, fat 120).",
                                "Código compila/executa sem warnings/erros.",
                                "Modificações em limites alteram saídas corretamente.",
                                "Não há loops infinitos ou off-by-one.",
                                "Variável acumuladora final é precisa."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe for 100% correta e eficiente.",
                                "Cálculos precisos em sequências e acumulativos.",
                                "Código limpo com comentários explicativos.",
                                "Tratamento de edge cases (n=0, n=1).",
                                "Otimização para repetições conhecidas vs while.",
                                "Demonstração de variações (passo, input)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências aritméticas, somas e produtos (fatorial).",
                                "Algoritmos: Complexidade O(n) para loops fixos.",
                                "Lógica: Condições booleanas em programação.",
                                "Estatística: Loops para médias e somas de dados."
                              ],
                              "realWorldApplication": "Processar listas fixas de dados como relatórios diários (1-31 dias), calcular totais em planilhas automatizadas, gerar tabelas de multiplicação em apps educacionais ou simular iterações em jogos com níveis conhecidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Aninhar loops for",
                            "description": "Criar estruturas aninhadas de loops for para gerar padrões como tabelas de multiplicação ou matrizes simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Loops For Simples",
                                  "subSteps": [
                                    "Estudar a sintaxe básica do loop for: for variavel in range(inicio, fim):",
                                    "Escrever um exemplo para imprimir números de 1 a 10",
                                    "Executar o código e observar a saída no console",
                                    "Modificar o loop para imprimir apenas números pares",
                                    "Testar com diferentes intervalos para entender range()"
                                  ],
                                  "verification": "Escrever e executar um loop for simples que imprima números de 1 a 10 sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code ou Replit)",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Use print() para visualizar cada iteração e depurar.",
                                  "learningObjective": "Dominar a sintaxe e execução de um loop for isolado.",
                                  "commonMistakes": [
                                    "Esquecer os dois pontos após o for",
                                    "Usar range(fim) em vez de range(1, fim+1)",
                                    "Indentação incorreta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Conceito de Aninhamento",
                                  "subSteps": [
                                    "Explicar que um loop interno executa completamente para cada iteração do loop externo",
                                    "Desenhar um diagrama fluxograma mostrando 2 iterações externas com 3 internas cada",
                                    "Simular manualmente um exemplo pequeno: externo 1-2, interno 1-3",
                                    "Identificar o total de execuções internas: linhas_externas * colunas_internas",
                                    "Discutir quando usar aninhamento (padrões 2D como tabelas)"
                                  ],
                                  "verification": "Descrever verbalmente ou por escrito como um loop aninhado funciona com um exemplo numérico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Editor de código para testes iniciais"
                                  ],
                                  "tips": "Pense no loop externo como 'linhas' e interno como 'colunas' de uma tabela.",
                                  "learningObjective": "Entender a lógica sequencial e multiplicativa de loops aninhados.",
                                  "commonMistakes": [
                                    "Confundir ordem de aninhamento",
                                    "Achar que loops rodam em paralelo",
                                    "Ignorar indentação dupla"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Padrão Visual Simples",
                                  "subSteps": [
                                    "Criar loop externo for i in range(1, 6): (5 linhas)",
                                    "Aninhar loop interno for j in range(i): print('*', end='')",
                                    "Adicionar print() vazio após interno para nova linha",
                                    "Executar e ajustar para formar triângulo de estrelas",
                                    "Variar o padrão imprimindo números em vez de estrelas"
                                  ],
                                  "verification": "O programa imprime um triângulo de estrelas com 1 na primeira linha até 5 na última.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Use end='' no print interno para manter na mesma linha.",
                                  "learningObjective": "Aplicar aninhamento para gerar padrões bidimensionais visuais.",
                                  "commonMistakes": [
                                    "Esquecer print() para quebra de linha",
                                    "Range errado no interno (use i)",
                                    "Excesso de espaços"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar Tabela de Multiplicação",
                                  "subSteps": [
                                    "Configurar loop externo for i in range(1, 6): (linhas 1-5)",
                                    "Aninhar loop interno for j in range(1, 6): (colunas 1-5)",
                                    "Calcular e imprimir i * j formatado como 'i x j = produto'",
                                    "Adicionar formatação alinhada com espaços ou tabs",
                                    "Testar saída e corrigir erros de cálculo ou alinhamento"
                                  ],
                                  "verification": "O programa imprime uma tabela 5x5 de multiplicação correta e alinhada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Use f-strings para formatação: print(f'{i} x {j} = {i*j}')",
                                  "learningObjective": "Construir estruturas aninhadas para dados tabulares matemáticos.",
                                  "commonMistakes": [
                                    "Erro no cálculo i*j",
                                    "Falta de alinhamento",
                                    "Loop interno começando em 0"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Estender para Matrizes Simples",
                                  "subSteps": [
                                    "Criar lista de listas simulando matriz 3x3: matrix = [[0]*3 for _ in range(3)]",
                                    "Usar loops aninhados para preencher: matrix[i][j] = i*3 + j + 1",
                                    "Imprimir matriz linha por linha com loop aninhado",
                                    "Adicionar exemplo de soma de linhas usando aninhamento",
                                    "Refatorar código para reutilizável com variáveis de tamanho"
                                  ],
                                  "verification": "Preencher e imprimir uma matriz 3x3 corretamente sem erros de índice.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Sempre verifique limites de índice para evitar IndexError.",
                                  "learningObjective": "Generalizar aninhamento para manipulação de estruturas de dados 2D.",
                                  "commonMistakes": [
                                    "Acessar índice fora do range",
                                    "Confundir i e j na matriz",
                                    "Não inicializar matriz corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um programa que gere e imprima a tabela de multiplicação de 1 a 10, com linhas rotuladas (ex: '  1: 1  2  3 ... 10') e colunas alinhadas, usando dois loops for aninhados. Formate para visualização clara como uma tabela.",
                              "finalVerifications": [
                                "Todos os produtos da tabela de multiplicação estão corretos (ex: 7x8=56).",
                                "A saída é formatada em grade/tabular sem desalinhamentos.",
                                "O programa executa sem erros de sintaxe ou runtime.",
                                "Padrões visuais como triângulo de estrelas são gerados precisamente.",
                                "Matriz 3x3 é preenchida e impressa com valores sequenciais corretos.",
                                "Tempo de execução é eficiente para tamanhos pequenos (sem loops infinitos)."
                              ],
                              "assessmentCriteria": [
                                "Loops corretamente aninhados com indentação adequada.",
                                "Uso preciso de range() para controlar iterações.",
                                "Cálculos e saídas livres de erros lógicos.",
                                "Formatação e alinhamento da saída visualmente claros.",
                                "Código comentado explicando o aninhamento.",
                                "Generalização para diferentes tamanhos via variáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reforça tabelas de multiplicação e operações aritméticas.",
                                "Artes e Design: Geração de padrões geométricos e visuais.",
                                "Análise de Dados: Processamento de matrizes e tabelas em planilhas.",
                                "Física: Simulação de grades em modelagem 2D (ex: campos vetoriais)."
                              ],
                              "realWorldApplication": "Loops for aninhados são essenciais em processamento de imagens (percorrer pixels linha por linha), geração de relatórios tabulares em sistemas empresariais, simulações de jogos (grids de mapas), análise de dados em planilhas ou bancos de dados, e automação de planilhas em ferramentas como Excel via scripts."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Loop Do-While",
                        "description": "Estrutura de repetição que executa o bloco de comandos pelo menos uma vez e verifica a condição booleana no final de cada iteração.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Compreender a sintaxe do loop do-while",
                            "description": "Identificar e codificar a sintaxe do do-while, destacando a execução inicial obrigatória antes da verificação da condição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura básica da sintaxe do loop do-while",
                                  "subSteps": [
                                    "Analise a sintaxe geral: 'do { corpo } while (condição);'",
                                    "Identifique os componentes: 'do' inicia, chaves delimitam o corpo, 'while' com parênteses para a condição e ponto e vírgula final",
                                    "Note que o corpo é executado pelo menos uma vez antes da verificação",
                                    "Compare visualmente com diagramas de fluxo de outros loops",
                                    "Escreva a sintaxe em pseudocódigo manualmente"
                                  ],
                                  "verification": "Reescreva corretamente a sintaxe em um papel ou editor sem erros",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou papel",
                                    "Diagrama de fluxo do do-while (impresso ou online)"
                                  ],
                                  "tips": "Sempre inclua o ponto e vírgula após a condição para evitar erros de compilação",
                                  "learningObjective": "Reconhecer e reproduzir a estrutura sintática exata do do-while",
                                  "commonMistakes": [
                                    "Esquecer o ponto e vírgula final",
                                    "Usar chaves incorretas ou ausentes",
                                    "Confundir com while tradicional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o fluxo de execução do loop",
                                  "subSteps": [
                                    "Simule a execução passo a passo: corpo executa primeiro, depois verifica condição",
                                    "Desenhe um fluxograma mostrando a execução inicial obrigatória",
                                    "Teste mentalmente com condição falsa desde o início (executa uma vez)",
                                    "Compare com loop while: diferença na ordem de verificação",
                                    "Anote cenários onde isso é útil (ex: menu que mostra pelo menos uma vez)"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que o corpo executa ao menos uma vez",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para fluxograma",
                                    "Vídeo tutorial curto sobre loops (opcional)"
                                  ],
                                  "tips": "Pense em 'faça primeiro, pergunte depois' para memorizar o fluxo",
                                  "learningObjective": "Diferenciar o fluxo do do-while de outros loops repetitivos",
                                  "commonMistakes": [
                                    "Achar que é como while (verificação primeiro)",
                                    "Ignorar execução mínima de uma vez",
                                    "Confundir com for"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar exemplos simples da sintaxe",
                                  "subSteps": [
                                    "Escreva um do-while que imprima 'Olá' uma vez (condição falsa)",
                                    "Crie um que some números até 10, usando contador",
                                    "Inclua variáveis de controle e atualize no corpo",
                                    "Compile e execute em um ambiente de programação",
                                    "Modifique a condição para testar loops infinitos (cuidado!)"
                                  ],
                                  "verification": "Código compila e executa conforme esperado, com saída correta",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador/IDE como Code::Blocks ou online (Repl.it)",
                                    "Exemplos de código base"
                                  ],
                                  "tips": "Use variáveis simples como int i = 1; para controle fácil",
                                  "learningObjective": "Implementar sintaxe correta em código funcional",
                                  "commonMistakes": [
                                    "Ponto e vírgula faltando causando loop infinito",
                                    "Atualização de variável fora do corpo",
                                    "Parênteses errados na condição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e corrigir variações e erros na sintaxe",
                                  "subSteps": [
                                    "Analise códigos com erros comuns e corrija-os",
                                    "Teste do-while com condições booleanas complexas",
                                    "Converta um while para do-while e vice-versa",
                                    "Crie um exemplo com input do usuário que valida pelo menos uma vez",
                                    "Debugue um código com loop infinito intencional"
                                  ],
                                  "verification": "Corrija 5 códigos errados com 100% de acerto",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de códigos com erros (preparada ou online)",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Sempre verifique o ';' final e a posição da atualização da variável",
                                  "learningObjective": "Diagnosticar e corrigir problemas sintáticos no do-while",
                                  "commonMistakes": [
                                    "Loop infinito por falta de atualização",
                                    "Condição sempre verdadeira",
                                    "Mistura com sintaxe de outros loops"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo em C: int i = 1; do { printf(\"Número: %d\\n\", i); i++; } while (i <= 5); // Imprime 1 a 5, mesmo se i>5 inicialmente executa uma vez.",
                              "finalVerifications": [
                                "Escreve a sintaxe completa sem erros",
                                "Explica o porquê da execução mínima de uma vez",
                                "Codifica e executa um do-while funcional",
                                "Diferencia do-while de while e for",
                                "Corrige erros sintáticos em exemplos dados",
                                "Simula fluxo com condição falsa inicial"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe 100% correta em códigos produzidos",
                                "Compreensão demonstrada no fluxo de execução",
                                "Exemplos práticos executáveis sem erros",
                                "Identificação precisa de diferenças com outros loops",
                                "Correção eficaz de erros comuns",
                                "Explicações claras e concisas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Condições lógicas e desigualdades",
                                "Lógica: Fluxogramas e algoritmos sequenciais",
                                "Física: Simulações de loops em processos repetitivos",
                                "Inglês: Leitura de documentação de linguagens"
                              ],
                              "realWorldApplication": "Usado em validação de inputs (ex: 'Digite uma opção válida' mostra menu pelo menos uma vez), jogos (animações que rodam uma frame inicial), e protocolos de rede que enviam pacotes mínimos antes de checar resposta."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Diferenciar do-while de while",
                            "description": "Comparar o comportamento do do-while com o while, ilustrando cenários onde o do-while é essencial, como validação de entrada com execução mínima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o loop while",
                                  "subSteps": [
                                    "Estudar a sintaxe: while (condição) { corpo }",
                                    "Analisar que a condição é avaliada antes da execução do corpo",
                                    "Executar um exemplo simples: imprimir números de 1 a 5",
                                    "Testar caso a condição inicial seja falsa: o loop não executa",
                                    "Identificar necessidade de inicialização e incremento"
                                  ],
                                  "verification": "Escrever e executar um código while que não executa nenhuma iteração",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Compilador de C ou pseudocódigo"
                                  ],
                                  "tips": "Sempre verifique a condição inicial para evitar loops infinitos",
                                  "learningObjective": "Dominar o comportamento pré-execução do while",
                                  "commonMistakes": [
                                    "Esquecer o incremento, causando loop infinito",
                                    "Não inicializar variáveis de controle"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o loop do-while",
                                  "subSteps": [
                                    "Estudar a sintaxe: do { corpo } while (condição);",
                                    "Analisar que o corpo executa pelo menos uma vez antes da condição",
                                    "Executar um exemplo simples: imprimir 'Olá' pelo menos uma vez",
                                    "Testar com condição falsa inicial: ainda executa uma vez",
                                    "Comparar visualmente com while em diagramas de fluxo"
                                  ],
                                  "verification": "Escrever e executar um do-while que executa exatamente uma iteração",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador de C",
                                    "Papel para diagramas"
                                  ],
                                  "tips": "Use ponto e vírgula após a condição no do-while",
                                  "learningObjective": "Entender a execução pós-teste do do-while",
                                  "commonMistakes": [
                                    "Esquecer o ponto e vírgula final",
                                    "Confundir com while sem o 'do'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar comportamentos dos loops",
                                  "subSteps": [
                                    "Criar tabelas comparativas: pré vs pós-teste, execução mínima",
                                    "Converter um while para do-while e vice-versa em códigos idênticos",
                                    "Simular execuções passo a passo com variáveis de exemplo",
                                    "Identificar cenários onde while falha (ex: 0 iterações necessárias)",
                                    "Discutir loops infinitos em ambos"
                                  ],
                                  "verification": "Criar uma tabela de diferenças e um código híbrido comentado",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Editor de código"
                                  ],
                                  "tips": "Pense em 'do-while faz primeiro, pergunta depois'",
                                  "learningObjective": "Diferenciar precisamente os fluxos de controle",
                                  "commonMistakes": [
                                    "Achar que do-while sempre executa mais",
                                    "Ignorar casos de condição falsa inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em cenários essenciais para do-while",
                                  "subSteps": [
                                    "Implementar validação de entrada: ler até número válido",
                                    "Criar menu interativo que executa pelo menos uma vez",
                                    "Comparar com while: mostrar falha em validação sem execução",
                                    "Testar com entradas inválicas múltiplas",
                                    "Refatorar código while problemático para do-while"
                                  ],
                                  "verification": "Executar código de validação que força pelo menos uma leitura",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador",
                                    "Entradas de teste"
                                  ],
                                  "tips": "Ideal para 'execute uma vez e valide'",
                                  "learningObjective": "Reconhecer quando do-while é obrigatório",
                                  "commonMistakes": [
                                    "Usar while em validações que precisam de execução mínima",
                                    "Loops infinitos por falha na condição"
                                  ]
                                }
                              ],
                              "practicalExample": "Código em C para menu de opções: do { printf('1-Somar 2-Sair'); scanf('%d', &op); if(op==2) break; ... } while(op != 2); // Executa menu pelo menos uma vez, essencial para interação inicial.",
                              "finalVerifications": [
                                "Explicar verbalmente por que do-while executa uma vez mesmo com condição falsa inicial",
                                "Converter um código while para do-while sem alterar lógica",
                                "Identificar em código dado qual loop garante execução mínima",
                                "Simular 3 iterações de cada loop com condição variável",
                                "Criar cenário onde while não funciona mas do-while sim",
                                "Depurar loop infinito em do-while"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da diferença de teste (pré vs pós)",
                                "Correção em exemplos de código funcional",
                                "Identificação correta de cenários essenciais para do-while",
                                "Uso adequado de sintaxe em implementações",
                                "Análise clara de comportamentos edge-case",
                                "Criatividade em aplicações práticas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica condicional e indução em sequências",
                                "Engenharia de Software: Controle de fluxo em algoritmos",
                                "Lógica: Análise de fluxogramas e diagramas de decisão",
                                "Design de UX: Validação de inputs em interfaces",
                                "Análise de Dados: Loops em processamento iterativo"
                              ],
                              "realWorldApplication": "Em sistemas bancários para validação de PIN: o teclado é lido pelo menos uma vez antes de checar validade, evitando falhas em interfaces físicas ou apps onde input inicial é garantido."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Aplicar do-while em interfaces interativas",
                            "description": "Desenvolver programas com do-while para menus interativos ou repetição até confirmação do usuário, garantindo pelo menos uma execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe e funcionamento do loop do-while",
                                  "subSteps": [
                                    "Estude a sintaxe básica: do { bloco de código } while (condição);",
                                    "Identifique que o bloco executa pelo menos uma vez antes da verificação da condição",
                                    "Compare com o loop while tradicional, destacando a diferença na ordem de execução",
                                    "Analise exemplos simples, como imprimir números até uma condição ser falsa",
                                    "Pratique escrevendo um do-while que executa uma ação uma vez e para imediatamente"
                                  ],
                                  "verification": "Explique em voz alta ou por escrito: 'Por que o do-while garante pelo menos uma execução e quando usá-lo?'",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem de programação (ex: C, Java ou Python com while equivalente)",
                                    "Exemplos de código online ou apostila do curso"
                                  ],
                                  "tips": [
                                    "Sempre teste a condição após o bloco para evitar loops infinitos iniciais.",
                                    "Visualize o fluxo: execute → teste → repita se verdadeiro."
                                  ],
                                  "learningObjective": "Dominar a sintaxe e a lógica única do do-while para cenários de execução garantida.",
                                  "commonMistakes": [
                                    "Confundir com while (que testa antes de executar)",
                                    "Esquecer o ponto e vírgula após a condição while",
                                    "Colocar a condição dentro do bloco em vez de após"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar a estrutura da interface interativa",
                                  "subSteps": [
                                    "Defina as opções do menu (ex: 1 - Opção A, 2 - Opção B, 0 - Sair)",
                                    "Especifique a variável de controle (ex: int opcao) e a condição de saída (opcao != 0)",
                                    "Esboce o fluxo: exibir menu → ler input do usuário → processar ação → verificar condição",
                                    "Considere validação básica de input (ex: repetir leitura se inválido)",
                                    "Desenhe um fluxograma simples mostrando o loop do-while"
                                  ],
                                  "verification": "Crie um fluxograma ou pseudocódigo que descreva o loop completo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta de diagrama online (ex: Draw.io ou Lucidchart)"
                                  ],
                                  "tips": [
                                    "Mantenha o menu simples com 3-4 opções para foco inicial.",
                                    "Pense no usuário: opções claras e numeradas."
                                  ],
                                  "learningObjective": "Planejar logicamente uma interface que exija repetição até confirmação do usuário.",
                                  "commonMistakes": [
                                    "Ignorar inputs inválidos no planejamento",
                                    "Definir condição de saída confusa",
                                    "Esquecer a execução inicial obrigatória"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o código do loop do-while com menu interativo",
                                  "subSteps": [
                                    "Inicie com 'do {' e escreva o código para exibir o menu e ler a opção do usuário",
                                    "Adicione estruturas if/switch para processar cada opção escolhida",
                                    "Feche com '} while (opcao != 0);' garantindo a condição de repetição",
                                    "Inclua uma mensagem de saída após o loop (ex: 'Programa encerrado')",
                                    "Compile o código e execute uma vez para verificação básica"
                                  ],
                                  "verification": "Execute o programa e confirme que o menu aparece pelo menos uma vez e repete até a saída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Dev-C++)",
                                    "Compilador da linguagem (ex: GCC para C)"
                                  ],
                                  "tips": [
                                    "Use printf/scanf em C ou input() em Python para simplicidade.",
                                    "Comente cada linha do loop para clareza."
                                  ],
                                  "learningObjective": "Codificar um programa funcional que utilize do-while para interface interativa.",
                                  "commonMistakes": [
                                    "Loop infinito por condição sempre verdadeira",
                                    "Não ler input corretamente (ex: char em vez de int)",
                                    "Executar ações fora do loop"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e refinar a interface",
                                  "subSteps": [
                                    "Teste cenários: input válido para repetição, input de saída, input inválido",
                                    "Verifique se o programa não trava ou entra em loop infinito",
                                    "Adicione validação de input dentro do do (ex: while para reler se inválido)",
                                    "Meça o tempo de execução e otimize mensagens para melhor UX",
                                    "Documente os testes realizados em um log simples"
                                  ],
                                  "verification": "Registre 5 testes diferentes com resultados esperados vs. reais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Programa compilado",
                                    "Terminal ou console para execução múltipla"
                                  ],
                                  "tips": [
                                    "Use breakpoints ou prints de debug para rastrear a variável de controle.",
                                    "Sempre teste o caso de 'saída na primeira iteração'."
                                  ],
                                  "learningObjective": "Garantir robustez e usabilidade da interface interativa com do-while.",
                                  "commonMistakes": [
                                    "Não testar saída imediata",
                                    "Ignorar inputs não numéricos",
                                    "Condição de loop invertida"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um menu de calculadora simples em C: '1 - Somar, 2 - Subtrair, 0 - Sair'. Use do-while para repetir até o usuário digitar 0, lendo dois números por opção e exibindo o resultado. Exemplo de código inicial: do { printf('Menu...'); scanf('%d', &op); if(op==1) { /* soma */ } } while(op != 0);",
                              "finalVerifications": [
                                "O menu é exibido pelo menos uma vez, independentemente da entrada inicial",
                                "O loop repete corretamente até a opção de saída ser escolhida",
                                "Cada opção processa inputs e executa a ação esperada",
                                "O programa encerra graciosamente sem erros ou loops infinitos",
                                "Inputs inválidos não causam crash (com validação básica)",
                                "Mensagens são claras e o fluxo é intuitivo para o usuário"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe do do-while 100% correta e funcional",
                                "Lógica de repetição atende à garantia de pelo menos uma execução",
                                "Interface interativa é clara, com menu bem formatado",
                                "Código é limpo, comentado e indentado adequadamente",
                                "Testes demonstram robustez contra casos edge",
                                "Validação de input implementada para usabilidade"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica condicional e estruturas de decisão",
                                "Design de Interfaces: Princípios de UX para menus intuitivos",
                                "Língua Portuguesa: Redação clara de mensagens e prompts",
                                "Ética em Computação: Tratamento seguro de inputs do usuário",
                                "Física/Engenharia: Modelagem de loops em sistemas de controle"
                              ],
                              "realWorldApplication": "Criação de menus em aplicativos console como ATMs bancários, jogos textuais interativos, sistemas de configuração de software ou interfaces de administração em ferramentas CLI, onde é essencial executar ações pelo menos uma vez antes de permitir saída."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Estruturas Seletivas",
                    "description": "Comando switch-case para seleção múltipla baseada em valores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Comando Switch-Case",
                        "description": "O comando switch-case é uma estrutura seletiva que permite a execução de diferentes blocos de código com base no valor de uma expressão inteira ou enumerada, oferecendo uma alternativa eficiente ao uso de múltiplos if-else aninhados para seleções múltiplas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Identificar cenários de uso do switch-case",
                            "description": "Reconhecer situações em que o switch-case é mais apropriado que if-else, como menus com opções fixas ou seleção baseada em valores discretos, analisando exemplos de algoritmos simples em linguagens procedimentais como C ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as limitações do if-else em cenários de múltiplas condições discretas",
                                  "subSteps": [
                                    "Revise a sintaxe básica de if-else em C/C++ com exemplos de 2-3 condições.",
                                    "Analise um código if-else aninhado para um menu com 5 opções e identifique repetições e legibilidade ruim.",
                                    "Compare o tempo de execução e manutenção de if-else para valores exatos (ex: char ou int discretos).",
                                    "Liste cenários onde if-else funciona bem (condições booleanas compostas).",
                                    "Discuta por que if-else falha em escalabilidade para 10+ opções fixas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito 3 limitações do if-else para menus fixos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código como Code::Blocks ou VS Code",
                                    "Documentação C/C++ sobre if-else"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar aninhamentos excessivos.",
                                  "learningObjective": "Identificar quando if-else se torna ineficiente para seleções discretas.",
                                  "commonMistakes": [
                                    "Confundir if-else com switch em condições de intervalo",
                                    "Ignorar legibilidade em cadeias longas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a sintaxe e vantagens do switch-case",
                                  "subSteps": [
                                    "Estude a sintaxe do switch-case em C/C++: switch(expr) { case val: ... break; }.",
                                    "Compare switch com if-else para um exemplo de seleção de dia da semana (1-7).",
                                    "Identifique requisitos: expressão deve ser integral (int, char), cases discretos.",
                                    "Explique o papel do 'break' para evitar fall-through.",
                                    "Liste vantagens: legibilidade, performance em jump tables para cases muitos."
                                  ],
                                  "verification": "Escreva um switch-case simples para 4 vogais e teste compilação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador GCC ou online como Replit",
                                    "Exemplos de código prontos"
                                  ],
                                  "tips": "Sempre inclua default: para cases não cobertos.",
                                  "learningObjective": "Reconhecer a sintaxe e cenários ideais para switch-case.",
                                  "commonMistakes": [
                                    "Esquecer 'break' causando execução múltipla",
                                    "Usar switch para floats ou strings"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos reais de algoritmos onde switch-case é superior",
                                  "subSteps": [
                                    "Examine um menu de calculadora: opções 1=soma, 2=subtração, etc., refatorando de if-else para switch.",
                                    "Analise seleção de comandos em um shell simples (ex: 'a'=add, 'd'=delete).",
                                    "Compare códigos lado a lado: conte linhas, leia legibilidade em voz alta.",
                                    "Teste performance com 20 cases simulando input aleatório.",
                                    "Identifique padrões: menus fixos, enums, estados finitos discretos."
                                  ],
                                  "verification": "Refatore um if-else fornecido para switch e justifique melhorias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Códigos exemplo em arquivo .c",
                                    "Cronômetro para testes de performance"
                                  ],
                                  "tips": "Use enums para cases para maior clareza semântica.",
                                  "learningObjective": "Diferenciar cenários práticos onde switch otimiza if-else.",
                                  "commonMistakes": [
                                    "Aplicar switch em condições lógicas complexas",
                                    "Overlook fall-through intencional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação de cenários em códigos variados",
                                  "subSteps": [
                                    "Receba 5 trechos de código mistos (if-else e switch) e classifique adequação.",
                                    "Crie fluxogramas para 3 algoritmos e decida estrutura seletiva ideal.",
                                    "Desenvolva um mini-projeto: menu de jogo com 6 opções usando switch.",
                                    "Debata em duplas: 'Por que não if-else aqui?' para cada caso.",
                                    "Registre 5 cenários pessoais onde switch seria melhor (ex: parser de teclas)."
                                  ],
                                  "verification": "Submeta relatório com 3 refatorações corretas e justificativas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Trechos de código para análise",
                                    "Ferramenta de fluxograma como Draw.io"
                                  ],
                                  "tips": "Pense em 'discretos e exatos' como regra de ouro para switch.",
                                  "learningObjective": "Aplicar critério de seleção autônomo em novos contextos.",
                                  "commonMistakes": [
                                    "Escolher switch por default sem analisar discrição",
                                    "Ignorar portabilidade (switch em C++11+ para strings)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de menu de banco em C: int opcao; printf('Escolha: 1-Deposito 2-Saque 3-Saldo'); scanf('%d', &opcao); switch(opcao){ case 1: depositar(); break; case 2: sacar(); break; ... default: printf('Invalido'); }. Superior a if-else aninhado por clareza em 7 opções fixas.",
                              "finalVerifications": [
                                "Lista corretamente 4 cenários ideais para switch-case (ex: menus, enums).",
                                "Refatora if-else para switch em exemplo dado sem erros sintáticos.",
                                "Explica fall-through e break com precisão.",
                                "Identifica 3 limitações do switch (não para ranges, floats).",
                                "Justifica escolha em código real com foco em legibilidade/performance.",
                                "Cria fluxograma correto para seleção discreta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção if-else vs switch (90% acerto em exemplos).",
                                "Profundidade de justificativas (cita legibilidade, performance, manutenção).",
                                "Qualidade do código refatorado (compila, testa corretamente).",
                                "Criatividade em cenários reais identificados.",
                                "Completude dos fluxogramas e relatórios.",
                                "Evita erros comuns como fall-through inadvertido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Mapeamento de funções discretas e teoria de conjuntos finitos.",
                                "Design de Interfaces: Princípios de UX em menus intuitivos e escaláveis.",
                                "Lógica Formal: Estados de máquina finita em automatos.",
                                "Engenharia de Software: Padrões de design para controle de fluxo.",
                                "Análise de Algoritmos: Complexidade O(1) em jump tables."
                              ],
                              "realWorldApplication": "Desenvolvimento de interfaces de usuário em sistemas embarcados (ex: menus de microcontroladores Arduino), parsers de comandos em shells Unix-like, switches em jogos para handling de inputs de teclado (WASD), e roteadores de eventos em aplicativos desktop C++ como editores de texto."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Diferenciar switch-case de estruturas condicionais simples",
                            "description": "Comparar o switch-case com if-else e if-elif-else, destacando vantagens em legibilidade e performance para comparações exatas de valores múltiplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Estruturas Condicionais Simples (if-else e if-elif-else)",
                                  "subSteps": [
                                    "Estude a sintaxe básica do if-else em uma linguagem procedural como C ou Python.",
                                    "Implemente um exemplo simples com if-else para comparar dois números.",
                                    "Expanda para if-elif-else lidando com múltiplas condições, como classificação de notas (A, B, C, etc.).",
                                    "Execute o código e observe o fluxo de execução.",
                                    "Anote as limitações em cenários com muitas comparações exatas."
                                  ],
                                  "verification": "Escrever e executar um código if-elif-else funcional que classifique 5 valores diferentes sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou IDLE)",
                                    "Documentação da linguagem (ex: Python docs)"
                                  ],
                                  "tips": "Comece com condições simples para evitar confusão; teste com valores de borda.",
                                  "learningObjective": "Compreender o funcionamento e limitações das estruturas if-else para comparações múltiplas.",
                                  "commonMistakes": [
                                    "Esquecer blocos else para casos padrão",
                                    "Indentação incorreta",
                                    "Usar == em vez de = em comparações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Sintaxe e Funcionamento do Switch-Case",
                                  "subSteps": [
                                    "Leia a documentação oficial do switch-case na linguagem escolhida.",
                                    "Escreva um exemplo básico de switch-case para mapear um inteiro a uma string (ex: 1 -> 'Um').",
                                    "Inclua um case default para valores inválidos.",
                                    "Compile e execute, verificando o case selecionado.",
                                    "Compare visualmente com um if-elif equivalente."
                                  ],
                                  "verification": "Implementar um switch-case que funcione corretamente para 4 cases + default.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Referência de sintaxe da linguagem (ex: cppreference para C++)"
                                  ],
                                  "tips": "Lembre-se que switch-case é para valores exatos; use break para evitar fall-through.",
                                  "learningObjective": "Dominar a sintaxe e execução do switch-case.",
                                  "commonMistakes": [
                                    "Esquecer 'break' causando execução de cases subsequentes",
                                    "Usar switch com tipos não-integráveis",
                                    "Não incluir default"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Sintaxe e Exemplos Equivalentes",
                                  "subSteps": [
                                    "Escreva o mesmo programa (ex: menu de opções 1-5) primeiro com if-elif-else.",
                                    "Refatore o código para switch-case equivalente.",
                                    "Compare linha por linha: contagem de linhas, clareza e repetições.",
                                    "Meça o tempo de execução com um profiler simples para 1000 iterações.",
                                    "Documente diferenças em legibilidade e performance."
                                  ],
                                  "verification": "Produzir dois códigos equivalentes e uma tabela de comparação com pelo menos 3 métricas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Ferramenta de profiling (timeit em Python)"
                                  ],
                                  "tips": "Use o mesmo input para ambos; foque em comparações exatas de valores.",
                                  "learningObjective": "Identificar diferenças práticas entre switch-case e condicionais simples.",
                                  "commonMistakes": [
                                    "Ignorar performance em loops",
                                    "Comparar cenários inadequados para switch",
                                    "Não testar com inputs inválidos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens, Desvantagens e Casos de Uso",
                                  "subSteps": [
                                    "Liste vantagens do switch-case: legibilidade para múltiplos valores exatos, potencial ganho de performance.",
                                    "Liste desvantagens: limitação a valores discretos, verbosidade em alguns casos.",
                                    "Identifique cenários ideais para switch (menus, enums) vs. if-else (condições complexas).",
                                    "Pesquise benchmarks online para performance em linguagens específicas.",
                                    "Crie um fluxograma comparando ambos."
                                  ],
                                  "verification": "Elaborar um relatório curto (200 palavras) com prós/contras e recomendações de uso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Navegador para benchmarks",
                                    "Ferramenta de fluxograma (Draw.io)"
                                  ],
                                  "tips": "Considere compiladores modernos que otimizam if-chains como jump tables.",
                                  "learningObjective": "Avaliar quando e por que preferir switch-case sobre condicionais simples.",
                                  "commonMistakes": [
                                    "Superestimar performance sem benchmarks",
                                    "Ignorar legibilidade em equipes",
                                    "Aplicar switch a ranges numéricos"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa de menu para um jogo simples: usuário digita 1-4 para 'Jogar', 'Configurações', 'High Scores', 'Sair'. Implemente primeiro com if-elif-else, depois refatore para switch-case. Meça linhas de código e tempo de execução em loop.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 vantagens do switch-case sobre if-elif para 5+ opções.",
                                "Reescrever um código if-elif fornecido usando switch-case corretamente.",
                                "Identificar em um código misto quando switch é mais apropriado.",
                                "Executar benchmarks mostrando diferença de performance em 10k iterações.",
                                "Criar um fluxograma comparativo sem erros lógicos.",
                                "Responder quiz com 80% acerto sobre diferenças sintáticas e semânticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários ideais para switch-case (peso 25%).",
                                "Clareza e completude na comparação de legibilidade/performance (peso 25%).",
                                "Correção sintática nos exemplos codificados (peso 20%).",
                                "Profundidade na análise de prós/contras com evidências (peso 15%).",
                                "Criatividade nos fluxogramas e exemplos práticos (peso 10%).",
                                "Ausência de erros comuns como fall-through (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equivalência lógica e árvores de decisão.",
                                "Lógica e Filosofia: Análise de casos exaustivos (proof by cases).",
                                "Design de Software: Padrões de menu e UX em interfaces.",
                                "Inglês Técnico: Leitura de documentação de linguagens.",
                                "Algoritmos: Otimização de tabelas de salto (jump tables)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos para menus de opções (Unity/C# switch), parsers de comandos CLI (git switch), roteadores de eventos em apps web (JavaScript switch em reducers), e sistemas embarcados onde performance em comparações múltiplas é crítica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Analisar fluxograma de execução do switch-case",
                            "description": "Interpretar diagramas de fluxo que representam o comportamento do switch-case, incluindo avaliação da expressão e salto para o case correspondente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a estrutura geral do fluxograma",
                                  "subSteps": [
                                    "Localize o símbolo de início (geralmente um oval) e o nó da expressão switch (retângulo com 'switch(expr)' ou similar).",
                                    "Identifique os nós de decisão para cada case (losangos representando comparação expr == case_value).",
                                    "Observe os nós de saída ou fim, incluindo possíveis saltos para default ou break.",
                                    "Mapeie todas as setas de fluxo de controle, anotando direções de entrada e saída.",
                                    "Verifique se há loops ou retornos implícitos ausentes no fluxograma."
                                  ],
                                  "verification": "Desenhe um esboço simplificado do fluxograma destacando início, switch e fim, e confirme que todos os nós estão conectados logicamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fluxograma impresso ou digital",
                                    "Lápis e papel para anotações",
                                    "Editor de diagramas como Draw.io (opcional)"
                                  ],
                                  "tips": "Comece pelo topo e siga as setas; ignore valores específicos inicialmente para focar na topologia.",
                                  "learningObjective": "Compreender a topologia visual do fluxograma switch-case para navegação intuitiva.",
                                  "commonMistakes": [
                                    "Confundir nós de decisão com ações",
                                    "Ignorar setas de salto condicional",
                                    "Pular o nó de default prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a avaliação da expressão switch",
                                  "subSteps": [
                                    "Identifique a expressão dentro do switch (ex: switch(diaSemana)) e liste possíveis tipos de dados (int, char, string).",
                                    "Trace o fluxo desde o switch até o primeiro losango de decisão para case 1.",
                                    "Simule avaliação: se expr == case1? Sim -> execute case1; Não -> próximo case.",
                                    "Anote o caminho para cada possível match inicial.",
                                    "Verifique se o fluxograma mostra avaliação sequencial ou otimizada (como jump table)."
                                  ],
                                  "verification": "Escreva pseudocódigo equivalente à avaliação inicial da expressão e teste com 2 valores de exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fluxograma",
                                    "Papel para simulações",
                                    "Calculadora para expressões complexas (se aplicável)"
                                  ],
                                  "tips": "Pense na expressão como uma chave que 'desbloqueia' um case específico; teste com valor conhecido.",
                                  "learningObjective": "Dominar como a expressão é avaliada e comparada sequencialmente com cases.",
                                  "commonMistakes": [
                                    "Assumir comparação paralela em vez de sequencial",
                                    "Ignorar tipo de dados da expressão",
                                    "Confundir expr com valor do case"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar matching de cases, breaks e default",
                                  "subSteps": [
                                    "Para cada case, trace o 'Sim' (match) para execução e 'Não' para próximo case.",
                                    "Localize instruções 'break' e siga setas de salto para após o switch.",
                                    "Identifique o case default (se presente) como último losango sem condição específica.",
                                    "Simule cenários: match exato, sem match (default), fall-through sem break.",
                                    "Anote fluxos para todos os cases possíveis."
                                  ],
                                  "verification": "Crie uma tabela de decisão: colunas para valores de expr, linhas para cases, marque caminhos tomados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fluxograma",
                                    "Planilha ou tabela em papel",
                                    "Exemplos de valores de teste"
                                  ],
                                  "tips": "Use cores diferentes para marcar caminhos de cada case; lembre-se que sem break há fall-through.",
                                  "learningObjective": "Entender dinâmicas de matching, salto e tratamento de default.",
                                  "commonMistakes": [
                                    "Esquecer fall-through sem break",
                                    "Confundir default com último case",
                                    "Ignorar saltos de break"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular execução completa e validar fluxos",
                                  "subSteps": [
                                    "Escolha 3-5 valores de entrada para a expressão e trace o caminho completo no fluxograma.",
                                    "Registre saídas esperadas para cada simulação (execução de cases).",
                                    "Verifique consistência: todos os caminhos levam a fim sem loops infinitos?",
                                    "Compare com código fonte equivalente se disponível.",
                                    "Identifique ambiguidades ou erros no fluxograma."
                                  ],
                                  "verification": "Documente simulações em um relatório curto, confirmando saídas corretas para todos os testes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fluxograma",
                                    "Lista de valores de teste",
                                    "Código fonte original (opcional)"
                                  ],
                                  "tips": "Teste edge cases: valor não listado, null/undefined, múltiplos matches.",
                                  "learningObjective": "Aplicar análise para validar comportamento dinâmico do switch-case.",
                                  "commonMistakes": [
                                    "Testar só valores óbvios",
                                    "Não simular default",
                                    "Perder track de breaks em simulações longas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um fluxograma para switch(dia): case 1: 'Segunda' break; case 2: 'Terça' break; default: 'Fim de semana'. Simule com dia=3: fluxo -> switch -> não case1 -> não case2 -> default -> 'Fim de semana' -> fim.",
                              "finalVerifications": [
                                "Trace corretamente o caminho para 5 valores de entrada diferentes.",
                                "Identifica presença e função de todos os breaks e default.",
                                "Explica verbalmente o fluxo sem olhar o fluxograma.",
                                "Detecta e corrige erros intencionais no fluxograma (ex: break ausente).",
                                "Converte fluxograma em pseudocódigo equivalente.",
                                "Simula fall-through corretamente em fluxogramas sem break."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de nós e setas (90%+ correto).",
                                "Correta simulação de matching e saltos para todos cases.",
                                "Compreensão demonstrada de default e fall-through.",
                                "Uso efetivo de tabelas/simulações para validação.",
                                "Detecção de inconsistências no fluxograma.",
                                "Clareza na documentação de análises."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Raciocínio: Similar a árvores de decisão em Matemática.",
                                "Algoritmos: Relaciona com estruturas de controle em Ciência da Computação.",
                                "Visualização de Dados: Interpretação de diagramas como em Estatística.",
                                "Engenharia: Fluxogramas em processos industriais e automação.",
                                "Linguagens: Paralelo com match-case em Python ou enum em Java."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, analisar fluxogramas de switch-case ajuda a debugar menus de aplicativos (ex: seleção de opções em apps mobile), roteadores de rede (switch por protocolo) e sistemas embarcado (controle de estados em IoT), garantindo execução eficiente e sem falhas lógicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Sintaxe e Elementos Básicos do Switch-Case",
                        "description": "A sintaxe padrão inclui a palavra-chave 'switch', parênteses com a expressão de controle, chaves delimitando cases, labels 'case' com valores constantes e 'break' para sair do bloco.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Escrever a sintaxe básica de um switch-case",
                            "description": "Construir um bloco switch-case simples com uma variável inteira como seletor, incluindo pelo menos dois cases e um default, em pseudocódigo ou linguagem C/C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral do switch-case",
                                  "subSteps": [
                                    "Estude a sintaxe básica: switch(expressão) { case valor1: código; break; ... default: código; }",
                                    "Identifique que a expressão deve ser inteira (int em C/C++)",
                                    "Note a obrigatoriedade dos 'break;' para evitar fall-through",
                                    "Revise exemplos em pseudocódigo: SWITCH x { CASE 1: print('Um'); BREAK; DEFAULT: print('Outro'); }",
                                    "Anote diferenças entre if-else e switch para seleção múltipla"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os componentes principais (switch, case, default, break)",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação de C/C++ sobre switch",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Visualize o switch como um menu com opções numeradas",
                                  "learningObjective": "Reconhecer e descrever todos os elementos sintáticos do switch-case",
                                  "commonMistakes": [
                                    "Confundir com if-else aninhado",
                                    "Esquecer que selector deve ser inteiro",
                                    "Ignorar a necessidade de break"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar a variável seletora e iniciar o switch",
                                  "subSteps": [
                                    "Declare uma variável int, ex: int opcao = 0;",
                                    "Escreva a linha de abertura: switch(opcao) {",
                                    "Adicione um case simples: case 1: printf('Opção 1'); break;",
                                    "Identifique o ponto de inserção para mais cases",
                                    "Garanta indentação consistente para legibilidade"
                                  ],
                                  "verification": "Código parcial compila sem erros de sintaxe quando adicionado a um main() básico",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C/C++ (gcc ou online como repl.it)",
                                    "Template de programa main() vazio"
                                  ],
                                  "tips": "Sempre inicialize a variável para evitar lixo de memória",
                                  "learningObjective": "Construir a estrutura inicial funcional com um case",
                                  "commonMistakes": [
                                    "Usar float ou char sem cast",
                                    "Esquecer chaves { }",
                                    "Falta de ponto e vírgula após break"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar múltiplos cases e o default",
                                  "subSteps": [
                                    "Insira pelo menos um case adicional: case 2: printf('Opção 2'); break;",
                                    "Adicione o default: default: printf('Opção inválida'); break;",
                                    "Teste logicamente fluxos: opcao=1, opcao=2, opcao=3",
                                    "Verifique alinhamento e espaçamento entre cases",
                                    "Simule execução mental para cada caminho"
                                  ],
                                  "verification": "Substitua valores na variável e trace o código manualmente sem erros",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama de fluxo",
                                    "Compilador para testes parciais"
                                  ],
                                  "tips": "Use números sequenciais nos cases para simplicidade inicial",
                                  "learningObjective": "Implementar seleção condicional completa com fallback",
                                  "commonMistakes": [
                                    "Fall-through intencional sem break",
                                    "Case com valores não-inteiros",
                                    "Default sem break"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar em programa completo e testar",
                                  "subSteps": [
                                    "Envolva em função main(): #include <stdio.h> int main() { int opcao; scanf('%d', &opcao); switch... return 0; }",
                                    "Compile: gcc programa.c -o programa",
                                    "Execute e teste inputs: 1, 2, 3 (inválido)",
                                    "Corrija erros de compilação ou runtime",
                                    "Documente o código com comentários"
                                  ],
                                  "verification": "Programa executa corretamente para todos os cases e default, sem warnings",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ambiente de desenvolvimento C/C++",
                                    "Entrada de teste preparada"
                                  ],
                                  "tips": "Use scanf para entrada interativa e demonstre uso real",
                                  "learningObjective": "Criar e validar um switch-case funcional em contexto de programa",
                                  "commonMistakes": [
                                    "Falta de & em scanf",
                                    "Includes omitidos",
                                    "Return sem valor em main"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa de menu simples: int dia; printf('Digite dia (1-7):'); scanf('%d', &dia); switch(dia){ case 1: printf('Segunda'); break; case 2: printf('Terça'); break; ... default: printf('Inválido'); }",
                              "finalVerifications": [
                                "Código compila sem erros ou warnings",
                                "Execução correta para cases específicos",
                                "Default captura valores fora dos cases",
                                "Breaks evitam execução de cases subsequentes",
                                "Entrada/saída via scanf/printf funcionam",
                                "Código comentado explica cada seção"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe 100% correta (switch, cases, default, breaks)",
                                "Pelo menos dois cases + default implementados",
                                "Selector é variável inteira válida",
                                "Indentação e legibilidade adequadas",
                                "Testes cobrem todos os caminhos lógicos",
                                "Integração em main() completo sem erros"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica discreta e conjuntos de valores",
                                "Algoritmos: Estruturas de decisão multi-ramo",
                                "Lógica de Programação: Fluxogramas para switch",
                                "Inglês Técnico: Leitura de documentação C/C++",
                                "Design de Software: Menus e interfaces baseadas em escolha"
                              ],
                              "realWorldApplication": "Implementação de menus em aplicativos console (ex: calculadoras, jogos simples), roteadores de comandos em shells, validação de opções em sistemas embarcados como controles remotos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Implementar labels case com valores constantes",
                            "description": "Definir múltiplos labels 'case' com valores literais inteiros compatíveis com o tipo da expressão de controle, garantindo correspondência exata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Sintaxe e Requisitos dos Labels Case",
                                  "subSteps": [
                                    "Estude a documentação da linguagem procedimental (ex: C) sobre a estrutura switch-case.",
                                    "Identifique que labels 'case' devem usar valores constantes literais inteiros ou enumerados compatíveis com o tipo da expressão de controle (geralmente int).",
                                    "Analise exemplos simples para entender a exigência de correspondência exata entre o valor da variável e o label case.",
                                    "Anote restrições: sem variáveis, floats ou strings nos cases; valores devem ser únicos.",
                                    "Verifique compatibilidade de tipos, como promoção implícita em inteiros."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando os requisitos e dê um exemplo verbal de erro comum.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (ex: manual do C)",
                                    "Editor de texto ou IDE como VS Code"
                                  ],
                                  "tips": "Comece com exemplos canônicos da linguagem para fixar a sintaxe exata.",
                                  "learningObjective": "Dominar as regras sintáticas e semânticas para labels case constantes.",
                                  "commonMistakes": [
                                    "Usar variáveis em vez de constantes",
                                    "Ignorar compatibilidade de tipos",
                                    "Esquecer que valores devem ser inteiros literais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar Constantes Inteiras para os Labels Case",
                                  "subSteps": [
                                    "Escolha 3-5 valores inteiros únicos e representativos (ex: 1 para VERMELHO, 2 para AZUL).",
                                    "Declare as constantes usando #define (ex: #define VERMELHO 1) ou const int VERMELHO = 1;",
                                    "Posicione as declarações no início do escopo apropriado (antes do switch).",
                                    "Teste a declaração compilando um programa simples que usa as constantes em printf.",
                                    "Garanta nomes descritivos para melhorar legibilidade."
                                  ],
                                  "verification": "Compile um snippet isolado com as constantes; verifique se não há erros de redefinição ou tipo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador (ex: gcc)",
                                    "Editor de código com suporte a C"
                                  ],
                                  "tips": "Use nomes em maiúsculas para #define para seguir convenções.",
                                  "learningObjective": "Aprender a criar e usar constantes para tornar o código mais legível e manutenível.",
                                  "commonMistakes": [
                                    "Valores duplicados",
                                    "Usar float ou char sem cast",
                                    "Declarar dentro do switch"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Estrutura Switch-Case com Labels Case",
                                  "subSteps": [
                                    "Escreva a declaração da variável de controle (ex: int opcao = 2;).",
                                    "Estruture o switch(opcao) { case CONST1: ...; case CONST2: ...; }",
                                    "Adicione pelo menos 3 labels case com as constantes declaradas.",
                                    "Inclua instruções simples em cada case (ex: printf).",
                                    "Adicione 'break;' após cada case para evitar fall-through."
                                  ],
                                  "verification": "Compile o código parcial; execute com um valor fixo e confira o branch correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador e terminal",
                                    "Exemplos de código de referência"
                                  ],
                                  "tips": "Indentação consistente ajuda a visualizar a estrutura; teste um case por vez.",
                                  "learningObjective": "Construir switch-case funcional com múltiplos cases constantes.",
                                  "commonMistakes": [
                                    "Esquecer 'break;' causando execução sequencial",
                                    "Ponto e vírgula após case",
                                    "Mismatch de valores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar com Default, Testar e Depurar",
                                  "subSteps": [
                                    "Adicione um case default: para valores não cobertos.",
                                    "Implemente entrada do usuário (ex: scanf para int).",
                                    "Compile e execute com inputs variados cobrindo todos os cases e default.",
                                    "Use debugger ou prints para rastrear o fluxo.",
                                    "Corrija erros identificados e reteste."
                                  ],
                                  "verification": "Execute 5 testes: 3 cases válidos, 1 default, 1 inválido; outputs corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador com suporte a debug (ex: gdb)",
                                    "Lista de casos de teste"
                                  ],
                                  "tips": "Sempre teste edge cases como valores fora do range.",
                                  "learningObjective": "Garantir robustez e corretude da estrutura seletiva.",
                                  "commonMistakes": [
                                    "Default sem break",
                                    "scanf sem validação",
                                    "Overflow em valores grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "#include <stdio.h>\n#define VERMELHO 1\n#define VERDE 2\n#define AZUL 3\n\nint main() {\n    int cor;\n    printf(\"Digite 1(Vermelho), 2(Verde) ou 3(Azul): \");\n    scanf(\"%d\", &cor);\n    switch(cor) {\n        case VERMELHO:\n            printf(\"Cor selecionada: Vermelho\\n\");\n            break;\n        case VERDE:\n            printf(\"Cor selecionada: Verde\\n\");\n            break;\n        case AZUL:\n            printf(\"Cor selecionada: Azul\\n\");\n            break;\n        default:\n            printf(\"Cor invalida!\\n\");\n    }\n    return 0;\n}",
                              "finalVerifications": [
                                "Código compila sem warnings ou erros de sintaxe.",
                                "Execução seleciona branch correto para cada constante.",
                                "Break statements previnem fall-through indesejado.",
                                "Default captura valores não mapeados.",
                                "Nomes de constantes melhoram legibilidade.",
                                "Testes com múltiplos inputs confirmam correspondência exata."
                              ],
                              "assessmentCriteria": [
                                "Uso exclusivo de constantes inteiras nos labels case.",
                                "Valores únicos e compatíveis com tipo da variável de controle.",
                                "Presença de break em todos os cases.",
                                "Inclusão de default para robustez.",
                                "Código legível com comentários explicativos.",
                                "Testes demonstram funcionamento correto."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação e comparação de valores inteiros.",
                                "Lógica e Algoritmos: Estruturas de decisão multi-ramo.",
                                "Design de Software: Uso de constantes para abstração e manutenção.",
                                "Análise de Sistemas: Validação de entradas em fluxos de controle."
                              ],
                              "realWorldApplication": "Implementação de menus interativos em aplicativos console (ex: escolha de opções em jogos ou ferramentas CLI), parsers de códigos de status em logs de sistemas, ou controladores de estados em dispositivos embarcados como Arduino."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Utilizar a instrução break",
                            "description": "Inserir 'break;' ao final de cada case para interromper a execução e evitar o fall-through para o próximo case, demonstrando o comportamento com e sem break.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Comportamento de Fall-Through no Switch-Case",
                                  "subSteps": [
                                    "Leia a documentação ou explicação sobre switch-case em linguagens procedurais como C.",
                                    "Identifique que sem 'break', o código continua executando os cases subsequentes (fall-through).",
                                    "Analise um diagrama de fluxo mostrando o comportamento sem interrupção.",
                                    "Discuta com um colega ou tutor o propósito do switch-case em estruturas seletivas.",
                                    "Anote exemplos de cenários onde fall-through pode ser intencional ou problemático."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que acontece sem 'break' em um switch com múltiplos cases.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação da linguagem (ex: man page de C), editor de texto simples.",
                                  "tips": "Visualize o fluxo como uma escada: sem break, você desce todos os degraus.",
                                  "learningObjective": "Entender o fluxo de execução padrão do switch-case sem interruptores.",
                                  "commonMistakes": "Confundir fall-through com erro de sintaxe; assumir que cada case é isolado por padrão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar o Problema com Código Sem Break",
                                  "subSteps": [
                                    "Escreva um programa simples com switch-case sem 'break;' em todos os cases.",
                                    "Compile e execute o código com diferentes entradas para observar fall-through.",
                                    "Registre saídas inesperadas onde múltiplos cases executam.",
                                    "Modifique a entrada para testar vários cenários e documente os resultados.",
                                    "Compare o comportamento observado com o esperado."
                                  ],
                                  "verification": "Execute o código e capture saídas mostrando execução de múltiplos cases para uma única entrada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador (ex: gcc para C), terminal ou IDE básica.",
                                  "tips": "Use printf para imprimir mensagens em cada case para visualizar o fluxo.",
                                  "learningObjective": "Reproduzir e observar o comportamento indesejado de fall-through na prática.",
                                  "commonMistakes": "Esquecer de testar múltiplas entradas; ignorar warnings do compilador."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Instrução Break para Corrigir o Fluxo",
                                  "subSteps": [
                                    "Adicione 'break;' ao final de cada case no código anterior.",
                                    "Recompile e reexecute com as mesmas entradas para comparar saídas.",
                                    "Teste um caso com fall-through intencional (sem break em um case específico) para demonstrar controle.",
                                    "Adicione um case default sem break para reforçar o aprendizado.",
                                    "Refatore o código para incluir comentários explicando cada break."
                                  ],
                                  "verification": "Confirme que apenas o case correspondente executa, sem vazamento para outros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo compilador e IDE do step anterior, papel para anotações.",
                                  "tips": "Sempre posicione 'break;' imediatamente após o código do case, antes da próxima label.",
                                  "learningObjective": "Aplicar 'break;' corretamente para interromper o fluxo e isolar cases.",
                                  "commonMistakes": "Colocar 'break;' dentro de condicionais, causando falhas intermitentes; esquecer no último case."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar em um Programa Completo",
                                  "subSteps": [
                                    "Crie um programa maior, como um menu interativo usando switch-case.",
                                    "Inclua breaks em todos os cases e teste todas as opções.",
                                    "Introduza intencionalmente um break faltante e corrija após observar o erro.",
                                    "Use debugger para pausar no switch e inspecionar o fluxo.",
                                    "Escreva um relatório resumindo diferenças com e sem break."
                                  ],
                                  "verification": "Programa executa corretamente todas as opções sem efeitos colaterais de fall-through.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Debugger (ex: gdb), IDE com suporte a debug.",
                                  "tips": "Em menus, fall-through pode executar saídas múltiplas, confundindo usuários.",
                                  "learningObjective": "Integrar 'break;' em contextos reais e validar o controle de fluxo.",
                                  "commonMistakes": "Não testar o case default; assumir que break é opcional em todos os cenários."
                                }
                              ],
                              "practicalExample": "Em um menu de calculadora simples: switch(op) { case 1: printf('Soma'); /*código soma*/ break; case 2: printf('Subtração'); /*código sub*/ break; ... }. Sem break no case 1, executa soma E subtração ao escolher 1.",
                              "finalVerifications": [
                                "Código compila sem warnings sobre fall-through.",
                                "Cada entrada ativa apenas o case pretendido.",
                                "Saídas correspondem exatamente ao esperado por case.",
                                "Debugger mostra saída imediata após break.",
                                "Programa lida corretamente com default sem vazamentos.",
                                "Comentários explicam o papel de cada break."
                              ],
                              "assessmentCriteria": [
                                "Explicação precisa de fall-through vs. break.",
                                "Códigos de exemplo funcionais e bem documentados.",
                                "Testes cobrem todos os cases, incluindo edge cases.",
                                "Identificação correta de erros comuns em switch.",
                                "Aplicação consistente de break em programas complexos.",
                                "Relatório demonstra compreensão profunda do fluxo."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Fluxogramas: Representar switch como decisão múltipla.",
                                "Debugging: Identificar fall-through como causa de bugs.",
                                "Matemática: Casos como funções piecewise.",
                                "Design de Software: Boas práticas em estruturas de controle."
                              ],
                              "realWorldApplication": "Em parsers de comandos CLI, menus de jogos ou roteadores de eventos em sistemas embarcados, onde fall-through causaria ações erradas, como executar múltiplas operações em um único input."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Case Default e Aplicações Práticas",
                        "description": "O label 'default' captura valores não previstos nos cases, atuando como fallback, e o switch-case é ideal para validação de entradas em programas interativos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Implementar o case default",
                            "description": "Adicionar um bloco 'default:' no switch-case para tratar valores fora dos cases definidos, exibindo mensagens de erro ou ações alternativas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito e a necessidade do case default",
                                  "subSteps": [
                                    "Estudar a estrutura switch-case e seus componentes (cases e break).",
                                    "Identificar situações em que uma variável pode receber valores não previstos nos cases.",
                                    "Analisar exemplos de código sem default para observar falhas em casos inesperados.",
                                    "Explicar verbalmente ou por escrito por que o default garante robustez no programa.",
                                    "Comparar switch com if-else aninhado para destacar vantagens do default."
                                  ],
                                  "verification": "Resumir em 3 frases o propósito do default e listar 2 cenários onde é essencial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem (ex: C, Java, JavaScript)",
                                    "Exemplos de código switch simples"
                                  ],
                                  "tips": [
                                    "Sempre pergunte: 'O que acontece se o input for inválido?'",
                                    "Visualize fluxogramas para entender o fluxo."
                                  ],
                                  "learningObjective": "Entender o papel do case default na prevenção de comportamentos indefinidos.",
                                  "commonMistakes": [
                                    "Confundir default com um case específico.",
                                    "Achar que o compilador avisa sobre casos não cobertos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a sintaxe do case default",
                                  "subSteps": [
                                    "Escrever um switch-case básico com 3-4 cases.",
                                    "Inserir o bloco 'default:' logo após o último case, antes do fechamento da chave.",
                                    "Adicionar instruções dentro do default, como exibir uma mensagem de erro.",
                                    "Incluir 'break;' no final do default para evitar fall-through.",
                                    "Compilar e verificar erros de sintaxe."
                                  ],
                                  "verification": "Produzir um código switch com default sintaticamente correto e compilado sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Dev-C++)",
                                    "Compilador da linguagem"
                                  ],
                                  "tips": [
                                    "Posicione default sempre no final para clareza.",
                                    "Use comentários para explicar o default."
                                  ],
                                  "learningObjective": "Reproduzir a sintaxe exata do case default de forma precisa.",
                                  "commonMistakes": [
                                    "Esquecer o dois-pontos após 'default'.",
                                    "Omitir 'break;' causando execução de código posterior."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o case default em um programa prático",
                                  "subSteps": [
                                    "Criar um programa com switch-case para um menu de opções (ex: 1=adicionar, 2=subtrair).",
                                    "Identificar o input da variável de controle (ex: int opcao).",
                                    "Adicionar o default com ação alternativa, como 'printf(\"Opção inválida!\");'.",
                                    "Integrar leitura de input do usuário.",
                                    "Adicionar loop para múltiplas execuções."
                                  ],
                                  "verification": "Executar o programa com input válido e inválido, confirmando execução do default.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Terminal para execução"
                                  ],
                                  "tips": [
                                    "Teste com valores extremos (negativos, zero).",
                                    "Torne a mensagem de erro informativa."
                                  ],
                                  "learningObjective": "Aplicar o default em contexto real para tratar entradas inválidas.",
                                  "commonMistakes": [
                                    "Não ler input corretamente.",
                                    "Colocar default antes dos cases."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e refinar a implementação",
                                  "subSteps": [
                                    "Executar o programa com valores cobertos pelos cases e verificar resultados.",
                                    "Testar com 5 valores inválidos diferentes e confirmar mensagem do default.",
                                    "Depurar erros comuns, como fall-through ou sintaxe.",
                                    "Refinar o default com ações mais úteis (ex: re-prompt input).",
                                    "Documentar o código com comentários sobre o default."
                                  ],
                                  "verification": "Relatório de testes mostrando 100% de cobertura de casos inválidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de debug (debugger, printf para traces)"
                                  ],
                                  "tips": [
                                    "Use asserts ou logs para tracing.",
                                    "Automatize testes com scripts simples."
                                  ],
                                  "learningObjective": "Garantir que o default funcione corretamente em todos os cenários.",
                                  "commonMistakes": [
                                    "Não testar inputs inválidos.",
                                    "Ignorar warnings do compilador."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma calculadora simples em C: switch(op) { case '+': resultado = a+b; break; ... default: printf(\"Operador inválido! Use +, -, *, /\"); } Ao digitar 'x', exibe erro e evita divisão por zero ou crash.",
                              "finalVerifications": [
                                "O bloco default é executado para valores não listados nos cases?",
                                "Mensagem de erro ou ação alternativa é exibida corretamente?",
                                "O programa continua executando sem crashar após default?",
                                "Sintaxe está 100% correta sem warnings?",
                                "Break está presente no default?",
                                "Input inválido é tratado de forma user-friendly?"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa do default (posição, dois-pontos, break).",
                                "Integração lógica no switch-case existente.",
                                "Mensagem ou ação no default é clara e útil.",
                                "Código testado com casos válidos e inválidos.",
                                "Comentários explicam o propósito do default.",
                                "Robustez: programa não falha em inputs inesperados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de decisão e conjuntos (casos exaustivos).",
                                "Português: Redação clara de mensagens de erro para usuários.",
                                "Ética e Cidadania: Programação defensiva para segurança de dados.",
                                "Física/Engenharia: Modelagem de estados em sistemas reais."
                              ],
                              "realWorldApplication": "Em aplicativos como menus de jogos (opções inválidas mostram 'Comando desconhecido'), validadores de formulários web (alertas para campos errados) ou sistemas bancários (rejeição segura de códigos inválidos), prevenindo crashes e melhorando experiência do usuário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Desenvolver programa com switch-case para menu",
                            "description": "Criar um programa completo que use switch-case para um menu de opções (ex: 1-calcular, 2-sair), integrando entrada/saída e atribuções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar a estrutura do menu e opções",
                                  "subSteps": [
                                    "Defina 3-5 opções claras para o menu (ex: 1-Calcular soma, 2-Calcular subtração, 3-Sair).",
                                    "Esboce um fluxograma simples mostrando o loop principal, leitura da opção e switch-case.",
                                    "Identifique variáveis necessárias: opção (int), valores de entrada (float ou int).",
                                    "Planeje o tratamento de saída (case para sair).",
                                    "Liste os casos especiais, incluindo default para opções inválidas."
                                  ],
                                  "verification": "Fluxograma desenhado e lista de opções documentada em um arquivo de texto ou papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Ferramenta de fluxograma online (opcional)"
                                  ],
                                  "tips": "Comece com opções simples para evitar complexidade inicial; inclua sempre 'Sair'.",
                                  "learningObjective": "Compreender a lógica do menu antes da implementação, promovendo design thinking.",
                                  "commonMistakes": [
                                    "Definir muitas opções (mais de 5)",
                                    "Esquecer opção de saída",
                                    "Não planejar default case"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o esqueleto do programa com loop e switch-case",
                                  "subSteps": [
                                    "Inclua headers necessários (#include <stdio.h>).",
                                    "Crie a função main() com um loop do-while ou while para repetir o menu.",
                                    "Exiba o menu com printf() dentro do loop.",
                                    "Leia a opção do usuário com scanf().",
                                    "Implemente a estrutura switch(opcao) com cases básicos e break em cada um."
                                  ],
                                  "verification": "Programa compila e exibe o menu em loop, aguardando input sem crashar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Dev-C++)",
                                    "Compilador C (GCC)"
                                  ],
                                  "tips": "Use do-while para garantir que o menu apareça pelo menos uma vez; valide input com default.",
                                  "learningObjective": "Dominar a sintaxe de switch-case dentro de loops para controle de fluxo.",
                                  "commonMistakes": [
                                    "Esquecer break nos cases",
                                    "Loop infinito sem condição de saída",
                                    "Não limpar buffer de input após scanf"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar funcionalidades aos cases e entrada/saída",
                                  "subSteps": [
                                    "No case 1, leia dois números e calcule/exiba o resultado (ex: soma).",
                                    "No case 2, implemente outra operação similar (ex: subtração).",
                                    "No case de saída (ex: 3), use break ou exit(0).",
                                    "Adicione case default para exibir mensagem de erro e pausar.",
                                    "Melhore saídas com mensagens claras e formatação (ex: printf com %.2f)."
                                  ],
                                  "verification": "Executando opções válidas, resultados corretos são exibidos; inválidas mostram erro.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador C",
                                    "Terminal para testes"
                                  ],
                                  "tips": "Use variáveis locais para cada cálculo; teste cada case isoladamente.",
                                  "learningObjective": "Integrar entrada/saída com estruturas seletivas para programas interativos.",
                                  "commonMistakes": [
                                    "Não declarar variáveis antes do switch",
                                    "Erros de cálculo em operações",
                                    "scanf sem & para variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e finalizar o programa",
                                  "subSteps": [
                                    "Compile e execute, testando todas as opções, incluindo inválidas e saída.",
                                    "Adicione pausas (system('pause') ou getch()) para visualizar resultados.",
                                    "Corrija bugs como loops infinitos ou crashes em input inválido.",
                                    "Adicione comentários no código explicando cada seção.",
                                    "Documente o programa com um cabeçalho (autor, data, descrição)."
                                  ],
                                  "verification": "Programa roda sem erros, todas opções funcionam e código está comentado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador C",
                                    "Ferramenta de debug (printf para traces)"
                                  ],
                                  "tips": "Teste com inputs extremos (0, números negativos, letras); use printf para debug.",
                                  "learningObjective": "Aplicar boas práticas de teste e manutenção em programas com switch-case.",
                                  "commonMistakes": [
                                    "Ignorar default case",
                                    "Não testar saída",
                                    "Código sem indentação ou comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa em C para menu de calculadora: exibe '1-Soma 2-Subtração 3-Sair'. Lê opção em loop; case 1 lê a+b e soma; case 2 subtrai; default erro; case 3 sai. Exemplo de saída: 'Resultado: 5.00'.",
                              "finalVerifications": [
                                "Programa compila e executa sem erros ou warnings.",
                                "Menu é exibido repetidamente até opção de saída.",
                                "Todas as opções produzem saídas corretas com inputs válidos.",
                                "Opções inválidas são tratadas pelo default case.",
                                "Código possui comentários e indentação adequada.",
                                "Entrada/saída usa formatação apropriada (ex: casas decimais)."
                              ],
                              "assessmentCriteria": [
                                "Uso correto e completo de switch-case com break e default.",
                                "Integração eficaz de loops com entrada/saída (scanf/printf).",
                                "Lógica de menu funcional e intuitiva.",
                                "Tratamento de erros para inputs inválidos.",
                                "Código limpo, comentado e bem estruturado.",
                                "Eficiência: sem loops infinitos ou vazamentos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações aritméticas básicas e precisão numérica.",
                                "Design de Interface: Princípios de UX para menus intuitivos.",
                                "Lógica e Algoritmos: Fluxogramas e estruturas de decisão.",
                                "Testes de Software: Estratégias de debugging e validação."
                              ],
                              "realWorldApplication": "Desenvolvimento de interfaces de usuário em aplicativos console, como menus de ATMs bancários, sistemas de gerenciamento de estoque, jogos textuais ou ferramentas administrativas em linguagens procedimentais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.3",
                              "10.1.3.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Tratamento de Exceções",
                "description": "Aborda técnicas para gerenciar erros e exceções durante a execução de programas.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Definição de Exceções",
                    "description": "Conceito de exceções como erros runtime e sua importância no gerenciamento de falhas em programas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Conceito de Exceção",
                        "description": "Definição fundamental de exceção como um evento que interrompe o fluxo normal de execução de um programa devido a uma condição inesperada.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Definir o que é uma exceção",
                            "description": "Explicar que uma exceção é um objeto ou sinal que representa um erro ou condição anormal detectada durante a execução runtime de um programa, diferenciando-a de erros de sintaxe ou compilação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as fases de execução de um programa",
                                  "subSteps": [
                                    "Estude o ciclo de vida de um programa: escrita de código, compilação ou interpretação, e execução em runtime.",
                                    "Identifique erros de sintaxe, que ocorrem na fase de escrita (ex: falta de parênteses).",
                                    "Explique erros de compilação, comuns em linguagens como Java ou C++ (ex: tipo incompatível).",
                                    "Diferencie erros em runtime, que só aparecem durante a execução.",
                                    "Crie um diagrama simples das fases com exemplos de erros."
                                  ],
                                  "verification": "Desenhe ou liste as fases com um exemplo de erro para cada uma e revise se está correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de Python ou Java sobre erros",
                                    "Vídeo introdutório no YouTube sobre ciclo de vida de programas"
                                  ],
                                  "tips": "Use a analogia de uma receita culinária: sintaxe é a receita escrita, compilação é preparar ingredientes, runtime é cozinhar.",
                                  "learningObjective": "Dominar as fases de um programa para contextualizar onde exceções ocorrem.",
                                  "commonMistakes": "Confundir erros de compilação com runtime, achando que ambos impedem execução."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar e exemplificar tipos de erros comuns",
                                  "subSteps": [
                                    "Liste erros de sintaxe (ex: print('Olá' em Python sem aspas fechadas).",
                                    "Liste erros de compilação (ex: variável não declarada em Java).",
                                    "Liste erros lógicos (ex: loop infinito, mas que roda).",
                                    "Identifique condições anormais em runtime (ex: arquivo não encontrado).",
                                    "Compare os tipos em uma tabela: quando detectados e impacto."
                                  ],
                                  "verification": "Crie uma tabela com 3 exemplos por tipo de erro e explique o impacto de cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código como VS Code",
                                    "Tutoriais online de erros comuns em Python/Java"
                                  ],
                                  "tips": "Teste códigos com erros intencionais em um playground online para ver na prática.",
                                  "learningObjective": "Classificar erros para isolar exceções como um subconjunto específico.",
                                  "commonMistakes": "Achar que todos os erros em runtime são exceções; nem todos geram exceções."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o conceito de exceção",
                                  "subSteps": [
                                    "Leia a definição: exceção é um objeto ou sinal que representa erro ou condição anormal em runtime.",
                                    "Anote características: gerada automaticamente pelo runtime, interrompe fluxo normal.",
                                    "Estude hierarquia em linguagens (ex: Exception em Java, BaseException em Python).",
                                    "Explique que exceções são tratáveis, diferentemente de crashes fatais.",
                                    "Escreva sua definição em 2-3 frases."
                                  ],
                                  "verification": "Escreva a definição completa e compare com fontes oficiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial: docs.python.org/3/tutorial/errors.html ou Oracle Java Exceptions"
                                  ],
                                  "tips": "Pense em exceções como 'alarmes' que o programa emite para alertar problemas.",
                                  "learningObjective": "Formular uma definição precisa de exceção.",
                                  "commonMistakes": "Definir exceção como qualquer erro, ignorando o foco em runtime."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar exceções de outros erros",
                                  "subSteps": [
                                    "Compare: sintaxe/compilação param antes de runtime; exceções ocorrem durante execução.",
                                    "Exemplo: erro de sintaxe não executa; exceção como divisão por zero executa até o erro.",
                                    "Discuta exceções checked vs unchecked (Java) ou built-in (Python).",
                                    "Crie fluxograma: erro → tipo → se exceção.",
                                    "Teste um código que gera exceção vs sintaxe."
                                  ],
                                  "verification": "Execute códigos exemplo e classifique o erro gerado como exceção ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "REPL Python online (repl.it)",
                                    "Compilador Java online"
                                  ],
                                  "tips": "Sempre rode o código para ver o stack trace, que confirma exceções.",
                                  "learningObjective": "Distinguir exceções de erros de sintaxe/compilação.",
                                  "commonMistakes": "Confundir exceções com erros de lógica que não crasham o programa."
                                }
                              ],
                              "practicalExample": "Em Python, execute: resultado = 10 / 0. Isso gera ZeroDivisionError em runtime, uma exceção que interrompe o programa, diferentemente de um erro de sintaxe como print(Olá) que nem compila.",
                              "finalVerifications": [
                                "Explique em suas palavras o que é uma exceção.",
                                "Dê um exemplo de exceção e um de erro de sintaxe, explicando a diferença.",
                                "Identifique se 'arquivo não encontrado' é exceção (sim, FileNotFoundError).",
                                "Descreva quando uma exceção é detectada.",
                                "Compare exceção com crash fatal.",
                                "Liste 2 características chave de exceções."
                              ],
                              "assessmentCriteria": [
                                "Definição inclui 'objeto/sinal em runtime' e 'condição anormal' (peso alto).",
                                "Diferenciação clara de sintaxe/compilação vs runtime.",
                                "Exemplos precisos e testáveis.",
                                "Uso correto de termos técnicos (ex: stack trace).",
                                "Compreensão de tratabilidade das exceções.",
                                "Fluxo lógico na explicação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Condições anormais como divisão por zero em cálculos.",
                                "Lógica e Filosofia: Conceitos de 'exceções à regra' em raciocínio.",
                                "Engenharia: Gerenciamento de falhas em projetos de sistemas robustos.",
                                "Física: Modelagem de eventos inesperados em simulações."
                              ],
                              "realWorldApplication": "Em um app de e-commerce, uma exceção é lançada se o usuário inserir um CEP inválido durante cadastro, permitindo capturar o erro, mostrar mensagem amigável e continuar o fluxo, evitando crash do sistema."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Identificar características de exceções",
                            "description": "Listar e descrever características principais de exceções, como serem assíncronas, propagáveis e tratáveis por mecanismos específicos da linguagem de programação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Conceito Básico de Exceções",
                                  "subSteps": [
                                    "Ler a definição oficial de exceções na documentação da linguagem (ex: Java Throwable hierarchy).",
                                    "Identificar diferenças entre exceções, erros e retornos normais de funções.",
                                    "Anotar exemplos de eventos que geram exceções (divisão por zero, arquivo não encontrado).",
                                    "Comparar exceções com fluxos de controle síncronos como if-else.",
                                    "Resumir em bullet points as propriedades iniciais observadas."
                                  ],
                                  "verification": "Escrever um parágrafo definindo exceção e listando 2 exemplos reais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (ex: Oracle Java Exceptions)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use analogias do dia a dia, como 'exceção é um imprevisto na estrada'.",
                                  "learningObjective": "Definir exceção e distinguir de outros mecanismos de controle de fluxo.",
                                  "commonMistakes": "Confundir exceções com erros de sintaxe ou semântica de compilação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Característica Assíncrona das Exceções",
                                  "subSteps": [
                                    "Executar código simples que lança exceção em runtime (ex: Integer.parseInt(null)).",
                                    "Observar que a exceção ocorre independentemente do fluxo sequencial esperado.",
                                    "Comparar com eventos síncronos como chamadas de método normais.",
                                    "Registrar timestamps ou pontos de parada para confirmar timing imprevisível.",
                                    "Documentar por que assincronia é crítica em programação concorrente."
                                  ],
                                  "verification": "Executar código e descrever o momento exato da interrupção do fluxo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou VS Code",
                                    "Código de exemplo com try-catch básico"
                                  ],
                                  "tips": "Use debugger para pausar e inspecionar o stack trace em tempo real.",
                                  "learningObjective": "Identificar e explicar a assincronia como interrupção não sequencial.",
                                  "commonMistakes": "Achar que exceções só ocorrem em loops ou condições específicas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Propagação de Exceções pela Pilha de Chamadas",
                                  "subSteps": [
                                    "Criar um programa com métodos aninhados onde exceção é lançada no mais interno.",
                                    "Observar como a exceção 'sobe' pela stack trace até ser capturada.",
                                    "Testar sem tratamento para ver stack overflow ou terminação.",
                                    "Adicionar throws em assinaturas de métodos e analisar impacto.",
                                    "Mapear a pilha de chamadas em um diagrama manual."
                                  ],
                                  "verification": "Gerar e interpretar um stack trace completo de uma exceção propagada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Código template com métodos recursivos leves"
                                  ],
                                  "tips": "Imprima stack traces com printStackTrace() para visualização clara.",
                                  "learningObjective": "Descrever como exceções propagam através de chamadas de métodos.",
                                  "commonMistakes": "Ignorar que propagação para apenas quando tratada ou chega ao main."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Mecanismos Específicos de Tratamento e Sintetizar Características",
                                  "subSteps": [
                                    "Implementar blocos try-catch-finally em código propagado.",
                                    "Testar checked vs unchecked exceptions (ex: IOException vs NullPointerException).",
                                    "Listar todas as características: assíncrona, propagável, tratável via try-catch.",
                                    "Comparar com linguagens diferentes (Java vs Python) para generalizar.",
                                    "Criar uma tabela resumindo características com exemplos."
                                  ],
                                  "verification": "Produzir uma lista completa de 5+ características com descrições e código de prova.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de try-catch",
                                    "Planilha ou Markdown para tabela"
                                  ],
                                  "tips": "Sempre inclua finally para cleanup, mesmo em testes simples.",
                                  "learningObjective": "Listar e descrever mecanismos de tratamento e sintetizar todas as características principais.",
                                  "commonMistakes": "Esquecer finally ou confundir checked/unchecked com tratabilidade."
                                }
                              ],
                              "practicalExample": "Em Java, crie um método divide(int a, int b) que lança ArithmeticException se b==0. Chame de outro método sem tratamento: a exceção propaga assincronamente do runtime, sobe a stack até main onde é capturada por try-catch, imprimindo 'Erro: divisão por zero' e limpando recursos no finally.",
                              "finalVerifications": [
                                "Listar corretamente assincronia, propagação e tratabilidade por try-catch.",
                                "Explicar stack trace de uma exceção propagada.",
                                "Diferenciar exceções de erros síncronos com exemplo de código.",
                                "Identificar 3+ outras características (ex: hierarquia Throwable, checked/unchecked).",
                                "Sintetizar em tabela ou lista todas as principais características.",
                                "Demonstrar tratamento em código funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na lista de características (mínimo 4 principais).",
                                "Uso correto de terminologia técnica (assíncrona, propagável, etc.).",
                                "Exemplos de código executáveis e comentados.",
                                "Análise clara de stack traces e fluxos de propagação.",
                                "Conexão explícita entre teoria e prática via verificações.",
                                "Ausência de confusões comuns como exceções vs. validações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de incertezas e casos edge em algoritmos.",
                                "Lógica e Estruturas de Dados: Fluxos condicionais avançados semelhantes a recursão.",
                                "Debugging e Análise: Interpretação de traces como em ciência de dados.",
                                "Design de Sistemas: Resiliência e fault-tolerance em engenharia."
                              ],
                              "realWorldApplication": "Em aplicações web como e-commerce, exceções de conexão ao banco propagam do serviço até o controller, sendo tratadas para retornar HTTP 500 amigável ao usuário, evitando crashes e logando erros para monitoramento em ferramentas como Sentry."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Diferenciar exceções de erros comuns",
                            "description": "Comparar exceções com outros tipos de erros, como erros lógicos ou de compilação, destacando que exceções ocorrem apenas em tempo de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar tipos de erros comuns em programação",
                                  "subSteps": [
                                    "Revise erros de sintaxe, que impedem a compilação do código.",
                                    "Estude erros de compilação, detectados pelo compilador antes da execução.",
                                    "Analise erros lógicos, onde o código executa mas produz resultados incorretos.",
                                    "Examine erros de runtime não excepcionais, como estouro de pilha sem tratamento.",
                                    "Liste exemplos de cada tipo em uma linguagem como Python ou Java."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 3 exemplos de cada erro comum e confirme se o código compila/executa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Documentação oficial de Python/Java sobre erros"
                                  ],
                                  "tips": "Use comentários no código para anotar o tipo de erro encontrado.",
                                  "learningObjective": "Ao final deste passo, você será capaz de classificar erros comuns sem usar tratamento de exceções.",
                                  "commonMistakes": [
                                    "Confundir erros de sintaxe com lógicos",
                                    "Ignorar que erros de compilação não executam o programa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de exceções",
                                  "subSteps": [
                                    "Defina exceções como erros detectados apenas em tempo de execução.",
                                    "Identifique triggers comuns: divisão por zero, acesso a índice inválido, arquivo não encontrado.",
                                    "Diferencie exceções tratáveis de crashes fatais.",
                                    "Estude a hierarquia de exceções em uma linguagem (ex: Exception em Java, BaseException em Python).",
                                    "Simule uma exceção simples em código e observe o comportamento padrão."
                                  ],
                                  "verification": "Execute um código que gera uma exceção e descreva o stack trace gerado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente de execução Python ou Java",
                                    "Referência de exceções da linguagem"
                                  ],
                                  "tips": "Sempre rode o código em modo debug para ver o stack trace completo.",
                                  "learningObjective": "Ao final, você identificará exceções como eventos runtime específicos e tratáveis.",
                                  "commonMistakes": [
                                    "Achar que todas exceções são erros de compilação",
                                    "Confundir exceções com avisos do IDE"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar exceções com erros comuns",
                                  "subSteps": [
                                    "Crie uma tabela de diferenças: momento de detecção (compile vs runtime), tratabilidade, impacto no programa.",
                                    "Compare exemplos: erro de compilação (variável não declarada) vs exceção (divisão por zero).",
                                    "Analise por que exceções são separadas: permitem recuperação via try-catch.",
                                    "Discuta cenários onde um erro lógico pode levar a uma exceção.",
                                    "Registre 5 diferenças chave em um documento."
                                  ],
                                  "verification": "Apresente a tabela de comparação e classifique 5 cenários mistos corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou documento Markdown",
                                    "Exemplos de código preparados"
                                  ],
                                  "tips": "Use cores na tabela para destacar diferenças (vermelho para compile-time, azul para runtime).",
                                  "learningObjective": "Você será capaz de destacar as distinções fundamentais entre exceções e outros erros.",
                                  "commonMistakes": [
                                    "Acreditar que exceções ocorrem em compile-time",
                                    "Ignorar que erros lógicos podem gerar exceções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar diferenciação em cenários reais",
                                  "subSteps": [
                                    "Analise 5 trechos de código com erros mistos e classifique cada um.",
                                    "Modifique códigos para transformar erros comuns em exceções tratáveis.",
                                    "Crie um fluxograma de decisão para identificar exceções vs outros erros.",
                                    "Teste seu fluxograma em novos exemplos não vistos.",
                                    "Registre acertos/erros e ajuste o fluxograma."
                                  ],
                                  "verification": "Classifique corretamente 10 cenários de teste com taxa de acerto >90%.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Banco de códigos de teste",
                                    "Ferramenta de fluxograma (Draw.io)"
                                  ],
                                  "tips": "Comece com exemplos simples e aumente a complexidade gradualmente.",
                                  "learningObjective": "Aplicar a diferenciação de forma autônoma em códigos reais.",
                                  "commonMistakes": [
                                    "Classificar exceções como lógicas sem verificar runtime",
                                    "Não considerar o contexto de execução"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: Erro de compilação (sintaxe): 'print(Hello)' → SyntaxError em compile-time. Exceção: 'print(1/0)' → ZeroDivisionError em runtime. Compare: o primeiro nem executa; o segundo roda até a linha problemática e pode ser capturado com try-except.",
                              "finalVerifications": [
                                "Classifique 5 erros aleatórios como exceção ou não-exceção com justificativa.",
                                "Explique verbalmente 3 diferenças chave entre exceções e erros de compilação.",
                                "Identifique em um stack trace se é exceção ou erro lógico.",
                                "Crie um exemplo onde erro lógico gera exceção.",
                                "Diferencie em código comentado um erro comum vs exceção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação: >90% de acertos em testes.",
                                "Compreensão conceitual: explicação clara de diferenças runtime vs compile-time.",
                                "Uso de exemplos relevantes e corretos.",
                                "Capacidade de recuperação: sugerir try-catch apenas para exceções.",
                                "Profundidade na comparação: cobrir tratabilidade e impacto."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Análise de falhas em algoritmos.",
                                "Engenharia: Modelagem de falhas e resiliência em sistemas.",
                                "Análise de Dados: Tratamento de erros em pipelines de dados.",
                                "Design de Sistemas: Princípios de robustez e depuração."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software empresarial, diferenciar exceções permite criar apps robustos que lidam com falhas runtime (ex: banco indisponível) sem crashar, melhorando UX e manutenibilidade em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Exceções como Erros Runtime",
                        "description": "Compreensão de exceções no contexto de erros que surgem durante a execução do programa, após a fase de compilação.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Explicar erros runtime",
                            "description": "Descrever erros runtime como falhas que ocorrem quando o programa está rodando, como divisão por zero ou acesso a memória inválida, e como eles geram exceções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Conceitos Básicos de Runtime",
                                  "subSteps": [
                                    "Estude o ciclo de vida de um programa: compile-time (verificação estática) vs runtime (execução dinâmica)",
                                    "Leia definições de runtime em documentações de linguagens como Python ou Java",
                                    "Anote diferenças entre fases de desenvolvimento e execução do código",
                                    "Crie um diagrama simples ilustrando quando ocorrem erros em cada fase",
                                    "Revise exemplos iniciais de falhas durante a execução"
                                  ],
                                  "verification": "Explique em 2-3 frases o que significa 'runtime' e forneça um exemplo verbal",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Python/Java",
                                    "Papel e caneta para diagrama",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use analogias cotidianas: compile-time é planejar uma viagem, runtime é dirigir e encontrar imprevistos",
                                  "learningObjective": "Compreender o contexto temporal de erros runtime no ciclo de vida do programa",
                                  "commonMistakes": [
                                    "Confundir runtime com tempo de compilação",
                                    "Ignorar que runtime aplica a linguagens compiladas e interpretadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Exemplos Comuns de Erros Runtime",
                                  "subSteps": [
                                    "Liste erros clássicos: divisão por zero, acesso a índice inválido em arrays, referência a variável não inicializada",
                                    "Pesquise exemplos em código: ZeroDivisionError em Python, NullPointerException em Java",
                                    "Execute códigos simples que causem esses erros em um interpretador online",
                                    "Registre o que acontece: programa para, mensagem de erro exibida",
                                    "Classifique 3-5 erros como runtime ou não-runtime"
                                  ],
                                  "verification": "Demonstre executando um código com divisão por zero e descreva o output",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Interpretador Python online (Replit)",
                                    "Exemplos de código prontos",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Sempre rode o código em ambiente controlado para observar o comportamento real",
                                  "learningObjective": "Reconhecer e exemplificar falhas típicas que só ocorrem em execução",
                                  "commonMistakes": [
                                    "Listar erros de sintaxe como runtime",
                                    "Subestimar impacto de variáveis não definidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Geração de Exceções por Erros Runtime",
                                  "subSteps": [
                                    "Estude como o runtime detecta anomalias e lança exceções (try-catch mental)",
                                    "Analise stack trace: o que mostra (linha, tipo de erro, causa)",
                                    "Compare exceções checked vs unchecked (Java) ou built-in (Python)",
                                    "Desenhe fluxo: erro ocorre → exceção lançada → programa interrompido ou tratado",
                                    "Escreva pseudocódigo ilustrando detecção automática"
                                  ],
                                  "verification": "Descreva o processo de geração de exceção para um erro específico, incluindo stack trace",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Documentação de exceções Python/Java",
                                    "Ferramenta de diagrama online (Draw.io)",
                                    "Exemplos de stack trace"
                                  ],
                                  "tips": "Foquem no 'por quê': exceções pausam execução para evitar corrupção de dados",
                                  "learningObjective": "Entender o mecanismo de exceções como resposta a erros runtime",
                                  "commonMistakes": [
                                    "Achar que exceções são opcionais",
                                    "Confundir lançamento manual com automático"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Diferenciar Erros Runtime",
                                  "subSteps": [
                                    "Crie tabela comparativa: runtime vs compile-time vs lógica",
                                    "Resuma causas raiz: inputs inválidos, estado inesperado, recursos indisponíveis",
                                    "Discuta prevenção inicial: validações, mas foco em detecção runtime",
                                    "Teste conhecimento respondendo quiz autoavaliativo com 5 perguntas",
                                    "Prepare explicação oral para ensinar a outro"
                                  ],
                                  "verification": "Apresente tabela comparativa e explique um erro runtime sem consultar notas",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha Google Sheets para tabela",
                                    "Quiz online sobre exceções"
                                  ],
                                  "tips": "Use mnemônicos: Runtime = 'Real-Time Unexpected' falhas",
                                  "learningObjective": "Integrar conhecimentos para explicar erros runtime de forma holística",
                                  "commonMistakes": [
                                    "Generalizar todos os erros como runtime",
                                    "Omitir papel das exceções na depuração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, execute: result = 10 / 0. Isso gera ZeroDivisionError durante runtime, exibindo stack trace com linha exata, interrompendo o programa e evitando resultados indefinidos como NaN em alguns contextos.",
                              "finalVerifications": [
                                "Define erro runtime como falha em execução, não em compilação",
                                "Cita pelo menos 3 exemplos: divisão por zero, acesso inválido, null reference",
                                "Explica geração de exceções com stack trace",
                                "Diferencia de erros de sintaxe ou lógica estática",
                                "Descreve impacto: programa para ou transfere controle via handler",
                                "Fornece analogia precisa para leigos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (sem confusão com compile-time)",
                                "Diversidade e correção de exemplos fornecidos",
                                "Clareza na explicação de exceções e stack trace",
                                "Uso de analogias ou diagramas para ilustração",
                                "Capacidade de diferenciação de tipos de erros",
                                "Profundidade em causas e consequências",
                                "Fluência na explicação oral ou escrita"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de operações indefinidas como divisão por zero",
                                "Lógica e Filosofia: Análise de estados inválidos e paradoxos computacionais",
                                "Física: Analogia com sistemas dinâmicos e falhas em simulações",
                                "Inglês Técnico: Interpretação de stack traces e terminologia de erros",
                                "Design de Sistemas: Prevenção de falhas em engenharia de software"
                              ],
                              "realWorldApplication": "Em desenvolvimento de aplicativos bancários, detectar divisão por zero em cálculos de juros evita crashes durante transações reais, permitindo depuração rápida via logs de exceções e garantindo estabilidade em produção."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Classificar exemplos de exceções runtime",
                            "description": "Identificar e classificar exemplos comuns de exceções runtime, como NullPointerException, IndexOutOfBoundsException ou ArithmeticException em linguagens como C++ ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Exceções Runtime",
                                  "subSteps": [
                                    "Defina exceções runtime como erros detectados durante a execução do programa, não na compilação.",
                                    "Diferencie de erros de compilação (sintaxe) e de lógica.",
                                    "Identifique causas comuns: divisão por zero, acesso a índice inválido, referência a objeto nulo.",
                                    "Revise hierarquia de exceções em Python (Exception > ArithmeticError, IndexError, etc.) e C++ (std::exception).",
                                    "Analise por que elas interrompem o fluxo normal do programa."
                                  ],
                                  "verification": "Escreva uma definição de 3-5 frases e liste 4 causas comuns com exemplos verbais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/3/tutorial/errors.html",
                                    "Documentação C++: std::exception",
                                    "Notebook de anotações"
                                  ],
                                  "tips": "Use analogias: exceções runtime são como tropeçar enquanto corre (execução), não planejar mal a rota (compilação).",
                                  "learningObjective": "Dominar a definição e causas fundamentais de exceções runtime.",
                                  "commonMistakes": [
                                    "Confundir com erros de sintaxe",
                                    "Ignorar que C++ nem sempre lança exceções automaticamente para alguns erros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Exemplos Comuns em Python",
                                  "subSteps": [
                                    "Execute código para ZeroDivisionError: print(10 / 0).",
                                    "Teste IndexError: lista = [1,2]; print(lista[5]).",
                                    "Simule referência nula: print(None[0]) para TypeError ou AttributeError.",
                                    "Registre KeyError em dicionários: d = {}; print(d['chave']).",
                                    "Capture e imprima o tipo da exceção usando try-except."
                                  ],
                                  "verification": "Crie e execute 4 snippets de código, cada um lançando uma exceção diferente, e identifique o tipo corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor Python (IDLE, VS Code)",
                                    "REPL Python interativo"
                                  ],
                                  "tips": "Sempre use try-except para capturar e printar exc_info() para ver detalhes.",
                                  "learningObjective": "Reconhecer e reproduzir exceções runtime específicas em Python.",
                                  "commonMistakes": [
                                    "Não diferenciar IndexError de KeyError",
                                    "Esquecer de executar o código para observar o erro real"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exceções em C++ e Comparar com Python",
                                  "subSteps": [
                                    "Compile e execute array out-of-bounds: int arr[3]; cout << arr[5]; (undefined behavior, não exceção sempre).",
                                    "Teste divisão por zero: int a = 10 / 0; (pode ser SIGFPE, não std::exception).",
                                    "Use std::vector e at() para std::out_of_range: vector<int> v(3); cout << v.at(5).",
                                    "Simule nullptr dereference: int* p = nullptr; cout << *p; (segfault).",
                                    "Compare: Python lança exceções automaticamente; C++ requer throw manual ou bibliotecas."
                                  ],
                                  "verification": "Escreva 3 códigos C++ que causem runtime errors/exceções e classifique cada um (ex: out_of_range como IndexOutOfBounds equivalente).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ online como Replit)",
                                    "Referência std::exception"
                                  ],
                                  "tips": "Em C++, at() lança exceções; [] não. Sempre cheque bounds manualmente.",
                                  "learningObjective": "Identificar equivalentes de exceções runtime em C++ e contrastar com Python.",
                                  "commonMistakes": [
                                    "Assumir que C++ lança exceções como Python para todos os casos",
                                    "Ignorar undefined behavior vs. exceções reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Classificação de Cenários Mistos",
                                  "subSteps": [
                                    "Crie uma tabela: cenário (ex: acessar lista[10] com 5 itens) -> classificação (IndexError em Python).",
                                    "Classifique 5 cenários aleatórios misturando linguagens.",
                                    "Desenvolva um quiz: dado traceback, identifique exceção e causa.",
                                    "Debata: quando uma exceção é 'inevitável' vs. erro de programação.",
                                    "Refatore um código buggy para prevenir 3 exceções comuns."
                                  ],
                                  "verification": "Classifique corretamente 8/10 cenários em um teste autoavaliado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos de tracebacks online"
                                  ],
                                  "tips": "Agrupe por categoria: aritmética, índice, referência, tipo.",
                                  "learningObjective": "Aplicar classificação de exceções em cenários reais de código.",
                                  "commonMistakes": [
                                    "Classificar todos como 'NullPointer' genericamente",
                                    "Não considerar contexto da linguagem"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: def risky(): l = [1,2,3]; print(l[5])  # IndexError\nprint(5/0)  # ZeroDivisionError\nprint(None.name)  # AttributeError. Execute e classifique cada erro no traceback.",
                              "finalVerifications": [
                                "Lista pelo menos 5 exceções runtime comuns com exemplos em Python e C++.",
                                "Classifica corretamente tracebacks de 4 cenários mistos.",
                                "Explica diferenças entre linguagens em 3 pontos chave.",
                                "Identifica prevenção básica para 3 exceções (ex: if len(l) > idx).",
                                "Cria um snippet que lança e captura uma exceção específica.",
                                "Diferencia exceções runtime de outras falhas (segfault, UB)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de exceções: 90%+ correto.",
                                "Profundidade nos substeps: todos completos com evidências (códigos executados).",
                                "Clareza na classificação: usa termos exatos (ex: IndexError, não 'erro de índice').",
                                "Compreensão comparativa: destaca diferenças Python/C++.",
                                "Criatividade na prática: cenários originais além dos exemplos.",
                                "Tempo de conclusão: dentro do estimado total (2 horas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Divisão por zero e limites (ArithmeticException).",
                                "Lógica e Algoritmos: Verificações de bounds em loops e arrays.",
                                "Engenharia de Software: Debugging e robustez de código.",
                                "Física/Computação: Modelagem de falhas em simulações (ex: overflow).",
                                "Inglês Técnico: Leitura de tracebacks e docs."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps web (evitar crashes em Django/Flask por KeyError), jogos (IndexError em arrays de levels), sistemas embarcados C++ (prevenir segfaults por nullptr), e debugging em produção para reduzir downtime."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Relacionar exceções com fluxo de execução",
                            "description": "Demonstrar como uma exceção runtime interrompe o fluxo normal de um programa e transfere o controle para um bloco de tratamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Fluxo Normal de Execução de um Programa",
                                  "subSteps": [
                                    "Escreva um programa simples com sequência linear de instruções, como imprimir mensagens e realizar cálculos básicos.",
                                    "Execute o programa e trace o fluxo usando print statements ou debugger para observar a execução sequencial.",
                                    "Desenhe um diagrama de fluxo simples mostrando o caminho normal sem interrupções.",
                                    "Identifique pontos onde o fluxo poderia ser alterado por erros.",
                                    "Registre o tempo total de execução e o output esperado."
                                  ],
                                  "verification": "O programa executa todas as linhas sequencialmente sem erros e produz output completo conforme esperado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code ou PyCharm), interpretador Python.",
                                  "tips": "Use print('Passo X') em cada linha para visualizar o fluxo.",
                                  "learningObjective": "Compreender a execução sequencial padrão de um programa sem exceções.",
                                  "commonMistakes": "Ignorar a ordem de execução ou não registrar todos os prints."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir uma Exceção Runtime no Programa",
                                  "subSteps": [
                                    "Modifique o programa adicionando código que gere uma exceção runtime, como divisão por zero (ex: 10 / 0).",
                                    "Execute o programa e observe a interrupção abrupta do fluxo normal.",
                                    "Analise a stack trace exibida, identificando onde a exceção ocorreu.",
                                    "Note que o código após o ponto de exceção não é executado.",
                                    "Compare o output com o fluxo normal anterior."
                                  ],
                                  "verification": "O programa para na linha da exceção, mostra stack trace e não executa código subsequente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmo editor e Python; anote stack trace em um arquivo.",
                                  "tips": "Coloque a exceção no meio do programa para ver claramente a interrupção.",
                                  "learningObjective": "Observar como exceções runtime quebram o fluxo sequencial.",
                                  "commonMistakes": "Confundir exceções runtime com erros de sintaxe que impedem execução."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Bloco de Tratamento de Exceções",
                                  "subSteps": [
                                    "Envolva o código problemático em um bloco try-except.",
                                    "Adicione um handler específico para ZeroDivisionError e um genérico para outras exceções.",
                                    "Execute e trace o fluxo: observe transferência para o except após a exceção.",
                                    "Adicione finally para cleanup e verifique sua execução independente do tratamento.",
                                    "Desenhe diagrama atualizado mostrando desvio para except."
                                  ],
                                  "verification": "Exceção é capturada, fluxo continua após except/finally, sem stack trace no console.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor, Python debugger (pdb ou IDE breakpoints).",
                                  "tips": "Use except Exception as e: print(e) para logar a exceção sem interromper.",
                                  "learningObjective": "Demonstrar transferência de controle para bloco de tratamento.",
                                  "commonMistakes": "Esquecer finally ou capturar exceções erradas, mascarando problemas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Comparar Fluxos com Diagrama",
                                  "subSteps": [
                                    "Crie diagramas lado a lado: fluxo normal, com exceção não tratada e tratada.",
                                    "Simule execução verbalmente com colega ou gravando tela.",
                                    "Teste variações: exceções em loops ou funções aninhadas.",
                                    "Documente diferenças no controle de fluxo em um relatório curto.",
                                    "Execute testes unitários para validar comportamentos."
                                  ],
                                  "verification": "Diagramas corretos mostram interrupção e desvio preciso; testes passam.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io ou papel), código de teste.",
                                  "tips": "Use setas coloridas: verde para normal, vermelho para exceção, azul para tratamento.",
                                  "learningObjective": "Relacionar visualmente exceções ao controle de fluxo do programa.",
                                  "commonMistakes": "Representar except como continuação linear em vez de desvio."
                                }
                              ],
                              "practicalExample": "Em Python:\n\ntry:\n    print('Início')\n    resultado = 10 / 0  # Exceção runtime\n    print('Após divisão')  # Não executa\nexcept ZeroDivisionError:\n    print('Tratada: Divisão por zero!')\n    resultado = 0\nfinally:\n    print('Cleanup final')\nprint('Fim do programa')  # Executa\n\nOutput: Início\nTratada: Divisão por zero!\nCleanup final\nFim do programa\n\nSem try-except, para em stack trace após 'Início'.",
                              "finalVerifications": [
                                "Diagrama de fluxo correto identifica interrupção e desvio para except.",
                                "Programa com exceção tratada executa completamente sem crash.",
                                "Stack trace analisada corretamente aponta linha exata da exceção.",
                                "Variações testadas (ex: em loop) mostram consistência no comportamento.",
                                "Relatório documenta pelo menos 3 diferenças chave nos fluxos.",
                                "Testes unitários validam tratamento sem alterar lógica normal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do ponto de interrupção do fluxo normal (90%+ correto).",
                                "Correta implementação e explicação do desvio para bloco except/finally.",
                                "Qualidade dos diagramas: claros, com setas e labels precisos.",
                                "Análise de stack trace e comparação de outputs antes/depois.",
                                "Criatividade em variações testadas e lições aprendidas.",
                                "Tempo de execução dentro dos estimados com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Lógica de Programação: Fluxogramas e controle condicional.",
                                "Debugging e Testes: Análise de stack traces como ferramenta de diagnóstico.",
                                "Engenharia de Software: Princípios de robustez e resiliência em sistemas.",
                                "Matemática: Modelagem de fluxos como grafos direcionados."
                              ],
                              "realWorldApplication": "Em servidores web (ex: Flask/Django), exceções como conexão falha são tratadas para retornar HTTP 500 graceful, mantendo app rodando; em apps mobile, evita crashes em inputs inválidos, melhorando UX."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Importância no Gerenciamento de Falhas",
                        "description": "Reconhecimento do papel das exceções no controle e recuperação de falhas em programas, promovendo robustez e manutenibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Descrever benefícios das exceções",
                            "description": "Explicar como exceções melhoram o gerenciamento de falhas ao permitir recuperação elegante, depuração facilitada e separação de lógica de erro da lógica principal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Gerenciamento Tradicional de Falhas sem Exceções",
                                  "subSteps": [
                                    "Estude métodos comuns como códigos de retorno (ex: retornar -1 ou null para indicar erro)",
                                    "Analise exemplos de código onde checagens if aninhadas poluem a lógica principal",
                                    "Identifique desvantagens: propagação manual de erros, propensão a ignorar falhas e código verboso",
                                    "Compare com cenários reais onde erros não tratados causam falhas em cascata",
                                    "Registre pelo menos três limitações em um documento"
                                  ],
                                  "verification": "Escreva um parágrafo resumindo as desvantagens dos códigos de erro tradicionais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código em Python ou Java (funções com códigos de retorno)",
                                    "Editor de texto ou IDE"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o aninhamento de ifs.",
                                  "learningObjective": "Identificar limitações do gerenciamento de erros sem exceções.",
                                  "commonMistakes": [
                                    "Ignorar que códigos de erro podem ser acidentalmente desconsiderados",
                                    "Confundir falhas síncronas com assíncronas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Exceções e sua Mecânica Básica",
                                  "subSteps": [
                                    "Defina exceções como eventos que interrompem o fluxo normal para sinalizar falhas",
                                    "Estude a estrutura try-catch-finally em linguagens como Python (try-except) ou Java",
                                    "Examine como exceções são lançadas (raise/throw) e propagadas pela pilha de chamadas",
                                    "Diferencie exceções checked vs unchecked (se aplicável à linguagem)",
                                    "Crie um fluxograma simples mostrando o fluxo de execução com exceções"
                                  ],
                                  "verification": "Desenhe um fluxograma de uma função que lança e captura uma exceção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação oficial de exceções (Python docs ou Java API)",
                                    "IDE com suporte a debugging"
                                  ],
                                  "tips": "Comece com exceções built-in como ZeroDivisionError para familiaridade.",
                                  "learningObjective": "Entender o mecanismo fundamental das exceções.",
                                  "commonMistakes": [
                                    "Pensar que exceções substituem toda validação de entrada",
                                    "Confundir lançamento com captura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Benefício da Recuperação Elegante",
                                  "subSteps": [
                                    "Explique como exceções permitem tratamento localizado e continuação da execução",
                                    "Compare código: sem exceções (propagação de erro para cima) vs com exceções (recuperação local)",
                                    "Implemente um exemplo onde uma falha em um módulo é recuperada sem afetar o todo",
                                    "Discuta cenários de retry automático ou fallback em caso de exceção",
                                    "Avalie como isso melhora a resiliência do software"
                                  ],
                                  "verification": "Modifique um código com ifs para usar try-catch e demonstre recuperação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de código fonte para edição",
                                    "Ambiente de execução (REPL ou IDE)"
                                  ],
                                  "tips": "Teste com entradas inválidas para ver a recuperação em ação.",
                                  "learningObjective": "Demonstrar como exceções habilitam recuperação graciosa de falhas.",
                                  "commonMistakes": [
                                    "Usar exceções para fluxo de controle normal",
                                    "Não especificar tipos de exceção corretos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Benefícios de Depuração Facilitada e Separação de Lógica",
                                  "subSteps": [
                                    "Descreva como stack traces fornecem contexto completo para depuração",
                                    "Compare depuração: rastrear ifs manuais vs stack trace de exceções",
                                    "Mostre como exceções separam lógica de negócio da lógica de erro",
                                    "Examine métricas: código mais limpo, legibilidade e manutenibilidade",
                                    "Sintetize os três benefícios principais em uma tabela comparativa"
                                  ],
                                  "verification": "Gere uma stack trace de uma exceção e explique seu conteúdo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Debugger integrado na IDE",
                                    "Códigos de exemplo com e sem exceções"
                                  ],
                                  "tips": "Use print statements ou logger para complementar stack traces.",
                                  "learningObjective": "Explicar ganhos em depuração e clareza de código com exceções.",
                                  "commonMistakes": [
                                    "Subestimar o valor de stack traces detalhadas",
                                    "Misturar lógica de erro na principal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um script de divisão de números, sem exceções: if num == 0 return -1; com exceções: try { result = a/b } catch (ArithmeticException e) { log(e); use fallback value }. Isso permite logar o erro, oferecer valor padrão e continuar, evitando crash.",
                              "finalVerifications": [
                                "Liste e explique os três benefícios principais das exceções.",
                                "Compare trechos de código equivalentes com e sem exceções.",
                                "Gere e interprete uma stack trace de uma exceção real.",
                                "Descreva um cenário onde recuperação elegante previne falha total.",
                                "Crie uma tabela resumindo prós vs contras de exceções.",
                                "Explique verbalmente a separação de lógica de erro da principal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos benefícios (recuperação, depuração, separação).",
                                "Uso correto de terminologia técnica (stack trace, throw/raise, catch/except).",
                                "Capacidade de comparar códigos com clareza e exemplos.",
                                "Demonstração prática via código funcional.",
                                "Compreensão de cenários reais de aplicação.",
                                "Identificação precisa de erros comuns em gerenciamento sem exceções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tratamento de divisões por zero e casos limite em algoritmos.",
                                "Design de Sistemas: Princípios de resiliência e fault-tolerance em engenharia.",
                                "Lógica e Filosofia: Separação de preocupações (concern separation).",
                                "Psicologia Cognitiva: Redução de carga mental em depuração de código.",
                                "Gestão de Projetos: Melhoria na manutenibilidade e redução de tempo de debug."
                              ],
                              "realWorldApplication": "Em sistemas bancários como apps de mobile banking, exceções capturam falhas de conexão de rede, permitindo retry automático e log para auditoria, sem crashar a app e frustrar o usuário durante uma transferência."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Analisar cenários sem tratamento de exceções",
                            "description": "Discutir consequências de não tratar exceções, como terminação abrupta do programa, perda de dados e dificuldade em diagnosticar problemas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender exceções comuns e seus triggers",
                                  "subSteps": [
                                    "Estudar definições de exceções runtime como ZeroDivisionError, IndexError e FileNotFoundError.",
                                    "Identificar linhas de código suscetíveis a exceções em exemplos simples.",
                                    "Analisar o fluxo de execução normal versus exceções em diagramas de fluxo.",
                                    "Discutir em grupo cenários reais onde exceções ocorrem.",
                                    "Consultar documentação oficial da linguagem (ex: Python docs)."
                                  ],
                                  "verification": "Criar uma lista de 5 exceções comuns com exemplos de código que as disparam.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de linguagem de programação (Python/Java)",
                                    "Editor de texto ou IDE",
                                    "Diagramas de fluxo impressos"
                                  ],
                                  "tips": "Priorize exceções runtime, pois elas não impedem a compilação.",
                                  "learningObjective": "Identificar triggers de exceções sem tratamento em código.",
                                  "commonMistakes": [
                                    "Confundir exceções com erros de sintaxe",
                                    "Ignorar exceções de entrada de usuário inválida",
                                    "Subestimar exceções em loops"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular cenários de código sem tratamento de exceções",
                                  "subSteps": [
                                    "Escrever um programa simples que cause divisão por zero (ex: 10 / 0).",
                                    "Executar o código e registrar o stack trace gerado.",
                                    "Criar outro exemplo com acesso a índice inválido em uma lista vazia.",
                                    "Rodar múltiplas simulações variando inputs para observar padrões de falha.",
                                    "Capturar screenshots ou logs das terminações abruptas."
                                  ],
                                  "verification": "Executar pelo menos 3 códigos e documentar o output de erro para cada um.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE como VS Code ou PyCharm",
                                    "Terminal para execução",
                                    "Papel para anotações de logs"
                                  ],
                                  "tips": "Use inputs dinâmicos (ex: input do usuário) para simular condições reais.",
                                  "learningObjective": "Observar empiricamente o comportamento de programas sem tratamento.",
                                  "commonMistakes": [
                                    "Não capturar stack traces completos",
                                    "Testar apenas casos ideais",
                                    "Executar em modo debug que mascara erros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar consequências específicas da falta de tratamento",
                                  "subSteps": [
                                    "Mapear terminação abrupta: programa para e não continua execução.",
                                    "Identificar perda de dados: variáveis não salvas ou transações incompletas.",
                                    "Examinar dificuldade de diagnóstico: stack trace genérico sem contexto.",
                                    "Quantificar impactos: tempo perdido em debug, frustração do usuário.",
                                    "Comparar com fluxos normais usando before/after diagrams."
                                  ],
                                  "verification": "Redigir um relatório com 3 consequências principais, ilustradas com evidências das simulações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Logs das simulações anteriores",
                                    "Ferramentas de diagramação (Draw.io)",
                                    "Modelos de relatório"
                                  ],
                                  "tips": "Use tabelas para comparar 'com' vs 'sem' tratamento.",
                                  "learningObjective": "Discutir qualitativa e quantitativamente os riscos de exceções não tratadas.",
                                  "commonMistakes": [
                                    "Focar só em crashes visíveis",
                                    "Ignorar impactos em dados persistentes",
                                    "Generalizar sem evidências"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar lições e preparar para tratamento",
                                  "subSteps": [
                                    "Listar estratégias preventivas baseadas nas análises.",
                                    "Discutir cenários em escala: apps web, bancos de dados.",
                                    "Criar um checklist de análise para futuros códigos.",
                                    "Apresentar achados em grupo e receber feedback.",
                                    "Refletir sobre importância no ciclo de desenvolvimento."
                                  ],
                                  "verification": "Produzir um checklist personalizado com 5 itens para análise de exceções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Checklist modelo",
                                    "Ferramenta de apresentação (Google Slides)"
                                  ],
                                  "tips": "Conecte lições a boas práticas como 'fail-fast' vs robustez.",
                                  "learningObjective": "Internalizar importância do tratamento para software confiável.",
                                  "commonMistakes": [
                                    "Checklist genérico sem personalização",
                                    "Ignorar feedback grupal",
                                    "Subestimar escalabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de caixa eletrônico, ao dividir o saldo por zero (input inválido), o programa crasha sem salvar a transação, resultando em perda de registro, saldo inconsistente e necessidade de intervenção manual do banco.",
                              "finalVerifications": [
                                "Pode reproduzir e explicar terminação abrupta em 3 cenários simulados.",
                                "Lista pelo menos 4 consequências como perda de dados e debug difícil.",
                                "Cria diagramas mostrando fluxo interrompido por exceção.",
                                "Desenvolve checklist para análise de exceções em código novo.",
                                "Explica impactos em sistemas reais com exemplos concretos.",
                                "Identifica 3 exceções comuns sem olhar documentação."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na identificação de triggers e consequências (30%).",
                                "Qualidade das simulações e evidências documentadas (25%).",
                                "Profundidade da análise qualitativa/quantitativa (20%).",
                                "Criatividade e relevância do checklist e diagramas (15%).",
                                "Participação e integração de feedback grupal (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de operações indefinidas como divisão por zero.",
                                "Gestão de Projetos: Planejamento de riscos e robustez em entregas.",
                                "Ética e Responsabilidade: Proteção de dados usuários em falhas.",
                                "Lógica e Raciocínio: Debugging como processo dedutivo.",
                                "Comunicação: Apresentação clara de análises técnicas."
                              ],
                              "realWorldApplication": "Em aplicações de e-commerce como Amazon, exceções não tratadas em carrinho de compras (ex: item indisponível) causam crashes, perda de vendas, reclamações de clientes e custos de suporte, destacando a necessidade de try-catch para uptime 99.9%."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Justificar uso em programação robusta",
                            "description": "Argumentar a importância das exceções para desenvolver software confiável, citando exemplos de linguagens procedimentais como C++ e sua relação com lógica de programação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Programação Robusta e Exceções",
                                  "subSteps": [
                                    "Defina programação robusta como a capacidade de um software lidar com erros inesperados sem crashar.",
                                    "Explique exceções como mecanismos para capturar e tratar erros de forma estruturada.",
                                    "Compare exceções com alternativas como códigos de retorno em linguagens procedimentais.",
                                    "Identifique cenários comuns de falhas, como divisão por zero ou falha de I/O.",
                                    "Discuta por que ignorar erros leva a software não confiável."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo programação robusta e exceções, com pelo menos 3 exemplos de falhas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de linguagens como C++ e Python sobre exceções; vídeo introdutório sobre robustez.",
                                  "tips": "Use analogias cotidianas, como freios de emergência em carros, para ilustrar robustez.",
                                  "learningObjective": "Compreender os pilares conceituais de exceções na construção de software confiável.",
                                  "commonMistakes": "Confundir exceções com bugs; achar que exceções são apenas para linguagens OO."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos em Linguagens Procedimentais como C++",
                                  "subSteps": [
                                    "Estude o mecanismo try-catch em C++ para tratamento de exceções.",
                                    "Compare com abordagens tradicionais como setjmp/longjmp ou códigos de erro.",
                                    "Implemente um exemplo simples em C++: divida por zero sem e com exceções.",
                                    "Observe como exceções propagam erros de forma limpa pela pilha de chamadas.",
                                    "Registre diferenças em legibilidade e manutenção do código."
                                  ],
                                  "verification": "Compile e execute um código C++ com try-catch, demonstrando captura de exceção.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador C++ (g++); exemplos de código de exceções do cppreference.com.",
                                  "tips": "Teste cenários de falha reais, como arquivo inexistente, para ver exceções em ação.",
                                  "learningObjective": "Dominar exemplos práticos de exceções em C++ para embasar argumentos.",
                                  "commonMistakes": "Ignorar overhead de performance das exceções; não testar propagação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Argumentar Benefícios para Software Confiável",
                                  "subSteps": [
                                    "Liste benefícios: separação de lógica de negócio de tratamento de erros.",
                                    "Discuta como exceções evitam aninhamento excessivo de ifs para checagem de erros.",
                                    "Cite estatísticas ou casos: crashes em apps sem exceções vs. recuperação graciosa.",
                                    "Explique relação com princípios como fail-fast e recovery.",
                                    "Prepare contra-argumentos, como performance em sistemas embedded."
                                  ],
                                  "verification": "Escreva 3 argumentos pró-exceções com evidências de C++.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigos sobre 'exception handling best practices'; livros como 'Effective C++'.",
                                  "tips": "Use bullet points para estruturar argumentos claros e persuasivos.",
                                  "learningObjective": "Construir argumentos lógicos sobre a superioridade das exceções.",
                                  "commonMistakes": "Focar só em teoria sem exemplos concretos; superestimar exceções como panaceia."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Lógica de Programação e Sintetizar Justificativa",
                                  "subSteps": [
                                    "Conecte exceções à lógica booleana: condições de erro como fluxos alternativos.",
                                    "Discuta como exceções promovem código modular e reutilizável.",
                                    "Sintetize uma justificativa completa: 'Exceções em C++ elevam robustez ao...'.",
                                    "Pratique oralmente ou em escrita persuasiva.",
                                    "Revise e refine com feedback simulado."
                                  ],
                                  "verification": "Apresente uma justificativa de 200 palavras, citando C++ e lógica.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Folha de papel ou editor de texto; gravação para auto-avaliação.",
                                  "tips": "Estruture como tese-evidência-conclusão para força argumentativa.",
                                  "learningObjective": "Integrar conceitos em uma defesa coesa do uso de exceções.",
                                  "commonMistakes": "Omitir relação com lógica; fazer argumento genérico sem C++."
                                }
                              ],
                              "practicalExample": "Em um sistema bancário em C++, ao tentar sacar saldo insuficiente, uma exceção 'InsufficientFundsException' é lançada, permitindo log do erro, notificação ao usuário e rollback da transação, evitando perda de dados em vez de retornar código -1 e crashar o app.",
                              "finalVerifications": [
                                "Pode definir programação robusta e exceções corretamente?",
                                "Citar e explicar try-catch em C++ com exemplo funcional?",
                                "Listar 3 benefícios das exceções vs. códigos de erro?",
                                "Relacionar exceções à lógica de programação com pelo menos 2 conexões?",
                                "Escrever uma justificativa persuasiva de 150+ palavras?",
                                "Identificar cenários onde exceções falham e alternativas?"
                              ],
                              "assessmentCriteria": [
                                "Clareza e estrutura lógica do argumento (30%)",
                                "Precisão técnica em exemplos de C++ (25%)",
                                "Uso de evidências e contra-argumentos (20%)",
                                "Relevância à robustez e lógica de programação (15%)",
                                "Originalidade e persuasão na justificativa (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional em fluxos de controle de exceções.",
                                "Física: Sistemas de controle de falhas em engenharia (ex: redundância).",
                                "Língua Portuguesa: Argumentação persuasiva e redação técnica.",
                                "Ética: Responsabilidade em desenvolver software seguro para usuários."
                              ],
                              "realWorldApplication": "Em aviões autônomos (como drones da NASA), exceções em C++ gerenciam falhas de sensores, permitindo pouso de emergência seguro, prevenindo acidentes e garantindo conformidade com normas de segurança como DO-178C."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Tipos de Exceções",
                    "description": "Classificação de exceções em verificadas, não verificadas e erros, com exemplos em linguagens como C++ e Python.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Exceções Verificadas",
                        "description": "Exceções verificadas são aquelas que o compilador de certas linguagens, como Java, obriga o programador a tratar explicitamente no momento da compilação, usando try-catch ou declarando throws. Em C++ e Python, não há exceções estritamente verificadas, mas o conceito é importante para entender linguagens que impõem verificação em tempo de compilação.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Definir exceções verificadas",
                            "description": "Explicar o que são exceções verificadas, sua obrigatoriedade pelo compilador e contrastar com linguagens como C++ (onde exceções como std::out_of_range não são verificadas) e Python (todas exceções são runtime).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender exceções básicas em Java",
                                  "subSteps": [
                                    "Estude a hierarquia de exceções: Throwable > Exception e Error",
                                    "Identifique que Exceptions são divididas em checked e unchecked",
                                    "Revise exemplos comuns como NullPointerException (unchecked) vs IOException (checked)",
                                    "Analise o fluxograma de lançamento e captura de exceções",
                                    "Pratique identificando tipos em código simples"
                                  ],
                                  "verification": "Liste 3 exceções checked e 3 unchecked corretamente",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java Exceptions",
                                    "Editor de código como IntelliJ ou VS Code"
                                  ],
                                  "tips": "Use diagramas de herança para visualizar a hierarquia",
                                  "learningObjective": "Dominar a hierarquia e classificação inicial de exceções em Java",
                                  "commonMistakes": [
                                    "Confundir Exception com Error",
                                    "Ignorar a distinção checked/unchecked"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e exemplificar exceções verificadas",
                                  "subSteps": [
                                    "Defina checked exceptions como subclasses de Exception (exceto RuntimeException)",
                                    "Explique que são 'verificadas' pelo compilador em tempo de compilação",
                                    "Estude declaração obrigatória com 'throws' em métodos",
                                    "Analise exemplos: IOException, SQLException",
                                    "Escreva um método simples que lança uma checked exception"
                                  ],
                                  "verification": "Escreva um método que compila apenas com 'throws IOException'",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "API Java Docs para Exception subclasses",
                                    "Compilador Java (javac)"
                                  ],
                                  "tips": "Sempre verifique erros de compilação para entender enforcement",
                                  "learningObjective": "Explicar precisamente o que são exceções verificadas e sua obrigatoriedade",
                                  "commonMistakes": [
                                    "Achar que todas Exceptions são checked",
                                    "Esquecer 'throws' em signatures"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar com exceções unchecked e outras linguagens",
                                  "subSteps": [
                                    "Compare com unchecked: RuntimeException e subclasses (ex: NullPointerException)",
                                    "Analise C++: std::out_of_range é runtime, sem verificação pelo compilador",
                                    "Estude Python: Todas exceções são runtime, sem distinção checked",
                                    "Crie tabela comparativa Java vs C++ vs Python",
                                    "Discuta vantagens: Java força handling explícito"
                                  ],
                                  "verification": "Preencha tabela comparativa sem erros",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação C++ std::exception",
                                    "Python exceptions docs",
                                    "Planilha ou tabela Markdown"
                                  ],
                                  "tips": "Use exemplos de código em cada linguagem para ilustrar",
                                  "learningObjective": "Diferenciar checked exceptions de Java com abordagens em C++ e Python",
                                  "commonMistakes": [
                                    "Confundir runtime de C++ com checked",
                                    "Achar Python tem checked exceptions"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar enforcement pelo compilador",
                                  "subSteps": [
                                    "Escreva código que tenta compilar sem 'throws' ou try-catch para checked exception",
                                    "Corrija adicionando handling adequado",
                                    "Teste cenários: método chamando outro com throws",
                                    "Compile e execute para ver erros em tempo de compilação vs runtime",
                                    "Refatore código para demonstrar conformidade"
                                  ],
                                  "verification": "Código compila sem warnings de unchecked exceptions",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "Exemplos de código Java"
                                  ],
                                  "tips": "Use 'javac -Xlint:unchecked' para mais insights",
                                  "learningObjective": "Demonstrar como o compilador Java enforce checked exceptions",
                                  "commonMistakes": [
                                    "Usar @SuppressWarnings indevidamente",
                                    "Confundir compile-time com runtime errors"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa que lê um arquivo: public void readFile(String path) throws IOException { ... } – O compilador força 'throws IOException' ou try-catch, simulando I/O real onde falhas como arquivo não encontrado devem ser tratadas explicitamente.",
                              "finalVerifications": [
                                "Defina corretamente exceções verificadas em 1 frase",
                                "Liste 3 exemplos de checked exceptions em Java",
                                "Explique por que std::out_of_range em C++ não é verificada",
                                "Descreva diferença com Python exceptions",
                                "Mostre código que falha compilação sem handling",
                                "Compare enforcement em tabela"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (100% match com docs Java)",
                                "Correta distinção checked vs unchecked (sem confusões)",
                                "Exemplos válidos e compiláveis",
                                "Contraste claro com C++ e Python",
                                "Entendimento de compile-time enforcement",
                                "Uso correto de 'throws' e try-catch em exemplos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de fluxos condicionais e tratamento de casos edge",
                                "Inglês: Terminologia técnica em documentação (API docs)",
                                "Design de Software: Princípios de robustez e error handling",
                                "Física/Engenharia: Modelagem de falhas previsíveis em sistemas"
                              ],
                              "realWorldApplication": "Em aplicações empresariais como bancos ou e-commerces, checked exceptions forçam desenvolvedores a tratar erros de rede (SocketException) ou banco (SQLException), prevenindo crashes silenciosos e garantindo software resiliente em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Identificar exemplos de exceções verificadas",
                            "description": "Reconhecer exemplos como IOException em Java; em C++, discutir exceções derivadas de std::exception sem verificação obrigatória; em Python, notar ausência e usar raise Exception('mensagem') como equivalente não verificado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Exceções Verificadas",
                                  "subSteps": [
                                    "Leia a definição: Exceções verificadas (checked exceptions) são aquelas que o compilador obriga o programador a tratar explicitamente no momento da compilação.",
                                    "Compare com exceções não verificadas (unchecked): as verificadas herdam de Exception (não RuntimeException) em Java.",
                                    "Estude a hierarquia de exceções em linguagens como Java, C++ e Python usando diagramas oficiais.",
                                    "Anote diferenças chave: Java força 'throws' ou 'try-catch'; C++ não obriga; Python não tem conceito nativo.",
                                    "Crie um fluxograma simples mostrando o fluxo de compilação com e sem tratamento."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e explique com um exemplo simples de Java.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Java Exceptions (Oracle Docs)",
                                    "Diagramas de hierarquia de exceções em C++ e Python",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use cores para diferenciar checked vs unchecked em diagramas para melhor retenção visual.",
                                  "learningObjective": "Definir exceções verificadas e contrastá-las com não verificadas em múltiplas linguagens.",
                                  "commonMistakes": [
                                    "Confundir exceções verificadas com erros de runtime",
                                    "Ignorar que C++ e Python não forçam verificação em compile-time"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Exemplos em Java",
                                  "subSteps": [
                                    "Analise código Java: 'FileReader fr = new FileReader(\"file.txt\");' – identifique IOException como verificada.",
                                    "Liste comuns: SQLException, IOException, ParseException – verifique herança de Exception.",
                                    "Compile código sem try-catch: observe erro de compilação 'unhandled exception'.",
                                    "Escreva código corrigido com throws ou try-catch e compile novamente.",
                                    "Compare com RuntimeException (unchecked) como NullPointerException."
                                  ],
                                  "verification": "Compile um código Java com IOException sem tratamento e corrija-o, documentando o erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "IDE como IntelliJ ou Eclipse",
                                    "Exemplos de código de Oracle Tutorials"
                                  ],
                                  "tips": "Sempre cheque a hierarquia com 'extends Exception?' para confirmação rápida.",
                                  "learningObjective": "Reconhecer e listar exemplos concretos de exceções verificadas em Java.",
                                  "commonMistakes": [
                                    "Achar que todas as Exceptions são verificadas (ignore RuntimeException)",
                                    "Não testar compilação para validar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exceções em C++ e Comparar",
                                  "subSteps": [
                                    "Estude std::exception e derivadas: std::runtime_error, std::logic_error – note ausência de verificação obrigatória.",
                                    "Escreva código C++ com throw std::runtime_error sem try-catch – compile sem erros.",
                                    "Compare com Java: discuta trade-offs (flexibilidade vs segurança).",
                                    "Analise código exemplo: função que lança std::invalid_argument sem declaração throws.",
                                    "Crie tabela comparativa: Java (checked) vs C++ (unchecked por design)."
                                  ],
                                  "verification": "Compile código C++ lançando std::exception sem catch e confirme que compila.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador GCC/Clang",
                                    "Documentação C++ std::exception (cppreference.com)",
                                    "Planilha para tabela comparativa"
                                  ],
                                  "tips": "Lembre: C++ prioriza performance; exceções são runtime, não compile-time.",
                                  "learningObjective": "Identificar que C++ não tem exceções verificadas e exemplificar com std::exception.",
                                  "commonMistakes": [
                                    "Assumir que C++ força try-catch como Java",
                                    "Confundir exceções C++ com checked Java"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exceções em Python e Síntese Final",
                                  "subSteps": [
                                    "Note: Python não tem exceções verificadas; todas são unchecked em runtime.",
                                    "Exemplo equivalente: raise Exception('mensagem') – sem obrigatoriedade de catch.",
                                    "Teste código: def read_file(): open('file.txt') – rode sem try-except, observe runtime error.",
                                    "Sintetize: crie mindmap conectando Java (IOException), C++ (std::exception), Python (raise Exception).",
                                    "Pratique identificando em snippets mistos de linguagens."
                                  ],
                                  "verification": "Crie e rode código Python com raise Exception sem tratamento, explicando por que não é verificada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3 instalado",
                                    "Documentação Python Exceptions (python.org)",
                                    "Ferramenta de mindmap como XMind"
                                  ],
                                  "tips": "Pense em Python como 'duck typing' para exceções: flexível, mas requer disciplina manual.",
                                  "learningObjective": "Reconhecer ausência em Python e sintetizar conhecimento cross-language.",
                                  "commonMistakes": [
                                    "Procurar 'checked exceptions' em Python",
                                    "Não testar runtime behavior"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise este snippet Java: public void readFile() { FileInputStream fis = new FileInputStream('data.txt'); } // Erro: unhandled IOException (verificada). Corrija adicionando try-catch ou throws IOException. Em C++: void readFile() { throw std::runtime_error('File not found'); } // Compila sem problemas. Em Python: def readFile(): raise Exception('File not found') # Roda até erro runtime.",
                              "finalVerifications": [
                                "Liste 3 exceções verificadas em Java com exemplos.",
                                "Explique por que std::exception em C++ não é verificada.",
                                "Demonstre raise Exception em Python sem tratamento obrigatório.",
                                "Identifique corretamente em um snippet misto de código.",
                                "Crie tabela comparativa de 3 linguagens.",
                                "Explique impacto na compilação/execução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de checked vs unchecked (90% acerto).",
                                "Uso correto de exemplos reais de cada linguagem.",
                                "Demonstração prática via compilação/execução.",
                                "Síntese clara em comparações cross-language.",
                                "Ausência de confusões comuns (ex: RuntimeException como checked).",
                                "Profundidade em verificações e mindmaps."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Matemática: Fluxo de controle e grafos de decisão em tratamento de erros.",
                                "Engenharia: Design de sistemas robustos e análise de falhas (fault tolerance).",
                                "Filosofia da Computação: Trade-offs entre segurança estática e flexibilidade dinâmica.",
                                "Debugging e Testes: Integração com unit tests para exceções."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise (ex: apps bancários), identificar exceções verificadas como IOException previne crashes por I/O falho, garantindo apps robustas que logam erros e continuam operando, comum em servidores Java como Spring Boot."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Comparar tratamento em C++ e Python",
                            "description": "Analisar código em C++ com try { throw std::runtime_error(\"erro\"); } catch(...) {} e em Python com try: raise ValueError('erro') except ValueError: print('tratado'), destacando falta de verificação em compilação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar sintaxe de tratamento de exceções em C++",
                                  "subSteps": [
                                    "Estude o bloco try-catch em C++: try { código } catch (const std::exception& e) { tratamento }",
                                    "Analise o exemplo: try { throw std::runtime_error(\"erro\"); } catch(...) {}",
                                    "Compile e execute um código simples com throw e catch para observar runtime behavior",
                                    "Identifique que C++ usa exceções unchecked, sem obrigatoriedade de catch",
                                    "Note o uso de catch(...) para capturar qualquer exceção"
                                  ],
                                  "verification": "Compilar e executar código sem erros em runtime e descrever o que acontece sem catch",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou Visual Studio)",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Use std::runtime_error para exceções customizadas; sempre inclua <stdexcept> e <iostream>",
                                  "learningObjective": "Compreender a estrutura básica de try-throw-catch em C++ e seu comportamento em runtime",
                                  "commonMistakes": [
                                    "Esquecer #include <stdexcept>",
                                    "Não inicializar variáveis no catch",
                                    "Ignorar exceções não tratadas levando a terminate()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar sintaxe de tratamento de exceções em Python",
                                  "subSteps": [
                                    "Estude o bloco try-except: try: código except ValueError: tratamento",
                                    "Analise o exemplo: try: raise ValueError('erro') except ValueError: print('tratado')",
                                    "Execute o código Python para ver o tratamento seletivo",
                                    "Teste com except Exception: para capturar múltiplas exceções",
                                    "Observe que Python também não força tratamento em runtime"
                                  ],
                                  "verification": "Executar script Python e confirmar que exceção é capturada e mensagem impressa",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Interpretador Python 3.x",
                                    "Editor como IDLE ou Jupyter Notebook"
                                  ],
                                  "tips": "Use raise para lançar exceções específicas; prefira except específicas a genéricas",
                                  "learningObjective": "Dominar a estrutura try-raise-except em Python e seu fluxo de execução",
                                  "commonMistakes": [
                                    "Usar except: sem especificar tipo (captura tudo, incluindo KeyboardInterrupt)",
                                    "Não usar as e para acessar a exceção",
                                    "Raising exceções built-in sem necessidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar sintaxe e verificação em compilação entre C++ e Python",
                                  "subSteps": [
                                    "Liste similaridades: ambos usam try-catch/except, exceções unchecked (não verificadas em compile-time)",
                                    "Destaque diferenças: C++ requer compilação e linking, Python é interpretado; C++ tem catch(...) amplo",
                                    "Teste código C++ sem catch: compila mas falha em runtime; mesmo em Python",
                                    "Compare tipos: C++ std::runtime_error vs Python ValueError (ambos unchecked)",
                                    "Discuta ausência de verificação em compilação em ambos (diferente de Java checked exceptions)"
                                  ],
                                  "verification": "Criar tabela comparativa em documento e preencher com 5+ pontos de similaridade/diferença",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Códigos dos steps anteriores"
                                  ],
                                  "tips": "Foque em unchecked nature: compilador não força tratamento, responsabilidade do dev",
                                  "learningObjective": "Identificar e explicar diferenças chave, especialmente falta de compile-time checks",
                                  "commonMistakes": [
                                    "Confundir com Java (checked exceptions)",
                                    "Achar que C++ verifica exceções em compile",
                                    "Ignorar performance overhead em C++"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar implicações práticas e melhores práticas",
                                  "subSteps": [
                                    "Discuta riscos: exceções não tratadas causam crash (C++) ou traceback (Python)",
                                    "Implemente logger em ambos para exceções: std::cerr em C++, logging em Python",
                                    "Refatore exemplos para incluir verificação manual pré-throw",
                                    "Compare overhead: C++ mais custoso que Python para exceções frequentes",
                                    "Defina guideline: prefira verificações explícitas a exceções em hot paths"
                                  ],
                                  "verification": "Modificar códigos originais com logging e testar cenários de falha",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Códigos expandidos",
                                    "Documentação oficial C++ exceptions e Python exceptions"
                                  ],
                                  "tips": "Em produção, use RAII em C++ para resource management; context managers em Python",
                                  "learningObjective": "Aplicar comparação para adotar melhores práticas em tratamento de erros",
                                  "commonMistakes": [
                                    "Tratar exceções como goto (anti-pattern)",
                                    "Não documentar exceções esperadas",
                                    "Overuse de exceções para flow control"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa de divisão segura: em C++, try { if (denom==0) throw std::runtime_error(\"div0\"); } catch(...){}; em Python, try: if denom==0: raise ValueError('div0') except ValueError: print('tratado'). Compile/exec sem catch para ver crash/traceback, destacando falta de compile-time warning.",
                              "finalVerifications": [
                                "Explicar por que ambos compilam/executam parcialmente sem tratamento",
                                "Listar 3 diferenças sintáticas entre C++ e Python",
                                "Demonstrar código funcional com catch/except em ambos",
                                "Identificar quando usar exceções vs if-checks",
                                "Comparar output de exceções não tratadas",
                                "Criar tabela de prós/contras de unchecked exceptions"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de sintaxe C++ e Python (90%+ correta)",
                                "Correta identificação de unchecked exceptions em ambos",
                                "Tabela comparativa completa com pelo menos 5 itens",
                                "Códigos executáveis sem erros de compilação/execução",
                                "Análise de implicações práticas demonstrada em refatoração",
                                "Uso correto de verificações e tips nos steps"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Princípios de robustez e error handling",
                                "Algoritmos: Comparação de performance em exception handling",
                                "Lógica de Programação: Fluxo de controle com exceções vs condicionais",
                                "Debugging: Análise de stack traces em C++ vs Python"
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise, como sistemas bancários, entender diferenças permite escolher linguagem certa: C++ para performance crítica sem exceções frequentes, Python para scripts rápidos com tratamento dinâmico, evitando crashes em produção por exceções não verificadas em compile-time."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Exceções Não Verificadas",
                        "description": "Exceções não verificadas, também chamadas de runtime exceptions, ocorrem em tempo de execução e não são obrigadas a serem tratadas pelo compilador. São comuns em C++ e Python, como divisão por zero ou acesso inválido a índices.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Definir exceções não verificadas",
                            "description": "Descrever exceções não verificadas como erros detectados em runtime, sem obrigatoriedade de tratamento em C++ (ex: std::bad_alloc) e Python (ex: ZeroDivisionError), diferindo de verificadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de exceções não verificadas",
                                  "subSteps": [
                                    "Leia a definição: exceções não verificadas são erros detectados apenas em tempo de execução (runtime), sem verificação obrigatória pelo compilador.",
                                    "Identifique características chave: não precisam ser declaradas ou tratadas explicitamente no código fonte.",
                                    "Diferencie de exceções verificadas: estas são checadas em compile-time e exigem tratamento explícito.",
                                    "Anote exemplos genéricos: falhas de memória ou divisão por zero.",
                                    "Resuma em suas palavras: o que torna uma exceção 'não verificada'?"
                                  ],
                                  "verification": "Escreva um parágrafo definindo exceções não verificadas e contrastando com verificadas; revise se menciona runtime vs compile-time.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial C++ (cppreference.com/exceptions), Python docs (docs.python.org/3/tutorial/errors.html)",
                                  "tips": "Use analogia: exceções não verificadas são como buracos no chão que você só vê ao pisar, não sinalizados antes.",
                                  "learningObjective": "Definir precisamente exceções não verificadas e suas distinções fundamentais.",
                                  "commonMistakes": "Confundir com exceções sempre tratáveis; achar que todas as linguagens têm o mesmo modelo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar exceções não verificadas em C++",
                                  "subSteps": [
                                    "Compile e execute código simples com std::bad_alloc: tente alocar memória excessiva com new.",
                                    "Observe o comportamento em runtime: programa crasha sem tratamento prévio obrigatório.",
                                    "Analise std::out_of_range em std::vector: acesse índice inválido.",
                                    "Verifique documentação: confirme que o compilador não força try-catch.",
                                    "Teste sem tratamento: note stack trace ou abort."
                                  ],
                                  "verification": "Execute código que lança std::bad_alloc sem catch; confirme crash em runtime sem erros de compilação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador GCC/Clang, IDE como Visual Studio Code, código de exemplo: #include <new> int main() { new int[SIZE_MAX]; }",
                                  "tips": "Use valgrind ou debugger para inspecionar runtime errors sem tratamento.",
                                  "learningObjective": "Identificar e reproduzir exceções não verificadas específicas em C++.",
                                  "commonMistakes": "Tratar exceções como warnings de compilador; ignorar que C++ permite unchecked por performance."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar exceções não verificadas em Python",
                                  "subSteps": [
                                    "Execute 1/0 para lançar ZeroDivisionError e observe traceback.",
                                    "Teste IndexError com lista[100] em lista vazia.",
                                    "Confirme via docs: Python trata todas exceções como unchecked pelo interpretador.",
                                    "Compare execução: sem try-except, programa para abruptamente.",
                                    "Escreva snippet com ValueError: int('abc')."
                                  ],
                                  "verification": "Rode código Python sem tratamento para ZeroDivisionError; verifique se roda até runtime e então falha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python 3 interpretador, Jupyter Notebook, docs.python.org/3/library/exceptions.html",
                                  "tips": "Use pdb para debug runtime; print traceback com import traceback; traceback.print_exc().",
                                  "learningObjective": "Demonstrar exceções não verificadas em Python via exemplos práticos.",
                                  "commonMistakes": "Achar que Python força tratamento como Java; confundir com SyntaxError (compile-time)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar diferenças, implicações e boas práticas",
                                  "subSteps": [
                                    "Compare C++/Python vs linguagens com checked exceptions (Java): liste prós/cons (performance vs segurança).",
                                    "Discuta riscos: código instável se ignorado; incentive tratamento voluntário.",
                                    "Crie tabela: coluna para exceção, linguagem, detecção (runtime), obrigatório (não).",
                                    "Planeje estratégia: use try-catch mesmo unchecked para robustez.",
                                    "Resuma implicações: flexibilidade mas responsabilidade do dev."
                                  ],
                                  "verification": "Crie tabela comparativa com 3 exemplos; explique verbalmente por que não são verificadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha ou Markdown para tabela, comparação Java vs C++/Python docs",
                                  "tips": "Pense em cenários reais: servidor web crashando por OOM (Out of Memory).",
                                  "learningObjective": "Avaliar trade-offs de exceções não verificadas e recomendar práticas.",
                                  "commonMistakes": "Subestimar necessidade de tratamento; achar unchecked = ignore sempre."
                                }
                              ],
                              "practicalExample": "Em C++: vector<int> v(5); cout << v[10]; // std::out_of_range em runtime. Em Python: lst = []; print(lst[0]) # IndexError sem checagem prévia.",
                              "finalVerifications": [
                                "Definição correta recitada: runtime-only, não obrigatório.",
                                "Exemplos C++ (bad_alloc) e Python (ZeroDivisionError) reproduzidos com crashes.",
                                "Diferença com checked exceptions explicada (compile-time vs runtime).",
                                "Tabela comparativa completa.",
                                "Estratégia de tratamento voluntário proposta.",
                                "Riscos de não tratar identificados."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (runtime vs compile-time): 25%",
                                "Exemplos corretos e executados: 25%",
                                "Comparação clara com verificadas: 20%",
                                "Implicações e boas práticas: 15%",
                                "Tabela ou resumo estruturado: 10%",
                                "Ausência de confusões comuns: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Programação Defensiva (Engenharia de Software): tratamento voluntário.",
                                "Debugging e Testing: análise de runtime errors.",
                                "Desempenho de Sistemas: trade-off unchecked por velocidade.",
                                "Lógica Computacional: detecção de erros em execução."
                              ],
                              "realWorldApplication": "Em apps de alta performance como games (C++), exceções unchecked como bad_alloc evitam overhead de checagem, mas devs usam try-catch para graceful degradation em servidores web Python (ex: Django handling ZeroDivisionError em cálculos financeiros)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Exemplificar em C++ e Python",
                            "description": "Citar exemplos: C++ - vector.at(10) lança std::out_of_range; Python - 1/0 lança ZeroDivisionError, e demonstrar com código simples de lançamento e captura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambientes de Desenvolvimento para C++ e Python",
                                  "subSteps": [
                                    "Instale um compilador C++ como g++ (via MinGW no Windows ou nativo no Linux/Mac).",
                                    "Configure uma IDE como Visual Studio Code com extensões C++ e Python.",
                                    "Verifique a instalação do Python 3.x executando 'python --version' no terminal.",
                                    "Crie pastas separadas para os projetos C++ e Python.",
                                    "Teste ambientes compilando/executando um 'Hello World' simples em cada linguagem."
                                  ],
                                  "verification": "Ambientes funcionam: 'Hello World' compila e executa sem erros em ambos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "g++ compiler, Visual Studio Code, Python 3.x",
                                  "tips": "Use 'g++ -std=c++17 arquivo.cpp -o output' para compilar com suporte moderno.",
                                  "learningObjective": "Preparar ferramentas essenciais para codificação e depuração de exceções.",
                                  "commonMistakes": "Não configurar PATH para g++ ou Python, levando a comandos não encontrados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Exemplo de Exceção Não Verificada em C++ com vector.at()",
                                  "subSteps": [
                                    "Inclua headers: #include <vector>, #include <iostream>, #include <stdexcept>.",
                                    "Crie um vector<int> pequeno, ex: std::vector<int> vec = {1, 2, 3};",
                                    "Use try-catch: tente vec.at(10), que lança std::out_of_range.",
                                    "No catch, capture std::out_of_range& e imprima mensagem de erro.",
                                    "Adicione código fora do try para demonstrar continuação normal após captura."
                                  ],
                                  "verification": "Compilar e executar: exceção é lançada, capturada e programa continua sem crash.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, terminal para compilar",
                                  "tips": "Use .at() em vez de [] para forçar lançamento de exceção em índices inválidos.",
                                  "learningObjective": "Demonstrar lançamento e captura de std::out_of_range em runtime.",
                                  "commonMistakes": "Usar vec[10] ao invés de .at(10), que não lança exceção; esquecer #include <stdexcept>."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Exemplo de Exceção Não Verificada em Python com Divisão por Zero",
                                  "subSteps": [
                                    "Crie um script Python com try-except block.",
                                    "No try, execute 1 / 0 para lançar ZeroDivisionError.",
                                    "No except ZeroDivisionError:, imprima mensagem como 'Divisão por zero detectada!'.",
                                    "Adicione código após except para mostrar que o programa continua.",
                                    "Teste variando o denominador para 0 intencionalmente."
                                  ],
                                  "verification": "Executar script: exceção lançada, capturada corretamente com mensagem, programa prossegue.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python interpreter, editor de código",
                                  "tips": "Use 'except ZeroDivisionError as e: print(e)' para detalhes da exceção.",
                                  "learningObjective": "Ilustrar lançamento e captura de ZeroDivisionError em runtime.",
                                  "commonMistakes": "Esquecer 'as e' no except ou usar except genérico sem especificar ZeroDivisionError."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, Comparar e Documentar os Exemplos",
                                  "subSteps": [
                                    "Compile e rode o código C++ múltiplas vezes, variando índice para confirmar lançamento.",
                                    "Execute o script Python com diferentes cenários de divisão por zero.",
                                    "Compare saídas: identifique similaridades (runtime, captura) e diferenças (sintaxe, nomes).",
                                    "Documente em um README.md: códigos, saídas e lições aprendidas.",
                                    "Depure qualquer erro ajustando códigos."
                                  ],
                                  "verification": "Documentação completa com códigos funcionais, saídas screenshot e comparação clara.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Terminal, editor para README",
                                  "tips": "Use diff ou side-by-side no VSCode para comparar códigos C++ e Python.",
                                  "learningObjective": "Consolidar compreensão comparativa de exceções não verificadas entre linguagens.",
                                  "commonMistakes": "Não testar casos edge como vector vazio ou divisão por float zero."
                                }
                              ],
                              "practicalExample": "Em um programa de inventário: C++ - Acessar inventario.at(10) em lista de 5 itens lança out_of_range; Python - Calcular total / 0 itens lança ZeroDivisionError. Capturar para logar 'Índice inválido' ou 'Sem itens para dividir' e continuar operação.",
                              "finalVerifications": [
                                "Código C++ compila sem warnings e lança/captura std::out_of_range corretamente.",
                                "Script Python executa e lança/captura ZeroDivisionError com mensagem precisa.",
                                "Programas continuam execução após captura sem crash.",
                                "Saídas incluem nomes exatos das exceções.",
                                "Documentação compara sintaxe try-catch vs try-except.",
                                "Testes com índices/denominadores válidos não lançam exceções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação: exceções lançadas apenas em condições inválidas.",
                                "Correta captura e tratamento com mensagens informativas.",
                                "Código limpo, comentado e seguindo convenções de cada linguagem.",
                                "Compreensão demonstrada na comparação entre C++ e Python.",
                                "Execução robusta sem vazamentos ou erros adicionais.",
                                "Documentação clara e acionável."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Uso de vectors/arrays e acesso indexado.",
                                "Algoritmos: Tratamento de erros em cálculos matemáticos como divisão.",
                                "Lógica de Programação: Controle de fluxo com try-catch/except.",
                                "Depuração: Identificação e handling de runtime errors."
                              ],
                              "realWorldApplication": "Em aplicações de software como jogos (acesso inválido a níveis de itens) ou finanças (divisão por zero em relatórios de médias), capturar essas exceções previne crashes, loga erros para debugging e garante continuidade do serviço para usuários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Implementar tratamento básico",
                            "description": "Escrever código em C++ usando try-catch para std::exception e em Python usando try-except para capturar exceções como IndexError, sem verificação prévia pelo compilador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Exceções Não Verificadas",
                                  "subSteps": [
                                    "Leia a documentação oficial sobre exceções em C++ (std::exception e derivadas como std::out_of_range).",
                                    "Estude exceções em Python, focando em IndexError e exceções built-in não verificadas.",
                                    "Compare sintaxe: try-catch em C++ vs. try-except em Python.",
                                    "Identifique que exceções não verificadas ocorrem em runtime, sem checagem pelo compilador.",
                                    "Anote exemplos de cenários comuns, como acesso a índice inválido em vetores/listas."
                                  ],
                                  "verification": "Resuma em 3 frases as diferenças entre C++ e Python para tratamento de exceções.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Documentação C++: cppreference.com/exceptions",
                                    "Python docs: docs.python.org/3/tutorial/errors.html",
                                    "Editor de texto ou IDE como VS Code"
                                  ],
                                  "tips": [
                                    "Use diagramas para visualizar fluxo try-catch/except.",
                                    "Teste mentalmente um erro de índice antes de codificar."
                                  ],
                                  "learningObjective": "Dominar os fundamentos teóricos de exceções não verificadas e suas sintaxes em C++ e Python.",
                                  "commonMistakes": [
                                    "Confundir exceções verificadas (checked) com não verificadas.",
                                    "Ignorar que std::exception é a classe base em C++."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Try-Catch Básico em C++ para std::exception",
                                  "subSteps": [
                                    "Crie um programa simples com um std::vector e acesso via .at() para lançar exceção.",
                                    "Estruture o bloco try { código arriscado } catch (const std::exception& e) { imprimir e.what() }.",
                                    "Inclua headers necessários: <iostream>, <vector>, <stdexcept>.",
                                    "Adicione um bloco finally-like com código pós-catch para demonstrar continuidade.",
                                    "Compile com g++ e execute para testar lançamento e captura."
                                  ],
                                  "verification": "Execute o código com índice inválido e confirme que captura e imprime mensagem sem crash.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Compilador g++",
                                    "Editor como Code::Blocks ou VS Code com C++ extension"
                                  ],
                                  "tips": [
                                    "Use const std::exception& para eficiência e polimorfismo.",
                                    "Sempre imprima e.what() para debug."
                                  ],
                                  "learningObjective": "Escrever código C++ funcional que capture std::exception de forma genérica.",
                                  "commonMistakes": [
                                    "Esquecer #include <stdexcept>",
                                    "Usar [] em vez de .at() (não lança exceção)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Try-Except Básico em Python para IndexError",
                                  "subSteps": [
                                    "Crie uma lista Python e tente acessar índice inválido com lst[index].",
                                    "Estruture try: código arriscado except IndexError as e: imprimir str(e).",
                                    "Adicione else: para código que roda se sem exceção, e finally: para cleanup.",
                                    "Teste com input dinâmico para simular uso real.",
                                    "Execute no interpretador Python e valide captura."
                                  ],
                                  "verification": "Rode o script com índice inválido e verifique mensagem de erro customizada.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Python 3.x interpreter",
                                    "Editor como IDLE ou Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Use 'as e' para acessar detalhes da exceção.",
                                    "Prefira exceções específicas como IndexError antes de Exception genérica."
                                  ],
                                  "learningObjective": "Desenvolver código Python que trate IndexError de maneira robusta.",
                                  "commonMistakes": [
                                    "Capturar Exception genérica primeiro, mascarando erros específicos.",
                                    "Esquecer indentação no bloco except."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Integrar Tratamentos em Ambos os Idiomas",
                                  "subSteps": [
                                    "Crie um programa híbrido conceitual comparando saídas de C++ e Python.",
                                    "Introduza cenários múltiplos: índices válidos/inválidos e múltiplas exceções.",
                                    "Depure com breakpoints ou prints para rastrear fluxo.",
                                    "Refatore para mensagens de erro amigáveis ao usuário final.",
                                    "Documente o código com comentários explicando cada bloco."
                                  ],
                                  "verification": "Ambos códigos rodam sem crash, capturam exceções corretamente e continuam execução.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "g++ e Python",
                                    "Debugger como gdb para C++ ou pdb para Python"
                                  ],
                                  "tips": [
                                    "Teste edge cases: índice -1, tamanho zero.",
                                    "Considere logging em vez de apenas print."
                                  ],
                                  "learningObjective": "Validar e refinar implementações para robustez prática.",
                                  "commonMistakes": [
                                    "Não testar casos sem exceção (else/finally vazios).",
                                    "Ignorar warnings do compilador."
                                  ]
                                }
                              ],
                              "practicalExample": "Programa C++: #include <iostream>\\n#include <vector>\\n#include <stdexcept>\\nint main() { std::vector<int> v{1,2,3}; try { std::cout << v.at(5); } catch(const std::exception& e) { std::cout << \"Erro: \" << e.what(); } return 0; } // Saída: Erro: vector::_M_range_check\\nPython: lst = [1,2,3]; try: print(lst[5]); except IndexError as e: print(f\"Erro de índice: {e}\"); // Saída: Erro de índice: list index out of range",
                              "finalVerifications": [
                                "Código C++ compila e executa sem segment fault ao acessar índice inválido.",
                                "Try-catch captura std::exception e imprime mensagem descritiva.",
                                "Código Python captura IndexError especificamente sem interromper o programa.",
                                "Ambos exibem continuidade pós-exceção (ex: print final).",
                                "Nenhum vazamento de memória ou comportamento indefinido observado.",
                                "Testes com índices válidos e inválidos passam corretamente."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta de try-catch/except sem erros de compilação/execução.",
                                "Captura apropriada de std::exception/IndexError (não genérica desnecessária).",
                                "Mensagens de erro claras e informativas para o usuário.",
                                "Estrutura inclui handling de fluxo completo (try/except/else/finally onde aplicável).",
                                "Código limpo, comentado e reproduzível.",
                                "Robustez contra múltiplos cenários de erro."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Manipulação de vetores/listas e limites de índices.",
                                "Programação Orientada a Objetos: Herança de classes de exceção.",
                                "Testes e Depuração: Uso de debuggers para validar exceções.",
                                "Lógica Condicional: Alternativas a if-checks via exceções.",
                                "Engenharia de Software: Princípios de robustez e recuperação de falhas."
                              ],
                              "realWorldApplication": "Em aplicações como editores de texto ou jogos, tratamento de exceções previne crashes ao lidar com entradas inválidas (ex: usuário digita índice errado em uma lista de itens), permitindo feedback amigável e continuidade do app, essencial em software comercial como navegadores ou sistemas bancários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Erros",
                        "description": "Erros representam falhas graves no sistema, como falta de memória ou problemas irrecuperáveis, geralmente não devem ser capturados pelo código do usuário. Em Java são subclass de Throwable; em C++ e Python, similares a exceções fatais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Definir erros em exceções",
                            "description": "Explicar erros como condições irrecuperáveis (ex: OutOfMemoryError em Java/Python), contrastando com exceções tratáveis; em C++, std::bad_alloc como erro de alocação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Exceções e Erros",
                                  "subSteps": [
                                    "Defina exceção como uma condição recuperável que pode ser tratada com try-catch.",
                                    "Defina erro como uma condição irrecuperável, como falha crítica do sistema (ex: falta de memória).",
                                    "Identifique que erros não devem ser capturados, pois indicam problemas fatais.",
                                    "Compare exceções (checked/unchecked em Java) com erros irrecuperáveis.",
                                    "Estude a hierarquia: em Java, Error herda de Throwable, mas não é exceção."
                                  ],
                                  "verification": "Resuma em 3 frases a diferença entre exceção e erro, citando exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Java/Python (Throwable hierarchy)",
                                    "Notas de aula sobre tratamento de exceções"
                                  ],
                                  "tips": "Use diagramas de herança de classes para visualizar diferenças.",
                                  "learningObjective": "Diferenciar conceitualmente exceções tratáveis de erros irrecuperáveis.",
                                  "commonMistakes": [
                                    "Confundir Error com Exception em Java",
                                    "Achar que todos os problemas de memória são exceções tratáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos em Java e Python",
                                  "subSteps": [
                                    "Em Java, estude OutOfMemoryError: simule alocando arrays gigantes até falhar.",
                                    "Em Python, explore MemoryError: crie loop infinito consumindo memória.",
                                    "Observe que try-except não deve capturar esses erros; logue e termine graciosamente.",
                                    "Compare com exceções como ArrayIndexOutOfBoundsException (tratável).",
                                    "Registre stack traces para entender o contexto de falha."
                                  ],
                                  "verification": "Execute código que gera OutOfMemoryError e descreva o que acontece sem catch.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE como IntelliJ/Eclipse para Java",
                                    "Python IDLE ou Jupyter Notebook",
                                    "Códigos de exemplo para OOM"
                                  ],
                                  "tips": "Use ferramentas como VisualVM (Java) para monitorar heap e prever erros.",
                                  "learningObjective": "Reconhecer e simular erros de memória em linguagens gerenciadas.",
                                  "commonMistakes": [
                                    "Tentar capturar Error com catch genérico",
                                    "Ignorar limites de heap durante testes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Erros em C++ (std::bad_alloc)",
                                  "subSteps": [
                                    "Estude std::bad_alloc: exceção lançada por new/malloc quando alocação falha.",
                                    "Note que em C++, é uma exceção, mas tratada como erro irrecuperável em contextos modernos.",
                                    "Compare com abort() ou std::terminate() para falhas críticas.",
                                    "Implemente código com try-catch para bad_alloc e discuta se capturar é boa prática.",
                                    "Analise cenários onde alocação falha (ex: sistema sem swap)."
                                  ],
                                  "verification": "Compile e rode código C++ que lança std::bad_alloc; explique por que não capturar.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador GCC/Clang",
                                    "Documentação std::bad_alloc (cppreference.com)",
                                    "Código de teste com new excessivo"
                                  ],
                                  "tips": "Compile com -std=c++11+ e use valgrind para detectar vazamentos simulados.",
                                  "learningObjective": "Entender tratamento de erros de alocação em linguagens não-gerenciadas.",
                                  "commonMistakes": [
                                    "Tratar std::bad_alloc como exceção comum e retry infinito",
                                    "Não checar nullptr em malloc manual"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar e Definir Regras para Erros vs Exceções",
                                  "subSteps": [
                                    "Crie tabela comparativa: Java/Python Error vs C++ bad_alloc vs exceções tratáveis.",
                                    "Defina regra: não capture erros; propague ou termine app com log.",
                                    "Discuta impactos: performance, debug, estabilidade em produção.",
                                    "Pratique identificando em código real se é erro ou exceção.",
                                    "Escreva guideline pessoal para definir erros em projetos."
                                  ],
                                  "verification": "Crie tabela comparativa e explique 2 cenários onde confundir causa bugs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Exemplos de código de projetos open-source"
                                  ],
                                  "tips": "Priorize logs detalhados antes de crash para análise pós-mortem.",
                                  "learningObjective": "Formular regras claras para distinguir e lidar com erros.",
                                  "commonMistakes": [
                                    "Capturar tudo com catch-all",
                                    "Ignorar diferenças entre linguagens"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app Java de processamento de imagens, carregue 1GB de dados em heap de 256MB: gera OutOfMemoryError. Logue o erro, libere recursos e termine, contrastando com IndexOutOfBoundsException que retry corrige índice.",
                              "finalVerifications": [
                                "Explique diferença entre Error e Exception em Java com herança.",
                                "Simule MemoryError em Python sem capturar.",
                                "Descreva std::bad_alloc em C++ e por que evitar catch.",
                                "Identifique 3 erros irrecuperáveis em código dado.",
                                "Crie guideline: 'Erros = irrecuperáveis; log + exit.'",
                                "Compare impactos em produção."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 90% acerto em definições.",
                                "Exemplos corretos em 3 linguagens.",
                                "Tabela comparativa completa e clara.",
                                "Identificação correta de 80% dos cenários teste.",
                                "Guideline prática e aplicável.",
                                "Análise de impactos em produção."
                              ],
                              "crossCurricularConnections": [
                                "Debugging: Análise de stack traces para root cause.",
                                "Gerenciamento de Recursos: Otimização de memória e GC.",
                                "Arquitetura de Software: Design resiliente com fallbacks.",
                                "Testes: Simulação de falhas com chaos engineering.",
                                "Segurança: Prevenção de DoS via OOM."
                              ],
                              "realWorldApplication": "Em servidores web (ex: JVM em Kubernetes), OutOfMemoryError triggers restart automático via liveness probes, evitando downtime total; logs alimentam monitoramento (Prometheus) para escalar pods."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1",
                              "10.1.4.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Identificar exemplos em linguagens",
                            "description": "Exemplos: Python - MemoryError ao alocar muita memória; C++ - new falhando e lançando std::bad_alloc, que é um erro não recomendado para captura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o MemoryError em Python",
                                  "subSteps": [
                                    "Acesse a documentação oficial do Python (docs.python.org) e busque por 'MemoryError'.",
                                    "Leia a definição: exceção levantada quando o interpretador não consegue alocar mais memória.",
                                    "Identifique cenários comuns: listas ou dicionários muito grandes, recursão infinita profunda.",
                                    "Execute um código simples que force MemoryError, como criar uma lista com 10^9 elementos.",
                                    "Registre o traceback completo gerado pelo erro."
                                  ],
                                  "verification": "Conseguiu reproduzir e capturar o MemoryError com print do traceback.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Python oficial",
                                    "Editor de código (VS Code ou IDLE)",
                                    "Ambiente Python instalado"
                                  ],
                                  "tips": "Use try-except para capturar sem crashar o programa; monitore uso de RAM no Gerenciador de Tarefas.",
                                  "learningObjective": "Explicar causas e detecção do MemoryError em Python.",
                                  "commonMistakes": [
                                    "Confundir com OutOfMemoryError de Java",
                                    "Ignorar limites de memória do sistema",
                                    "Não usar ferramentas de profiling como memory_profiler"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender std::bad_alloc em C++",
                                  "subSteps": [
                                    "Consulte a referência C++ (cppreference.com) sobre std::bad_alloc e operador new.",
                                    "Entenda que new lança std::bad_alloc ao falhar na alocação; não recomendado capturar em produção.",
                                    "Compile e execute código C++ que tente alocar array dinâmico oversized, ex: int* arr = new int[1e9];",
                                    "Use try-catch para capturar e imprimir a exceção.",
                                    "Compare com std::nothrow para alocação sem exceção."
                                  ],
                                  "verification": "Código C++ compila, executa e lança/captura std::bad_alloc corretamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "cppreference.com",
                                    "Compilador g++ ou clang",
                                    "Editor como CLion ou VS Code com C++"
                                  ],
                                  "tips": "Compile com -std=c++17; use valgrind para detectar leaks relacionados.",
                                  "learningObjective": "Identificar quando e por que std::bad_alloc é lançado em C++.",
                                  "commonMistakes": [
                                    "Capturar bad_alloc rotineiramente (anti-padrão)",
                                    "Confundir com falhas de malloc",
                                    "Não considerar overhead de alocador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar exemplos entre Python e C++",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: causa, lançamento, captura recomendada, traceback.",
                                    "Analise diferenças: Python é GC-managed, C++ manual; bad_alloc é unchecked por default.",
                                    "Execute códigos lado a lado em terminais separados e compare outputs.",
                                    "Pesquise fóruns (Stack Overflow) por casos reais de cada erro.",
                                    "Anote similaridades: ambos indicam exaustão de memória heap."
                                  ],
                                  "verification": "Tabela comparativa completa com pelo menos 5 linhas de diferenças/semelhanças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel",
                                    "Códigos dos steps anteriores"
                                  ],
                                  "tips": "Foco em padrões de erro no traceback para identificação rápida.",
                                  "learningObjective": "Diferenciar contextos de MemoryError e std::bad_alloc.",
                                  "commonMistakes": [
                                    "Assumir comportamentos idênticos entre linguagens",
                                    "Ignorar diferenças de runtime"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em cenários reais",
                                  "subSteps": [
                                    "Baixe repositórios open-source com issues de OOM (OutOfMemory) em Python/C++.",
                                    "Identifique linhas causadoras de MemoryError ou bad_alloc em logs.",
                                    "Modifique códigos para reproduzir e corrigir (ex: chunking em Python).",
                                    "Crie quiz pessoal: dado traceback, qual linguagem e erro?",
                                    "Discuta em fórum ou com peer o que aprendeu."
                                  ],
                                  "verification": "Identificou corretamente 3 exemplos de repositórios reais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GitHub busca 'MemoryError python'",
                                    "cppreference examples"
                                  ],
                                  "tips": "Use grep/busca por 'MemoryError' ou 'bad_alloc' em códigos.",
                                  "learningObjective": "Aplicar conhecimento para identificar erros em código real.",
                                  "commonMistakes": [
                                    "Não verificar limites de máquina virtual",
                                    "Sobreestimar memória disponível"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: lst = []; for i in range(10**8): lst.append(i*10)  # Provoca MemoryError. Em C++: int* p = new int[1000000000];  // Lança std::bad_alloc. Capturar: try { ... } catch (std::bad_alloc&) { std::cout << 'Falha!'; }",
                              "finalVerifications": [
                                "Explica diferença entre MemoryError e std::bad_alloc em 1 minuto.",
                                "Reproduz ambos erros em <5 min cada.",
                                "Identifica erro correto em tracebacks misturados.",
                                "Lista 3 cenários reais por linguagem.",
                                "Sugere 2 correções preventivas por erro.",
                                "Compara com erros similares em outras linguagens (ex: Java OOM)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reprodução de exemplos (100% match com docs).",
                                "Profundidade da tabela comparativa (cobertura >80%).",
                                "Correção em identificação de tracebacks (90%+).",
                                "Criatividade em correções práticas.",
                                "Clareza em explicações orais/escritas.",
                                "Uso adequado de ferramentas de debug."
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de Recursos em Sistemas Operacionais (alocação heap).",
                                "Debugging e Análise de Logs em Engenharia de Software.",
                                "Algoritmos e Otimização de Memória em Ciência da Computação.",
                                "Segurança: Prevenção de DoS por exaustão de memória.",
                                "Desenvolvimento Ágil: Tratamento de exceções em testes unitários."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps escaláveis (ex: servidores web), identificar MemoryError/bad_alloc previne crashes em produção, otimiza uso de cloud resources (AWS/GCP) e reduz downtime em sistemas críticos como bancos ou games multiplayer."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Discutir quando não capturar",
                            "description": "Analisar por que erros como StackOverflowError em Python ou recursão infinita em C++ não devem ser tratados, permitindo que o programa termine graciosamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a natureza de erros irrecuperáveis como StackOverflowError e recursão infinita",
                                  "subSteps": [
                                    "Pesquise definições: StackOverflowError em Python ocorre por recursão excessiva esgotando a pilha de chamadas.",
                                    "Analise recursão infinita em C++: função chama a si mesma sem condição de parada, levando a estouro de pilha.",
                                    "Compare com exceções recuperáveis: diferencie de erros como divisão por zero que podem ser tratados localmente.",
                                    "Estude impactos: perda de controle do programa, corrupção de memória e dificuldade de recuperação.",
                                    "Documente exemplos simples de código que causam esses erros."
                                  ],
                                  "verification": "Liste 3 exemplos de código que geram esses erros e explique o mecanismo subjacente em um parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação Python (docs.python.org), documentação C++ (cppreference.com), editor de código como VS Code.",
                                  "tips": "Use diagramas de pilha de chamadas para visualizar o esgotamento.",
                                  "learningObjective": "Identificar e diferenciar erros irrecuperáveis de exceções tratáveis.",
                                  "commonMistakes": "Confundir com exceções normais como ValueError; ignorar diferenças entre linguagens."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar riscos de capturar esses erros",
                                  "subSteps": [
                                    "Simule captura em código Python: tente try-except em recursão infinita e observe loop eterno.",
                                    "Teste em C++: use try-catch para recursão infinita e note que o handler pode falhar ou causar mais recursão.",
                                    "Discuta problemas: captura mascara sintomas, impede diagnóstico, consome recursos indefinidamente.",
                                    "Avalie cenários: em servidores, captura pode levar a denial-of-service por uso excessivo de CPU/memória.",
                                    "Registre observações: anote falhas específicas observadas nos testes."
                                  ],
                                  "verification": "Execute códigos de teste e capture screenshots ou logs mostrando falhas na captura.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente Python e C++ (Replit ou local), debugger como pdb ou gdb.",
                                  "tips": "Defina timeout nos testes para evitar travamentos reais.",
                                  "learningObjective": "Explicar por que capturar esses erros agrava problemas em vez de resolvê-los.",
                                  "commonMistakes": "Assumir que 'catch-all' resolve tudo; não testar em cenários de produção simulados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar estratégias para término gracioso sem captura",
                                  "subSteps": [
                                    "Estude saídas padrão: em Python, unhandled StackOverflowError gera traceback e encerra; em C++, aborta com signal.",
                                    "Implemente logs: configure logging antes de potenciais recursões para registrar estado pré-erro.",
                                    "Discuta monitoramento: use ferramentas como Sentry ou Prometheus para capturar crashes pós-fato.",
                                    "Planeje recuperação: desenhe arquitetura com supervisores (ex: systemd) para reiniciar processos.",
                                    "Escreva diretrizes: crie um documento pessoal sobre quando deixar falhar."
                                  ],
                                  "verification": "Crie um código com logging que falha graciosamente e demonstre o output.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Biblioteca logging do Python, signal handling em C++, ferramentas de monitoramento online.",
                                  "tips": "Priorize fail-fast: detecte condições ruins cedo para evitar deep recursion.",
                                  "learningObjective": "Desenvolver práticas para permitir falhas controladas e recuperação externa.",
                                  "commonMistakes": "Tentar 'recuperar' adicionando mais código no handler; ignorar custos de monitoramento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar discussão e casos reais",
                                  "subSteps": [
                                    "Compile argumentos: liste 5 razões contra captura baseadas nos steps anteriores.",
                                    "Analise casos famosos: pesquise incidentes como recursão em browsers ou servidores (ex: Heartbleed indireto).",
                                    "Debata trade-offs: quando exceções semelhantes podem ser tratadas vs. não.",
                                    "Crie apresentação: resuma em slides ou markdown para 'discussão'.",
                                    "Autoavalie: responda perguntas como 'Por que não capturar?' em voz alta."
                                  ],
                                  "verification": "Produza um resumo escrito de 300 palavras com exemplos e razões.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Artigos sobre incidentes (ex: StackOverflow blog), Markdown editor.",
                                  "tips": "Use analogias: 'capturar StackOverflow é como tapar furo em dique com dedo'.",
                                  "learningObjective": "Articular claramente princípios de não-captura em discussões técnicas.",
                                  "commonMistakes": "Generalizar demais; não diferenciar contextos (ex: scripts vs. serviços)."
                                }
                              ],
                              "practicalExample": "Em um parser JSON recursivo em Python: def parse(node): if node['type'] == 'object': for child in node['children']: parse(child)  # Falta base case. Tentar except StackOverflowError: print('Overflow!') resulta em loop eterno no handler. Deixe falhar para traceback completo e reinício via supervisor.",
                              "finalVerifications": [
                                "Explica mecanismo de StackOverflowError e recursão infinita com precisão.",
                                "Identifica pelo menos 4 riscos de capturar esses erros.",
                                "Descreve como um programa termina graciosamente sem captura.",
                                "Fornece exemplos em Python e C++ com códigos funcionais.",
                                "Discute monitoramento e recuperação externa adequadamente.",
                                "Sintetiza argumentos em uma discussão coerente."
                              ],
                              "assessmentCriteria": [
                                "Profundidade técnica: demonstra compreensão de pilha de chamadas e signals.",
                                "Evidências práticas: inclui testes/códigos executados.",
                                "Análise de riscos: cobre impactos em performance e segurança.",
                                "Clareza na discussão: argumentos lógicos e bem estruturados.",
                                "Aplicação contextual: diferencia cenários recuperáveis/irrecuperáveis.",
                                "Criatividade: usa analogias ou casos reais efetivos."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e Profiling: técnicas para investigar causas raiz pré-captura.",
                                "Design de Sistemas: princípios fail-fast e circuit breakers.",
                                "Segurança de Software: prevenção de DoS por recursão maliciosa.",
                                "Gerenciamento de Processos: uso de containers/orquestradores para restarts."
                              ],
                              "realWorldApplication": "Em microsserviços de produção (ex: Netflix ou AWS Lambda), deixar StackOverflow crashar permite Sentry capturar stack traces completos para correção rápida, enquanto supervisores reiniciam o serviço em segundos, evitando downtime prolongado por loops mascarados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.4",
                            "name": "Comparar hierarquia de exceções",
                            "description": "Desenhar hierarquia: Throwable > Error e Exception > RuntimeException; mapear para C++ (std::exception hierarchy) e Python (BaseException > Exception e SystemExit etc.).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Hierarquia de Exceções em Java",
                                  "subSteps": [
                                    "Pesquise a classe raiz Throwable na documentação oficial do Java.",
                                    "Identifique as subclasses principais: Error (ex: OutOfMemoryError) e Exception (ex: IOException).",
                                    "Explore a distinção entre checked exceptions (herdam de Exception, mas não RuntimeException) e unchecked (herdam de RuntimeException).",
                                    "Liste exemplos de subclasses como NullPointerException (RuntimeException) e FileNotFoundException (IOException).",
                                    "Desenhe um diagrama simples da hierarquia usando setas para relações pai-filho."
                                  ],
                                  "verification": "Desenhe e valide um diagrama da hierarquia Java contra a documentação oficial, confirmando pelo menos 5 classes principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Java (docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html)",
                                    "IDE como IntelliJ ou Eclipse",
                                    "Papel e caneta ou ferramenta de diagrama como draw.io"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para checked vs unchecked exceptions.",
                                    "Comece do topo (Throwable) e expanda para baixo."
                                  ],
                                  "learningObjective": "Identificar e mapear precisamente a estrutura hierárquica de exceções em Java, distinguindo Error, Exception e RuntimeException.",
                                  "commonMistakes": [
                                    "Confundir Error (não recuperável) com Exception (recuperável).",
                                    "Omitir a distinção checked/unchecked."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Hierarquia de Exceções em C++",
                                  "subSteps": [
                                    "Estude a classe base std::exception do header <stdexcept>.",
                                    "Identifique categorias principais: std::logic_error (ex: std::invalid_argument) e std::runtime_error (ex: std::range_error).",
                                    "Explore exceções específicas como std::bad_alloc e std::out_of_range.",
                                    "Note que C++ não impõe checked exceptions como Java; todas são unchecked.",
                                    "Desenhe um diagrama da hierarquia std::exception, incluindo exemplos de subclasses."
                                  ],
                                  "verification": "Crie um diagrama C++ e teste compilando um código simples que lança std::runtime_error, verificando captura via std::exception.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação C++ (cppreference.com/w/cpp/error/exception)",
                                    "Compilador GCC/Clang",
                                    "Ferramenta de diagrama"
                                  ],
                                  "tips": [
                                    "Lembre-se: C++ usa herança virtual para exceções personalizadas.",
                                    "Teste com try-catch para validar."
                                  ],
                                  "learningObjective": "Descrever a hierarquia std::exception em C++, focando em logic_error e runtime_error.",
                                  "commonMistakes": [
                                    "Assumir checked exceptions em C++ como em Java.",
                                    "Ignorar necessidade de #include <stdexcept>."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Hierarquia de Exceções em Python",
                                  "subSteps": [
                                    "Identifique BaseException como raiz, com subclasses Exception, SystemExit, KeyboardInterrupt e GeneratorExit.",
                                    "Estude Exception como base para a maioria das exceções personalizadas (ex: ValueError, TypeError).",
                                    "Diferencie exceções built-in como StopIteration e RuntimeError.",
                                    "Note que Python não distingue checked/unchecked formalmente.",
                                    "Desenhe um diagrama da hierarquia BaseException > Exception."
                                  ],
                                  "verification": "Escreva um script Python que liste exceções via inspect module e desenhe diagrama comparando com docs oficiais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Documentação Python (docs.python.org/3/library/exceptions.html)",
                                    "Interpretador Python",
                                    "Ferramenta de diagrama"
                                  ],
                                  "tips": [
                                    "Use help(Exception) no REPL para hierarquia interativa.",
                                    "Agrupe exceções por tipo (arithmetic, lookup, etc.)."
                                  ],
                                  "learningObjective": "Mapear a hierarquia BaseException em Python, destacando diferenças com Java/C++.",
                                  "commonMistakes": [
                                    "Confundir BaseException com Exception.",
                                    "Omitir exceções de sistema como SystemExit."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Mapear Hierarquias Entre Linguagens",
                                  "subSteps": [
                                    "Alinhe hierarquias: Java Throwable ~ C++ std::exception ~ Python BaseException.",
                                    "Compare Error (Java) com runtime erros em C++/Python.",
                                    "Mapeie RuntimeException (Java) para std::runtime_error (C++) e RuntimeError (Python).",
                                    "Crie uma tabela comparativa de exemplos (ex: NullPointer ~ std::nullptr? ~ AttributeError).",
                                    "Desenhe um diagrama unificado mostrando similaridades e diferenças."
                                  ],
                                  "verification": "Produza uma tabela/diagrama comparativo e explique oralmente ou por escrito 3 mapeamentos chave.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Diagramas dos steps anteriores",
                                    "Ferramenta de tabela como Markdown ou Excel",
                                    "Documentações das 3 linguagens"
                                  ],
                                  "tips": [
                                    "Use setas bidirecionais para mapeamentos aproximados.",
                                    "Foco em conceitos: recoverable vs irrecoverable."
                                  ],
                                  "learningObjective": "Comparar hierarquias de exceções entre Java, C++ e Python, identificando padrões e diferenças.",
                                  "commonMistakes": [
                                    "Forçar mapeamentos 1:1 inexistentes.",
                                    "Ignorar contextos linguísticos (ex: GC em Java vs manual em C++)."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenhe um diagrama comparativo das hierarquias e implemente um programa multi-linguagem: Em Java, lance NullPointerException e capture via Exception; em C++, std::invalid_argument via std::exception; em Python, ValueError via Exception. Analise como a hierarquia afeta o catch-all.",
                              "finalVerifications": [
                                "Diagrama Java correto com Throwable > Error/Exception > RuntimeException.",
                                "Diagrama C++ com std::exception > logic_error/runtime_error.",
                                "Diagrama Python com BaseException > Exception.",
                                "Tabela comparativa com pelo menos 5 mapeamentos precisos.",
                                "Explicação escrita de 3 diferenças chave (ex: checked em Java).",
                                "Teste prático: código em cada linguagem capturando exceções hierarquicamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão das hierarquias (100% classes principais corretas).",
                                "Qualidade dos diagramas (clareza visual, setas corretas).",
                                "Profundidade da comparação (mapeamentos conceituais além de nomes).",
                                "Exemplos práticos viáveis e testados.",
                                "Identificação de 3+ diferenças contextuais (ex: checked/unchecked)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos (herança e polimorfismo em exceções).",
                                "Design de Software (padrões de tratamento de erros cross-language).",
                                "Debugging e Testes (análise de stack traces hierárquicos).",
                                "Arquitetura de Sistemas (portabilidade em equipes multi-linguagem)."
                              ],
                              "realWorldApplication": "Em projetos de software enterprise multi-linguagem (ex: backend Java + scripts Python + libs C++), compreender hierarquias permite debugging eficiente, migração de código e design de APIs robustas que lidam com falhas de forma previsível, reduzindo downtime em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Lançamento de Exceções",
                    "description": "Uso de comandos como throw para gerar exceções explicitamente durante a execução.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Exceções Lançadas Explicitamente",
                        "description": "Compreensão do conceito de exceções geradas intencionalmente pelo programador para sinalizar condições de erro ou eventos inesperados durante a execução de um programa, diferenciando de exceções capturadas automaticamente pelo sistema.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Definir exceções lançadas explicitamente",
                            "description": "Explicar o propósito e a utilidade de lançar exceções explicitamente em um programa, identificando situações como validação de entrada inválida ou condições de negócio não atendidas, com exemplos em pseudocódigo ou C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Exceções Lançadas Explicitamente",
                                  "subSteps": [
                                    "Defina exceção como um mecanismo para sinalizar erros ou condições excepcionais durante a execução.",
                                    "Diferencie exceções lançadas automaticamente pelo runtime (ex: divisão por zero) das lançadas explicitamente pelo programador usando 'throw'.",
                                    "Explique o propósito: permitir tratamento controlado de erros, interrompendo fluxo normal e propagando para handlers.",
                                    "Analise utilidade: melhora legibilidade, separa lógica de negócios de tratamento de erros.",
                                    "Revise sintaxe básica em pseudocódigo: if (condicao_invalida) throw ExcecaoPersonalizada(mensagem);"
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e dê um exemplo simples de pseudocódigo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial de C++ sobre exceptions (cppreference.com)",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": [
                                    "Foquem em exceções como 'sinais de parada' para fluxos inválidos.",
                                    "Use exceções para erros recuperáveis ou não esperados."
                                  ],
                                  "learningObjective": "Dominar a definição, propósito e diferenças de exceções lançadas explicitamente.",
                                  "commonMistakes": [
                                    "Confundir 'throw' com 'return' para erros.",
                                    "Achar que exceções substituem validações preventivas.",
                                    "Ignorar propagação de exceções pelo stack."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Situações Adequadas para Lançamento Explícito",
                                  "subSteps": [
                                    "Liste cenários comuns: validação de entrada inválida (ex: string vazia em campo obrigatório).",
                                    "Identifique condições de negócio não atendidas (ex: saldo insuficiente em transação).",
                                    "Considere falhas de recursos (ex: arquivo não encontrado após verificação).",
                                    "Avalie quando NÃO lançar: erros triviais melhor tratados com retornos.",
                                    "Crie uma tabela de exemplos: situação, por quê lançar exceção."
                                  ],
                                  "verification": "Liste 3 situações reais e justifique por que lançar exceção explicitamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de código C++ de bibliotecas padrão",
                                    "Papel e caneta para tabela"
                                  ],
                                  "tips": [
                                    "Pergunte: 'Isso é um erro esperado mas inválido?' Se sim, throw.",
                                    "Evite exceções para controle de fluxo normal."
                                  ],
                                  "learningObjective": "Reconhecer contextos precisos onde exceções explícitas adicionam valor.",
                                  "commonMistakes": [
                                    "Lançar exceções em loops para performance ruim.",
                                    "Usar para validações client-side simples.",
                                    "Não diferenciar de warnings ou logs."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Lançamento de Exceções em Pseudocódigo e C++",
                                  "subSteps": [
                                    "Escreva pseudocódigo para função validarIdade(int idade): if (idade < 0 || idade > 150) throw InvalidAgeException(idade);",
                                    "Traduza para C++: #include <stdexcept>, use std::invalid_argument, throw std::invalid_argument(\"Idade inválida: \" + std::to_string(idade));",
                                    "Crie classe personalizada: class InvalidAgeException : public std::runtime_error { ... };",
                                    "Adicione try-catch para demonstrar captura.",
                                    "Teste com entradas inválidas e valide saída."
                                  ],
                                  "verification": "Compile e execute código C++ com throw e catch, confirmando mensagem de erro.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou online como godbolt.org)",
                                    "Ambiente IDE como CLion ou Code::Blocks"
                                  ],
                                  "tips": [
                                    "Sempre inclua mensagem descritiva no throw.",
                                    "Use std::exception hierarchy para padronização."
                                  ],
                                  "learningObjective": "Capacitar implementação prática de throws em código real.",
                                  "commonMistakes": [
                                    "Esquecer #include <stdexcept>.",
                                    "Throw sem catch, causando crash.",
                                    "Usar raw pointers em exceptions."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Benefícios, Testar e Refinar",
                                  "subSteps": [
                                    "Compare código com/ sem throw: analise legibilidade e robustez.",
                                    "Teste cenários: entrada válida (sem throw), inválida (com throw e catch).",
                                    "Meça performance: discuta overhead mas priorize corretude.",
                                    "Refine: adicione logging no catch.",
                                    "Documente quando usar em projetos maiores."
                                  ],
                                  "verification": "Modifique código para 2 cenários novos e demonstre funcionamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de debug como gdb",
                                    "Exemplos de código de repositórios GitHub"
                                  ],
                                  "tips": [
                                    "Exceções propagam até catch adequado.",
                                    "Profile antes de otimizar exceções."
                                  ],
                                  "learningObjective": "Avaliar impactos e boas práticas no uso de exceções explícitas.",
                                  "commonMistakes": [
                                    "Catch-all genérico sem rethrow.",
                                    "Ignorar custo de unwinding do stack.",
                                    "Overuse em código quente (hot paths)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de banco: função transferir(double valor, double saldo) { if (valor > saldo) throw std::invalid_argument(\"Saldo insuficiente: \" + std::to_string(saldo)); saldo -= valor; }. Isso previne transações inválidas, permitindo catch no caller para retry ou log.",
                              "finalVerifications": [
                                "Explicar verbalmente propósito de throw explícito com exemplo.",
                                "Identificar 3 situações para lançamento e 2 para evitar.",
                                "Escrever e compilar código C++ funcional com throw personalizado.",
                                "Demonstrar try-catch propagando exceção corretamente.",
                                "Comparar código com exceções vs. códigos de retorno.",
                                "Listar prós/cons em contexto real."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição e diferenças 100% corretas.",
                                "Relevância de cenários: exemplos práticos e apropriados.",
                                "Qualidade de código: sintaxe C++ válida, mensagens claras.",
                                "Cobertura de testes: cenários válidos/inválidos tratados.",
                                "Análise crítica: benefícios e pitfalls identificados.",
                                "Documentação: comentários explicativos no código."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos e Lógica: uso de condicionais para detecção de erros.",
                                "Design de Software: princípios de robustez e separação de concerns.",
                                "Testes Unitários: verificação de exceções em frameworks como GoogleTest.",
                                "Matemática Discreta: modelagem de estados inválidos.",
                                "Comunicação: redação de mensagens de erro claras."
                              ],
                              "realWorldApplication": "Em aplicações empresariais como ERPs ou apps financeiros, lançar exceções explícitas em validações de dados (ex: CPF inválido) garante integridade, facilita debugging e integra com logs/monitores como ELK Stack, evitando corrupções silenciosas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Identificar cenários para lançamento de exceções",
                            "description": "Analisar trechos de código para determinar quando é apropriado lançar uma exceção explicitamente, como divisão por zero personalizada ou parâmetros fora do intervalo esperado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Exceções e Lançamento Explícito",
                                  "subSteps": [
                                    "Ler a definição de exceções em programação e suas categorias (checked e unchecked).",
                                    "Estudar a diferença entre exceções lançadas pelo runtime e exceções lançadas explicitamente com 'throw'.",
                                    "Analisar exemplos simples de lançamento explícito em linguagens como Java ou Python.",
                                    "Identificar o propósito: sinalizar erros recuperáveis ou condições inválidas.",
                                    "Diferenciar lançamento de exceção de retorno de valores de erro ou códigos de status."
                                  ],
                                  "verification": "Escrever um resumo de 3-5 frases explicando quando usar 'throw' em vez de outras abordagens.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (Java/Python)",
                                    "Vídeo tutorial curto sobre exceções (5-10 min)",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Use exemplos reais da documentação para fixar conceitos; evite pular para código sem teoria.",
                                  "learningObjective": "Dominar os fundamentos teóricos para discernir cenários de lançamento explícito.",
                                  "commonMistakes": [
                                    "Confundir lançamento ('throw') com captura ('catch')",
                                    "Achar que toda validação precisa de exceção"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenários Comuns para Lançamento Explícito de Exceções",
                                  "subSteps": [
                                    "Listar cenários típicos: parâmetros inválidos (null, fora de intervalo), divisão por zero, recursos indisponíveis.",
                                    "Classificar cenários por gravidade: condições de entrada inválida vs. erros internos.",
                                    "Estudar guidelines da linguagem: quando exceções são preferíveis a validações simples.",
                                    "Analisar prós e contras: exceções interrompem fluxo, mas fornecem stack trace útil.",
                                    "Criar uma tabela mental com 5 cenários e exceções apropriadas (ex: IllegalArgumentException)."
                                  ],
                                  "verification": "Criar uma lista de 5 cenários comuns com justificativa para lançamento explícito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência de exceções da linguagem (ex: Oracle Java Docs)",
                                    "Artigo sobre 'fail-fast' principle"
                                  ],
                                  "tips": "Priorize cenários de API pública onde chamadores precisam saber de erros de entrada.",
                                  "learningObjective": "Reconhecer padrões recorrentes que demandam exceções explícitas.",
                                  "commonMistakes": [
                                    "Lançar exceções para fluxo de controle normal",
                                    "Ignorar exceções hierárquicas personalizadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Trechos de Código para Detectar Pontos de Lançamento",
                                  "subSteps": [
                                    "Selecionar um trecho de código simples (ex: função de divisão ou validação de array).",
                                    "Inspecionar condicionais: ifs que verificam zero, null ou limites.",
                                    "Marcar pontos onde continuação causaria comportamento indefinido ou incorreto.",
                                    "Propor exceções específicas: ArithmeticException para divisão por zero, IndexOutOfBounds para arrays.",
                                    "Justificar: 'Por quê lançar aqui em vez de retornar null ou -1?'."
                                  ],
                                  "verification": "Anotar em 2-3 trechos de código os pontos exatos de lançamento com razões.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "3-5 trechos de código exemplo fornecidos ou online"
                                  ],
                                  "tips": "Leia o código linha por linha; pergunte 'o que acontece se input inválido?'",
                                  "learningObjective": "Desenvolver habilidade analítica para inspecionar código real.",
                                  "commonMistakes": [
                                    "Marcar validações triviais como exceções",
                                    "Sugestões genéricas como 'Exception' em vez de específicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Validar Análises com Modificações no Código",
                                  "subSteps": [
                                    "Modificar um código exemplo adicionando 'throw' nos pontos identificados.",
                                    "Testar o código com inputs inválidos para verificar se exceções são lançadas corretamente.",
                                    "Refatorar para exceções personalizadas ou mensagens claras.",
                                    "Comparar antes/depois: fluxo normal vs. erro.",
                                    "Documentar lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Executar testes unitários e confirmar que exceções param execução corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ambiente de desenvolvimento (JDK/Python)",
                                    "Framework de testes (JUnit/Pytest)"
                                  ],
                                  "tips": "Sempre inclua mensagens descritivas na exceção para depuração.",
                                  "learningObjective": "Aplicar conhecimento em prática, consolidando identificação e implementação.",
                                  "commonMistakes": [
                                    "Exceções muito amplas sem contexto",
                                    "Não testar casos edge"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma função de cálculo de média de notas: se o array de notas estiver vazio, lançar IllegalArgumentException('Array de notas não pode estar vazio'); se nota < 0 ou > 10, lançar IllegalArgumentException('Nota fora do intervalo [0-10]'). Teste com inputs: notas vazias, nota -1, nota 11.",
                              "finalVerifications": [
                                "Identificar corretamente todos os 4 cenários de exceção em um trecho de código complexo.",
                                "Justificar verbalmente ou por escrito por quê uma exceção é apropriada em 80% dos casos.",
                                "Modificar código para incluir lançamentos sem quebrar fluxo normal.",
                                "Explicar diferenças entre exceções explícitas e implícitas.",
                                "Listar 3 exceções built-in adequadas para cenários comuns."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (90% acerto).",
                                "Justificativas lógicas e alinhadas a boas práticas.",
                                "Uso correto de tipos de exceções específicas vs. genéricas.",
                                "Clareza nas mensagens de exceção e stack traces interpretados.",
                                "Eficiência: análise em tempo razoável sem erros comuns.",
                                "Criatividade em cenários edge não óbvios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Validação de operações como divisão por zero ou raízes negativas.",
                                "Lógica e Algoritmos: Condicionais if/else para detecção de pré-condições.",
                                "Design de Software: Princípios de API robusta e contratos (Design by Contract).",
                                "Ética em Computação: Tratamento responsável de erros para evitar falhas críticas.",
                                "Testes e QA: Integração com testes unitários para validar exceções."
                              ],
                              "realWorldApplication": "Em aplicativos bancários, lançar exceções para saques com saldo insuficiente ou CPF inválido, permitindo que o sistema logue o erro, notifique o usuário e evite transações fraudulentas, garantindo robustez e auditabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Diferenciar lançamento explícito de implícito",
                            "description": "Comparar exceções lançadas pelo programador (explícitas) com aquelas geradas automaticamente pelo compilador ou runtime, usando exemplos de linguagens procedimentais como C++.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Exceções em C++",
                                  "subSteps": [
                                    "Leia a documentação oficial do C++ sobre exceções (seção de try-catch-throw).",
                                    "Identifique que exceções são eventos de erro que interrompem o fluxo normal do programa.",
                                    "Anote definições chave: lançamento (throw), captura (catch) e propagação.",
                                    "Revise exemplos simples de exceções em código C++.",
                                    "Discuta com um colega ou anote diferenças entre erros normais (return codes) e exceções."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos básicos e liste 2 exemplos de exceções comuns em C++.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação C++ (cppreference.com), editor de texto como VS Code.",
                                  "tips": "Use diagramas de fluxo para visualizar interrupção do programa por exceções.",
                                  "learningObjective": "Entender o papel fundamental das exceções no controle de erros em C++.",
                                  "commonMistakes": "Confundir exceções com funções de retorno de erro; ignorar custo de performance das exceções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Lançamento Explícito de Exceções",
                                  "subSteps": [
                                    "Escreva um código C++ simples usando 'throw' para lançar uma exceção personalizada (ex: std::runtime_error).",
                                    "Teste o código com try-catch para capturar a exceção lançada explicitamente.",
                                    "Modifique o código para lançar diferentes tipos de exceções (int, string, classe customizada).",
                                    "Analise o stack trace gerado pelo throw.",
                                    "Compare com cenários onde throw é usado para validação de input."
                                  ],
                                  "verification": "Execute o código e confirme que a exceção é lançada apenas quando 'throw' é chamado explicitamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador g++ ou Clang, IDE como Code::Blocks ou online compiler (repl.it).",
                                  "tips": "Sempre inicialize exceções com mensagens descritivas para debugging fácil.",
                                  "learningObjective": "Dominar o uso do operador 'throw' para controle intencional de erros pelo programador.",
                                  "commonMistakes": "Lançar exceções sem try-catch próximo, causando terminação abrupta; usar tipos inadequados para throw."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Lançamento Implícito de Exceções",
                                  "subSteps": [
                                    "Identifique cenários automáticos em C++: divisão por zero, acesso inválido de memória (nullptr dereference).",
                                    "Compile e execute códigos que geram exceções runtime sem 'throw' explícito (ex: std::vector at() out of bounds).",
                                    "Use ferramentas como Valgrind para observar exceções implícitas em runtime.",
                                    "Registre diferenças no comportamento: geradas pelo compilador/runtime sem intervenção do programador.",
                                    "Compare logs de erros implícitos vs. explícitos."
                                  ],
                                  "verification": "Gere uma exceção implícita e capture-a, confirmando ausência de 'throw' no código fonte.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C++ com suporte a exceções (-fexceptions), Valgrind (opcional).",
                                  "tips": "Habilite exceções no compilador com flags específicas para evitar otimizações que as desabilitam.",
                                  "learningObjective": "Reconhecer exceções geradas automaticamente pelo sistema sem código explícito.",
                                  "commonMistakes": "Acreditar que todas exceções precisam de 'throw'; ignorar que implícitas são não-verificadas em C++."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Diferenciar Lançamento Explícito vs. Implícito",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: controle (programador vs. runtime), timing, exemplos, vantagens/desvantagens.",
                                    "Refatore um código com exceção implícita para torná-la explícita e vice-versa.",
                                    "Analise um código real (ex: biblioteca STL) para identificar ambos os tipos.",
                                    "Debata cenários onde um é preferível ao outro (ex: validações de negócio vs. erros de hardware).",
                                    "Teste em um programa maior com múltiplas exceções mistas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito 5 diferenças chave com exemplos de código para cada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha ou documento para tabela, códigos dos steps anteriores.",
                                  "tips": "Use assert() para debugging implícito antes de exceções em desenvolvimento.",
                                  "learningObjective": "Diferenciar precisamente explícito de implícito e escolher o apropriado por contexto.",
                                  "commonMistakes": "Confundir lançamento com captura; subestimar overhead de throw em loops."
                                }
                              ],
                              "practicalExample": "Em C++: Explícito - if (denominador == 0) throw std::runtime_error('Divisão por zero'); Implícito - int x = 10 / 0; // SIGFPE ou runtime error automático. Código completo: função divide() com try-catch mostrando ambos.",
                              "finalVerifications": [
                                "Pode listar 3 exemplos de lançamento explícito e 3 implícito em C++?",
                                "Identifica corretamente em um código fornecido qual tipo de lançamento ocorre?",
                                "Explica vantagens do explícito sobre implícito em cenários de validação?",
                                "Cria um código híbrido com ambos e captura adequadamente?",
                                "Discute quando evitar throw explícito por performance?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção conceitual (explícito controlado vs. implícito automático).",
                                "Uso correto de sintaxe C++ em exemplos práticos.",
                                "Análise completa de vantagens/desvantagens em contextos reais.",
                                "Capacidade de refatorar código entre tipos de lançamento.",
                                "Clareza na tabela ou explicação comparativa.",
                                "Identificação de erros comuns em cenários mistos."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Algoritmos: Fluxo de controle e propagação de erros.",
                                "Debugging e Testes de Software: Análise de stack traces e ferramentas como GDB.",
                                "Design de Sistemas: Robustez e tratamento de falhas em arquiteturas distribuídas.",
                                "Matemática Discreta: Modelagem de estados de erro como autômatos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software crítico como sistemas bancários ou embedded (ex: automotivo), usar throw explícito para erros de lógica de negócio (validação de transações) enquanto capturar implícitos (falhas de hardware) garante apps robustos e debuggáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Comando throw",
                        "description": "Sintaxe e mecânica do comando throw para gerar exceções em linguagens de programação como C++ ou Python, incluindo o tipo de objeto lançado e propagação na pilha de chamadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Escrever sintaxe básica do throw",
                            "description": "Construir instruções usando o comando throw para lançar exceções padrão, como throw new std::runtime_error(\"mensagem\"); em C++, ou raise ValueError em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Propósito e Conceito do Comando Throw/Raise",
                                  "subSteps": [
                                    "Estude o que são exceções em programação: eventos que interrompem o fluxo normal para sinalizar erros.",
                                    "Identifique cenários comuns para lançar exceções, como divisão por zero ou entrada inválida.",
                                    "Compare throw em C++ com raise em Python: ambos sinalizam erros personalizados.",
                                    "Leia documentação oficial: std::runtime_error em C++ e ValueError em Python.",
                                    "Anote diferenças: C++ usa new para alocar, Python usa classe diretamente."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que e quando usar throw/raise, com 2 exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação C++: https://en.cppreference.com/w/cpp/error/runtime_error",
                                    "Documentação Python: https://docs.python.org/3/tutorial/errors.html",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Foquem em exceções como 'sinais de erro controlado', não como falhas totais do programa.",
                                  "learningObjective": "Entender o papel do throw/raise no tratamento de exceções para controle de erros.",
                                  "commonMistakes": [
                                    "Confundir lançamento com captura (catch/try-except)",
                                    "Achar que throw encerra o programa permanentemente sem tratamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Sintaxe Básica do Throw em C++",
                                  "subSteps": [
                                    "Inclua o header necessário: #include <stdexcept>.",
                                    "Escreva a sintaxe: throw new std::runtime_error(\"sua mensagem de erro\");",
                                    "Teste em um código simples: crie uma função que lança se argumento inválido.",
                                    "Compile e execute para ver a exceção ser lançada (sem catch ainda).",
                                    "Varie a mensagem e o tipo (ex: std::invalid_argument)."
                                  ],
                                  "verification": "Compile um código C++ que lança runtime_error e observe a saída de erro no console.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou IDE como Code::Blocks)",
                                    "Exemplo de código base: main() com if inválido"
                                  ],
                                  "tips": "Sempre use 'new' para exceções customizadas em C++; delete não é necessário pois o runtime gerencia.",
                                  "learningObjective": "Dominar a sintaxe exata do throw em C++ com exceções padrão.",
                                  "commonMistakes": [
                                    "Esquecer #include <stdexcept>",
                                    "Omitir 'new' antes da classe de exceção",
                                    "Usar aspas simples em vez de duplas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender a Sintaxe Básica do Raise em Python",
                                  "subSteps": [
                                    "Escreva a sintaxe: raise ValueError(\"sua mensagem de erro\").",
                                    "Crie uma função simples que verifica condição e lança exceção.",
                                    "Execute o script Python para ver o traceback com mensagem.",
                                    "Experimente outros tipos: TypeError, IndexError com mensagens customizadas.",
                                    "Compare execução com C++: note a simplicidade sem 'new'."
                                  ],
                                  "verification": "Execute um script Python que levanta ValueError e confirme a mensagem no traceback.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Interpretador Python (IDLE ou VS Code)",
                                    "Script base: def funcao() com if e raise"
                                  ],
                                  "tips": "Em Python 3, raise sem argumentos relança a exceção atual; sempre especifique para clareza.",
                                  "learningObjective": "Dominar a sintaxe exata do raise em Python com exceções built-in.",
                                  "commonMistakes": [
                                    "Usar 'throw' em Python (é raise)",
                                    "Esquecer parênteses na mensagem",
                                    "Não importar nada (built-in)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Integração e Verificação em Códigos Completos",
                                  "subSteps": [
                                    "Crie uma função de divisão que lança exceção em divisor zero (em C++ e Python).",
                                    "Adicione try-catch/try-except básico para capturar e imprimir mensagem.",
                                    "Teste casos válidos e inválidos, ajustando mensagens.",
                                    "Refatore para usar diferentes tipos de exceções baseados em condições.",
                                    "Documente o código com comentários explicando o throw/raise."
                                  ],
                                  "verification": "Rode testes: função lança exceção corretamente em inválido e funciona em válido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDEs para C++ e Python",
                                    "Templates de código para divisão segura"
                                  ],
                                  "tips": "Use mensagens descritivas que ajudem no debug, incluindo contexto como valores de variáveis.",
                                  "learningObjective": "Aplicar sintaxe de throw/raise em funções reais com tratamento básico.",
                                  "commonMistakes": [
                                    "Lançar exceção em casos válidos",
                                    "Não testar sem tratamento (crash)",
                                    "Mensagens vagas sem detalhes"
                                  ]
                                }
                              ],
                              "practicalExample": "Função de divisão segura:\nC++: double dividir(double a, double b) { if (b == 0) throw new std::runtime_error(\"Divisor zero inválido!\"); return a / b; }\nPython: def dividir(a, b): if b == 0: raise ValueError('Divisor zero inválido!') return a / b\nUso: try { dividir(10, 0); } catch (...) { cout << \"Erro capturado\"; }",
                              "finalVerifications": [
                                "Escreve sintaxe correta de throw new std::runtime_error em C++ sem erros.",
                                "Escreve raise ValueError em Python com mensagem customizada.",
                                "Integra throw/raise em função condicional e testa lançamento.",
                                "Explica diferença entre C++ e Python na alocação de exceções.",
                                "Cria código que captura e imprime mensagem da exceção lançada.",
                                "Identifica e corrige erros comuns em exemplos fornecidos."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe 100% precisa (new, aspas, tipo de exceção correto).",
                                "Mensagens de erro claras, contextuais e em inglês/português consistente.",
                                "Uso apropriado em condicionais lógicas (if/else).",
                                "Compilação/execução sem warnings/erros de sintaxe.",
                                "Tratamento básico incluído para demonstrar fluxo completo.",
                                "Comentários explicativos no código demonstrando compreensão."
                              ],
                              "crossCurricularConnections": [
                                "Lógica de Programação: Uso de condicionais para validação prévia.",
                                "Programação Orientada a Objetos: Herança de classes de exceções.",
                                "Testes de Software: Verificação de cenários de erro (unit tests).",
                                "Debugging e Manutenção: Mensagens para facilitar diagnóstico.",
                                "Matemática Computacional: Exceções em cálculos numéricos seguros."
                              ],
                              "realWorldApplication": "Em sistemas reais como aplicativos bancários, validar transferências (ex: saldo insuficiente -> throw InvalidTransactionError), em jogos para inputs inválidos (ex: movimento ilegal -> raise GameError), ou APIs web para parâmetros errados, evitando crashes e fornecendo feedback ao usuário via logs ou UI."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Lançar exceções com objetos personalizados",
                            "description": "Criar e lançar exceções com mensagens customizadas ou tipos específicos, demonstrando passagem de parâmetros para o construtor da exceção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar a classe de exceção personalizada",
                                  "subSteps": [
                                    "Escolha o tipo de exceção: estenda `Exception` para checked ou `RuntimeException` para unchecked, baseado no contexto.",
                                    "Defina o nome da classe de forma descritiva, como `InvalidUserInputException`.",
                                    "Adicione campos adicionais se necessário para armazenar parâmetros customizados (ex: `private String fieldName; private Object invalidValue;`).",
                                    "Implemente o método `serialVersionUID` para serialização.",
                                    "Certifique-se de que a classe seja pública ou package-private conforme o escopo."
                                  ],
                                  "verification": "A classe compila sem erros e pode ser instanciada via `new InvalidUserInputException()`.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "IDE (IntelliJ, Eclipse ou VS Code com extensão Java)",
                                    "JDK 8+ instalado",
                                    "Documentação oficial de Exceptions do Java"
                                  ],
                                  "tips": "Prefira `RuntimeException` para erros de programação e `Exception` para erros de domínio de negócio.",
                                  "learningObjective": "Compreender a extensão de classes de exceção built-in para criar tipos customizados.",
                                  "commonMistakes": [
                                    "Esquecer de declarar a classe como `public` se usada em outros pacotes.",
                                    "Não importar `java.lang.Exception` ou `RuntimeException`."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar construtores com mensagens e parâmetros customizados",
                                  "subSteps": [
                                    "Crie construtor default chamando `super()`.",
                                    "Crie construtor com `String message`: `super(message)`.",
                                    "Crie construtor com parâmetros adicionais: armazene-os em campos e use no `message` (ex: `super(\"Valor inválido para \" + fieldName + \": \" + invalidValue);`).",
                                    "Adicione construtor com `Throwable cause` para chaining: `super(message, cause)`.",
                                    "Gere getters para campos customizados se necessário."
                                  ],
                                  "verification": "Instancie a exceção com diferentes construtores e verifique `getMessage()` e campos via debug ou toString().",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Javadoc para Throwable constructors"
                                  ],
                                  "tips": "Use `String.format()` para mensagens formatadas com parâmetros para melhor legibilidade.",
                                  "learningObjective": "Dominar a passagem de parâmetros para construtores de exceções personalizadas.",
                                  "commonMistakes": [
                                    "Não chamar `super(message)` no construtor, causando NullPointerException.",
                                    "Concatenar strings ineficientemente sem usar formatadores."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Lançar a exceção usando o comando throw",
                                  "subSteps": [
                                    "Identifique o ponto de lançamento em um método (ex: validação de input).",
                                    "Crie uma instância da exceção personalizada passando parâmetros: `throw new InvalidUserInputException(\"idade\", age);`.",
                                    "Coloque o `throw` dentro de uma condição if para cenários específicos.",
                                    "Garanta que o método declare `throws` se for checked exception.",
                                    "Teste sintaxe compilando o código."
                                  ],
                                  "verification": "O código compila e, ao executar com input inválido, lança a exceção customizada.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Código-fonte de exemplo",
                                    "Compilador Java (javac ou IDE)"
                                  ],
                                  "tips": "Sempre lance exceções específicas antes de genéricas para melhor debugging.",
                                  "learningObjective": "Aplicar `throw` com objetos personalizados em fluxos de controle.",
                                  "commonMistakes": [
                                    "Usar `throw new Exception()` genérico em vez de customizado.",
                                    "Esquecer de passar parâmetros, resultando em mensagens vazias."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e verificar o lançamento da exceção",
                                  "subSteps": [
                                    "Escreva um método main ou teste unitário (JUnit) que chame o método lançador com input inválido.",
                                    "Use try-catch para capturar e imprimir detalhes: `e.getMessage()`, `e.getFieldName()`, etc.",
                                    "Execute e confirme que a stack trace mostra a exceção customizada.",
                                    "Adicione asserts em testes para validar mensagem e parâmetros.",
                                    "Refatore se necessário para cenários edge-case."
                                  ],
                                  "verification": "Teste passa: exceção lançada com mensagem e parâmetros corretos; input válido não lança.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "JUnit 5 para testes unitários",
                                    "IDE com runner de testes"
                                  ],
                                  "tips": "Use `@Test(expected = InvalidUserInputException.class)` para validação rápida.",
                                  "learningObjective": "Validar o comportamento completo de lançamento e captura de exceções customizadas.",
                                  "commonMistakes": [
                                    "Não testar casos válidos, focando só em exceções.",
                                    "Ignorar stack trace para identificar origem do lançamento."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie `InvalidAgeException extends Exception` com construtor `InvalidAgeException(int age) { super(\"Idade inválida: \" + age); this.invalidAge = age; }`. Em um método `registerUser(int age)`, se `age < 0 || age > 150`, faça `throw new InvalidAgeException(age);`. No main: try { registerUser(-5); } catch (InvalidAgeException e) { System.out.println(e.getMessage()); // Saída: \"Idade inválida: -5\" }",
                              "finalVerifications": [
                                "A classe de exceção compila e herda corretamente de Exception/RuntimeException.",
                                "Construtores recebem e utilizam parâmetros para mensagens customizadas.",
                                "`throw` é usado corretamente em contexto condicional.",
                                "Teste unitário captura e valida a exceção lançada com parâmetros exatos.",
                                "Stack trace identifica origem precisa do lançamento."
                              ],
                              "assessmentCriteria": [
                                "Código compila sem warnings de exceções não declaradas.",
                                "Mensagem da exceção inclui parâmetros passados dinamicamente.",
                                "Exceção é lançada apenas em condições inválidas específicas.",
                                "Testes cobrem lançamento, captura e verificação de detalhes.",
                                "Uso de boas práticas: getters, serialVersionUID e formatação de mensagem."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: herança e construtores.",
                                "Design de Software: validação de domínio e API robusta.",
                                "Testes e Debugging: unit testing com JUnit e análise de stack traces.",
                                "Lógica de Programação: condicionais para lançamento seletivo."
                              ],
                              "realWorldApplication": "Em aplicações web/bancárias, lançar `InsufficientFundsException(attemptedAmount, currentBalance)` durante transferências para fornecer feedback preciso ao usuário e logs detalhados para auditoria, melhorando usabilidade e manutenção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Integrar throw em estruturas condicionais",
                            "description": "Incorporar o comando throw dentro de comandos condicionais (if/else) para validar condições e interromper a execução normal do fluxo do programa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de estruturas condicionais e comando throw",
                                  "subSteps": [
                                    "Estude a sintaxe básica de if/else em Java.",
                                    "Revise o comando throw para lançar exceções personalizadas, como IllegalArgumentException.",
                                    "Analise exemplos de fluxos de programa interrompidos por exceções.",
                                    "Identifique cenários onde validações condicionais são necessárias, como entrada de usuário.",
                                    "Compare throw com return para entender diferenças no controle de fluxo."
                                  ],
                                  "verification": "Escreva um resumo de 3 frases explicando quando usar throw em condicionais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Java: if/else e Throwable",
                                    "Editor de código como IntelliJ ou VS Code"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o impacto do throw no programa.",
                                  "learningObjective": "Compreender a integração conceitual de condicionais com lançamento de exceções.",
                                  "commonMistakes": [
                                    "Confundir throw com System.exit()",
                                    "Ignorar que throw interrompe o fluxo imediatamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar throw em uma estrutura if simples",
                                  "subSteps": [
                                    "Crie um método que receba um parâmetro inteiro.",
                                    "Adicione um if para verificar se o valor é negativo.",
                                    "Dentro do if, use throw new IllegalArgumentException('Valor inválido').",
                                    "Adicione um else para processar o valor válido.",
                                    "Compile e execute o código com inputs válidos e inválidos."
                                  ],
                                  "verification": "Execute o código com input negativo e confirme que a exceção é lançada com mensagem correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JDK instalado",
                                    "Editor de código"
                                  ],
                                  "tips": "Sempre inclua uma mensagem descritiva na exceção para facilitar depuração.",
                                  "learningObjective": "Construir uma validação básica usando if e throw.",
                                  "commonMistakes": [
                                    "Esquecer import java.lang.IllegalArgumentException",
                                    "Não tratar o caso else adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir para estruturas if/else if com múltiplas validações",
                                  "subSteps": [
                                    "Modifique o método para validar múltiplos critérios (ex: valor entre 1 e 100).",
                                    "Use if/else if para checar limites inferior e superior.",
                                    "Inclua throw em cada condição inválida com mensagens específicas.",
                                    "Adicione um else final para o processamento válido.",
                                    "Teste com valores fora dos limites e confirme exceções apropriadas."
                                  ],
                                  "verification": "Registre saídas para 5 inputs diferentes, verificando exceções corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para testes"
                                  ],
                                  "tips": "Priorize validações em ordem lógica para evitar exceções redundantes.",
                                  "learningObjective": "Aplicar throw em condicionais compostas para validações robustas.",
                                  "commonMistakes": [
                                    "Usar else if incorretamente, pulando validações",
                                    "Lançar exceções genéricas sem detalhes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar em um programa maior e praticar depuração",
                                  "subSteps": [
                                    "Incorpore o método validado em uma classe principal com menu de opções.",
                                    "Adicione try-catch no main para capturar e exibir exceções.",
                                    "Simule inputs do usuário via Scanner.",
                                    "Depure cenários de erro usando breakpoints.",
                                    "Refatore o código adicionando comentários e melhorando mensagens."
                                  ],
                                  "verification": "Execute o programa completo 10 vezes com mix de inputs válidos/inválidos sem crashes inesperados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Scanner import",
                                    "Ferramentas de debug do IDE"
                                  ],
                                  "tips": "Use exceções customizadas para cenários específicos do domínio.",
                                  "learningObjective": "Dominar a integração de throw condicional em fluxos de programa reais.",
                                  "commonMistakes": [
                                    "Não capturar exceções no chamador",
                                    "Ignorar stack trace na depuração"
                                  ]
                                }
                              ],
                              "practicalExample": "public class Validador {\n  public static void processarIdade(int idade) {\n    if (idade < 0) {\n      throw new IllegalArgumentException(\"Idade não pode ser negativa.\");\n    } else if (idade > 150) {\n      throw new IllegalArgumentException(\"Idade excede limite humano realista.\");\n    } else {\n      System.out.println(\"Idade válida: \" + idade);\n    }\n  }\n\n  public static void main(String[] args) {\n    try {\n      processarIdade(-5); // Lança exceção\n    } catch (IllegalArgumentException e) {\n      System.out.println(\"Erro: \" + e.getMessage());\n    }\n  }\n}",
                              "finalVerifications": [
                                "O código compila sem erros de sintaxe.",
                                "Exceções são lançadas corretamente para todas condições inválidas testadas.",
                                "Mensagens de exceção são claras e específicas.",
                                "Fluxo do programa prossegue apenas com inputs válidos.",
                                "Try-catch captura e trata exceções sem crashar o programa.",
                                "Stack trace mostra localização exata do throw."
                              ],
                              "assessmentCriteria": [
                                "Correção na sintaxe de if/else com throw (100% funcional).",
                                "Adequação das condições de validação ao contexto.",
                                "Qualidade das mensagens de exceção (informativas e concisas).",
                                "Eficiência no controle de fluxo (sem redundâncias).",
                                "Capacidade de depuração e teste abrangente.",
                                "Boas práticas: comentários e exceções apropriadas.",
                                "Integração seamless em código maior."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Condicionais equivalem a proposições lógicas (if P then Q).",
                                "Design de Software: Validação de entrada como princípio de robustez.",
                                "Algoritmos: Estruturas de decisão em pseudocódigo.",
                                "Banco de Dados: Constraints semelhantes a throws em triggers.",
                                "Segurança da Informação: Prevenção de injeções via validações condicionais."
                              ],
                              "realWorldApplication": "Em aplicações web como e-commerces, validar parâmetros de entrada (ex: preço negativo) antes de processar pedidos, evitando erros de negócio e logs de depuração úteis para equipes de suporte."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Aplicações Práticas de Lançamento",
                        "description": "Exemplos reais de uso do lançamento de exceções em funções e subprogramas, considerando escopo de variáveis e integração com tratamento posterior.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Implementar lançamento em funções",
                            "description": "Desenvolver uma função que lança exceções em casos de erro, como função de divisão que lança exceção para divisor zero, e testar sua propagação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar a função e identificar cenários de erro",
                                  "subSteps": [
                                    "Analise os requisitos da função de divisão: dois parâmetros double (numerador e denominador).",
                                    "Identifique o erro principal: divisão por zero (denominador == 0).",
                                    "Escolha o tipo de exceção apropriado, como IllegalArgumentException para entrada inválida.",
                                    "Esboce o fluxo: verificação if, throw se erro, else calcular e retornar.",
                                    "Liste casos de teste: válido (10/2), inválido (10/0)."
                                  ],
                                  "verification": "Documento ou comentário no código com cenários de erro listados e esboço da lógica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (ex: VS Code, IntelliJ)",
                                    "Papel e caneta para rascunho"
                                  ],
                                  "tips": "Sempre considere entradas zero, negativas e extremas para robustez.",
                                  "learningObjective": "Identificar condições de erro e planejar uso de exceções para programação defensiva.",
                                  "commonMistakes": [
                                    "Esquecer casos edge como Double.NaN ou valores muito grandes.",
                                    "Confundir ArithmeticException (automática) com lançamento manual."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função com lançamento de exceção",
                                  "subSteps": [
                                    "Crie a assinatura: public static double divide(double numerador, double denominador) throws IllegalArgumentException.",
                                    "Adicione verificação: if (denominador == 0.0) { throw new IllegalArgumentException(\"Divisor não pode ser zero\"); }",
                                    "Implemente a lógica principal: return numerador / denominador;",
                                    "Adicione Javadoc ou comentários explicando o lançamento.",
                                    "Compile o código para verificar sintaxe."
                                  ],
                                  "verification": "Código compila sem erros e estrutura da função está correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "JDK instalado (versão 8+), IDE com suporte a Java (IntelliJ, Eclipse ou VS Code com extensão Java)"
                                  ],
                                  "tips": "Use mensagem de exceção descritiva para facilitar depuração.",
                                  "learningObjective": "Codificar lançamento explícito de exceções com throw.",
                                  "commonMistakes": [
                                    "Esquecer 'throws' na assinatura do método.",
                                    "Usar return após throw, tornando código inalcançável."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar o lançamento de exceção isoladamente",
                                  "subSteps": [
                                    "Crie um método main simples com chamada divide(10.0, 0.0).",
                                    "Execute o programa e verifique se a exceção é lançada no console.",
                                    "Teste caso válido: divide(10.0, 2.0) e confirme retorno 5.0.",
                                    "Capture e imprima o stack trace usando try-catch para análise.",
                                    "Registre saídas esperadas vs. reais."
                                  ],
                                  "verification": "Exceção lançada corretamente para divisor zero; resultado correto para casos válidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal ou console da IDE para execução",
                                    "JDK compiler (javac e java comandos)"
                                  ],
                                  "tips": "Use System.out.println para logs antes do throw para depuração.",
                                  "learningObjective": "Validar comportamento de lançamento em testes unitários básicos.",
                                  "commonMistakes": [
                                    "Não testar casos válidos, focando só em erros.",
                                    "Ignorar stack trace para entender origem da exceção."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar propagação de exceções em contexto maior",
                                  "subSteps": [
                                    "Crie uma função intermediária, ex: double calculateArea(double r) { return Math.PI * divide(r, 2); }",
                                    "Chame calculateArea(5.0) e calculateArea com r que cause divide(0).",
                                    "Execute sem try-catch para ver propagação até main.",
                                    "Adicione try-catch em main para capturar e logar a exceção propagada.",
                                    "Analise stack trace para confirmar caminho de propagação."
                                  ],
                                  "verification": "Exceção propaga corretamente da função interna para main; tratada ou impressa adequadamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmos da Step 2: IDE e JDK"
                                  ],
                                  "tips": "Stack trace mostra toda a cadeia de chamadas; use para depuração.",
                                  "learningObjective": "Compreender e demonstrar propagação automática de exceções não tratadas.",
                                  "commonMistakes": [
                                    "Adicionar try-catch prematuro, mascarando propagação.",
                                    "Não verificar se exceção original é preservada."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refatorar, documentar e verificar cobertura",
                                  "subSteps": [
                                    "Adicione mais testes: use JUnit se possível, ou asserts manuais.",
                                    "Melhore mensagens de exceção com detalhes (ex: valores passados).",
                                    "Documente o código com comentários sobre exceções.",
                                    "Execute todos os testes e registre resultados.",
                                    "Revise código por conformidade com boas práticas (SOLID, etc.)."
                                  ],
                                  "verification": "Todos testes passam; código documentado e sem warnings de compilação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "JUnit (opcional, via Maven/Gradle) ou testes manuais",
                                    "Ferramenta de linting como Checkstyle"
                                  ],
                                  "tips": "Considere custom exceptions para cenários reais.",
                                  "learningObjective": "Aplicar refinamentos para código de produção.",
                                  "commonMistakes": [
                                    "Sobrecarregar com exceções desnecessárias.",
                                    "Esquecer documentação de exceções em Javadoc."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma função de login em um sistema bancário: String login(String user, String pass). Se pass vazia, throw new InvalidCredentialsException(\"Senha inválida\"), propagando para o menu principal que exibe 'Acesso negado' via try-catch.",
                              "finalVerifications": [
                                "Função divide lança IllegalArgumentException exatamente quando denominador é zero.",
                                "Casos válidos retornam resultado matemático correto sem exceções.",
                                "Exceção propaga através de pelo menos uma função intermediária até main.",
                                "Stack trace identifica corretamente a linha de lançamento.",
                                "Código compila e executa sem erros em cenários válidos.",
                                "Mensagens de exceção são claras e incluem contexto do erro.",
                                "Testes cobrem 100% dos cenários planejados."
                              ],
                              "assessmentCriteria": [
                                "Lógica de lançamento correto e condicional precisa (25%)",
                                "Implementação da função com throw e throws apropriados (20%)",
                                "Testes isolados e de propagação funcionais (25%)",
                                "Análise de stack trace e verificações (15%)",
                                "Código limpo, comentado e sem erros comuns (10%)",
                                "Cobertura de edge cases (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Compreensão de operações indefinidas como divisão por zero.",
                                "Lógica e Algoritmos: Uso de condicionais para fluxos de decisão.",
                                "Desenvolvimento Ágil: Práticas de TDD com testes de exceções.",
                                "Segurança da Informação: Validação de inputs para prevenir exploits."
                              ],
                              "realWorldApplication": "Em aplicativos web como e-commerces, funções de pagamento lançam exceções para cartões inválidos ou saldos insuficientes, propagando para controllers que retornam HTTP 400 com mensagens user-friendly, evitando crashes e melhorando experiência do usuário."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Analisar código com throw",
                            "description": "Ler e debugar programas que utilizam throw, identificando o ponto de lançamento e prevendo o comportamento da execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Examinar a estrutura geral do código",
                                  "subSteps": [
                                    "Ler todo o código linha por linha para entender o contexto geral.",
                                    "Identificar funções, blocos de código e variáveis principais envolvidas.",
                                    "Mapear o fluxo normal de execução sem exceções.",
                                    "Anotar pontos de entrada e saída do programa.",
                                    "Destacar seções condicionais ou loops que possam alterar o fluxo."
                                  ],
                                  "verification": "Criar um diagrama de fluxo simples do código sem exceções.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Comece pelo main ou função principal para ter visão geral.",
                                  "learningObjective": "Compreender o esqueleto do programa antes de focar em exceções.",
                                  "commonMistakes": [
                                    "Ignorar imports ou declarações de classes",
                                    "Pular comentários explicativos",
                                    "Não mapear variáveis globais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e analisar statements de throw",
                                  "subSteps": [
                                    "Procurar por palavras-chave 'throw' no código.",
                                    "Identificar o tipo de exceção sendo lançada (ex: IllegalArgumentException).",
                                    "Analisar a mensagem de erro associada ao throw.",
                                    "Verificar as condições (if/else) que precedem o throw.",
                                    "Documentar o escopo (método/função) onde o throw ocorre."
                                  ],
                                  "verification": "Listar todos os throws encontrados com linha e condição.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Editor de código com busca (Ctrl+F)",
                                    "Documentação da linguagem (ex: Java Exceptions)"
                                  ],
                                  "tips": "Use busca por 'throw' e filtre por maiúscula para evitar falsos positivos.",
                                  "learningObjective": "Reconhecer precisamente onde e por quê exceções são lançadas.",
                                  "commonMistakes": [
                                    "Confundir 'throw' com 'throws'",
                                    "Ignorar throws condicionais",
                                    "Não verificar herança de exceções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Prever o comportamento da execução com throw",
                                  "subSteps": [
                                    "Simular inputs que ativam a condição do throw.",
                                    "Traçar o fluxo: o que acontece antes, durante e após o throw.",
                                    "Identificar se há blocos try-catch próximos que capturam a exceção.",
                                    "Prever o stack trace e parada da execução.",
                                    "Considerar propagação da exceção se não capturada."
                                  ],
                                  "verification": "Escrever uma previsão escrita do output e stack trace para inputs específicos.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Simulador online ou debugger (ex: IntelliJ IDEA)",
                                    "Papel para traçar fluxos"
                                  ],
                                  "tips": "Use setas para desenhar o desvio do fluxo normal causado pelo throw.",
                                  "learningObjective": "Antecipar impactos do throw no fluxo de controle.",
                                  "commonMistakes": [
                                    "Assumir que throw sempre para o programa",
                                    "Ignorar finally blocks",
                                    "Não considerar exceções propagadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Debugar e validar a análise",
                                  "subSteps": [
                                    "Executar o código com inputs que ativem o throw.",
                                    "Usar breakpoints no throw e condições prévias.",
                                    "Comparar stack trace real com a previsão.",
                                    "Testar variações de inputs para cenários edge-case.",
                                    "Corrigir ou refinar a análise baseada nos resultados."
                                  ],
                                  "verification": "Captura de tela ou log mostrando stack trace matching a previsão.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Ambiente de execução (JDK para Java)",
                                    "Debugger integrado no IDE"
                                  ],
                                  "tips": "Ative verbose logging para exceções se disponível.",
                                  "learningObjective": "Validar análise teórica com execução prática.",
                                  "commonMistakes": [
                                    "Executar só com inputs válidos",
                                    "Não checar propagação para chamadores",
                                    "Ignorar warnings do compilador"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere este código Java: public class Divisor { public static void divide(int a, int b) { if (b == 0) throw new ArithmeticException('Divisor zero!'); System.out.println(a / b); } public static void main(String[] args) { divide(10, 0); System.out.println('Continua?'); } } Análise: Throw na linha if (b==0), ativa com b=0, imprime stack trace e para antes de 'Continua?', sem catch.",
                              "finalVerifications": [
                                "Localiza todos os throws no código fornecido.",
                                "Prevê corretamente o stack trace para inputs inválidos.",
                                "Identifica condições exatas que disparam o throw.",
                                "Traça fluxo desviado corretamente em diagrama.",
                                "Valida previsão executando o código.",
                                "Explica impacto em chamadores se exceção propaga."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de throws (100% encontrados).",
                                "Correção na previsão de comportamento (acima de 90%).",
                                "Detalhe nos substeps e diagramas (completo e claro).",
                                "Uso adequado de debugger para validação.",
                                "Identificação de erros comuns evitados.",
                                "Explicação clara de mensagens e tipos de exceção."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Análise de condições if/else como predicados lógicos.",
                                "Algoritmos: Fluxogramas e previsão de execução como em teoria da computação.",
                                "Física/Engenharia: Modelagem de falhas e comportamentos emergentes em sistemas.",
                                "Estatística: Análise de cenários probabilísticos de erros."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, analisa código legado com throws para debugar falhas em produção, prevendo crashes em cenários de usuário reais, como validação de inputs em apps bancários ou e-commerces, evitando downtime e melhorando robustez."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Captura e Tratamento de Exceções",
                    "description": "Estrutura try-catch-finally para interceptar, tratar e finalizar exceções de forma controlada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Bloco try",
                        "description": "O bloco try envolve o código potencialmente suscetível a exceções, permitindo que o programa monitore e redirecione o fluxo de execução para tratamento em caso de erro, evitando a terminação abrupta.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Identificar código suscetível a exceções",
                            "description": "Analisar trechos de código para reconhecer operações que podem gerar exceções, como divisão por zero, acesso a índices inválidos em arrays ou falhas em entrada/saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender exceções comuns e suas causas",
                                  "subSteps": [
                                    "Estude definições de exceções como ZeroDivisionError, IndexError e IOError.",
                                    "Liste operações que geram essas exceções: divisão por zero, acesso a índice inválido, leitura de arquivo inexistente.",
                                    "Revise exemplos básicos em uma linguagem como Python ou Java.",
                                    "Classifique exceções em checked (compiladas) vs unchecked (runtime).",
                                    "Crie um glossário pessoal com 5 exceções principais."
                                  ],
                                  "verification": "Crie uma tabela resumindo 5 exceções comuns, suas causas e exemplos de código.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (ex: Python docs)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Foquem em exceções runtime primeiro, pois são mais sutis.",
                                  "learningObjective": "Reconhecer as exceções mais frequentes e suas triggers operacionais.",
                                  "commonMistakes": [
                                    "Confundir exceções com erros de sintaxe",
                                    "Ignorar exceções de I/O como 'não críticas'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar padrões de código arriscado",
                                  "subSteps": [
                                    "Analise operações matemáticas sem validação (ex: a / b sem checar b==0).",
                                    "Examine acessos a arrays/listas sem bounds checking (ex: lista[10] sem len(lista)).",
                                    "Revise chamadas de I/O: open(file) sem verificar existência.",
                                    "Identifique casts ou conversões sem validação (ex: int(input()) sem try).",
                                    "Pratique destacando linhas suscetíveis em códigos simples."
                                  ],
                                  "verification": "Marque em 3 trechos de código curto as linhas potencialmente excepcionais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código como VS Code",
                                    "Exemplos de código preparados"
                                  ],
                                  "tips": "Procure por variáveis não validadas antes de operações críticas.",
                                  "learningObjective": "Detectar padrões sintáticos que precedem exceções.",
                                  "commonMistakes": [
                                    "Sobrepor exceções raras às comuns",
                                    "Ignorar contextos condicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar trechos de código completos",
                                  "subSteps": [
                                    "Leia o código inteiro para entender fluxo e variáveis.",
                                    "Passe linha por linha, simulando execução mental.",
                                    "Anote pontos de falha potenciais com razões específicas.",
                                    "Considere inputs variados: edge cases como zero, listas vazias.",
                                    "Documente riscos em comentários ou relatório."
                                  ],
                                  "verification": "Produza um relatório anotado de um código de 20-30 linhas listando todos riscos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Trechos de código de teste",
                                    "Ferramenta de linting opcional como pylint"
                                  ],
                                  "tips": "Simule com debugger mental: 'o que se input for inválido?'",
                                  "learningObjective": "Aplicar análise sistemática para identificar vulnerabilidades em fluxos reais.",
                                  "commonMistakes": [
                                    "Focar só no início do código",
                                    "Não considerar loops ou recursão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e refinar detecção",
                                  "subSteps": [
                                    "Resolva 5 exercícios variados de identificação de exceções.",
                                    "Compare sua análise com soluções modelo.",
                                    "Crie seu próprio código suscetível e identifique falhas.",
                                    "Discuta com pares ou mentor um caso complexo.",
                                    "Registre lições aprendidas em um journal."
                                  ],
                                  "verification": "Acertar 90% em um quiz de 10 trechos de código.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Plataformas como LeetCode ou HackerRank (seção exceptions)",
                                    "Quiz auto-gerado"
                                  ],
                                  "tips": "Tempo limite por exercício para simular pressão.",
                                  "learningObjective": "Automatizar reconhecimento intuitivo de código suscetível.",
                                  "commonMistakes": [
                                    "Memorizar sem entender contexto",
                                    "Subestimar exceções assíncronas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: def divide(a, b): return a / b; lista = [1,2]; print(lista[5]) + divide(10, 0). Aqui, IndexError em lista[5], ZeroDivisionError em divide(10,0). Identifique sem executar.",
                              "finalVerifications": [
                                "Lista corretamente 5 exceções comuns e suas operações triggers.",
                                "Analisa um trecho de 20 linhas identificando todos riscos sem erros.",
                                "Explica por que um código 'parece seguro' mas falha em edge case.",
                                "Sugere validações preventivas para riscos identificados.",
                                "Acerta 9/10 em quiz de detecção prática.",
                                "Documenta análise de forma clara e estruturada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação (sem falsos positivos/negativos >95%).",
                                "Cobertura completa de edge cases e fluxos alternativos.",
                                "Explicações claras ligando código a exceções específicas.",
                                "Velocidade de análise ( <5min por trecho médio).",
                                "Capacidade de priorizar riscos por severidade.",
                                "Integração com boas práticas de codificação defensiva.",
                                "Consistência em múltiplas linguagens ou contextos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Entender domínios de funções (ex: denominador ≠0).",
                                "Lógica e Algoritmos: Análise de pré-condições e invariants.",
                                "Segurança da Informação: Identificação de vulnerabilidades em inputs.",
                                "Design de Software: Princípios de robustez e fault-tolerance."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps bancários, identificar divisão por zero em cálculos financeiros previne erros milionários; em e-commerces, acessos inválidos evitam crashes durante picos de tráfego, garantindo uptime e confiança do usuário."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Implementar sintaxe do bloco try",
                            "description": "Escrever corretamente a estrutura try em linguagens procedimentais como C++ (try { }) ou Python (try:), posicionando o código executável dentro do bloco.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a sintaxe básica do bloco try",
                                  "subSteps": [
                                    "Revise a documentação oficial do Python para try-except (try: ... except: ...).",
                                    "Estude a sintaxe do C++ para try-catch (try { ... } catch (...) { ... }).",
                                    "Identifique diferenças chave: Python usa dois pontos (:) e indentação; C++ usa chaves {}.",
                                    "Anote exemplos mínimos de cada linguagem em um caderno.",
                                    "Compare com blocos condicionais if para analogia."
                                  ],
                                  "verification": "Crie um diagrama comparativo das sintaxes e explique verbalmente as diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Python (docs.python.org)",
                                    "Documentação C++ (cppreference.com)",
                                    "Caderno ou editor de texto"
                                  ],
                                  "tips": "Use um editor de código com realce de sintaxe para visualizar melhor.",
                                  "learningObjective": "Compreender e diferenciar a sintaxe do bloco try em Python e C++.",
                                  "commonMistakes": [
                                    "Confundir indentação em Python com chaves em C++; esquecer o dois pontos após try em Python."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar bloco try em Python",
                                  "subSteps": [
                                    "Abra um IDE como VS Code ou PyCharm.",
                                    "Escreva um código simples: try: x = 1/0 except: print('Erro').",
                                    "Posicione o código potencialmente falho dentro do try:.",
                                    "Adicione um print após o try para confirmar execução.",
                                    "Salve como try_python.py."
                                  ],
                                  "verification": "Execute o código e confirme que o bloco try captura a exceção ZeroDivisionError.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python instalado (versão 3.x)",
                                    "IDE como VS Code"
                                  ],
                                  "tips": "Sempre teste com uma exceção intencional primeiro para validar a captura.",
                                  "learningObjective": "Escrever corretamente a estrutura try em Python com código executável dentro.",
                                  "commonMistakes": [
                                    "Colocar código após except dentro do try; esquecer indentação nos blocos internos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar bloco try em C++",
                                  "subSteps": [
                                    "Abra um IDE como Code::Blocks ou Visual Studio.",
                                    "Inclua <iostream> e use namespace std.",
                                    "Escreva: try { int x = 1/0; } catch(...) { cout << 'Erro'; }.",
                                    "Adicione main() e retorne 0.",
                                    "Salve como try_cpp.cpp."
                                  ],
                                  "verification": "Compile com g++ try_cpp.cpp -o try_cpp e execute; confirme mensagem de erro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador g++ ou Clang",
                                    "IDE C++"
                                  ],
                                  "tips": "Use catch(...) para capturar qualquer exceção inicialmente.",
                                  "learningObjective": "Escrever corretamente a estrutura try em C++ com chaves e código dentro.",
                                  "commonMistakes": [
                                    "Esquecer chaves {} no try ou catch; não incluir headers necessários."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar implementações",
                                  "subSteps": [
                                    "Execute ambos os códigos com input válido e inválido (ex: divisão por zero).",
                                    "Modifique para um cenário real: leitura de input do usuário que pode falhar.",
                                    "Verifique se o código continua após o try sem crash.",
                                    "Compare saídas e ajuste sintaxe se houver erros.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Ambos códigos executam sem erros de sintaxe e capturam exceções corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Códigos salvos dos steps anteriores",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use try-catch aninhados para cenários complexos, mas comece simples.",
                                  "learningObjective": "Validar sintaxe do try em contextos práticos e depurar erros comuns.",
                                  "commonMistakes": [
                                    "Não testar exceções; ignorar warnings do compilador."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: try: num = int(input('Digite um número: ')); result = 10 / num; print(result) except ValueError: print('Entrada inválida') except ZeroDivisionError: print('Divisão por zero!'). Isso previne crash ao digitar letra ou zero.",
                              "finalVerifications": [
                                "Código Python compila e executa sem SyntaxError.",
                                "Código C++ compila sem erros de sintaxe.",
                                "Bloco try captura exceções como ZeroDivisionError ou divisão por zero.",
                                "Código continua execução após exceção.",
                                "Sintaxe usa corretamente : em Python e {} em C++.",
                                "Input inválido é tratado sem crash do programa."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe try em ambas linguagens (100% precisão).",
                                "Código executável dentro do try é posicionado adequadamente.",
                                "Captura efetiva de exceções sem vazamento.",
                                "Ausência de erros comuns como indentação ou chaves faltantes.",
                                "Testes demonstram robustez em cenários reais.",
                                "Clareza e legibilidade do código escrito."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tratamento de operações indefinidas como divisão por zero.",
                                "Lógica: Estruturas condicionais análogas a if-else para fluxos de erro.",
                                "Física/Engenharia: Modelagem de falhas em simulações robustas.",
                                "Comunicação: Documentação clara de exceções para equipes."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, blocos try previnem crashes em apps como calculadoras financeiras (evitando divisão por zero em saldos) ou editores de texto (tratando arquivos corrompidos), garantindo estabilidade e experiência de usuário suave em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Testar execução normal no bloco try",
                            "description": "Executar e verificar que o código dentro do try prossegue normalmente quando não há exceções, confirmando o fluxo padrão do programa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e revisar a sintaxe do bloco try",
                                  "subSteps": [
                                    "Instale ou abra uma IDE como VS Code, PyCharm ou Jupyter Notebook com Python.",
                                    "Escreva um bloco try vazio com um print simples dentro dele.",
                                    "Adicione um bloco except genérico para capturar exceções inesperadas.",
                                    "Salve o arquivo como 'teste_try_normal.py'.",
                                    "Execute o código para confirmar que não há erros de sintaxe."
                                  ],
                                  "verification": "O código executa sem erros e o print no try aparece na saída.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python 3.x instalado, IDE (VS Code ou similar), arquivo .py",
                                  "tips": "Use print('try iniciado') no início do try para rastrear o fluxo.",
                                  "learningObjective": "Compreender a estrutura básica do bloco try e prepará-lo para testes.",
                                  "commonMistakes": "Esquecer indentação no Python; não salvar o arquivo antes de executar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever código simples que executa normalmente no try",
                                  "subSteps": [
                                    "Adicione uma operação sem risco de exceção, como 'resultado = 10 / 2'.",
                                    "Inclua prints antes, dentro e após o try para mapear o fluxo.",
                                    "Mantenha o except para ZeroDivisionError, mas sem dispará-lo.",
                                    "Adicione um print final fora do try para confirmar continuidade do programa.",
                                    "Comente o código explicando o fluxo esperado."
                                  ],
                                  "verification": "Revise o código: operação aritmética simples sem divisão por zero ou outros erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo arquivo 'teste_try_normal.py', documentação Python try/except",
                                  "tips": "Escolha operações determinísticas como soma ou divisão por número não-zero.",
                                  "learningObjective": "Criar um cenário onde o try executa o fluxo padrão sem exceções.",
                                  "commonMistakes": "Inserir acidentalmente código que gera exceção, como divisão por zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o código e observar o fluxo normal",
                                  "subSteps": [
                                    "Execute o script no terminal ou IDE com 'python teste_try_normal.py'.",
                                    "Anote a saída completa, verificando ordem dos prints.",
                                    "Confirme que todos os prints no try e após aparecem, sem mensagens de except.",
                                    "Repita a execução 3 vezes para consistência.",
                                    "Capture screenshot da saída para registro."
                                  ],
                                  "verification": "Saída mostra prints sequenciais do try e continuação do programa, sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Terminal/IDE, script preparado",
                                  "tips": "Use --verbose ou logs se disponível na IDE para mais detalhes.",
                                  "learningObjective": "Observar empiricamente que o try prossegue normalmente sem exceções.",
                                  "commonMistakes": "Ignorar prints fora do try; confundir saída com execução em except."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e documentar o teste de execução normal",
                                  "subSteps": [
                                    "Compare saída esperada vs. real em um documento ou comentário.",
                                    "Modifique ligeiramente o código (ex: mude números) e reexecute para validar.",
                                    "Escreva um relatório curto: 'Fluxo normal confirmado'.",
                                    "Teste removendo o try para contrastar com crash sem tratamento.",
                                    "Salve versão final com comentários."
                                  ],
                                  "verification": "Relatório confirma execução normal; teste sem try mostra diferença (crash).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Script, editor de texto para relatório",
                                  "tips": "Use asserts em código para automação: assert 'sucesso' in output.",
                                  "learningObjective": "Documentar e validar o comportamento padrão do try em testes.",
                                  "commonMistakes": "Não contrastar com cenário de exceção; relatório incompleto."
                                }
                              ],
                              "practicalExample": "```python\nprint('Programa inicia')\ntry:\n    resultado = 10 / 2\n    print('No try: resultado =', resultado)\n    print('Try concluído normalmente')\nexcept ZeroDivisionError:\n    print('Exceção capturada')\nprint('Programa continua após try')\n```\nSaída esperada:\nPrograma inicia\nNo try: resultado = 5.0\nTry concluído normalmente\nPrograma continua após try",
                              "finalVerifications": [
                                "Todos os prints dentro do try aparecem na saída.",
                                "Nenhum print ou ação do bloco except é executado.",
                                "O programa continua executando código após o try.",
                                "Execuções múltiplas produzem saída idêntica e previsível.",
                                "Alterações no código dentro do try (sem exceções) refletem na saída.",
                                "Contraste com código sem try mostra crash em exceções."
                              ],
                              "assessmentCriteria": [
                                "Código possui bloco try com operação normal sem exceções (100%).",
                                "Saída confirma fluxo sequencial sem desvio para except (100%).",
                                "Documentação inclui prints de debug e relatório (80%).",
                                "Testes repetidos e contrastes demonstrados (90%).",
                                "Identificação correta de erros comuns evitados (100%).",
                                "Tempo total dentro do estimado com eficiência (bonus)."
                              ],
                              "crossCurricularConnections": [
                                "Lógica de Programação: Entender fluxo condicional sem exceções.",
                                "Debugging e Testes: Uso de prints para verificação de execução.",
                                "Matemática Computacional: Operações aritméticas seguras.",
                                "Escrita Técnica: Documentação de testes e relatórios."
                              ],
                              "realWorldApplication": "Em aplicações web ou mobile, testar fluxos normais em blocos try garante que operações cotidianas como login bem-sucedido ou cálculos simples prossigam sem interrupções desnecessárias, melhorando a robustez e experiência do usuário em softwares de e-commerce ou bancos."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Bloco catch",
                        "description": "O bloco catch captura exceções lançadas pelo bloco try, permitindo tratamento específico ou genérico, com acesso ao objeto exceção para análise e recuperação.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Capturar exceções genéricas",
                            "description": "Implementar um bloco catch que intercepte qualquer tipo de exceção, exibindo mensagens de erro genéricas e permitindo continuação do programa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de exceções genéricas e o papel do bloco catch",
                                  "subSteps": [
                                    "Estude o que são exceções em programação e por que capturá-las genéricamente.",
                                    "Leia a documentação oficial sobre a classe Exception (ex: em Java, Exception é a superclasse).",
                                    "Identifique cenários onde um catch genérico é útil, como em protótipos iniciais.",
                                    "Anote diferenças entre catch específico e genérico.",
                                    "Revise hierarquia de exceções para entender por que Exception captura tudo."
                                  ],
                                  "verification": "Explique em suas palavras o que um catch genérico faz e liste 3 vantagens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação da linguagem (ex: Java Docs para Exception), editor de texto.",
                                  "tips": "Comece com exemplos simples de exceções como ArithmeticException para visualizar.",
                                  "learningObjective": "Entender o propósito e limitações de capturar exceções com Exception.",
                                  "commonMistakes": "Confundir Exception com Throwable (captura erros do sistema também); ignorar que catch genérico mascara tipos específicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a sintaxe básica do bloco try-catch genérico",
                                  "subSteps": [
                                    "Escreva um bloco try vazio.",
                                    "Adicione um catch (Exception e) { } após o try.",
                                    "No catch, adicione System.out.println('Erro genérico: ' + e.getMessage());",
                                    "Teste compilação com código try { int x = 1/0; } catch(Exception e) { ... }",
                                    "Adicione finally opcional para cleanup."
                                  ],
                                  "verification": "O código compila sem erros e imprime mensagem ao dividir por zero.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE como IntelliJ ou VS Code com Java, terminal para execução.",
                                  "tips": "Use e.printStackTrace() inicialmente para debug, mas prefira getMessage() para produção.",
                                  "learningObjective": "Dominar a sintaxe exata para um catch que intercepta qualquer Exception.",
                                  "commonMistakes": "Esquecer parênteses em catch(Exception e); usar RuntimeException em vez de Exception."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar o catch genérico em um programa existente para permitir continuação",
                                  "subSteps": [
                                    "Crie um programa simples com múltiplas operações propensas a erros (divisão, array index, input inválido).",
                                    "Envolva seções arriscadas em try-catch genérico.",
                                    "No catch, exiba mensagem genérica e continue com próximo código.",
                                    "Garanta que o programa não pare após erro (ex: loop continua).",
                                    "Adicione log do tipo de exceção para observação."
                                  ],
                                  "verification": "Execute o programa com erros induzidos; confirme que erros são logados mas execução prossegue.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE, exemplos de código com exceções comuns.",
                                  "tips": "Coloque try-catch ao redor de blocos lógicos, não linha por linha, para performance.",
                                  "learningObjective": "Implementar catch genérico que mantém o programa rodando apesar de falhas.",
                                  "commonMistakes": "Colocar todo o main em try (ruim para isolamento); não usar e.getMessage() corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar o tratamento genérico",
                                  "subSteps": [
                                    "Gere exceções variadas: Arithmetic, NullPointer, IndexOutOfBounds.",
                                    "Verifique se todas são capturadas e mensagens são exibidas.",
                                    "Teste continuação: adicione prints após catch para confirmar fluxo.",
                                    "Refatore para mensagens mais amigáveis e logging opcional.",
                                    "Documente limitações no código (comentários)."
                                  ],
                                  "verification": "Relatório de testes mostra 100% de exceções capturadas sem crash.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "JUnit ou testes manuais, debugger da IDE.",
                                  "tips": "Use debugger para pausar no catch e inspecionar 'e'.",
                                  "learningObjective": "Validar robustez do catch genérico em cenários reais.",
                                  "commonMistakes": "Não testar exceções checked vs unchecked; assumir que catch genérico resolve tudo."
                                }
                              ],
                              "practicalExample": "Em um calculadora simples: try { resultado = num1 / num2; } catch(Exception e) { System.out.println('Erro no cálculo: ' + e.getMessage()); resultado = 0; } System.out.println('Continuando com próximo cálculo...'); Isso permite múltiplos cálculos sem parar o app.",
                              "finalVerifications": [
                                "Código compila e executa sem crashes em exceções testadas.",
                                "Mensagens genéricas são exibidas corretamente para qualquer Exception.",
                                "Programa continua execução após catch.",
                                "Stack trace ou mensagem inclui detalhes suficientes para debug inicial.",
                                "Nenhum erro é propagado para cima sem tratamento."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe do catch genérico (usa Exception adequadamente).",
                                "Mensagens de erro são genéricas mas informativas (usa getMessage()).",
                                "Fluxo do programa continua ininterruptamente.",
                                "Código é limpo, com comentários explicando escolhas.",
                                "Testes cobrem pelo menos 3 tipos de exceções diferentes."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e Testing: Relaciona com identificação de bugs em ciclos de desenvolvimento.",
                                "Design de UX: Melhora experiência do usuário evitando crashes abruptos.",
                                "Gestão de Projetos: Ensina resiliência em software para entregas robustas.",
                                "Lógica e Algoritmos: Reforça controle de fluxo com exceções."
                              ],
                              "realWorldApplication": "Em aplicativos web ou mobile, um catch genérico em rotas críticas previne que um erro de usuário (ex: input inválido) derrube o servidor inteiro, permitindo que outros usuários continuem acessando enquanto o erro é logado para correção posterior."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Capturar exceções específicas",
                            "description": "Especificar tipos de exceções no catch, como ZeroDivisionError em Python ou std::exception em C++, para tratamentos direcionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Exceções Específicas e sua Hierarquia",
                                  "subSteps": [
                                    "Estude a hierarquia de exceções na linguagem escolhida (ex: BaseException em Python ou std::exception em C++).",
                                    "Liste 5 exceções comuns: ZeroDivisionError, ValueError, IndexError em Python; ou divide_by_zero em C++.",
                                    "Compare catch genérico (Exception) vs. específico, destacando vantagens como tratamentos direcionados.",
                                    "Crie um diagrama simples da hierarquia de exceções.",
                                    "Leia exemplos da documentação oficial."
                                  ],
                                  "verification": "Liste corretamente 5 exceções específicas com descrições e hierarquia em um documento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Python (docs.python.org) ou C++ (cppreference.com)",
                                    "Notebook ou editor de texto"
                                  ],
                                  "tips": "Use ferramentas como `pythontutor.com` para visualizar hierarquias.",
                                  "learningObjective": "Dominar a hierarquia de exceções e benefícios de capturas específicas para tratamentos precisos.",
                                  "commonMistakes": [
                                    "Capturar exceções muito genéricas como 'Exception' em tudo.",
                                    "Ignorar a herança na hierarquia, capturando subclasses incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Exceções Relevantes em Código",
                                  "subSteps": [
                                    "Selecione um código simples propenso a erros (ex: divisão ou acesso a lista).",
                                    "Execute o código com inputs inválidos para observar exceções geradas.",
                                    "Registre o tipo exato da exceção usando try-except temporário ou debugger.",
                                    "Mapeie 3-5 cenários de erro e suas exceções correspondentes.",
                                    "Priorize exceções baseadas em frequência e impacto."
                                  ],
                                  "verification": "Crie uma tabela com cenários de erro, exceções esperadas e causas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE como VS Code ou PyCharm",
                                    "Código de exemplo com erros intencionais"
                                  ],
                                  "tips": "Use print(sys.exc_info()) em Python para inspecionar exceções durante testes.",
                                  "learningObjective": "Analisar código para prever e mapear exceções específicas de forma proativa.",
                                  "commonMistakes": [
                                    "Não testar com inputs edge-case como zero ou índices inválidos.",
                                    "Confundir exceções de runtime com syntax errors."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Blocos Catch para Exceções Específicas",
                                  "subSteps": [
                                    "Escreva um bloco try com código arriscado (ex: 10 / int(input())).",
                                    "Adicione catches específicos: except ZeroDivisionError, except ValueError.",
                                    "Implemente tratamentos direcionados: mensagens customizadas ou valores default.",
                                    "Adicione múltiplos catches em ordem hierárquica correta (mais específica primeiro).",
                                    "Inclua um catch genérico final para exceções não previstas."
                                  ],
                                  "verification": "O código executa sem crash e imprime mensagens corretas para 3 exceções testadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código Python/C++"
                                  ],
                                  "tips": "Em C++, use 'catch (const std::runtime_error& e)' para herança.",
                                  "learningObjective": "Construir blocos try-catch com tipos específicos para tratamentos robustos e direcionados.",
                                  "commonMistakes": [
                                    "Ordem errada de catches (genérico antes de específico).",
                                    "Não tratar a exceção adequadamente, só printando."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Refinar Tratamentos de Exceções",
                                  "subSteps": [
                                    "Crie testes unitários para cada exceção (ex: pytest em Python).",
                                    "Simule cenários reais e verifique se catches ativam corretamente.",
                                    "Meça cobertura de exceções com ferramentas como coverage.py.",
                                    "Refine tratamentos com logging ou recuperação de estado.",
                                    "Documente o código com comentários sobre exceções capturadas."
                                  ],
                                  "verification": "Todos os testes passam e cobertura de exceções >80%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de teste: pytest (Python) ou Google Test (C++)",
                                    "Debugger integrado na IDE"
                                  ],
                                  "tips": "Use asserts para verificar estados pós-exceção.",
                                  "learningObjective": "Validar e otimizar catches específicos para software confiável.",
                                  "commonMistakes": [
                                    "Testar só casos felizes, ignorando exceções.",
                                    "Excesso de catches desnecessários, complicando o código."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: \n```python\ntry:\n    num = int(input('Digite um número: '))\n    result = 10 / num\nexcept ValueError:\n    print('Entrada inválida! Use um número inteiro.')\nexcept ZeroDivisionError:\n    print('Não divida por zero!')\nelse:\n    print(f'Resultado: {result}')\n```\nEm C++: \n```cpp\ntry {\n    int num; std::cin >> num;\n    if (num == 0) throw 0;\n    std::cout << 10 / num;\n} catch (const std::invalid_argument& e) {\n    std::cout << \"Entrada inválida!\";\n} catch (int e) {\n    std::cout << \"Divisão por zero!\";\n}\n```",
                              "finalVerifications": [
                                "Código captura ZeroDivisionError e ValueError sem propagar exceções genéricas.",
                                "Tratamentos exibem mensagens direcionadas e evitam crashes.",
                                "Testes cobrem todos os catches específicos implementados.",
                                "Hierarquia de catches respeita ordem (específico antes de genérico).",
                                "Logging ou saída confirma ativação correta de cada catch.",
                                "Código mantém funcionalidade para entradas válidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na especificação de tipos de exceções no catch (100% corretos).",
                                "Tratamentos direcionados e úteis, não genéricos.",
                                "Cobertura de pelo menos 80% das exceções identificadas.",
                                "Ordem hierárquica correta nos múltiplos catches.",
                                "Integração fluida com fluxo principal do programa.",
                                "Documentação clara sobre exceções tratadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reconhecer operações inválidas como divisão por zero.",
                                "Design de Software: Princípios de robustez e defensive programming.",
                                "Debugging e Testes: Análise de stack traces e unit testing.",
                                "Lógica Computacional: Mapeamento de condições de erro a ações.",
                                "Gestão de Projetos: Redução de downtime em aplicações críticas."
                              ],
                              "realWorldApplication": "Em aplicativos bancários para validar transações (ex: divisão por zero em cálculos de juros), APIs web que processam inputs de usuários evitando crashes em e-commerces, ou jogos que lidam com colisões inválidas sem interromper a experiência do jogador."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Acessar informações da exceção",
                            "description": "Utilizar métodos como getMessage() ou what() para extrair detalhes da exceção capturada e logá-los ou exibi-los ao usuário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da classe Exception e seus métodos",
                                  "subSteps": [
                                    "Acessar a documentação oficial da linguagem (ex: JavaDoc para Exception em Java ou std::exception em C++).",
                                    "Identificar métodos principais como getMessage(), getLocalizedMessage(), toString() e printStackTrace().",
                                    "Analisar herança: Exception herda de Throwable em Java ou exception em C++.",
                                    "Estudar exemplos de exceções comuns (NullPointerException, IOException).",
                                    "Comparar diferenças entre getMessage() (retorna String da mensagem) e printStackTrace() (imprime stack completo)."
                                  ],
                                  "verification": "Listar e descrever pelo menos 3 métodos da classe Exception com seus retornos esperados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial (JDK ou C++ reference)",
                                    "IDE com suporte a documentação (IntelliJ, VS Code)"
                                  ],
                                  "tips": "Use o atalho da IDE para ver tooltips dos métodos diretamente no código.",
                                  "learningObjective": "Identificar e entender os métodos disponíveis para extrair informações de exceções.",
                                  "commonMistakes": [
                                    "Assumir que todos os métodos sempre retornam dados não-nulos",
                                    "Confundir exceções checked com unchecked sem verificar herança"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Capturar a exceção no bloco catch de forma adequada",
                                  "subSteps": [
                                    "Escrever um bloco try-catch básico envolvendo código que pode lançar exceção (ex: divisão por zero).",
                                    "Declarar a variável da exceção no catch: catch (Exception e) {}",
                                    "Garantir que o tipo da exceção seja específico ou genérico (Exception para capturar qualquer).",
                                    "Testar captura com throw manual para validar.",
                                    "Evitar catch-all sem análise; preferir exceções específicas quando possível."
                                  ],
                                  "verification": "Executar código que lança exceção e confirmar que é capturada sem crash do programa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com compilador",
                                    "Código de exemplo simples com throw"
                                  ],
                                  "tips": "Sempre nomeie a variável como 'e' ou 'ex' para clareza e convenção.",
                                  "learningObjective": "Capturar exceções de forma segura e acessível no escopo do catch.",
                                  "commonMistakes": [
                                    "Esquecer de declarar a variável da exceção",
                                    "Usar catch sem parâmetro (inválido em linguagens modernas)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair detalhes da exceção usando métodos específicos",
                                  "subSteps": [
                                    "Dentro do catch, chamar e.getMessage() (Java) ou e.what() (C++) e armazenar em variável String.",
                                    "Concatenar com outros métodos se necessário: e.toString() para classe + mensagem.",
                                    "Verificar se o retorno é null e tratar com mensagem padrão.",
                                    "Capturar stack trace com e.printStackTrace() para debug.",
                                    "Adaptar para linguagem: usar std::string msg = e.what(); em C++."
                                  ],
                                  "verification": "Imprimir ou logar o resultado e confirmar que exibe mensagem correta da exceção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE",
                                    "Logger simples (System.out ou std::cout)"
                                  ],
                                  "tips": "Combine getMessage() com getClass().getName() para contexto completo: 'Erro: ' + e.getClass().getSimpleName() + ' - ' + e.getMessage()",
                                  "learningObjective": "Extrair e manipular informações detalhadas da exceção capturada.",
                                  "commonMistakes": [
                                    "Chamar getMessage() sem verificar null",
                                    "Ignorar encoding em C++ com what()"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Logar ou exibir as informações extraídas de forma apropriada",
                                  "subSteps": [
                                    "Usar System.out.println ou logger para exibir: System.out.println('Erro: ' + e.getMessage());",
                                    "Implementar log estruturado: incluir timestamp e contexto.",
                                    "Para usuário final, mostrar mensagem amigável sem detalhes técnicos.",
                                    "Gravar em arquivo de log se aplicável (ex: FileWriter em Java).",
                                    "Testar com múltiplas exceções para validar consistência."
                                  ],
                                  "verification": "Gerar exceções variadas e inspecionar output/log para detalhes corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE",
                                    "Ferramenta de log (java.util.logging ou cout)",
                                    "Arquivo de teste"
                                  ],
                                  "tips": "Nunca exponha stack trace completo ao usuário; reserve para logs internos.",
                                  "learningObjective": "Aplicar as informações extraídas em saídas úteis para debug ou usuário.",
                                  "commonMistakes": [
                                    "Expor detalhes sensíveis ao usuário",
                                    "Esquecer de flush no log para arquivo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java:\ntry {\n  int x = 10 / 0;\n} catch (ArithmeticException e) {\n  String msg = e.getMessage(); // 'by zero'\n  System.out.println(\"Erro detectado: \" + msg);\n  e.printStackTrace(); // Para log completo\n}",
                              "finalVerifications": [
                                "Código captura e extrai mensagem de pelo menos 3 tipos de exceções diferentes.",
                                "Mensagens são logadas/exibidas sem crash do programa.",
                                "Tratamento de null em getMessage() é implementado.",
                                "Stack trace é acessível apenas em modo debug.",
                                "Testes unitários confirmam comportamento em cenários edge-case."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de getMessage()/what() sem erros de sintaxe.",
                                "Integração fluida no bloco catch com captura adequada.",
                                "Tratamento robusto de retornos null ou vazios.",
                                "Diferenciação clara entre log para dev e mensagem para usuário.",
                                "Eficiência: sem chamadas desnecessárias a métodos pesados como printStackTrace().",
                                "Adaptabilidade a linguagens Java/C++."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e análise de logs em Desenvolvimento de Software.",
                                "Gestão de erros em Sistemas Operacionais e Redes.",
                                "Relatórios de falhas em Qualidade de Software e Testes.",
                                "UX/UI: Mensagens de erro amigáveis em Design de Interfaces."
                              ],
                              "realWorldApplication": "Em aplicações empresariais como bancos online, acessar e logar detalhes de exceções (ex: conexão BD falha) permite debug rápido pela equipe sem expor vulnerabilidades ao usuário, garantindo continuidade e conformidade com auditorias de segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.4",
                            "name": "Encadear múltiplos blocos catch",
                            "description": "Configurar vários catch consecutivos para tratar diferentes tipos de exceções em ordem de especificidade, garantindo captura apropriada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a hierarquia de exceções e a ordem de captura",
                                  "subSteps": [
                                    "Estude a hierarquia de exceções em Java (Throwable > Exception > RuntimeException e checked exceptions).",
                                    "Identifique exceções específicas como IOException, FileNotFoundException e ArithmeticException.",
                                    "Aprenda que catch blocks devem ser ordenados do mais específico para o mais genérico (ex: FileNotFoundException antes de IOException).",
                                    "Revise exemplos da documentação oficial da Oracle sobre exceções.",
                                    "Anote 3 exemplos de hierarquias comuns em cenários de I/O e divisão por zero."
                                  ],
                                  "verification": "Crie um diagrama simples da hierarquia de exceções usadas e confirme a ordem correta de captura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Java Exceptions (docs.oracle.com), editor de texto ou papel para diagrama.",
                                  "tips": "Sempre priorize catch específicos primeiro para evitar captura prematura por genéricos.",
                                  "learningObjective": "Entender por que a ordem importa para tratamento seletivo de exceções.",
                                  "commonMistakes": "Colocar catch genérico (Exception) antes de específicos, capturando tudo inadvertidamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar sintaxe de múltiplos blocos catch",
                                  "subSteps": [
                                    "Escreva um bloco try com código que possa lançar exceções específicas (ex: ler arquivo inexistente e divisão por zero).",
                                    "Adicione 3 catch blocks consecutivos: um para FileNotFoundException, um para ArithmeticException e um para Exception.",
                                    "Inclua ações específicas em cada catch: log da exceção, mensagem personalizada e recuperação se possível.",
                                    "Compile o código para verificar sintaxe.",
                                    "Adicione um finally block opcional para cleanup."
                                  ],
                                  "verification": "Código compila sem erros e cada catch tem lógica única.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE como IntelliJ ou Eclipse, JDK instalado.",
                                  "tips": "Use 'e instanceof' ou multi-catch (Java 7+) para otimizar, mas foque em múltiplos blocks aqui.",
                                  "learningObjective": "Dominar a sintaxe e estrutura de encadeamento de catch blocks.",
                                  "commonMistakes": "Esquecer de importar classes de exceção ou inverter ordem dos blocks."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar o encadeamento com diferentes exceções",
                                  "subSteps": [
                                    "Crie cenários de teste: arquivo inexistente, divisão por zero e exceção genérica.",
                                    "Execute o código e verifique qual catch é acionado para cada caso.",
                                    "Use System.out ou logger para registrar qual block foi atingido.",
                                    "Altere a ordem dos catch e observe o comportamento (e corrija).",
                                    "Teste com exceções não previstas para validar o catch genérico."
                                  ],
                                  "verification": "Logs mostram captura correta por especificidade em todos os testes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE com console/debugger, arquivos de teste dummy.",
                                  "tips": "Use breakpoints no debugger para pausar em cada catch e inspecionar.",
                                  "learningObjective": "Validar funcionalidade do encadeamento em runtime.",
                                  "commonMistakes": "Não testar exceções intermediárias na hierarquia, assumindo comportamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refatorar e aplicar boas práticas",
                                  "subSteps": [
                                    "Analise o código: remova redundâncias e melhore mensagens de erro.",
                                    "Considere usar multi-catch se aplicável (ex: catch (IOException | SQLException e).",
                                    "Integre em um método maior, como um leitor de configuração.",
                                    "Adicione Javadoc comentando a lógica de captura.",
                                    "Revise com um peer ou self-review checklist."
                                  ],
                                  "verification": "Código refatorado é legível, comentado e segue princípios SOLID (Single Responsibility).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE com linter (ex: Checkstyle), guia de boas práticas Java.",
                                  "tips": "Prefira exceções customizadas em projetos reais para granularidade.",
                                  "learningObjective": "Aplicar encadeamento de forma robusta e mantível.",
                                  "commonMistakes": "Ignorar finally ou propagar exceções desnecessariamente."
                                }
                              ],
                              "practicalExample": "Em um app de processamento de arquivos: try { lerArquivo(); dividirValores(); } catch (FileNotFoundException e) { log('Arquivo ausente'); criarArquivoDefault(); } catch (ArithmeticException e) { log('Divisão inválida'); usarZero(); } catch (Exception e) { log('Erro genérico'); sairGracefully(); } finally { fecharRecursos(); }",
                              "finalVerifications": [
                                "Código captura exceções na ordem correta de especificidade.",
                                "Cada catch executa ação apropriada sem vazamento.",
                                "Testes cobrem todos os branches de catch.",
                                "Nenhuma exceção escapa sem tratamento.",
                                "Código compila e roda sem warnings de exceções unchecked.",
                                "Logs diferenciam tipos de erro claramente."
                              ],
                              "assessmentCriteria": [
                                "Ordem dos catch blocks segue hierarquia (específico > genérico): 25%.",
                                "Implementação sintática correta e testada: 25%.",
                                "Tratamento seletivo e recuperação lógica: 20%.",
                                "Boas práticas (logs, finally, comentários): 15%.",
                                "Exemplo prático integrado e funcional: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Debugging e Testing: Uso de unit tests com mocks para exceções.",
                                "Design de Software: Princípios de resiliência e fail-safe.",
                                "Lógica e Algoritmos: Estruturas condicionais aninhadas em tratamento.",
                                "Banco de Dados: Tratamento de SQLExceptions em camadas de persistência."
                              ],
                              "realWorldApplication": "Em servidores web (ex: Spring Boot), encadear catch para tratar ConnectionTimeoutException antes de IOException em chamadas HTTP, garantindo retry seletivo e logs granulares para monitoramento em produção."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Bloco finally",
                        "description": "O bloco finally executa código de limpeza independentemente de exceções ocorrerem ou não, garantindo liberação de recursos como arquivos ou conexões.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Implementar sintaxe do bloco finally",
                            "description": "Adicionar o bloco finally após try-catch em C++ ou Python (finally:), posicionando ações obrigatórias de finalização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o propósito e o contexto do bloco finally",
                                  "subSteps": [
                                    "Explicar que o bloco finally executa sempre, independentemente se houve exceção ou não no try ou except.",
                                    "Identificar usos comuns: limpeza de recursos como fechar arquivos, conexões de banco ou liberar memória.",
                                    "Comparar com C++: em C++, não há finally nativo; usa-se RAII (destructors automáticos) para ações semelhantes.",
                                    "Analisar fluxograma: try → (exceção? except : nada) → finally.",
                                    "Ler exemplos na documentação oficial do Python (seção exceptions)."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo o papel do finally e dar um exemplo de uso.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/3/tutorial/errors.html",
                                    "Editor de texto ou IDE como VS Code"
                                  ],
                                  "tips": "Visualize cenários onde um erro impede o cleanup manual, como abrir um arquivo sem fechá-lo.",
                                  "learningObjective": "Entender o 'sempre executa' do finally e suas aplicações em gerenciamento de recursos.",
                                  "commonMistakes": "Confundir finally com except (finally não captura exceções) ou achar que só roda em erros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar e praticar a sintaxe básica de try-except",
                                  "subSteps": [
                                    "Escrever um código simples com try-except sem finally: ex. divisão por zero.",
                                    "Testar execução: sucesso e falha, observando que cleanup manual pode ser esquecido.",
                                    "Identificar onde inserir finally: logo após except (Python) ou catch (C++ equivalente).",
                                    "Estudar sintaxe Python: try: ... except Exception: ... finally: ...",
                                    "Para C++: notar ausência de finally e planejar uso de std::unique_ptr ou destructors."
                                  ],
                                  "verification": "Executar código try-except e confirmar que print no final do código roda só em sucesso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "REPL Python ou Jupyter Notebook",
                                    "Compilador C++ opcional (g++)"
                                  ],
                                  "tips": "Use print() em cada bloco para visualizar ordem de execução.",
                                  "learningObjective": "Dominar a base try-except para adicionar finally corretamente.",
                                  "commonMistakes": "Esquecer indentação no Python ou usar wrong syntax como 'catch' em vez de 'except'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a sintaxe do bloco finally em código",
                                  "subSteps": [
                                    "Adicionar finally ao código anterior: ex. try: open('file.txt') except: print('erro') finally: print('cleanup') ou file.close().",
                                    "Posicionar ações obrigatórias: sempre no finally, como fechar recursos.",
                                    "Testar em Python: rodar com sucesso e erro, confirmando finally sempre.",
                                    "Para C++: implementar equivalente com classe RAII que chama destructor para cleanup.",
                                    "Refatorar código existente adicionando finally onde necessário."
                                  ],
                                  "verification": "Rodar código 3x: sucesso, exceção e normal; finally deve printar sempre.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como PyCharm ou VS Code com Python/C++",
                                    "Arquivo de teste 'arquivo.txt'"
                                  ],
                                  "tips": "Use 'with open()' como alternativa ao finally para arquivos, mas foque em finally para generalidade.",
                                  "learningObjective": "Implementar sintaxe correta e posicionar ações de finalização.",
                                  "commonMistakes": "Colocar código de cleanup no try (falha em exceção) ou indentar finally errado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar cenários avançados e verificar robustez",
                                  "subSteps": [
                                    "Testar exceções no finally: deve propagar após executar.",
                                    "Simular cenários reais: conexão DB falsa com socket, cleanup sempre.",
                                    "Comparar performance: medir tempo com/ sem finally (insignificante, mas cleanup garante).",
                                    "Adaptar para C++: criar struct com destructor que loga 'finally'.",
                                    "Documentar código com comentários explicando finally."
                                  ],
                                  "verification": "Criar relatório: 'Finally executou em X/4 cenários esperados'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca socket para simular rede",
                                    "Unit tests com pytest"
                                  ],
                                  "tips": "Use try-finally sem except para casos onde não quer capturar, só cleanup.",
                                  "learningObjective": "Garantir que finally funcione em todos fluxos e exceções aninhadas.",
                                  "commonMistakes": "Ignorar exceções no finally ou não testar caminhos de falha."
                                }
                              ],
                              "practicalExample": "Exemplo em Python:\n```python\ntry:\n    f = open('dados.txt', 'r')\n    conteudo = f.read()\nexcept FileNotFoundError:\n    print('Arquivo não encontrado!')\nfinally:\n    print('Fechando arquivo...')\n    if 'f' in locals():\n        f.close()\n```\nSaída sempre inclui 'Fechando arquivo...' mesmo em erro. Em C++: use std::ifstream com RAII.",
                              "finalVerifications": [
                                "Bloco finally executa em sucesso, exceção capturada e exceção não capturada.",
                                "Recursos são liberados corretamente (ex. arquivo fechado).",
                                "Código não gera vazamentos de memória ou recursos.",
                                "Sintaxe é válida e compila/ roda sem erros.",
                                "Exceções no finally propagam após execução.",
                                "Comentários explicam o uso do finally."
                              ],
                              "assessmentCriteria": [
                                "Correta posição e indentação do finally após try/except.",
                                "Ações de cleanup estão exclusivamente no finally.",
                                "Testes cobrem 100% dos cenários (sucesso/falha).",
                                "Código é legível com comentários.",
                                "Adaptação para C++ usa RAII corretamente.",
                                "Tempo de execução não é impactado negativamente."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: fluxos condicionais e incondicionais.",
                                "Gestão de Projetos: planejamento de cleanup em falhas.",
                                "Física: analogia com conservação de energia/recursos.",
                                "Inglês Técnico: leitura de docs Python/C++."
                              ],
                              "realWorldApplication": "Em aplicações de software como servidores web (ex. Flask/Django), onde conexões de banco ou sockets devem ser fechadas sempre, evitando vazamentos de memória ou locks em produção, mesmo em crashes parciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Usar finally para limpeza de recursos",
                            "description": "Colocar comandos de fechamento de arquivos, desalocação de memória ou reset de variáveis no finally para evitar vazamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender recursos gerenciados e riscos de vazamento",
                                  "subSteps": [
                                    "Identificar tipos comuns de recursos: arquivos, conexões de banco de dados, streams de rede",
                                    "Explicar ciclo de vida: abertura, uso e fechamento obrigatório",
                                    "Analisar cenários de falha: exceções durante abertura ou uso impedem fechamento no try",
                                    "Discutir impactos: consumo excessivo de memória, handles abertos, lentidão no sistema",
                                    "Comparar try-catch sem finally vs. com finally"
                                  ],
                                  "verification": "Escrever um parágrafo resumindo riscos de não usar finally e envie para revisão",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial da linguagem (ex: Java FileInputStream), exemplos de vazamentos online",
                                  "tips": "Pense em um app real: sem fechar arquivos, o SO fica sobrecarregado após múltiplas execuções",
                                  "learningObjective": "Reconhecer quando e por que recursos precisam de limpeza garantida",
                                  "commonMistakes": "Ignorar recursos não-IO como locks ou timers que também vazam"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar o bloco try-catch-finally básico",
                                  "subSteps": [
                                    "Criar estrutura try {} catch (Exception e) {} finally {}",
                                    "Colocar código de abertura de recurso no início do try",
                                    "Adicionar lógica de uso do recurso no meio do try",
                                    "Simular uma exceção intencional no try para testar fluxo",
                                    "Verificar execução sequencial: try -> catch (se exceção) -> finally sempre"
                                  ],
                                  "verification": "Executar código e confirmar via logs que finally roda em todos os cenários",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE (Eclipse/IntelliJ/VSCode), compilador Java/Python equivalente",
                                  "tips": "Use System.out.println em cada bloco para visualizar o fluxo de execução",
                                  "learningObjective": "Implementar corretamente a sintaxe try-catch-finally",
                                  "commonMistakes": "Esquecer chaves {} ou colocar finally dentro do catch"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar comandos de limpeza no bloco finally",
                                  "subSteps": [
                                    "Verificar se recurso foi aberto antes de fechar (if (recurso != null) recurso.close())",
                                    "Adicionar try-catch interno no finally para exceções de fechamento",
                                    "Incluir múltiplos recursos: fechar em ordem inversa de abertura",
                                    "Resetar variáveis de referência para null após fechamento",
                                    "Registrar logs de limpeza para depuração"
                                  ],
                                  "verification": "Rodar com e sem exceção, inspecionar logs e monitor de processos (ex: jconsole para handles)",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplo de arquivo de teste (texto.txt), ferramenta de monitoramento de recursos (Task Manager ou jvisualvm)",
                                  "tips": "Ordem importa: feche dependentes primeiro (ex: writer antes de reader)",
                                  "learningObjective": "Colocar adequadamente comandos de desalocação/reset no finally",
                                  "commonMistakes": "Fechar recurso sem null-check, causando NullPointerException no finally"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refatorar para robustez",
                                  "subSteps": [
                                    "Criar testes unitários: sucesso, exceção no try, exceção no finally",
                                    "Simular falhas reais: arquivo inexistente, disco cheio",
                                    "Refatorar para try-with-resources se aplicável (Java 7+)",
                                    "Analisar cobertura de código e métricas de vazamento",
                                    "Documentar o padrão no código com comentários"
                                  ],
                                  "verification": "Testes passam 100% e nenhum vazamento detectado após 100 iterações",
                                  "estimatedTime": "25 minutos",
                                  "materials": "JUnit/Pytest para testes, profiler de memória (VisualVM)",
                                  "tips": "Automatize testes em loop para detectar vazamentos cumulativos",
                                  "learningObjective": "Validar e otimizar o uso de finally em cenários reais",
                                  "commonMistakes": "Não testar exceções no finally, assumindo que limpeza nunca falha"
                                }
                              ],
                              "practicalExample": "Em Java: try { FileInputStream fis = new FileInputStream('arquivo.txt'); // uso } catch (IOException e) { // log } finally { if (fis != null) { try { fis.close(); } catch (IOException ex) { // log } } fis = null; } // Garante fechamento mesmo se exceção ocorrer.",
                              "finalVerifications": [
                                "Recurso é fechado em execução normal (sem exceção)",
                                "Recurso é fechado quando exceção ocorre no try",
                                "Recurso é fechado mesmo se exceção no catch ou finally",
                                "Nenhum vazamento detectado via monitor de processos",
                                "Logs confirmam execução do finally em todos fluxos",
                                "Variáveis resetadas para null após limpeza"
                              ],
                              "assessmentCriteria": [
                                "Estrutura try-catch-finally sintaticamente correta (100%)",
                                "Null-check e try-catch no finally para robustez",
                                "Limpeza em ordem correta para múltiplos recursos",
                                "Testes cobrem todos cenários de exceção (80%+ cobertura)",
                                "Código limpo com comentários explicativos",
                                "Nenhum vazamento em simulações estressadas"
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de memória em Ciência da Computação",
                                "Boas práticas de programação defensiva em Algoritmos",
                                "Padrões de design (RAII em C++) em Engenharia de Software",
                                "Segurança de sistemas (evitar DoS por vazamentos)"
                              ],
                              "realWorldApplication": "Em servidores web (ex: Spring Boot), garante fechamento de conexões JDBC mesmo em picos de tráfego com exceções, prevenindo esgotamento de pool de conexões e downtime."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Verificar execução incondicional do finally",
                            "description": "Testar cenários com e sem exceções para confirmar que o finally sempre executa, inclusive em casos de return ou break.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e código base com bloco try-finally",
                                  "subSteps": [
                                    "Crie um projeto simples em uma IDE como IntelliJ ou Eclipse com uma linguagem que suporte try-catch-finally (ex: Java).",
                                    "Escreva um método básico com bloco try {} finally { System.out.println(\"Finally executado\"); }.",
                                    "Adicione prints no try para rastrear a execução: System.out.println(\"Try executado\");.",
                                    "Compile e execute o código base sem exceções.",
                                    "Confirme que tanto try quanto finally são impressos."
                                  ],
                                  "verification": "Verifique os logs de saída no console: deve mostrar 'Try executado' seguido de 'Finally executado'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE (IntelliJ/Eclipse), JDK instalado, editor de código.",
                                  "tips": "Use System.out.println para depuração visual; evite IDEs com auto-complete excessivo inicialmente.",
                                  "learningObjective": "Compreender a estrutura básica do bloco try-finally e prepará-lo para testes.",
                                  "commonMistakes": "Esquecer de importar classes necessárias ou sintaxe incorreta no bloco finally."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar execução normal sem exceções",
                                  "subSteps": [
                                    "Execute o código base sem lançar exceções.",
                                    "Adicione um return simples no final do try: return; após o print.",
                                    "Registre o tempo de execução e observe a ordem dos prints.",
                                    "Repita com break em um loop interno no try.",
                                    "Anote se o finally sempre executa após o try."
                                  ],
                                  "verification": "Console mostra 'Try executado' e 'Finally executado' em todos os casos normais, mesmo com return ou break.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Código base do step 1, console da IDE.",
                                  "tips": "Use breakpoints na IDE para pausar e inspecionar o fluxo.",
                                  "learningObjective": "Confirmar que finally executa incondicionalmente em fluxos normais.",
                                  "commonMistakes": "Confundir return no finally com return no try; return no try ainda permite finally."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar execução com exceções lançadas",
                                  "subSteps": [
                                    "Modifique o try para lançar uma exceção: throw new RuntimeException(\"Teste\");.",
                                    "Execute e verifique se finally roda após a exceção.",
                                    "Adicione um catch vazio ou com print para observar ordem: try > catch > finally.",
                                    "Teste com return no catch e confirme finally.",
                                    "Registre diferenças nos logs."
                                  ],
                                  "verification": "Logs mostram execução do try (até exceção), possivelmente catch, e sempre finally.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código modificado, debugger da IDE.",
                                  "tips": "Não capture exceções no catch inicialmente para isolar o finally.",
                                  "learningObjective": "Validar que exceções não impedem a execução do finally.",
                                  "commonMistakes": "Achar que exceções 'pulam' o finally; elas não pulam."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar cenários especiais e sintetizar resultados",
                                  "subSteps": [
                                    "Combine return no try com exceção posterior (impossível, mas teste variações).",
                                    "Teste break/continue em loops dentro do try com e sem exceção.",
                                    "Crie uma tabela comparativa: cenários vs. execução do finally.",
                                    "Execute todos os testes em sequência e colete evidências.",
                                    "Documente conclusões sobre incondicionalidade."
                                  ],
                                  "verification": "Tabela confirma 100% de execução do finally em todos os 6+ cenários testados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha ou documento para tabela, códigos de testes anteriores.",
                                  "tips": "Automatize testes com JUnit para repetibilidade.",
                                  "learningObjective": "Sintetizar que finally é incondicional, independentemente de return, break ou exceções.",
                                  "commonMistakes": "Ignorar que System.exit() pode pular finally; foque em cenários normais."
                                }
                              ],
                              "practicalExample": "Em Java: public void testeFinally() { try { System.out.println(\"Try\"); return; } finally { System.out.println(\"Finally sempre!\"); } } // Saída: Try Finally sempre! (mesmo com return). Teste com throw new Exception() no try: ainda imprime Finally.",
                              "finalVerifications": [
                                "Finally executa em execução normal sem return/break.",
                                "Finally executa com return ou break no try.",
                                "Finally executa quando exceção é lançada no try.",
                                "Finally executa após catch com return.",
                                "Ordem de execução é consistente: try/catch > finally.",
                                "Nenhum cenário testado pula o finally."
                              ],
                              "assessmentCriteria": [
                                "Código testado cobre todos os cenários (normal, exceção, return, break): 30%.",
                                "Logs e tabela comprovam execução incondicional: 25%.",
                                "Análise escrita identifica padrões corretos: 20%.",
                                "Tempo de execução e depuração eficientes: 15%.",
                                "Documentação clara com prints e conclusões: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Lógica de programação: Entender fluxo de controle e garantias de execução.",
                                "Depuração e testes: Práticas de unit testing e verificação empírica.",
                                "Gestão de recursos: Conceitos de cleanup semelhantes a gerenciamento de memória.",
                                "Matemática discreta: Analogia com 'sempre execute' em algoritmos determinísticos."
                              ],
                              "realWorldApplication": "Em aplicações web/bancárias, o finally garante fechamento de conexões de banco de dados ou arquivos, evitando vazamentos de recursos mesmo em crashes ou retornos precoces, prevenindo downtime e perda de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Hierarquia de Exceções",
                    "description": "Organização em classes base e derivadas para tratamento seletivo de exceções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Classe Base de Exceções",
                        "description": "A classe base é a superclasse fundamental de onde todas as exceções em uma linguagem de programação derivam, permitindo um tratamento genérico de erros e servindo como ponto de partida para a hierarquia.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Identificar a classe base de exceções",
                            "description": "Reconhecer e nomear a classe base específica em linguagens como std::exception em C++ ou Exception em Python, explicando seu papel como ancestral comum de todas as exceções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Hierarquia de Exceções e Classe Base",
                                  "subSteps": [
                                    "Leia a definição de hierarquia de exceções em documentações oficiais.",
                                    "Identifique que uma classe base é o ancestral comum de todas as exceções personalizadas.",
                                    "Estude diagramas de herança para visualizar a estrutura árvore.",
                                    "Anote exemplos de exceções derivadas da classe base.",
                                    "Compare hierarquias em linguagens diferentes para padrões comuns."
                                  ],
                                  "verification": "Explique em 2-3 frases o que é uma classe base de exceções e dê um exemplo de exceção derivada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Python (docs.python.org), Documentação C++ (cppreference.com), Editor de texto para anotações"
                                  ],
                                  "tips": "Use diagramas visuais para mapear a herança; foque na raiz da árvore.",
                                  "learningObjective": "Compreender o papel fundamental da classe base como ponto de partida para todas as exceções.",
                                  "commonMistakes": [
                                    "Confundir classe base com exceções built-in específicas como ValueError.",
                                    "Ignorar que nem todas as linguagens têm a mesma hierarquia exata."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Classe Base em Python",
                                  "subSteps": [
                                    "Acesse a seção 'Built-in Exceptions' na documentação Python.",
                                    "Localize o diagrama de hierarquia de exceções.",
                                    "Confirme que 'Exception' é a classe base para a maioria das exceções.",
                                    "Teste em um interpretador Python: herança(isinstance(ValueError(), Exception)).",
                                    "Liste 3 exceções derivadas de Exception."
                                  ],
                                  "verification": "Execute um código simples que demonstre isinstance(alguma_excecao, Exception) retornando True.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Interpretador Python ou IDE como PyCharm/VS Code",
                                    "Documentação Python oficial"
                                  ],
                                  "tips": "BaseException é o topo absoluto, mas Exception é a base prática para exceções definidas pelo usuário.",
                                  "learningObjective": "Reconhecer 'Exception' como classe base em Python e verificar sua herança.",
                                  "commonMistakes": [
                                    "Confundir Exception com BaseException.",
                                    "Não testar com código real."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a Classe Base em C++",
                                  "subSteps": [
                                    "Consulte a referência std::exception em cppreference.com.",
                                    "Analise a hierarquia: std::exception é a base para exceções da biblioteca padrão.",
                                    "Compile e execute um código que lança std::runtime_error e captura com std::exception.",
                                    "Verifique exceções derivadas como std::logic_error e std::runtime_error.",
                                    "Note que exceções personalizadas devem herdar de std::exception."
                                  ],
                                  "verification": "Escreva e compile um programa C++ que capture uma exceção derivada usando referência à std::exception.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C++ (g++), IDE como CLion ou VS Code com C++ extension",
                                    "cppreference.com"
                                  ],
                                  "tips": "Use try-catch com referência: catch(const std::exception& e) para polimorfismo.",
                                  "learningObjective": "Identificar 'std::exception' como classe base em C++ e demonstrar captura genérica.",
                                  "commonMistakes": [
                                    "Esquecer o namespace std::.",
                                    "Capturar por valor em vez de referência, perdendo polimorfismo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o Papel e Aplicar em Código Prático",
                                  "subSteps": [
                                    "Descreva o papel: permite captura genérica de qualquer exceção derivada.",
                                    "Crie um handler genérico que loga e re-lança exceções usando a classe base.",
                                    "Teste com exceções específicas e verifique captura pela base.",
                                    "Discuta vantagens: código mais robusto e manutenção fácil.",
                                    "Refatore um código existente para usar catch da classe base."
                                  ],
                                  "verification": "Implemente um bloco try-catch que capture múltiplas exceções via classe base e liste-as corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com Python e C++",
                                    "Exemplos de código de teste"
                                  ],
                                  "tips": "Sempre use 'catch(...)' apenas como último recurso após catches específicos.",
                                  "learningObjective": "Explicar e demonstrar o papel da classe base como ancestral comum para tratamento unificado.",
                                  "commonMistakes": [
                                    "Usar classe base como primeira opção, mascarando erros específicos.",
                                    "Não chamar e.what() para detalhes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: try:\n    1/0\nexcept Exception as e:\n    print(f'Erro capturado pela base: {type(e).__name__} - {e}')\nEm C++: try {\n    throw std::runtime_error(\"Divisão por zero\");\n} catch (const std::exception& e) {\n    std::cout << \"Erro base: \" << e.what() << std::endl;\n}",
                              "finalVerifications": [
                                "Nomeie corretamente std::exception (C++) e Exception (Python).",
                                "Desenhe ou descreva a hierarquia básica com 3 níveis.",
                                "Execute código que captura exceções derivadas via base.",
                                "Explique em voz alta o papel como ancestral comum.",
                                "Identifique quando usar catch genérico vs. específico.",
                                "Compare hierarquias entre Python e C++."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação das classes base (100% correto).",
                                "Compreensão demonstrada via explicação do papel de herança.",
                                "Códigos funcionais sem erros de compilação/execução.",
                                "Uso correto de verificações como isinstance() ou dynamic_cast.",
                                "Análise de vantagens e limitações do catch genérico.",
                                "Criatividade em exemplos personalizados."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: Conceitos de herança e polimorfismo.",
                                "Design de Software: Padrões de hierarquia para extensibilidade.",
                                "Debugging e Testes: Tratamento robusto de erros inesperados.",
                                "Arquitetura de Sistemas: Logging e recuperação de falhas."
                              ],
                              "realWorldApplication": "Em frameworks como Django (Python) ou bibliotecas STL (C++), handlers genéricos de exceções base capturam erros inesperados, logam detalhes e garantem estabilidade da aplicação em produção, evitando crashes totais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Explicar o propósito da classe base",
                            "description": "Descrever como a classe base permite capturar qualquer exceção de forma genérica em um bloco try-catch, fornecendo métodos comuns como getMessage() para obter detalhes do erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a hierarquia fundamental de exceções em Java",
                                  "subSteps": [
                                    "Revise a documentação oficial da Oracle sobre Throwable e Exception.",
                                    "Desenhe um diagrama simples da hierarquia: Throwable → Error e Exception.",
                                    "Identifique que Exception é subclasse de Throwable, servindo como classe base para exceções tratáveis.",
                                    "Note que RuntimeException é uma subclasse de Exception para exceções unchecked.",
                                    "Compare com classes específicas como IOException ou NullPointerException."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama da hierarquia com Throwable no topo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Java SE (Throwable e Exception), papel e caneta ou ferramenta de diagrama como draw.io",
                                  "tips": "Use setas para mostrar herança (extends) para visualizar melhor a estrutura.",
                                  "learningObjective": "Compreender a posição da classe base na hierarquia de exceções.",
                                  "commonMistakes": "Confundir Throwable com Exception; lembrar que Throwable inclui Errors também."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o propósito da classe base Throwable/Exception para captura genérica",
                                  "subSteps": [
                                    "Escreva um código simples com try-catch usando Exception como tipo genérico.",
                                    "Teste capturando exceções específicas e observe que todas são pegas pela classe base.",
                                    "Explique verbalmente ou por escrito por que usar a classe base permite tratar qualquer exceção sem especificar tipos.",
                                    "Discuta cenários onde captura genérica é útil, como em blocos de fallback.",
                                    "Analise o código fonte de Throwable na JDK para ver métodos herdados."
                                  ],
                                  "verification": "Execute código que lança diferentes exceções e confirme que catch(Exception e) as captura todas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE Java (Eclipse/IntelliJ), JDK instalada",
                                  "tips": "Comece com exceções checked e unchecked para ver a abrangência.",
                                  "learningObjective": "Reconhecer como a classe base habilita tratamento unificado de exceções.",
                                  "commonMistakes": "Usar catch(Object) incorretamente; stick to Throwable ou Exception."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar métodos comuns fornecidos pela classe base",
                                  "subSteps": [
                                    "Liste métodos chave: getMessage(), getLocalizedMessage(), toString(), printStackTrace().",
                                    "Implemente um catch block que use getMessage() para logar detalhes do erro.",
                                    "Teste com exceções reais (ex: divisão por zero, NullPointerException) e imprima mensagens.",
                                    "Compare saídas de getMessage() vs printStackTrace() para entender diferenças.",
                                    "Pratique sobrescrevendo getMessage() em uma exceção customizada."
                                  ],
                                  "verification": "Crie e execute código que captura exceções e exibe getMessage() corretamente para 3 tipos diferentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE Java, console para output",
                                  "tips": "Sempre logue stack trace em produção para debugging completo.",
                                  "learningObjective": "Dominar métodos essenciais para extrair informações de exceções genéricas.",
                                  "commonMistakes": "Ignorar null checks em getMessage(); pode retornar null."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e sintetizar o conhecimento sobre a classe base",
                                  "subSteps": [
                                    "Refatore um código existente com múltiplos catch blocks para um único catch genérico com instanceof checks.",
                                    "Discuta prós e contras: flexibilidade vs especificidade.",
                                    "Crie um handler de exceções genérico reutilizável em uma classe utilitária.",
                                    "Teste o handler com cenários variados e verifique logs.",
                                    "Escreva um resumo de 100 palavras explicando o propósito da classe base."
                                  ],
                                  "verification": "O handler genérico trata corretamente 4+ tipos de exceções com logs apropriados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE Java, código de exemplo com exceções",
                                  "tips": "Evite captura genérica excessiva; use para último recurso.",
                                  "learningObjective": "Integrar o conceito em práticas de tratamento de exceções robustas.",
                                  "commonMistakes": "Perder especificidade ao generalizar demais sem checks."
                                }
                              ],
                              "practicalExample": "Em um aplicativo de banco: try { transferencia(); } catch (Exception e) { logger.error('Erro na transferência: ' + e.getMessage()); // Captura IOException, SQLException, etc., de forma genérica }",
                              "finalVerifications": [
                                "Explica corretamente que Throwable/Exception é superclasse para captura ampla.",
                                "Demonstra código com catch(Exception) pegando múltiplas exceções.",
                                "Usa getMessage() e printStackTrace() adequadamente em exemplos.",
                                "Desenha hierarquia precisa sem erros.",
                                "Discute quando usar captura genérica vs específica.",
                                "Refatora código para handler genérico funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do propósito da classe base (captura genérica e métodos comuns).",
                                "Profundidade nos steps: subSteps completos e verificações executadas.",
                                "Código prático compila e roda sem erros, demonstrando conceitos.",
                                "Diagrama de hierarquia claro e correto.",
                                "Resumo escrito captura essência sem omissões chave.",
                                "Identifica erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos (herança e polimorfismo).",
                                "Debugging e Logging (análise de stack traces).",
                                "Design de Software (princípios de robustez e exception handling).",
                                "Lógica e Estruturas de Controle (try-catch como fluxo condicional)."
                              ],
                              "realWorldApplication": "Em sistemas empresariais como e-commerces ou apps financeiros, um catch genérico com Throwable captura falhas inesperadas (ex: rede, DB), loga detalhes via getMessage()/stackTrace para suporte, evitando crashes e permitindo recuperação graciosa."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Criar uma exceção personalizada derivada da base",
                            "description": "Definir uma nova classe de exceção que herda da classe base, adicionando atributos específicos e sobrescrevendo métodos para personalização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a classe base de exceções e planejar a herança",
                                  "subSteps": [
                                    "Estude a documentação oficial da classe Exception e suas subclasses comuns (ex: ValueError, TypeError).",
                                    "Identifique o tipo de erro da sua exceção personalizada e escolha a classe base apropriada (ex: ValueError para valores inválidos).",
                                    "Defina os atributos extras necessários (ex: código de erro, valor inválido) e esboce um diagrama de herança simples.",
                                    "Liste os métodos que serão sobrescritos, como __init__ e __str__.",
                                    "Verifique exemplos built-in para inspiração."
                                  ],
                                  "verification": "Explique por escrito ou verbalmente a classe base escolhida e justifique os atributos planejados.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Documentação Python: https://docs.python.org/pt-br/3/library/exceptions.html",
                                    "Editor de texto ou papel para diagrama"
                                  ],
                                  "tips": "Prefira subclasses específicas como ValueError em vez de Exception genérica para semântica correta.",
                                  "learningObjective": "Entender a hierarquia de exceções e planejar uma extensão personalizada.",
                                  "commonMistakes": [
                                    "Herdar diretamente de BaseException em vez de Exception.",
                                    "Ignorar o contexto semântico da classe base."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e implementar o construtor da exceção personalizada",
                                  "subSteps": [
                                    "Crie a classe: class MinhaExcecao(BaseExcecao):",
                                    "Implemente __init__(self, message, *args extras): super().__init__(message)",
                                    "Inicialize atributos personalizados: self.codigo_erro = codigo_erro",
                                    "Passe argumentos extras para super().__init__ se necessário.",
                                    "Adicione docstring explicando o uso."
                                  ],
                                  "verification": "Instancie a exceção e verifique se não há erros de sintaxe e atributos são setados corretamente via print.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Editor de código (VSCode, PyCharm ou IDLE)",
                                    "Interpretador Python ativo"
                                  ],
                                  "tips": "Sempre chame super().__init__() para preservar comportamento da base.",
                                  "learningObjective": "Implementar inicialização segura com herança.",
                                  "commonMistakes": [
                                    "Esquecer super().__init__(), causando perda de mensagem padrão.",
                                    "Não tratar argumentos variáveis corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Personalizar métodos e adicionar comportamentos extras",
                                  "subSteps": [
                                    "Sobrescreva __str__(self): return f'{super().__str__()} - Detalhes: {self.atributo}'",
                                    "Opcionalmente, adicione __repr__() para depuração.",
                                    "Implemente método customizado como get_details() para retornar info extras.",
                                    "Adicione validações internas no __init__ (ex: if self.codigo < 0: raise ValueError).",
                                    "Teste instanciação e print da exceção."
                                  ],
                                  "verification": "Execute print(exc) e verifique saída customizada; chame métodos extras sem erros.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Terminal Python para testes interativos"
                                  ],
                                  "tips": "Mantenha __str__ conciso e informativo para logs.",
                                  "learningObjective": "Estender funcionalidade da exceção via sobrescrita de métodos.",
                                  "commonMistakes": [
                                    "Não chamar super().__str__(), perdendo mensagem original.",
                                    "Tornar métodos muito complexos desnecessariamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a exceção em contexto real",
                                  "subSteps": [
                                    "Crie um script de teste: função que levanta a exceção sob condição inválida.",
                                    "Use try-except para capturar: except MinhaExcecao as e: print(e.atributo)",
                                    "Verifique herança: assert isinstance(e, BaseExcecao)",
                                    "Execute testes com casos válidos e inválidos.",
                                    "Adicione asserts para atributos e mensagens."
                                  ],
                                  "verification": "Todos os testes passam: exceção é levantada, capturada, herança confirmada e atributos acessíveis.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Script Python de teste",
                                    "Biblioteca unittest (opcional)"
                                  ],
                                  "tips": "Use pytest ou unittest para automação futura.",
                                  "learningObjective": "Validar integração e robustez da exceção personalizada.",
                                  "commonMistakes": [
                                    "Não testar herança com isinstance().",
                                    "Esquecer casos edge (ex: atributos None)."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie InvalidAgeError derivada de ValueError:\n\nclass InvalidAgeError(ValueError):\n    def __init__(self, age, message='Idade inválida'):\n        super().__init__(message)\n        self.age = age\n    def __str__(self):\n        return f'{super().__str__()} (idade fornecida: {self.age})'\n\n# Teste:\ntry:\n    if age < 0:\n        raise InvalidAgeError(age)\nexcept InvalidAgeError as e:\n    print(e)\n    print(f'Idade inválida: {e.age}')\n\nSaída: 'Idade inválida (idade fornecida: -5)'",
                              "finalVerifications": [
                                "A classe herda corretamente da base (isinstance confirma).",
                                "Construtor inicializa mensagem e atributos extras sem erros.",
                                "Métodos sobrescritos (__str__, etc.) produzem saída personalizada.",
                                "Exceção é levantada, capturada e atributos são acessíveis.",
                                "Não há erros de sintaxe ou runtime na instanciação.",
                                "Testes cobrem casos válidos e inválidos."
                              ],
                              "assessmentCriteria": [
                                "Herança e super().__init__() implementados corretamente (peso alto).",
                                "Atributos personalizados acessíveis e úteis.",
                                "Personalização de métodos funcional e sem bugs.",
                                "Testes abrangentes com verificação de herança.",
                                "Código limpo, documentado e sem warnings.",
                                "Eficiência: passos lógicos e sem complexidade desnecessária."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: conceitos de herança e polimorfismo.",
                                "Engenharia de Software: design de APIs extensíveis e tratamento de erros.",
                                "Testes de Software: unit testing e TDD.",
                                "Lógica e Estruturas de Dados: modelagem de erros como objetos."
                              ],
                              "realWorldApplication": "Em sistemas de validação de formulários web (ex: Django/Flask), lançar InvalidUserInputError com detalhes do campo inválido facilita logging preciso, debugging e respostas amigáveis ao usuário, melhorando robustez e manutenibilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Classes Derivadas de Exceções",
                        "description": "Classes especializadas que herdam da classe base, representando tipos específicos de erros como divisão por zero ou falha de entrada/saída, permitindo tratamentos mais precisos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Listar exemplos de classes derivadas comuns",
                            "description": "Identificar e exemplificar classes derivadas como ArithmeticException, IOException ou std::runtime_error em C++, relacionando-as a cenários de erro reais em programas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Hierarquia Base de Exceções",
                                  "subSteps": [
                                    "Estude a classe base Exception em Java (herda de Throwable) e exception em C++.",
                                    "Identifique subclasses principais: RuntimeException (unchecked) e Exception (checked) em Java; logic_error e runtime_error em C++.",
                                    "Desenhe um diagrama simples da hierarquia usando papel ou ferramenta digital.",
                                    "Anote diferenças entre linguagens: Java tem checked/unchecked, C++ é mais genérica.",
                                    "Consulte documentação oficial para confirmação."
                                  ],
                                  "verification": "Diagrama completo da hierarquia base com pelo menos 4 classes principais listadas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação Java (docs.oracle.com), C++ Reference (cppreference.com), papel/caneta ou Draw.io",
                                  "tips": "Comece pela Throwable/Exception base para contextualizar derivadas.",
                                  "learningObjective": "Compreender a estrutura hierárquica fundamental de exceções em Java e C++.",
                                  "commonMistakes": "Confundir RuntimeException com Exception checked; ignorar std::exception como base em C++."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Classes Derivadas Comuns em Java",
                                  "subSteps": [
                                    "Liste ArithmeticException (divisão por zero), NullPointerException, IOException (erros I/O).",
                                    "Pesquise em docs.oracle.com exemplos de uso para cada uma.",
                                    "Classifique como checked ou unchecked (ex: IOException é checked).",
                                    "Escreva um snippet de código simples que possa lançar cada exceção.",
                                    "Teste os snippets em uma IDE para observar o comportamento."
                                  ],
                                  "verification": "Lista de pelo menos 5 classes derivadas Java com classificação e snippet de código funcional.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE como IntelliJ/Eclipse, docs.oracle.com/javase/8/docs/api/",
                                  "tips": "Use try-catch para capturar e imprimir stack trace ao testar.",
                                  "learningObjective": "Memorizar e exemplificar 5+ classes derivadas comuns em Java.",
                                  "commonMistakes": "Esquecer de importar java.io para IOException; confundir com erros de compilação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Classes Derivadas em C++",
                                  "subSteps": [
                                    "Liste std::runtime_error, std::logic_error, std::out_of_range, std::invalid_argument.",
                                    "Consulte cppreference.com para hierarquia e construtores.",
                                    "Escreva exemplos de throw new std::runtime_error('Mensagem');",
                                    "Integre em um programa simples com try-catch.",
                                    "Compile e execute para verificar lançamento."
                                  ],
                                  "verification": "Lista de 4+ classes C++ com código compilável que lança exceções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador GCC/Clang, cppreference.com, IDE como Visual Studio Code",
                                  "tips": "Use std::string para mensagens em construtores para melhor legibilidade.",
                                  "learningObjective": "Dominar classes derivadas padrão em C++ e seu uso prático.",
                                  "commonMistakes": "Esquecer #include <stdexcept>; não usar 'throw' corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Classes a Cenários Reais de Erro",
                                  "subSteps": [
                                    "Para cada classe listada, descreva um cenário: ArithmeticException em calculadora financeira.",
                                    "IOException em leitura de arquivo de config de app.",
                                    "std::out_of_range em acesso a vetor em jogo.",
                                    "Crie uma tabela: Classe | Cenário | Prevenção.",
                                    "Discuta com um colega ou anote como catch específico melhora código."
                                  ],
                                  "verification": "Tabela completa com 8+ cenários reais mapeados a classes específicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha Google Sheets ou papel, exemplos de código dos steps anteriores",
                                  "tips": "Pense em apps reais como banco ou rede social para cenários autênticos.",
                                  "learningObjective": "Conectar classes abstratas a problemas concretos de programação.",
                                  "commonMistakes": "Cenários genéricos demais; não ligar à prevenção via validação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Consolidar Lista Pessoal e Praticar Recuperação",
                                  "subSteps": [
                                    "Compile uma lista unificada de 10 classes derivadas (5 Java + 5 C++).",
                                    "Crie flashcards com classe no frente e cenário/derivada no verso.",
                                    "Teste-se recitando sem olhar; repita até 90% acerto.",
                                    "Escreva um quiz autoavaliativo com 10 perguntas.",
                                    "Revise erros e atualize lista."
                                  ],
                                  "verification": "Lista final de 10 classes com 90% acerto em auto-teste.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "App Anki para flashcards, documento de texto",
                                  "tips": "Use mnemônicos: 'Aritmética Nula IO' para lembrar Java basics.",
                                  "learningObjective": "Fixar conhecimento para recall imediato em cenários de codificação.",
                                  "commonMistakes": "Listas curtas; não praticar recall ativo."
                                }
                              ],
                              "practicalExample": "Em um app de calculadora Java: int result = 10 / 0; lança ArithmeticException (derivada de RuntimeException). Catch específico: catch(ArithmeticException e) { System.out.println('Divisão por zero!'); } relaciona a erro real em finanças.",
                              "finalVerifications": [
                                "Pode listar 8+ classes derivadas comuns sem hesitação?",
                                "Explica hierarquia e cenários para 5 classes em Java e 5 em C++?",
                                "Código de teste lança exceções corretas?",
                                "Tabela de cenários reais está completa?",
                                "Auto-quiz com 90% acerto?",
                                "Identifica diferenças entre Java checked/unchecked e C++?"
                              ],
                              "assessmentCriteria": [
                                "Precisão da lista de classes (80% peso): Todas corretas e derivadas?",
                                "Profundidade de cenários (15%): Reais e preventivos?",
                                "Qualidade de códigos/exemplos (5%): Compiláveis e testados?",
                                "Completude da tabela/flashcards: Cobertura mínima?",
                                "Recall em quiz: ≥90% correto?",
                                "Clareza de explicações: Linguagem técnica precisa?"
                              ],
                              "crossCurricularConnections": [
                                "Debugging e Testing: Usar exceções em unit tests.",
                                "Design de Software: Hierarquia para exceções customizadas.",
                                "Lógica e Matemática: Erros como divisão por zero em algoritmos.",
                                "Sistemas Operacionais: I/O exceptions em gerenciamento de arquivos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise, como apps bancários (ArithmeticException previne perdas financeiras) ou servidores web (IOException gerencia falhas de rede), permitindo robustez e logs para manutenção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Compreender a herança entre classes de exceções",
                            "description": "Explicar como classes derivadas herdam propriedades e métodos da classe base, formando uma árvore de herança que permite polimorfismo no tratamento de exceções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Explorar a Hierarquia Padrão de Exceções",
                                  "subSteps": [
                                    "Identifique a classe base Throwable e suas subclasses principais: Error e Exception.",
                                    "Estude as subcategorias de Exception: checked exceptions (ex: IOException) e unchecked (RuntimeException).",
                                    "Liste exemplos de exceções comuns como NullPointerException, ArithmeticException e suas posições na árvore.",
                                    "Desenhe um diagrama simples da hierarquia usando ferramentas como Draw.io ou papel.",
                                    "Compare herança com hierarquia de classes normais em OOP."
                                  ],
                                  "verification": "Crie um diagrama da hierarquia com pelo menos 10 classes e explique verbalmente para um colega.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (ex: JavaDoc para Throwable)",
                                    "IDE com autocompletar",
                                    "Ferramenta de diagramação (Draw.io)"
                                  ],
                                  "tips": "Comece pela classe Throwable e desça recursivamente para evitar sobrecarga de informação.",
                                  "learningObjective": "Compreender a estrutura hierárquica padrão de exceções e sua relação com Throwable.",
                                  "commonMistakes": [
                                    "Confundir Error com Exception",
                                    "Ignorar a distinção entre checked e unchecked exceptions"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Herança em Classes de Exceções Personalizadas",
                                  "subSteps": [
                                    "Crie uma classe de exceção customizada que herde diretamente de Exception.",
                                    "Adicione construtores que chamem o super() da classe base.",
                                    "Crie uma subclasse da sua exceção customizada, demonstrando herança múltipla níveis.",
                                    "Teste a instanciação e lançamento dessas exceções em código simples.",
                                    "Verifique como propriedades e métodos da base (como getMessage()) são herdados."
                                  ],
                                  "verification": "Escreva e execute código que lance e capture uma exceção customizada de dois níveis de herança.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE (Eclipse, IntelliJ ou VS Code)",
                                    "Compilador Java/Python equivalente"
                                  ],
                                  "tips": "Sempre inclua mensagens descritivas nos construtores para facilitar depuração.",
                                  "learningObjective": "Dominar a criação de exceções personalizadas com herança, herdando comportamentos da base.",
                                  "commonMistakes": [
                                    "Esquecer de chamar super() no construtor",
                                    "Não declarar a classe como public ou extends Exception"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender Polimorfismo no Tratamento de Exceções",
                                  "subSteps": [
                                    "Escreva um bloco try-catch que capture uma exceção genérica (Exception) e veja como pega derivadas.",
                                    "Adicione catches específicos para subclasses e observe a ordem de execução (mais específica primeiro).",
                                    "Teste cenários onde uma exceção derivada é lançada e capturada pelo catch da base.",
                                    "Explique por que o polimorfismo permite tratamento unificado de famílias de exceções.",
                                    "Refatore código para usar catch polimórfico otimizando blocos repetitivos."
                                  ],
                                  "verification": "Modifique código existente para usar polimorfismo em catches e demonstre com prints ou logs.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Exemplos de código de repositórios GitHub sobre exceções"
                                  ],
                                  "tips": "Use o debugger para pausar no lançamento e ver o tipo real da exceção no catch.",
                                  "learningObjective": "Aplicar polimorfismo para tratamento eficiente de exceções hierárquicas.",
                                  "commonMistakes": [
                                    "Colocar catch genérico antes de específicos",
                                    "Não entender que catch(Exception) pega tudo abaixo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Sintetizar a Árvore de Herança Completa",
                                  "subSteps": [
                                    "Integre a hierarquia padrão com exceções customizadas em um diagrama unificado.",
                                    "Simule cenários de lançamento mistos (padrão + custom) e trace o caminho de herança.",
                                    "Discuta vantagens da herança: reutilização de código e tratamento seletivo.",
                                    "Crie um método utilitário que use instanceof para verificações finas na hierarquia.",
                                    "Documente insights em um resumo de 1 página."
                                  ],
                                  "verification": "Apresente o diagrama completo e responda perguntas sobre fluxos de herança.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Lucidchart ou papel)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use setas para indicar 'extends' e cores para diferenciar checked/unchecked.",
                                  "learningObjective": "Sintetizar conhecimentos em uma visão holística da árvore de herança de exceções.",
                                  "commonMistakes": [
                                    "Ignorar herança múltipla ou conflitos de nomes",
                                    "Confundir herança com composição"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema bancário Java, crie InvalidAccountException extends AccountException extends Exception. Lance InvalidAccountException em um método de saque inválido. Use try-catch(AccountException e) para tratar toda família polimorficamente, logando 'Erro na conta: ' + e.getMessage(), demonstrando herança e polimorfismo.",
                              "finalVerifications": [
                                "Desenhar corretamente a árvore de herança com Throwable no topo.",
                                "Explicar polimorfismo em catches com exemplo de código.",
                                "Criar e testar exceção customizada de 2 níveis.",
                                "Identificar 5 exceções unchecked e suas bases.",
                                "Discutir por que herança facilita manutenção de código.",
                                "Usar instanceof corretamente em verificações hierárquicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da hierarquia (sem erros factuais).",
                                "Completude dos diagramas e códigos funcionais.",
                                "Demonstração clara de polimorfismo com testes.",
                                "Profundidade nas explicações de herança e vantagens.",
                                "Identificação correta de erros comuns e soluções.",
                                "Criatividade em exemplos customizados relevantes."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos (herança e polimorfismo geral).",
                                "Design de Software (padrões para tratamento de erros).",
                                "Engenharia de Software (boas práticas em exceções).",
                                "Lógica e Estruturas de Dados (árvores hierárquicas).",
                                "Depuração e Testes (análise de stack traces)."
                              ],
                              "realWorldApplication": "Em aplicações empresariais como e-commerces, herança de exceções permite tratar erros de pagamento (PaymentException > CreditCardException) de forma unificada no serviço de checkout, reduzindo código duplicado e facilitando logging centralizado em microsserviços."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Diferenciar exceções verificadas e não verificadas",
                            "description": "Distinguir entre exceções derivadas que devem ser tratadas obrigatoriamente (verificadas) e as opcionais (não verificadas), com exemplos de cada na hierarquia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Definições Básicas de Exceções Verificadas e Não Verificadas",
                                  "subSteps": [
                                    "Ler definição de exceções verificadas (checked): herdam diretamente de Exception (exceto RuntimeException), compilador exige tratamento via try-catch ou declaração throws.",
                                    "Ler definição de exceções não verificadas (unchecked): herdam de RuntimeException ou Error, tratamento é opcional pelo compilador.",
                                    "Criar uma tabela comparativa com colunas: Tipo, Herança, Obrigatório?, Exemplo.",
                                    "Explicar verbalmente ou por escrito a diferença principal."
                                  ],
                                  "verification": "Resumir as definições em 2-3 frases próprias e confirmar com uma fonte confiável como documentação Java.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Java: https://docs.oracle.com/javase/tutorial/essential/exceptions/",
                                    "Diagrama de hierarquia Throwable",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Foquem na distinção pelo compilador: checked força ação, unchecked permite preguiça (mas não é recomendável).",
                                  "learningObjective": "Definir precisamente exceções verificadas e não verificadas e suas implicações no compilador.",
                                  "commonMistakes": [
                                    "Confundir unchecked com 'sem tratamento necessário' - ainda precisam ser gerenciadas em runtime.",
                                    "Achar que todas as Exceptions são checked - RuntimeException é exceção."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Hierarquia de Classes na Documentação",
                                  "subSteps": [
                                    "Visualizar hierarquia: Throwable > Error (unchecked) e Exception > RuntimeException (unchecked) vs outras subclasses de Exception (checked).",
                                    "Identificar posição exata: checked derivam de Exception mas não de RuntimeException.",
                                    "Listar 3 classes pai/derivadas para cada tipo usando javadoc ou IDE.",
                                    "Desenhar um diagrama simples da árvore relevante."
                                  ],
                                  "verification": "Produzir um diagrama hierárquico rotulado corretamente com pelo menos 6 classes exemplares.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Javadoc Java SE: Throwable, Exception, RuntimeException",
                                    "Ferramenta de diagrama como draw.io ou papel/caneta",
                                    "IDE como IntelliJ ou Eclipse para navegar hierarquia"
                                  ],
                                  "tips": "Use Ctrl+B (ou F4 no Eclipse) na IDE para 'go to superclass' e explorar visualmente.",
                                  "learningObjective": "Mapear a hierarquia de exceções e identificar ramos checked vs unchecked.",
                                  "commonMistakes": [
                                    "Esquecer que Error é unchecked e não Exception.",
                                    "Colocar RuntimeException como checked."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Concretos de Cada Tipo",
                                  "subSteps": [
                                    "Listar e codificar exemplos checked: IOException, SQLException, FileNotFoundException.",
                                    "Listar e codificar exemplos unchecked: NullPointerException, ArithmeticException, IndexOutOfBoundsException.",
                                    "Compilar código simples lançando cada tipo sem tratamento e observar erros.",
                                    "Adicionar throws/try-catch e recompilar para contraste."
                                  ],
                                  "verification": "Classificar corretamente 8 exceções comuns (4 de cada tipo) e prever comportamento de compilação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código/IDE com Java",
                                    "Lista de exceções comuns da documentação Java",
                                    "Terminal para javac"
                                  ],
                                  "tips": "Teste sempre compilando: checked falha sem throws/try, unchecked compila.",
                                  "learningObjective": "Reconhecer e exemplificar exceções checked e unchecked na prática.",
                                  "commonMistakes": [
                                    "Classificar IllegalArgumentException como checked (é unchecked).",
                                    "Ignorar que subclasses herdam o comportamento do pai."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação em Cenários Reais",
                                  "subSteps": [
                                    "Escrever um método que lê arquivo (checked: FileNotFoundException) sem tratamento -> corrigir.",
                                    "Escrever método que acessa array inválido (unchecked: ArrayIndexOutOfBounds) -> opcionalmente tratar.",
                                    "Analisar código de terceiros: identificar tipos e sugerir melhorias.",
                                    "Documentar quando usar cada tipo em design de API."
                                  ],
                                  "verification": "Criar e testar 2 snippets de código (1 checked, 1 unchecked) com tratamento apropriado e relatório de resultados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "IDE Java com JDK",
                                    "Arquivos de teste para I/O",
                                    "Exemplos de código open-source"
                                  ],
                                  "tips": "Checked para erros esperados/recuperáveis; unchecked para violações de contrato.",
                                  "learningObjective": "Aplicar distinção em código funcional e decidir tratamentos.",
                                  "commonMistakes": [
                                    "Tratar unchecked como checked desnecessariamente verbose.",
                                    "Ignorar checked achando 'runtime resolve'."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um método readUserFile(String path) que abre um arquivo: lança FileNotFoundException (checked) - compilador exige try-catch ou throws. Compare com divideByZero(int x) que lança ArithmeticException (unchecked) - compila sem tratamento, mas app crasha em runtime se não gerenciado.",
                              "finalVerifications": [
                                "Explicar em 1 frase a diferença entre checked e unchecked.",
                                "Classificar corretamente: IOException, NullPointerException, SQLException, OutOfMemoryError.",
                                "Prever se 'public void metodo() { throw new IOException(); }' compila sem throws.",
                                "Desenhar hierarquia básica sem erros.",
                                "Identificar em código fornecido 2 checked e 2 unchecked.",
                                "Justificar uso de checked vs unchecked em um cenário I/O."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e hierarquia 100% corretas.",
                                "Classificação de exemplos: acerto em pelo menos 90% das exceções testadas.",
                                "Compreensão prática: códigos compilam e comportamentos explicados corretamente.",
                                "Diagrama hierárquico: claro, completo e rotulado.",
                                "Aplicação: escolhas justificadas de tratamento em cenários.",
                                "Relatório: cobre verificações sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Estruturas de Dados: análise hierárquica de classes como árvores.",
                                "Design de Software: impacto em APIs e contratos de métodos (throws clauses).",
                                "Debugging e Testes: priorizar unchecked para bugs, checked para edge cases.",
                                "Matemática Discreta: herança como relações de subconjuntos.",
                                "Ética em Computação: exceções unchecked evitam 'esconder' erros do programador."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software enterprise, use checked exceptions para falhas recuperáveis como falha de conexão DB (SQLException), forçando devs a tratar; unchecked para estados inválidos como argumentos nulos (IllegalArgumentException), permitindo foco em lógica principal sem boilerplate excessivo."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Tratamento Seletivo Usando a Hierarquia",
                        "description": "Mecanismo que explora a hierarquia de herança para capturar exceções específicas em blocos catch antes das genéricas, otimizando o fluxo de controle em programas com tratamento de exceções.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Implementar blocos catch seletivos",
                            "description": "Estruturar um bloco try-catch onde catches para classes derivadas específicas precedem o catch genérico da classe base, garantindo tratamento priorizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a hierarquia de exceções relevantes",
                                  "subSteps": [
                                    "Identifique a classe base de exceções (ex: Exception em Java ou C#).",
                                    "Pesquise subclasses específicas que serão tratadas (ex: IOException e FileNotFoundException).",
                                    "Desenhe um diagrama da hierarquia mostrando a ordem de herança.",
                                    "Verifique na documentação oficial exemplos de lançamento dessas exceções.",
                                    "Anote cenários onde cada exceção ocorre."
                                  ],
                                  "verification": "Diagrama da hierarquia criado e anotado corretamente, com pelo menos 3 exceções mapeadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação da linguagem (Java API, MSDN para C#), editor de diagramas (Draw.io ou papel).",
                                  "tips": "Sempre comece pela superclasse mais genérica e desça para as específicas.",
                                  "learningObjective": "Mapear precisamente a hierarquia de exceções para ordenação correta dos catches.",
                                  "commonMistakes": "Confundir subclasses com classes paralelas na hierarquia."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar o bloco try com código que lança exceções",
                                  "subSteps": [
                                    "Escreva um método ou função principal dentro do bloco try.",
                                    "Inclua código que intencionalmente lance exceções específicas (ex: abrir arquivo inexistente).",
                                    "Adicione prints ou logs para rastrear o fluxo antes das exceções.",
                                    "Compile o código para garantir que não há erros de sintaxe iniciais.",
                                    "Prepare cenários de teste para cada exceção."
                                  ],
                                  "verification": "Código compila e lança exceções esperadas quando executado sem catches.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "IDE (Eclipse, Visual Studio Code), compilador da linguagem.",
                                  "tips": "Use try-catch temporário genérico para testar lançamentos isolados.",
                                  "learningObjective": "Criar código realista que demonstre múltiplas exceções hierárquicas.",
                                  "commonMistakes": "Não simular exceções reais, usando apenas throw manual sem contexto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar catches seletivos na ordem correta",
                                  "subSteps": [
                                    "Adicione o primeiro catch para a subclasse mais específica (ex: catch(FileNotFoundException)).",
                                    "Adicione catches subsequentes para outras subclasses, sempre precedendo a genérica.",
                                    "Por último, adicione o catch genérico para a classe base (ex: catch(Exception)).",
                                    "Implemente ações específicas em cada handler (logs, mensagens customizadas, recuperação).",
                                    "Garanta que nenhum catch seja redundante ou sobreponha outros."
                                  ],
                                  "verification": "Ordem dos catches segue hierarquia (específicos primeiro), código compila sem warnings.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "IDE com suporte a linting, documentação de exceções.",
                                  "tips": "Lembre-se: compilador impede catches fora de ordem; use isso como verificação automática.",
                                  "learningObjective": "Ordenar catches corretamente para tratamento priorizado e seletivo.",
                                  "commonMistakes": "Colocar catch genérico antes dos específicos, causando shadowing."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o comportamento seletivo",
                                  "subSteps": [
                                    "Execute o código com cenários que lancem exceções específicas.",
                                    "Verifique via logs ou debugger qual catch é acionado primeiro.",
                                    "Teste fallback para catch genérico com exceções não cobertas.",
                                    "Refatore handlers se necessário para melhor recuperação.",
                                    "Documente resultados em um relatório de testes."
                                  ],
                                  "verification": "Relatório de testes confirma acionamento correto de catches em todos cenários.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "IDE com debugger, ferramenta de logs (Console ou Log4j).",
                                  "tips": "Use breakpoints no debugger para pausar em cada catch e inspecionar.",
                                  "learningObjective": "Validar empiricamente a seletividade do tratamento de exceções.",
                                  "commonMistakes": "Não testar todos os caminhos, assumindo correção só por compilação."
                                }
                              ],
                              "practicalExample": "Em Java, para ler um arquivo:\ntry {\n    // Código que pode lançar FileNotFoundException (sub de IOException)\n    FileInputStream fis = new FileInputStream(\"arquivo_inexistente.txt\");\n    // Mais código que lança IOException genérica\n} catch (FileNotFoundException e) {\n    System.out.println(\"Arquivo não encontrado: \" + e.getMessage());\n} catch (IOException e) {\n    System.out.println(\"Erro IO genérico: \" + e.getMessage());\n} catch (Exception e) {\n    System.out.println(\"Erro inesperado: \" + e.getMessage());\n}\nResultado: Catch FileNotFoundException precede IOException.",
                              "finalVerifications": [
                                "Catches para subclasses precedem o genérico na ordem exata da hierarquia.",
                                "Cada handler específico é acionado corretamente em testes isolados.",
                                "Catch genérico atua como fallback para exceções não tratadas.",
                                "Nenhum warning de compilador sobre ordem de catches.",
                                "Logs confirmam mensagens customizadas por tipo de exceção.",
                                "Código recupera ou falha graciosamente em todos cenários."
                              ],
                              "assessmentCriteria": [
                                "Hierarquia mapeada com 100% de acurácia (diagrama correto).",
                                "Ordem dos catches segue precedência hierárquica sem erros.",
                                "Handlers implementam ações distintas e apropriadas (não genéricas).",
                                "Testes cobrem todos os catches com evidências (logs/screenshots).",
                                "Código é limpo, comentado e segue boas práticas (ex: finally opcional).",
                                "Tempo total dentro do estimado com qualidade alta."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: Reforça herança e polimorfismo.",
                                "Debugging e Testes: Prática de unit tests para exceções.",
                                "Design de Software: Princípios de robustez e resiliência.",
                                "Lógica e Algoritmos: Fluxo condicional baseado em tipos.",
                                "Segurança da Informação: Tratamento seguro de erros para evitar vazamentos."
                              ],
                              "realWorldApplication": "Em aplicações empresariais como sistemas de banco ou e-commerce, permite tratar erros específicos de rede (ex: TimeoutException antes de genérica), melhorando diagnósticos, logs precisos e experiência do usuário, evitando crashes totais por exceções não priorizadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1",
                              "10.1.4.5.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Aplicar re-throw em hierarquias",
                            "description": "Utilizar re-lançamento de exceções (throw novamente) após tratamento parcial, propagando erros específicos pela hierarquia para tratamento em níveis superiores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Hierarquia de Exceções Customizadas",
                                  "subSteps": [
                                    "Crie uma classe base customizada estendendo Exception (ex: DatabaseException).",
                                    "Crie subclasses específicas (ex: ConnectionException e QueryException estendendo DatabaseException).",
                                    "Adicione construtores que chamem super(message, cause) para preservar causa.",
                                    "Compile as classes para verificar herança.",
                                    "Documente a hierarquia com comentários Javadoc."
                                  ],
                                  "verification": "Classes compilam sem erros e instanceof confirma herança (ex: QueryException instanceof DatabaseException).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE (IntelliJ/Eclipse), JDK 8+, arquivo fonte Java.",
                                  "tips": "Use checked exceptions para forçar tratamento explícito em chamadas.",
                                  "learningObjective": "Construir hierarquia de exceções que reflita o domínio do problema para tratamento seletivo.",
                                  "commonMistakes": "Esquecer de declarar 'throws' nas assinaturas de métodos ou não chamar super no construtor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Lançamento de Exceção Específica em Método Inferior",
                                  "subSteps": [
                                    "Crie um método inferior (ex: executarQuery()) que simule falha e lance QueryException.",
                                    "Use throw new QueryException('Erro na query') em condição de erro (ex: SQL inválido).",
                                    "Adicione lógica condicional para disparar exceção (ex: if invalidInput).",
                                    "Teste compilação com throws QueryException na assinatura.",
                                    "Execute método isoladamente para confirmar lançamento."
                                  ],
                                  "verification": "Método lança QueryException corretamente quando condição de erro é atendida, visível via stack trace.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "IDE, JDK, console para execução.",
                                  "tips": "Inclua mensagem descritiva na exceção para debugging.",
                                  "learningObjective": "Lançar exceções específicas na folha da hierarquia para propagação controlada.",
                                  "commonMistakes": "Lançar Exception genérica em vez de específica, perdendo granularidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Tratamento Parcial com Re-throw em Método Intermediário",
                                  "subSteps": [
                                    "Crie método intermediário (ex: processarDados()) que chame executarQuery().",
                                    "Use try-catch para capturar DatabaseException (superclasse).",
                                    "No catch: realize tratamento parcial (ex: log erro com System.err.println ou logger), então 'throw ex;' para re-lançar.",
                                    "Evite 'throw new Exception(ex)' para preservar stack trace original.",
                                    "Compile e execute para observar log e propagação."
                                  ],
                                  "verification": "Exceção é capturada, log é impresso, e re-lançada para chamador superior (stack trace intacto).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE, JDK, logger simples (java.util.logging opcional).",
                                  "tips": "Sempre use 'throw;' sem new para manter stack trace completo.",
                                  "learningObjective": "Executar ações parciais (logging) antes de propagar exceção para níveis superiores.",
                                  "commonMistakes": "Recriar exceção com 'new', resetando stack trace e perdendo contexto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratar Exceção Propagada em Método Superior e Testar Fluxo Completo",
                                  "subSteps": [
                                    "Crie método superior (ex: main() ou gerenciarOperacao()) que chame processarDados().",
                                    "Use try-catch seletivo para QueryException ou DatabaseException.",
                                    "Implemente tratamento final (ex: exibir mensagem amigável ao usuário, rollback).",
                                    "Execute cenários: sucesso e falha, verificando logs e mensagens.",
                                    "Adicione asserts ou testes unitários com JUnit para automação."
                                  ],
                                  "verification": "Exceção propaga corretamente, tratamento final ocorre sem vazamento, logs presentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "IDE, JUnit (opcional), console.",
                                  "tips": "Teste com diferentes exceções na hierarquia para validar seletividade.",
                                  "learningObjective": "Completar fluxo de hierarquia com tratamento contextual em cada nível.",
                                  "commonMistakes": "Capturar exceções muito amplas (Throwable) em níveis superiores, mascarando erros."
                                }
                              ],
                              "practicalExample": "Em um sistema bancário Java, método validarSaque() lança InsufficientFundsException (sub de AccountException) se saldo insuficiente. Método processarTransacao() captura AccountException, loga 'Tentativa de saque inválido', e re-throw. Método main() captura InsufficientFundsException e exibe 'Saldo insuficiente, transação cancelada' ao usuário, garantindo log central e UX amigável.",
                              "finalVerifications": [
                                "Exceção específica propaga pela hierarquia sem perda de tipo.",
                                "Tratamento parcial (log) executa no nível intermediário.",
                                "Stack trace original é preservado no tratamento final.",
                                "Tratamento seletivo funciona para subclasses diferentes.",
                                "Código compila com throws corretos e sem warnings.",
                                "Execução em cenários de erro não crasha o programa."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de 'throw ex;' sem recriação de exceção.",
                                "Hierarquia de exceções customizadas com herança adequada.",
                                "Tratamento parcial acionável (ex: logging) antes de re-throw.",
                                "Captura seletiva por tipo de exceção em níveis superiores.",
                                "Preservação de stack trace verificada via logs.",
                                "Testes cobrem fluxos de sucesso e falha."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: Herança e polimorfismo em exceções.",
                                "Design de Software: Princípio da Responsabilidade Única em camadas.",
                                "Manutenção de Código: Logging e debugging hierárquico.",
                                "Testes de Software: Asserts para exceções em JUnit.",
                                "Arquitetura de Sistemas: Propagação de erros em microsserviços."
                              ],
                              "realWorldApplication": "Em aplicações empresariais como ERPs ou APIs REST, re-throw permite logging local em serviços (ex: camada de dados loga erro de BD e propaga para camada de negócio tratar transacionalmente), melhorando rastreabilidade sem duplicar lógica de tratamento."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1",
                              "10.1.4.5.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Analisar diagramas de hierarquia de exceções",
                            "description": "Interpretar diagramas UML ou árvores de herança de exceções, prevendo o comportamento de um bloco try-catch com base na ordem e especificidade dos catches.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Hierarquia de Exceções",
                                  "subSteps": [
                                    "Estude a classe base Throwable e suas subclasses principais: Exception (checked) e Error (unchecked graves).",
                                    "Identifique exemplos de herança: IOException herda de Exception, FileNotFoundException herda de IOException.",
                                    "Diferencie exceções checked (compiladas) de unchecked (runtime).",
                                    "Desenhe uma árvore simples de herança para RuntimeException e suas subclasses comuns como NullPointerException."
                                  ],
                                  "verification": "Explique por escrito ou verbalmente a cadeia de herança de uma exceção específica, como ArithmeticException.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Java (Throwable, Exception)",
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Sempre comece da raiz Throwable para contextualizar a profundidade da herança.",
                                  "learningObjective": "Dominar a estrutura hierárquica básica das exceções em linguagens orientadas a objetos como Java.",
                                  "commonMistakes": [
                                    "Confundir Error com exceções recuperáveis",
                                    "Ignorar que subclasses herdam comportamento de superclasses"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar Elementos em Diagramas UML ou Árvores de Herança",
                                  "subSteps": [
                                    "Identifique símbolos UML: classes como retângulos, setas de herança (triângulo vazio para generalização).",
                                    "Trace a linha de herança de uma exceção específica até Throwable.",
                                    "Anote níveis de especificidade: exceções mais derivadas são mais específicas.",
                                    "Pratique lendo 2-3 diagramas simples, destacando caminhos de herança.",
                                    "Compare diagramas UML com representações textuais de herança."
                                  ],
                                  "verification": "Redesenhe um diagrama fornecido, rotulando corretamente 3 caminhos de herança.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de diagramas UML de exceções (online ou livro)",
                                    "Ferramenta UML como PlantUML ou Lucidchart"
                                  ],
                                  "tips": "Siga as setas de herança de baixo para cima para entender generalização.",
                                  "learningObjective": "Ler e decodificar visualmente diagramas de hierarquia de exceções.",
                                  "commonMistakes": [
                                    "Confundir setas de herança com composição",
                                    "Ignorar herança múltipla indireta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Hierarquia para Blocos Try-Catch",
                                  "subSteps": [
                                    "Analise a ordem dos catches: do mais específico ao mais genérico.",
                                    "Mapeie uma exceção lançada no diagrama para os catches disponíveis.",
                                    "Verifique matching: uma exceção matches o primeiro catch compatível na hierarquia.",
                                    "Simule lançamento de exceções em diferentes pontos do try.",
                                    "Identifique catches 'mortos' (nunca alcançados devido à ordem)."
                                  ],
                                  "verification": "Para um código try-catch dado e diagrama, liste qual catch executa para 3 exceções simuladas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código como IntelliJ ou VS Code",
                                    "Código Java de exemplo com try-catch múltiplo"
                                  ],
                                  "tips": "Compile e execute o código para validar previsões manualmente.",
                                  "learningObjective": "Aplicar regras de matching de hierarquia em estruturas try-catch.",
                                  "commonMistakes": [
                                    "Assumir ordem top-to-bottom ignora especificidade",
                                    "Esquecer que catch(Exception) pega tudo abaixo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever e Simular Comportamentos em Cenários Complexos",
                                  "subSteps": [
                                    "Crie cenários com exceções polimórficas (subclasse lançada).",
                                    "Preveja fluxos para rethrowing ou nested try-catch.",
                                    "Teste com diagramas que incluem custom exceptions.",
                                    "Analise impactos de ordem invertida (compilação falha).",
                                    "Documente previsões vs. execução real em tabela."
                                  ],
                                  "verification": "Simule 4 cenários complexos e acerte 100% das previsões ao executar o código.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Java compilável",
                                    "Debugger integrado no IDE"
                                  ],
                                  "tips": "Use breakpoints no debugger para pausar e inspecionar o fluxo de exceções.",
                                  "learningObjective": "Prever com precisão o comportamento runtime baseado em hierarquia e ordem.",
                                  "commonMistakes": [
                                    "Subestimar propagação de exceções unchecked",
                                    "Confundir lançamento com catching"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o diagrama UML: Throwable --> Exception --> IOException --> FileNotFoundException. Código: try { throw new FileNotFoundException(); } catch (FileNotFoundException e) { print('Arquivo não encontrado'); } catch (IOException e) { print('IO genérico'); } catch (Exception e) { print('Exceção geral'); }. Previsão: 'Arquivo não encontrado' executa, pois FileNotFoundException matches o primeiro catch específico.",
                              "finalVerifications": [
                                "Corretamente interpreta 5 diagramas UML fornecidos, traçando heranças.",
                                "Preveja com 100% acerto o catch ativado em 10 cenários de código.",
                                "Identifica e corrige 3 catches mortos em código dado.",
                                "Explica regras de matching hierárquico em entrevista simulada.",
                                "Cria um diagrama UML customizado para uma hierarquia de exceções inventada.",
                                "Simula nested exceptions em debugger sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de caminhos de herança (90%+).",
                                "Correta previsão de fluxos try-catch em cenários variados.",
                                "Clareza na documentação de análises e justificativas.",
                                "Detecção de erros comuns como ordem incorreta de catches.",
                                "Criatividade em exemplos práticos e conexões reais.",
                                "Eficiência temporal: completa tarefas dentro dos estimates."
                              ],
                              "crossCurricularConnections": [
                                "Lógica de Fluxo e Árvores de Decisão (Matemática Discreta)",
                                "Design de Classes e Polimorfismo (Programação Orientada a Objetos)",
                                "Análise de Grafos e Hierarquias (Teoria dos Grafos)",
                                "Engenharia de Software e Debugging (Desenvolvimento Ágil)"
                              ],
                              "realWorldApplication": "Em aplicações enterprise como sistemas bancários, permite prever e otimizar handlers de exceções para falhas de rede ou banco de dados, garantindo robustez e logs precisos para debugging em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Tipos de Dados",
                "description": "Explora tipos escalares e estruturados utilizados em programação.",
                "totalSkills": 58,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Tipos Escalares Primitivos",
                    "description": "Definição e características de tipos básicos como inteiro, real, caractere e lógico.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Tipo Inteiro",
                        "description": "O tipo inteiro (int) é um tipo escalar primitivo que representa números inteiros sem parte fracionária, como 0, -5, 42. Características principais: tamanho fixo em memória (geralmente 4 bytes), faixa de valores típica de -2^31 a 2^31-1 em sistemas de 32 bits, utilizado para contagens, índices de arrays e operações aritméticas inteiras.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Definir e caracterizar o tipo inteiro",
                            "description": "Explicar a definição de tipo inteiro, suas características como tamanho em bytes, faixa de valores e usos comuns em programação, diferenciando de outros tipos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição básica de tipo inteiro",
                                  "subSteps": [
                                    "Ler a definição: tipo inteiro representa números inteiros sem parte fracionária, como 1, -5, 0.",
                                    "Identificar que é um tipo primitivo escalar em linguagens como C, Java, Python.",
                                    "Exemplificar com declarações simples: int x = 10; em Java.",
                                    "Discutir que inteiros são usados para contagens exatas.",
                                    "Revisar história breve: evolução de 16-bit para 64-bit."
                                  ],
                                  "verification": "Escrever uma definição própria em 2-3 frases e citar 2 exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de linguagens (Java, C++)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias cotidianas, como contar maçãs (sempre números inteiros).",
                                  "learningObjective": "Definir precisamente o tipo inteiro e seus conceitos fundamentais.",
                                  "commonMistakes": [
                                    "Confundir com números reais (floats)",
                                    "Ignorar sinal (positivo/negativo/zero)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar características técnicas: tamanho e faixa de valores",
                                  "subSteps": [
                                    "Estudar tamanhos: int de 4 bytes (32 bits) em maioria das linguagens modernas.",
                                    "Calcular faixas: -2^31 a 2^31-1 para signed int (aprox. -2bi a 2bi).",
                                    "Comparar variantes: short (2 bytes), long (8 bytes), unsigned.",
                                    "Verificar em código: usar sizeof(int) em C ou Integer.SIZE em Java.",
                                    "Testar limites com código simples para overflow."
                                  ],
                                  "verification": "Listar tamanhos e faixas para int, short e long, com cálculos manuais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador online (Repl.it)",
                                    "Tabela de tipos de dados da linguagem"
                                  ],
                                  "tips": "Memorize potências de 2: 2^10=1024, 2^20≈1M, 2^30≈1G.",
                                  "learningObjective": "Caracterizar precisamente o tamanho em bytes e faixas de valores do tipo inteiro.",
                                  "commonMistakes": [
                                    "Esquecer o bit de sinal reduzindo a faixa pela metade",
                                    "Confundir signed com unsigned"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar usos comuns do tipo inteiro em programação",
                                  "subSteps": [
                                    "Identificar usos: contadores de loops, índices de arrays, IDs de entidades.",
                                    "Exemplos: for(int i=0; i<10; i++), contagem de itens em listas.",
                                    "Aplicar em cenários: idade de pessoas, quantidade de produtos, scores em jogos.",
                                    "Codificar 3 exemplos simples e executá-los.",
                                    "Analisar por que inteiro é preferido: precisão, performance."
                                  ],
                                  "verification": "Criar e executar um programa com 3 usos diferentes de int.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE como VS Code ou online compiler",
                                    "Exemplos de código prontos"
                                  ],
                                  "tips": "Sempre inicialize variáveis int para evitar lixo de memória.",
                                  "learningObjective": "Identificar e exemplificar usos comuns e eficientes do tipo inteiro.",
                                  "commonMistakes": [
                                    "Usar int para valores fracionários (use float)",
                                    "Overflow em loops longos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar tipo inteiro de outros tipos numéricos",
                                  "subSteps": [
                                    "Comparar com float/double: inteiros exatos vs. aproximação binária de decimais.",
                                    "Tabela comparativa: precisão, tamanho, usos (int para contagens, double para medidas).",
                                    "Exemplos de erros: 0.1 + 0.2 != 0.3 em float, mas ok em int.",
                                    "Testar conversões: casting int para float e vice-versa.",
                                    "Resumir quando escolher cada tipo."
                                  ],
                                  "verification": "Montar tabela de diferenças e codificar exemplo de falha em float.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa impressa ou digital",
                                    "Compilador para testes"
                                  ],
                                  "tips": "Lembre: int para 'quantos?', float para 'quanto custa?'.",
                                  "learningObjective": "Diferenciar claramente inteiro de float, double e outros numéricos.",
                                  "commonMistakes": [
                                    "Assumir precisão infinita em float",
                                    "Não considerar perda em casting"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de e-commerce, use 'int quantidade = 5;' para representar o número de unidades de um produto no carrinho, somando totais exatos sem erros de arredondamento.",
                              "finalVerifications": [
                                "Definir tipo inteiro em próprias palavras.",
                                "Citar tamanho em bytes e faixa exata para int32.",
                                "Listar 3 usos comuns com exemplos de código.",
                                "Explicar diferença chave entre int e float com contraexemplo.",
                                "Identificar overflow em um valor limite.",
                                "Montar tabela comparativa de tipos numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e características técnicas (30%)",
                                "Correção nas faixas de valores e cálculos (25%)",
                                "Diversidade e relevância dos usos exemplificados (20%)",
                                "Clareza na diferenciação de outros tipos (15%)",
                                "Qualidade dos exemplos práticos e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de números inteiros, potências de 2 e limites.",
                                "Física: Contagens discretas em experimentos (número de partículas).",
                                "Economia: Cálculos de quantidades inteiras em estoques e transações."
                              ],
                              "realWorldApplication": "No desenvolvimento de software bancário, inteiros são usados para IDs de contas e transações, garantindo contagens exatas e evitando erros em saldos que poderiam ocorrer com floats."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Identificar valores e operações com inteiros",
                            "description": "Reconhecer valores válidos para inteiros, identificar overflow/underflow e realizar operações básicas como soma, subtração, multiplicação e divisão inteira.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de inteiros e seus limites de valor",
                                  "subSteps": [
                                    "Defina o que é um inteiro em programação (números inteiros sem parte fracionária).",
                                    "Aprenda os limites típicos para inteiros de 32 bits: de -2.147.483.648 a 2.147.483.647.",
                                    "Identifique representações em linguagens como C++ (int), Java (int) ou Python (int ilimitado, mas foque em limites fixos).",
                                    "Pratique convertendo números decimais para binários simples para entender representação.",
                                    "Liste exemplos de valores válidos e inválidos para inteiros."
                                  ],
                                  "verification": "Liste 5 valores válidos e 3 inválidos para um int de 32 bits, explicando por quê.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de tipos de dados da linguagem (ex: cppreference.com para C++), calculadora binária online"
                                  ],
                                  "tips": "Lembre-se: limites dependem do tamanho em bits (8, 16, 32, 64). Comece com 32 bits.",
                                  "learningObjective": "Reconhecer valores válidos e inválidos para inteiros primitivos.",
                                  "commonMistakes": [
                                    "Confundir com floats/decimais",
                                    "Ignorar sinal (positivo/negativo)",
                                    "Esquecer limites exatos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar overflow e underflow em inteiros",
                                  "subSteps": [
                                    "Explique overflow: resultado excede o limite máximo (torna-se negativo ou wrap-around).",
                                    "Explique underflow: resultado abaixo do limite mínimo.",
                                    "Simule overflow: some 2.000.000.000 + 2.000.000.000 em um int de 32 bits.",
                                    "Use código simples para demonstrar (ex: int a = INT_MAX; int b = a + 1;).",
                                    "Discuta comportamento undefined em C++ vs. wrap-around em Java."
                                  ],
                                  "verification": "Identifique e corrija 3 exemplos de código que causam overflow/underflow.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador online (repl.it ou IDEOne), header <limits.h> ou <climits> para INT_MAX/MIN"
                                  ],
                                  "tips": "Sempre verifique limites antes de operações com números grandes; use tipos long long para valores maiores.",
                                  "learningObjective": "Detectar e prever condições de overflow/underflow em operações.",
                                  "commonMistakes": [
                                    "Assumir que linguagens previnem automaticamente",
                                    "Não considerar wrap-around modular",
                                    "Confundir com divisão por zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar operações básicas com inteiros: soma, subtração, multiplicação e divisão inteira",
                                  "subSteps": [
                                    "Pratique soma e subtração: calcule 100 + 50, -20 - 30, verificando limites.",
                                    "Multiplicação: 1000 * 1000, observe potencial overflow.",
                                    "Divisão inteira: 10 / 3 = 3 (descarta resto), -10 / 3 = -3.",
                                    "Escreva e execute 10 expressões mistas (ex: (5 + 3) * 2 / 4).",
                                    "Compare resultados com calculadora para validar."
                                  ],
                                  "verification": "Execute 5 operações em código e explique resultados, incluindo qualquer truncamento na divisão.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Editor de código simples, exemplos de código prontos para soma/sub/etc."
                                  ],
                                  "tips": "Divisão inteira sempre trunca para baixo em direção a zero em muitas linguagens; teste com negativos.",
                                  "learningObjective": "Executar operações aritméticas precisas com inteiros, prevendo resultados.",
                                  "commonMistakes": [
                                    "Esquecer truncamento na divisão",
                                    "Ignorar precedência de operadores",
                                    "Não tratar negativos corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar conceitos em exercícios práticos e depuração",
                                  "subSteps": [
                                    "Crie um programa que leia dois inteiros e compute soma, produto e quociente.",
                                    "Adicione verificações para overflow usando if (resultado > INT_MAX).",
                                    "Depure cenários de erro: entrada que causa underflow.",
                                    "Otimize código para usar tipos maiores quando necessário.",
                                    "Teste com casos extremos: INT_MAX, INT_MIN, zero."
                                  ],
                                  "verification": "Desenvolva e teste um programa completo sem erros de overflow/underflow.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Compilador local/online, conjunto de testes de entrada/saída"
                                  ],
                                  "tips": "Use assert() ou condicionais para validação durante desenvolvimento.",
                                  "learningObjective": "Aplicar todos os conceitos em um contexto programático integrado.",
                                  "commonMistakes": [
                                    "Não testar bordas (edge cases)",
                                    "Esquecer divisão por zero",
                                    "Misturar tipos (int vs long)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de contagem de estoque, some quantidades: int stock1 = 2e9, stock2 = 1e9; int total = stock1 + stock2; // Overflow! Total vira negativo. Solução: use long long.",
                              "finalVerifications": [
                                "Explicar limites de int de 32 bits com números exatos.",
                                "Identificar overflow em soma de dois INT_MAX/2.",
                                "Calcular corretamente 17 / 5 e -17 / 5 em divisão inteira.",
                                "Escrever código que detecta overflow antes da operação.",
                                "Depurar um programa com underflow fornecido.",
                                "Listar 3 consequências reais de overflow não tratado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de valores válidos/inválidos (90%+ acerto).",
                                "Detecção correta de overflow/underflow em 100% dos exemplos.",
                                "Execução impecável de operações básicas sem erros aritméticos.",
                                "Código funcional com verificações de limites implementadas.",
                                "Explicações claras e concisas dos conceitos.",
                                "Tratamento adequado de casos edge em testes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e representação binária.",
                                "Lógica e Algoritmos: Previsão de comportamentos em fluxos de dados.",
                                "Física/Engenharia: Modelagem de contadores em sistemas embarcados.",
                                "Segurança da Informação: Vulnerabilidades como integer overflow em exploits."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como jogos (pontuações altas causam overflow), finanças (cálculos de saldos grandes), sistemas embarcados (sensores com contadores) e bancos de dados (IDs de entidades), onde overflow pode levar a bugs críticos ou vulnerabilidades de segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Declarar e atribuir variáveis inteiras",
                            "description": "Escrever declarações de variáveis do tipo inteiro em uma linguagem procedimental e realizar atribuições de valores inteiros, considerando escopo local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variáveis inteiras e declaração",
                                  "subSteps": [
                                    "Estude a definição de variável inteira: um espaço na memória para armazenar números inteiros (ex: -5, 0, 42).",
                                    "Aprenda a diferença entre declaração (reservar espaço) e definição (declaração com inicialização).",
                                    "Identifique o escopo local: variável acessível apenas dentro de uma função ou bloco.",
                                    "Revise tipos primitivos escalares, focando em int como tipo inteiro padrão.",
                                    "Anote exemplos de inteiros em diferentes linguagens procedurais como C ou Pascal."
                                  ],
                                  "verification": "Explique em suas palavras o que é uma variável inteira local e dê um exemplo verbal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de sintaxe de C (int)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogia: variável é como uma caixa etiquetada 'int' para guardar números inteiros.",
                                  "learningObjective": "Entender o papel e escopo de variáveis inteiras em programação procedimental.",
                                  "commonMistakes": [
                                    "Confundir escopo local com global",
                                    "Achar que variáveis não precisam de tipo explícito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever declarações básicas de variáveis inteiras",
                                  "subSteps": [
                                    "Abra um editor de código (ex: VS Code) e crie um arquivo .c.",
                                    "Escreva a sintaxe: int nomeVariavel; (sem inicialização).",
                                    "Declare múltiplas: int a, b, c;.",
                                    "Compile com gcc para verificar erros de sintaxe.",
                                    "Adicione #include <stdio.h> e uma função main() para contexto."
                                  ],
                                  "verification": "Compilação bem-sucedida sem erros de declaração.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Code::Blocks)",
                                    "Compilador GCC instalado"
                                  ],
                                  "tips": "Sempre declare dentro de {} para escopo local claro.",
                                  "learningObjective": "Dominar a sintaxe de declaração de variáveis int locais.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula",
                                    "Usar letras maiúsculas no tipo (Int em vez de int)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar atribuições de valores inteiros",
                                  "subSteps": [
                                    "Atribua valores: int x = 10; ou x = 20; após declaração.",
                                    "Teste atribuições múltiplas: x = 5; y = x + 3;.",
                                    "Evite atribuições fora do escopo: declare dentro de main().",
                                    "Compile e execute com printf para imprimir valores.",
                                    "Experimente valores negativos e zero."
                                  ],
                                  "verification": "Programa executa e imprime valores atribuídos corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use = para atribuição, não == (que é comparação).",
                                  "learningObjective": "Executar atribuições seguras a variáveis int declaradas.",
                                  "commonMistakes": [
                                    "Usar == para atribuição",
                                    "Atribuir floats a int sem cast"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar declaração e atribuição em um programa funcional",
                                  "subSteps": [
                                    "Crie um programa completo: declare int idade; atribua idade = 25; printf idade.",
                                    "Adicione cálculos: int soma = idade + 5;.",
                                    "Teste escopo: declare em função local e acesse apenas ali.",
                                    "Compile, execute e depure erros.",
                                    "Modifique para múltiplas variáveis e operações."
                                  ],
                                  "verification": "Programa compila, executa e produz saída esperada sem warnings.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor com debugger opcional",
                                    "Exemplos de código C básicos"
                                  ],
                                  "tips": "Sempre inicialize variáveis para evitar lixo na memória.",
                                  "learningObjective": "Combinar declaração, atribuição e uso em contexto procedural com escopo local.",
                                  "commonMistakes": [
                                    "Acessar variável fora do escopo",
                                    "Não inicializar levando a valores garbage"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C: int main() { int score = 100; int bonus = 50; score += bonus; printf(\"Score final: %d\\n\", score); return 0; } // Saída: Score final: 150",
                              "finalVerifications": [
                                "Declara variável int sem erros de sintaxe.",
                                "Atribui valor inteiro corretamente e imprime.",
                                "Respeita escopo local (não acessível fora da função).",
                                "Manipula múltiplas variáveis int em operações básicas.",
                                "Compila e executa programa sem warnings.",
                                "Identifica e corrige erros comuns de declaração/atribuição."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa de declaração (tipo, nome, ;).",
                                "Atribuições válidas com valores inteiros.",
                                "Escopo local respeitado sem violações.",
                                "Código compila e executa corretamente.",
                                "Uso em contexto funcional (main() ou função).",
                                "Comentários explicando escopo e atribuições."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações com números inteiros (soma, subtração).",
                                "Lógica: Conceitos de armazenamento e manipulação de dados.",
                                "Física: Modelagem de contadores discretos (ex: posições inteiras).",
                                "Inglês: Leitura de documentação técnica de linguagens."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, declarar variáveis int locais para contadores de loops, scores em jogos, IDs de usuários ou índices de arrays, garantindo eficiência e isolamento de dados em funções modulares."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Tipo Real",
                        "description": "O tipo real (float ou double) é um tipo escalar primitivo que representa números com parte fracionária, como 3.14, -2.5. Características: precisão limitada (float: ~7 dígitos, double: ~15), representação em ponto flutuante IEEE 754, usado para medidas, cálculos científicos e finanças.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Definir e caracterizar o tipo real",
                            "description": "Descrever o tipo real, diferenciando float de double, explicando precisão, notação científica e possíveis erros de arredondamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição básica do tipo real",
                                  "subSteps": [
                                    "Pesquise a definição de números reais em computação como números de ponto flutuante.",
                                    "Identifique que representam números com parte fracionária, ao contrário de inteiros.",
                                    "Leia sobre padrões IEEE 754 para representação binária.",
                                    "Anote exemplos de uso em linguagens como C ou Java.",
                                    "Compare com representação decimal humana."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e cite o padrão IEEE 754.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação IEEE 754, tutoriais online sobre tipos de dados (ex: GeeksforGeeks).",
                                  "tips": "Use analogias como 'dinheiro com centavos' para visualizar frações.",
                                  "learningObjective": "Compreender o conceito fundamental de tipos reais como aproximações binárias de números decimais.",
                                  "commonMistakes": "Confundir tipos reais com inteiros ou assumir precisão infinita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar float de double",
                                  "subSteps": [
                                    "Estude o tamanho: float (32 bits, ~7 dígitos decimais), double (64 bits, ~15 dígitos).",
                                    "Compile e execute códigos de exemplo em C comparando precisão.",
                                    "Analise o impacto no uso de memória e performance.",
                                    "Teste conversões entre float e double.",
                                    "Registre diferenças em uma tabela comparativa."
                                  ],
                                  "verification": "Crie uma tabela comparativa e demonstre com código a perda de precisão em float.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C (GCC), editor de código (VS Code), exemplos de código online.",
                                  "tips": "Sempre prefira double para cálculos precisos, a menos que memória seja crítica.",
                                  "learningObjective": "Saber escolher entre float e double baseado em precisão e recursos.",
                                  "commonMistakes": "Usar float por padrão sem considerar perda de precisão em cálculos acumulados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar precisão e limitações",
                                  "subSteps": [
                                    "Aprenda sobre mantissa e expoente na representação binária.",
                                    "Calcule exemplos de precisão: 0.1 em binário não é exato.",
                                    "Execute testes mostrando epsilon de máquina.",
                                    "Discuta quando usar precisão simples vs dupla.",
                                    "Anote limitações como overflow/underflow."
                                  ],
                                  "verification": "Explique por que 0.1 + 0.2 != 0.3 em código e mostre o resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora binária online, código de teste em Python ou C.",
                                  "tips": "Use funções como nextafter() para explorar limites de precisão.",
                                  "learningObjective": "Entender as limitações inerentes da precisão em ponto flutuante.",
                                  "commonMistakes": "Assumir que computadores representam decimais exatos como humanos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender notação científica",
                                  "subSteps": [
                                    "Estude a forma normalizada: ± mantissa × 2^expoente.",
                                    "Converta números decimais para notação científica binária manualmente.",
                                    "Analise como linguagens imprimem com %e ou printf.",
                                    "Teste valores extremos como 1e308.",
                                    "Compare com notação decimal."
                                  ],
                                  "verification": "Converta 12.5 para notação binária e imprima em código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela de potências de 2, simulador IEEE 754 online.",
                                  "tips": "Pratique com números pequenos para fixar o conceito de normalização.",
                                  "learningObjective": "Representar números reais na forma científica usada em hardware.",
                                  "commonMistakes": "Confundir base 2 (binária) com base 10 (decimal)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Identificar e mitigar erros de arredondamento",
                                  "subSteps": [
                                    "Identifique causas: operações não exatas, acumulação de erros.",
                                    "Teste somas repetidas como 0.1 * 10.",
                                    "Aprenda técnicas: usar inteiros escalados, bibliotecas como GMP.",
                                    "Analise impactos em algoritmos como soma de séries.",
                                    "Documente boas práticas para evitar erros."
                                  ],
                                  "verification": "Corrija um código com erro de arredondamento e compare resultados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de código com erros conhecidos, documentação de bibliotecas numéricas.",
                                  "tips": "Evite comparações exatas com floats; use tolerâncias como fabs(a-b) < 1e-9.",
                                  "learningObjective": "Detectar e corrigir erros comuns de precisão em aplicações reais.",
                                  "commonMistakes": "Ignorar erros pequenos que se acumulam em loops longos."
                                }
                              ],
                              "practicalExample": "Em C: float f = 0.1f; double d = 0.1; printf('Float: %.20f, Double: %.20f\\n', f, d); // Mostra diferenças de precisão. Some 10x 0.1 e observe !=1.0 em float.",
                              "finalVerifications": [
                                "Define corretamente tipo real como número de ponto flutuante IEEE 754.",
                                "Diferencia float (32 bits) de double (64 bits) com exemplos.",
                                "Explica precisão limitada e demonstra 0.1 + 0.2 != 0.3.",
                                "Representa um número em notação científica binária.",
                                "Identifica erro de arredondamento em código e propõe solução.",
                                "Escolhe tipo adequado para cenários de alta precisão."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa e completa do tipo real.",
                                "Comparação clara e precisa entre float e double.",
                                "Explicação correta de limitações de precisão com evidências.",
                                "Uso correto de notação científica em exemplos.",
                                "Análise profunda de erros de arredondamento com mitigações.",
                                "Clareza e correção em todos os exemplos de código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aproximações numéricas e análise de erros.",
                                "Física: Representação de medidas experimentais com precisão limitada.",
                                "Engenharia: Cálculos em simulações e controle numérico.",
                                "Matemática Computacional: Métodos numéricos estáveis."
                              ],
                              "realWorldApplication": "Em jogos (física de colisões com double para precisão), finanças (cálculos de juros compostos evitando arredondamentos), machine learning (pesos em redes neurais com float para eficiência) e simulações científicas (modelos climáticos exigindo double)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Identificar valores e operações com reais",
                            "description": "Reconhecer literais reais válidos, realizar operações aritméticas com reais e identificar problemas como perda de precisão em comparações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Reconhecer Literais Reais Válidos",
                                  "subSteps": [
                                    "Estude a definição de literal real: números com parte fracionária representados por ponto decimal ou notação científica.",
                                    "Identifique exemplos válidos em linguagens como C ou Java: 3.14, 0.0, -2.5e3, 1.23E-4.",
                                    "Distinga de literais inválidos: inteiros sem decimal (ex: 5 é int, não real), uso de vírgula (ex: 3,14).",
                                    "Pratique escrevendo 10 literais reais variados em um editor de código.",
                                    "Compile ou valide sintaxe em um compilador online para confirmar."
                                  ],
                                  "verification": "Liste 5 literais reais válidos e 3 inválidos, explicando o motivo para cada inválido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de tipos de dados em C/Java",
                                    "Editor de código online (ex: Replit)",
                                    "Compilador online"
                                  ],
                                  "tips": [
                                    "Sempre use ponto (.) para decimal, independentemente da localidade.",
                                    "Notação científica é útil para números muito grandes ou pequenos."
                                  ],
                                  "learningObjective": "Identificar e escrever corretamente literais reais em código fonte.",
                                  "commonMistakes": [
                                    "Confundir literais inteiros com reais",
                                    "Usar vírgula em vez de ponto decimal",
                                    "Esquecer o 'e' minúsculo ou maiúsculo na notação científica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Operações Aritméticas Básicas com Reais",
                                  "subSteps": [
                                    "Revise operadores aritméticos: + (soma), - (subtração), * (multiplicação), / (divisão).",
                                    "Escreva expressões simples: 3.14 + 2.0, 10.5 / 3.0, resultando em reais.",
                                    "Declare variáveis reais (float/double) e atribua resultados de operações.",
                                    "Execute código de exemplo em um ambiente de programação e observe saídas.",
                                    "Teste com valores zero e negativos para edge cases."
                                  ],
                                  "verification": "Escreva e execute um programa que compute soma, produto e quociente de dois reais fornecidos, imprimindo resultados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente de programação (ex: Code::Blocks, OnlineGDB)",
                                    "Exemplos de código pré-prontos"
                                  ],
                                  "tips": [
                                    "Use double em vez de float para maior precisão na maioria dos casos.",
                                    "Imprima com printf ou cout para verificar resultados."
                                  ],
                                  "learningObjective": "Executar operações aritméticas com reais sem erros de compilação ou runtime.",
                                  "commonMistakes": [
                                    "Misturar tipos int e real sem casting implícito",
                                    "Dividir por zero (causa NaN ou infinity)",
                                    "Esquecer de incluir bibliotecas de I/O"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Perda de Precisão em Operações com Reais",
                                  "subSteps": [
                                    "Entenda representação binária de reais: IEEE 754, mantissa e expoente.",
                                    "Teste exemplo clássico: 0.1 + 0.2 resulta em algo como 0.30000000000000004.",
                                    "Compare resultados de operações repetidas: 0.1 * 3 vs 0.3.",
                                    "Use ferramentas para visualizar representação binária (ex: float.toString em JS ou hex dump).",
                                    "Discuta arredondamentos em somas e produtos extensos."
                                  ],
                                  "verification": "Execute código mostrando 0.1 + 0.2 != 0.3 e explique a saída em termos de precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo sobre IEEE 754",
                                    "Ferramenta online de conversão float para binário",
                                    "Compilador com debugger"
                                  ],
                                  "tips": [
                                    "Aumente precisão com double, mas lembre que problemas persistem.",
                                    "Evite operações desnecessárias que acumulem erros."
                                  ],
                                  "learningObjective": "Explicar causas de perda de precisão em operações com reais.",
                                  "commonMistakes": [
                                    "Acreditar que reais têm precisão infinita como racionais",
                                    "Ignorar diferenças entre float e double",
                                    "Usar impressões com poucas casas decimais para 'esconder' erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Problemas em Comparações de Reais",
                                  "subSteps": [
                                    "Aprenda por que == falha: devido a erros de arredondamento acumulados.",
                                    "Introduza comparações com epsilon: if (abs(a - b) < 1e-9).",
                                    "Teste cenários: loops que acumulam erros, funções trigonométricas.",
                                    "Implemente função de comparação segura para reais.",
                                    "Aplique em um exemplo prático de soma iterativa."
                                  ],
                                  "verification": "Refatore código com == para usar epsilon e demonstre correção em casos falhos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código com bugs de precisão",
                                    "Biblioteca <cmath> para abs",
                                    "Debugger"
                                  ],
                                  "tips": [
                                    "Escolha epsilon baseado na precisão desejada (ex: 1e-6 para geral).",
                                    "Prefira funções que evitam comparações diretas quando possível."
                                  ],
                                  "learningObjective": "Aplicar técnicas seguras para comparações de valores reais.",
                                  "commonMistakes": [
                                    "Usar == para floats/doubles",
                                    "Epsilon fixo muito grande ou pequeno",
                                    "Comparar sem considerar magnitude relativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa simples para calcular a área de um círculo (A = π * r²) usando r = 1.0 / 3.0. Observe perda de precisão ao comparar com valor matemático exato e use epsilon para verificação.",
                              "finalVerifications": [
                                "Lista corretamente literais reais válidos e inválidos.",
                                "Executa operações aritméticas com reais produzindo saídas esperadas.",
                                "Demonstra e explica o resultado de 0.1 + 0.2 != 0.3.",
                                "Implementa comparação de reais com epsilon corretamente.",
                                "Identifica e corrige bugs de precisão em código fornecido.",
                                "Explica impacto da representação IEEE 754 em operações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de literais (100% acerto em testes).",
                                "Código compila e executa sem erros em operações básicas (passa 10 testes).",
                                "Explicação correta de perda de precisão (cobertura de IEEE 754 e exemplos).",
                                "Implementação de comparações seguras (epsilon relativo/absoluto).",
                                "Análise de erros comuns evitados em exemplos práticos.",
                                "Tempo de execução e clareza no raciocínio demonstrados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética de números reais e limites de representação decimal.",
                                "Física: Modelagem de grandezas contínuas com precisão finita (ex: velocidades, acelerações).",
                                "Engenharia: Análise de erros em simulações numéricas.",
                                "Economia/Finanças: Cálculos de juros e arredondamentos monetários."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software para jogos (física de colisões), finanças (cálculo de portfólios sem erros acumulados), gráficos 3D (coordenadas flutuantes) e machine learning (gradientes com precisão controlada), onde comparações inexatas podem causar bugs catastróficos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Declarar e atribuir variáveis reais",
                            "description": "Declarar variáveis reais em código, atribuir valores com diferentes formatos (decimal, exponencial) e converter de inteiro para real implicitamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos básicos de variáveis reais",
                                  "subSteps": [
                                    "Estude a definição de números reais como valores com parte decimal.",
                                    "Compare com inteiros: reais permitem frações, como 3.14 ou 1.5e3.",
                                    "Revise sintaxe de declaração em Portugol: 'real nomeVariavel;'.",
                                    "Analise exemplos de uso em contextos numéricos precisos.",
                                    "Identifique quando usar real vs inteiro."
                                  ],
                                  "verification": "Responda corretamente a um quiz com 5 perguntas sobre diferenças entre real e inteiro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de Portugol sobre tipos de dados",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Lembre-se: reais são essenciais para precisão em cálculos decimais.",
                                  "learningObjective": "Compreender o propósito e características de variáveis reais.",
                                  "commonMistakes": [
                                    "Confundir real com inteiro",
                                    "Ignorar precisão limitada de reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar variáveis reais corretamente",
                                  "subSteps": [
                                    "Abra o ambiente de programação (ex: Visualg ou Portugol Studio).",
                                    "Escreva a sintaxe: 'real pi, raio, area;'.",
                                    "Declare múltiplas variáveis reais em uma linha separadas por vírgula.",
                                    "Compile o código para verificar erros de sintaxe.",
                                    "Adicione comentários explicando cada declaração."
                                  ],
                                  "verification": "Código declara variáveis reais sem erros de compilação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ambiente de programação Portugol",
                                    "Editor de texto"
                                  ],
                                  "tips": "Sempre inicialize variáveis logo após declarar para evitar valores indefinidos.",
                                  "learningObjective": "Dominar a sintaxe de declaração de variáveis do tipo real.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula",
                                    "Usar aspas em nomes de variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atribuir valores reais em formatos decimal e exponencial",
                                  "subSteps": [
                                    "Atribua valor decimal: 'pi := 3.14159;'.",
                                    "Atribua valor exponencial: 'distancia := 1.5e3;' (equivalente a 1500.0).",
                                    "Teste atribuições múltiplas: 'raio := 5.0; area := pi * raio * raio;'.",
                                    "Exiba valores com 'escreva(pi);' para verificar.",
                                    "Experimente diferentes precisões, como 0.001 ou 2.71828e0."
                                  ],
                                  "verification": "Programa exibe valores atribuídos corretamente na tela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente de programação",
                                    "Exemplos de código prontos"
                                  ],
                                  "tips": "Use 'e' ou 'E' para notação científica; é case-insensitive.",
                                  "learningObjective": "Aplicar atribuições de valores reais em múltiplos formatos.",
                                  "commonMistakes": [
                                    "Usar vírgula em vez de ponto decimal",
                                    "Esquecer o expoente em notação científica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar conversão implícita de inteiro para real",
                                  "subSteps": [
                                    "Declare uma variável inteira: 'inteiro num := 10;'.",
                                    "Atribua a uma real: 'real resultado := num / 3;'.",
                                    "Observe a promoção implícita: resultado será 3.333... (real).",
                                    "Compare com divisão inteira: 'inteiro divInt := num / 3;' (resultado 3).",
                                    "Teste em um programa completo e verifique saídas."
                                  ],
                                  "verification": "Programa demonstra conversão implícita com saída decimal correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente de programação",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "A linguagem promove inteiro para real em operações mistas automaticamente.",
                                  "learningObjective": "Entender e aplicar conversão implícita de inteiro para real.",
                                  "commonMistakes": [
                                    "Esperar truncamento em vez de promoção",
                                    "Forçar conversão explícita desnecessária"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa que declara variáveis reais para calcular a área de um círculo: real pi := 3.14159, raio := 5, area; area := pi * raio * raio; escreva('Área: ', area); Demonstre conversão atribuindo raio := 10 / 2; (implícito real).",
                              "finalVerifications": [
                                "Código compila sem erros de tipo ou sintaxe.",
                                "Valores reais são exibidos com decimais corretos.",
                                "Conversão implícita produz resultado fracionário.",
                                "Notação exponencial é interpretada corretamente (ex: 1e3 = 1000.0).",
                                "Programa executa e exibe 3 exemplos distintos.",
                                "Comentários explicam cada atribuição."
                              ],
                              "assessmentCriteria": [
                                "Correção na declaração (100% sem erros).",
                                "Diversidade de formatos de atribuição (decimal e exponencial).",
                                "Demonstração clara de conversão implícita.",
                                "Saídas precisas e formatadas.",
                                "Código limpo com comentários.",
                                "Eficiência e ausência de variáveis desnecessárias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações com números reais e notação científica.",
                                "Física: Cálculos de medidas como velocidade (m/s) ou aceleração.",
                                "Química: Concentrações molares com decimais precisos."
                              ],
                              "realWorldApplication": "Em engenharia de software, variáveis reais são usadas em simulações financeiras (juros compostos), jogos (coordenadas flutuantes) e análise de dados (médias ponderadas), garantindo precisão em cálculos não-inteiros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Tipo Caractere",
                        "description": "O tipo caractere (char) é um tipo escalar primitivo que representa um único símbolo alfanumérico ou especial, como 'A', '5', armazenado como código ASCII/Unicode (geralmente 1 byte). Características: delimitado por aspas simples, usado para textos curtos e manipulação de strings individuais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Definir e caracterizar o tipo caractere",
                            "description": "Explicar o tipo char, seu tamanho (1 byte), códigos de representação (ASCII) e distinção de strings.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição básica do tipo caractere",
                                  "subSteps": [
                                    "Pesquise a definição de 'caractere' em programação como um tipo de dado primitivo que representa um único símbolo alfanumérico.",
                                    "Leia documentação oficial de linguagens como C ou Java sobre o tipo 'char'.",
                                    "Anote que char é escalar, armazenando um só caractere, não sequências.",
                                    "Compare com inteiros: char é mapeado para códigos numéricos.",
                                    "Registre exemplos visuais: 'A', '5', '$'."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e cite 3 exemplos de caracteres válidos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Documentação de C/Java online, caderno para anotações",
                                  "tips": "Use analogia: char é como uma letra única em uma palavra.",
                                  "learningObjective": "Definir precisamente o tipo char e identificá-lo em contextos primitivos.",
                                  "commonMistakes": "Confundir char com string desde o início; achar que char armazena múltiplos símbolos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Caracterizar o tamanho e representação em códigos ASCII",
                                  "subSteps": [
                                    "Aprenda que char ocupa 1 byte (8 bits) na maioria das arquiteturas.",
                                    "Estude a tabela ASCII: 0-127 para caracteres padrão, 128-255 estendidos.",
                                    "Converta manualmente: 'A' é 65, 'a' é 97.",
                                    "Verifique em ferramentas online de conversão ASCII.",
                                    "Entenda variações Unicode para contextos modernos, mas foque em ASCII básico."
                                  ],
                                  "verification": "Liste 5 pares caractere-código ASCII e confirme o tamanho de 1 byte em specs de linguagem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela ASCII impressa ou online, calculadora binária",
                                  "tips": "Memorize faixas: maiúsculas 65-90, minúsculas 97-122.",
                                  "learningObjective": "Explicar o tamanho de 1 byte e mapear chars para códigos ASCII.",
                                  "commonMistakes": "Ignorar que tamanho pode variar em Unicode; confundir bytes com bits."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Distinguir tipo char de strings",
                                  "subSteps": [
                                    "Defina string como array ou ponteiro para múltiplos chars terminados em null.",
                                    "Compare declarações: char c = 'A'; vs. char s[] = \"Olá\";",
                                    "Analise diferenças: char é único, string é sequencial com tamanho variável.",
                                    "Teste em pseudocódigo: atribuir string a char causa truncamento.",
                                    "Discuta por que chars são eficientes para processamento individual."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 4 diferenças chave entre char e string.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Editor de texto para tabelas, referência de sintaxe da linguagem",
                                  "tips": "Pense em char como átomo, string como molécula de chars.",
                                  "learningObjective": "Diferenciar char (único) de string (sequência) em uso e memória.",
                                  "commonMistakes": "Usar aspas duplas para char (\"A\" é string, 'A' é char)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar declaração e manipulação básica de chars",
                                  "subSteps": [
                                    "Escreva código simples: declare char, inicialize com ASCII, imprima valor e código.",
                                    "Converta int para char e vice-versa usando casting.",
                                    "Teste limites: char com valor 0 (null) vs. caracteres imprimíveis.",
                                    "Compile e execute, observando saídas no console.",
                                    "Modifique código para validar distinção com strings."
                                  ],
                                  "verification": "Execute código que demonstre declaração, ASCII e diferença com string sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador C/C++ (GCC online ou local), editor VS Code",
                                  "tips": "Use printf(\"%c %d\", c, (int)c); para visualizar.",
                                  "learningObjective": "Aplicar conhecimento em código funcional para chars.",
                                  "commonMistakes": "Esquecer terminador null em strings; overflow em casts."
                                }
                              ],
                              "practicalExample": "Em C: char letra = 'A'; printf(\"Caractere: %c, Código ASCII: %d\\n\", letra, (int)letra); // Saída: Caractere: A, Código ASCII: 65. Agora, char* str = \"ABC\"; mostra string com 4 bytes (incluindo \\0).",
                              "finalVerifications": [
                                "Explique verbalmente o que é char em 1 minuto.",
                                "Converta 'Z' para ASCII corretamente.",
                                "Identifique erro: char c = \"Hi\";",
                                "Descreva uso de 1 byte.",
                                "Compare char vs. string em uma frase.",
                                "Execute código de exemplo sem bugs."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa de char (único símbolo, primitivo).",
                                "Correto tamanho (1 byte) e menção a ASCII.",
                                "Distinção clara de strings (array vs. escalar).",
                                "Exemplos práticos com códigos funcionais.",
                                "Sem confusões comuns como aspas duplas.",
                                "Compreensão de representação numérica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Mapeamento bi-injetivo ASCII (funções discretas).",
                                "Linguística: Símbolos como unidades fonéticas básicas.",
                                "História da Computação: Evolução de ASCII para Unicode.",
                                "Física: Codificação binária de sinais elétricos."
                              ],
                              "realWorldApplication": "Em software, chars são fundamentais para processar teclados (input único), criptografia (manipulação de símbolos em senhas), parsing de arquivos texto e interfaces de usuário onde cada caractere é renderizado individualmente em displays."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Identificar valores e operações com caracteres",
                            "description": "Reconhecer literais de caractere válidos, realizar comparações e operações como conversão para código numérico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender literais de caractere válidos",
                                  "subSteps": [
                                    "Estude a sintaxe de literais de caractere em C: usar aspas simples como 'a', '1', '\\n'.",
                                    "Identifique caracteres imprimíveis (letras, dígitos, símbolos) e de controle (escape sequences).",
                                    "Liste exemplos válidos ('A', 'z', ' ', '\\t') e inválidos (\"abc\", 'ab').",
                                    "Pratique declarando variáveis char: char c = 'x';.",
                                    "Explore o tamanho de um char (geralmente 1 byte)."
                                  ],
                                  "verification": "Criar uma lista de 10 literais válidos e 5 inválidos, explicando por quê.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C online (como Replit ou IDEone), documentação de sintaxe C.",
                                  "tips": "Sempre use aspas simples para um único caractere; aspas duplas são para strings.",
                                  "learningObjective": "Reconhecer e declarar literais de caractere válidos conforme a norma da linguagem.",
                                  "commonMistakes": "Confundir com strings (usar \" em vez de '), ou usar múltiplos caracteres em literais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar comparações entre caracteres",
                                  "subSteps": [
                                    "Aprenda operadores de comparação: ==, !=, <, >, <=, >= para chars.",
                                    "Entenda que chars são comparados pelos seus códigos ASCII (ex: 'a' < 'b').",
                                    "Escreva expressões como if ('A' == 'a') para testar igualdade.",
                                    "Pratique com intervalos: verificar se um char é maiúscula ('A' <= c && c <= 'Z').",
                                    "Teste em um programa simples que compara dois chars lidos do usuário."
                                  ],
                                  "verification": "Implementar e testar um programa que classifica um char como vogal ou consoante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador C, tabela ASCII.",
                                  "tips": "Lembre-se: maiúsculas vêm antes de minúsculas no ASCII (A=65, a=97).",
                                  "learningObjective": "Aplicar operadores de comparação corretamente em valores char.",
                                  "commonMistakes": "Ignorar sensibilidade a maiúsculas/minúsculas, ou usar = em vez de ==."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar operações de conversão para código numérico",
                                  "subSteps": [
                                    "Aprenda a converter char para int: (int)c ou c (implícito).",
                                    "Estude conversão reversa: (char)65 para obter 'A'.",
                                    "Explore operações aritméticas: c + 1 para próximo caractere.",
                                    "Implemente funções como isDigit(c): c >= '0' && c <= '9'.",
                                    "Teste com printf para exibir códigos: printf(\"%d\", c);."
                                  ],
                                  "verification": "Criar programa que converte uma string de chars em soma dos códigos ASCII.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Compilador C, tabela ASCII completa.",
                                  "tips": "Use casts explícitos para clareza: int codigo = (int)'A';.",
                                  "learningObjective": "Dominar conversões e operações aritméticas em chars como inteiros.",
                                  "commonMistakes": "Esquecer cast em atribuições, ou subestimar overflow em aritmética."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar conceitos em exemplos práticos",
                                  "subSteps": [
                                    "Combine literais, comparações e conversões em um programa completo.",
                                    "Crie validador de senha simples usando checks de char.",
                                    "Debugue erros comuns em códigos de teste.",
                                    "Otimize código para eficiência em comparações.",
                                    "Documente o código explicando cada operação com char."
                                  ],
                                  "verification": "Executar e demonstrar um programa que processa input de usuário com chars.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Compilador C, exemplos de código anteriores.",
                                  "tips": "Sempre inicialize variáveis char para evitar lixo de memória.",
                                  "learningObjective": "Sintetizar conhecimentos em aplicações funcionais.",
                                  "commonMistakes": "Não tratar input inválido, como chars fora de range esperado."
                                }
                              ],
                              "practicalExample": "Escreva um programa em C que lê um caractere do usuário, verifica se é uma letra maiúscula usando comparações ('A' <= c && c <= 'Z'), converte para código ASCII com (int)c e imprime 'Válida' se for, senão 'Inválida'. Exemplo: input 'B' → output \"Código: 66 - Válida\".",
                              "finalVerifications": [
                                "Lista corretamente 10 literais de char válidos e invalidações.",
                                "Implementa comparações precisas sem erros de sintaxe.",
                                "Converte char para int e vice-versa com resultados corretos (ASCII).",
                                "Programa integrado roda sem warnings ou erros de compilação.",
                                "Explica diferenças entre char e string em contexto.",
                                "Identifica e corrige 5 erros comuns em códigos de teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de literais (90% correto).",
                                "Correção em comparações e operações (sem falhas lógicas).",
                                "Eficiência e clareza no código gerado.",
                                "Compreensão demonstrada em verificações finais (rubrica 4/5).",
                                "Integração de conceitos em exemplo prático funcional.",
                                "Evita erros comuns listados nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Códigos ASCII como representação numérica de símbolos.",
                                "Linguística: Análise de caracteres em processamento de linguagem natural.",
                                "Lógica: Condicionais e operadores relacionais como em algoritmos.",
                                "História da Computação: Evolução de encodings como ASCII para Unicode."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usado para validar inputs de usuário (ex: senhas, formulários), processamento de texto (filtros de email), criptografia simples (shifts em chars) e parsers de arquivos (checagem de delimitadores)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Declarar e atribuir variáveis caractere",
                            "description": "Declarar variáveis char, atribuir caracteres e usar em entrada/saída básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variável caractere (char)",
                                  "subSteps": [
                                    "Estude a definição de tipo char: representa um único caractere Unicode ou ASCII (ex: 'A', '1', '@').",
                                    "Aprenda sobre o tamanho: geralmente 1 byte (8 bits), com valores de 0 a 255 em C/C++.",
                                    "Entenda a representação: use aspas simples ' ' para literais char, não duplas \" \".",
                                    "Explore exemplos: 'a' (letra minúscula), '\\n' (nova linha), códigos de escape.",
                                    "Diferencie char de string: char é escalar, string é array de chars."
                                  ],
                                  "verification": "Responda corretamente a um quiz com 5 perguntas sobre diferenças entre char e outros tipos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem C (man page ou site oficial)",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Visualize a tabela ASCII para associar números a caracteres.",
                                  "learningObjective": "Explicar o que é uma variável char, seu tamanho e sintaxe de literal.",
                                  "commonMistakes": "Usar aspas duplas para char (isso cria string); confundir com int."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar variáveis do tipo char",
                                  "subSteps": [
                                    "Escreva a sintaxe básica: char nomeVariavel; (sem inicialização).",
                                    "Declare com inicialização: char letra = 'B';",
                                    "Declare múltiplas: char c1, c2 = 'X', c3;",
                                    "Use em função main(): inclua #include <stdio.h> e int main().",
                                    "Compile e verifique erros: gcc programa.c -o programa."
                                  ],
                                  "verification": "Compile um código com 3 declarações char sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador GCC ou online como Replit",
                                    "Terminal ou IDE"
                                  ],
                                  "tips": "Sempre declare dentro de escopo válido, como main().",
                                  "learningObjective": "Declarar corretamente variáveis char com e sem inicialização.",
                                  "commonMistakes": "Esquecer ponto e vírgula (;); usar = sem declaração prévia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atribuir valores a variáveis char",
                                  "subSteps": [
                                    "Atribua literais: variavel = 'Z';",
                                    "Atribua de outra variável: char a = 'A'; char b = a;",
                                    "Use códigos de escape: char novaLinha = '\\n';",
                                    "Evite atribuições inválidas: não atribua strings ou múltiplos chars.",
                                    "Teste reatribuição: variavel = ' novo valor ';"
                                  ],
                                  "verification": "Execute um programa que atribui e imprime 3 valores diferentes em uma char.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Exemplos de código prontos para modificar"
                                  ],
                                  "tips": "Lembre-se: char aceita apenas um caractere; overflow causa comportamento indefinido.",
                                  "learningObjective": "Atribuir valores literais, de variáveis e códigos especiais a char.",
                                  "commonMistakes": "Atribuir string como \"AB\" (erro de compilação); esquecer aspas simples."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Usar variáveis char em entrada e saída básica",
                                  "subSteps": [
                                    "Saída com printf: printf(\"Caractere: %c\\n\", variavel);",
                                    "Entrada com scanf: scanf(\"%c\", &variavel); note o & para endereço.",
                                    "Combine: leia char do usuário e imprima de volta.",
                                    "Trate espaços: use getchar() para entrada precisa.",
                                    "Compile, execute e teste com diferentes inputs."
                                  ],
                                  "verification": "Programa lê um char do teclado e o imprime corretamente 5 vezes com inputs variados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Terminal para input/output"
                                  ],
                                  "tips": "Pressione Enter após input; %c lê um char incluindo espaços se não flush buffer.",
                                  "learningObjective": "Ler e escrever variáveis char usando funções de I/O padrão.",
                                  "commonMistakes": "Esquecer & no scanf (crash); usar %s para char (lê string)."
                                }
                              ],
                              "practicalExample": "#include <stdio.h>\\nint main() {\\n    char inicial;\\n    printf(\"Digite uma letra inicial: \");\\n    scanf(\"%c\", &inicial);\\n    printf(\"Sua inicial é: %c (código ASCII: %d)\\n\", inicial, (int)inicial);\\n    return 0;\\n}\\n// Exemplo de saída: Digite uma letra inicial: J\\n// Sua inicial é: J (código ASCII: 74)",
                              "finalVerifications": [
                                "Declara char sem erros de sintaxe.",
                                "Atribui literal char corretamente.",
                                "Atribui valor de input via scanf.",
                                "Imprime char com %c sem garbage.",
                                "Converte char para int (código ASCII) e vice-versa.",
                                "Diferencia char de string em uso prático."
                              ],
                              "assessmentCriteria": [
                                "Código compila e executa sem warnings/erros.",
                                "Entrada/saída funcionam para letras, dígitos e símbolos.",
                                "Uso correto de & em scanf para char.",
                                "Explicação oral do código ASCII.",
                                "Identifica e corrige 3 erros comuns em códigos fornecidos.",
                                "Programa completo com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Códigos ASCII e conversão numérica (char para int).",
                                "Língua Portuguesa: Manipulação de letras maiúsculas/minúsculas e acentos.",
                                "Artes: Representação gráfica de caracteres em interfaces.",
                                "Física: Codificação binária de símbolos (bits para chars)."
                              ],
                              "realWorldApplication": "Em software de validação de senhas (verificar caracteres especiais), jogos (teclas pressionadas como 'W' para mover), editores de texto (armazenar caractere cursor) e sistemas de login (ler inicial do usuário)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.4",
                        "name": "Tipo Lógico",
                        "description": "O tipo lógico (bool) é um tipo escalar primitivo que representa apenas dois valores: verdadeiro (true) ou falso (false). Características: ocupa 1 byte tipicamente, essencial para estruturas condicionais e repetitivas, resultado de expressões booleanas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.4.1",
                            "name": "Definir e caracterizar o tipo lógico",
                            "description": "Descrever o tipo bool, seus valores possíveis (true/false), representação interna e importância na lógica de programação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de tipo lógico",
                                  "subSteps": [
                                    "Leia a definição de tipo lógico como um tipo de dado que representa valores de verdade.",
                                    "Compare com tipos numéricos e de texto para destacar diferenças.",
                                    "Anote exemplos cotidianos de situações verdadeiras ou falsas.",
                                    "Pesquise brevemente a origem do termo 'booleano' em honra a George Boole.",
                                    "Discuta em voz alta: 'Por que precisamos de um tipo específico para verdadeiro/falso?'"
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e compare com referências padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagem de programação (ex: Python bool), caderno para anotações"
                                  ],
                                  "tips": "Use analogias simples como interruptor ligado/desligado para fixar o conceito.",
                                  "learningObjective": "Definir tipo lógico e diferenciá-lo de outros tipos primitivos.",
                                  "commonMistakes": "Confundir com inteiros (0/1 não são sinônimos exatos de false/true)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar valores possíveis do tipo bool",
                                  "subSteps": [
                                    "Liste os dois únicos valores: true e false.",
                                    "Declare variáveis bool em uma linguagem simples (ex: Python: a = True; b = False).",
                                    "Imprima os valores para visualizar na tela.",
                                    "Teste atribuições e observe case sensitivity (True vs true).",
                                    "Crie uma tabela comparando true/false com representações numéricas implícitas."
                                  ],
                                  "verification": "Execute código que exibe true e false corretamente sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código online (Replit, CodePen), documentação oficial de bool"
                                  ],
                                  "tips": "Sempre use maiúsculas iniciais em linguagens como Python/C++ para evitar erros.",
                                  "learningObjective": "Reconhecer e usar os valores true/false em código.",
                                  "commonMistakes": "Usar minúsculas ou strings 'true' em vez de valores bool nativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a representação interna do tipo bool",
                                  "subSteps": [
                                    "Aprenda que bool é representado por 1 byte (8 bits) na maioria das linguagens.",
                                    "Visualize em binário: true como 0x01 (00000001), false como 0x00 (00000000).",
                                    "Use ferramentas como debugger para inspecionar memória de uma variável bool.",
                                    "Compare tamanhos: sizeof(bool) == 1 em C/C++.",
                                    "Discuta otimizações: às vezes armazenado como int para performance."
                                  ],
                                  "verification": "Confirme o tamanho em memória executando código com sizeof ou sys.getsizeof().",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C/Python com debugger, diagramas de bits online"
                                  ],
                                  "tips": "Desenhe bits em papel para visualizar representação binária.",
                                  "learningObjective": "Descrever como bool é armazenado em memória.",
                                  "commonMistakes": "Achar que bool ocupa 0 bits ou é sempre 1 bit sem padding."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer a importância na lógica de programação",
                                  "subSteps": [
                                    "Identifique usos em condicionais (if/else), loops (while) e operadores lógicos.",
                                    "Escreva código simples com &&, ||, ! operando em bools.",
                                    "Analise fluxogramas onde decisões dependem de bools.",
                                    "Reflita: sem bool, como faríamos condições? (usando ints hacky).",
                                    "Pesquise exemplos reais: validação de login (isAuthenticated = true)."
                                  ],
                                  "verification": "Crie e execute um programa que usa bool em uma decisão lógica correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código, exemplos de código de condicionais"
                                  ],
                                  "tips": "Comece com expressões simples antes de compor com operadores.",
                                  "learningObjective": "Explicar papel do bool em controle de fluxo e lógica.",
                                  "commonMistakes": "Ignorar precedência de operadores lógicos levando a resultados inesperados."
                                }
                              ],
                              "practicalExample": "Em Python: def is_adult(age): return age >= 18  # Retorna bool. if is_adult(20): print('Acesso liberado')  # Usa bool em if.",
                              "finalVerifications": [
                                "Defina 'tipo lógico' corretamente em uma frase.",
                                "Liste valores possíveis e dê exemplos de código.",
                                "Explique representação interna com tamanho em bytes.",
                                "Descreva 3 usos na programação.",
                                "Diferencie bool de int em contexto lógico.",
                                "Identifique erro em código com bool mal usado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e valores (100% correto).",
                                "Compreensão de representação interna (bits/bytes).",
                                "Exemplos práticos relevantes e sem erros.",
                                "Explicação clara da importância lógica.",
                                "Uso correto de terminologia (true/false, não 1/0).",
                                "Conexões com controle de fluxo demonstradas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Booleana e tabelas-verdade.",
                                "Física: Circuitos lógicos e portas AND/OR.",
                                "Filosofia: Conceitos de verdade e falsidade.",
                                "Lógica: Raciocínio dedutivo e proposições."
                              ],
                              "realWorldApplication": "Em software, bools controlam autenticação de usuários (isLoggedIn), validações de formulários (isValidEmail) e automações como 'se estoque baixo, reabastecer', essenciais em apps bancários, jogos e IA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.4.2",
                            "name": "Identificar expressões lógicas",
                            "description": "Construir e avaliar expressões lógicas com operadores AND, OR, NOT e relacionais, identificando resultados booleanos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender operadores lógicos e relacionais básicos",
                                  "subSteps": [
                                    "Liste os operadores relacionais: == (igual), != (diferente), > (maior), < (menor), >= (maior ou igual), <= (menor ou igual).",
                                    "Liste os operadores lógicos: AND (conjunção), OR (disjunção), NOT (negação).",
                                    "Memorize os valores de verdade: true (verdadeiro) ou false (falso).",
                                    "Crie uma tabela verdade simples para AND e OR com dois operandos booleanos.",
                                    "Explique verbalmente como NOT inverte o valor booleano."
                                  ],
                                  "verification": "Crie e complete tabelas verdade para AND, OR e NOT sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples; tabela verdade impressa como referência.",
                                  "tips": "Use símbolos claros como ∧ para AND, ∨ para OR e ¬ para NOT para visualização.",
                                  "learningObjective": "Identificar e descrever corretamente todos os operadores lógicos e relacionais e seus resultados básicos.",
                                  "commonMistakes": "Confundir operadores relacionais com lógicos; esquecer que NOT aplica a um único operando."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir expressões lógicas simples",
                                  "subSteps": [
                                    "Combine dois valores booleanos com AND: ex. true AND false.",
                                    "Combine com OR: ex. false OR true.",
                                    "Aplique NOT: ex. NOT true.",
                                    "Use operadores relacionais em números: ex. 5 > 3.",
                                    "Misture relacionais com lógicos: ex. (5 > 3) AND (2 < 1)."
                                  ],
                                  "verification": "Escreva 5 expressões simples e anote o resultado booleano esperado para cada uma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora simples ou interpretador online (ex. Python REPL para testar).",
                                  "tips": "Sempre use parênteses em misturas para evitar confusão inicial com precedência.",
                                  "learningObjective": "Construir expressões lógicas básicas usando operadores relacionais e lógicos.",
                                  "commonMistakes": "Esquecer parênteses em expressões compostas; confundir ordem de avaliação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar expressões considerando precedência e parênteses",
                                  "subSteps": [
                                    "Aprenda a precedência: parênteses > NOT > AND > OR.",
                                    "Avalie sem parênteses: ex. true AND false OR true (resultado true).",
                                    "Use parênteses para alterar: ex. (true AND false) OR true (true).",
                                    "Teste em pseudocódigo ou código real: if (idade >= 18 AND renda > 1000) { permitir(); }.",
                                    "Crie 3 expressões complexas e avalie passo a passo."
                                  ],
                                  "verification": "Avalie corretamente 5 expressões com precedência e parênteses, mostrando passos intermediários.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código online (ex. Replit com Python ou JavaScript); papel para rascunhos.",
                                  "tips": "Avalie da esquerda para direita para operadores de mesma precedência; pratique com tabelas verdade expandidas.",
                                  "learningObjective": "Avaliar o resultado booleano de expressões considerando regras de precedência.",
                                  "commonMistakes": "Ignorar precedência (ex. avaliar AND antes de OR incorretamente); erros em NOT duplo (NOT NOT true = true)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar expressões em cenários práticos",
                                  "subSteps": [
                                    "Crie expressões para validações: ex. (senha.length > 8) AND (temMaiuscula == true).",
                                    "Teste com valores reais e registre resultados booleanos.",
                                    "Identifique expressões equivalentes: ex. NOT (A AND B) == (NOT A) OR (NOT B).",
                                    "Debugue expressões erradas: corrija uma que retorne false inesperado.",
                                    "Resolva 3 problemas: preveja resultados sem executar."
                                  ],
                                  "verification": "Implemente e teste 4 expressões em um snippet de código, confirmando resultados booleanos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ambiente de programação (Python, JS console); exemplos de código prontos.",
                                  "tips": "Use console.log ou print para verificar resultados booleanos imediatamente.",
                                  "learningObjective": "Construir, avaliar e depurar expressões lógicas em contextos aplicados.",
                                  "commonMistakes": "Não testar com todos os casos (true/true, true/false, etc.); confundir == com = em código."
                                }
                              ],
                              "practicalExample": "Em um sistema de login: if ((usuario.idade >= 18) AND (usuario.ehPremium OR usuario.tentativas < 3)) { acessar(); } else { negar(); }. Avalie para idade=20, ehPremium=false, tentativas=2 (resultado: true).",
                              "finalVerifications": [
                                "Lista corretamente todos os operadores lógicos e relacionais com exemplos.",
                                "Avalia 10 expressões mistas sem erros, incluindo precedência.",
                                "Constrói 5 expressões originais para cenários dados e prevê resultados booleanos.",
                                "Explica leis de De Morgan com exemplos simples.",
                                "Depura uma expressão complexa identificando o erro lógico.",
                                "Cria tabela verdade completa para uma expressão com 3 operandos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na avaliação de resultados booleanos (90%+ correto).",
                                "Uso correto de precedência e parênteses em construções.",
                                "Capacidade de criar expressões equivalentes ou simplificadas.",
                                "Identificação de erros comuns em expressões dadas.",
                                "Aplicação prática em pseudocódigo ou código real sem falhas.",
                                "Explicação clara de raciocínio em avaliações passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e tabelas verdade.",
                                "Filosofia: Raciocínio lógico e silogismos.",
                                "Engenharia: Condições em fluxogramas e automação.",
                                "Linguagens Naturais: Análise de frases condicionais (se-então)."
                              ],
                              "realWorldApplication": "Validações de formulários web (ex. email válido AND senha forte), regras de negócio em software (ex. aprovação de empréstimo: renda > limite AND score > 700), filtros de busca em bancos de dados (ex. idade BETWEEN 18 AND 65 OR vip=true), e circuitos digitais em hardware."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.4.3",
                            "name": "Declarar e atribuir variáveis lógicas",
                            "description": "Declarar variáveis bool, atribuir valores lógicos e usar em comandos condicionais simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos básicos de variáveis lógicas",
                                  "subSteps": [
                                    "Estude o que é uma variável lógica (booleana): representa valores verdadeiro (true) ou falso (false).",
                                    "Aprenda os valores possíveis: true (verdadeiro) e false (falso).",
                                    "Identifique onde são usadas: em condições, comparações e lógica de decisão.",
                                    "Revise operadores lógicos simples: == (igual), != (diferente), >, <, >=, <=",
                                    "Exemplo: 5 > 3 resulta em true."
                                  ],
                                  "verification": "Responda corretamente a um quiz com 5 perguntas sobre true/false e operadores.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Material didático sobre tipos de dados booleanos, vídeo introdutório (ex: Khan Academy).",
                                  "tips": "Lembre-se: booleanos são o coração das decisões em programação.",
                                  "learningObjective": "Compreender o papel e os valores das variáveis lógicas.",
                                  "commonMistakes": "Confundir true/false com strings 'true'/'false'; ignorar maiúsculas/minúsculas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar variáveis lógicas",
                                  "subSteps": [
                                    "Aprenda a sintaxe de declaração: em Python, use 'eh_valido = True' ou 'ativo = False'.",
                                    "Pratique declarando 3 variáveis lógicas sem atribuição inicial.",
                                    "Use nomes descritivos: 'isLoggedIn', 'ehPar', 'temEstoque'.",
                                    "Teste declaração em um editor de código.",
                                    "Compile e execute para verificar erros de sintaxe."
                                  ],
                                  "verification": "Código declara variável bool sem erros e roda sem exceção.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor Python online (Replit ou Google Colab), documentação Python types.",
                                  "tips": "Sempre use snake_case para nomes de variáveis em Python.",
                                  "learningObjective": "Declarar corretamente variáveis do tipo booleano.",
                                  "commonMistakes": "Esquecer tipo ou usar aspas em true/false (torna string)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atribuir e modificar valores lógicos",
                                  "subSteps": [
                                    "Atribua valores iniciais: eh_maior = 10 > 5  # resulta em True",
                                    "Modifique valores: eh_maior = False",
                                    "Use expressões booleanas: idade >= 18 resulta em True/False",
                                    "Pratique com input do usuário: idade = int(input()); adulto = idade >= 18",
                                    "Exiba o valor com print(eh_maior)"
                                  ],
                                  "verification": "Programa atribui e imprime valores corretos para 3 cenários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ambiente Python interativo, exemplos de código prontos.",
                                  "tips": "Teste expressões no interpretador Python antes de codificar.",
                                  "learningObjective": "Atribuir valores lógicos via literais ou expressões.",
                                  "commonMistakes": "Usar = em vez de == em comparações; atribuir números a bool."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Usar variáveis lógicas em comandos condicionais simples",
                                  "subSteps": [
                                    "Estruture um if simples: if variavel_logica: print('Sim')",
                                    "Adicione else: else: print('Não')",
                                    "Integre com input: nota = float(input()); aprovado = nota >= 7; if aprovado: ...",
                                    "Teste com múltiplos casos (true e false).",
                                    "Debugue erros comuns como indentação."
                                  ],
                                  "verification": "Programa executa condicional corretamente para entradas variadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor Python, testes unitários simples.",
                                  "tips": "Use print() para debugar valores de variáveis antes do if.",
                                  "learningObjective": "Aplicar variáveis bool em estruturas if/else.",
                                  "commonMistakes": "Erro de indentação; esquecer dois pontos após if."
                                }
                              ],
                              "practicalExample": "Crie um programa que verifica se um número é par:\nn = int(input('Digite um número: '))\neh_par = n % 2 == 0\nif eh_par:\n    print('É par!')\nelse:\n    print('É ímpar!')\n# Teste com 4 (true) e 5 (false)",
                              "finalVerifications": [
                                "Declara variável bool corretamente sem erros de sintaxe.",
                                "Atribui valor lógico via expressão e exibe corretamente.",
                                "Usa variável em if/else com lógica correta.",
                                "Programa responde adequadamente a inputs true/false.",
                                "Identifica e corrige erros comuns em 3 tentativas.",
                                "Explica o fluxo de execução para um colega."
                              ],
                              "assessmentCriteria": [
                                "Correção da declaração e atribuição (30%)",
                                "Funcionamento do condicional (30%)",
                                "Uso de nomes descritivos e boas práticas (15%)",
                                "Tratamento de casos edge (true/false) (15%)",
                                "Clareza do código e comentários (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operadores relacionais e lógica proposicional.",
                                "Lógica: Tabelas-verdade e implicações booleanas.",
                                "Física: Modelagem de estados (ligado/desligado).",
                                "Português: Nomenclatura clara e descritiva de variáveis."
                              ],
                              "realWorldApplication": "Em apps de login (isAuthenticated), jogos (isGameOver), validações de formulários (isValidEmail) e automação (isDoorOpen em IoT)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Tipos Inteiros",
                    "description": "Representação, faixas de valores e operações com números inteiros.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Representação de Números Inteiros",
                        "description": "Como os números inteiros são armazenados em memória usando representação binária para positivos e complemento de dois para negativos, considerando o número de bits utilizados.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Converter decimal positivo para binário",
                            "description": "Realizar a conversão manual de um número inteiro decimal positivo para sua representação binária, utilizando divisão sucessiva por 2 e leitura dos restos de baixo para cima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Algoritmo de Conversão Decimal para Binário",
                                  "subSteps": [
                                    "Aprenda que o sistema binário usa base 2, com dígitos 0 e 1.",
                                    "Entenda o método: divida o número decimal por 2 sucessivamente e anote o resto (0 ou 1).",
                                    "Continue dividindo o quociente até que ele seja 0.",
                                    "Leia os restos de baixo para cima para formar o binário.",
                                    "Visualize com um diagrama simples de divisões."
                                  ],
                                  "verification": "Explique o processo em suas próprias palavras e demonstre com um exemplo simples como 5 (101).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional para verificação"
                                  ],
                                  "tips": "Sempre anote quociente e resto em colunas separadas para clareza.",
                                  "learningObjective": "Dominar a lógica por trás da divisão sucessiva e formação do binário.",
                                  "commonMistakes": [
                                    "Ler restos de cima para baixo",
                                    "Usar base errada (ex: dividir por 10)",
                                    "Ignorar o último resto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Iniciar as Divisões Sucessivas",
                                  "subSteps": [
                                    "Escolha um número decimal positivo inteiro (ex: 13).",
                                    "Divida o número por 2 e anote o quociente e o resto.",
                                    "Pegue o quociente e repita a divisão por 2, anotando novo resto.",
                                    "Continue até o quociente ser 0, registrando todos os restos.",
                                    "Mantenha uma tabela organizada: coluna para quociente, resto e número original."
                                  ],
                                  "verification": "Mostre a tabela completa de divisões com pelo menos 4 iterações para um número dado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Use uma tabela vertical para alinhar restos facilmente.",
                                  "learningObjective": "Executar divisões precisas e registrar restos corretamente.",
                                  "commonMistakes": [
                                    "Erros aritméticos na divisão",
                                    "Arredondar restos (sempre 0 ou 1)",
                                    "Parar antes do quociente zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Representação Binária",
                                  "subSteps": [
                                    "Liste os restos na ordem de baixo para cima (último resto é o bit mais significativo).",
                                    "Escreva o binário sem espaços ou separadores.",
                                    "Ignore leading zeros (não adicione zeros à esquerda desnecessários).",
                                    "Confirme o comprimento: deve ter log2(n)+1 bits aproximadamente.",
                                    "Escreva o binário final e compare com a lista de restos."
                                  ],
                                  "verification": "Escreva o binário resultante e confirme que corresponde aos restos invertidos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de restos do step anterior"
                                  ],
                                  "tips": "Pense nos restos como uma pilha: o último empilhado é lido primeiro.",
                                  "learningObjective": "Montar corretamente o binário a partir dos restos.",
                                  "commonMistakes": [
                                    "Inverter a ordem dos restos",
                                    "Adicionar zeros extras à esquerda",
                                    "Confundir MSB (mais significativo) com LSB"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Praticar a Conversão",
                                  "subSteps": [
                                    "Converta o binário de volta para decimal para validar (multiplique por potências de 2).",
                                    "Teste com 3 números diferentes: pequeno (5), médio (13), maior (45).",
                                    "Compare seu resultado com uma ferramenta online ou calculadora.",
                                    "Registre erros e corrija-os.",
                                    "Explique por que a verificação reversa confirma a correção."
                                  ],
                                  "verification": "Converta 3 números com acerto total e valide reversamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou app de conversão para verificação",
                                    "Papel para prática"
                                  ],
                                  "tips": "Para verificação reversa: 1101 = 1*8 + 1*4 + 0*2 + 1*1 = 13.",
                                  "learningObjective": "Garantir precisão através de validação e prática iterativa.",
                                  "commonMistakes": [
                                    "Falhar na verificação reversa",
                                    "Não praticar números variados",
                                    "Confiar só no método sem validar"
                                  ]
                                }
                              ],
                              "practicalExample": "Converta 13 (decimal) para binário:\n- 13 ÷ 2 = 6, resto 1\n- 6 ÷ 2 = 3, resto 0\n- 3 ÷ 2 = 1, resto 1\n- 1 ÷ 2 = 0, resto 1\nLeia restos de baixo para cima: 1101 (binário). Verificação: 1*8 + 1*4 + 0*2 + 1*1 = 13.",
                              "finalVerifications": [
                                "Converteu corretamente 5 números de tamanhos variados sem erros.",
                                "Explicou o processo completo verbalmente ou por escrito.",
                                "Validou todas as conversões revertendo para decimal.",
                                "Identificou e corrigiu um erro comum simulado.",
                                "Criou uma tabela organizada para qualquer número dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas divisões e restos (100% correto).",
                                "Ordem correta dos restos (de baixo para cima).",
                                "Ausência de zeros leading desnecessários.",
                                "Validação reversa realizada e correta.",
                                "Tempo de execução eficiente e tabela clara.",
                                "Explicação do método sem hesitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Divisão euclidiana e restos (módulo 2).",
                                "Lógica e Programação: Loops while em algoritmos de conversão.",
                                "Física: Representação em circuitos digitais e flip-flops.",
                                "História da Computação: Base dos sistemas numéricos modernos."
                              ],
                              "realWorldApplication": "Essencial em programação para operações de bits (máscaras, shifts), desenvolvimento de hardware (ALUs), redes (endereços IP em binário) e depuração de código em assembly."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Representar números negativos em complemento de dois",
                            "description": "Aplicar o método de complemento de dois para representar números inteiros negativos em binário, invertendo bits e somando 1 ao resultado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar representação binária de números inteiros positivos",
                                  "subSteps": [
                                    "Escolha um número de bits fixo, como 8 bits, para todas as representações.",
                                    "Converta o número positivo para binário usando divisão sucessiva por 2.",
                                    "Adicione zeros à esquerda para completar o número de bits fixo.",
                                    "Verifique a conversão somando os valores posicionais (potências de 2).",
                                    "Pratique com 3 exemplos simples (ex: 5, 13, 7)."
                                  ],
                                  "verification": "Converta corretamente pelo menos 3 números positivos para binário de 8 bits sem erros.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou conversor binário online"
                                  ],
                                  "tips": [
                                    "Sempre comece pela divisão por 2 e leia os restos de baixo para cima.",
                                    "Use o número fixo de bits para evitar ambiguidades."
                                  ],
                                  "learningObjective": "Compreender e aplicar a conversão de decimais positivos para binário com largura fixa.",
                                  "commonMistakes": [
                                    "Esquecer de preencher com zeros à esquerda.",
                                    "Ler os restos na ordem errada.",
                                    "Confundir com representação hexadecimal."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a inverter bits (complemento de 1)",
                                  "subSteps": [
                                    "Pegue a representação binária do número positivo de 8 bits.",
                                    "Inverta cada bit: 0 vira 1 e 1 vira 0.",
                                    "Registre o resultado como complemento de 1.",
                                    "Compare com o original para garantir que todos os bits foram invertidos.",
                                    "Repita com 2 exemplos do passo anterior."
                                  ],
                                  "verification": "Inverta corretamente o binário de pelo menos 2 números positivos e identifique diferenças.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de bits para referência"
                                  ],
                                  "tips": [
                                    "Pense em 'NOT lógico' para cada bit individualmente.",
                                    "Não inverta o sinal do número, apenas os bits."
                                  ],
                                  "learningObjective": "Dominar a operação de inversão de bits como base para complemento de dois.",
                                  "commonMistakes": [
                                    "Deixar bits à esquerda inalterados.",
                                    "Confundir inversão com adição.",
                                    "Usar número variável de bits."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar complemento de dois: somar 1 ao complemento de 1",
                                  "subSteps": [
                                    "Comece com o complemento de 1 do número positivo.",
                                    "Some 1 ao resultado, aplicando carry bit por bit da direita para a esquerda.",
                                    "Ignore o carry final que sai do bit mais significativo (overflow).",
                                    "Verifique se o resultado tem o número correto de bits.",
                                    "Teste com os mesmos exemplos dos passos anteriores."
                                  ],
                                  "verification": "Calcule o complemento de dois corretamente para 3 números positivos e valide o processo.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Simulador de soma binária online"
                                  ],
                                  "tips": [
                                    "Trate a soma como adição binária padrão, propagando carries.",
                                    "O carry final confirma que é um negativo correto."
                                  ],
                                  "learningObjective": "Executar o processo completo de complemento de dois para representação de negativos.",
                                  "commonMistakes": [
                                    "Parar o carry prematuramente.",
                                    "Esquecer de somar exatamente 1.",
                                    "Alterar o número de bits durante a soma."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e praticar conversão de complemento de dois de volta para decimal",
                                  "subSteps": [
                                    "Pegue uma representação em complemento de dois (ex: de exemplos anteriores).",
                                    "Se o bit mais significativo for 1, subtraia 2^n do valor binário positivo (n=7 para 8 bits).",
                                    "Ou aplique complemento de dois novamente para obter o positivo e adicione sinal negativo.",
                                    "Valide com pelo menos 3 exemplos, incluindo verificação de soma zero (positivo + negativo).",
                                    "Registre erros e corrija."
                                  ],
                                  "verification": "Converta de volta 3 representações negativas para decimal corretamente e verifique soma zero.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de potências de 2"
                                  ],
                                  "tips": [
                                    "Soma de um número e seu negativo sempre dá zero (com overflow ignorado).",
                                    "Pratique verificação bidirecional."
                                  ],
                                  "learningObjective": "Validar representações em complemento de dois através de conversões reversas.",
                                  "commonMistakes": [
                                    "Ignorar o bit de sinal na verificação.",
                                    "Confundir subtração de 2^n com adição.",
                                    "Não testar soma para zero."
                                  ]
                                }
                              ],
                              "practicalExample": "Represente -13 em 8 bits:\n1. 13 decimal = 00001101 binário.\n2. Complemento de 1: 11110010.\n3. Somar 1: 11110010 + 00000001 = 11110011.\nVerificação: 11110011 + 00001101 = 1 00000000 (carry de 1 indica correto).",
                              "finalVerifications": [
                                "Represente -5 em 8 bits como 11111011.",
                                "Converta 11110100 (8 bits) de volta para -12 decimal.",
                                "Verifique que 00000101 + 11111011 = 1 00000000.",
                                "Identifique erros em representações comuns como 11110010 (-14 incorreto).",
                                "Explique por que complemento de dois permite soma uniforme."
                              ],
                              "assessmentCriteria": [
                                "Precisão na conversão inicial para binário positivo (sem erros de bits).",
                                "Correta inversão de todos os bits no complemento de 1.",
                                "Adição de 1 com propagação correta de carries.",
                                "Validação bidirecional (decimal -> binário -> decimal).",
                                "Uso consistente de largura fixa de bits (ex: 8 bits).",
                                "Explicação clara do processo em palavras próprias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e potências de 2.",
                                "Eletrônica: Portas lógicas NOT e ADD em circuitos digitais.",
                                "Programação: Operações com inteiros signed em linguagens como C ou Java.",
                                "Física: Representação de sinais em registradores de CPU."
                              ],
                              "realWorldApplication": "Em processadores de computadores e microcontroladores, o complemento de dois é o padrão para representar números negativos, permitindo operações aritméticas (soma, subtração) uniformes em hardware sem lógica especial para sinais, otimizando velocidade e simplicidade em aplicações como jogos, IA e sistemas embarcados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Identificar representação binária por número de bits",
                            "description": "Determinar a representação binária de um inteiro considerando um tamanho fixo de bits (ex: 8, 16, 32 bits) e o impacto na faixa de valores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conversão de decimal para binário",
                                  "subSteps": [
                                    "Explicar o sistema binário como base 2 (0s e 1s).",
                                    "Demonstrar método de divisão sucessiva por 2, lendo restos de baixo para cima.",
                                    "Praticar com números pequenos: converter 5, 13 e 42 para binário sem limite de bits.",
                                    "Verificar resultado somando potências de 2 correspondentes aos bits 1.",
                                    "Discutir representação sem sinal inicialmente."
                                  ],
                                  "verification": "Converter corretamente 3 números decimais dados (ex: 10, 25, 100) para binário e validar expandindo de volta para decimal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional",
                                    "Tabela de potências de 2 até 2^31"
                                  ],
                                  "tips": "Sempre divida o número inteiro por 2 e anote o resto (0 ou 1); leia os restos invertido.",
                                  "learningObjective": "Dominar o processo manual de conversão decimal-binário para inteiros positivos.",
                                  "commonMistakes": [
                                    "Ler restos da esquerda para direita",
                                    "Esquecer de incluir o bit menos significativo",
                                    "Confundir com base 10"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar representação binária com tamanho fixo de bits",
                                  "subSteps": [
                                    "Identificar o número de bits fixo (ex: 8, 16, 32).",
                                    "Converter o número decimal para binário ilimitado.",
                                    "Adicionar zeros à esquerda (padding) até atingir exatamente o número de bits.",
                                    "Exemplificar com 42 em 8 bits: 00101010.",
                                    "Testar com números que excedem a capacidade (ex: 300 em 8 bits) e notar truncamento ou overflow."
                                  ],
                                  "verification": "Representar 5 números decimais (0-255) corretamente em 8 bits, sem erros de padding.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado para bits",
                                    "Ferramenta online de conversão binária para verificação (opcional)"
                                  ],
                                  "tips": "Conte os bits da direita para a esquerda; padding sempre à esquerda para MSB (Most Significant Bit).",
                                  "learningObjective": "Padronizar representações binárias para um comprimento fixo, simulando alocação de memória.",
                                  "commonMistakes": [
                                    "Padding à direita",
                                    "Não completar todos os bits",
                                    "Ignorar overflow em números grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular faixas de valores para diferentes números de bits",
                                  "subSteps": [
                                    "Para unsigned: faixa de 0 a 2^n - 1 (ex: 8 bits = 0 a 255).",
                                    "Para signed (two's complement): -2^{n-1} a 2^{n-1} - 1 (ex: 8 bits = -128 a 127).",
                                    "Calcular exemplos: 16 bits unsigned (0-65535), 32 bits signed (-2^31 a 2^31-1).",
                                    "Listar faixas em tabela para 8, 16, 32 bits (unsigned e signed).",
                                    "Converter extremos: 127 e -128 em 8 bits signed."
                                  ],
                                  "verification": "Preencher tabela com faixas corretas para 8, 16 e 32 bits, tanto unsigned quanto signed.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de potências de 2 impressa",
                                    "Planilha Excel para cálculos"
                                  ],
                                  "tips": "Memorize fórmulas: unsigned max = 2^n -1; signed min = -2^{n-1}.",
                                  "learningObjective": "Compreender limites numéricos impostos pelo tamanho de bits em representações signed e unsigned.",
                                  "commonMistakes": [
                                    "Confundir signed com unsigned",
                                    "Erro em expoentes (ex: 2^8=256, não 255)",
                                    "Esquecer sinal negativo no min signed"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos da escolha do número de bits",
                                  "subSteps": [
                                    "Discutir overflow: o que acontece se valor excede faixa (wrap-around).",
                                    "Comparar eficiência: 8 bits para pixels vs 32 bits para coordenadas.",
                                    "Explorar trade-offs: mais bits = maior faixa mas mais memória.",
                                    "Simular erro: tente representar 300 em 8 bits unsigned e discuta consequências.",
                                    "Relacionar com linguagens: int em C++ (32 bits) vs short (16 bits)."
                                  ],
                                  "verification": "Explicar em parágrafo curto o impacto de usar 8 bits vs 32 bits para armazenar idades humanas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de código simples em Python (bin(42))",
                                    "Diagrama de memória"
                                  ],
                                  "tips": "Pense em aplicações reais: economia de espaço em bancos de dados.",
                                  "learningObjective": "Avaliar implicações práticas do tamanho de bits na precisão e armazenamento.",
                                  "commonMistakes": [
                                    "Ignorar diferenças signed/unsigned em impactos",
                                    "Subestimar overflow em cenários reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Converta o número decimal 42 para representação binária em 8 bits (unsigned): 00101010. Calcule a faixa para 8 bits unsigned (0-255) e signed (-128 a 127). Note que 42 cabe em ambos, mas 300 causaria overflow em 8 bits.",
                              "finalVerifications": [
                                "Converteu corretamente 5 decimais aleatórios para binário com padding de 8 bits.",
                                "Calculou faixas precisas para 8, 16 e 32 bits (unsigned e signed).",
                                "Identificou overflow em pelo menos 2 exemplos.",
                                "Explicou impacto de bits em uma aplicação real.",
                                "Validou representações revertendo binário para decimal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na conversão decimal-binário (100% correto).",
                                "Correto padding e contagem de bits.",
                                "Fórmulas de faixa aplicadas sem erros aritméticos.",
                                "Análise de impactos clara e relevante.",
                                "Uso adequado de signed vs unsigned.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Potências de 2 e aritmética modular.",
                                "Física: Representação em circuitos lógicos e registradores.",
                                "Programação: Limites de tipos primitivos em linguagens como C/Python.",
                                "Engenharia: Otimização de memória em embedded systems."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, escolher 32 bits para inteiros evita overflow em cálculos financeiros; em IoT, 8 bits economiza bateria em sensores de temperatura (-128 a 127°C)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Faixas de Valores dos Tipos Inteiros",
                        "description": "Faixas de valores suportadas por diferentes tipos inteiros (short, int, long) em linguagens como C++, incluindo signed e unsigned, calculadas com base no número de bits.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Calcular faixa de valores para inteiros com sinal",
                            "description": "Calcular a faixa mínima e máxima para um tipo inteiro com sinal de n bits usando as fórmulas -2^(n-1) a 2^(n-1)-1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a representação de inteiros com sinal em two's complement",
                                  "subSteps": [
                                    "Revise como os inteiros sem sinal usam todos os bits para magnitude.",
                                    "Aprenda que em inteiros com sinal, o bit mais significativo (MSB) é o bit de sinal: 0 para positivo/zero, 1 para negativo.",
                                    "Estude o two's complement: inverta bits e adicione 1 para negativos.",
                                    "Identifique que para n bits, há 2^n combinações possíveis, divididas entre positivos, negativos e zero.",
                                    "Pratique convertendo números pequenos (ex: 4 bits) para binário com sinal."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que o bit de sinal permite representar negativos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Tabela de two's complement para 4-8 bits"
                                  ],
                                  "tips": "Comece com 4 bits para visualizar facilmente: faixa de -8 a 7.",
                                  "learningObjective": "Compreender o papel do bit de sinal e two's complement na representação.",
                                  "commonMistakes": [
                                    "Confundir com representação por sinal-magnitude",
                                    "Ignorar que zero usa bit de sinal 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula para o valor mínimo (mais negativo)",
                                  "subSteps": [
                                    "Considere o número com todos os bits em 1: 111...1 (n bits).",
                                    "No two's complement, isso representa -2^(n-1), pois inverte para 000...0 e +1 = 1, mas como negativo é -1.",
                                    "Geralize: o menor valor ocorre quando MSB=1 e o resto maximiza o complemento.",
                                    "Calcule para n=4: 1000 binário = -8 = -2^3.",
                                    "Confirme a fórmula: mínimo = -2^(n-1)."
                                  ],
                                  "verification": "Calcule manualmente o valor de 1000...0 (n bits) e confirme como -2^(n-1).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha com potências de 2"
                                  ],
                                  "tips": "Lembre: 2^(n-1) é o peso do bit de sinal quando negativo.",
                                  "learningObjective": "Derivar e justificar a fórmula do valor mínimo.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo",
                                    "Usar 2^n em vez de 2^(n-1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a fórmula para o valor máximo (mais positivo)",
                                  "subSteps": [
                                    "O máximo é 0111...1 (MSB=0, resto 1s): soma de 2^(n-2) + ... + 2^0 = 2^(n-1) - 1.",
                                    "Para n=4: 0111 = 7 = 8-1 = 2^3 -1.",
                                    "Note que positivos vão de 0 a 2^(n-1)-1, negativos de -1 a -2^(n-1).",
                                    "Some o número de positivos e negativos: 2^(n-1) cada, mais zero.",
                                    "Pratique para n=8: máximo 127."
                                  ],
                                  "verification": "Converta 0111...1 para decimal e confirme 2^(n-1)-1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de potências de 2"
                                  ],
                                  "tips": "Máximo = (2^(n-1) -1), pois um bit é 'sacrificado' para sinal.",
                                  "learningObjective": "Derivar e justificar a fórmula do valor máximo.",
                                  "commonMistakes": [
                                    "Incluir 2^(n-1) no máximo",
                                    "Confundir com inteiros sem sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar as fórmulas em cálculos práticos",
                                  "subSteps": [
                                    "Calcule faixa para n=8, 16, 32 bits usando fórmulas.",
                                    "Ex: n=8: min=-128, max=127.",
                                    "Compare com inteiros sem sinal (0 a 255 para 8 bits).",
                                    "Resolva problemas: 'Qual a faixa de int32?' (-2^31 a 2^31-1).",
                                    "Teste em código simples (opcional, se disponível)."
                                  ],
                                  "verification": "Liste faixas corretas para 3 valores de n diferentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Editor de texto ou IDE para verificação opcional"
                                  ],
                                  "tips": "Memorize: signed n-bit = -2^(n-1) to 2^(n-1)-1.",
                                  "learningObjective": "Aplicar fórmulas com precisão para vários n.",
                                  "commonMistakes": [
                                    "Erro em expoente: n-1 vs n",
                                    "Esquecer -1 no máximo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um inteiro com sinal de 8 bits (int8): mínimo = -2^(8-1) = -128 (10000000 em binário), máximo = 2^7 - 1 = 127 (01111111 em binário). Isso é usado em linguagens como C para tipos char ou short.",
                              "finalVerifications": [
                                "Calcule corretamente a faixa para n=32: -2147483648 a 2147483647.",
                                "Explique por que não há +128 em 8 bits signed.",
                                "Converta -1 (8 bits) para binário: 11111111.",
                                "Identifique overflow se tentar armazenar 128 em int8.",
                                "Compare faixas signed vs unsigned para n=16."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas: uso correto de 2^(n-1).",
                                "Justificativa baseada em two's complement.",
                                "Cálculos exatos para múltiplos n sem erros aritméticos.",
                                "Entendimento assimétrico: um negativo extra.",
                                "Aplicação contextual em programação.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Potenciação e soma de séries geométricas (2^0 a 2^(n-2)).",
                                "Física: Limites em simulações numéricas (ex: posições em modelagem).",
                                "Programação: Gerenciamento de overflow em algoritmos.",
                                "Eletrônica: Representação em registradores de hardware."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, conhecer essas faixas previne bugs de overflow, como em cálculos financeiros (ex: saldos negativos em bancos) ou jogos (posições de personagens em coordenadas signed), garantindo que apps como editores de imagem ou sistemas embarcados lidem corretamente com valores dentro dos limites de tipos como int32."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Calcular faixa para inteiros sem sinal",
                            "description": "Determinar a faixa de 0 a 2^n - 1 para tipos unsigned com n bits e comparar com signed.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de inteiros sem sinal (unsigned)",
                                  "subSteps": [
                                    "Defina o que são inteiros unsigned: números inteiros não negativos representados em binário puro.",
                                    "Explique que com n bits, todos os bits representam magnitude, sem sinal.",
                                    "Discuta que o valor mínimo é sempre 0.",
                                    "Identifique que o valor máximo é quando todos os bits estão em 1.",
                                    "Represente em binário: para n=3, 111 binário = 7 decimal."
                                  ],
                                  "verification": "Escreva uma definição clara e represente 3 bits unsigned em binário e decimal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora binária opcional",
                                    "Tabela de potências de 2"
                                  ],
                                  "tips": "Lembre-se: unsigned usa todos os bits para valor, sem bit de sinal.",
                                  "learningObjective": "Compreender a representação binária de inteiros unsigned e seu valor mínimo.",
                                  "commonMistakes": [
                                    "Confundir com signed, achando que há bit de sinal",
                                    "Esquecer que mínimo é 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula da faixa máxima para unsigned",
                                  "subSteps": [
                                    "Liste as potências de 2: 2^0=1, 2^1=2, 2^2=4, etc.",
                                    "Mostre que n bits em 1 representam 2^n - 1.",
                                    "Derive: soma de série geométrica 2^0 + 2^1 + ... + 2^{n-1} = 2^n - 1.",
                                    "Confirme com exemplo: n=8, 2^8 - 1 = 255.",
                                    "Escreva a fórmula geral: faixa de 0 a 2^n - 1."
                                  ],
                                  "verification": "Derive e escreva a fórmula para n=4, confirmando 0-15.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com potências de 2",
                                    "Calculadora para potências"
                                  ],
                                  "tips": "Use a fórmula de soma geométrica para memorizar 2^n - 1.",
                                  "learningObjective": "Derivar e memorizar a fórmula exata para a faixa máxima de unsigned n bits.",
                                  "commonMistakes": [
                                    "Calcular 2^n em vez de 2^n -1",
                                    "Confundir com máximo de signed"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular faixas para tipos unsigned comuns",
                                  "subSteps": [
                                    "Calcule para uint8 (n=8): 0 a 255.",
                                    "Calcule para uint16 (n=16): 0 a 65.535.",
                                    "Calcule para uint32 (n=32): 0 a 4.294.967.295.",
                                    "Calcule para uint64 (n=64): 0 a 18.446.744.073.709.551.615.",
                                    "Tabule os resultados em uma tabela."
                                  ],
                                  "verification": "Crie uma tabela com faixas corretas para uint8, uint16, uint32.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou papel para tabela"
                                  ],
                                  "tips": "Memorize atalhos: uint8=255, uint16=65k, uint32=4G, uint64=18Q.",
                                  "learningObjective": "Aplicar a fórmula para calcular faixas de tipos unsigned padrão.",
                                  "commonMistakes": [
                                    "Erros de cálculo em potências grandes",
                                    "Adicionar 1 extra"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar faixas unsigned com signed",
                                  "subSteps": [
                                    "Lembre signed: n bits, metade positiva (0 a 2^{n-1}-1), metade negativa (-2^{n-1} a 0).",
                                    "Compare uint8 (0-255) vs int8 (-128 a 127).",
                                    "Compare uint16 (0-65535) vs int16 (-32768 a 32767).",
                                    "Discuta vantagens: unsigned dobra o range positivo.",
                                    "Identifique quando usar cada: unsigned para contadores não-negativos."
                                  ],
                                  "verification": "Crie tabela comparativa para 8, 16 bits, destacando diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela anterior de unsigned",
                                    "Referência de faixas signed"
                                  ],
                                  "tips": "Signed reserva 1 bit para sinal, unsigned usa todos para magnitude.",
                                  "learningObjective": "Comparar faixas e entender trade-offs entre unsigned e signed.",
                                  "commonMistakes": [
                                    "Invertir ranges signed",
                                    "Ignorar o dobro de range positivo em unsigned"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C++, declare uint8_t contador = 255; // Máximo para 8 bits. Ao incrementar, rola para 0 (overflow). Compare com int8_t que vai para -128.",
                              "finalVerifications": [
                                "Calcule corretamente 2^32 - 1 = 4.294.967.295.",
                                "Explique por que uint8 vai de 0 a 255.",
                                "Compare faixa uint16 vs int16 em uma frase.",
                                "Identifique overflow em unsigned: volta a 0.",
                                "Liste 3 cenários onde unsigned é preferível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula 2^n - 1 (100% correto).",
                                "Cálculos exatos para pelo menos 3 tamanhos de bits.",
                                "Comparação clara e correta com signed.",
                                "Uso correto de terminologia (unsigned, bits, range).",
                                "Explicação de aplicações práticas.",
                                "Ausência de erros comuns como confundir com 2^n."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Potenciação e séries geométricas.",
                                "Programação: Declaração de variáveis em linguagens como C/C++ ou Java.",
                                "Eletrônica: Representação binária em registradores de hardware.",
                                "Lógica: Compreensão de overflow e wrap-around."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software embarcado, use uint32_t para contadores de tempo (ex: microssegundos desde boot), evitando valores negativos e maximizando range positivo para aplicações como IoT ou jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Identificar faixas de tipos comuns em C++",
                            "description": "Memorizar e aplicar faixas típicas: short (16 bits), int (32 bits), long (64 bits) em sistemas comuns.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender tamanhos em bits e representação assinada",
                                  "subSteps": [
                                    "Explicar que short usa 16 bits, int usa 32 bits e long usa 64 bits em sistemas comuns (x86-64).",
                                    "Aprender representação em complemento de dois para números assinados.",
                                    "Calcular faixas: para n bits, máximo = 2^(n-1) - 1, mínimo = -2^(n-1).",
                                    "Exemplificar: short (16 bits): -32768 a 32767.",
                                    "Diferenciar signed de unsigned (ex: unsigned short: 0 a 65535)."
                                  ],
                                  "verification": "Escrever fórmulas e faixas manualmente sem consultar referências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para potências de 2"
                                  ],
                                  "tips": "Memorize potências de 2: 2^10=1024, 2^15=32768, 2^31=2147483648.",
                                  "learningObjective": "Entender como bits definem faixas de valores para tipos inteiros assinados.",
                                  "commonMistakes": "Confundir bits com bytes (1 byte=8 bits); ignorar sinalização (pensar só em positivos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar faixas exatas dos tipos comuns",
                                  "subSteps": [
                                    "Listar: short (-32768 a 32767), int (-2147483648 a 2147483647), long (-9223372036854775808 a 9223372036854775807).",
                                    "Criar mnemônicos: 'short: 32k', 'int: 2 bi', 'long: 9 quintilhões'.",
                                    "Repetir recitação 10 vezes, cobrindo com papel para teste de memória.",
                                    "Comparar tamanhos: short < int <= long.",
                                    "Notar variações: use <climits> para portable."
                                  ],
                                  "verification": "Recitar faixas corretas em voz alta ou por escrito 3 vezes seguidas sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Flashcards (aplicativo como Anki)",
                                    "Tabela impressa de referências"
                                  ],
                                  "tips": "Associe com datas: 32767 ~ ano 32k, mas pratique diariamente por 5 min.",
                                  "learningObjective": "Fixar na memória as faixas padrão para uso imediato.",
                                  "commonMistakes": "Errar sinal do mínimo (ex: -32768 como 32768); confundir long com long long."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar faixas programaticamente em C++",
                                  "subSteps": [
                                    "Incluir <limits> e <iostream>.",
                                    "Usar std::numeric_limits<short>::min/max() e imprimir.",
                                    "Repetir para int e long.",
                                    "Compilar e executar em sistema 64-bit.",
                                    "Comparar saída com valores memorizados."
                                  ],
                                  "verification": "Programa compila e imprime faixas exatas matching as esperadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou online como Compiler Explorer)",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Use namespace std; para simplicidade; teste em diferentes plataformas se possível.",
                                  "learningObjective": "Aplicar conhecimento compilando código que confirma faixas reais.",
                                  "commonMistakes": "Esquecer #include <limits>; usar sizeof em vez de limits (sizeof dá bytes, não faixa)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e aplicação em cenários",
                                  "subSteps": [
                                    "Dado valor 50000, escolher tipo (int, não short).",
                                    "Simular overflow: atribuir 40000 a short e observar wrap-around.",
                                    "Criar função que retorna tipo ideal baseado em magnitude.",
                                    "Resolver 5 exercícios: 'Qual tipo para contador de população mundial?'.",
                                    "Debugar código com overflow intencional."
                                  ],
                                  "verification": "Resolver 5 cenários corretamente, explicando por quê.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exercícios impressos ou online (LeetCode easy integers)",
                                    "Compilador C++"
                                  ],
                                  "tips": "Sempre pergunte: 'Valor absoluto cabe na faixa positiva?'. Considere unsigned se só positivos.",
                                  "learningObjective": "Aplicar faixas para seleção de tipos e detecção de problemas.",
                                  "commonMistakes": "Escolher tipo maior desnecessariamente (desperdício de memória); ignorar overflow."
                                }
                              ],
                              "practicalExample": "Escreva um programa C++ que imprima uma tabela: Tipo | Bits | Mínimo | Máximo. Exemplo saída: short | 16 | -32768 | 32767. Use numeric_limits e loop para múltiplos tipos. Execute e capture screenshot da saída correta.",
                              "finalVerifications": [
                                "Recitar faixas de short, int e long sem hesitação.",
                                "Calcular manualmente 2^31 - 1 e explicar.",
                                "Identificar tipo correto para valores como 100000, -50000, 10^18.",
                                "Executar programa que confirma faixas no seu sistema.",
                                "Explicar diferença entre int e long em 32-bit vs 64-bit.",
                                "Detectar e corrigir overflow em código simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas faixas memorizadas (100% correto).",
                                "Compreensão de cálculos binários (potências de 2).",
                                "Código C++ compila e produz saída correta.",
                                "Seleção apropriada de tipos em cenários práticos.",
                                "Identificação de erros comuns como overflow.",
                                "Explicação clara de signed vs unsigned."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética binária e potências de 2.",
                                "Arquitetura de Computadores: Representação em memória e registradores.",
                                "Engenharia de Software: Otimização de memória e portabilidade.",
                                "Física: Limites de sistemas embarcados (ex: Arduino com int 16-bit)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos, use short para coordenadas de pixels (economia de memória); em finanças, long para saldos bancários globais evitando overflow; em IoT, int para sensores evitando erros em sistemas embedded com memória limitada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Operações com Números Inteiros",
                        "description": "Operações aritméticas básicas (+, -, *, /, %) em inteiros, considerando truncamento em divisão e overflow.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Executar soma e subtração de inteiros",
                            "description": "Realizar operações de soma e subtração em binário, detectando overflow quando o resultado excede a faixa do tipo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a representação binária de inteiros com sinal usando complemento de 2",
                                  "subSteps": [
                                    "Estude a estrutura de um inteiro signed de n bits: o bit mais significativo (MSB) indica o sinal (0 positivo, 1 negativo).",
                                    "Aprenda a converter um número decimal positivo para binário: divida por 2 sucessivamente e leia os restos de baixo para cima.",
                                    "Para números negativos: inverta todos os bits do positivo e some 1 (complemento de 2).",
                                    "Pratique representando números como +5, -3 em 4 bits e 8 bits.",
                                    "Verifique a faixa de representação para n bits: de -2^(n-1) a 2^(n-1)-1."
                                  ],
                                  "verification": "Converta corretamente 5 e -7 para binário em 4 bits sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de potências de 2",
                                    "Simulador binário online (ex: binary-hex-converter)"
                                  ],
                                  "tips": "Sempre comece pela representação positiva e aplique complemento de 2 apenas para negativos.",
                                  "learningObjective": "Representar qualquer inteiro signed em binário usando complemento de 2.",
                                  "commonMistakes": [
                                    "Esquecer de somar 1 após inverter bits no complemento de 2",
                                    "Confundir o tamanho do bit (ex: usar 4 bits mas calcular como 8)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar soma de inteiros em binário",
                                  "subSteps": [
                                    "Alinhe os números binários pela direita, considerando o mesmo número de bits.",
                                    "Some bit a bit da direita para a esquerda, usando carry (vai-um): 0+0=0, 0+1=1, 1+1=0 com carry 1, 1+1+1=1 com carry 1.",
                                    "Ignore o carry final que sai do MSB (não faz parte do resultado).",
                                    "Pratique somas como 0101 (+5) + 0010 (+2) = 0111 (+7) em 4 bits.",
                                    "Registre cada carry em uma linha separada para visualização."
                                  ],
                                  "verification": "Realize a soma de dois números binários e obtenha o resultado correto em decimal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora binária",
                                    "Vídeo tutorial de soma binária"
                                  ],
                                  "tips": "Desenhe colunas para bits, carry e resultado para evitar confusão.",
                                  "learningObjective": "Realizar soma binária bit a bit com carry corretamente.",
                                  "commonMistakes": [
                                    "Esquecer de propagar o carry para o próximo bit",
                                    "Somar o carry final ao resultado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar subtração de inteiros em binário via complemento de 2",
                                  "subSteps": [
                                    "Converta o subtraendo (número a subtrair) para seu complemento de 2 (negativo).",
                                    "Some o minuendo ao complemento de 2 do subtraendo, como na soma normal.",
                                    "Ignore o carry final do MSB.",
                                    "Pratique: 0101 (+5) - 0011 (+3) = 0101 + 1101 (-3) = 0010 (+2).",
                                    "Verifique o resultado convertendo de volta para decimal."
                                  ],
                                  "verification": "Subtraia dois números e confirme o resultado decimal equivalente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Simulador de aritmética binária (ex: tool online como binary subtraction calculator)"
                                  ],
                                  "tips": "Subtração é soma com o negativo: sempre transforme o subtraendo em complemento de 2.",
                                  "learningObjective": "Transformar subtração em soma usando complemento de 2.",
                                  "commonMistakes": [
                                    "Inverter errado o complemento de 2",
                                    "Não ignorar carry final na subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar overflow em operações de soma e subtração",
                                  "subSteps": [
                                    "Para soma: overflow se os sinais dos operandos são iguais e diferentes do resultado (ex: dois positivos dão negativo).",
                                    "Para subtração: similar, verifique sinais antes e depois.",
                                    "Regra alternativa: overflow se carry entra no MSB mas não sai (ou vice-versa).",
                                    "Exemplo overflow: 0111 (+7) + 0001 (+1) = 1000 (-8) em 4 bits → overflow.",
                                    "Pratique detectando em 5 exemplos variados."
                                  ],
                                  "verification": "Identifique corretamente overflow em 4 de 5 operações dadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de exemplos pré-prontos",
                                    "Ferramenta de verificação de overflow online"
                                  ],
                                  "tips": "Foquem nos sinais: mudança inesperada indica overflow.",
                                  "learningObjective": "Detectar e explicar overflow em operações binárias.",
                                  "commonMistakes": [
                                    "Confundir carry com overflow",
                                    "Ignorar o tamanho fixo dos bits"
                                  ]
                                }
                              ],
                              "practicalExample": "Em 4 bits signed: Calcule 6 (0110) + 3 (0011). Soma: 1001 (-7). Sinais iguais (positivos) mas resultado negativo → overflow detectado. Resultado correto seria 9, fora da faixa (-8 a +7).",
                              "finalVerifications": [
                                "Converter 3 inteiros signed para binário corretamente.",
                                "Realizar 5 somas binárias sem erros aritméticos.",
                                "Executar 5 subtrações via complemento de 2 com resultados precisos.",
                                "Detectar overflow em todos os casos de exemplo fornecidos.",
                                "Explicar o processo de uma operação completa verbalmente.",
                                "Resolver um problema misto (soma/subtração com overflow) em menos de 5 minutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas operações bit a bit (sem erros de carry).",
                                "Correta aplicação do complemento de 2 para negativos.",
                                "Detecção consistente de overflow usando regras de sinal.",
                                "Eficiência no tempo de execução das operações.",
                                "Capacidade de verificar resultados convertendo para decimal.",
                                "Clareza na documentação de steps e carries."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações em bases numéricas e álgebra booleana.",
                                "Programação: Operadores + e - em linguagens como C/C++ com tipos int.",
                                "Eletrônica: Circuitos de soma (full adder) e ALU em hardware.",
                                "Lógica: Portas AND/OR/XOR para implementação binária."
                              ],
                              "realWorldApplication": "Em processadores de computadores, CPUs executam soma/subtração binária em registradores fixos (ex: 32/64 bits), detectando overflow via flags (ex: flag OF no x86) para evitar erros em softwares como jogos, finanças ou sistemas embarcados onde resultados incorretos podem causar falhas críticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Realizar multiplicação e divisão inteira",
                            "description": "Executar multiplicação por repetição de soma e divisão inteira com resto (modulo), notando truncamento para valores negativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar multiplicação de inteiros positivos por repetição de soma",
                                  "subSteps": [
                                    "Entenda o conceito: multiplicar a por b significa somar a, b vezes (assumindo b >= 0)",
                                    "Escreva pseudocódigo usando um loop while ou for para repetir a soma b vezes",
                                    "Teste manualmente com exemplo simples: 3 * 4 = 3+3+3+3 = 12",
                                    "Implemente em uma linguagem de programação simples (ex: Python) sem usar o operador *",
                                    "Valide com múltiplos casos: 5*2, 7*0, 1*10"
                                  ],
                                  "verification": "O código produz resultados corretos para pelo menos 5 exemplos positivos sem usar operador de multiplicação",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE",
                                    "Papel e caneta para testes manuais",
                                    "Calculadora para verificação"
                                  ],
                                  "tips": "Inicialize o acumulador em 0 e conte até b sem exceder",
                                  "learningObjective": "Compreender multiplicação como soma iterativa para positivos",
                                  "commonMistakes": [
                                    "Loop infinito por não inicializar contador corretamente",
                                    "Confundir a e b na repetição",
                                    "Esquecer caso b=0 retorna 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estender multiplicação para números negativos",
                                  "subSteps": [
                                    "Analise sinais: resultado positivo se ambos positivos ou ambos negativos; negativo caso contrário",
                                    "Ajuste pseudocódigo: use valor absoluto para repetição e aplique sinal final",
                                    "Teste: (-3)*4 = -(3+3+3+3) = -12; 3*(-4) similar; (-3)*(-4)=12",
                                    "Implemente e teste casos: (-5)*2, 7*(-1), (-1)*(-1)",
                                    "Compare com operador * para validar"
                                  ],
                                  "verification": "Código lida corretamente com todos os 4 quadrantes de sinais (++, +-, -+, --)",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Tabela de sinais em papel"
                                  ],
                                  "tips": "Trabalhe com abs(a) e abs(b), multiplique sinais separadamente (1 ou -1)",
                                  "learningObjective": "Gerenciar sinais em operações aritméticas iterativas",
                                  "commonMistakes": [
                                    "Erro no sinal final",
                                    "Loop com negativos causando infinito",
                                    "Ignorar (-n)*0=0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar divisão inteira e módulo para positivos",
                                  "subSteps": [
                                    "Entenda: a / b = quociente q onde a = b*q + r, 0 <= r < |b|",
                                    "Pseudocódigo: subtraia b repetidamente de a até < b, conte subtrações (q), resto r = a final",
                                    "Teste: 17 / 5 = 3 (17-5-5-5=2), r=2; 10/3=3 r=1; 5/5=1 r=0",
                                    "Implemente sem usar / ou %",
                                    "Teste casos: 0/5=0 r=0, 7/1=7 r=0"
                                  ],
                                  "verification": "Quociente e resto corretos para 5+ exemplos positivos, com r >=0 e r < b",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "IDE",
                                    "Papel para simular subtrações"
                                  ],
                                  "tips": "Use loop while a >= b para evitar sobras negativas",
                                  "learningObjective": "Realizar divisão por subtração iterativa",
                                  "commonMistakes": [
                                    "Resto negativo",
                                    "Loop não para em a < b",
                                    "Confundir dividend e divisor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Lidar com divisão inteira e módulo envolvendo negativos (truncamento)",
                                  "subSteps": [
                                    "Note truncamento towards zero: -17 / 5 = -3 (não -4), r = -17 -5*(-3) = -2",
                                    "Ajuste algoritmo: use abs para loop, mas aplique truncamento correto",
                                    "Pseudocódigo para sinais: determine sinal de q, compute abs, ajuste r para matching sinal de a",
                                    "Teste: -17/5=-3 r=-2; 17/-5=-3 r=2; -17/-5=3 r=-2",
                                    "Valide contra linguagens como C/Python (// e % behavior)"
                                  ],
                                  "verification": "Resultados batem com truncamento towards zero para todos sinais",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Editor",
                                    "Documentação de operadores em linguagens"
                                  ],
                                  "tips": "r deve ter mesmo sinal de a; q = trunc(a/b)",
                                  "learningObjective": "Entender e implementar comportamento de divisão inteira em computadores",
                                  "commonMistakes": [
                                    "Usar floor division em vez de truncate",
                                    "Resto com sinal errado",
                                    "Falhar em casos zero"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma função multiply_divide(a, b) que retorna {quotient: a/b inteira, remainder: a%b, product: a*b} usando apenas soma/subtração/loops. Teste com a=-17, b=5: product=-85, quotient=-3, remainder=-2.",
                              "finalVerifications": [
                                "Multiplicação correta para 8*7=56 e -8*7=-56",
                                "Divisão 23/4=5 resto 3",
                                "-10/3=-3 resto -1",
                                "17/-4=-4 resto 1",
                                "-17/-5=3 resto -2",
                                "Casos edge: 0*5=0, 10/1=10 r=0, 5/0 (tratar erro)"
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos sem operadores * / %",
                                "Correto tratamento de sinais e truncamento towards zero",
                                "Eficiência do loop (sem loops infinitos)",
                                "Explicação clara do algoritmo em comentários",
                                "Testes abrangentes incluindo edge cases",
                                "Código legível e modular"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e propriedades de inteiros",
                                "Programação: Estruturas de loop e controle de fluxo",
                                "Engenharia: Simulação de operações de CPU/assembly",
                                "Física: Cálculos de divisões em trajetórias (ex: pixels por frame)"
                              ],
                              "realWorldApplication": "Em compiladores, interpretadores ou sistemas embarcados sem suporte a multiplicação/divisão hardware, ou para depuração de bugs em aritmética de ponto fixo em jogos e simulações financeiras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Detectar e tratar overflow em operações",
                            "description": "Identificar quando uma operação aritmética causa overflow em um tipo inteiro específico e discutir implicações em programas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Overflow em Tipos Inteiros",
                                  "subSteps": [
                                    "Defina overflow como o resultado de uma operação aritmética que excede os limites do tipo inteiro (ex: INT_MIN a INT_MAX para signed int32).",
                                    "Estude os ranges: signed int32 (-2^31 a 2^31-1), unsigned uint32 (0 a 2^32-1).",
                                    "Aprenda o comportamento padrão: wrap-around (modular aritmética) em linguagens como C/C++.",
                                    "Discuta implicações: resultados incorretos, loops infinitos ou crashes em programas.",
                                    "Compare signed vs unsigned overflow (undefined behavior em signed em C)."
                                  ],
                                  "verification": "Escreva uma definição própria de overflow e liste os ranges de int32 signed e unsigned corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de tipos inteiros (cppreference.com ou JavaDoc)",
                                    "Calculadora para 2^31"
                                  ],
                                  "tips": [
                                    "Sempre verifique se é signed ou unsigned antes de calcular limites.",
                                    "Use ferramentas como Godbolt para ver assembly."
                                  ],
                                  "learningObjective": "Compreender os limites e comportamentos de overflow em inteiros.",
                                  "commonMistakes": [
                                    "Confundir ranges de signed e unsigned.",
                                    "Ignorar undefined behavior em signed overflow."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Overflow em Operações de Soma e Subtração",
                                  "subSteps": [
                                    "Implemente soma manual: verifique se a + b > INT_MAX ou < INT_MIN antes da operação.",
                                    "Use fórmula para detecção pré-soma: if (a > INT_MAX - b) then overflow.",
                                    "Teste subtração: if (a < INT_MIN + b) para a - b.",
                                    "Escreva uma função safe_add(int a, int b) que retorna bool para overflow.",
                                    "Compile e teste com valores extremos: INT_MAX + 1, INT_MIN - 1."
                                  ],
                                  "verification": "Sua função safe_add detecta corretamente overflow em 5 casos de teste extremos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Compilador C/C++ ou Java",
                                    "Valores limite: 2147483647 (INT_MAX), -2147483648 (INT_MIN)"
                                  ],
                                  "tips": [
                                    "Teste com valores próximos aos limites primeiro.",
                                    "Considere usar long long para cálculos intermediários."
                                  ],
                                  "learningObjective": "Implementar detecção confiável de overflow em adição e subtração.",
                                  "commonMistakes": [
                                    "Não tratar overflow durante a própria soma.",
                                    "Esquecer de verificar ambos os operandos zero."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Overflow em Multiplicação e Divisão",
                                  "subSteps": [
                                    "Para multiplicação: verifique se a != 0 && b > INT_MAX / a (para positivos).",
                                    "Adapte para negativos: considere sinais e use abs aproximado.",
                                    "Para divisão: overflow raro, mas cheque divisão por zero e resultados que levam a overflow posterior.",
                                    "Crie função safe_multiply(int a, int b) com detecção.",
                                    "Teste casos: 100000 * 100000, INT_MAX * 2, 0 * INT_MIN."
                                  ],
                                  "verification": "Função safe_multiply passa em testes com overflow e casos edge.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo editor e compilador do step anterior",
                                    "Lista de casos de teste pré-definidos"
                                  ],
                                  "tips": [
                                    "Divida por a só se a != 0.",
                                    "Use unsigned para cálculos se possível."
                                  ],
                                  "learningObjective": "Dominar detecção de overflow em operações de multiplicação.",
                                  "commonMistakes": [
                                    "Dividir por zero acidentalmente.",
                                    "Não lidar com overflow em negativos corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estratégias para Tratar e Prevenir Overflow",
                                  "subSteps": [
                                    "Estratégias: usar tipos maiores (long long), saturação (clamp ao limite), lançamento de exceção.",
                                    "Implemente versão saturada: se overflow, retorne INT_MAX ou INT_MIN.",
                                    "Refatore código existente para usar funções safe.",
                                    "Discuta bibliotecas: SafeInt em C++, BigInteger em Java.",
                                    "Analise um código com bug de overflow e corrija."
                                  ],
                                  "verification": "Implemente e teste uma função safe_add_saturate que previne wrap-around.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código de exemplo com bug (fornecido ou criar)",
                                    "Documentação de std::numeric_limits"
                                  ],
                                  "tips": [
                                    "Prefira detecção pré-operação para performance.",
                                    "Logue overflows para debug."
                                  ],
                                  "learningObjective": "Aplicar técnicas de tratamento para tornar código robusto contra overflow.",
                                  "commonMistakes": [
                                    "Usar wrap-around intencionalmente sem documentar.",
                                    "Ignorar performance de tipos maiores."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de estoque, calcular total = preco_unitario * quantidade. Se preco=100000 e quantidade=30000, 3e9 excede INT_MAX (2e9), causando wrap-around para valor negativo, levando a erros de cobrança.",
                              "finalVerifications": [
                                "Explicar corretamente o que acontece em INT_MAX + 1 em C.",
                                "Implementar safe_add que detecta todos overflows em 10 testes.",
                                "Identificar e corrigir overflow em código fornecido.",
                                "Discutir 3 implicações reais de overflow não tratado.",
                                "Comparar detecção em soma vs multiplicação.",
                                "Implementar saturação em uma operação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de overflow (100% em testes edge).",
                                "Clareza e eficiência das funções implementadas.",
                                "Correta compreensão de signed vs unsigned.",
                                "Uso apropriado de verificações pré-operacionais.",
                                "Capacidade de refatorar código para prevenção.",
                                "Explicação verbal de implicações e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e limites de representação numérica.",
                                "Segurança de Software: Prevenção de vulnerabilidades como integer overflow em exploits.",
                                "Algoritmos: Impacto em corretude de sorting ou hashing.",
                                "Desenvolvimento Ágil: Testes unitários para edge cases numéricos."
                              ],
                              "realWorldApplication": "Em aplicativos financeiros (ex: calculadoras de juros compostos), jogos (scores altos), ou sistemas embarcados (sensores IoT), onde overflow pode causar perdas monetárias, crashes ou decisões erradas baseadas em valores incorretos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1",
                              "10.1.5.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.4",
                            "name": "Aplicar operações em código simples",
                            "description": "Escrever trechos de código em C++ ou pseudocódigo para realizar e imprimir resultados de operações com inteiros, declarando tipos adequados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e planejar o código",
                                  "subSteps": [
                                    "Instale um compilador C++ como g++ ou use um IDE online como Replit ou Code::Blocks.",
                                    "Revise a sintaxe básica de um programa C++: #include <iostream>, int main(), using namespace std;.",
                                    "Defina o problema: identifique os inteiros de entrada e as operações necessárias (ex: soma, subtração).",
                                    "Esboce o pseudocódigo: declare variáveis, realize operações, imprima resultado.",
                                    "Escreva comentários no planejamento para documentar cada parte."
                                  ],
                                  "verification": "Ambiente configurado e pseudocódigo escrito em um arquivo de texto ou editor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Compilador C++ (g++), IDE (VS Code com extensão C++), editor de texto.",
                                  "tips": "Use pseudocódigo primeiro para evitar erros de sintaxe iniciais.",
                                  "learningObjective": "Compreender a estrutura básica de um programa C++ e planejar logicamente as operações.",
                                  "commonMistakes": "Esquecer de incluir <iostream> ou não usar namespace std; pular o planejamento e ir direto ao código."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar variáveis inteiras e atribuir valores",
                                  "subSteps": [
                                    "Escreva int main() { } no início do programa.",
                                    "Declare variáveis com 'int': ex: int a = 5; int b = 3;.",
                                    "Atribua valores literais ou use cin para entrada: cin >> a >> b;.",
                                    "Adicione comentários explicando o tipo int e seu range (-2^31 a 2^31-1).",
                                    "Teste declarações isoladas compilando um programa mínimo."
                                  ],
                                  "verification": "Programa compila e variáveis são declaradas sem erros de tipo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmo ambiente do step 1, exemplos de código de referência.",
                                  "tips": "Sempre inicialize variáveis para evitar valores garbage.",
                                  "learningObjective": "Dominar declaração e inicialização de variáveis do tipo inteiro em C++.",
                                  "commonMistakes": "Usar float ou double em vez de int; esquecer ponto-e-vírgula após declarações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar operações aritméticas",
                                  "subSteps": [
                                    "Declare variáveis para resultados: int soma = a + b; int produto = a * b;.",
                                    "Inclua operações básicas: +, -, *, /, % (módulo).",
                                    "Atenção à divisão inteira: 5/2 = 2, não 2.5.",
                                    "Combine operações: int diferenca = (a - b) * 2;.",
                                    "Adicione comentários sobre precedência de operadores (use parênteses para clareza)."
                                  ],
                                  "verification": "Cálculos manuais coincidem com valores impressos em cout temporário.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora para verificação manual, tabela de operadores aritméticos.",
                                  "tips": "Use parênteses extras para evitar ambiguidades em expressões complexas.",
                                  "learningObjective": "Aplicar corretamente operadores aritméticos em expressões com inteiros.",
                                  "commonMistakes": "Confundir / com divisão real (use 5.0/2 para float); overflow em números grandes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Imprimir resultados, compilar e testar",
                                  "subSteps": [
                                    "Use cout << \"Soma: \" << soma << endl; para cada resultado.",
                                    "Adicione return 0; no final de main().",
                                    "Compile: g++ programa.cpp -o programa.",
                                    "Execute: ./programa e insira valores de teste.",
                                    "Teste casos edge: zero, negativos, divisão por zero (trate com if)."
                                  ],
                                  "verification": "Programa executa, imprime resultados corretos para múltiplos inputs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Terminal para compilar/executar, casos de teste pré-definidos.",
                                  "tips": "Use endl para flush de saída; teste com inputs variados.",
                                  "learningObjective": "Integrar entrada/saída e executar código funcional com operações.",
                                  "commonMistakes": "Esquecer << entre strings e variáveis; não tratar divisão por zero."
                                }
                              ],
                              "practicalExample": "Escreva um programa C++ que leia dois inteiros a e b, calcule e imprima: soma, diferença, produto, quociente inteiro e resto da divisão. Exemplo de saída para a=10, b=3: Soma: 13, Diferença: 7, Produto: 30, Quociente: 3, Resto: 1.",
                              "finalVerifications": [
                                "Código compila sem warnings ou erros.",
                                "Resultados impressos são exatos para 5+ casos de teste (positivos, negativos, zero).",
                                "Variáveis declaradas corretamente como int.",
                                "Saída formatada claramente com labels.",
                                "Programa trata divisão por zero com mensagem de erro.",
                                "Comentários explicam cada operação."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática e sem erros de compilação (30%).",
                                "Operações aritméticas implementadas precisamente (25%).",
                                "Entrada/saída funcionais e user-friendly (20%).",
                                "Tratamento de casos especiais (15%).",
                                "Código limpo, comentado e legível (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reforça aritmética básica e propriedades de inteiros.",
                                "Lógica e Algoritmos: Introduz fluxo sequencial de programação.",
                                "Física/Engenharia: Base para cálculos numéricos em simulações.",
                                "Matemática Computacional: Entender overflow e precisão."
                              ],
                              "realWorldApplication": "Desenvolvimento de calculadoras simples em apps mobile, jogos (scores), sistemas de inventário (cálculo de totais), ou scripts de automação para processamento de dados numéricos em planilhas ou bancos de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Tipos em Ponto Flutuante",
                    "description": "Armazenamento de números reais, precisão e limitações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Representação de Números em Ponto Flutuante",
                        "description": "Estrutura binária para armazenamento de números reais, baseada no padrão IEEE 754, composta por sinal, expoente e mantissa.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Identificar componentes da representação IEEE 754",
                            "description": "Reconhecer e descrever o bit de sinal, o expoente enviesado e a mantissa normalizada em um número de ponto flutuante de 32 ou 64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral do IEEE 754",
                                  "subSteps": [
                                    "Estudar a definição do padrão IEEE 754 para números de ponto flutuante.",
                                    "Memorizar o layout para precisão simples (32 bits): 1 bit sinal, 8 bits expoente, 23 bits mantissa.",
                                    "Memorizar o layout para dupla precisão (64 bits): 1 bit sinal, 11 bits expoente, 52 bits mantissa.",
                                    "Desenhar diagramas visuais representando a divisão dos bits para ambos os formatos.",
                                    "Comparar com representações de ponto fixo para destacar diferenças."
                                  ],
                                  "verification": "Desenhar e rotular corretamente os diagramas de 32 e 64 bits, confirmando as contagens de bits.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagramas de referência IEEE 754 online",
                                    "Calculadora conversora binária"
                                  ],
                                  "tips": "Use cores diferentes para sinal (vermelho), expoente (azul) e mantissa (verde) nos diagramas para facilitar a memorização visual.",
                                  "learningObjective": "Dominar a divisão exata dos bits nos formatos IEEE 754 de 32 e 64 bits.",
                                  "commonMistakes": [
                                    "Confundir o número de bits da mantissa (23 vs 52).",
                                    "Esquecer que o formato é little-endian ou big-endian dependendo da arquitetura."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Bit de Sinal",
                                  "subSteps": [
                                    "Aprender que o bit de sinal é o bit mais significativo: 0 para positivo ou zero, 1 para negativo.",
                                    "Localizar o bit: posição 31 em 32 bits, posição 63 em 64 bits.",
                                    "Converter números decimais simples como 1.0 (positivo) e -1.0 (negativo) para binário e isolar o sinal.",
                                    "Praticar com 5 exemplos aleatórios de números positivos e negativos.",
                                    "Explicar o impacto do bit de sinal no valor final do número."
                                  ],
                                  "verification": "Dado um padrão binário de 32 ou 64 bits, identificar corretamente o sinal e justificar.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta online de conversão float para binário (ex: IEEE-754 converter)",
                                    "Lista de 10 números decimais para prática"
                                  ],
                                  "tips": "Sempre verifique o bit MSB primeiro, independentemente do endianness, focando na representação lógica.",
                                  "learningObjective": "Reconhecer e interpretar o bit de sinal em qualquer representação IEEE 754.",
                                  "commonMistakes": [
                                    "Ignorar o endianness ao ler dumps de memória.",
                                    "Confundir sinal com o bit implícito da mantissa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Expoente Enviesado",
                                  "subSteps": [
                                    "Entender o bias: 127 para 32 bits, 1023 para 64 bits; expoente real = valor armazenado - bias.",
                                    "Localizar os bits: posições 30-23 em 32 bits, 62-52 em 64 bits.",
                                    "Identificar casos especiais: todos 0s (subnormal/zero), todos 1s (infinito/NaN).",
                                    "Calcular o expoente real para 3 exemplos, como expoente armazenado 127 (real 0).",
                                    "Converter um número decimal para expoente binário enviesado."
                                  ],
                                  "verification": "Para um expoente binário dado, calcular corretamente o valor real e identificar se é especial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de bias IEEE 754",
                                    "Calculadora binária para somas/subtrações",
                                    "Exemplos de números como 2.0 e 0.5"
                                  ],
                                  "tips": "Lembre-se: o bias permite representar expoentes negativos sem bits de sinal extras.",
                                  "learningObjective": "Calcular e interpretar o expoente enviesado, incluindo casos especiais.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair o bias.",
                                    "Confundir expoente com mantissa em padrões all-1s."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer a Mantissa Normalizada",
                                  "subSteps": [
                                    "Aprender que a mantissa é normalizada com bit implícito 1. (1.mantissa em binário).",
                                    "Localizar os bits: 22-0 em 32 bits, 51-0 em 64 bits.",
                                    "Calcular o valor da mantissa: 1 + fração binária dos bits.",
                                    "Praticar extração em exemplos, como mantissa 0 = 1.0.",
                                    "Combinar com sinal e expoente para validar um número completo."
                                  ],
                                  "verification": "Extrair a mantissa de um padrão binário, adicionar o bit implícito e calcular sua fração decimal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Conversor IEEE 754",
                                    "Papel para cálculos binários decimais",
                                    "Exemplos hexadecimais como 0x3F800000 (1.0)"
                                  ],
                                  "tips": "O bit implícito economiza 1 bit; ignore-o nos subnormais (expoente 0).",
                                  "learningObjective": "Interpretar a mantissa normalizada e seu papel na precisão do número.",
                                  "commonMistakes": [
                                    "Esquecer o bit implícito 1.",
                                    "Tratar mantissa como inteira em vez de fracionária."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise 0x40490FDA (aprox. 3.14159 em single precision). Sinal: bit 31=0 (positivo). Expoente: bits 30-23=10000000 (128 dec, real=1). Mantissa: bits 22-0=01001000 11011001 10111100 (com 1. implícito ≈1.5708). Valor: +1.5708 * 2^1 ≈ 3.1416 (pi/2 aproximado).",
                              "finalVerifications": [
                                "Divide corretamente um padrão de 32/64 bits em sinal, expoente e mantissa.",
                                "Identifica o sinal e determina se o número é positivo/negativo.",
                                "Calcula expoente real de biased e reconhece casos especiais.",
                                "Extrai mantissa, inclui bit implícito e interpreta seu valor.",
                                "Valida componentes reconstruindo o número decimal aproximado.",
                                "Aplica a todos os formatos (32/64 bits) sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização e contagem de bits para cada componente.",
                                "Correta aplicação do bias no cálculo do expoente real.",
                                "Compreensão do bit implícito na mantissa normalizada.",
                                "Capacidade de descrever verbalmente cada componente e seu papel.",
                                "Consistência em exemplos variados, incluindo casos especiais.",
                                "Velocidade e confiança na identificação em padrões binários/hex."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversões binário-decimal e potências de 2.",
                                "Engenharia de Computação: Codificação de dados em processadores e memória.",
                                "Física: Representação numérica em simulações de dinâmica e ondas.",
                                "Programação: Manipulação de floats em C, Python e assembly.",
                                "Eletrônica: Lógica digital em ALUs de FPU (Floating Point Unit)."
                              ],
                              "realWorldApplication": "Usado em jogos e computação gráfica para coordenadas 3D precisas, simulações científicas em física quântica e clima, e inteligência artificial para cálculos de pesos em redes neurais, garantindo eficiência em hardware como GPUs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Converter número decimal para ponto flutuante",
                            "description": "Realizar a conversão passo a passo de um número decimal real para sua representação binária em ponto flutuante, incluindo normalização e ajuste do expoente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Converter a parte inteira do número decimal para binário",
                                  "subSteps": [
                                    "Divida o número inteiro por 2 sucessivamente, registrando os restos.",
                                    "Leia os restos de baixo para cima para formar o binário da parte inteira.",
                                    "Verifique se a conversão está correta multiplicando de volta.",
                                    "Registre o resultado com o ponto decimal.",
                                    "Trate casos especiais como zero ou números negativos (sinal)."
                                  ],
                                  "verification": "Multiplique os bits binários por potências de 2 correspondentes e some para confirmar o valor original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional",
                                    "Tabela de potências de 2"
                                  ],
                                  "tips": "Comece sempre pela divisão por 2 e anote os restos em uma coluna para evitar confusão.",
                                  "learningObjective": "Dominar a conversão de inteiros decimais para binário usando divisão sucessiva.",
                                  "commonMistakes": [
                                    "Ler os restos de cima para baixo",
                                    "Esquecer de incluir o bit de sinal para negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter a parte fracionária para binário",
                                  "subSteps": [
                                    "Multiplique a parte fracionária por 2 e registre o bit inteiro (0 ou 1).",
                                    "Use a parte fracionária resultante para repetir o processo.",
                                    "Continue até obter precisão desejada ou 23 bits para mantissa IEEE 754.",
                                    "Pare se a fração se tornar zero.",
                                    "Anote os bits após o ponto decimal."
                                  ],
                                  "verification": "Reconstrua o valor decimal somando cada bit fracionário multiplicado por 2^(-posição).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para multiplicações precisas"
                                  ],
                                  "tips": "Mantenha pelo menos 10-15 bits para precisão, mesmo que IEEE use 23.",
                                  "learningObjective": "Aprender a representar frações decimais em binário via multiplicação por 2.",
                                  "commonMistakes": [
                                    "Usar divisão em vez de multiplicação",
                                    "Ignorar bits que não terminam exatamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Combinar partes e normalizar a representação binária",
                                  "subSteps": [
                                    "Junte a parte inteira e fracionária com o ponto binário.",
                                    "Mova o ponto para a direita do primeiro bit 1 (normalização científica binária).",
                                    "Conte o número de posições movidas para calcular o expoente não-biased.",
                                    "Escreva na forma 1.mantissa x 2^expoente.",
                                    "Verifique se o primeiro bit após o ponto é sempre 1 (exceto para zero)."
                                  ],
                                  "verification": "Confirme que o valor normalizado, quando 'denormalizado', retorna ao binário original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de referência IEEE 754"
                                  ],
                                  "tips": "Para números <1, o expoente inicial é negativo; conte deslocamentos à direita como positivo.",
                                  "learningObjective": "Entender normalização para representação eficiente em ponto flutuante.",
                                  "commonMistakes": [
                                    "Contar deslocamentos incorretamente",
                                    "Normalizar para números já normalizados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o expoente biased e preparar a mantissa",
                                  "subSteps": [
                                    "Adicione o bias (127 para single precision IEEE 754) ao expoente normalizado.",
                                    "Converta o expoente biased para binário de 8 bits.",
                                    "Remova o bit 1 implícito da mantissa e preencha com zeros até 23 bits.",
                                    "Trunque ou arredonde se necessário para 23 bits.",
                                    "Anote sinal (0 positivo, 1 negativo), expoente e mantissa separadamente."
                                  ],
                                  "verification": "Subtraia o bias do expoente binário e confirme que bate com o expoente normalizado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de bias IEEE 754",
                                    "Conversor decimal-binário"
                                  ],
                                  "tips": "Lembre: bias 127 garante expoentes positivos em unsigned.",
                                  "learningObjective": "Aplicar bias ao expoente e formatar mantissa para padrão IEEE 754.",
                                  "commonMistakes": [
                                    "Bias errado (usar 128 em vez de 127)",
                                    "Incluir o bit 1 na mantissa"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar a representação final em ponto flutuante de 32 bits",
                                  "subSteps": [
                                    "Concatene: 1 bit sinal + 8 bits expoente + 23 bits mantissa.",
                                    "Converta o resultado binário para hexadecimal para verificação.",
                                    "Compare com uma ferramenta online ou calculadora IEEE 754.",
                                    "Teste com denormalização para validar.",
                                    "Documente todos os passos para revisão."
                                  ],
                                  "verification": "Use um conversor IEEE 754 online para confirmar o valor exato.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Ferramenta online IEEE 754 converter",
                                    "Papel para concatenação"
                                  ],
                                  "tips": "Agrupe em nibbles (4 bits) para facilitar conversão para hex.",
                                  "learningObjective": "Finalizar o formato binário padrão de ponto flutuante single precision.",
                                  "commonMistakes": [
                                    "Ordem errada dos campos",
                                    "Erros de transcrição de bits"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo: Converter 12.625 (decimal) para IEEE 754 single precision.\n- Inteiro 12: 1100\n- Fracionário 0.625: 0.101\n- Combinado: 1100.101\n- Normalizado: 1.100101 x 2^3\n- Expoente biased: 3 + 127 = 130 = 10000010\n- Mantissa: 10010100000000000000000\n- Final: 0 10000010 10010100000000000000000 (hex: 414A0000)",
                              "finalVerifications": [
                                "O bit de sinal está correto (0 para positivo)?",
                                "O expoente biased está em 8 bits e subtraindo 127 dá o expoente correto?",
                                "A mantissa tem exatamente 23 bits sem o 1 implícito?",
                                "Denormalizando o resultado retorna aproximadamente o número original?",
                                "Conversão para hex bate com ferramentas padrão?",
                                "Nenhum overflow/underflow não tratado?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na conversão binária inicial (erro < 0.1%)",
                                "Normalização correta com expoente exato",
                                "Cálculo preciso do bias no expoente",
                                "Mantissa formatada corretamente (23 bits)",
                                "Representação final validada por ferramenta externa",
                                "Documentação clara de todos os passos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações com bases numéricas e normalização científica",
                                "Física: Representação de medidas em simulações computacionais",
                                "Engenharia: Otimização de armazenamento em hardware",
                                "Programação: Uso de floats em linguagens como C/Python"
                              ],
                              "realWorldApplication": "Em jogos e simulações 3D, números em ponto flutuante representam posições, velocidades e texturas; entender isso previne erros de precisão em cálculos gráficos e científicos, como em motores de jogos (Unity/Unreal) ou modelagem climática."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Explicar normalização e desnormalização",
                            "description": "Diferenciar números normalizados e desnormalizados, entendendo seu papel na representação de valores próximos a zero e evitando perda de precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a representação básica de números em ponto flutuante IEEE 754",
                                  "subSteps": [
                                    "Revise a estrutura geral: sinal (1 bit), expoente (8 bits para single precision), mantissa (23 bits).",
                                    "Explique o expoente biased: valor real = expoente armazenado - 127.",
                                    "Discuta o bit implícito de 1 na mantissa para números normalizados.",
                                    "Identifique casos especiais: zero, infinito e NaN.",
                                    "Represente um exemplo simples como 1.0 em binário."
                                  ],
                                  "verification": "Desenhe a representação binária de 1.0 e 0.5 em um papel ou ferramenta online.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação IEEE 754, calculadora binária online (ex: IEEE-754 Floating Point Converter).",
                                  "tips": "Sempre comece com exemplos inteiros para fixar a base antes de fracionários.",
                                  "learningObjective": "Compreender os componentes fundamentais da representação de ponto flutuante.",
                                  "commonMistakes": "Confundir expoente biased com o valor real; ignorar o bit implícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar números normalizados",
                                  "subSteps": [
                                    "Defina normalização: ajustar o valor para que a mantissa comece com 1.xxxx (bit implícito 1).",
                                    "Ajuste o expoente para o maior possível sem overflow na mantissa.",
                                    "Converta um número como 0.75 (binário 0.11) para normalizado: 1.1 * 2^-1.",
                                    "Calcule a representação completa em 32 bits.",
                                    "Verifique com ferramenta online."
                                  ],
                                  "verification": "Converta manualmente 0.75 e valide com conversor IEEE 754.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta para cálculos binários, conversor IEEE 754 online.",
                                  "tips": "Use notação científica binária para visualizar shifts.",
                                  "learningObjective": "Dominar o processo de normalização e sua representação.",
                                  "commonMistakes": "Esquecer de subtrair o bias no expoente; não normalizar corretamente o mantissa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar normalização e desnormalização e discutir impactos",
                                  "subSteps": [
                                    "Compare tabelas: normalizado (expoente >=1), desnormalizado (expoente=0).",
                                    "Discuta perda de precisão: desnormalizados sacrificam bits de mantissa.",
                                    "Analise underflow: sem desnormalizados, valores < 2^-126 viram zero.",
                                    "Exemplo prático: soma acumulativa de pequenos valores em loop.",
                                    "Debata trade-offs: precisão vs. range."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 3 exemplos e explique verbalmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha ou papel para tabela, código simples em Python para testar underflow.",
                                  "tips": "Teste em código real para ver diferenças numéricas.",
                                  "learningObjective": "Diferenciar processos e entender implicações em precisão.",
                                  "commonMistakes": "Ignorar impacto em algoritmos sensíveis a precisão como finanças ou física."
                                }
                              ],
                              "practicalExample": "Em um programa de simulação física, ao somar acelerações muito pequenas (ex: 1e-40 m/s²) repetidamente, desnormalizados evitam que o acumulador subitamente zere, mantendo precisão gradual. Teste em Python: soma = 0; for i in range(100000): soma += 1e-300",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre normalizado e desnormalizado com exemplo binário.",
                                "Converter um número pequeno (<2^-126) para representação IEEE 754 corretamente.",
                                "Identificar se uma representação dada (bits) é normalizada ou desnormalizada.",
                                "Discutir por que desnormalizados evitam perda de precisão perto de zero.",
                                "Demonstrar underflow em código sem e com desnormalizados (flush-to-zero).",
                                "Criar tabela comparativa de precisão e range."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e representação binária (90% correto).",
                                "Capacidade de diferenciar casos com exemplos numéricos.",
                                "Explicação clara do papel em precisão e underflow.",
                                "Uso correto de ferramentas para verificação.",
                                "Análise de trade-offs e impactos reais.",
                                "Comunicação estruturada na tabela ou verbal."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Notação científica e limites de precisão em aritmética finita.",
                                "Física: Simulações numéricas onde gradientes pequenos importam (ex: mecânica quântica).",
                                "Engenharia de Software: Otimização de algoritmos numéricos estáveis.",
                                "Computação: Assembly e flags de FPU para controle de desnormalizados."
                              ],
                              "realWorldApplication": "Em gráficos 3D e jogos, desnormalizados previnem artefatos visuais em sombras suaves ou partículas próximas ao zero; em finanças, evitam erros cumulativos em cálculos de juros compostos minúsculos, garantindo conformidade regulatória."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Tipos de Ponto Flutuante em Linguagens de Programação",
                        "description": "Tipos escalares como float (simples precisão) e double (dupla precisão) em linguagens como C++ e Python, com suas características de tamanho e faixa de valores.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Declarar e inicializar variáveis de ponto flutuante",
                            "description": "Criar variáveis do tipo float e double em C++ ou Python, atribuindo valores reais e verificando seu armazenamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos básicos de variáveis de ponto flutuante",
                                  "subSteps": [
                                    "Pesquise a diferença entre números inteiros e de ponto flutuante.",
                                    "Aprenda que float usa cerca de 4 bytes (precisão simples) e double 8 bytes (precisão dupla).",
                                    "Identifique casos de uso: float para cálculos rápidos, double para precisão alta.",
                                    "Compare precisão em linguagens: C++ tem float/double, Python usa float (double por padrão).",
                                    "Anote exemplos de valores reais como 3.14159 ou 2.71828."
                                  ],
                                  "verification": "Resuma em uma frase a diferença entre float e double e cite um exemplo de perda de precisão.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Documentação oficial de C++ (cppreference.com) e Python (docs.python.org), bloco de notas.",
                                  "tips": "Lembre-se: ponto flutuante representa frações, não exatas como 0.1.",
                                  "learningObjective": "Compreender a representação binária e limitações de precisão de floats.",
                                  "commonMistakes": "Confundir com inteiros; assumir precisão infinita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e inicializar variáveis float e double em C++",
                                  "subSteps": [
                                    "Abra um editor de código e crie um arquivo main.cpp.",
                                    "Declare uma variável float: float pi = 3.14159f;",
                                    "Declare uma double: double euler = 2.718281828459045;",
                                    "Compile com g++ main.cpp -o main.",
                                    "Adicione #include <iostream> e use std::cout para imprimir valores."
                                  ],
                                  "verification": "Código compila sem erros e imprime valores próximos aos esperados (ex: pi ≈ 3.14159).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Compilador GCC/Clang, IDE como VS Code ou Code::Blocks.",
                                  "tips": "Use sufixo 'f' para float literals em C++ para evitar promoção automática.",
                                  "learningObjective": "Dominar sintaxe de declaração e inicialização em C++ com precisão.",
                                  "commonMistakes": "Esquecer sufixo 'f' em float; usar vírgula em vez de ponto decimal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar e inicializar variáveis float em Python",
                                  "subSteps": [
                                    "Crie um arquivo main.py.",
                                    "Declare: pi = 3.14159  # Python float é double por padrão.",
                                    "Atribua: velocidade = 9.8  # aceleração da gravidade.",
                                    "Use print(pi, velocidade) para exibir.",
                                    "Execute com python main.py e verifique saída."
                                  ],
                                  "verification": "Script executa e imprime valores reais corretamente sem erros de sintaxe.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python 3 instalado, editor como IDLE ou VS Code.",
                                  "tips": "Python trata todos os floats como double internamente; não há distinção float/double explícita.",
                                  "learningObjective": "Aplicar declaração dinâmica em Python para valores reais.",
                                  "commonMistakes": "Usar aspas em valores numéricos; esquecer importações desnecessárias."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar armazenamento e testar precisão",
                                  "subSteps": [
                                    "Em C++, imprima sizeof(float) e sizeof(double) com cout.",
                                    "Teste precisão: atribua 0.1 a float/double e imprima múltiplas casas decimais.",
                                    "Em Python, use print(f'{pi:.20f}') para ver precisão.",
                                    "Compare saídas entre C++ e Python.",
                                    "Registre observações sobre arredondamentos."
                                  ],
                                  "verification": "Confirme tamanhos (4/8 bytes C++) e detecte imprecisões como 0.1 != 0.10000000149.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Códigos dos steps anteriores, calculadora para validação.",
                                  "tips": "Use std::fixed e std::setprecision(10) em C++ para melhor visualização.",
                                  "learningObjective": "Validar armazenamento e compreender limitações numéricas.",
                                  "commonMistakes": "Ignorar diferenças de precisão; não usar formatação de saída."
                                }
                              ],
                              "practicalExample": "Em C++: #include <iostream> int main() { float pi = 3.14159f; double e = 2.71828; std::cout << pi << ' ' << e; return 0; } Saída: 3.14159 2.71828. Em Python: pi = 3.14159; print(pi) → 3.14159.",
                              "finalVerifications": [
                                "Código C++ compila e executa sem warnings de tipo.",
                                "Valores impressos em C++ e Python correspondem aos literais com precisão esperada.",
                                "sizeof(float) == 4 e sizeof(double) == 8 confirmado em C++.",
                                "Teste de 0.1 mostra imprecisão binária corretamente identificada.",
                                "Dois programas independentes (C++/Python) funcionam corretamente.",
                                "Nenhuma perda de dados em inicializações simples."
                              ],
                              "assessmentCriteria": [
                                "Declaração usa tipos corretos (float/double em C++, float em Python).",
                                "Inicialização com valores reais (ex: decimais) sem erros de sintaxe.",
                                "Código imprime valores verificáveis.",
                                "Comentários explicam diferenças de precisão.",
                                "Testes incluem verificação de tamanho e precisão.",
                                "Solução funciona em ambos os ambientes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de números reais e erros de arredondamento.",
                                "Física: Modelagem de grandezas contínuas como velocidade (m/s).",
                                "Engenharia: Simulações numéricas em software embarcado.",
                                "Estatística: Cálculos com dados decimais em análise de dados."
                              ],
                              "realWorldApplication": "Desenvolvimento de software para cálculos científicos (ex: simulação de trajetórias em jogos ou previsão climática), finanças (taxas de juros compostos), gráficos 3D (coordenadas reais) e jogos (posições de objetos com velocidades fracionárias)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Comparar precisão entre float e double",
                            "description": "Analisar o número de bits dedicados à mantissa em float (23 bits) versus double (52 bits) e demonstrar diferenças em exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a representação IEEE 754 para float",
                                  "subSteps": [
                                    "Estude a estrutura de um float de 32 bits: 1 bit para sinal, 8 bits para expoente e 23 bits para mantissa.",
                                    "Aprenda sobre o bit implícito na mantissa (normalização), que adiciona precisão efetiva de 24 bits.",
                                    "Converta um número decimal simples, como 1.0, para sua representação binária em float.",
                                    "Calcule a precisão aproximada: cerca de 6-7 dígitos decimais significativos.",
                                    "Visualize diagramas da estrutura de bits usando ferramentas online."
                                  ],
                                  "verification": "Desenhe e rotule corretamente a representação binária de um float de 32 bits para o número 0.5.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação IEEE 754",
                                    "Conversor binário online (ex: IEEE-754 Floating Point Converter)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Sempre inclua o bit implícito '1' na mantissa para números normalizados.",
                                  "learningObjective": "Compreender a alocação exata de bits e a precisão limitada do tipo float.",
                                  "commonMistakes": [
                                    "Esquecer o bit implícito na mantissa",
                                    "Confundir expoente com mantissa",
                                    "Ignorar a normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a representação IEEE 754 para double",
                                  "subSteps": [
                                    "Estude a estrutura de um double de 64 bits: 1 bit para sinal, 11 bits para expoente e 52 bits para mantissa.",
                                    "Aprenda sobre o bit implícito, proporcionando precisão efetiva de 53 bits.",
                                    "Converta o mesmo número decimal (ex: 1.0) para representação binária em double.",
                                    "Calcule a precisão aproximada: cerca de 15-16 dígitos decimais significativos.",
                                    "Compare visualmente os diagramas de float e double lado a lado."
                                  ],
                                  "verification": "Desenhe e rotule corretamente a representação binária de um double de 64 bits para o número 0.5.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação IEEE 754",
                                    "Conversor binário online",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Note o expoente maior em double, que também afeta o range, mas foque na mantissa para precisão.",
                                  "learningObjective": "Compreender a alocação de bits e maior precisão do tipo double.",
                                  "commonMistakes": [
                                    "Subestimar os 52 bits da mantissa",
                                    "Confundir tamanhos de expoente",
                                    "Não comparar com float"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar teoricamente a precisão das mantissas",
                                  "subSteps": [
                                    "Liste os bits da mantissa: 23 em float vs. 52 em double.",
                                    "Calcule a diferença em precisão: double tem cerca de 2x mais bits (~2^29 vezes mais preciso).",
                                    "Discuta implicações: float perde precisão em operações acumulativas mais rápido.",
                                    "Crie uma tabela comparativa de range, precisão decimal e uso típico.",
                                    "Resolva exercícios: preveja quando um número perde precisão em cada tipo."
                                  ],
                                  "verification": "Crie uma tabela comparativa precisa destacando os 23 vs. 52 bits da mantissa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Referências IEEE 754"
                                  ],
                                  "tips": "Use potências de 2 para quantificar: 2^23 ≈ 8 milhões vs. 2^52 ≈ 4 quatrilhões.",
                                  "learningObjective": "Analisar quantitativamente a superioridade de precisão do double.",
                                  "commonMistakes": [
                                    "Focar só em tamanho total ignorando mantissa",
                                    "Confundir precisão com range",
                                    "Erros em cálculos de potências de 2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar diferenças com exemplos numéricos em código",
                                  "subSteps": [
                                    "Escreva código em uma linguagem (ex: Java, C++ ou Python) declarando variáveis float e double.",
                                    "Teste operações como 0.1 + 0.2 e compare com 0.3 para mostrar desigualdades.",
                                    "Acumule somas em loop (ex: 1000 adições de 0.1) e imprima resultados.",
                                    "Use funções para extrair bits da mantissa e confirme contagens.",
                                    "Analise saídas: float mostra erros maiores que double."
                                  ],
                                  "verification": "Execute código que demonstre perda de precisão em float mas não em double para um exemplo específico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE ou editor de código (Java/C++/Python)",
                                    "Compilador/interpretador"
                                  ],
                                  "tips": "Use printf com alta precisão (%.20f) para visualizar diferenças.",
                                  "learningObjective": "Demonstrar empiricamente as diferenças de precisão entre float e double.",
                                  "commonMistakes": [
                                    "Não usar precisão suficiente na saída",
                                    "Ignorar arredondamentos em linguagens específicas",
                                    "Testar só números inteiros"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Java: float f = 0.1f + 0.2f; double d = 0.1 + 0.2; System.out.printf(\"%.20f != 0.3: %b%n\", f, f != 0.3f); System.out.printf(\"%.20f != 0.3: %b%n\", d, d != 0.3); Saída mostra true para float (erro visível) e false para double (mais preciso).",
                              "finalVerifications": [
                                "Explicar corretamente 23 bits mantissa em float vs. 52 em double.",
                                "Converter um número decimal para binário em ambos os formatos.",
                                "Executar código demonstrando perda de precisão em float mas mínima em double.",
                                "Prever corretamente quando usar float vs. double em cenários reais.",
                                "Criar tabela comparativa precisa de precisão e range.",
                                "Identificar erros comuns em representações IEEE 754."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem e explicação dos bits da mantissa (23 vs. 52).",
                                "Correção dos diagramas binários e cálculos de precisão decimal.",
                                "Qualidade e acurácia dos exemplos de código com saídas analisadas.",
                                "Profundidade da comparação teórica vs. prática.",
                                "Identificação correta de implicações para programação.",
                                "Clareza na tabela comparativa e verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aproximações de números reais e erros de arredondamento.",
                                "Física: Simulações numéricas onde precisão afeta resultados (ex: trajetórias).",
                                "Engenharia: Otimização de memória em sistemas embarcados (float para performance).",
                                "Economia/Finanças: Cálculos monetários exigindo alta precisão (double).",
                                "Ciência de Dados: Análise numérica em machine learning."
                              ],
                              "realWorldApplication": "Em jogos 3D, float é usado para coordenadas (performance em GPUs), mas double em simulações científicas ou finanças para evitar erros acumulativos que distorcem resultados críticos, como saldos bancários ou trajetórias orbitais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Determinar faixa de representação",
                            "description": "Calcular a faixa mínima e máxima de valores representáveis por float e double, considerando overflow e underflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a representação IEEE 754 para float (single precision, 32 bits)",
                                  "subSteps": [
                                    "Analisar a estrutura: 1 bit de sinal, 8 bits de expoente (bias 127), 23 bits de mantissa.",
                                    "Explicar o valor decodificado: (-1)^sinal * (1 + mantissa/2^23) * 2^(expoente - 127).",
                                    "Diferenciar números normais (expoente 1-254), subnormais (expoente 0), infinito e NaN.",
                                    "Estudar casos especiais: overflow (expoente 255, mantissa 0 = infinito), underflow (subnormais).",
                                    "Desenhar um diagrama bit a bit de um exemplo de float."
                                  ],
                                  "verification": "Desenhar e explicar corretamente o diagrama de um float representando 1.0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentação IEEE 754 (online), papel e caneta ou editor de diagramas.",
                                  "tips": "Sempre subtraia o bias do expoente para obter o verdadeiro expoente.",
                                  "learningObjective": "Dominar a decodificação da estrutura binária de um float.",
                                  "commonMistakes": "Esquecer o bit implícito '1' na mantissa para números normais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a faixa máxima e mínima para float",
                                  "subSteps": [
                                    "Máximo finito: expoente 254 (11111110), mantissa toda 1s → ≈ 3.4028235 × 10^38.",
                                    "Mínimo normal: expoente 1 (00000001), mantissa 0 → 1.17549435 × 10^-38.",
                                    "Mínimo subnormal: expoente 0, mantissa mínima (000...001) → ≈ 1.4012985 × 10^-45.",
                                    "Verificar com fórmulas: max = (2 - 2^-23) × 2^(127), min_normal = 2^(-126).",
                                    "Listar valores em notação científica e binária."
                                  ],
                                  "verification": "Calcular e anotar os três valores (max, min_normal, min_subnormal) com precisão de 5 casas decimais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica, tabela de potências de 2.",
                                  "tips": "Use 2^(127) = 1.7014118 × 10^38 como base para max.",
                                  "learningObjective": "Calcular precisamente os limites da faixa de float.",
                                  "commonMistakes": "Confundir expoente máximo (254 biased) com 255 (infinito)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender e calcular a faixa para double (64 bits)",
                                  "subSteps": [
                                    "Estrutura: 1 bit sinal, 11 bits expoente (bias 1023), 52 bits mantissa.",
                                    "Fórmula: (-1)^sinal * (1 + mantissa/2^52) * 2^(expoente - 1023).",
                                    "Máximo finito: expoente 2046 → ≈ 1.7976931348623157 × 10^308.",
                                    "Mínimo normal: expoente 1 → ≈ 2.2250738585072014 × 10^-308.",
                                    "Mínimo subnormal: ≈ 4.94065645841247 × 10^-324.",
                                    "Comparar faixas: double tem ~15 dígitos decimais vs. 7 de float."
                                  ],
                                  "verification": "Calcular e comparar os limites de double com float em uma tabela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, documentação IEEE 754 para double.",
                                  "tips": "Bias 1023 é o dobro de 127 (aprox.), facilitando memória.",
                                  "learningObjective": "Dominar cálculos para double e diferenças com float.",
                                  "commonMistakes": "Usar bias errado (127 em vez de 1023)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar overflow e underflow em código",
                                  "subSteps": [
                                    "Em C/C++ ou Java, incluir <limits> ou <float.h> e imprimir FLT_MAX, DBL_MAX, FLT_MIN, DBL_MIN.",
                                    "Testar overflow: somar FLT_MAX + FLT_MAX e observar infinito.",
                                    "Testar underflow: dividir número pequeno por grande e verificar subnormal ou zero.",
                                    "Usar union para inspecionar bits: union {float f; unsigned int i;} e printf bits.",
                                    "Compilar e executar, anotar saídas."
                                  ],
                                  "verification": "Executar código que imprime limites e demonstra overflow/underflow com saídas corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C/C++ (GCC/Clang), IDE como VS Code.",
                                  "tips": "Use %a para printf imprimir representação hexadecimal de float.",
                                  "learningObjective": "Aplicar conceitos em prática programática.",
                                  "commonMistakes": "Ignorar que FLT_MIN é min_normal, não subnormal (use DBL_TRUE_MIN)."
                                }
                              ],
                              "practicalExample": "Em um simulador de física, calcular trajetórias com double para evitar overflow em distâncias cósmicas (10^300 m), enquanto float underflow em escalas quânticas (10^-40 m). Código C: printf(\"FLT_MAX: %e\\n\", FLT_MAX); float ov = FLT_MAX * 2.0f; printf(\"Overflow: %a\\n\", ov); // inf",
                              "finalVerifications": [
                                "Calcular corretamente max/min para float e double com precisão.",
                                "Explicar diferença entre normais e subnormais.",
                                "Identificar overflow/underflow em exemplo de código.",
                                "Desenhar estrutura IEEE para ambos os tipos.",
                                "Comparar faixas numéricas em tabela.",
                                "Executar código demonstrando limites."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de expoentes e mantissas (erro <1%).",
                                "Correta distinção de casos especiais (infinito, NaN, subnormais).",
                                "Implementação funcional de código com saídas esperadas.",
                                "Explicação clara de fórmulas IEEE 754.",
                                "Identificação de 3+ erros comuns evitados.",
                                "Conexão prática com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Notação científica e logaritmos para faixas exponenciais.",
                                "Física: Precisão numérica em simulações (ex: mecânica quântica vs. relativística).",
                                "Engenharia de Software: Análise de estabilidade numérica em algoritmos.",
                                "Análise Numérica: Estudo de erros de arredondamento e condicionamento."
                              ],
                              "realWorldApplication": "Em aplicações científicas como modelagem climática ou finanças, usar double para faixas amplas (ex: simular temperaturas de 10^-300 K a 10^300 K sem overflow), evitando crashes por underflow em probabilidades pequenas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Precisão e Limitações dos Tipos em Ponto Flutuante",
                        "description": "Erros inerentes devido à precisão finita, como arredondamento, perda de significância e impossibilidade de representar certos decimais exatamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Identificar números não representáveis exatamente",
                            "description": "Exemplificar frações decimais como 0.1 que resultam em representações aproximadas em binário e demonstrar com código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a representação binária de números de ponto flutuante",
                                  "subSteps": [
                                    "Revise o formato IEEE 754 para float32 e float64, identificando sinal, expoente e mantissa.",
                                    "Aprenda como frações decimais são convertidas para binário fracionário (ex: 0.5 = 0.1 em binário).",
                                    "Identifique que nem todas as frações decimais têm representação finita em binário, similar a 1/3 em decimal.",
                                    "Pratique convertendo números simples como 0.5 e 0.25 para binário.",
                                    "Discuta limitações: apenas potências negativas de 2 são exatas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que 0.5 é exatamente representável, mas 0.1 não.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação IEEE 754 online, calculadora de conversão binária (ex: onlinebinarytools.com)",
                                  "tips": "Use diagramas visuais para separar sinal, expoente e mantissa.",
                                  "learningObjective": "Compreender o formato binário de ponto flutuante e por que algumas frações são inexatas.",
                                  "commonMistakes": "Confundir representação decimal com binária; assumir que todos os decimais são finitos em binário."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter 0.1 manualmente para binário e identificar inexatidão",
                                  "subSteps": [
                                    "Multiplique 0.1 por 2 repetidamente: 0.1 * 2 = 0.2 (0), 0.2 * 2 = 0.4 (0), etc., gerando bits fracionários.",
                                    "Continue até detectar o padrão repetitivo: 0.1 em binário é 0.0001100110011... (repetindo 0011).",
                                    "Compare com representação finita: trunca após 52 bits para double precision.",
                                    "Calcule o erro de arredondamento aproximado.",
                                    "Registre a fração binária aproximada: aproximadamente 0.1000000000000000055511151231257827021181583404541015625."
                                  ],
                                  "verification": "Mostre o processo de multiplicação por 2 em papel ou ferramenta, destacando o loop infinito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta ou planilha Excel para multiplicações, ferramenta online como binaryconvert.com",
                                  "tips": "Pare após 20 iterações para ver o padrão; use frações como 1/10 = 1/(2*5) para entender denominadores.",
                                  "learningObjective": "Realizar conversão manual de 0.1 para binário e reconhecer sua natureza periódica.",
                                  "commonMistakes": "Parar cedo achando que termina; ignorar o impacto do arredondamento na mantissa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar limitações com código em Python",
                                  "subSteps": [
                                    "Escreva código para imprimir 0.1 em formato hexadecimal: format(0.1, '.50f') e '{:a}'.format(0.1).",
                                    "Execute print(0.1 + 0.2 == 0.3) para mostrar False devido a erros de precisão.",
                                    "Use decimal module para comparação: from decimal import Decimal; print(Decimal('0.1')).",
                                    "Visualize bits com struct: import struct; struct.unpack('!Q', struct.pack('!d', 0.1))[0].",
                                    "Teste outros números como 0.3 para reforçar o conceito."
                                  ],
                                  "verification": "Execute o código e capture saída mostrando representação inexata de 0.1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python 3 instalado (ou online como repl.it), editor de código como VS Code",
                                  "tips": "Use '{:.17g}' para ver precisão real; compare float vs Decimal.",
                                  "learningObjective": "Implementar e executar código que revela representações aproximadas em ponto flutuante.",
                                  "commonMistakes": "Usar print(0.1) que arredonda para 0.1; não importar módulos corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos e soluções para números inexatos",
                                  "subSteps": [
                                    "Discuta erros cumulativos em somas repetidas: 0.1 * 10 != 1.0.",
                                    "Explore soluções: usar integers para finanças (centavos), bibliotecas como decimal ou fractions.",
                                    "Teste código com loop: soma = 0; for i in range(10): soma += 0.1; print(soma).",
                                    "Compare precisões float32 vs float64.",
                                    "Documente quando usar ponto flutuante vs alternativas."
                                  ],
                                  "verification": "Crie relatório curto com saídas de código e explicação de uma solução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmo ambiente Python do step anterior, notebook Jupyter para visualização",
                                  "tips": "Sempre teste == com epsilon: abs(a - b) < 1e-9.",
                                  "learningObjective": "Identificar impactos práticos e mitigações para limitações de precisão.",
                                  "commonMistakes": "Ignorar que double tem mais bits mas ainda arredonda; superestimar exatidão de float."
                                }
                              ],
                              "practicalExample": "Em Python: print(0.1 + 0.2) resulta em 0.30000000000000004, não 0.3 exato, demonstrando arredondamento binário de 0.1 e 0.2.",
                              "finalVerifications": [
                                "Explicar manualmente a conversão de 0.1 para binário repetitivo.",
                                "Executar código mostrando '{:a}'.format(0.1) como '0x1.999999999999ap-4'.",
                                "Demonstrar 0.1 + 0.2 != 0.3 e corrigir com Decimal.",
                                "Identificar que 1/2, 1/4 são exatos, mas 1/10 não.",
                                "Propor solução para soma de 0.1 dez vezes não igual a 1.0.",
                                "Comparar representação em float32 vs float64."
                              ],
                              "assessmentCriteria": [
                                "Precisão na conversão manual de 0.1 para binário (padrão repetitivo identificado).",
                                "Código funcional revelando representação interna e erros de comparação.",
                                "Explicação clara de causas IEEE 754 e arredondamento.",
                                "Uso correto de ferramentas como Decimal para mitigação.",
                                "Análise de impactos reais com exemplos concretos.",
                                "Relatório organizado com verificações passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expansões fracionárias binárias e convergência de séries.",
                                "Física: Simulações numéricas onde erros de precisão afetam resultados (ex: trajetórias).",
                                "Economia/Finanças: Cálculos monetários exigindo precisão exata.",
                                "Algoritmos: Importância de tipos de dados em buscas e ordenações."
                              ],
                              "realWorldApplication": "Em sistemas financeiros, somas de valores decimais como $0.10 podem acumular erros, levando a discrepâncias de centavos; soluções usam centavos como integers ou Decimal para evitar fraudes ou perdas em transações bancárias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Analisar erros de arredondamento em operações",
                            "description": "Observar acumulação de erros em somas e multiplicações repetidas de números de ponto flutuante e quantificar a perda de precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a representação IEEE 754 e erros de arredondamento básicos",
                                  "subSteps": [
                                    "Estude o formato IEEE 754 para single (float) e double precision.",
                                    "Converta números decimais como 0.1 para binário e observe a representação aproximada.",
                                    "Identifique os modos de arredondamento (round to nearest, etc.).",
                                    "Execute exemplos simples em uma linguagem como Python ou C++ para ver o valor binário de float(0.1).",
                                    "Compare precisão entre float e double."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que 0.1 + 0.2 != 0.3 em ponto flutuante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação IEEE 754",
                                    "Python ou Jupyter Notebook",
                                    "Calculadora de ponto flutuante online (ex: ieee754-visualization)"
                                  ],
                                  "tips": "Sempre verifique a representação binária para entender a origem do erro.",
                                  "learningObjective": "Entender como números decimais são aproximados em binário e geram erros iniciais de arredondamento.",
                                  "commonMistakes": [
                                    "Assumir que decimais têm representação exata em binário",
                                    "Ignorar a diferença entre float e double",
                                    "Confundir erro de arredondamento com erro de truncamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Observar acumulação de erros em somas repetidas",
                                  "subSteps": [
                                    "Implemente um loop para somar 0.1 dez vezes e compare com o valor exato 1.0.",
                                    "Registre o valor computado após 1, 5 e 10 iterações.",
                                    "Repita com 1000 iterações e observe a deriva cumulativa.",
                                    "Use print com alta precisão (ex: format com 20 casas decimais).",
                                    "Compare soma em ordem reversa para ver impacto da associatividade."
                                  ],
                                  "verification": "Mostre que após 10 somas de 0.1, o resultado difere de 1.0 em pelo menos 1e-16.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente de programação (Python/C++)",
                                    "Notebook Jupyter para gráficos opcionais"
                                  ],
                                  "tips": "Use funções como f'{x:.20f}' em Python para visualizar erros pequenos.",
                                  "learningObjective": "Demonstrar como erros de arredondamento se acumulam em operações de soma iterativas.",
                                  "commonMistakes": [
                                    "Não usar precisão suficiente na saída",
                                    "Ignorar a ordem das somas",
                                    "Confundir erro com limitação da tela"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar erros em multiplicações repetidas",
                                  "subSteps": [
                                    "Implemente um loop para multiplicar 1.0001 por si mesmo 1000 vezes (aprox. e^1).",
                                    "Compare com o valor exato usando math.exp(1) ou bibliotecas de precisão arbitrária.",
                                    "Teste com diferentes fatores como 0.9999 para observar deriva negativa.",
                                    "Meça o erro após 100, 500 e 1000 iterações.",
                                    "Experimente com float vs double para comparar sensibilidades."
                                  ],
                                  "verification": "Calcule que após 1000 multiplicações por 1.0001, o erro relativo excede 1e-10 em float.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com decimal module para exato",
                                    "Gráficos de erro vs iterações"
                                  ],
                                  "tips": "Use Decimal('1.0001') para baseline exato e compare com float.",
                                  "learningObjective": "Identificar como multiplicações repetidas amplificam erros de arredondamento.",
                                  "commonMistakes": [
                                    "Não ter um baseline exato",
                                    "Usar poucos iterações para ver acumulação",
                                    "Esquecer de normalizar erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Quantificar a perda de precisão e mitigações",
                                  "subSteps": [
                                    "Calcule erro absoluto e relativo: |computed - exact| / |exact|.",
                                    "Analise o número de casas decimais perdidas (ex: machine epsilon).",
                                    "Teste técnicas de mitigação: soma compensada (Kahan), usar double.",
                                    "Gere um relatório com tabelas de erros para soma e multiplicação.",
                                    "Discuta limites de precisão condicional."
                                  ],
                                  "verification": "Produza um gráfico ou tabela mostrando erro relativo crescendo com iterações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Biblioteca decimal ou mpmath",
                                    "Matplotlib para gráficos"
                                  ],
                                  "tips": "Epsilon de máquina (~1e-16 para double) é o limite teórico por operação.",
                                  "learningObjective": "Quantificar perda de precisão e introduzir métodos para análise e redução de erros.",
                                  "commonMistakes": [
                                    "Erro relativo sem normalização",
                                    "Ignorar overflow/underflow",
                                    "Não considerar custo computacional de mitigações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: s = 0.0; for _ in range(10): s += 0.1; print(s) resulta em 0.9999999999999999 ao invés de 1.0. Repita 1000x e quantifique o desvio de 100.0.",
                              "finalVerifications": [
                                "Explicar representação binária aproximada de 0.1.",
                                "Demonstrar acumulação em soma de 0.1 x 1000 com erro > 1e-10.",
                                "Mostrar multiplicação 1.0001^1000 desviando de e^1 em >1e-8 para float.",
                                "Calcular erro relativo corretamente em exemplos.",
                                "Identificar quando usar double ou bibliotecas de alta precisão.",
                                "Propor uma mitigação simples para soma acumulada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de IEEE 754 (80% cobertura dos componentes).",
                                "Códigos executáveis reproduzindo erros com saídas corretas.",
                                "Cálculos de erro relativo com <5% de discrepância.",
                                "Análise qualitativa da acumulação (causalidade correta).",
                                "Sugestões de boas práticas em software realistas.",
                                "Relatório claro com tabelas/gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Erros de Propagação.",
                                "Física: Simulações Numéricas em Mecânica (integração temporal).",
                                "Estatística: Erros em Simulações Monte Carlo.",
                                "Engenharia: Validação de Modelos Computacionais."
                              ],
                              "realWorldApplication": "Em finanças, erros acumulados em cálculos de juros compostos diários podem levar a discrepâncias milionárias; em jogos, física em ponto flutuante causa 'tremores' em posições; em ML, gradientes descendentes divergem por perda de precisão em epochs longas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Aplicar técnicas para comparações seguras",
                            "description": "Usar epsilon para comparações de igualdade entre floats em vez de ==, e explicar o motivo em contextos de programação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as limitações da precisão em ponto flutuante",
                                  "subSteps": [
                                    "Explicar a representação binária dos números de ponto flutuante IEEE 754 e por que nem todos os decimais são representáveis exatamente.",
                                    "Executar um exemplo simples em código: calcular 0.1 + 0.2 e comparar com 0.3 usando ==.",
                                    "Imprimir os valores com alta precisão (ex: format com 20 casas decimais) para visualizar a diferença.",
                                    "Discutir impactos em loops, somas acumulativas e cálculos iterativos."
                                  ],
                                  "verification": "Executar código que demonstra 0.1 + 0.2 != 0.3 e imprimir os valores exatos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código com Python (ex: VS Code, Jupyter Notebook)",
                                    "Console Python interativo"
                                  ],
                                  "tips": "Use print(f'{valor:.20f}') para revelar a precisão real.",
                                  "learningObjective": "Identificar e demonstrar por que comparações exatas com == falham em floats.",
                                  "commonMistakes": [
                                    "Acreditar que é um erro de arredondamento simples sem investigar representação binária",
                                    "Usar == em testes unitários sem considerar precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de comparação com tolerância (Epsilon)",
                                  "subSteps": [
                                    "Definir epsilon como uma pequena tolerância positiva (ex: 1e-9 ou 1e-12) baseada na magnitude dos números.",
                                    "Explicar a fórmula: abs(a - b) < epsilon para considerar a e b 'iguais'.",
                                    "Discutir escolha de epsilon: relativo vs absoluto, dependendo do contexto (ex: eps * max(abs(a), abs(b)) para relativo).",
                                    "Comparar com outras abordagens como diferença relativa."
                                  ],
                                  "verification": "Escrever e explicar a fórmula de comparação em pseudocódigo ou comentário no código.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação IEEE 754 (opcional)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Comece com epsilon fixo de 1e-9 para simplicidade; ajuste baseado em testes.",
                                  "learningObjective": "Entender o papel da tolerância na comparação segura de floats.",
                                  "commonMistakes": [
                                    "Escolher epsilon muito grande (causa falsos positivos) ou muito pequeno (falsos negativos)",
                                    "Confundir epsilon absoluto com relativo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar funções de comparação segura",
                                  "subSteps": [
                                    "Criar função is_close(a, b, eps=1e-9): return abs(a - b) < eps.",
                                    "Implementar versão relativa: rel_eps = eps * max(abs(a), abs(b)); return abs(a - b) < rel_eps.",
                                    "Testar a função com exemplos: 0.1 + 0.2 vs 0.3, e casos edge como 1e10 + 1e-5.",
                                    "Integrar em uma condição if para lógica de programa."
                                  ],
                                  "verification": "Executar testes unitários onde is_close(0.1 + 0.2, 0.3) retorna True, mas == retorna False.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com biblioteca math (opcional para ulp)",
                                    "Ferramentas de teste como assert"
                                  ],
                                  "tips": "Use bibliotecas como numpy.isclose() como referência, mas implemente manualmente.",
                                  "learningObjective": "Desenvolver e testar código reutilizável para comparações seguras.",
                                  "commonMistakes": [
                                    "Esquecer tratamento para NaN ou Inf (use math.isnan)",
                                    "Não testar com números grandes/pequenos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar em um cenário prático",
                                  "subSteps": [
                                    "Calcular distância euclidiana entre dois pontos próximos devido a cálculos flutuantes.",
                                    "Usar == vs is_close para verificar se distância < threshold (ex: colisão).",
                                    "Executar múltiplos testes: somas, subtrações, funções trigonométricas (sin(pi) ≈ 0).",
                                    "Refatorar código existente substituindo == por is_close onde apropriado."
                                  ],
                                  "verification": "Programa roda sem falhas lógicas e passa todos os testes de precisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código de exemplo com pontos 2D",
                                    "Gráfico opcional para visualizar (matplotlib)"
                                  ],
                                  "tips": "Sempre inclua epsilon como parâmetro default na função para flexibilidade.",
                                  "learningObjective": "Aplicar técnica em contexto real e debugar issues de precisão.",
                                  "commonMistakes": [
                                    "Ignorar direção da diferença (use abs sempre)",
                                    "Aplicar epsilon em inteiros por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Revisar e otimizar para uso geral",
                                  "subSteps": [
                                    "Analisar desempenho: impacto em loops intensivos.",
                                    "Explorar bibliotecas: math.isclose() em Python 3.5+ e quando usá-las.",
                                    "Documentar função com docstring explicando uso e escolha de eps.",
                                    "Criar conjunto de testes abrangente para diferentes magnitudes."
                                  ],
                                  "verification": "Função documentada e testes cobrem 90% dos casos comuns.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "pytest ou unittest para automação"
                                  ],
                                  "tips": "Prefira math.isclose() em produção para robustez.",
                                  "learningObjective": "Tornar a técnica escalável e mantível em projetos reais.",
                                  "commonMistakes": [
                                    "Sobrecarregar com otimizações prematuras",
                                    "Não documentar escolha de epsilon"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um simulador de física 2D, calcule a distância entre dois objetos após atualização de posição: dist = sqrt((x2 - x1)**2 + (y2 - y1)**2). Use is_close(dist, 0, eps=1e-6) para detectar colisão exata, evitando falhas como dist = 1e-15 != 0 devido a precisão.",
                              "finalVerifications": [
                                "Explicar corretamente por que 0.1 + 0.2 != 0.3 em floats.",
                                "Implementar e testar função is_close que passa em 5+ exemplos falhos de ==.",
                                "Identificar e corrigir uso de == em código fornecido.",
                                "Escolher epsilon apropriado para 3 contextos diferentes (pequeno, médio, grande números).",
                                "Documentar função com explicação do motivo e uso."
                              ],
                              "assessmentCriteria": [
                                "Código correto e eficiente sem erros de precisão.",
                                "Explicação clara do problema e solução (IEEE 754, epsilon).",
                                "Testes abrangentes cobrindo casos edge (NaN, Inf, zero).",
                                "Aplicação correta em exemplo prático sem falsos positivos/negativos.",
                                "Documentação completa incluindo escolha de epsilon."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e erros de arredondamento.",
                                "Física: Simulações computacionais com precisão limitada.",
                                "Engenharia de Software: Boas práticas em testes unitários e robustez.",
                                "Estatística: Comparações em dados flutuantes de experimentos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos para detecção precisa de colisões sem 'fantasmas'; em finanças para validação de totais após múltiplos arredondamentos; em machine learning para comparações de gradientes e pesos numéricos; em simulações científicas (ex: clima, física de partículas) onde precisão afeta resultados cumulativos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Tipos Caractere e Lógico",
                    "description": "Manipulação de caracteres individuais e valores booleanos verdadeiro/falso.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Tipo Caractere",
                        "description": "Representação de caracteres individuais (como letras, dígitos ou símbolos) utilizando o tipo de dado caractere (char), incluindo declaração, atribuição, entrada e saída.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Declarar variável caractere",
                            "description": "Criar uma variável do tipo caractere (char) para armazenar um único símbolo, utilizando a sintaxe básica de declaração em linguagens procedimentais como C++ ou Python (ex: char c; ou c = 'A').",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variável caractere",
                                  "subSteps": [
                                    "Leia a definição de tipo caractere: um tipo de dado primitivo que armazena um único símbolo Unicode ou ASCII (ex: 'A', '1', '@').",
                                    "Diferencie de strings: char armazena 1 byte (em C++), enquanto strings armazena sequências.",
                                    "Estude a tabela ASCII para entender valores numéricos associados a caracteres (ex: 'A' = 65).",
                                    "Identifique usos comuns: armazenamento de letras, dígitos e símbolos em programas.",
                                    "Anote exemplos de caracteres válidos ('a'-'z', '0'-9', espaços) e inválidos (múltiplos chars)."
                                  ],
                                  "verification": "Resuma em suas palavras o que é uma variável char e liste 5 exemplos válidos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação de tipos de dados em C++ (ex: cppreference.com)",
                                    "Tabela ASCII impressa ou online"
                                  ],
                                  "tips": "Visualize chars como números disfarçados de símbolos para facilitar o entendimento.",
                                  "learningObjective": "Explicar o propósito e limitações de variáveis do tipo char.",
                                  "commonMistakes": [
                                    "Confundir char com string (ex: usar \"AB\" em char)",
                                    "Ignorar que char é signed/unsigned por padrão em algumas compilers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe de declaração em C++",
                                  "subSteps": [
                                    "Abra um editor de código (ex: VS Code, Code::Blocks).",
                                    "Escreva a sintaxe básica: 'char nomeVariavel;' (ex: char c;).",
                                    "Declare múltiplas variáveis: 'char inicial, final;'",
                                    "Experimente declaração com inicialização: 'char letra = 'A';'",
                                    "Adicione #include <iostream> e using namespace std; para testes futuros."
                                  ],
                                  "verification": "Crie 3 declarações válidas de char em um arquivo .cpp sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto/IDE com suporte a C++ (ex: VS Code com extensão C++)",
                                    "Compilador g++ instalado"
                                  ],
                                  "tips": "Sempre use aspas simples ' ' para chars, nunca duplas \" \".",
                                  "learningObjective": "Dominar a sintaxe exata para declarar variáveis char em C++.",
                                  "commonMistakes": [
                                    "Usar aspas duplas para char (causa erro de tipo)",
                                    "Esquecer ponto e vírgula no final da declaração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar e manipular a variável char",
                                  "subSteps": [
                                    "Atribua valores: c = 'B'; ou na declaração char c = 'Z';",
                                    "Teste atribuição dinâmica: cin >> c; para input do usuário.",
                                    "Imprima o valor: cout << c << endl;",
                                    "Converta char para int: int ascii = (int)c; e imprima.",
                                    "Teste limites: tente atribuir múltiplos chars (deve falhar em compile-time)."
                                  ],
                                  "verification": "Execute um código que declara, inicializa via input e imprime um char corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal para compilar e executar (g++ arquivo.cpp -o exec && ./exec)",
                                    "Exemplos de código prontos para referência"
                                  ],
                                  "tips": "Use cout << (int)c; para ver o código ASCII e debugar.",
                                  "learningObjective": "Inicializar e usar variáveis char em expressões simples.",
                                  "commonMistakes": [
                                    "Atribuir string a char (ex: c = \"A\";)",
                                    "Não incluir <iostream> causando erro de cin/cout"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar um programa completo com char",
                                  "subSteps": [
                                    "Escreva um programa que declara char, lê do usuário e verifica se é letra (usando isalpha(c) de <cctype>).",
                                    "Compile: g++ -o teste teste.cpp",
                                    "Execute e teste com inputs válidos ('A') e inválidos (números múltiplos).",
                                    "Corrija erros comuns como warnings de char signed/unsigned.",
                                    "Salve o código funcional e anote lições aprendidas."
                                  ],
                                  "verification": "Programa compila sem erros/warnings e processa 5 inputs diferentes corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C++ (g++)",
                                    "Header <cctype> para funções como isalpha"
                                  ],
                                  "tips": "Compile com -Wall para pegar warnings precocemente.",
                                  "learningObjective": "Integrar declaração de char em um programa funcional e depurá-lo.",
                                  "commonMistakes": [
                                    "Não flushar input com cin.ignore()",
                                    "Ignorar diferenças entre char e unsigned char em valores altos"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa C++ simples: #include <iostream> int main() { char inicial; std::cout << \"Digite uma letra: \"; std::cin >> inicial; std::cout << \"ASCII: \" << (int)inicial << std::endl; return 0; } Saída para 'A': ASCII: 65",
                              "finalVerifications": [
                                "Declara char sem erros de sintaxe.",
                                "Inicializa e atribui valores únicos corretamente.",
                                "Compila e executa programa com input/output de char.",
                                "Converte char para int (ASCII) sem problemas.",
                                "Identifica e corrige 3 erros comuns listados.",
                                "Explica diferença entre char e string em 1 frase."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: 100% das declarações compilam.",
                                "Funcionalidade: Programa lê, armazena e imprime char corretamente.",
                                "Compreensão conceitual: Explica ASCII e limites de char.",
                                "Depuração: Identifica e corrige erros independentes.",
                                "Eficiência: Código limpo, sem warnings, com boas práticas.",
                                "Criatividade: Adiciona verificação extra (ex: isalpha)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Códigos ASCII como representação numérica de símbolos.",
                                "Língua Portuguesa: Manipulação de caracteres alfabéticos e acentuados.",
                                "Física/Engenharia: Codificação de sinais em eletrônica digital.",
                                "História da Computação: Evolução de tipos de dados de EBCDIC para Unicode."
                              ],
                              "realWorldApplication": "Em software embarcado, chars armazenam comandos de teclados ou sensores; em jogos, representam teclas pressionadas; em bancos, validam formatos de CPF (dígitos como char)."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Atribuir valor a variável caractere",
                            "description": "Atribuir um valor literal de caractere a uma variável char, diferenciando aspas simples de aspas duplas e compreendendo códigos ASCII básicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Tipo de Dado Char e Literais de Caractere",
                                  "subSteps": [
                                    "Estude a definição: char é um tipo primitivo que armazena um único caractere Unicode/ASCII em 1 byte.",
                                    "Aprenda sobre literais de caractere: representados por aspas simples, ex: 'A', '5', '$'.",
                                    "Identifique o range ASCII básico: 0 a 127, onde 'A' é 65, 'a' é 97.",
                                    "Diferencie de números inteiros: char é simbólico, mas pode ser convertido numericamente.",
                                    "Revise exemplos: ' ' (espaço) é 32, '\\n' (nova linha) é escape sequence."
                                  ],
                                  "verification": "Escreva 5 exemplos de literais char e seus códigos ASCII equivalentes sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela ASCII básica (impressa ou online)",
                                    "Documentação oficial da linguagem C/C++ sobre tipos char"
                                  ],
                                  "tips": "Sempre use aspas simples para char; duplas são para strings.",
                                  "learningObjective": "Dominar conceitos fundamentais de char e sua representação literal.",
                                  "commonMistakes": [
                                    "Usar aspas duplas para char (causa erro de tipo)",
                                    "Confundir char com string ou int"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma Variável do Tipo Char",
                                  "subSteps": [
                                    "Escreva a sintaxe: char nomeVariavel; ou char nomeVariavel = 'valor';",
                                    "Declare variáveis sem inicialização e observe comportamento (pode conter lixo).",
                                    "Inicialize com literais: char vogal = 'a';",
                                    "Teste em diferentes linguagens se aplicável (C, Java, Python com ord()/chr()).",
                                    "Compile um programa simples apenas com declaração."
                                  ],
                                  "verification": "Criar e compilar código com 3 declarações char diferentes sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Dev-C++)",
                                    "Compilador C (GCC)"
                                  ],
                                  "tips": "Inicialize sempre para evitar valores indeterminados.",
                                  "learningObjective": "Saber declarar corretamente variáveis char de forma segura.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula",
                                    "Declarar como char[] acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atribuir e Manipular Valores em Variáveis Char",
                                  "subSteps": [
                                    "Atribua literais: char c = 'Z'; c = '!';",
                                    "Use atribuição com variáveis: char a = 'A'; char b = a;",
                                    "Inclua escape sequences: char newline = '\\n'; char tab = '\\t';",
                                    "Imprima valores: printf(\"%c\", c); ou cout << c;",
                                    "Teste atribuição inválida (ex: múltiplos chars) para ver erros."
                                  ],
                                  "verification": "Executar programa que atribui, imprime e altera 4 chars diferentes corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador",
                                    "Tabela de escape sequences ASCII"
                                  ],
                                  "tips": "Use %c para imprimir char, não %s.",
                                  "learningObjective": "Executar atribuições precisas e imprimir chars corretamente.",
                                  "commonMistakes": [
                                    "Atribuir string como \"ab\" a char",
                                    "Imprimir com printf(\"%s\", c)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Char de String e Integrar Códigos ASCII",
                                  "subSteps": [
                                    "Compare: char c = 'a'; vs. char* s = \"a\"; (string literal).",
                                    "Converta ASCII para char: char num65 = 65; // 'A'",
                                    "Use funções: isalpha(c), tolower(c) para manipulação.",
                                    "Crie programa que converte código ASCII para char e vice-versa.",
                                    "Identifique erros comuns em cenários reais de input."
                                  ],
                                  "verification": "Escrever e rodar código que demonstra diferenças e conversões ASCII-char sem bugs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência de funções char (ctype.h em C)",
                                    "Calculadora para ASCII"
                                  ],
                                  "tips": "Lembre: aspas simples = 1 char; duplas = array de chars terminando em \\0.",
                                  "learningObjective": "Distinguir char de string e usar códigos ASCII efetivamente.",
                                  "commonMistakes": [
                                    "Tratar char como string em funções",
                                    "Ignorar valores signed/unsigned de char"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C: #include <stdio.h> int main() { char inicial = 'J'; printf(\"Inicial: %c (ASCII: %d)\\n\", inicial, (int)inicial); inicial = 66; printf(\"Nova: %c\\n\", inicial); return 0; } // Saída: Inicial: J (ASCII: 74) Nova: B",
                              "finalVerifications": [
                                "Compilar e executar código sem warnings/erros de tipo.",
                                "Imprimir chars corretos com %c e códigos ASCII com %d.",
                                "Demonstrar diferença: 'A' compila, \"A\" em char falha.",
                                "Converter bidirecionalmente ASCII <-> char.",
                                "Evitar overflows atribuindo valores fora de 0-127.",
                                "Usar escape sequences sem erros de sintaxe."
                              ],
                              "assessmentCriteria": [
                                "Correção na declaração e atribuição (sem erros de compilação).",
                                "Uso preciso de aspas simples vs. duplas.",
                                "Compreensão demonstrada via conversão ASCII-char.",
                                "Impressão e manipulação sem bugs comuns.",
                                "Explicação clara das diferenças char/string.",
                                "Eficiência: código mínimo e funcional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação numérica de símbolos via códigos ASCII (aritmética modular 256).",
                                "Língua Portuguesa: Análise de caracteres alfabéticos e acentos em encodings.",
                                "Física/Engenharia: Sinais digitais e codificação binária de caracteres.",
                                "História: Evolução do ASCII na computação dos anos 1960."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, atribuir chars é essencial para validação de senhas (verificar caracteres especiais), processamento de texto em editores (inserir símbolos), interfaces de usuário (ícones/char especiais) e protocolos de rede (parsing de headers com chars delimitadores)."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Entrada de caractere",
                            "description": "Ler um caractere individual do teclado utilizando comandos de entrada como scanf('%c') em C++ ou input() em Python, tratando possíveis espaços ou quebras de linha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os comandos de entrada para caracteres em C++ e Python",
                                  "subSteps": [
                                    "Estude a documentação de scanf('%c') em C++: ele lê exatamente um caractere do stdin, incluindo espaços.",
                                    "Analise input() em Python: retorna uma string, então use [0] para o primeiro caractere.",
                                    "Compare diferenças: C++ lê binário, Python lê como string; ambos sensíveis a buffers.",
                                    "Identifique problemas comuns: espaços em branco e quebras de linha no buffer.",
                                    "Anote exemplos simples de código para cada linguagem."
                                  ],
                                  "verification": "Crie um diagrama ou tabela comparando scanf('%c') e input() com exemplos de saída esperada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação oficial C++ (cppreference.com), Python docs (docs.python.org), editor de texto",
                                  "tips": "Use exemplos interativos online como repl.it para testar conceitos sem setup.",
                                  "learningObjective": "Diferenciar mecanismos de entrada de caractere em C++ e Python, reconhecendo limitações de buffer.",
                                  "commonMistakes": "Confundir input() como leitura direta de char (é string); ignorar que scanf('%c') consome espaços."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar leitura básica de caractere em C++ usando scanf",
                                  "subSteps": [
                                    "Inclua <cstdio> para scanf.",
                                    "Declare uma variável char, ex: char c;",
                                    "Use scanf('%c', &c); para ler.",
                                    "Imprima o caractere lido com printf('%c\n', c);",
                                    "Compile e execute: g++ programa.cpp -o prog && ./prog"
                                  ],
                                  "verification": "Execute o programa e insira 'A' + Enter; deve imprimir 'A' sem capturar Enter.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Compilador GCC (Code::Blocks ou VS Code com C++ extension)",
                                  "tips": "Sempre passe & para variáveis em scanf.",
                                  "learningObjective": "Escrever e executar código C++ que leia um único caractere corretamente.",
                                  "commonMistakes": "Esquecer &c em scanf (leva a lixo ou crash); não incluir <cstdio>."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar leitura básica de caractere em Python usando input",
                                  "subSteps": [
                                    "Use c = input()[0] para capturar o primeiro caractere.",
                                    "Imprima com print(c).",
                                    "Teste com entrada 'B Enter': deve capturar 'B'.",
                                    "Adicione try-except para entradas vazias.",
                                    "Salve como .py e execute: python programa.py"
                                  ],
                                  "verification": "Insira 'X' + Enter; saída deve ser 'X'; teste com espaço primeiro.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python 3 instalado (IDLE ou Jupyter Notebook)",
                                  "tips": "input() inclui newline; slice [0] resolve para char único.",
                                  "learningObjective": "Criar script Python que extraia e processe um caractere de entrada de usuário.",
                                  "commonMistakes": "Usar input() sem [0] (retorna string inteira); não tratar input vazio."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratar espaços, quebras de linha e edge cases em ambos os códigos",
                                  "subSteps": [
                                    "Em C++: Use scanf(' %c', &c); (espaço ignora whitespace).",
                                    "Em Python: c = input().strip()[0] if input().strip() else ' ';",
                                    "Teste casos: espaço + char, múltiplos Enter, char especial como Enter.",
                                    "Adicione loop para múltiplas leituras até 'q'.",
                                    "Compare saídas e ajuste."
                                  ],
                                  "verification": "Digite ' A' (espaço + A + Enter); deve ler 'A' em ambos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmos compiladores/IDEs dos steps anteriores",
                                  "tips": "Em C++, espaço antes %c é chave para pular whitespace.",
                                  "learningObjective": "Modificar códigos para lidar robustamente com inputs malformados.",
                                  "commonMistakes": "Não limpar buffer em C++ (use getchar() após); strip() em Python esquece chars como espaço intencional."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e integrar em um programa prático completo",
                                  "subSteps": [
                                    "Crie programa que leia char e classifique: vogal/consoante/outro.",
                                    "Implemente em C++ e Python separadamente.",
                                    "Teste 10 inputs variados: vogais maiúsc/minúsc, consoantes, símbolos, espaços.",
                                    "Meça precisão e registre falhas.",
                                    "Refatore com funções para reutilização."
                                  ],
                                  "verification": "Programa classifica corretamente todos testes; sem crashes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDEs com debugger (CLion para C++, PyCharm para Python)",
                                  "tips": "Use toupper() em C++ para case-insensitive.",
                                  "learningObjective": "Construir aplicação funcional usando entrada de caractere tratada.",
                                  "commonMistakes": "Case sensitivity em checks; não validar range ASCII."
                                }
                              ],
                              "practicalExample": "Programa que lê um caractere e informa se é vogal (A,E,I,O,U,a,e,i,o,u): em C++, use scanf(' %c', &c); if(strchr(\"AEIOUaeiou\", c)) printf(\"Vogal\"); similar em Python com c = input().strip().lower()[0] if input().strip() else '?';",
                              "finalVerifications": [
                                "Código lê corretamente char após espaços ou Enter múltiplos.",
                                "Não crasha com input vazio ou só whitespace.",
                                "Classifica vogais/consoantes/symbols precisamente.",
                                "Funciona em ambos C++ e Python sem warnings.",
                                "Tempo de execução <1s para 100 inputs.",
                                "Saída matches exatamente input esperado (ignore case onde aplicável)."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% acerto em 10+ test cases variados.",
                                "Robustez: Trata todos edge cases (espaços, newlines, empty).",
                                "Eficiência: Código limpo, sem loops desnecessários.",
                                "Legibilidade: Comentários e nomes variáveis claros.",
                                "Portabilidade: Funciona em múltiplas plataformas/compiladores.",
                                "Documentação: Explica tratamentos de buffer no código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Códigos ASCII/Unicode para chars (valores numéricos).",
                                "Lógica: Condicionais e switches para classificação de chars.",
                                "Inglês: Leitura de docs técnicas em inglês (cppreference, Python docs).",
                                "Design de Software: Validação de input e user experience."
                              ],
                              "realWorldApplication": "Em editores de texto ou jogos CLI, ler teclas para menus (ex: 'S' para salvar); validação de forms web (captura inicial de char para tipo de dado); parsers de configuração onde primeiro char define modo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.4",
                            "name": "Saída de caractere",
                            "description": "Exibir o valor de uma variável caractere na tela com comandos de saída como printf('%c') ou print(), formatando corretamente para visualização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender declaração e inicialização de variável caractere",
                                  "subSteps": [
                                    "Declare uma variável do tipo char em C, usando a sintaxe 'char variavel = 'X';' onde X é um caractere entre aspas simples.",
                                    "Inicialize a variável com diferentes caracteres alfanuméricos, como 'A', '5' ou '$'.",
                                    "Verifique o valor armazenado usando um depurador ou printf temporário para char como inteiro (ASCII).",
                                    "Experimente inicializar com escape sequences como '\\n' ou '\\t'.",
                                    "Confirme que char ocupa 1 byte de memória."
                                  ],
                                  "verification": "Compile e execute um código simples que declara e inicializa char, confirmando que o valor é armazenado corretamente via depuração.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Dev-C++)",
                                    "Compilador GCC",
                                    "Documentação C sobre tipos char"
                                  ],
                                  "tips": "Sempre use aspas simples para caracteres únicos; aspas duplas são para strings.",
                                  "learningObjective": "Compreender como declarar e inicializar corretamente uma variável char para prepará-la para saída.",
                                  "commonMistakes": [
                                    "Usar aspas duplas em vez de simples",
                                    "Inicializar com múltiplos caracteres",
                                    "Confundir char com string"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender sintaxe de comandos de saída para caractere",
                                  "subSteps": [
                                    "Estude a função printf() com especificador '%c' para saída de char único.",
                                    "Analise exemplos: printf('%c', variavel); e printf('%c\\n', variavel); para quebra de linha.",
                                    "Compare com putchar(variavel); como alternativa para saída de char.",
                                    "Teste em um esboço de código sem main completa para validar sintaxe.",
                                    "Revise manuais para entender que %c ignora strings e trata como caractere único."
                                  ],
                                  "verification": "Escreva trechos isolados de printf('%c') e confirme sintaxe sem erros de compilação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência C (cppreference.com)",
                                    "Terminal com GCC",
                                    "Exemplos de código prontos"
                                  ],
                                  "tips": "Use \\n após %c para formatação limpa; evite misturar com %s.",
                                  "learningObjective": "Dominar a sintaxe exata de printf('%c') e putchar() para exibição de char.",
                                  "commonMistakes": [
                                    "Usar %s para char",
                                    "Esquecer vírgula após %c",
                                    "Não incluir <stdio.h>"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever e integrar código completo para saída de caractere",
                                  "subSteps": [
                                    "Estruture um programa com #include <stdio.h>, int main(), declaração char, e printf('%c\\n', variavel);",
                                    "Adicione múltiplas saídas: declare vários chars e imprima em sequência.",
                                    "Inclua formatação como printf('O caractere é: %c\\n', c); para contexto.",
                                    "Teste com input: use scanf('%c', &c); seguido de printf para eco.",
                                    "Formate saída para alinhamento ou maiúsculas/minúsculas."
                                  ],
                                  "verification": "Compile o programa completo e execute, garantindo que o char apareça formatado na tela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "Editor com highlight de sintaxe",
                                    "Amostras de código C"
                                  ],
                                  "tips": "Sempre termine printf com \\n para flush de buffer; use & em scanf para char.",
                                  "learningObjective": "Construir um programa funcional que exibe variável char com formatação correta.",
                                  "commonMistakes": [
                                    "Faltar return 0;",
                                    "Não usar & em scanf('%c')",
                                    "Buffer overflow em input"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, depurar e otimizar a saída de caractere",
                                  "subSteps": [
                                    "Compile com gcc -o programa programa.c e execute ./programa.",
                                    "Use gdb ou printf debug para inspecionar valores de char durante execução.",
                                    "Teste edge cases: char nulo '\\0', caracteres especiais como '\\''.",
                                    "Otimize formatação para múltiplos chars em loop ou array.",
                                    "Valide saída em diferentes terminais/encodigos (UTF-8 vs ASCII)."
                                  ],
                                  "verification": "Programa roda sem warnings, saída matches input esperado em todos testes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "Terminal Linux/Windows",
                                    "Valgrind para memory check"
                                  ],
                                  "tips": "Para chars especiais, escape corretamente; teste em console puro.",
                                  "learningObjective": "Garantir robustez na saída de char através de execução e depuração.",
                                  "commonMistakes": [
                                    "Ignorar warnings de compilação",
                                    "Não testar chars não-ASCII",
                                    "Loop infinito sem break"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva um programa em C que declare char inicial = 'A'; e imprima: \"A primeira letra do alfabeto é: A\". Use printf(\"A primeira letra do alfabeto é: %c\\n\", inicial);. Compile e execute para ver a saída formatada corretamente na tela.",
                              "finalVerifications": [
                                "Programa compila sem erros ou warnings usando GCC.",
                                "Saída exibe exatamente o caractere esperado sem lixo ou espaçamento extra.",
                                "Testes com 5 chars diferentes (letra, dígito, símbolo) funcionam.",
                                "Uso de scanf e printf ecoa input corretamente.",
                                "Execução em loop imprime array de chars sem falhas.",
                                "Depurador mostra valor ASCII correto da variável."
                              ],
                              "assessmentCriteria": [
                                "Correto uso de '%c' em printf sem substituição por %s ou outros.",
                                "Formatação inclui contexto textual e quebra de linha apropriada.",
                                "Inclusão obrigatória de headers e main structure válida.",
                                "Tratamento correto de input/output com & para variáveis.",
                                "Ausência de vazamentos de memória ou warnings em ferramentas como Valgrind.",
                                "Capacidade de lidar com escape sequences em char."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação ASCII/Unicode de caracteres como valores numéricos.",
                                "Linguagens: Comparação de sintaxe print() em Python vs printf em C.",
                                "Design de Software: Formatação de UI console para user experience.",
                                "Segurança: Prevenção de buffer overflow em scanf('%c')."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, saída de caracteres é essencial para logs de debug (ex: imprimir status 'OK'), interfaces de console em jogos CLI, validação de input em formulários web backend, e geração de relatórios textuais em sistemas embarcados como ATMs."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Tipo Lógico",
                        "description": "Representação de valores booleanos verdadeiro (true) ou falso (false) com o tipo lógico (bool), utilizado em estruturas condicionais e expressões lógicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Declarar variável lógica",
                            "description": "Criar uma variável do tipo booleano (bool) para armazenar valores verdadeiro ou falso, usando sintaxe como bool b; em C++ ou b = True em Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variável lógica (booleana)",
                                  "subSteps": [
                                    "Estude a definição: uma variável booleana armazena apenas valores verdadeiro (true) ou falso (false).",
                                    "Compare com outros tipos: diferente de inteiros ou strings, representa estados lógicos binários.",
                                    "Identifique usos comuns: condições, flags de controle e decisões em programas.",
                                    "Revise exemplos reais: sim/não, ligado/desligado, aprovado/reprovado.",
                                    "Anote em um caderno: escreva 3 cenários do dia a dia que usam lógica verdadeiro/falso."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é uma variável booleana e dê 2 exemplos de uso.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação oficial de C++ ou Python sobre tipos de dados",
                                    "Caderno e caneta"
                                  ],
                                  "tips": "Pense sempre em perguntas de 'sim ou não' para associar ao booleano.",
                                  "learningObjective": "Entender o propósito e representação de valores lógicos em programação.",
                                  "commonMistakes": [
                                    "Confundir booleano com inteiro (usar 1/0 em vez de true/false)",
                                    "Ignorar que booleans são binários, não textuais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar variável booleana em C++",
                                  "subSteps": [
                                    "Abra um editor de código como Code::Blocks ou VS Code com extensão C++.",
                                    "Inclua a biblioteca necessária: #include <iostream> e using namespace std;.",
                                    "Declare a variável: escreva 'bool nomeVariavel;' (ex: bool ativo;).",
                                    "Compile o código simples: int main() { bool ativo; return 0; }.",
                                    "Teste inicialização opcional: bool ligado = true;"
                                  ],
                                  "verification": "Compilar o código sem erros de sintaxe e visualizar a declaração no debugger.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código C++ (ex: Code::Blocks)",
                                    "Compilador g++ instalado"
                                  ],
                                  "tips": "Sempre termine declarações com ponto e vírgula (;). Use nomes descritivos como 'isValid'.",
                                  "learningObjective": "Dominar a sintaxe exata de declaração de bool em C++.",
                                  "commonMistakes": [
                                    "Esquecer o ponto e vírgula",
                                    "Usar 'boolean' em vez de 'bool'",
                                    "Não incluir <iostream> para saída futura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar variável booleana em Python",
                                  "subSteps": [
                                    "Abra um editor como IDLE ou VS Code com extensão Python.",
                                    "Declare diretamente: nomeVariavel = True ou nomeVariavel = False (ex: ativo = True).",
                                    "Não precisa de tipo explícito: Python é dinâmico, mas confirme com type(ativo) == bool.",
                                    "Execute no interpretador: print(ativo) deve mostrar True ou False.",
                                    "Teste atribuição: ligado = False; print(type(ligado))."
                                  ],
                                  "verification": "Executar o script e confirmar que print(type(variavel)) retorna <class 'bool'>.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Python instalado (versão 3.x)",
                                    "Editor IDLE ou Jupyter Notebook"
                                  ],
                                  "tips": "Python usa True/False com maiúscula inicial. Evite aspas para valores literais.",
                                  "learningObjective": "Aplicar declaração dinâmica de bool em Python.",
                                  "commonMistakes": [
                                    "Usar 'true' minúsculo",
                                    "Declarar como string: ativo = 'True'",
                                    "Esquecer type() para verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar declaração e verificação básica",
                                  "subSteps": [
                                    "Crie um programa híbrido: declare bool em C++ e Python para uma flag 'isLogged'.",
                                    "Inicialize e altere: em C++ bool isLogged = false; isLogged = true;.",
                                    "Em Python: isLogged = True; isLogged = not isLogged.",
                                    "Saída de teste: use cout << boolalpha << isLogged; em C++ ou print(isLogged) em Python.",
                                    "Compare os dois códigos lado a lado em arquivos separados."
                                  ],
                                  "verification": "Rodar ambos os programas e confirmar saídas corretas de true/false.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dois arquivos: main.cpp e script.py",
                                    "Terminais para compilação/execução"
                                  ],
                                  "tips": "Use 'boolalpha' em C++ para imprimir 'true' em vez de '1'. Teste sempre com valores opostos.",
                                  "learningObjective": "Consolidar declaração comparando linguagens e testando atribuições.",
                                  "commonMistakes": [
                                    "Não inicializar variáveis (undefined em C++)",
                                    "Erro de case em Python",
                                    "Confundir sintaxes entre linguagens"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de login: bool isAuthenticated = false; if (username == 'admin' && password == '123') { isAuthenticated = true; } cout << (isAuthenticated ? 'Acesso liberado' : 'Negado'); // Saída: Acesso liberado ou Negado.",
                              "finalVerifications": [
                                "Código em C++ compila sem warnings de declaração.",
                                "Script Python executa e type() confirma bool.",
                                "Variáveis inicializadas corretamente exibem true/false.",
                                "Alteração de valor (true para false) funciona em ambos.",
                                "Nenhum erro de sintaxe ou runtime relacionado à declaração.",
                                "Uso em condição if altera fluxo corretamente."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa: 'bool' em C++, True/False em Python.",
                                "Inicialização opcional demonstrada.",
                                "Nomes de variáveis descritivos e camelCase/snake_case adequados.",
                                "Testes de verificação incluídos no código.",
                                "Comparação entre linguagens evidenciada.",
                                "Ausência de erros comuns como strings em vez de bool."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional (AND, OR, NOT).",
                                "Física: Estados binários em circuitos digitais (0/1).",
                                "Lógica Filosófica: Verdadeiro/Falso em argumentos.",
                                "Engenharia Elétrica: Sinais lógicos em hardware."
                              ],
                              "realWorldApplication": "Flags de autenticação em apps (login bem-sucedido), validação de formulários web (isValid), controle de estados em jogos (isGameOver) e sistemas embarcados (sensorAtivo)."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Atribuir valores booleanos",
                            "description": "Atribuir diretamente valores lógicos (true/false ou 1/0) a uma variável bool, compreendendo sua representação interna como escalar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de tipo booleano",
                                  "subSteps": [
                                    "Estude a definição de tipo booleano como um escalar que armazena valores lógicos true (verdadeiro) ou false (falso).",
                                    "Leia sobre sua representação interna: geralmente 1 byte na memória, onde true é 1 e false é 0.",
                                    "Compare com inteiros: true/false podem ser usados como 1/0 em contextos numéricos.",
                                    "Anote exemplos de uso em lógica: condições verdadeiras ou falsas.",
                                    "Responda: Qual a diferença entre bool e int?"
                                  ],
                                  "verification": "Resuma em 3 frases o que aprendeu e compartilhe com um colega ou anote no caderno.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação de linguagem (ex: C stdbool.h ou Python bool)",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Lembre-se: bool é específico para lógica, evite confundir com outros tipos.",
                                  "learningObjective": "Entender o propósito e representação interna do tipo booleano.",
                                  "commonMistakes": [
                                    "Confundir true/false com strings 'true'/'false'",
                                    "Ignorar que bool ocupa 1 byte tipicamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma variável booleana",
                                  "subSteps": [
                                    "Abra um editor de código e inclua a biblioteca necessária (ex: #include <stdbool.h> em C).",
                                    "Declare uma variável do tipo bool: bool minhaVariavel;.",
                                    "Compile o código vazio para verificar sintaxe.",
                                    "Adicione um comentário explicando a declaração.",
                                    "Teste declaração múltipla: bool flag1, flag2;"
                                  ],
                                  "verification": "Código declara variável bool sem erros de compilação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Code::Blocks)",
                                    "Compilador (GCC para C)"
                                  ],
                                  "tips": "Sempre inclua headers necessários para bool em C.",
                                  "learningObjective": "Dominar a sintaxe de declaração de variáveis booleanas.",
                                  "commonMistakes": [
                                    "Esquecer #include <stdbool.h> em C",
                                    "Usar Bool maiúsculo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atribuir valores booleanos diretamente",
                                  "subSteps": [
                                    "Atribua true a uma variável: bool ativa = true;.",
                                    "Imprima o valor (ex: printf(\"%d\", ativa); // 1).",
                                    "Atribua false: bool inativa = false; e imprima (// 0).",
                                    "Altere o valor: ativa = false; e verifique mudança.",
                                    "Teste atribuição com 1/0: bool teste = 1; // true"
                                  ],
                                  "verification": "Execute e confirme saídas: 1 para true, 0 para false.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Terminal para compilação e execução"
                                  ],
                                  "tips": "Use %d para imprimir bool como inteiro para ver representação.",
                                  "learningObjective": "Executar atribuições diretas de true/false/1/0 a bool.",
                                  "commonMistakes": [
                                    "Usar aspas: true como 'true'",
                                    "Atribuir sem declarar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e testar atribuições booleanas",
                                  "subSteps": [
                                    "Crie um programa com múltiplas variáveis bool e atribuições.",
                                    "Use if para testar: if (ativa) printf(\"Ativa!\");.",
                                    "Inspecione memória com debugger (ex: gdb) para ver 1/0.",
                                    "Escreva um teste unitário simples para atribuições.",
                                    "Documente o que observou sobre representação interna."
                                  ],
                                  "verification": "Programa executa corretamente e debugger mostra valores escalares 0/1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Debugger (GDB)",
                                    "Editor com suporte a debug"
                                  ],
                                  "tips": "Pratique com printf para depuração rápida.",
                                  "learningObjective": "Validar atribuições e compreender uso prático.",
                                  "commonMistakes": [
                                    "Não testar ambas true/false",
                                    "Ignorar promoção para int em prints"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C: #include <stdio.h> #include <stdbool.h> int main() { bool loginSucesso = true; bool admin = false; printf(\"Login: %d, Admin: %d\\n\", loginSucesso, admin); // Saída: Login: 1, Admin: 0 loginSucesso = false; printf(\"Após logout: %d\\n\", loginSucesso); // 0 return 0; }",
                              "finalVerifications": [
                                "Declara variável bool sem erros.",
                                "Atribui true e obtém representação 1.",
                                "Atribui false e obtém representação 0.",
                                "Altera valor corretamente em execução.",
                                "Explica representação interna como escalar.",
                                "Usa bool em condicional simples."
                              ],
                              "assessmentCriteria": [
                                "Código compila e executa sem warnings.",
                                "Saídas numéricas corretas (1/0).",
                                "Explicação verbal da representação interna.",
                                "Identifica e corrige erros comuns.",
                                "Aplica em exemplo prático independente.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional (verdadeiro/falso em proposições).",
                                "Física: Estados binários em circuitos lógicos (on/off).",
                                "Filosofia: Conceitos de verdade e falsidade.",
                                "Estatística: Variáveis indicadoras (1/0)."
                              ],
                              "realWorldApplication": "Em software, flags booleanas controlam fluxos como 'usuário logado' em apps web, validações de formulários ('campo válido?') ou estados de dispositivos IoT ('sensor ativo')."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Entrada e saída de valores lógicos",
                            "description": "Ler e exibir valores booleanos usando comandos de entrada/saída adaptados, convertendo quando necessário (ex: ler string e converter para bool).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender valores lógicos e preparar o ambiente",
                                  "subSteps": [
                                    "Estude o conceito de valores booleanos: True (verdadeiro) e False (falso).",
                                    "Revise a sintaxe da linguagem para declarar variáveis booleanas.",
                                    "Configure um editor de código e ambiente de execução (ex: Python IDLE ou online como Replit).",
                                    "Teste imprimir valores booleanos literais: print(True) e print(False).",
                                    "Explore funções de conversão básica como bool() em Python."
                                  ],
                                  "verification": "Execute um código simples que imprima True e False corretamente, sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm ou Replit)",
                                    "Documentação oficial da linguagem (ex: Python docs sobre bool)"
                                  ],
                                  "tips": "Sempre use maiúscula em True/False; evite strings como 'true'.",
                                  "learningObjective": "Identificar e manipular valores booleanos básicos.",
                                  "commonMistakes": [
                                    "Usar minúsculas 'true/false'",
                                    "Confundir booleanos com inteiros 0/1",
                                    "Não importar módulos desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar entrada de valores lógicos com conversão",
                                  "subSteps": [
                                    "Use comando de entrada (ex: input() em Python) para capturar string do usuário.",
                                    "Crie lógica condicional para mapear entradas como 'sim'/'s' para True e 'nao'/'n' para False.",
                                    "Aplique função de conversão: valor_bool = bool(input_string.lower() in ['sim', 's', 'true']).",
                                    "Armazene o valor booleano em uma variável.",
                                    "Teste com entradas variadas: 'SIM', 'Nao', 'yes' (trate exceções)."
                                  ],
                                  "verification": "Digite diferentes entradas e confirme que a variável booleana é setada corretamente via print().",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para testes interativos"
                                  ],
                                  "tips": "Normalize entrada com .lower() e use 'in' para listas de sinônimos.",
                                  "learningObjective": "Converter entradas de texto em valores booleanos de forma robusta.",
                                  "commonMistakes": [
                                    "Não tratar variações de maiúsculas/minúsculas",
                                    "Esquecer de converter string para bool",
                                    "Assumir input direto como bool"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar saída de valores lógicos formatados",
                                  "subSteps": [
                                    "Use print() para exibir o valor booleano diretamente.",
                                    "Adicione formatação: exiba 'Verdadeiro' se True, 'Falso' se False.",
                                    "Inclua mensagens contextuais: 'O resultado é: ' + str(valor_bool).",
                                    "Teste saídas com valores de entrada anterior.",
                                    "Experimente formatação avançada como f-strings em Python."
                                  ],
                                  "verification": "Execute o código e verifique se a saída reflete corretamente o booleano processado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de formatação de strings"
                                  ],
                                  "tips": "Use str(valor_bool) para conversão segura em concatenação.",
                                  "learningObjective": "Exibir booleanos de forma legível e contextualizada.",
                                  "commonMistakes": [
                                    "Imprimir booleano sem formatação (aparece como 'True')",
                                    "Erros de tipo em concatenação string-bool",
                                    "Não testar ambos True/False"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar entrada e saída em um programa completo e depurar",
                                  "subSteps": [
                                    "Combine passos anteriores em um programa: pergunte, converta, exiba.",
                                    "Adicione loop para múltiplas entradas até 'sair'.",
                                    "Inclua tratamento de erros (ex: try/except para entradas inválidas).",
                                    "Execute testes unitários: valide 5 entradas diferentes.",
                                    "Depure erros comuns e otimize o código."
                                  ],
                                  "verification": "Programa roda sem crashes, converte corretamente e exibe para 10 testes variados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor com debugger",
                                    "Lista de casos de teste"
                                  ],
                                  "tips": "Sempre valide input com mensagens de erro claras.",
                                  "learningObjective": "Criar um programa funcional de I/O booleano com robustez.",
                                  "commonMistakes": [
                                    "Loop infinito sem condição de saída",
                                    "Não tratar inputs inválidos",
                                    "Ignorar edge cases como strings vazias"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa em Python que pergunte: 'Você aprova esta política? (sim/nao)': Converta a resposta para booleano e exiba: 'Aprovação: Verdadeiro' ou 'Aprovação: Falso'. Teste com 'SIM', 'N', 'talvez' (trate como False).",
                              "finalVerifications": [
                                "Consegue converter 'sim'/'SIM' para True corretamente?",
                                "Entrada inválida é tratada sem crashar o programa?",
                                "Saída booleana é exibida de forma legível?",
                                "Programa lida com múltiplas entradas em loop?",
                                "Diferença entre bool('1') e bool('false') é compreendida?",
                                "Código é limpo, com comentários e indentação correta?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na conversão de strings para booleanos (90% acerto em testes).",
                                "Robustez: tratamento de erros e entradas variadas.",
                                "Clareza na saída: mensagens informativas e formatadas.",
                                "Eficiência: código conciso sem redundâncias.",
                                "Documentação: comentários explicando lógica de conversão.",
                                "Testes: evidência de execução com casos positivos/negativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e tabelas-verdade.",
                                "Física: Representação binária em circuitos lógicos (0/1 como False/True).",
                                "Língua Portuguesa: Processamento de linguagem natural para validação.",
                                "Ética: Validações booleanas em sistemas de privacidade (aceitar/negado)."
                              ],
                              "realWorldApplication": "Em formulários web (ex: checkboxes 'Aceito termos?'), validações de login (autenticado: True/False), automação de testes (assertTrue em frameworks como pytest) e jogos (vivo/morto para personagens)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.4",
                            "name": "Usar booleano em condicional simples",
                            "description": "Aplicar variável bool em estrutura if simples para controle de fluxo, demonstrando manipulação básica de valores verdadeiro/falso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de valores booleanos",
                                  "subSteps": [
                                    "Estude o que são valores booleanos: True (verdadeiro) e False (falso).",
                                    "Identifique exemplos cotidianos, como 'a luz está acesa?' (True/False).",
                                    "Aprenda operadores de comparação que geram booleanos: ==, !=, >, <, >=, <=.",
                                    "Explore operadores lógicos básicos: and, or, not."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre True e False, com um exemplo de operador de comparação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação da linguagem de programação (ex: Python docs)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Pense em booleanos como interruptores: ligados (True) ou desligados (False).",
                                  "learningObjective": "Identificar e exemplificar valores booleanos e como eles são gerados.",
                                  "commonMistakes": [
                                    "Confundir booleanos com strings como 'true'",
                                    "Ignorar maiúsculas/minúsculas em True/False",
                                    "Achar que 1 e 0 são booleanos por padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e atribuir variáveis booleanas",
                                  "subSteps": [
                                    "Crie uma variável booleana e atribua True ou False diretamente.",
                                    "Gere um booleano usando uma comparação, como idade >= 18.",
                                    "Exiba o valor da variável usando print() ou equivalente.",
                                    "Teste alterando o valor e observando a saída.",
                                    "Use um operador lógico simples, como not idade_maior."
                                  ],
                                  "verification": "Execute código que declara e imprime pelo menos duas variáveis booleanas diferentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente de programação (ex: IDLE, VS Code com Python)",
                                    "Console interativo (REPL)"
                                  ],
                                  "tips": "Sempre use print() para inspecionar valores booleanos durante o desenvolvimento.",
                                  "learningObjective": "Manipular variáveis do tipo booleano de forma básica.",
                                  "commonMistakes": [
                                    "Esquecer de atribuir o resultado da comparação à variável",
                                    "Usar = em vez de == para comparação",
                                    "Não considerar o tipo da variável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar estrutura condicional if simples com booleano",
                                  "subSteps": [
                                    "Escreva a sintaxe básica: if condicao_booleana: ...",
                                    "Adicione um bloco de código indentado dentro do if (ex: print('Aprovado')).",
                                    "Teste com valor True e False alterando a variável.",
                                    "Adicione um else opcional para o caso False.",
                                    "Integre uma entrada do usuário para gerar o booleano dinamicamente."
                                  ],
                                  "verification": "O programa executa o bloco correto baseado no valor booleano, sem erros de sintaxe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código com execução (ex: Replit, PyCharm Community)",
                                    "Exemplos de código comentados"
                                  ],
                                  "tips": "Lembre-se da indentação: 4 espaços ou tab no Python para o bloco if.",
                                  "learningObjective": "Controlar o fluxo de execução com if baseado em booleano.",
                                  "commonMistakes": [
                                    "Falta de dois pontos (:) após o if",
                                    "Indentação incorreta",
                                    "Usar else sem if correspondente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e refatorar o código",
                                  "subSteps": [
                                    "Execute o programa com múltiplos cenários de entrada.",
                                    "Identifique e corrija erros comuns usando mensagens de erro.",
                                    "Adicione comentários explicando o uso do booleano.",
                                    "Refatore para maior clareza, como nomear variáveis descritivas.",
                                    "Compartilhe o código para revisão ou autoavaliação."
                                  ],
                                  "verification": "Código roda sem erros em pelo menos 3 testes (True e False).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de depuração (ex: print statements, debugger básico)",
                                    "Checklist de testes"
                                  ],
                                  "tips": "Use variáveis com nomes como 'is_adult' para clareza semântica.",
                                  "learningObjective": "Garantir robustez no uso de booleanos em condicionais.",
                                  "commonMistakes": [
                                    "Não testar o caso False",
                                    "Ignorar erros de runtime",
                                    "Código sem comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um programa em Python que verifica se um aluno foi aprovado: nota = 7.5; aprovado = nota >= 7; if aprovado: print('Aprovado!'); else: print('Reprovado. Estude mais.'). Teste alterando a nota para 6.0.",
                              "finalVerifications": [
                                "Variável booleana é corretamente declarada e usada no if.",
                                "Bloco if executa apenas quando booleano é True.",
                                "Programa lida com ambos os valores (True/False) sem crashes.",
                                "Saída é correta e legível para diferentes entradas.",
                                "Código está indentado e sintaticamente válido.",
                                "Comentários explicam o fluxo condicional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração e uso do booleano (100%).",
                                "Correta implementação da estrutura if (90-100%).",
                                "Testes abrangentes de cenários (80-90%).",
                                "Clareza do código e nomes de variáveis (70-80%).",
                                "Ausência de erros comuns listados (60-70%).",
                                "Integração com entrada do usuário (bônus)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e tabelas-verdade.",
                                "Filosofia: Tomada de decisões binárias e dilemas éticos.",
                                "Ciências da Computação: Fundamentos de algoritmos condicionais.",
                                "Língua Portuguesa: Nomenclatura clara em variáveis.",
                                "Educação Física: Condições para 'jogar' ou 'descansar' em regras de jogos."
                              ],
                              "realWorldApplication": "Validação de login (usuário autenticado? True -> acessar dashboard), verificação de idade em apps, alertas de segurança em sistemas IoT (sensor detectado? -> ativar alarme)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Tipos Estruturados: Arrays",
                    "description": "Coleções indexadas de elementos do mesmo tipo escalar.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Declaração de Arrays",
                        "description": "Processo de definir um array, especificando seu tipo, nome e tamanho, garantindo que todos os elementos sejam do mesmo tipo escalar.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Declarar array unidimensional",
                            "description": "Criar uma declaração de array unidimensional em uma linguagem procedimental como C++, especificando tipo escalar (ex: int, float), nome e tamanho fixo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe de declaração de array unidimensional em C++",
                                  "subSteps": [
                                    "Leia a documentação oficial de arrays em C++ (ex: cppreference.com).",
                                    "Identifique os componentes essenciais: tipo escalar, nome do array e tamanho fixo entre colchetes [].",
                                    "Analise exemplos como 'int numeros[10];' e 'float valores[5];'.",
                                    "Note que o tamanho deve ser uma expressão constante em tempo de compilação.",
                                    "Diferencie declaração de inicialização (ex: int arr[3] = {1,2,3};)."
                                  ],
                                  "verification": "Explique por escrito ou verbalmente a sintaxe completa com um exemplo próprio.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação C++ (cppreference.com ou livro de referência)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Sempre use colchetes [] imediatamente após o nome, não após o tipo.",
                                  "learningObjective": "Dominar a estrutura sintática exata da declaração de array unidimensional.",
                                  "commonMistakes": [
                                    "Colocar o tamanho após o nome sem colchetes",
                                    "Usar variáveis não-constantes para o tamanho",
                                    "Confundir com sintaxe de ponteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar tipo escalar, nome e tamanho fixo",
                                  "subSteps": [
                                    "Escolha o tipo escalar adequado: int para inteiros, float/double para reais, char para caracteres.",
                                    "Defina um nome descritivo e válido (letras, números, underline, sem espaços).",
                                    "Determine o tamanho fixo baseado no contexto (ex: 100 para notas de alunos).",
                                    "Valide que o tamanho seja uma constante positiva (ex: 10, ou constexpr).",
                                    "Considere limites de memória para tamanhos grandes."
                                  ],
                                  "verification": "Crie uma tabela com 3 cenários, tipos, nomes e tamanhos justificados.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Papel e caneta ou planilha digital",
                                    "Exemplos de problemas reais"
                                  ],
                                  "tips": "Use nomes como 'notasAlunos[50]' para clareza semântica.",
                                  "learningObjective": "Aplicar critérios para escolher componentes da declaração corretamente.",
                                  "commonMistakes": [
                                    "Escolher tipo inadequado (ex: float para contagens inteiras)",
                                    "Tamanho zero ou negativo",
                                    "Nomes com palavras reservadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever e compilar a declaração no código",
                                  "subSteps": [
                                    "Abra uma IDE como Code::Blocks ou VS Code com g++.",
                                    "Crie um programa simples com #include <iostream> e int main().",
                                    "Insira a declaração no escopo apropriado (ex: dentro de main).",
                                    "Compile o código com g++ arquivo.cpp -o executavel.",
                                    "Corrija erros de sintaxe se houver."
                                  ],
                                  "verification": "Compilação bem-sucedida sem warnings ou erros relacionados à declaração.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "IDE com compilador C++ (g++, Code::Blocks)",
                                    "Terminal para comandos de compilação"
                                  ],
                                  "tips": "Teste com tamanho pequeno primeiro para depuração rápida.",
                                  "learningObjective": "Produzir código compilável com declaração de array correta.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula no final",
                                    "Declarar dentro de estruturas não permitidas",
                                    "Tamanhos não constantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar funcionalidade básica da declaração",
                                  "subSteps": [
                                    "Acesse o primeiro e último elemento (ex: arr[0] = 10; arr[9] = 20;).",
                                    "Use sizeof(arr) / sizeof(arr[0]) para confirmar o tamanho.",
                                    "Imprima um elemento via cout para validar atribuição.",
                                    "Execute o programa e observe saídas.",
                                    "Adicione comentário explicando a declaração."
                                  ],
                                  "verification": "Programa executa corretamente e exibe valores atribuídos ao array.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "IDE com depurador",
                                    "Compilador g++"
                                  ],
                                  "tips": "Use loop for para inicializar e imprimir todo o array.",
                                  "learningObjective": "Confirmar que o array declarado funciona em runtime.",
                                  "commonMistakes": [
                                    "Acessar índices fora do range (ex: arr[10] em arr[10])",
                                    "Não inicializar antes de usar (lixo)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar e documentar a declaração",
                                  "subSteps": [
                                    "Adicione inicialização parcial se aplicável.",
                                    "Inclua comentários no código explicando escolhas.",
                                    "Teste com diferentes tipos (int, float).",
                                    "Salve o código como exemplo reutilizável.",
                                    "Compartilhe ou autoavalie contra critérios."
                                  ],
                                  "verification": "Código documentado compila e roda com múltiplos testes.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Checklist de verificação"
                                  ],
                                  "tips": "Use constexpr para tamanhos simbólicos (ex: constexpr int N = 10; int arr[N];).",
                                  "learningObjective": "Consolidar o conhecimento com documentação e variações.",
                                  "commonMistakes": [
                                    "Ignorar inicialização levando a valores indefinidos",
                                    "Falta de comentários"
                                  ]
                                }
                              ],
                              "practicalExample": "Para armazenar as 7 notas de um aluno em um array de floats: float notas[7]; Em um programa: #include <iostream> int main() { float notas[7]; notas[0] = 8.5; std::cout << notas[0]; return 0; } Compile e execute para ver 8.5.",
                              "finalVerifications": [
                                "Compilação sem erros de sintaxe na declaração.",
                                "sizeof(array) retorna tamanho correto em bytes.",
                                "Acesso a elementos arr[0] até arr[tamanho-1] sem erros.",
                                "Atribuições persistem durante a execução do programa.",
                                "Uso de sizeof(arr)/sizeof(arr[0]) == tamanho declarado."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe exata: tipo nome[tamanho]; com ponto e vírgula.",
                                "Tipo é escalar válido (int, float, char, etc.).",
                                "Tamanho é constante positiva em tempo de compilação.",
                                "Nome segue regras de identificadores C++.",
                                "Declaração em escopo correto (global ou local).",
                                "Compilação e execução sem crashes por declaração.",
                                "Documentação mínima presente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de sequências e vetores unidimensionais.",
                                "Física: Armazenamento de séries temporais de medidas (ex: velocidades).",
                                "Estatística: Conjuntos de dados para cálculos univariados.",
                                "Química: Listas de concentrações em experimentos."
                              ],
                              "realWorldApplication": "Em software de monitoramento IoT, declarar arrays para buffers de leituras de sensores (ex: int temperaturas[1440]; para minutos do dia); em jogos, arrays para posições de partículas; em bancos de dados simples, colunas de registros numéricos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Declarar array multidimensional",
                            "description": "Definir arrays bidimensionais ou multidimensionais, como matrizes, indicando dimensões e tipo escalar homogêneo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Arrays Multidimensionais",
                                  "subSteps": [
                                    "Defina array unidimensional como uma lista linear de elementos homogêneos.",
                                    "Explique array bidimensional como uma matriz (linhas e colunas).",
                                    "Estenda para multidimensionais (ex: 3D como cubos de dados).",
                                    "Identifique que todos os elementos devem ser do mesmo tipo escalar (int, float, char).",
                                    "Discuta dimensões: [linhas][colunas] para 2D."
                                  ],
                                  "verification": "Resuma em suas palavras o que é um array 2D e dê um exemplo verbal de uso.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Documentação de linguagem de programação (ex: C ou Java), quadro branco ou papel.",
                                  "tips": "Visualize como uma tabela Excel para facilitar a compreensão.",
                                  "learningObjective": "Entender arrays multidimensionais como estruturas de dados tabulares homogêneas.",
                                  "commonMistakes": "Confundir com arrays heterogêneos ou estruturas não homogêneas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Sintaxe de Declaração Básica",
                                  "subSteps": [
                                    "Escreva a sintaxe geral: tipo nome[dimensao1][dimensao2]...;",
                                    "Exemplo em C: int matriz[3][4]; // 3 linhas, 4 colunas.",
                                    "Declare um array 2D de floats: float temperaturas[5][7];",
                                    "Declare um 3D: char cubo[2][3][4];",
                                    "Compile um código simples com declaração apenas."
                                  ],
                                  "verification": "Compilar um programa que declara um array 2D sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code, Dev-C++), compilador (GCC).",
                                  "tips": "Sempre especifique dimensões constantes conhecidas em tempo de compilação.",
                                  "learningObjective": "Dominar a sintaxe para declarar arrays multidimensionais com dimensões fixas.",
                                  "commonMistakes": "Esquecer colchetes para cada dimensão ou usar variáveis não-constantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar com Inicialização Explícita",
                                  "subSteps": [
                                    "Inicialize na declaração: int matriz[2][3] = {{1,2,3},{4,5,6}};",
                                    "Preencha parcialmente: int arr[2][3] = {{1}, {4}}; // resto zero.",
                                    "Use loops para inicializar dinamicamente em código.",
                                    "Teste com printf para exibir valores.",
                                    "Corrija erros de inicialização excessiva ou insuficiente."
                                  ],
                                  "verification": "Criar e compilar código que declara e imprime um array 2D inicializado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, compilador, terminal para execução.",
                                  "tips": "Conte os elementos na inicialização para matching exato com dimensões.",
                                  "learningObjective": "Aplicar inicialização estática e dinâmica em arrays multidimensionais.",
                                  "commonMistakes": "Número incorreto de chaves ou vírgulas na lista de inicialização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Testar a Declaração",
                                  "subSteps": [
                                    "Acesse elementos: matriz[0][1] = 10;",
                                    "Escreva função para imprimir toda a matriz usando loops duplos.",
                                    "Teste limites: evite acesso fora de bounds (ex: matriz[3][0]).",
                                    "Compile e execute com diferentes tamanhos.",
                                    "Documente o código com comentários sobre dimensões."
                                  ],
                                  "verification": "Executar programa que declara, inicializa e acessa corretamente sem erros de runtime.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código, compilador, debugger opcional.",
                                  "tips": "Use índices começando em 0 e sempre loops for com limites corretos.",
                                  "learningObjective": "Validar declarações através de acesso e impressão segura.",
                                  "commonMistakes": "Acessar índices inválidos causando segmentation fault."
                                }
                              ],
                              "practicalExample": "Declare uma matriz 3x3 de inteiros representando um tabuleiro de jogo da velha: int tabuleiro[3][3] = {{' ', ' ', ' '}, {' ', 'X', ' '}, {'O', ' ', ' '}}; Imprima usando loops para visualizar.",
                              "finalVerifications": [
                                "Compilar sem erros um programa com array 2D e 3D declarados.",
                                "Inicializar e imprimir corretamente todos os elementos.",
                                "Acessar e modificar elementos específicos sem crashes.",
                                "Explicar dimensões e tipo homogêneo verbalmente.",
                                "Identificar e corrigir erros comuns em código fornecido.",
                                "Criar declaração personalizada para um cenário dado."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática na declaração (100% match com normas da linguagem).",
                                "Uso apropriado de dimensões e tipo escalar homogêneo.",
                                "Inicialização válida sem sobras ou faltas.",
                                "Ausência de erros de compilação ou runtime em testes.",
                                "Clareza em comentários e estrutura do código.",
                                "Capacidade de generalizar para mais dimensões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de matrizes para álgebra linear.",
                                "Física: Tabelas de dados experimentais (ex: posições em grades).",
                                "Estatística: Matrizes de dados para análise tabular."
                              ],
                              "realWorldApplication": "Em jogos (tabuleiros como xadrez), processamento de imagens (pixels em grades 2D), simulações científicas (grids 3D de temperaturas) e planilhas de dados em software empresarial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Especificar tamanho dinâmico",
                            "description": "Utilizar constantes ou variáveis para definir o tamanho do array na declaração, respeitando limitações da linguagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de tamanho dinâmico em arrays",
                                  "subSteps": [
                                    "Estude a diferença entre tamanho estático (fixo em tempo de compilação, ex: new int[10]) e dinâmico (definido por variável em tempo de execução).",
                                    "Analise exemplos de código onde o tamanho é literal vs. variável.",
                                    "Identifique cenários onde tamanho dinâmico é necessário, como entrada de usuário.",
                                    "Revise sintaxe básica de declaração de arrays na linguagem escolhida (ex: Java)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre estático e dinâmico, com exemplos.",
                                  "estimatedTime": "15 minutes",
                                  "materials": "Documentação da linguagem (ex: Oracle Java Docs), editor de texto simples.",
                                  "tips": "Use diagramas para visualizar memória alocada dinamicamente.",
                                  "learningObjective": "Diferenciar tamanhos de array estáticos e dinâmicos e justificar uso do dinâmico.",
                                  "commonMistakes": "Confundir com estruturas totalmente dinâmicas como ArrayList; assumir que arrays são sempre redimensionáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma variável para o tamanho do array",
                                  "subSteps": [
                                    "Escolha um tipo inteiro apropriado (ex: int size = 5;).",
                                    "Inicialize a variável com um valor em tempo de execução (ex: via Scanner para input).",
                                    "Valide o valor da variável (ex: size > 0 para evitar erros).",
                                    "Teste a declaração isoladamente imprimindo o valor da variável."
                                  ],
                                  "verification": "Execute código que imprime o valor da variável e confirme que é usado corretamente.",
                                  "estimatedTime": "10 minutes",
                                  "materials": "IDE com suporte a Java (IntelliJ, Eclipse), terminal para execução.",
                                  "tips": "Use nomes descritivos como 'numAlunos' em vez de 'n'.",
                                  "learningObjective": "Criar e inicializar variáveis que representem tamanhos de arrays dinamicamente.",
                                  "commonMistakes": "Esquecer de inicializar a variável, levando a valor zero ou lixo de memória."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar o array utilizando a variável de tamanho",
                                  "subSteps": [
                                    "Escreva a declaração do array com a sintaxe correta (ex: int[] arr = new int[size];).",
                                    "Compile o código para detectar erros de sintaxe.",
                                    "Acesse elementos do array (ex: arr[0] = 10;) e imprima o length para verificar.",
                                    "Experimente mudar o valor da variável e reexecute para observar mudança no tamanho."
                                  ],
                                  "verification": "Imprima arr.length e confirme que corresponde ao valor da variável.",
                                  "estimatedTime": "20 minutes",
                                  "materials": "IDE com depurador, exemplos de código de referência.",
                                  "tips": "Sempre verifique bounds com if (index < size) antes de acessar.",
                                  "learningObjective": "Implementar declaração de array com tamanho determinado por variável.",
                                  "commonMistakes": "Usar tamanho literal em vez da variável; esquecer colchetes ou tipo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o array de tamanho dinâmico",
                                  "subSteps": [
                                    "Preencha o array com dados de teste em loop (ex: for(int i=0; i<size; i++)).",
                                    "Execute cenários com diferentes valores de size (pequeno, grande, input usuário).",
                                    "Trate exceções como ArrayIndexOutOfBoundsException.",
                                    "Documente o código com comentários explicando o dinamismo."
                                  ],
                                  "verification": "Rode testes unitários ou prints que mostram alocação correta para múltiplos sizes.",
                                  "estimatedTime": "15 minutes",
                                  "materials": "Ferramentas de teste (JUnit para Java), console para outputs.",
                                  "tips": "Combine com loops para automação de testes.",
                                  "learningObjective": "Validar funcionalidade de arrays dinâmicos em contextos reais.",
                                  "commonMistakes": "Não tratar input inválido levando a NegativeArraySizeException."
                                }
                              ],
                              "practicalExample": "Em um programa de gerenciamento de notas de alunos: int numAlunos = scanner.nextInt(); String[] nomes = new String[numAlunos]; preencha e imprima a lista, adaptando ao número real de alunos inserido.",
                              "finalVerifications": [
                                "O array compila e executa sem erros para diferentes valores de size.",
                                "arr.length reflete exatamente o valor da variável de tamanho.",
                                "Acesso a elementos dentro dos bounds funciona corretamente.",
                                "Mudanças no valor da variável alteram o tamanho do array em runtime.",
                                "Input de usuário é processado sem crashes (com validações)."
                              ],
                              "assessmentCriteria": [
                                "Código usa variável (não literal) para especificar tamanho do array.",
                                "Variável é inicializada corretamente antes da declaração do array.",
                                "Array é utilizado de forma segura com verificações de bounds.",
                                "Exemplo prático demonstra aplicação real com input dinâmico.",
                                "Código está comentado e legível, sem erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Uso de variáveis e expressões aritméticas para tamanhos.",
                                "Algoritmos: Integração com loops e entrada/saída de dados.",
                                "Lógica de Programação: Condicionais para validação de inputs.",
                                "Banco de Dados: Conceitos de coleções dinâmicas semelhantes a listas."
                              ],
                              "realWorldApplication": "Desenvolvimento de aplicativos como gerenciadores de estoque ou redes sociais, onde o número de itens (produtos, posts) é desconhecido em tempo de compilação e definido por dados do usuário ou banco de dados."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Inicialização de Arrays",
                        "description": "Atribuir valores iniciais aos elementos do array, seja na declaração ou posteriormente, preenchendo com dados do tipo escalar correto.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Inicializar na declaração",
                            "description": "Preencher o array com valores literais durante a declaração, como {1, 2, 3} para um array de inteiros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Inicialização na Declaração",
                                  "subSteps": [
                                    "Leia a definição: inicializar um array fornecendo valores literais diretamente na declaração, sem usar new.",
                                    "Compare com inicialização separada: int[] arr = new int[3]; arr[0]=1; vs int[] arr = {1,2,3};",
                                    "Identifique vantagens: código mais conciso e legível.",
                                    "Analise exemplos simples em documentação da linguagem (ex: Java).",
                                    "Anote diferenças para tipos primitivos e objetos."
                                  ],
                                  "verification": "Explique em suas próprias palavras a diferença entre inicialização na declaração e alocação dinâmica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação oficial da linguagem (Java/C++)",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Foque nas chaves {} como lista de inicializadores.",
                                  "learningObjective": "Entender o propósito e benefícios da inicialização na declaração para arrays.",
                                  "commonMistakes": [
                                    "Confundir com alocação new[] que requer tamanho explícito",
                                    "Ignorar que o tamanho é inferido automaticamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Sintaxe para Arrays de Inteiros",
                                  "subSteps": [
                                    "Escreva a sintaxe básica: tipo[] nome = {valor1, valor2, ...};",
                                    "Teste com array de 3 inteiros: int[] numeros = {1, 2, 3};",
                                    "Compile e execute para imprimir o array (use loop for).",
                                    "Verifique o tamanho com .length.",
                                    "Experimente com arrays vazios: int[] vazio = {};"
                                  ],
                                  "verification": "O código compila e imprime os valores corretos sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE como IntelliJ ou VS Code",
                                    "Compilador Java instalado"
                                  ],
                                  "tips": "Sempre termine com ponto e vírgula e sem vírgula após o último elemento.",
                                  "learningObjective": "Aplicar corretamente a sintaxe para inicializar arrays de inteiros na declaração.",
                                  "commonMistakes": [
                                    "Adicionar vírgula extra no final: {1,2,3,}",
                                    "Esquecer as chaves {}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir para Outros Tipos de Dados",
                                  "subSteps": [
                                    "Inicialize array de doubles: double[] notas = {8.5, 7.0, 9.2};",
                                    "Crie array de strings: String[] nomes = {\"Ana\", \"João\", \"Maria\"};",
                                    "Teste com booleanos: boolean[] flags = {true, false, true};",
                                    "Compile e acesse elementos para validar.",
                                    "Note as aspas duplas para strings e vírgulas separadoras."
                                  ],
                                  "verification": "Todos os arrays de diferentes tipos compilam e acessam elementos corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "IDE com suporte a Java",
                                    "Exemplos de código online"
                                  ],
                                  "tips": "Para strings, use aspas duplas e escape caracteres especiais se necessário.",
                                  "learningObjective": "Generalizar a inicialização na declaração para tipos primitivos e referência.",
                                  "commonMistakes": [
                                    "Usar aspas simples em strings",
                                    "Misturar tipos no mesmo array"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar com Exemplos Complexos e Verificar",
                                  "subSteps": [
                                    "Crie array multidimensional: int[][] matriz = {{1,2}, {3,4}};",
                                    "Inicialize array grande com 10 elementos mistos.",
                                    "Escreva função para somar elementos e teste.",
                                    "Debugue erros comuns intencionalmente.",
                                    "Documente o código com comentários."
                                  ],
                                  "verification": "Execute testes unitários ou prints para confirmar valores e operações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com debugger",
                                    "Ferramentas de teste como JUnit básico"
                                  ],
                                  "tips": "Use System.out.println para validar durante desenvolvimento.",
                                  "learningObjective": "Consolidar o conhecimento através de prática avançada e depuração.",
                                  "commonMistakes": [
                                    "Erro de índice ao acessar",
                                    "Inicialização inconsistente em multidimensionais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de gerenciamento de notas de alunos, inicialize um array diretamente: double[] notasAlunos = {7.5, 8.0, 9.2, 6.5, 8.8};. Em seguida, calcule a média usando um loop for.",
                              "finalVerifications": [
                                "O array compila sem erros de sintaxe.",
                                "O tamanho do array corresponde ao número de elementos fornecidos.",
                                "Acessar e imprimir elementos retorna valores literais corretos.",
                                "Operações como soma ou busca funcionam como esperado.",
                                "Código é legível com comentários explicativos.",
                                "Testes com diferentes tipos (int, String, double) são bem-sucedidos."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe de inicialização (uso de {}, vírgulas, tipos).",
                                "Precisão dos valores literais no array.",
                                "Capacidade de inferir tamanho automaticamente.",
                                "Integração em código funcional (loops, métodos).",
                                "Ausência de erros comuns como vírgulas extras ou tipos mistos.",
                                "Eficiência e concisão do código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de sequências e vetores numéricos.",
                                "Lógica e Algoritmos: Processamento de listas de dados estruturados.",
                                "Banco de Dados: Inicialização de tabelas ou listas de registros.",
                                "Física/Química: Arrays para dados experimentais tabulares."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como em um app de e-commerce para inicializar lista fixa de categorias de produtos: String[] categorias = {\"Eletrônicos\", \"Roupas\", \"Livros\"}; facilitando configurações iniciais rápidas sem bancos de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Inicializar com loop",
                            "description": "Usar estruturas repetitivas (for) para atribuir valores iniciais a todos os elementos do array.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de arrays e loops for",
                                  "subSteps": [
                                    "Declare um array com tamanho fixo ou dinâmico.",
                                    "Identifique os índices dos elementos do array (de 0 até tamanho-1).",
                                    "Revise a sintaxe do loop for: for(início; condição; incremento).",
                                    "Explique como acessar e modificar elementos via índice.",
                                    "Diferencie inicialização estática de dinâmica com loop."
                                  ],
                                  "verification": "Escreva um array declarado e a sintaxe de um loop for simples sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (ex: VS Code), documentação de arrays e loops.",
                                  "tips": "Sempre comece o índice em 0 para arrays zero-based.",
                                  "learningObjective": "Dominar pré-requisitos para manipulação de arrays com repetição.",
                                  "commonMistakes": "Esquecer que arrays começam no índice 0; confundir loop for com while."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar a inicialização do array",
                                  "subSteps": [
                                    "Defina o tamanho do array e o valor inicial desejado (ex: 0, -1 ou valor específico).",
                                    "Calcule o número de iterações necessário (tamanho do array).",
                                    "Esboce o pseudocódigo: percorrer índices e atribuir valor.",
                                    "Considere casos especiais como array vazio ou tamanho variável.",
                                    "Liste variáveis necessárias: array, índice, valor_inicial."
                                  ],
                                  "verification": "Crie um fluxograma ou pseudocódigo comentado do processo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação (ex: Draw.io).",
                                  "tips": "Use valor_inicial como constante para facilitar mudanças futuras.",
                                  "learningObjective": "Planejar logicamente antes de codificar para evitar erros.",
                                  "commonMistakes": "Ignorar limites do array levando a overflow de índices."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop for para inicialização",
                                  "subSteps": [
                                    "Declare o array sem inicializar (ex: int array[10];).",
                                    "Escreva o loop for(i=0; i<tamanho; i++).",
                                    "Dentro do loop, atribua array[i] = valor_inicial.",
                                    "Adicione comentários explicando cada linha.",
                                    "Compile ou execute o código em um ambiente de teste."
                                  ],
                                  "verification": "O código roda sem erros e imprime o array inicializado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador/interpretador (ex: Python, C++ online como Replit).",
                                  "tips": "Use printf ou print para visualizar o array após o loop.",
                                  "learningObjective": "Escrever código funcional para inicializar arrays dinamicamente.",
                                  "commonMistakes": "Escrever i <= tamanho em vez de i < tamanho, causando acesso inválido."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar a inicialização",
                                  "subSteps": [
                                    "Teste com diferentes tamanhos de array (pequeno, médio).",
                                    "Verifique se todos os elementos têm o valor inicial correto.",
                                    "Introduza um erro intencional (ex: índice errado) e corrija.",
                                    "Meça o tempo de execução para arrays grandes.",
                                    "Documente lições aprendidas em um log."
                                  ],
                                  "verification": "Todos os testes passam e array está 100% inicializado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ambiente de execução com debugger.",
                                  "tips": "Use loops de impressão para inspecionar o array elemento por elemento.",
                                  "learningObjective": "Garantir robustez e correção do código implementado.",
                                  "commonMistakes": "Não testar bordas como array de tamanho 1 ou 0."
                                }
                              ],
                              "practicalExample": "Em Python: array = [0] * 5  # Estático\n# Com loop: array = [0] * 5\nfor i in range(5):\n    array[i] = -1\nprint(array)  # Saída: [-1, -1, -1, -1, -1] - Inicializa placar de jogo com valores padrão.",
                              "finalVerifications": [
                                "Todos os elementos do array possuem o valor inicial correto.",
                                "O loop executa exatamente 'tamanho' iterações.",
                                "Não há erros de índice fora dos limites (out of bounds).",
                                "O código é eficiente (O(n) tempo).",
                                "Funciona para tamanhos variáveis de array.",
                                "Impressão ou dump do array confirma inicialização."
                              ],
                              "assessmentCriteria": [
                                "Correção: Array inicializado sem falhas.",
                                "Eficiência: Loop simples sem redundâncias.",
                                "Legibilidade: Código comentado e indentado.",
                                "Robustez: Trata tamanhos diferentes corretamente.",
                                "Documentação: Explicações claras nos comentários.",
                                "Depuração: Identifica e corrige erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências aritméticas e iterações.",
                                "Lógica: Estruturas de controle e algoritmos repetitivos.",
                                "Física/Engenharia: Inicialização de vetores em simulações numéricas.",
                                "Estatística: Preparação de arrays para dados experimentais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, inicializar arrays com zeros para contadores em jogos (placar), buffers de rede ou matrizes em machine learning, evitando valores garbage e garantindo previsibilidade em simulações financeiras ou científicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Inicializar com valores padrão",
                            "description": "Atribuir um valor padrão (ex: zero) a todos os elementos usando loops ou funções específicas da linguagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de inicialização com valores padrão",
                                  "subSteps": [
                                    "Explicar o que são valores padrão (ex: zero para inteiros, null para objetos)",
                                    "Discutir problemas de memória não inicializada (valores lixo)",
                                    "Analisar exemplo de array declarado sem inicialização em uma linguagem como C ou Python",
                                    "Comparar arrays inicializados vs. não inicializados em termos de comportamento",
                                    "Identificar cenários onde inicialização é obrigatória"
                                  ],
                                  "verification": "Escrever um parágrafo resumindo a importância da inicialização e listar 3 riscos de não fazer",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagens (C, Java, Python)",
                                    "Editor de código simples"
                                  ],
                                  "tips": "Use diagramas de memória para visualizar valores lixo",
                                  "learningObjective": "Entender por que arrays precisam ser inicializados com valores padrão",
                                  "commonMistakes": "Acreditar que arrays são automaticamente inicializados com zero em todas as linguagens"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar o array e preparar para inicialização",
                                  "subSteps": [
                                    "Escolher o tipo de dado e tamanho do array (ex: int array[10])",
                                    "Declarar o array em pseudocódigo ou linguagem específica",
                                    "Verificar sintaxe de declaração na linguagem escolhida",
                                    "Alocar memória dinamicamente se necessário (ex: malloc em C)",
                                    "Compilar/testar declaração isolada"
                                  ],
                                  "verification": "Compilar o código de declaração sem erros e imprimir o array para ver valores iniciais",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador/IDE (GCC, Python IDLE)",
                                    "Referência de sintaxe da linguagem"
                                  ],
                                  "tips": "Sempre declare com tamanho fixo para prática inicial",
                                  "learningObjective": "Saber declarar arrays corretamente para posterior inicialização",
                                  "commonMistakes": "Confundir declaração estática com dinâmica ou errar o tipo de dado"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar inicialização usando loops",
                                  "subSteps": [
                                    "Escrever um loop for de 0 a tamanho-1",
                                    "Atribuir valor padrão dentro do loop (ex: array[i] = 0)",
                                    "Adicionar comentários explicando cada linha",
                                    "Executar o código e imprimir o array",
                                    "Medir o tempo de execução para arrays grandes"
                                  ],
                                  "verification": "Imprimir o array e confirmar que todos os elementos são o valor padrão escolhido",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use range() em Python ou for(int i=0; i<size; i++) em C",
                                  "learningObjective": "Dominar inicialização manual com loops para controle total",
                                  "commonMistakes": "Errar limites do loop (off-by-one) ou esquecer o incremento"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar funções específicas da linguagem para inicialização",
                                  "subSteps": [
                                    "Pesquisar funções built-in (ex: memset em C, Arrays.fill em Java, [0]*n em Python)",
                                    "Implementar usando a função específica",
                                    "Comparar performance com loop manual (usar timer)",
                                    "Testar com diferentes tipos de dados (int, float, char)",
                                    "Documentar vantagens e desvantagens de cada método"
                                  ],
                                  "verification": "Executar ambos métodos (loop e função) e comparar saídas e tempos",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial (man pages, Python docs)",
                                    "Ferramentas de profiling simples"
                                  ],
                                  "tips": "Prefira funções built-in para eficiência em produção",
                                  "learningObjective": "Conhecer e aplicar métodos otimizados de inicialização",
                                  "commonMistakes": "Usar função errada para o tipo de dado ou passar parâmetros incorretos"
                                }
                              ],
                              "practicalExample": "Em Python, inicialize um array de 10 inteiros com zero: arr = [0] * 10 ou usando loop: for i in range(10): arr[i] = 0. Em C: int arr[10]; memset(arr, 0, sizeof(arr));. Teste imprimindo: todos elementos devem ser 0.",
                              "finalVerifications": [
                                "Todos os elementos do array exibem o valor padrão exato (ex: 0)",
                                "Não há valores lixo ou indefinidos ao inspecionar o array",
                                "Código compila e executa sem erros ou warnings",
                                "Performance é aceitável para tamanhos testados (ex: <1s para 1000 elementos)",
                                "Método funciona para diferentes tipos de dados (int, float)",
                                "Documentação no código explica o método usado"
                              ],
                              "assessmentCriteria": [
                                "Correção: Todos elementos inicializados corretamente",
                                "Eficiência: Uso de loop ou função otimizada",
                                "Clareza: Código comentado e indentado",
                                "Robustez: Funciona para tamanhos variáveis",
                                "Documentação: Explicação de métodos alternativos",
                                "Testes: Verificações incluídas no código"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Compreensão de índices e sequências numéricas",
                                "Lógica: Estruturas de repetição e controle de fluxo",
                                "Física/Engenharia: Gerenciamento de memória em sistemas embarcados",
                                "Gestão de Projetos: Boas práticas para evitar bugs em software"
                              ],
                              "realWorldApplication": "Inicializar buffers de áudio/vídeo em apps multimídia, tabuleiros em jogos (ex: xadrez com peças vazias), matrizes em simulações científicas ou arrays de sensores em IoT para evitar leituras erradas."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Acesso e Manipulação de Arrays",
                        "description": "Acessar elementos por índice (base zero), modificar valores e percorrer o array para operações comuns.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Acessar elemento por índice",
                            "description": "Ler o valor de um elemento específico usando notação de colchetes [índice], validando limites para evitar erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de arrays e índices",
                                  "subSteps": [
                                    "Aprenda a definição de um array como uma coleção ordenada de elementos.",
                                    "Entenda que os índices começam em 0 (zero-based indexing).",
                                    "Visualize um array como uma prateleira numerada: posição 0 é o primeiro item.",
                                    "Identifique o tamanho do array com a propriedade length.",
                                    "Calcule o índice do último elemento: length - 1."
                                  ],
                                  "verification": "Explique em suas palavras o que é um índice e dê um exemplo com um array de 3 elementos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Documentação oficial da linguagem sobre arrays (ex: MDN para JavaScript)"
                                  ],
                                  "tips": "Sempre lembre: primeiro elemento é [0], não [1]. Use diagramas para visualizar.",
                                  "learningObjective": "Dominar o conceito de indexação zero-based em arrays.",
                                  "commonMistakes": [
                                    "Assumir que índices começam em 1 (como em algumas linguagens como MATLAB).",
                                    "Confundir índice com posição humana (1º, 2º)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe de acesso por colchetes",
                                  "subSteps": [
                                    "Escreva a sintaxe básica: nomeDoArray[índice].",
                                    "Teste acessando o primeiro elemento [0] em um array simples.",
                                    "Acesse um elemento intermediário, como [2].",
                                    "Acesse o último elemento usando length - 1.",
                                    "Armazene o valor acessado em uma variável."
                                  ],
                                  "verification": "Execute código que acesse e imprima array[0] e array[2], confirmando saídas corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ambiente de execução (ex: Replit, Node.js)",
                                    "Array de exemplo pronto para copiar"
                                  ],
                                  "tips": "Use console.log() para verificar valores imediatamente após acesso.",
                                  "learningObjective": "Aplicar corretamente a notação de colchetes para ler elementos.",
                                  "commonMistakes": [
                                    "Esquecer os colchetes ou usar parênteses ().",
                                    "Usar aspas no índice: array['0'] em vez de array[0]."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar acesso a elementos específicos",
                                  "subSteps": [
                                    "Crie um array com dados reais (ex: notas de alunos).",
                                    "Acesse elementos por índices fornecidos (ex: nota do aluno 1: [1]).",
                                    "Combine acesso com operações simples (ex: somar array[0] + array[1]).",
                                    "Itere manualmente acessando múltiplos índices.",
                                    "Modifique um elemento acessado e verifique a mudança."
                                  ],
                                  "verification": "Desenvolva um snippet que acesse 3 elementos diferentes e os exiba corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de exemplos de arrays temáticos",
                                    "Ferramenta de depuração (console ou debugger)"
                                  ],
                                  "tips": "Comece com arrays pequenos (3-5 elementos) para evitar confusão.",
                                  "learningObjective": "Executar acessos precisos em cenários práticos.",
                                  "commonMistakes": [
                                    "Acessar índice inexistente sem verificar (ex: [5] em array de 3).",
                                    "Não atualizar a visualização após modificação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar limites e tratar erros de índice",
                                  "subSteps": [
                                    "Verifique se índice >= 0 e < array.length antes de acessar.",
                                    "Use condicionais if para validar: if (indice >= 0 && indice < length).",
                                    "Implemente mensagem de erro para índices inválidos.",
                                    "Teste com índices negativos, zero e além do length.",
                                    "Adicione try-catch para erros de runtime em linguagens que suportam."
                                  ],
                                  "verification": "Código que rejeite acessos inválidos e acesse apenas válidos, sem crashes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de código com erros comuns",
                                    "Documentação de erros de array (ArrayIndexOutOfBounds)"
                                  ],
                                  "tips": "Sempre valide bounds antes do acesso para robustez.",
                                  "learningObjective": "Prevenir e gerenciar erros de acesso fora dos limites.",
                                  "commonMistakes": [
                                    "Ignorar validação, causando crashes.",
                                    "Usar length em vez de length-1 para último índice."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um array de notas de alunos: let notas = [8.5, 7.0, 9.2, 6.8]; Acesse a nota do segundo aluno com notas[1] (7.0), valide se 1 < notas.length, e imprima 'Nota: 7.0'. Teste com índice 4 para ver erro.",
                              "finalVerifications": [
                                "Consegue acessar corretamente o primeiro [0] e último [length-1] elemento?",
                                "Identifica e evita acesso a índice negativo?",
                                "Valida limites antes de acessar e trata erros?",
                                "Explica por que array[3] falha em um array de 3 elementos?",
                                "Modifica um elemento via acesso e confirma mudança?",
                                "Usa acesso em expressões compostas sem erros?"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe de [índice] usada corretamente em todos os casos.",
                                "Validação de bounds implementada e funcional.",
                                "Códigos executam sem erros de runtime.",
                                "Explicações verbais demonstram compreensão conceitual.",
                                "Exemplos práticos produzem saídas esperadas.",
                                "Tratamento de erros é proativo e informativo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e indexação numérica (aritmética modular).",
                                "Lógica e Algoritmos: Condicionais para validação de entrada.",
                                "Banco de Dados: Consultas por chave primária ou posição em tabelas.",
                                "Estatística: Acesso a dados em vetores para cálculos."
                              ],
                              "realWorldApplication": "Em um app de e-commerce, acessar o preço do produto no índice 2 de um carrinho de compras: carrinho[2].preco, validando para evitar crashes se o carrinho tiver menos itens, garantindo UX suave."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Modificar elemento do array",
                            "description": "Atribuir novo valor a um elemento específico via índice, demonstrando mutabilidade dos arrays.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Arrays e Índices",
                                  "subSteps": [
                                    "Defina o que é um array: uma estrutura de dados que armazena múltiplos valores em uma única variável, acessíveis por índice.",
                                    "Entenda os índices: começam em 0 para o primeiro elemento, incrementando sequencialmente.",
                                    "Crie um array simples em Python: minha_lista = ['a', 'b', 'c'].",
                                    "Acesse elementos por índice: print(minha_lista[0]) resulta em 'a'.",
                                    "Pratique acessando o último elemento com índice -1."
                                  ],
                                  "verification": "Liste corretamente os índices de um array de 5 elementos e acesse 3 elementos específicos sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código como VS Code ou Replit",
                                    "Documentação oficial do Python sobre listas"
                                  ],
                                  "tips": "Sempre lembre que índices começam em 0, não em 1, para evitar confusões iniciais.",
                                  "learningObjective": "Compreender a estrutura e o acesso sequencial por índice em arrays mutáveis.",
                                  "commonMistakes": [
                                    "Usar índice 1 para o primeiro elemento",
                                    "Ignorar índices negativos para acesso reverso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Mutabilidade dos Arrays",
                                  "subSteps": [
                                    "Explique mutabilidade: arrays em Python (listas) permitem alteração após criação, diferentemente de strings imutáveis.",
                                    "Compare com estruturas imutáveis: tente modificar uma string e observe o erro.",
                                    "Demonstre com exemplo: numeros = [1, 2, 3]; numeros[0] = 10; agora é [10, 2, 3].",
                                    "Discuta vantagens: eficiência em grandes coleções de dados dinâmicos.",
                                    "Identifique cenários onde mutabilidade é essencial, como listas de usuários."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre mutável e imutável, com exemplo funcional.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Console Python interativo (REPL)",
                                    "Notebook Jupyter para experimentação"
                                  ],
                                  "tips": "Use print() antes e depois da modificação para visualizar mudanças imediatamente.",
                                  "learningObjective": "Diferenciar mutabilidade de arrays e reconhecer quando usá-la.",
                                  "commonMistakes": [
                                    "Confundir listas com tuplas imutáveis",
                                    "Tentar modificar elementos em estruturas erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a Sintaxe de Modificação de Elementos",
                                  "subSteps": [
                                    "Aprenda a sintaxe principal: array[indice] = novo_valor.",
                                    "Teste com diferentes tipos de dados: strings, números, booleanos.",
                                    "Modifique múltiplos elementos: array[1] = 'novo'; array[3] = 99.",
                                    "Use índices dinâmicos: indice = 2; array[indice] = 'x'.",
                                    "Valide limites: evite IndexError acessando len(array) primeiro."
                                  ],
                                  "verification": "Execute código que modifique 3 elementos diferentes em um array e imprima o resultado alterado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente Python online como Python Tutor para visualização passo a passo",
                                    "Exercícios em LeetCode ou HackerRank"
                                  ],
                                  "tips": "Sempre verifique o comprimento do array com len() antes de modificar para prevenir erros de índice.",
                                  "learningObjective": "Aplicar corretamente a sintaxe de atribuição por índice em arrays.",
                                  "commonMistakes": [
                                    "Esquecer os colchetes [] na atribuição",
                                    "Usar vírgula em vez de atribuição ="
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Aplicar em Contextos Reais",
                                  "subSteps": [
                                    "Crie um array de notas de alunos e modifique uma nota específica.",
                                    "Simule um carrinho de compras: altere quantidade de um item pelo índice.",
                                    "Debugue erros comuns: corrija IndexError e TypeError em códigos falhos.",
                                    "Expanda para loops: use for i in range(len(array)) para modificações condicionais.",
                                    "Documente seu código com comentários explicando cada modificação."
                                  ],
                                  "verification": "Desenvolva e execute um script completo que modifique um array baseado em condições e produza saída correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Projeto pessoal em GitHub",
                                    "Ferramentas de debug como pdb ou print statements"
                                  ],
                                  "tips": "Combine com if para modificações condicionais: if array[i] > 5: array[i] = 0.",
                                  "learningObjective": "Integrar modificação de arrays em programas práticos e resolver problemas reais.",
                                  "commonMistakes": [
                                    "Modificar array durante iteração sem cuidado",
                                    "Índices fora dos limites em loops"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de tarefas: tarefas = ['Estudar Python', 'Fazer exercício', 'Revisar código']; tarefas[1] = 'Fazer exercício avançado'; print(tarefas) resulta em ['Estudar Python', 'Fazer exercício avançado', 'Revisar código']. Isso atualiza uma tarefa específica sem recriar a lista inteira.",
                              "finalVerifications": [
                                "Modificar corretamente um elemento por índice sem erros de sintaxe.",
                                "Explicar o impacto da mutabilidade antes/depois da alteração.",
                                "Identificar e corrigir IndexError em cenários de teste.",
                                "Aplicar modificação em array com pelo menos 5 elementos.",
                                "Comparar output antes e depois da modificação.",
                                "Usar len() para validar índices dinamicamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe de atribuição (array[índice] = valor).",
                                "Compreensão conceitual de mutabilidade demonstrada em explicações.",
                                "Capacidade de debugar erros comuns como IndexError.",
                                "Criatividade em exemplos práticos e aplicações.",
                                "Eficiência no uso de recursos como len() e loops.",
                                "Documentação clara do código com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Índices como coordenadas em sequências numéricas.",
                                "Lógica e Algoritmos: Modificações condicionais em fluxos de decisão.",
                                "Gestão de Projetos: Atualização de listas de tarefas em planejamento.",
                                "Banco de Dados: Conceitos semelhantes a UPDATE em SQL por chave primária."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, como atualizar o status de um pedido em um e-commerce (pedidos[índice] = 'enviado'), gerenciando estoques dinâmicos ou personalizando listas de usuários em apps web."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Percorrer array com loop",
                            "description": "Implementar loop for para iterar sobre todos os elementos, somando ou exibindo valores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar e Inicializar um Array de Exemplo",
                                  "subSteps": [
                                    "Escolha uma linguagem de programação introdutória como Python.",
                                    "Crie um array com valores numéricos, ex: notas = [85, 92, 78, 95, 88].",
                                    "Imprima o array para confirmar a inicialização.",
                                    "Verifique o comprimento do array usando len(notas).",
                                    "Adicione um comentário explicando o propósito do array."
                                  ],
                                  "verification": "Execute o código e confirme que o array é impresso corretamente com todos os elementos e o comprimento.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Replit)",
                                    "Python instalado"
                                  ],
                                  "tips": "Use nomes descritivos para variáveis para facilitar a compreensão.",
                                  "learningObjective": "Entender como declarar e visualizar um array para preparar iteração.",
                                  "commonMistakes": [
                                    "Esquecer vírgulas entre elementos",
                                    "Usar aspas em números (torna strings)",
                                    "Erro de sintaxe na declaração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender e Implementar a Sintaxe do Loop For com Índice",
                                  "subSteps": [
                                    "Estude a sintaxe: for i in range(len(array)):",
                                    "Escreva um loop vazio que itere de 0 até len(array)-1.",
                                    "Adicione print(i) dentro do loop para ver os índices.",
                                    "Teste o loop imprimindo os índices sequencialmente.",
                                    "Comente cada linha do loop explicando seu papel."
                                  ],
                                  "verification": "O loop deve imprimir índices de 0 a 4 (para array de 5 elementos) sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação Python range() e len()",
                                    "Ambiente de execução Python"
                                  ],
                                  "tips": "Lembre-se que range(len(array)) gera índices de 0 a n-1.",
                                  "learningObjective": "Dominar a sintaxe do loop for para acessar índices de um array.",
                                  "commonMistakes": [
                                    "Usar for i in array (itera valores, não índices)",
                                    "Esquecer os dois pontos após o for",
                                    "range(array) em vez de range(len(array))"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Iterar e Exibir Todos os Elementos do Array",
                                  "subSteps": [
                                    "Modifique o loop para acessar array[i] e imprimir cada elemento.",
                                    "Formate a saída como 'Elemento na posição X: valor'.",
                                    "Execute e compare a saída com o array original.",
                                    "Adicione um contador manual para validar iterações.",
                                    "Teste com um array maior para observar o comportamento."
                                  ],
                                  "verification": "Saída lista todos os elementos corretamente com suas posições.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Console ou terminal para depuração",
                                    "Array de teste expandido"
                                  ],
                                  "tips": "Use f-strings em Python para formatação clara: print(f'Posição {i}: {array[i]}').",
                                  "learningObjective": "Aplicar o loop para percorrer e exibir dados de um array.",
                                  "commonMistakes": [
                                    "Acessar array[i+1] causando index error",
                                    "Imprimir i em vez de array[i]",
                                    "Loop infinito por erro em range"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Soma de Elementos Usando o Loop",
                                  "subSteps": [
                                    "Inicialize uma variável soma = 0 antes do loop.",
                                    "Dentro do loop, adicione array[i] à soma.",
                                    "Após o loop, imprima a soma total.",
                                    "Calcule manualmente para verificar: soma deve ser 438 para [85,92,78,95,88].",
                                    "Refatore para calcular média: media = soma / len(array)."
                                  ],
                                  "verification": "Soma impressa é correta (438) e média é precisa (87.6).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora para verificação manual",
                                    "Código dos passos anteriores"
                                  ],
                                  "tips": "Sempre inicialize acumuladores como soma=0 para evitar resultados incorretos.",
                                  "learningObjective": "Usar loop para processar dados agregados como somas em arrays.",
                                  "commonMistakes": [
                                    "Esquecer inicializar soma (usa valor garbage)",
                                    "Adicionar i em vez de array[i]",
                                    "Dividir por 0 em média"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um array de vendas diárias: vendas = [100, 150, 200, 120, 180]. Use loop for i in range(len(vendas)): para somar o total de vendas e imprimir cada venda com 'Dia {i+1}: R${vendas[i]}'. Total esperado: 750.",
                              "finalVerifications": [
                                "Loop itera exatamente pelo número de elementos sem pular ou repetir.",
                                "Todos os elementos são acessados e processados corretamente.",
                                "Soma ou exibição produz resultados idênticos ao cálculo manual.",
                                "Código executa sem erros de índice ou sintaxe.",
                                "Comentários explicam lógica do loop e array.",
                                "Funciona com arrays de tamanhos variados (teste com 3 e 10 elementos)."
                              ],
                              "assessmentCriteria": [
                                "Correção da sintaxe do loop for e acesso por índice.",
                                "Precisão na exibição e soma de elementos.",
                                "Eficiência: O(n) sem loops desnecessários.",
                                "Robustez: Trata arrays vazios ou unitários.",
                                "Clareza: Código legível com comentários e formatação.",
                                "Testes: Múltiplos cenários validados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de somatória e iteração sequencial.",
                                "Estatística: Cálculo de médias e agregações de dados.",
                                "Algoritmos: Introdução a complexidade temporal O(n).",
                                "Lógica: Sequenciamento de instruções em programação."
                              ],
                              "realWorldApplication": "Em aplicativos de e-commerce, percorrer arrays de transações para calcular totais de vendas diárias, gerar relatórios financeiros ou processar listas de usuários em bancos de dados."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.4",
                            "name": "Tratar limites do array",
                            "description": "Verificar índices válidos (0 a tamanho-1) usando condicionais para prevenir acesso fora dos limites.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de limites de array",
                                  "subSteps": [
                                    "Defina o que é um índice em um array e explique que inicia em 0.",
                                    "Explique a propriedade 'length' ou 'tamanho' do array e seu significado.",
                                    "Identifique índices válidos: de 0 até (length - 1).",
                                    "Diferencie índices válidos de inválidos com exemplos simples (ex: array de 3 elementos: 0,1,2 válidos; -1 ou 3 inválidos).",
                                    "Discuta consequências de acesso fora dos limites (ex: erro de runtime)."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre índices válidos/inválidos em um array de tamanho conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de arrays na linguagem escolhida (ex: MDN para JS, Python docs)",
                                    "Editor de código simples"
                                  ],
                                  "tips": "Sempre subtraia 1 do length para o último índice válido.",
                                  "learningObjective": "Dominar os fundamentos teóricos de índices e bounds de arrays.",
                                  "commonMistakes": [
                                    "Assumir índices baseados em 1 (como em algumas linguagens matemáticas).",
                                    "Confundir length com número de índices acessíveis (length inclui o último).",
                                    "Ignorar índices negativos como inválidos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar riscos e cenários de erro",
                                  "subSteps": [
                                    "Analise código sem verificação de bounds e simule acessos inválidos.",
                                    "Liste cenários comuns: usuário insere índice negativo, maior que length ou length exato.",
                                    "Discuta impactos: exceções, crashes, dados incorretos ou comportamento indefinido.",
                                    "Crie um fluxograma simples de acesso a array com e sem verificação.",
                                    "Registre 3 exemplos de código vulnerável."
                                  ],
                                  "verification": "Crie e execute 3 exemplos de código que falhem por bounds checking ausente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Replit)",
                                    "Console para testar erros"
                                  ],
                                  "tips": "Use console.log ou print para simular entradas inválidas antes de codificar.",
                                  "learningObjective": "Reconhecer padrões de risco em manipulação de arrays.",
                                  "commonMistakes": [
                                    "Subestimar entradas do usuário (ex: loops que vão além do length).",
                                    "Não considerar length dinâmico (após push/pop).",
                                    "Ignorar que length pode ser 0 (array vazio)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar verificação condicional de bounds",
                                  "subSteps": [
                                    "Escreva uma função que receba array e índice como parâmetros.",
                                    "Adicione condicional: if (index >= 0 && index < array.length).",
                                    "No ramo true, acesse o elemento; no false, retorne mensagem de erro ou valor padrão.",
                                    "Teste a função com índices válidos e inválidos.",
                                    "Refatore para usar em um loop de iteração segura."
                                  ],
                                  "verification": "A função retorna valor correto para índices válidos e erro para inválidos, sem crashes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Linguagem de programação (JS/Python)",
                                    "Templates de código para arrays"
                                  ],
                                  "tips": "Use operadores lógicos AND (&&) para combinar condições; evite || para negações complexas.",
                                  "learningObjective": "Aplicar condicionais para validar acessos a arrays de forma segura.",
                                  "commonMistakes": [
                                    "Esquecer verificação de index < length (permitir length como válido).",
                                    "Usar <= length em vez de < length.",
                                    "Não tratar index como número (string conversion)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e refinar a implementação",
                                  "subSteps": [
                                    "Crie casos de teste: array vazio, índices negativos, zero, length-1, length.",
                                    "Execute testes automatizados ou manuais com asserts.",
                                    "Meça performance (bounds check é O(1), negligible).",
                                    "Adicione tratamento de erros com try-catch se aplicável.",
                                    "Documente a função com comentários sobre bounds."
                                  ],
                                  "verification": "Todos os 6+ casos de teste passam sem erros ou crashes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de teste (Jest para JS, unittest para Python)",
                                    "Lista de casos de teste pré-definida"
                                  ],
                                  "tips": "Priorize edge cases: eles causam 80% dos bugs de arrays.",
                                  "learningObjective": "Garantir robustez através de testes abrangentes de bounds.",
                                  "commonMistakes": [
                                    "Testar só casos felizes (índices médios).",
                                    "Ignorar arrays vazios ou com length=1.",
                                    "Não testar após modificações no array."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de notas de alunos, dado um array notas = [85, 90, 78, 92], antes de exibir notas[usuarioInput], verifique: if (usuarioInput >= 0 && usuarioInput < notas.length) { console.log(notas[usuarioInput]); } else { console.log('Índice inválido!'); }. Isso previne crash se usuário digitar 4 ou -1.",
                              "finalVerifications": [
                                "O código executa sem erros para todos os índices inválidos testados.",
                                "Acesso só ocorre para índices válidos, retornando valores corretos.",
                                "Mensagem de erro ou valor padrão é exibida para inválidos.",
                                "Funciona com arrays vazios (length=0).",
                                "Integração em loop não causa overflow.",
                                "Performance não degradada por checks repetidos."
                              ],
                              "assessmentCriteria": [
                                "Condicional completa: index >= 0 && index < length.",
                                "Tratamento explícito de falhas (não só silenciar).",
                                "Código legível com comentários explicando bounds.",
                                "Cobertura de testes inclui edges (negativo, zero, length).",
                                "Uso eficiente sem verificações redundantes.",
                                "Aplicação correta em contextos reais (funções/loops)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Compreensão de intervalos fechados [0, length-1].",
                                "Lógica e Algoritmos: Uso de condicionais if-else para validação.",
                                "Segurança da Informação: Prevenção de buffer overflows e injeções.",
                                "Estatística: Manipulação segura de datasets em arrays.",
                                "Design de Software: Princípios de robustez e defensive programming."
                              ],
                              "realWorldApplication": "Em aplicativos web (ex: e-commerce acessando carrinho por ID), jogos (movimentação de sprites em grid), sistemas bancários (acesso a transações por índice) e APIs (validação de parâmetros de query), evitando crashes, vazamentos de dados e downtime custoso."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.6",
                    "name": "Tipos Estruturados: Registros",
                    "description": "Agrupamento de diferentes tipos escalares em uma estrutura única.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.6.1",
                        "name": "Definição e Propósito de Registros",
                        "description": "Registros são tipos de dados estruturados que permitem o agrupamento de variáveis de diferentes tipos escalares em uma única estrutura coesa, facilitando a organização e manipulação de dados relacionados.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.6.1.1",
                            "name": "Identificar o conceito de registro",
                            "description": "Compreender que um registro é uma coleção heterogênea de campos de tipos escalares diferentes, acessíveis por nomes específicos, diferenciando-o de tipos escalares simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Tipos Escalares Simples",
                                  "subSteps": [
                                    "Defina tipos escalares como inteiros, strings e floats, que armazenam um único valor atômico.",
                                    "Liste exemplos: int para números inteiros, string para texto, float para decimais.",
                                    "Discuta limitações: não agrupam múltiplos valores de tipos diferentes.",
                                    "Compare com estruturas compostas em linguagens como C ou Pascal.",
                                    "Pratique identificando escalares em código simples."
                                  ],
                                  "verification": "Liste 5 exemplos de tipos escalares e explique por que eles são 'simples'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel, quadro branco ou editor de texto simples.",
                                  "tips": "Use analogias cotidianas, como um 'número único' vs. 'um formulário preenchido'.",
                                  "learningObjective": "Entender a natureza atômica e homogênea dos tipos escalares.",
                                  "commonMistakes": "Confundir escalares com arrays (que são homogêneos mas múltiplos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Coleções Heterogêneas",
                                  "subSteps": [
                                    "Explique 'heterogêneo' como mistura de tipos diferentes em uma estrutura única.",
                                    "Descreva um registro como uma 'caixa' contendo campos de tipos variados.",
                                    "Compare com tuplas (ordenadas, sem nomes) vs. registros (nomeados).",
                                    "Crie um diagrama simples mostrando campos mistos: nome (string), idade (int), salário (float).",
                                    "Discuta benefícios: organização lógica de dados relacionados."
                                  ],
                                  "verification": "Desenhe um diagrama de uma coleção heterogênea com 3 campos diferentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta para diagramas, ou ferramenta online como draw.io.",
                                  "tips": "Pense em um 'dossiê pessoal': foto, nome, data de nascimento – tudo junto mas diferente.",
                                  "learningObjective": "Reconhecer que registros agrupam dados de tipos escalares distintos.",
                                  "commonMistakes": "Achar que heterogêneo significa 'aleatório'; enfatize organização intencional."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Acesso por Nomes Específicos",
                                  "subSteps": [
                                    "Demonstre sintaxe: registro.campo ou registro['campo'] para acessar valores.",
                                    "Compare com arrays (índices numéricos) vs. registros (chaves nomeadas).",
                                    "Pratique atribuindo valores: pessoa.nome = 'João'; pessoa.idade = 25.",
                                    "Discuta vantagens: legibilidade e robustez a mudanças de ordem.",
                                    "Teste em pseudocódigo ou linguagem simples como Python (namedtuple)."
                                  ],
                                  "verification": "Escreva código para acessar e modificar 3 campos de um registro fictício.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código online (Replit ou CodePen), pseudocódigo.",
                                  "tips": "Nomes de campos devem ser descritivos para facilitar manutenção.",
                                  "learningObjective": "Dominar o acesso nomeado como característica chave dos registros.",
                                  "commonMistakes": "Usar índices numéricos em registros, confundindo com arrays."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Registros de Tipos Escalares",
                                  "subSteps": [
                                    "Resuma diferenças: escalar (1 valor simples) vs. registro (múltiplos campos nomeados heterogêneos).",
                                    "Crie tabela comparativa: colunas para tipo, composição, acesso, uso.",
                                    "Analise cenários: quando usar escalar (contador) vs. registro (perfil usuário).",
                                    "Debata em voz alta: 'Por que não usar múltiplos escalares separados?'",
                                    "Reforce com quiz rápido de classificação."
                                  ],
                                  "verification": "Classifique 5 estruturas como 'escalar' ou 'registro' com justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela em papel ou Google Sheets para comparação.",
                                  "tips": "Use mnemônico: 'Registro = Relacionados Nomeados Heterogêneos'.",
                                  "learningObjective": "Distinguir claramente registros de escalares em contextos práticos.",
                                  "commonMistakes": "Ver registro como 'apenas um array nomeado'; destaque heterogeneidade."
                                }
                              ],
                              "practicalExample": "Crie um registro 'Estudante': nome (string: 'Maria'), matricula (int: 12345), media (float: 8.5), ativo (boolean: true). Acesse e modifique: estudante.nome = 'Maria Silva'; imprima estudante.media para ver 8.5.",
                              "finalVerifications": [
                                "Defina registro em suas próprias palavras, incluindo heterogeneidade e acesso nomeado.",
                                "Diferencie registro de escalar com pelo menos 3 pontos chave.",
                                "Crie um registro exemplo com 4 campos de tipos diferentes.",
                                "Explique por que acesso por nome é superior a índices.",
                                "Identifique uso inadequado de escalar onde registro seria melhor."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de registro (heterogêneo, nomeado, escalares).",
                                "Clareza na diferenciação de escalares (unidade vs. composição).",
                                "Correção em exemplos práticos e sintaxe de acesso.",
                                "Profundidade em comparações (tabela ou diagrama).",
                                "Capacidade de aplicar em cenários reais sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de dados semelhantes a vetores/tuplas em álgebra linear.",
                                "Biologia: Registros como perfis genéticos (gene: string, posição: int, expressão: float).",
                                "Língua Portuguesa: Analogia com 'frases' compostas vs. 'palavras' simples.",
                                "Administração: Formulários de cadastro como registros heterogêneos."
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento como bancos de dados relacionais (tabelas com colunas nomeadas heterogêneas), apps de e-commerce (perfil de cliente: nome, email, saldo), ou jogos (personagem: vida int, nome string, posição float[])."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.6.1.2",
                            "name": "Reconhecer vantagens dos registros",
                            "description": "Explicar benefícios como organização lógica de dados relacionados, redução de parâmetros em funções e representação natural de entidades reais (ex.: aluno com nome, idade e nota).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição básica de registros",
                                  "subSteps": [
                                    "Ler a definição de registros como tipos estruturados que agrupam dados relacionados de tipos diferentes.",
                                    "Analisar a sintaxe básica em uma linguagem como Pascal: 'type Aluno = record nome: string; idade: integer; nota: real; end;'",
                                    "Identificar componentes: campos nomeados e tipos associados.",
                                    "Comparar com tipos primitivos (int, string) e arrays (mesmo tipo).",
                                    "Escrever uma definição simples em pseudocódigo."
                                  ],
                                  "verification": "Explicar em 2-3 frases o que é um registro e dar um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de registros em Pascal ou C",
                                    "Editor de texto ou IDE simples"
                                  ],
                                  "tips": "Pense nos registros como 'fichas de identificação' que organizam informações de uma entidade em um só lugar.",
                                  "learningObjective": "Definir registros e distinguir de outros tipos de dados.",
                                  "commonMistakes": [
                                    "Confundir registros com arrays (que têm elementos homogêneos)",
                                    "Ignorar que campos têm nomes e tipos específicos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar limitações de dados não estruturados",
                                  "subSteps": [
                                    "Criar uma função que recebe parâmetros separados para uma entidade: 'função imprimirAluno(nome: string, idade: int, nota: real)'",
                                    "Simular chamadas múltiplas: imprimirAluno('João', 20, 8.5); imprimirAluno('Maria', 19, 9.0).",
                                    "Listar problemas: repetição de parâmetros, risco de erros na ordem, dificuldade de manutenção.",
                                    "Contar parâmetros em funções complexas (ex: 5+ para um cliente).",
                                    "Discutir legibilidade do código resultante."
                                  ],
                                  "verification": "Descrever 3 problemas ao usar múltiplos parâmetros soltos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código sem registros"
                                  ],
                                  "tips": "Simule erros trocando ordem de parâmetros para sentir a fragilidade.",
                                  "learningObjective": "Reconhecer ineficiências em funções com muitos parâmetros independentes.",
                                  "commonMistakes": [
                                    "Subestimar erros de ordem",
                                    "Não perceber impacto na escalabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar vantagens específicas dos registros",
                                  "subSteps": [
                                    "Reescrever a função do step 2 usando registro: 'type Aluno = record ... end; função imprimirAluno(a: Aluno)'",
                                    "Comparar: redução de parâmetros (de 3 para 1), organização lógica.",
                                    "Listar vantagens: agrupamento semântico, fácil extensão de campos, representação natural de entidades.",
                                    "Testar chamadas: var al1: Aluno; al1.nome := 'João'; ... imprimirAluno(al1).",
                                    "Avaliar clareza e redução de erros."
                                  ],
                                  "verification": "Comparar códigos antes/depois e listar 4 vantagens observadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código com suporte a Pascal/C",
                                    "Papel para diagramas de comparação"
                                  ],
                                  "tips": "Use diagramas visuais: parâmetros soltos vs. estrutura de registro.",
                                  "learningObjective": "Explicar como registros resolvem problemas de organização e parâmetros.",
                                  "commonMistakes": [
                                    "Esquecer de nomear campos",
                                    "Não testar com dados reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar registros a entidades reais e sintetizar",
                                  "subSteps": [
                                    "Escolher entidade real (ex: Livro com título, autor, ISBN, ano).",
                                    "Definir registro correspondente e criar funções que o usam.",
                                    "Simular cenários: adicionar campo novo (ex: preço) sem quebrar código.",
                                    "Discutir abstração para mundo real (pessoas, produtos).",
                                    "Resumir todas as vantagens em uma tabela."
                                  ],
                                  "verification": "Criar um registro para nova entidade e explicar suas vantagens.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Lista de entidades reais (aluno, livro, carro)"
                                  ],
                                  "tips": "Comece com entidades familiares para fixar o conceito.",
                                  "learningObjective": "Aplicar vantagens de registros a casos práticos e sintetizar benefícios.",
                                  "commonMistakes": [
                                    "Escolher entidades com dados homogêneos (melhor para arrays)",
                                    "Ignorar extensibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere modelar um aluno. Sem registro: função exibirAluno(nome: string; idade: integer; nota: real). Com registro: type Aluno = record nome: string; idade: integer; nota: real; end; função exibirAluno(a: Aluno). Vantagens: chamada intuitiva (preenche ficha uma vez), menos parâmetros, fácil adicionar 'matricula: string' sem alterar assinatura da função.",
                              "finalVerifications": [
                                "Listar pelo menos 3 vantagens principais dos registros com exemplos.",
                                "Comparar código com e sem registros, destacando melhorias.",
                                "Definir registro para uma entidade real (ex: carro com placa, modelo, ano).",
                                "Explicar como registros reduzem erros em funções.",
                                "Identificar quando usar registros vs. outros tipos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de vantagens (organização, redução de params, representação natural).",
                                "Uso de exemplos concretos e corretos de entidades reais.",
                                "Clareza na comparação antes/depois de usar registros.",
                                "Compreensão de extensibilidade e manutenção.",
                                "Capacidade de aplicar a novos contextos.",
                                "Ausência de confusões com arrays ou structs semelhantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de dados como tuplas nomeadas ou vetores heterogêneos.",
                                "Ciências Biológicas: Modelagem de organismos (ex: registro para célula com DNA, membrana, núcleo).",
                                "Administração: Representação de clientes ou produtos em sistemas empresariais.",
                                "Física: Modelos de partículas com propriedades (massa, velocidade, posição)."
                              ],
                              "realWorldApplication": "Em bancos de dados relacionais (linhas de tabelas como registros), programação de jogos (personagens com atributos), sistemas ERP (cadastro de fornecedores com múltiplos campos), e desenvolvimento web (objetos JSON representando usuários)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.6.1.3",
                            "name": "Diferenciar registros de arrays",
                            "description": "Comparar registros (campos heterogêneos nomeados) com arrays (elementos homogêneos indexados), identificando cenários de uso adequados para cada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Características de Arrays",
                                  "subSteps": [
                                    "Defina array como uma coleção ordenada de elementos homogêneos acessados por índices numéricos sequenciais.",
                                    "Identifique que elementos são tipicamente do mesmo tipo (ex: todos inteiros ou strings).",
                                    "Explique acesso via índice (ex: array[0] para primeiro elemento).",
                                    "Discuta tamanho fixo ou dinâmico dependendo da linguagem.",
                                    "Exemplo simples: array de notas de alunos [85, 92, 78]."
                                  ],
                                  "verification": "Escreva uma definição de array e crie um exemplo com 3 elementos, acessando o segundo via índice.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de arrays em Python (lists) ou Java",
                                    "Editor de código online como Replit"
                                  ],
                                  "tips": "Sempre comece índices em 0; pratique acessando elementos para fixar.",
                                  "learningObjective": "Dominar as propriedades fundamentais de arrays como estrutura homogênea e indexada.",
                                  "commonMistakes": [
                                    "Confundir arrays com estruturas nomeadas",
                                    "Assumir heterogeneidade em arrays tipados",
                                    "Ignorar ordenação por índice"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Definição e Características de Registros",
                                  "subSteps": [
                                    "Defina registro como uma coleção de campos heterogêneos nomeados (ex: struct em C ou objeto em Python).",
                                    "Identifique que campos têm nomes e tipos diferentes (ex: nome:string, idade:int).",
                                    "Explique acesso via nome do campo (ex: pessoa.nome).",
                                    "Discuta que registros representam entidades compostas.",
                                    "Exemplo simples: registro de pessoa {nome: 'Ana', idade: 25, email: 'ana@email.com'}."
                                  ],
                                  "verification": "Crie um registro exemplo com 3 campos heterogêneos e acesse um via nome.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de structs em C ou classes em Python",
                                    "Editor de código online"
                                  ],
                                  "tips": "Use nomes descritivos para campos para melhorar legibilidade.",
                                  "learningObjective": "Dominar as propriedades de registros como estrutura heterogênea e nomeada.",
                                  "commonMistakes": [
                                    "Confundir campos nomeados com índices numéricos",
                                    "Forçar homogeneidade em registros",
                                    "Acessar via índice em vez de nome"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças entre Registros e Arrays",
                                  "subSteps": [
                                    "Compare homogeneidade: arrays homogêneos vs registros heterogêneos.",
                                    "Compare acesso: índices numéricos em arrays vs nomes de campos em registros.",
                                    "Discuta ordenação: arrays ordenados por índice vs registros sem ordem inerente.",
                                    "Analise tamanho: arrays frequentemente fixos vs registros flexíveis por campos.",
                                    "Crie uma tabela comparativa com 4 diferenças chave."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 diferenças entre arrays e registros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de tabela como Google Sheets",
                                    "Exemplos de código de steps anteriores"
                                  ],
                                  "tips": "Use mnemônicos: 'Array = Alinhado e Anônimo (índices)' vs 'Registro = Rotulado e Rico (nomes/tipos)'.",
                                  "learningObjective": "Identificar e articular diferenças estruturais precisas entre arrays e registros.",
                                  "commonMistakes": [
                                    "Ignorar diferenças de acesso",
                                    "Equiparar objetos dinâmicos a arrays",
                                    "Subestimar heterogeneidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Cenários de Uso Adequados para Cada Estrutura",
                                  "subSteps": [
                                    "Liste cenários para arrays: listas de números, sequências homogêneas (ex: coordenadas x,y,z).",
                                    "Liste cenários para registros: modelagem de entidades (ex: aluno com nome, nota, ID).",
                                    "Escolha estrutura errada em exemplos: por quê array não serve para dados heterogêneos?",
                                    "Combine: array de registros (ex: lista de alunos).",
                                    "Avalie trade-offs: performance de arrays vs legibilidade de registros."
                                  ],
                                  "verification": "Para 3 cenários reais, justifique a escolha entre array ou registro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos reais de código de sistemas como banco de dados simples"
                                  ],
                                  "tips": "Pergunte: 'Os dados são uniformes e ordenados?' -> Array; 'Compostos e nomeados?' -> Registro.",
                                  "learningObjective": "Selecionar a estrutura apropriada baseado em requisitos de dados.",
                                  "commonMistakes": [
                                    "Usar arrays para entidades complexas",
                                    "Usar registros para listas simples de primitivos",
                                    "Ignorar combinações como array<registro>"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de estoque: Use um array para armazenar quantidades de itens vendidos no dia [10, 25, 5] (homogêneo, indexado por produto). Use um registro para detalhes de um item {codigo: 'ABC123', nome: 'Notebook', preco: 2500.00, estoque: 15} (heterogêneo, nomeado). Uma lista de itens seria array de registros.",
                              "finalVerifications": [
                                "Explique em 2 frases a diferença principal entre acesso em arrays e registros.",
                                "Crie um exemplo onde array é inadequado e registro é ideal, justificando.",
                                "Converta um array de notas em array de registros de alunos.",
                                "Identifique 3 cenários onde cada estrutura é preferível.",
                                "Desenhe diagramas simples de memória para array vs registro.",
                                "Responda: 'Por que arrays são mais eficientes para buscas sequenciais?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de homogeneidade e heterogeneidade (90%+ correto).",
                                "Correta distinção de mecanismos de acesso (índice vs nome).",
                                "Exemplos práticos relevantes e sem erros de conceito.",
                                "Justificativas lógicas para cenários de uso.",
                                "Completude da tabela comparativa com pelo menos 5 itens.",
                                "Ausência de confusões comuns como equiparar listas a registros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Arrays como vetores/matrices; registros como tuplas nomeadas.",
                                "Banco de Dados: Arrays como colunas simples; registros como linhas/tuplas.",
                                "Biologia: Arrays para sequências genéticas homogêneas; registros para perfis de organismos.",
                                "Física: Arrays para dados experimentais seriados; registros para propriedades de partículas."
                              ],
                              "realWorldApplication": "No desenvolvimento de apps como e-commerce, arrays gerenciam carrinhos de quantidades (ex: [1,3,0]), enquanto registros modelam produtos ({id:1, nome:'Camisa', preco:29.99}); em jogos, arrays para posições de inimigos, registros para stats de personagens, otimizando performance e manutenibilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.6.2",
                        "name": "Declaração e Definição de Registros",
                        "description": "Processo de definir a estrutura de um registro, especificando nomes e tipos dos campos, em linguagens procedimentais como C ou C++.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.6.2.1",
                            "name": "Escrever declaração de tipo registro",
                            "description": "Criar a definição de um tipo registro usando sintaxe como 'struct' em C/C++, declarando campos de tipos escalares variados (ex.: struct Aluno { char nome[50]; int idade; float nota; };).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sintaxe básica de declaração de struct",
                                  "subSteps": [
                                    "Estude a sintaxe geral: 'struct NomeTipo { tipo1 campo1; tipo2 campo2; };'.",
                                    "Identifique componentes chave: 'struct', nome do tipo, chaves '{}', declarações de campos terminando em ';', ponto e vírgula final após '}'.",
                                    "Revise regras de nomenclatura: nomes em letras minúsculas, sem espaços ou caracteres especiais.",
                                    "Analise exemplos simples com 1-2 campos de tipos escalares.",
                                    "Escreva manualmente um struct vazio para fixar a estrutura."
                                  ],
                                  "verification": "Escreva um struct vazio e liste verbalmente ou por escrito todos os seus componentes corretos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação oficial de C/C++ sobre structs",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Visualize a estrutura como um molde para dados agrupados, similar a uma ficha de identificação.",
                                  "learningObjective": "Reconhecer e reproduzir a sintaxe fundamental de um struct.",
                                  "commonMistakes": [
                                    "Esquecer o ';' após as chaves fechadas.",
                                    "Confundir com funções ou arrays."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar os campos e tipos escalares para o registro",
                                  "subSteps": [
                                    "Defina o propósito do registro (ex.: representar um 'Aluno').",
                                    "Liste 4-6 campos relevantes com tipos escalares: char[] para strings, int para inteiros, float para decimais, bool para lógico.",
                                    "Garanta variedade: inclua pelo menos um array de char, um inteiro, um float e um bool.",
                                    "Especifique tamanhos para arrays (ex.: char nome[50]) e valide faixas realistas.",
                                    "Crie nomes descritivos para campos e struct, seguindo convenções camelCase ou snake_case."
                                  ],
                                  "verification": "Produza uma lista tabular de campos, tipos e justificativas, sem erros de tipo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel/caneta ou planilha digital",
                                    "Referência de tipos escalares em C/C++"
                                  ],
                                  "tips": "Pense em um cenário real para guiar a escolha de campos, evitando excesso ou falta.",
                                  "learningObjective": "Selecionar tipos escalares adequados para representar dados estruturados.",
                                  "commonMistakes": [
                                    "Usar float para contagens inteiras como idade.",
                                    "Nomes vagos como 'campo1' em vez de 'notaFinal'."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever a declaração completa do tipo registro",
                                  "subSteps": [
                                    "Inicie com 'struct NomeStruct {' em uma nova linha.",
                                    "Declare cada campo em linhas separadas: 'tipo nomeCampo;'.",
                                    "Adicione comentários inline explicando o propósito de cada campo.",
                                    "Feche com '};' seguido de ponto e vírgula.",
                                    "Opcionalmente, adicione 'typedef struct NomeStruct NomeStruct;' para uso como tipo."
                                  ],
                                  "verification": "Revise linha por linha e compare com um exemplo modelo para matching exato.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código com syntax highlighting (VS Code, Code::Blocks)"
                                  ],
                                  "tips": "Indente campos dentro das chaves para melhorar a legibilidade.",
                                  "learningObjective": "Construir uma declaração sintaticamente correta e comentada.",
                                  "commonMistakes": [
                                    "Faltar ';' após cada campo ou no final do struct.",
                                    "Misturar tipos compostos em vez de escalares."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a declaração em um programa",
                                  "subSteps": [
                                    "Crie um arquivo .c/.cpp com a declaração e uma variável: 'struct Nome s1;'.",
                                    "Inicialize campos: 'strcpy(s1.nome, \"João\"); s1.idade = 20;' (inclua headers necessários).",
                                    "Compile com 'gcc arquivo.c -o teste -std=c99 -Wall' (ou g++ para C++).",
                                    "Corrija erros/warnings reportados pelo compilador.",
                                    "Execute o programa e acesse um campo para confirmar (ex.: printf)."
                                  ],
                                  "verification": "Compilação e execução bem-sucedidas sem erros ou warnings.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador GCC/Clang",
                                    "Terminal ou IDE com build integrado"
                                  ],
                                  "tips": "Inclua #include <stdio.h>, <string.h>, <stdbool.h> conforme necessário.",
                                  "learningObjective": "Confirmar funcionalidade prática da declaração.",
                                  "commonMistakes": [
                                    "Esquecer headers para bool ou strcpy.",
                                    "Não inicializar arrays de char corretamente."
                                  ]
                                }
                              ],
                              "practicalExample": "struct Aluno {\n    char nome[50];\n    int idade;\n    float nota1, nota2;\n    bool aprovado;\n}; // Exemplo para registro de aluno com tipos escalares variados.",
                              "finalVerifications": [
                                "A declaração inicia com 'struct' e termina com ';' após '}'.",
                                "Todos os campos usam tipos escalares válidos (char[], int, float, bool).",
                                "Há pelo menos 4 campos com variedade de tipos.",
                                "Nomes de struct e campos são descritivos e seguem convenções.",
                                "Compilação de um programa de teste sem erros.",
                                "Comentários explicam cada campo."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática completa (40%)",
                                "Variedade e adequação de tipos escalares (20%)",
                                "Nomenclatura clara e consistente (15%)",
                                "Presença de comentários úteis (10%)",
                                "Compilação e teste bem-sucedidos (10%)",
                                "Estrutura legível com indentação (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de tipos numéricos (int, float) para cálculos precisos.",
                                "Língua Portuguesa: Nomeação descritiva de campos para clareza semântica.",
                                "Banco de Dados: Modelagem de registros similar a tabelas relacionais.",
                                "Administração: Representação de entidades como clientes ou produtos."
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento escolar ou empresariais, declarações de struct organizam dados de alunos ou funcionários (nome, ID, salário), permitindo armazenamento eficiente em memória e processamento em loops para relatórios ou cálculos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.6.2.2",
                            "name": "Declarar variáveis de tipo registro",
                            "description": "Instanciar variáveis ou arrays de registros após a definição do tipo, como 'struct Aluno a1;' ou 'struct Aluno turma[30];'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição do tipo registro (struct)",
                                  "subSteps": [
                                    "Analise um exemplo de struct já definido, como 'struct Aluno { int id; char nome[50]; float nota; };'.",
                                    "Identifique os componentes: nome do struct, campos e tipos de dados.",
                                    "Explique verbalmente ou anote o propósito de cada campo no contexto do exemplo.",
                                    "Compile um código simples com apenas a definição do struct para verificar sintaxe.",
                                    "Registre dúvidas sobre tipos compostos versus primitivos."
                                  ],
                                  "verification": "O struct compila sem erros e você pode listar todos os campos corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto (VS Code), compilador C (GCC), terminal.",
                                  "tips": "Sempre termine o struct com ponto e vírgula (;).",
                                  "learningObjective": "Entender a estrutura prévia necessária para declarar variáveis de registro.",
                                  "commonMistakes": "Esquecer o ponto e vírgula após a definição do struct ou usar chaves incorretas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma variável simples de tipo registro",
                                  "subSteps": [
                                    "Escreva a declaração: 'struct Aluno a1;' após a definição do struct.",
                                    "Posicione a declaração dentro da função main() ou em escopo global.",
                                    "Acesse um campo para testar: 'a1.id = 1;'.",
                                    "Compile e execute o código para verificar se a variável é reconhecida.",
                                    "Imprima um valor: 'printf(\"%d\", a1.id);' para confirmar."
                                  ],
                                  "verification": "O código compila e executa sem erros, acessando campos da variável.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto, compilador C, exemplos de código de structs.",
                                  "tips": "Use o nome completo 'struct Nome' até C11; em C moderno, typedef pode simplificar.",
                                  "learningObjective": "Dominar a sintaxe para instanciar uma única variável de struct.",
                                  "commonMistakes": "Declarar sem o 'struct' prefixo ou confundir com definição do tipo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar um array de variáveis de tipo registro",
                                  "subSteps": [
                                    "Escreva: 'struct Aluno turma[30];' para um array fixo.",
                                    "Acesse elementos: 'turma[0].id = 1; turma[1].nota = 8.5;'.",
                                    "Crie um loop para inicializar múltiplos elementos.",
                                    "Compile e teste com printf em índices diferentes.",
                                    "Experimente tamanhos variados, como [5] ou [100]."
                                  ],
                                  "verification": "Array compila, acessos por índice funcionam e loop inicializa corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto, compilador C, debugger opcional (GDB).",
                                  "tips": "Lembre-se que arrays de struct alocam memória para todos os elementos de uma vez.",
                                  "learningObjective": "Aprender a declarar e manipular coleções de registros.",
                                  "commonMistakes": "Esquecer colchetes [] ou acessar índice inválido causando segfault."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e debugar declarações de variáveis de registro",
                                  "subSteps": [
                                    "Crie um programa completo gerenciando 3 alunos em array.",
                                    "Inclua entrada de dados com scanf para campos.",
                                    "Adicione validações básicas (ex: nota entre 0-10).",
                                    "Teste cenários de erro: declaração duplicada ou fora de escopo.",
                                    "Refatore para usar typedef struct para simplificação."
                                  ],
                                  "verification": "Programa executa interativamente, gerencia dados corretamente sem crashes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto, compilador C, exemplos online de structs em C.",
                                  "tips": "Use gdb para debugar acessos inválidos em arrays.",
                                  "learningObjective": "Consolidar o uso prático de variáveis de registro em cenários reais.",
                                  "commonMistakes": "Não inicializar campos antes de usar, levando a lixo em memória."
                                }
                              ],
                              "practicalExample": "Exemplo completo em C:\n#include <stdio.h>\nstruct Aluno {\n    int id;\n    char nome[50];\n    float nota;\n};\nint main() {\n    struct Aluno a1;\n    struct Aluno turma[3];\n    a1.id = 1;\n    strcpy(a1.nome, \"Joao\");\n    a1.nota = 9.5;\n    turma[0].id = 2;\n    printf(\"Aluno: %s, Nota: %.1f\\n\", a1.nome, a1.nota);\n    return 0;\n}",
                              "finalVerifications": [
                                "Declaração de variável simples compila e acessa campos.",
                                "Array de structs inicializa múltiplos elementos via loop.",
                                "Programa gerencia pelo menos 5 registros sem erros de memória.",
                                "Uso de typedef simplifica declarações corretamente.",
                                "Debug de erros comuns (ex: índice inválido) é resolvido.",
                                "Código é legível com comentários explicando declarações."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa: uso correto de 'struct Nome var;' e 'struct Nome arr[N];'.",
                                "Manipulação correta de campos e índices de array.",
                                "Compilação e execução sem warnings ou erros.",
                                "Inicialização explícita de campos para evitar lixo.",
                                "Aplicação em contexto prático com entrada/saída.",
                                "Identificação e correção de 3 erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores e matrizes como arrays de structs.",
                                "Banco de Dados: Registros semelhantes a tuplas ou linhas em tabelas.",
                                "Algoritmos: Estruturas para grafos ou árvores.",
                                "Física/Engenharia: Modelagem de objetos com propriedades compostas."
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento escolar, declarar arrays de structs Aluno para armazenar turmas inteiras, permitindo cálculos de médias, relatórios e buscas eficientes sem bancos de dados complexos inicialmente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.6.2.3",
                            "name": "Inicializar registros",
                            "description": "Atribuir valores iniciais aos campos de um registro na declaração ou via atribuição, como 'struct Aluno a1 = {\"João\", 20, 8.5};'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e praticar inicialização na declaração com lista de valores",
                                  "subSteps": [
                                    "Defina um struct simples, como 'struct Aluno { char nome[50]; int idade; float nota; };'",
                                    "Declare uma variável do tipo struct e inicialize na mesma linha usando chaves: 'struct Aluno a1 = {\"João\", 20, 8.5};'",
                                    "Compile o código em um ambiente C (como GCC) e verifique se não há erros de sintaxe",
                                    "Adicione um printf para exibir os valores e execute o programa",
                                    "Teste alterando os valores e observe o impacto na saída"
                                  ],
                                  "verification": "O programa compila sem erros e imprime os valores corretos atribuídos",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C (GCC ou online como Replit)",
                                    "Editor de texto (VS Code)"
                                  ],
                                  "tips": "Lembre-se de que a ordem dos valores nas chaves deve corresponder exatamente à ordem dos campos no struct",
                                  "learningObjective": "Dominar a sintaxe de inicialização posicional na declaração de structs",
                                  "commonMistakes": [
                                    "Esquecer as chaves {} ou vírgulas entre valores",
                                    "Ordem incorreta dos campos",
                                    "Tipos de dados incompatíveis (ex: string em vez de int)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar campos nomeados explicitamente na declaração",
                                  "subSteps": [
                                    "Reutilize o struct Aluno e declare: 'struct Aluno a2 = {.nome = \"Maria\", .idade = 22, .nota = 9.0};'",
                                    "Note o uso do ponto (.) para nomear cada campo antes do valor",
                                    "Compile e execute com printf para verificar os valores",
                                    "Teste inicializando apenas alguns campos e veja o comportamento dos não inicializados (zero ou lixo)",
                                    "Experimente reordenar os campos nomeados para confirmar independência da ordem"
                                  ],
                                  "verification": "Todos os campos nomeados recebem valores corretos, independentemente da ordem",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo compilador e editor do step anterior",
                                    "Documentação C sobre designated initializers"
                                  ],
                                  "tips": "Use inicializadores designados para structs complexos, pois evitam erros de ordem",
                                  "learningObjective": "Aprender inicialização designada para maior clareza e flexibilidade",
                                  "commonMistakes": [
                                    "Esquecer o ponto antes do nome do campo",
                                    "Usar aspas em campos numéricos",
                                    "Inicializar campo inexistente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar registros via atribuição após a declaração",
                                  "subSteps": [
                                    "Declare o struct sem inicializar: 'struct Aluno a3;'",
                                    "Atribua valores campo por campo: 'strcpy(a3.nome, \"Pedro\"); a3.idade = 19; a3.nota = 7.5;'",
                                    "Para strings, use strcpy do <string.h>; inclua a biblioteca necessária",
                                    "Compile, execute e imprima para verificar",
                                    "Teste atribuição em funções ou loops para simular uso dinâmico"
                                  ],
                                  "verification": "Valores são atribuídos corretamente após declaração e exibidos sem erros",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca <string.h> para strcpy",
                                    "Compilador C"
                                  ],
                                  "tips": "Para arrays char (strings), use strcpy ou funções seguras como strncpy para evitar overflow",
                                  "learningObjective": "Entender atribuição runtime para cenários dinâmicos",
                                  "commonMistakes": [
                                    "Atribuir string diretamente sem strcpy (ex: a3.nome = \"Pedro\";)",
                                    "Esquecer incluir <string.h>",
                                    "Overflow em arrays char"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, depurar e aplicar em um programa completo",
                                  "subSteps": [
                                    "Crie um programa com array de 3 structs Aluno, inicialize 2 na declaração e 1 via atribuição",
                                    "Adicione função para imprimir todos os alunos",
                                    "Introduza erros proposital (ex: ordem errada) e use gdb ou printf para depurar",
                                    "Teste cenários edge: structs aninhados ou com pointers",
                                    "Otimize o código comentando cada inicialização"
                                  ],
                                  "verification": "Programa executa corretamente com múltiplos registros inicializados de formas variadas",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Debugger como gdb",
                                    "Exemplos de código C com structs"
                                  ],
                                  "tips": "Sempre inicialize structs para evitar valores lixo; use memset para zeroar se necessário",
                                  "learningObjective": "Integrar inicializações em programas reais e depurar problemas comuns",
                                  "commonMistakes": [
                                    "Valores não inicializados levando a lixo na memória",
                                    "Erros de compilação em inicializações mistas",
                                    "Problemas com escopo de variáveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento escolar, declare 'struct Aluno alunos[100];' e inicialize o primeiro: 'alunos[0] = (struct Aluno){ \"Ana\", 21, 9.2 };'. Em seguida, atribua aos demais via loop lendo inputs do usuário, e imprima a lista completa.",
                              "finalVerifications": [
                                "Compilar e executar código com inicializações posicional, designada e por atribuição sem erros",
                                "Imprimir valores corretos para todos os campos de pelo menos 3 registros diferentes",
                                "Identificar e corrigir 3 erros comuns introduzidos propositalmente",
                                "Explicar a diferença entre inicialização na declaração e por atribuição",
                                "Aplicar em um array de structs com sucesso",
                                "Usar strcpy corretamente para campos string"
                              ],
                              "assessmentCriteria": [
                                "Correção sintática em todas as formas de inicialização (100%)",
                                "Ordem e tipos de dados matching perfeitamente",
                                "Tratamento adequado de strings com strcpy ou inicializadores",
                                "Ausência de warnings de compilador",
                                "Capacidade de depuração rápida de erros comuns",
                                "Clareza no código com comentários explicativos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de tuplas e vetores multidimensionais",
                                "Banco de Dados: Registros como linhas em tabelas relacionais",
                                "Programação Orientada a Objetos: Inicialização de objetos e construtores",
                                "Engenharia de Software: Boas práticas em estruturas de dados compostas",
                                "Algoritmos: Uso de structs em listas ligadas ou árvores"
                              ],
                              "realWorldApplication": "Em aplicativos de RH para inicializar perfis de funcionários (nome, cargo, salário), jogos para stats de personagens, ou sistemas embarcados para configurações de sensores, garantindo dados válidos desde o início para evitar falhas em runtime."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.6.3",
                        "name": "Acesso e Manipulação de Campos",
                        "description": "Operações para ler, escrever e processar campos individuais dentro de instâncias de registros.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.6.3.1",
                            "name": "Acessar campos de um registro",
                            "description": "Usar o operador ponto (.) para acessar campos, como 'a1.idade = 21;' ou 'printf(\"%s\", a1.nome);'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar um tipo de registro (struct)",
                                  "subSteps": [
                                    "Estude a sintaxe básica de struct em C: 'struct Nome { tipo1 campo1; tipo2 campo2; };'",
                                    "Defina um struct simples para Pessoa com campos char nome[50] e int idade.",
                                    "Use typedef para criar um alias, ex: 'typedef struct Pessoa Pessoa;'",
                                    "Compile uma declaração isolada para verificar sintaxe."
                                  ],
                                  "verification": "O código de declaração compila sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Compilador GCC instalado"
                                  ],
                                  "tips": "Sempre termine a struct com ';' e agrupe campos relacionados logicamente.",
                                  "learningObjective": "Compreender a sintaxe para definir tipos de registros compostos.",
                                  "commonMistakes": [
                                    "Esquecer ';' após a chave '}'",
                                    "Misturar tipos de dados incompatíveis nos campos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar e inicializar uma instância do registro",
                                  "subSteps": [
                                    "Declare uma variável do tipo struct: 'Pessoa p1;'",
                                    "Inicialize os campos na declaração: 'Pessoa p1 = {\"João\", 25};'",
                                    "Atribua valores individualmente se necessário: 'strcpy(p1.nome, \"Maria\"); p1.idade = 30;'",
                                    "Teste compilação com inicialização."
                                  ],
                                  "verification": "Compilação bem-sucedida e inspeção manual dos valores atribuídos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador GCC",
                                    "Terminal para compilar (gcc arquivo.c -o saida)"
                                  ],
                                  "tips": "Use inicializadores designados para clareza: 'p1 = {.nome=\"João\", .idade=25};'",
                                  "learningObjective": "Saber criar e popular instâncias de registros com dados.",
                                  "commonMistakes": [
                                    "Esquecer incluir <string.h> para strcpy",
                                    "Inicializar array char sem aspas duplas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Acessar campos para leitura (ex: printf)",
                                  "subSteps": [
                                    "Use operador '.' para acessar: 'printf(\"Nome: %s\", p1.nome);'",
                                    "Combine múltiplos acessos: 'printf(\"%s tem %d anos\", p1.nome, p1.idade);'",
                                    "Adicione loops ou condições para múltiplas instâncias se aplicável.",
                                    "Execute e verifique saída no terminal."
                                  ],
                                  "verification": "Programa executa e imprime valores corretos dos campos acessados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador GCC",
                                    "Terminal"
                                  ],
                                  "tips": "Formato %s para strings e %d para int; evite buffer overflow em printf.",
                                  "learningObjective": "Aplicar operador '.' para ler e exibir campos de registros.",
                                  "commonMistakes": [
                                    "Usar vírgula ',' em vez de '.'",
                                    "Format specifier errado, ex: %d para string"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Acessar campos para escrita e modificação",
                                  "subSteps": [
                                    "Atribua novo valor: 'p1.idade = 26;'",
                                    "Modifique em funções ou condicionais: 'if(p1.idade > 18) p1.status = \"adulto\";'",
                                    "Combine leitura e escrita em um programa completo.",
                                    "Recompile, execute e confirme mudança na saída."
                                  ],
                                  "verification": "Valores modificados refletem corretamente em impressões subsequentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador GCC",
                                    "Terminal"
                                  ],
                                  "tips": "Sempre verifique limites de array ao atribuir strings.",
                                  "learningObjective": "Dominar atribuição e modificação de campos via operador '.'",
                                  "commonMistakes": [
                                    "Atribuir string sem strcpy ou formato correto",
                                    "Modificar sem ler primeiro para depuração"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Depurar e validar acessos em programa integrado",
                                  "subSteps": [
                                    "Crie um programa com array de structs e acesse via índice: 'pessoas[0].idade'",
                                    "Adicione validações: checar se campo não é nulo.",
                                    "Use gdb ou printf para debug se erros.",
                                    "Teste cenários de erro intencionalmente."
                                  ],
                                  "verification": "Programa lida com múltiplos registros sem crashes ou saídas erradas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador GCC",
                                    "Debugger gdb (opcional)"
                                  ],
                                  "tips": "Use const para campos que não devem ser modificados.",
                                  "learningObjective": "Integrar acessos em programas reais com depuração.",
                                  "commonMistakes": [
                                    "Acessar índice fora de bounds em arrays de structs",
                                    "Ignorar warnings do compilador sobre tipos"
                                  ]
                                }
                              ],
                              "practicalExample": "```c\n#include <stdio.h>\n#include <string.h>\ntypedef struct {\n    char nome[50];\n    int idade;\n} Pessoa;\n\nint main() {\n    Pessoa p1 = {\"João\", 21};\n    printf(\"%s tem %d anos.\\n\", p1.nome, p1.idade);\n    p1.idade = 22;\n    strcpy(p1.nome, \"João Silva\");\n    printf(\"Agora %s tem %d anos.\\n\", p1.nome, p1.idade);\n    return 0;\n}\n```\nSaída esperada: João tem 21 anos.\nAgora João Silva tem 22 anos.",
                              "finalVerifications": [
                                "Programa compila sem erros ou warnings.",
                                "Saídas de printf mostram valores corretos de leitura e após modificação.",
                                "Nenhuma violação de memória (valgrind limpo se disponível).",
                                "Múltiplos acessos em loop ou array funcionam.",
                                "Depuração revela valores esperados nos campos."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta do operador '.' em todos acessos.",
                                "Inicialização e atribuição sem erros de tipo.",
                                "Uso apropriado de format specifiers em printf.",
                                "Manipulação segura de strings (com strcpy ou inicializadores).",
                                "Programa executável demonstra leitura e escrita independentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Registros como tuplas ou vetores nomeados para dados compostos.",
                                "Física: Modelar objetos com atributos como posição.x e velocidade.y.",
                                "Banco de Dados: Campos de registros semelhantes a colunas em tabelas relacionais.",
                                "Língua Portuguesa: Campos como substantivos descritivos em modelagem de entidades."
                              ],
                              "realWorldApplication": "Em sistemas de RH, acessar e atualizar campos como 'funcionario.salario' ou 'cliente.endereco.rua' em softwares empresariais, jogos (jogador.vida) ou apps de e-commerce (produto.preco)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.6.3.2",
                            "name": "Passar registros como parâmetros",
                            "description": "Transmitir instâncias de registros para funções por valor ou referência, compreendendo cópia vs. modificação original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Passagem de Parâmetros",
                                  "subSteps": [
                                    "Defina o que é um parâmetro em funções e a diferença entre argumentos e parâmetros.",
                                    "Explique passagem por valor: o argumento é copiado para o parâmetro local.",
                                    "Explique passagem por referência: o parâmetro recebe o endereço da memória do argumento.",
                                    "Discuta implicações para tipos primitivos vs. compostos como registros.",
                                    "Identifique quando usar cada tipo de passagem."
                                  ],
                                  "verification": "Resuma em suas palavras a diferença entre passagem por valor e por referência, com um diagrama simples de pilha de memória.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de linguagem (ex: C ou Pascal), editor de texto para diagramas.",
                                  "tips": "Use diagramas de memória para visualizar cópias vs. referências.",
                                  "learningObjective": "Compreender os fundamentos teóricos de passagem de parâmetros.",
                                  "commonMistakes": "Confundir passagem por valor com cópia profunda em todos os casos; ignorar overhead de cópia para registros grandes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Passagem por Valor de Registros",
                                  "subSteps": [
                                    "Defina um registro simples (ex: struct Pessoa { nome, idade }).",
                                    "Crie uma função que receba o registro por valor e modifique seus campos.",
                                    "Chame a função com uma instância e observe que o original não muda.",
                                    "Meça o tamanho do registro e discuta custo de cópia.",
                                    "Teste com registro maior para ver impacto na performance."
                                  ],
                                  "verification": "Execute o código e confirme que o registro original permanece inalterado após a chamada da função.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE com compilador (ex: GCC para C, Free Pascal), exemplos de código iniciais.",
                                  "tips": "Compile com flags de otimização off para observar cópias reais.",
                                  "learningObjective": "Implementar e verificar passagem por valor, entendendo isolamento de modificações.",
                                  "commonMistakes": "Esquecer de inicializar o registro antes da passagem; assumir que valor significa 'sem cópia'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Passagem por Referência de Registros",
                                  "subSteps": [
                                    "Modifique a função para receber ponteiro ou referência ao registro.",
                                    "Crie uma instância, passe por referência e modifique campos dentro da função.",
                                    "Verifique que alterações persistem no registro original.",
                                    "Trate casos de ponteiro nulo para evitar crashes.",
                                    "Compare tempos de execução com passagem por valor para registros grandes."
                                  ],
                                  "verification": "Execute e confirme que modificações na função afetam o original; teste com ponteiro inválido e corrija.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesma IDE e compilador; debugger para inspecionar memória.",
                                  "tips": "Sempre verifique se o ponteiro é não-nulo antes de dereferenciar.",
                                  "learningObjective": "Dominar passagem por referência para modificações eficientes em registros.",
                                  "commonMistakes": "Dereferenciar ponteiro nulo; confundir sintaxe de ponteiro (*) com referência (& em C++)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar, Contrastar e Praticar Cenários Mistos",
                                  "subSteps": [
                                    "Crie funções mistas: uma por valor (leitura) e uma por referência (escrita).",
                                    "Analise cenários onde cópia é aceitável vs. quando referência é obrigatória.",
                                    "Implemente um programa completo que use ambas para manipular múltiplos registros.",
                                    "Profile performance: copie 1000 registros grandes por valor vs. referência.",
                                    "Refatore código para otimizar baseado na análise."
                                  ],
                                  "verification": "Programa roda corretamente, com modificações apenas onde intencional; relatório de performance mostra eficiência da referência.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "IDE com profiler simples (ex: time em terminal), múltiplos arquivos de teste.",
                                  "tips": "Use arrays de registros para testes de escala.",
                                  "learningObjective": "Aplicar conhecimentos em contextos reais, escolhendo o método correto.",
                                  "commonMistakes": "Usar referência quando cópia é mais segura (ex: funções puras); ignorar overhead de cópia em loops."
                                }
                              ],
                              "practicalExample": "Defina struct Pessoa { char nome[50]; int idade; }. Função por valor: void imprimir(Pessoa p) { printf(\"%s tem %d\", p.nome, p.idade); } – original intacto. Função por ref: void envelhecer(Pessoa *p) { p->idade++; } – original envelhece após chamada. Programa principal cria Pessoa joao = {\"Joao\", 25}; imprimir(joao); envelhecer(&joao); imprimir(joao); // saída: Joao 25, Joao 26.",
                              "finalVerifications": [
                                "Explica verbalmente ou por escrito a diferença entre cópia e modificação original.",
                                "Implementa função por valor sem alterar original.",
                                "Implementa função por referência que altera original corretamente.",
                                "Identifica e corrige código com ponteiro nulo.",
                                "Compara performance em exemplo com registro > 1KB.",
                                "Refatora código para usar método apropriado por cenário."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% correto em definições de valor vs. referência.",
                                "Correção de código: Compila e executa sem erros ou crashes.",
                                "Compreensão prática: Modificações ocorrem apenas como esperado.",
                                "Eficiência: Escolhe referência para grandes registros ou modificações.",
                                "Análise: Relatório inclui diagramas e métricas de performance.",
                                "Robustez: Trata edge cases como nulos ou registros vazios."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Memória: Relaciona com alocação dinâmica e ponteiros.",
                                "Estruturas de Dados: Aplicável a listas ligadas ou árvores usando nós como registros.",
                                "Programação Orientada a Objetos: Paralelo com passagem de objetos por referência.",
                                "Análise de Algoritmos: Impacto na complexidade temporal por cópias.",
                                "Engenharia de Software: Boas práticas em APIs e interfaces."
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento de banco de dados, passar registros de clientes por referência para funções de atualização evita cópias desnecessárias de dados grandes, otimizando performance em aplicações como ERPs ou jogos onde entidades (personagens) são modificadas frequentemente sem duplicar memória."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.6.3.3",
                            "name": "Copiar e comparar registros",
                            "description": "Realizar atribuição entre registros compatíveis e usar estruturas condicionais para comparar campos específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e declarar registros compatíveis",
                                  "subSteps": [
                                    "Estude a definição de registros em linguagens como Pascal ou Ada.",
                                    "Identifique os tipos de campos compatíveis para atribuição (mesma estrutura).",
                                    "Declare dois registros com estruturas idênticas ou compatíveis.",
                                    "Inicialize os registros com valores de exemplo.",
                                    "Verifique a sintaxe de declaração no compilador."
                                  ],
                                  "verification": "Compile o código de declaração sem erros e exiba os valores iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (ex: Free Pascal), documentação de registros da linguagem.",
                                  "tips": "Sempre use o mesmo tipo para registros a serem copiados para evitar erros de tipo.",
                                  "learningObjective": "Compreender compatibilidade de registros para atribuição segura.",
                                  "commonMistakes": "Declarar registros com campos de tipos diferentes; esquecer ponto e vírgula."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar atribuição (cópia) entre registros",
                                  "subSteps": [
                                    "Escreva uma instrução de atribuição simples: reg2 := reg1;.",
                                    "Teste a cópia exibindo campos antes e depois.",
                                    "Copie registros parcialmente, atribuindo campo por campo se necessário.",
                                    "Use loops para copiar arrays dentro de registros.",
                                    "Compile e execute para validar a cópia."
                                  ],
                                  "verification": "Os valores de reg2 devem ser idênticos aos de reg1 após atribuição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador de Pascal/Ada, exemplos de código de registros.",
                                  "tips": "Atribuição copia todo o registro de uma vez, não por referência.",
                                  "learningObjective": "Dominar a sintaxe e efeito da atribuição de registros inteiros.",
                                  "commonMistakes": "Confundir atribuição com comparação (usar = em vez de :=); não inicializar antes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar campos específicos com estruturas condicionais",
                                  "subSteps": [
                                    "Acesse campos individuais: if reg1.nome = reg2.nome then ...",
                                    "Use operadores lógicos (and, or) para múltiplas comparações.",
                                    "Implemente if-then-else para ações baseadas em comparações.",
                                    "Teste casos: iguais, diferentes, nulos.",
                                    "Adicione saída para relatar resultados da comparação."
                                  ],
                                  "verification": "O programa executa ações corretas baseadas em comparações verdadeiras/falsas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, debugger para rastrear condicionais.",
                                  "tips": "Compare strings com aspas duplas e números diretamente.",
                                  "learningObjective": "Aplicar condicionais para validação seletiva de campos de registros.",
                                  "commonMistakes": "Esquecer ponto e vírgula após condicionais; comparar tipos incompatíveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar cópia e comparação em um programa completo",
                                  "subSteps": [
                                    "Crie um programa que leia dois registros, copie um, altere campos e compare.",
                                    "Adicione validação: copiar apenas se compatíveis.",
                                    "Implemente função para comparar registros personalizada.",
                                    "Teste com dados variados (válidos e inválidos).",
                                    "Documente o código com comentários."
                                  ],
                                  "verification": "Programa compila, executa e produz saídas corretas para todos testes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Compilador completo, conjunto de testes de entrada.",
                                  "tips": "Use writeln para debug durante desenvolvimento.",
                                  "learningObjective": "Combinar atribuição e condicionais em fluxos de manipulação de dados.",
                                  "commonMistakes": "Não tratar casos edge como campos vazios; loops infinitos em validações."
                                }
                              ],
                              "practicalExample": "Em um sistema de gerenciamento de alunos, declare registros 'Aluno' com campos nome, idade, nota. Copie dados de aluno1 para aluno2 com aluno2 := aluno1;. Depois, compare if aluno1.nota > aluno2.nota then writeln('Nota maior'); para validar atualizações.",
                              "finalVerifications": [
                                "Registros são copiados integralmente sem perda de dados.",
                                "Comparações de campos produzem resultados booleanos corretos.",
                                "Programa lida com registros compatíveis e rejeita incompatíveis.",
                                "Saídas refletem estados antes/depois da cópia e comparação.",
                                "Nenhum erro de compilação ou runtime em testes variados.",
                                "Código está comentado e indentado corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe de atribuição e acesso a campos (100%).",
                                "Correção lógica das condicionais em comparações (90-100%).",
                                "Cobertura de subpassos em cada step (completo/incompleto).",
                                "Eficiência do código (sem redundâncias).",
                                "Qualidade dos testes e verificações incluídas.",
                                "Clareza e documentação do programa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica booleana em condicionais.",
                                "Banco de Dados: Validação e duplicação de registros em SQL.",
                                "Algoritmos: Estruturas de decisão e fluxo de controle."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usado para duplicar objetos de dados em validação de formulários, sincronização de perfis de usuário ou detecção de duplicatas em sistemas de CRM."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Subprogramação",
                "description": "Discute funções, passagem de parâmetros por valor e referência, escopo de variáveis e recursividade.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Funções",
                    "description": "Definição, declaração, chamada e retorno de funções em programação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Definição e Propósito de Funções",
                        "description": "Compreender o conceito fundamental de funções como subprogramas modulares que encapsulam lógica específica, promovem reutilização de código, facilitam a manutenção e organizam o programa em partes menores e independentes.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Identificar o que é uma função",
                            "description": "Explicar a definição de função como um bloco de código nomeado que executa uma tarefa específica, recebe entradas opcionais (parâmetros) e pode produzir uma saída (valor de retorno), diferenciando-a de comandos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender comandos simples versus blocos de código",
                                  "subSteps": [
                                    "Leia a definição de um comando simples: uma instrução única que executa uma ação imediata, como 'print(\"Olá\")'.",
                                    "Compare com um bloco de código: um grupo de instruções agrupadas para uma tarefa maior.",
                                    "Escreva 3 exemplos de comandos simples em pseudocódigo ou Python.",
                                    "Discuta por que blocos reutilizáveis são úteis em programação.",
                                    "Identifique em um código curto quais linhas são comandos simples."
                                  ],
                                  "verification": "Liste 3 comandos simples e explique por que não são blocos reutilizáveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto ou online como Replit; exemplos de código impressos.",
                                  "tips": "Sempre pergunte: 'Essa instrução pode ser reutilizada múltiplas vezes?'",
                                  "learningObjective": "Diferenciar comandos simples de blocos de código nomeados.",
                                  "commonMistakes": "Confundir loops ou condicionais com funções; eles são estruturas de controle, não blocos nomeados reutilizáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a definição formal de uma função",
                                  "subSteps": [
                                    "Estude a definição: 'Função é um bloco de código nomeado que executa uma tarefa específica, recebe entradas opcionais (parâmetros) e pode produzir saída (retorno)'.",
                                    "Anote os 4 elementos chave: nome, parâmetros (opcionais), corpo (tarefa), retorno (opcional).",
                                    "Compare função com procedimento: procedimento não retorna valor.",
                                    "Crie um fluxograma simples de como uma função é chamada e executada.",
                                    "Repita a definição em suas próprias palavras 3 vezes."
                                  ],
                                  "verification": "Explique a definição de função oralmente ou por escrito sem olhar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta para fluxograma; vídeo tutorial curto sobre funções (ex: Python functions intro).",
                                  "tips": "Pense em função como uma 'máquina' que recebe insumos, processa e devolve produto.",
                                  "learningObjective": "Memorizar e internalizar a definição precisa de uma função.",
                                  "commonMistakes": "Achar que toda função deve ter parâmetros ou retorno; ambos são opcionais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar componentes de uma função em exemplos",
                                  "subSteps": [
                                    "Examine código exemplo: def soma(a, b): return a + b",
                                    "Identifique: nome ('soma'), parâmetros ('a, b'), corpo ('return a + b'), retorno ('a + b').",
                                    "Modifique o exemplo: crie versão sem parâmetros (constante) e sem retorno (apenas print).",
                                    "Chame a função em código e observe execução.",
                                    "Compare com comando simples equivalente: print(2 + 3)."
                                  ],
                                  "verification": "Desmonte um exemplo de função em seus 4 componentes principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor Python online (Replit ou CodePen); 3 exemplos de funções variadas.",
                                  "tips": "Use print() dentro da função para debugar e ver o fluxo.",
                                  "learningObjective": "Reconhecer os componentes estruturais de uma função em código.",
                                  "commonMistakes": "Ignorar indentação no corpo da função; ela define o escopo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação de funções em códigos reais",
                                  "subSteps": [
                                    "Analise um programa com múltiplas funções e comandos misturados.",
                                    "Marque todas as funções e justifique: nome, chamada, parâmetros usados.",
                                    "Diferencie de outras estruturas: loops (for/while), condicionais (if).",
                                    "Crie um quiz pessoal: 'É função? Por quê?' para 5 trechos de código.",
                                    "Explique vantagens de usar funções em vez de repetir comandos."
                                  ],
                                  "verification": "Identifique corretamente 5 funções em um código de 20 linhas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Códigos de exemplo (um script simples de calculadora); marcador virtual.",
                                  "tips": "Procure por 'def' (Python) ou 'function' (JS) como palavra-chave inicial.",
                                  "learningObjective": "Identificar funções autonomamente em qualquer código.",
                                  "commonMistakes": "Confundir métodos de objetos ou classes com funções puras."
                                }
                              ],
                              "practicalExample": "Em Python: def calcular_idade(ano_nascimento, ano_atual): return ano_atual - ano_nascimento. Chamada: idade = calcular_idade(1990, 2023) → 33. Isso é função: nomeada, parâmetros opcionais, executa tarefa (subtrair), retorna valor; vs. comando simples: print(2023 - 1990).",
                              "finalVerifications": [
                                "Explica a definição de função sem hesitação.",
                                "Identifica corretamente funções em código desconhecido.",
                                "Diferencia funções de comandos, loops e condicionais.",
                                "Cria um exemplo simples de função com parâmetros e retorno.",
                                "Descreve o fluxo de execução de uma função chamada.",
                                "Lista vantagens de funções sobre código repetitivo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (nome, parâmetros, corpo, retorno).",
                                "Capacidade de diferenciar funções de outras estruturas.",
                                "Análise correta de componentes em exemplos.",
                                "Criatividade em exemplos práticos criados.",
                                "Compreensão de reutilização e modularidade.",
                                "Identificação em códigos complexos sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções matemáticas f(x) = 2x + 1 como analogia.",
                                "Língua Portuguesa: Definições e estruturas textuais modulares.",
                                "Física: Modelos de sistemas com entradas/saídas (ex: máquinas simples).",
                                "Artes: Composição modular em design (funções como blocos reutilizáveis)."
                              ],
                              "realWorldApplication": "Em apps como Instagram, funções processam likes (entrada: post ID, saída: contador atualizado); em jogos, funções calculam scores; em bancos, funções validam transações, permitindo código limpo, reutilizável e manutenção fácil em equipes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Reconhecer benefícios das funções",
                            "description": "Listar e descrever vantagens como modularidade, reutilização de código, redução de redundância, facilidade de depuração e abstração de detalhes complexos em programação procedimental.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os principais benefícios das funções",
                                  "subSteps": [
                                    "Revise a definição de funções em programação procedimental.",
                                    "Liste os cinco benefícios principais: modularidade, reutilização de código, redução de redundância, facilidade de depuração e abstração de detalhes complexos.",
                                    "Pesquise brevemente em documentação ou tutoriais online cada benefício.",
                                    "Anote uma frase curta explicando cada um.",
                                    "Discuta com um colega ou anote dúvidas iniciais."
                                  ],
                                  "verification": "Verifique se a lista contém todos os cinco benefícios com definições breves corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou caderno",
                                    "Acesso à internet para documentação de programação (ex: Python docs)"
                                  ],
                                  "tips": "Comece pela modularidade, pois ela conecta aos outros benefícios.",
                                  "learningObjective": "Reconhecer e nomear os cinco benefícios principais das funções.",
                                  "commonMistakes": [
                                    "Confundir reutilização com redução de redundância",
                                    "Ignorar abstração como benefício chave"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar modularidade e reutilização de código",
                                  "subSteps": [
                                    "Escreva um exemplo simples de código sem funções (ex: imprimir 'Olá' 5 vezes diretamente).",
                                    "Refatore o código criando uma função print_hello().",
                                    "Reutilize a função em diferentes contextos (ex: com parâmetros).",
                                    "Compare o comprimento e legibilidade dos dois códigos.",
                                    "Explique como isso promove modularidade."
                                  ],
                                  "verification": "Execute ambos os códigos e confirme que a versão com função é mais curta e reutilizável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, IDLE Python)",
                                    "Interpretador Python ou similar"
                                  ],
                                  "tips": "Use funções com parâmetros para demonstrar flexibilidade real.",
                                  "learningObjective": "Compreender como funções promovem modularidade e reutilização através de exemplos práticos.",
                                  "commonMistakes": [
                                    "Não testar a reutilização em múltiplos cenários",
                                    "Manter código rígido sem parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar redução de redundância e facilidade de depuração",
                                  "subSteps": [
                                    "Crie um programa monolítico que calcula áreas de retângulo e triângulo com código repetido.",
                                    "Refatore criando funções area_retangulo() e area_triangulo().",
                                    "Introduza um erro intencional no código monolítico e depure.",
                                    "Repita no código com funções e compare o tempo/esforço.",
                                    "Descreva como funções reduzem redundância e facilitam correções localizadas."
                                  ],
                                  "verification": "Corrija erros em ambas versões e meça o tempo gasto na depuração.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Interpretador de programação procedimental (Python/C)"
                                  ],
                                  "tips": "Escolha erros comuns como divisão por zero para simular depuração real.",
                                  "learningObjective": "Demonstrar empiricamente a redução de redundância e melhoria na depuração com funções.",
                                  "commonMistakes": [
                                    "Não quantificar o tempo de depuração",
                                    "Ignorar impacto da redundância em manutenção futura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender abstração e sintetizar todos os benefícios",
                                  "subSteps": [
                                    "Estude um exemplo complexo: função para ordenação de lista vs implementação inline.",
                                    "Explique como a função abstrai detalhes (ex: algoritmo de bubble sort).",
                                    "Crie um mapa mental conectando todos os cinco benefícios.",
                                    "Escreva um parágrafo resumindo por que usar funções em projetos reais.",
                                    "Autoavalie sua compreensão respondendo perguntas de verificação."
                                  ],
                                  "verification": "O mapa mental inclui todos os benefícios com setas de conexão lógicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de mind mapping (ex: papel, Draw.io)",
                                    "Exemplos de código avançados"
                                  ],
                                  "tips": "Pense em abstração como 'caixa preta' que esconde complexidade.",
                                  "learningObjective": "Sintetizar todos os benefícios, enfatizando abstração para programação escalável.",
                                  "commonMistakes": [
                                    "Subestimar abstração como mero 'nome bonito'",
                                    "Não conectar benefícios em um todo coeso"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa para gerenciar estoque de uma loja: sem funções, repita código para adicionar/verificar itens de 3 produtos; com funções (ex: adicionar_item(), verificar_estoque()), reutilize para 10 produtos, facilitando depuração de um bug em adicionar_item() sem afetar o resto.",
                              "finalVerifications": [
                                "Liste e defina corretamente os 5 benefícios principais.",
                                "Forneça um exemplo de código antes/depois para pelo menos 2 benefícios.",
                                "Explique em 1 minuto verbalmente os ganhos em depuração.",
                                "Identifique redundância em um código fornecido e sugira refatoração.",
                                "Crie um mapa mental conectando benefícios a cenários reais.",
                                "Responda quiz com 90% de acerto sobre vantagens."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na lista de benefícios (mínimo 5/5).",
                                "Qualidade dos exemplos práticos (código executável e comparativo).",
                                "Profundidade nas explicações (uso de termos técnicos corretos).",
                                "Capacidade de síntese (conexões entre benefícios evidentes).",
                                "Criatividade em aplicações reais (além de exemplos básicos).",
                                "Autoavaliação reflexiva demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com funções matemáticas f(x) para abstração.",
                                "Língua Portuguesa: Modularidade similar a parágrafos em redações.",
                                "Ciências: Experimentos modulares como hipóteses isoladas.",
                                "Artes: Composição modular em designs gráficos.",
                                "Educação Financeira: Reutilização como otimização de recursos."
                              ],
                              "realWorldApplication": "Em projetos como desenvolvimento de apps bancários, funções em bibliotecas (ex: funções de criptografia reutilizáveis) reduzem erros em transações globais, facilitam atualizações rápidas e abstraem complexidades de segurança para equipes multidisciplinares."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Diferenciar funções de procedimentos",
                            "description": "Comparar funções (com retorno de valor) e procedimentos (sem retorno explícito), identificando cenários de uso em linguagens como C++ ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Definições Básicas de Funções e Procedimentos",
                                  "subSteps": [
                                    "Leia a definição de função: um subprograma que executa uma tarefa e retorna um valor para o chamador.",
                                    "Leia a definição de procedimento: um subprograma que executa uma tarefa mas não retorna um valor explícito (pode usar saída por referência ou efeitos colaterais).",
                                    "Compare com exemplos simples em pseudocódigo: função soma(a, b) retorna a+b; procedimento imprime(msg) exibe msg.",
                                    "Anote as palavras-chave em linguagens: Python 'def func():' com 'return'; C++ 'int func(){return x;}' vs 'void proc(){}'.",
                                    "Liste 3 exemplos cotidianos: função como calculadora de IMC (retorna valor), procedimento como exibir relatório."
                                  ],
                                  "verification": "Escreva definições próprias em um documento e compare com referências oficiais de Python/C++ docs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Python/C++",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use analogias: função é como uma máquina que produz e entrega um produto; procedimento é uma ação que altera o ambiente.",
                                  "learningObjective": "Definir com precisão funções e procedimentos, distinguindo seu propósito fundamental.",
                                  "commonMistakes": [
                                    "Confundir 'void' em C++ com ausência de função; achar que print() em Python é função por retornar None implicitamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Diferenças Chave entre Funções e Procedimentos",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para assinatura (retorno vs void), uso de return, composição (funções podem chamar funções).",
                                    "Analise sintaxe: em Python, funções sempre podem retornar; procedimentos simulados com None. Em C++, void functions.",
                                    "Discuta efeitos colaterais: procedimentos modificam estado global; funções puras evitam isso.",
                                    "Teste em playground online: escreva uma função que retorna soma e um procedimento que imprime soma.",
                                    "Registre 5 diferenças principais: retorno de valor, reutilização em expressões, teste unitário mais fácil em funções."
                                  ],
                                  "verification": "Preencha tabela comparativa e execute códigos de teste sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Replit ou IDE online para Python/C++",
                                    "Planilha ou papel para tabela"
                                  ],
                                  "tips": "Lembre: funções são composíveis como blocos Lego; procedimentos são comandos imperativos.",
                                  "learningObjective": "Comparar estrutural e semanticamente funções vs procedimentos em múltiplas linguagens.",
                                  "commonMistakes": [
                                    "Ignorar que funções podem ter efeitos colaterais; supor que todos procedimentos são 'void functions'."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos Práticos em C++ e Python",
                                  "subSteps": [
                                    "Escreva em Python: def multiply(a,b): return a*b; def greet(name): print('Olá', name).",
                                    "Escreva em C++: int multiply(int a, int b){return a*b;} void greet(string name){cout<<\"Olá \"<<name;}.",
                                    "Chame-os: resultado = multiply(2,3); greet('Alice'); note que greet não atribui valor.",
                                    "Modifique: torne greet uma função retornando string; observe mudança no uso.",
                                    "Debugue erros comuns: esquecer return em função (undefined behavior em C++)."
                                  ],
                                  "verification": "Execute códigos em ambos linguagens e capture saídas/erros em screenshots.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C++ online (Godbolt)",
                                    "Python interpreter (Replit)"
                                  ],
                                  "tips": "Sempre compile/teste incrementalmente; use print/debug para rastrear fluxos.",
                                  "learningObjective": "Implementar e executar exemplos concretos, validando diferenças na prática.",
                                  "commonMistakes": [
                                    "Não importar <iostream> em C++; esquecer dois pontos em Python def."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar Cenários de Uso Apropriados",
                                  "subSteps": [
                                    "Liste cenários para funções: cálculos reutilizáveis (ex: validar email), transformações de dados.",
                                    "Liste cenários para procedimentos: I/O (print, salvar arquivo), atualizações de UI, logging.",
                                    "Analise código legado: refatore um procedimento com return para função se possível.",
                                    "Crie fluxograma: quando usar função (precisa valor?) vs procedimento (ação pura?).",
                                    "Debata prós/contras: funções facilitam testes e pipelines; procedimentos para side-effects necessários."
                                  ],
                                  "verification": "Classifique 5 subprogramas de um código exemplo como função ou procedimento com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código open-source (GitHub)",
                                    "Ferramenta de fluxograma (Draw.io)"
                                  ],
                                  "tips": "Prefira funções para pureza funcional; use procedimentos só quando inevitável.",
                                  "learningObjective": "Selecionar o tipo correto baseado em requisitos de retorno e efeitos.",
                                  "commonMistakes": [
                                    "Usar função só para print (desperdício); procedimentos para computações puras."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de gerenciamento de estoque Python: def calcular_preco_total(itens): return sum(item.preco for item in itens)  # Função retorna valor para uso em relatórios. def atualizar_estoque(id_produto, nova_quantidade): estoque[id_produto] = nova_quantidade; salvar_banco()  # Procedimento altera estado sem retornar.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito 3 diferenças principais sem consultar notas.",
                                "Converter um procedimento simples em função e vice-versa, executando sem erros.",
                                "Identificar incorretamente classificado em código fornecido (ex: função sem return).",
                                "Criar novo exemplo híbrido usando ambos em um script funcional.",
                                "Discutir quando evitar procedimentos em programação funcional.",
                                "Passar quiz com 90% acerto sobre sintaxe/uso em Python e C++."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (80% match com docs oficiais).",
                                "Corretude na implementação de exemplos (códigos rodam sem erros).",
                                "Profundidade na tabela comparativa (cobrir sintaxe, semântica, uso).",
                                "Criatividade e relevância nos cenários de uso propostos.",
                                "Identificação de erros comuns em códigos de pares.",
                                "Clareza na comunicação de verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções como mapeamentos f(x) → y; procedimentos como algoritmos iterativos.",
                                "Lógica e Filosofia: Distinção entre proposições declarativas (funções) e imperativas (procedimentos).",
                                "Inglês Técnico: Vocabulário de programação (return, void, subroutine).",
                                "Design de Sistemas: Modularidade em engenharia de software.",
                                "Ética em Computação: Funções puras reduzem bugs em sistemas críticos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps: funções para APIs REST (retornam JSON); procedimentos para handlers de eventos UI (atualizam tela sem retornar). Em jogos, funções calculam física (velocidade); procedimentos renderizam gráficos."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Declaração e Definição de Funções",
                        "description": "Dominar a sintaxe para declarar e definir funções, incluindo assinatura (nome, parâmetros, tipo de retorno), corpo da função e escopo de variáveis locais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Escrever a declaração de uma função",
                            "description": "Construir a protótipo de função com sintaxe correta: tipo_retorno nome_função(tipo_param1 nome_param1, ...); considerando passagem por valor e escopo local de variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral da declaração de função",
                                  "subSteps": [
                                    "Estude a sintaxe básica: tipo_retorno nome_função(parâmetros);",
                                    "Identifique os elementos principais: tipo de retorno, nome da função e lista de parâmetros.",
                                    "Revise conceitos de passagem por valor e escopo local de variáveis.",
                                    "Anote exemplos simples de declarações sem parâmetros.",
                                    "Compare declaração com definição de função."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os três componentes principais da declaração.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Documentação da linguagem C/C++, editor de texto simples.",
                                  "tips": "Use diagramas para visualizar a estrutura.",
                                  "learningObjective": "Reconhecer e descrever os componentes essenciais de uma declaração de função.",
                                  "commonMistakes": "Confundir declaração com definição (ausência de chaves {})."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o tipo de retorno e nome da função",
                                  "subSteps": [
                                    "Escolha o tipo de retorno apropriado (ex: int, void, double) baseado na funcionalidade.",
                                    "Crie um nome descritivo e seguindo convenções (camelCase ou snake_case).",
                                    "Verifique compatibilidade do tipo de retorno com o que a função deve produzir.",
                                    "Escreva apenas a parte 'tipo_retorno nome_função()'",
                                    "Teste mentalmente cenários de uso."
                                  ],
                                  "verification": "A parte inicial da declaração está correta e sem erros de sintaxe.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Folha de referência de tipos primitivos, exemplos de código.",
                                  "tips": "Nomeie funções com verbos para indicar ação (ex: calcularSoma).",
                                  "learningObjective": "Selecionar corretamente tipo de retorno e nome da função.",
                                  "commonMistakes": "Usar tipo incompatível (ex: retornar string com int)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar os parâmetros com tipos e nomes",
                                  "subSteps": [
                                    "Liste os parâmetros necessários: tipo_param nome_param.",
                                    "Considere passagem por valor (cópia) e declare múltiplos separados por vírgula.",
                                    "Garanta escopo local: parâmetros visíveis apenas dentro da função.",
                                    "Evite parâmetros desnecessários para manter simplicidade.",
                                    "Escreva a lista de parâmetros entre parênteses."
                                  ],
                                  "verification": "Todos parâmetros têm tipo e nome definidos corretamente.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Editor de código com realce de sintaxe, exemplos de funções com parâmetros.",
                                  "tips": "Use nomes de parâmetros descritivos (ex: int numero1, int numero2).",
                                  "learningObjective": "Construir lista de parâmetros considerando passagem por valor e escopo.",
                                  "commonMistakes": "Esquecer vírgulas entre parâmetros ou usar ponteiros sem necessidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e validar a declaração completa",
                                  "subSteps": [
                                    "Combine tipo_retorno, nome e parâmetros: tipo_retorno nome(tipo1 param1, tipo2 param2);",
                                    "Adicione ponto e vírgula no final.",
                                    "Compile ou valide sintaxe em um compilador online.",
                                    "Teste com variações (sem parâmetros, múltiplos).",
                                    "Documente a declaração com comentário explicativo."
                                  ],
                                  "verification": "A declaração compila sem erros em um ambiente de teste.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Compilador online (ex: Replit, OnlineGDB), exemplos resolvidos.",
                                  "tips": "Sempre termine com ';' e use parênteses vazios se sem parâmetros.",
                                  "learningObjective": "Produzir uma declaração de função sintaticamente correta e funcional.",
                                  "commonMistakes": "Omitir parênteses ou ponto e vírgula."
                                }
                              ],
                              "practicalExample": "Para uma função que soma dois inteiros: int soma(int a, int b); // Declaração que retorna soma de a e b por valor.",
                              "finalVerifications": [
                                "A declaração compila sem erros de sintaxe.",
                                "Tipo de retorno corresponde ao esperado.",
                                "Parâmetros estão corretamente tipados e nomeados.",
                                "Passagem por valor é respeitada (sem ponteiros desnecessários).",
                                "Escopo local é considerado (sem referências externas).",
                                "Comentário explica o propósito da função."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática (100% dos elementos presentes).",
                                "Apropriação do tipo de retorno (compatível com funcionalidade).",
                                "Precisão nos parâmetros (tipos e nomes adequados).",
                                "Uso correto de convenções de nomenclatura.",
                                "Validação por compilação ou análise estática.",
                                "Clareza na documentação inline."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tipos de dados e precisão numérica.",
                                "Lógica: Definição de entradas/saídas como em fluxogramas.",
                                "Português: Nomenclatura descritiva e comentários claros.",
                                "Física/Engenharia: Modelagem de funções em sistemas modulares."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, declarações de funções são usadas em headers (.h) para bibliotecas modulares, permitindo reutilização de código em projetos como calculadoras, jogos ou sistemas empresariais, promovendo programação limpa e colaborativa."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Implementar o corpo de uma função",
                            "description": "Definir o bloco de código da função com chaves {}, incluindo comandos de atribuição, condicionais e variáveis locais, respeitando o escopo e inicialização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o início do corpo da função com chaves de abertura",
                                  "subSteps": [
                                    "Após a assinatura da função (nome e parâmetros), insira a chave de abertura '{'.",
                                    "Planeje a estrutura interna: identifique variáveis locais necessárias, comandos de atribuição e condicionais.",
                                    "Verifique a indentação para melhorar a legibilidade do código.",
                                    "Confirme que não há código fora do escopo da função.",
                                    "Salve o arquivo temporariamente para testar sintaxe básica."
                                  ],
                                  "verification": "O editor destaca corretamente a abertura do bloco sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Documentação da linguagem de programação"
                                  ],
                                  "tips": "Use indentação consistente (2-4 espaços) para facilitar a leitura.",
                                  "learningObjective": "Compreender o delimitador inicial do corpo da função e planejar sua estrutura.",
                                  "commonMistakes": [
                                    "Esquecer a chave '{', causando erro de sintaxe",
                                    "Misturar código global com local"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e inicializar variáveis locais dentro do escopo",
                                  "subSteps": [
                                    "Declare variáveis com 'let' ou 'const' (evite 'var' para escopo moderno).",
                                    "Inicialize-as com valores padrão ou baseados em parâmetros.",
                                    "Posicione as declarações logo após a abertura '{' para clareza.",
                                    "Teste acessando a variável em uma linha simples de atribuição.",
                                    "Verifique se a variável não é acessível fora da função."
                                  ],
                                  "verification": "Console.log da variável exibe valor correto apenas dentro da função.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console do navegador ou terminal"
                                  ],
                                  "tips": "Sempre inicialize para evitar 'undefined' em condicionais.",
                                  "learningObjective": "Dominar declaração e inicialização de variáveis no escopo local.",
                                  "commonMistakes": [
                                    "Declarar sem inicializar, levando a NaN ou undefined",
                                    "Usar escopo global acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar comandos de atribuição e estruturas condicionais",
                                  "subSteps": [
                                    "Adicione comandos de atribuição para processar dados (ex: total = a + b).",
                                    "Insira condicionais 'if/else' para lógica ramificada, com chaves para blocos internos.",
                                    "Combine atribuições dentro de condicionais para fluxos complexos.",
                                    "Use operadores lógicos (&&, ||) para condições precisas.",
                                    "Execute o código passo a passo com debugger para validar lógica."
                                  ],
                                  "verification": "Testes unitários mostram saídas corretas para entradas variadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor com debugger",
                                    "Ferramenta de testes (ex: Jest para JS)"
                                  ],
                                  "tips": "Mantenha condicionais simples; divida em funções se complexo.",
                                  "learningObjective": "Construir lógica interna com atribuições e condicionais respeitando escopo.",
                                  "commonMistakes": [
                                    "Esquecer chaves em condicionais multi-linha",
                                    "Atribuição em vez de comparação (== vs =)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar o corpo com chave de fechamento e retorno",
                                  "subSteps": [
                                    "Adicione 'return' com o valor final processado.",
                                    "Insira a chave de fechamento '}' alinhada com a abertura.",
                                    "Verifique balanceamento de todas as chaves com o editor.",
                                    "Teste chamadas da função com diferentes parâmetros.",
                                    "Refatore para remover código morto ou redundante."
                                  ],
                                  "verification": "Função retorna valor esperado sem erros de 'missing }'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de teste"
                                  ],
                                  "tips": "Coloque return no final para evitar saídas prematuras.",
                                  "learningObjective": "Completar o corpo garantindo integridade e retorno correto.",
                                  "commonMistakes": [
                                    "Esquecer 'return', função retorna undefined",
                                    "Chaves desbalanceadas"
                                  ]
                                }
                              ],
                              "practicalExample": "function calcularDesconto(preco, percentual) {\n  let desconto = 0;\n  if (percentual > 0 && percentual <= 100) {\n    desconto = preco * (percentual / 100);\n  }\n  return preco - desconto;\n}\n// Teste: calcularDesconto(100, 20) deve retornar 80",
                              "finalVerifications": [
                                "O corpo está delimitado corretamente por {} balanceados.",
                                "Todas variáveis são locais e inicializadas.",
                                "Condicionais e atribuições executam sem erros de escopo.",
                                "Função retorna valor esperado em testes variados.",
                                "Código é legível com indentação adequada.",
                                "Não há vazamento de variáveis para escopo global."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta sem erros de compilação/execução.",
                                "Respeito total ao escopo local das variáveis.",
                                "Lógica condicional funciona para casos positivos e negativos.",
                                "Eficiência: sem variáveis ou comandos desnecessários.",
                                "Legibilidade: indentação e nomes claros.",
                                "Robustez: trata casos edge (ex: parâmetros inválidos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Expressões aritméticas e operadores lógicos.",
                                "Lógica: Fluxogramas e estruturas de decisão.",
                                "Resolução de Problemas: Decomposição em passos sequenciais.",
                                "Algoritmos: Sequência de comandos em sub-rotinas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de aplicativos web (JavaScript), como funções para calcular descontos em e-commerces, validar formulários ou processar dados de usuários em sistemas empresariais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1",
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Declarar funções com parâmetros",
                            "description": "Especificar parâmetros com tipos escalares, passagem por valor (cópia) versus por referência (alias), e entender impacto no escopo e modificação de argumentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Passagem de Parâmetros por Valor (Cópia)",
                                  "subSteps": [
                                    "Defina passagem por valor: o argumento é copiado para o parâmetro da função, criando uma variável local independente.",
                                    "Escreva uma declaração simples de função com parâmetros escalares por valor, ex: int soma(int a, int b).",
                                    "Teste modificando o parâmetro dentro da função e verifique que o argumento original permanece inalterado.",
                                    "Discuta tipos escalares suportados (int, float, char, etc.) e o impacto na memória (cópia consome espaço).",
                                    "Compare com variáveis globais para reforçar escopo local."
                                  ],
                                  "verification": "Chame a função com variáveis e imprima valores antes/depois; confirme que originais não mudam.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Compilador C++ (g++)",
                                    "Documentação de tipos escalares"
                                  ],
                                  "tips": "Use printf ou cout para depuração visual de valores.",
                                  "learningObjective": "Explicar e demonstrar como passagem por valor isola modificações no escopo da função.",
                                  "commonMistakes": [
                                    "Achar que modificações afetam o chamador",
                                    "Esquecer de declarar tipos nos parâmetros",
                                    "Usar ponteiros desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Passagem de Parâmetros por Referência (Alias)",
                                  "subSteps": [
                                    "Defina passagem por referência: o parâmetro é um alias para o argumento, usando & em C++.",
                                    "Declare função com referência, ex: void incrementa(int& x).",
                                    "Teste modificando o parâmetro e confirme que o argumento original é alterado.",
                                    "Explique impacto no escopo: referência acessa memória do chamador diretamente.",
                                    "Discuta quando usar (evitar cópias desnecessárias para structs grandes, mas cuidado com escalares)."
                                  ],
                                  "verification": "Execute função de incremento e verifique mudança no argumento original via print.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador C++",
                                    "Exemplos de código de referência online"
                                  ],
                                  "tips": "Sempre passe referências const quando não modificar (void func(const int& x)).",
                                  "learningObjective": "Demonstrar como referências permitem modificações diretas sem cópia.",
                                  "commonMistakes": [
                                    "Omitir & na declaração",
                                    "Confundir com ponteiros (*)",
                                    "Modificar acidentalmente variáveis indesejadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar Funções com Parâmetros Mistos e Analisar Impactos",
                                  "subSteps": [
                                    "Declare função com params por valor e referência misturados, ex: void troca(int a, int& b).",
                                    "Implemente corpo da função testando modificações seletivas.",
                                    "Analise escopo: params por valor são locais, por ref compartilham com chamador.",
                                    "Meça performance básica: compile e compare tempos com grandes dados (simule com loops).",
                                    "Escreva overloads para diferentes tipos escalares (int, double)."
                                  ],
                                  "verification": "Compile e rode testes unitários mostrando trocas corretas apenas via ref.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador C++ com flags -O2 para otimização",
                                    "Ferramenta de timing (chrono)",
                                    "Templates de testes"
                                  ],
                                  "tips": "Nomeie params descritivamente para evitar confusão entre valor e ref.",
                                  "learningObjective": "Criar declarações híbridas e prever comportamentos de modificação/escopo.",
                                  "commonMistakes": [
                                    "Passar todos por ref desnecessariamente",
                                    "Erros de compilação por mismatch de tipos",
                                    "Ignorar overhead de cópia em loops"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Refinar Declarações com Exemplos Práticos",
                                  "subSteps": [
                                    "Crie função realista: ex: void ajustaVelocidade(double velocidade, double& aceleracao).",
                                    "Teste cenários: modificação só via ref, escopo isolado para valor.",
                                    "Refatore código com erros comuns e corrija.",
                                    "Documente assinatura da função com comentários sobre passagem.",
                                    "Compile em modo debug e inspecione memória (opcional com gdb)."
                                  ],
                                  "verification": "Escreva main() chamando função 3x com asserts para valores esperados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Debugger (gdb ou IDE)",
                                    "Exemplos de código comentados"
                                  ],
                                  "tips": "Use static_assert para verificações em tempo de compilação.",
                                  "learningObjective": "Aplicar conhecimentos para declarações robustas e depuráveis.",
                                  "commonMistakes": [
                                    "Retornar refs locais (dangling)",
                                    "Passar arrays como escalares",
                                    "Esquecer inicializações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C++: void swap(int& a, int& b) { int temp = a; a = b; b = temp; } int x=5, y=10; swap(x,y); // Agora x=10, y=5. Compare com por valor: void swap_valor(int a, int b) { ... } // Não altera x,y.",
                              "finalVerifications": [
                                "Declara função com params por valor sem erros de compilação.",
                                "Declara e usa ref (&) corretamente, alterando argumentos originais.",
                                "Explica diferença de escopo e modificação em entrevista simulada.",
                                "Implementa função mista e passa todos testes unitários.",
                                "Identifica quando usar valor vs ref baseado em performance/segurança.",
                                "Refatora código legado adicionando refs para eficiência."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: tipos, & onde necessário (100%).",
                                "Comportamento semântico: mods só via ref (testes passam).",
                                "Eficiência: evita cópias desnecessárias em escalares grandes.",
                                "Clareza: comentários explicam escolhas de passagem.",
                                "Robustez: lida com edge cases (zero, negativos).",
                                "Escalabilidade: funciona com múltiplos params/tipos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com funções matemáticas f(x) onde x é cópia ou alias.",
                                "Lógica/Algoritmos: Entender fluxos de dados em grafos de dependência.",
                                "Física/Engenharia: Modelar sistemas dinâmicos modificando estados via ref.",
                                "Design de Software: Princípios SOLID (Single Responsibility via params).",
                                "Análise de Dados: Passagem eficiente em funções de processamento."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (Unity/C++), passe posição de inimigo por ref para updates eficientes sem cópias; em apps financeiros, calcule juros por valor para isolar testes sem alterar balanços reais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Chamada e Retorno de Funções",
                        "description": "Aprender a invocar funções corretamente e gerenciar o retorno de valores, incluindo integração em expressões e tratamento de fluxos de execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Realizar chamada de função",
                            "description": "Invocar função com argumentos compatíveis: nome_função(arg1, arg2); diferenciando argumentos posicionais e nomeados, e verificando correspondência com parâmetros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes de uma chamada de função",
                                  "subSteps": [
                                    "Analisar a sintaxe básica de uma chamada: nome_função(arg1, arg2)",
                                    "Identificar o nome da função e os parênteses obrigatórios",
                                    "Diferenciar parâmetros (definidos na função) de argumentos (passados na chamada)",
                                    "Estudar exemplos de definições de funções simples",
                                    "Explicar a importância da ordem e compatibilidade dos argumentos"
                                  ],
                                  "verification": "Descrever por escrito os componentes de uma chamada de função exemplo, distinguindo parâmetros e argumentos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: Replit ou VS Code)",
                                    "Documentação de Python sobre funções"
                                  ],
                                  "tips": "Sempre consulte a definição da função antes de chamá-la para entender os parâmetros esperados.",
                                  "learningObjective": "Reconhecer e nomear corretamente os elementos essenciais de uma chamada de função.",
                                  "commonMistakes": [
                                    "Confundir parâmetros com argumentos",
                                    "Omitir parênteses após o nome da função",
                                    "Ignorar a ordem dos argumentos posicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar chamadas com argumentos posicionais",
                                  "subSteps": [
                                    "Definir uma função simples com 2-3 parâmetros posicionais (ex: def soma(a, b): return a + b)",
                                    "Chamar a função passando argumentos na ordem exata dos parâmetros",
                                    "Executar a chamada com valores numéricos e strings diferentes",
                                    "Verificar o resultado impresso ou retornado",
                                    "Modificar argumentos e observar mudanças no output"
                                  ],
                                  "verification": "Executar 3 chamadas posicionais corretas sem erros e registrar os resultados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente de programação Python interativo (ex: Jupyter Notebook)",
                                    "Funções de exemplo pré-definidas"
                                  ],
                                  "tips": "Lembre-se: a ordem importa! O primeiro argumento vai para o primeiro parâmetro.",
                                  "learningObjective": "Invocar funções usando argumentos posicionais de forma precisa e ordenada.",
                                  "commonMistakes": [
                                    "Passar argumentos na ordem errada",
                                    "Usar tipo incompatível (ex: string em soma numérica)",
                                    "Esquecer vírgulas entre argumentos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Utilizar argumentos nomeados (keyword arguments)",
                                  "subSteps": [
                                    "Revisar a sintaxe: nome_função(arg1=valor1, arg2=valor2)",
                                    "Definir uma função com parâmetros opcionais ou obrigatórios",
                                    "Chamar usando nomes explícitos, ignorando a ordem posicional",
                                    "Misturar argumentos posicionais e nomeados (posicionais primeiro)",
                                    "Testar com valores default se disponíveis"
                                  ],
                                  "verification": "Executar 4 chamadas com argumentos nomeados, incluindo mistura, e confirmar saídas corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código com depurador",
                                    "Exemplos de funções com defaults (ex: print(sep=',')]"
                                  ],
                                  "tips": "Argumentos nomeados facilitam a legibilidade em funções com muitos parâmetros.",
                                  "learningObjective": "Aplicar argumentos nomeados para maior flexibilidade e clareza nas chamadas.",
                                  "commonMistakes": [
                                    "Usar nomes inexistentes para parâmetros",
                                    "Colocar argumentos nomeados antes de posicionais",
                                    "Repetir um argumento posicional e nomeado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar correspondência e praticar chamadas completas",
                                  "subSteps": [
                                    "Comparar assinatura da função (parâmetros, tipos) com argumentos passados",
                                    "Identificar e corrigir erros comuns como TypeError ou SyntaxError",
                                    "Criar um script com múltiplas funções e chamadas variadas",
                                    "Executar e debugar chamadas mistas (posicionais + nomeados)",
                                    "Documentar uma chamada correta com verificação de retorno"
                                  ],
                                  "verification": "Criar e executar um programa com 5 chamadas variadas sem erros, salvando o código funcional.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ambiente Python completo",
                                    "Lista de funções built-in como len(), max()"
                                  ],
                                  "tips": "Use print() ou debugger para inspecionar valores durante a execução.",
                                  "learningObjective": "Validar compatibilidade de argumentos e debugar chamadas de funções de forma autônoma.",
                                  "commonMistakes": [
                                    "Número incorreto de argumentos",
                                    "Tipos incompatíveis causando exceções",
                                    "Esquecer de capturar o valor de retorno"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina def calcular_media(nome, nota1, nota2, peso1=1, peso2=1): return f'{nome}: {(nota1*peso1 + nota2*peso2)/(peso1+peso2)}'\nChamadas: calcular_media('Ana', 8, 9); calcular_media('João', nota1=7, nota2=9, peso2=2); calcular_media(nome='Pedro', 6, 10, peso1=0.5). Todas executam sem erros e retornam médias corretas.",
                              "finalVerifications": [
                                "Todas as chamadas executam sem erros de sintaxe ou runtime",
                                "Argumentos correspondem em número, ordem/tipo e nomes aos parâmetros",
                                "Resultados das funções atendem ao esperado (verificar com print ou asserts)",
                                "Código é legível, com chamadas mistas posicionais e nomeadas",
                                "Retorno da função é utilizado corretamente (ex: atribuído a variável)",
                                "Nenhum erro de TypeError ou NameError relacionado a argumentos"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta da chamada (parênteses, vírgulas, nomes)",
                                "Compatibilidade total de argumentos com parâmetros (tipo, quantidade)",
                                "Uso apropriado de posicionais vs. nomeados conforme contexto",
                                "Execução bem-sucedida com resultados precisos",
                                "Capacidade de debugar e corrigir mismatches",
                                "Clareza e documentação no código de exemplo"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com funções matemáticas f(x, y) = x + y",
                                "Lógica e Raciocínio: Verificação de pré-condições e correspondências",
                                "Língua Portuguesa/Inglês: Leitura de documentação técnica de funções",
                                "Resolução de Problemas: Debugging de erros em chamadas"
                              ],
                              "realWorldApplication": "No desenvolvimento de software, chamar funções de bibliotecas como math.sqrt(x) para cálculos, requests.get(url, params=dict) para APIs, ou funções personalizadas em projetos colaborativos, garantindo integração correta de módulos e evitando falhas em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Utilizar valor de retorno",
                            "description": "Atribuir ou usar diretamente o valor retornado em expressões, como variavel = nome_função(args); compreendendo que funções sem retorno implícito são void.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Valor de Retorno",
                                  "subSteps": [
                                    "Leia a definição: funções podem retornar um valor usando 'return' em linguagens como Python ou C.",
                                    "Analise exemplos simples: def soma(a, b): return a + b",
                                    "Identifique que funções sem 'return' explícito são void (None em Python).",
                                    "Compare com funções que imprimem apenas (sem retorno).",
                                    "Anote diferenças em um caderno."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que acontece quando uma função retorna um valor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code ou IDLE), documentação de Python sobre funções.",
                                  "tips": "Sempre procure por 'return' no código da função para confirmar se há valor retornado.",
                                  "learningObjective": "Diferenciar funções que retornam valores de funções void.",
                                  "commonMistakes": "Confundir impressão (print) com retorno de valor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Tipos de Funções em Código Existente",
                                  "subSteps": [
                                    "Abra exemplos de código com funções variadas.",
                                    "Marque funções com 'return' e sem.",
                                    "Execute funções void e observe que atribuí-las a variáveis resulta em None.",
                                    "Teste chamando funções com retorno e inspecione o tipo.",
                                    "Crie uma tabela resumindo 5 funções de exemplo."
                                  ],
                                  "verification": "Crie um relatório listando 3 funções com retorno e 2 void, com provas de execução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ambiente Python interativo (REPL ou Jupyter), códigos de exemplo.",
                                  "tips": "Use print(type(funcao())) para verificar o tipo retornado.",
                                  "learningObjective": "Reconhecer funções void vs. com retorno no código fonte.",
                                  "commonMistakes": "Assumir que toda função retorna algo útil."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atribuir Valores Retornados a Variáveis",
                                  "subSteps": [
                                    "Defina uma função simples que retorna um valor, ex: def quadrado(x): return x**2",
                                    "Chame: resultado = quadrado(4)",
                                    "Imprima e use 'resultado' em outras operações.",
                                    "Teste com funções void: var = imprimir_ola() e observe None.",
                                    "Repita com 3 funções diferentes."
                                  ],
                                  "verification": "Execute código e confirme que variáveis recebem valores corretos, não None.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, console Python.",
                                  "tips": "Sempre teste atribuindo e imprimindo imediatamente após a chamada.",
                                  "learningObjective": "Atribuir corretamente valores retornados a variáveis.",
                                  "commonMistakes": "Esquecer o '=' na atribuição ou chamar sem atribuir."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Usar Valores Retornados Diretamente em Expressões",
                                  "subSteps": [
                                    "Combine chamadas: print(soma(quadrado(3), 5))",
                                    "Crie expressões complexas: media = soma(a, b) / 2",
                                    "Teste encadeamento: if quadrado(x) > 10:",
                                    "Debug erros como usar void em expressões.",
                                    "Escreva um mini-programa usando 4 chamadas com retorno."
                                  ],
                                  "verification": "Código roda sem erros e produz saídas esperadas em expressões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, exemplos de funções matemáticas.",
                                  "tips": "Planeje o fluxo: retorno -> uso imediato -> próxima operação.",
                                  "learningObjective": "Integrar valores retornados em expressões e condicionais.",
                                  "commonMistakes": "Usar funções void em cálculos, causando TypeError."
                                }
                              ],
                              "practicalExample": "Defina def calcular_imc(peso, altura): return peso / (altura ** 2). Então: imc = calcular_imc(70, 1.75); if imc > 25: print('Sobrepeso'). Isso atribui o IMC e usa em uma condição para aconselhamento nutricional.",
                              "finalVerifications": [
                                "Atribui corretamente valor de função com retorno a uma variável.",
                                "Identifica e evita usar funções void em atribuições.",
                                "Usa retorno diretamente em expressões aritméticas.",
                                "Encadeia múltiplas chamadas de funções em uma linha.",
                                "Debuga erros como 'NoneType' em operações.",
                                "Explica diferença entre print e return em testes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na atribuição de retornos (sem perda de valor).",
                                "Correta identificação de funções void (100% acerto).",
                                "Uso fluido em expressões sem erros de tipo.",
                                "Código limpo e comentado demonstrando compreensão.",
                                "Solução de problemas em cenários com múltiplas funções.",
                                "Explicação clara do conceito em relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções como mapeamentos de entrada-saída.",
                                "Lógica: Condicionais baseadas em retornos booleanos.",
                                "Física: Cálculos de fórmulas com funções (ex: velocidade).",
                                "Estatística: Funções para médias e desvios."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, APIs como requests.get(url) retornam respostas HTTP; atribuir response.status_code verifica sucesso, permitindo automação de testes ou integrações em apps web."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Implementar instrução de retorno",
                            "description": "Usar return valor; no corpo da função para encerrar execução prematuramente e enviar resultado, garantindo compatibilidade com tipo declarado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o propósito da instrução return",
                                  "subSteps": [
                                    "Estude a definição de return: encerra a execução da função prematuramente e envia um valor de retorno.",
                                    "Compare com funções sem return early: execute até o final vs. saída imediata.",
                                    "Analise cenários onde return early é útil, como validação de entrada.",
                                    "Leia documentação da linguagem sobre fluxo de controle em funções.",
                                    "Discuta exemplos onde return evita código desnecessário."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que usar return early em uma função com condições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação da linguagem (ex: Python docs), editor de texto.",
                                  "tips": "Pense em return como 'sair da função agora com este resultado'.",
                                  "learningObjective": "Identificar quando e por que usar return para otimizar fluxo.",
                                  "commonMistakes": "Confundir return com break/continue, que afetam loops, não funções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a sintaxe da instrução return",
                                  "subSteps": [
                                    "Escreva a sintaxe básica: 'return valor;' dentro do corpo da função.",
                                    "Pratique return com tipos primitivos (int, string, bool).",
                                    "Teste return sem valor (None ou void em linguagens tipadas).",
                                    "Posicione return em diferentes locais: início, meio, fim da função.",
                                    "Compile/teste sintaxe inválida para ver erros comuns."
                                  ],
                                  "verification": "Escreva 3 exemplos de sintaxe correta e 2 incorretas, identificando erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code, PyCharm), interpretador/compilador.",
                                  "tips": "Sempre termine com ';' se a linguagem exigir (ex: C, Java).",
                                  "learningObjective": "Escrever sintaxe correta de return em qualquer posição da função.",
                                  "commonMistakes": "Esquecer ';' ou usar return fora de função."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar return prematuro em funções condicionais",
                                  "subSteps": [
                                    "Crie uma função simples com if/else que usa return early para validação.",
                                    "Exemplo: função que verifica se número é par; retorne early se ímpar.",
                                    "Adicione múltiplos returns em condições aninhadas.",
                                    "Refatore uma função sem return early para usar esta técnica.",
                                    "Execute a função com inputs variados para observar comportamento."
                                  ],
                                  "verification": "A função para de executar após o primeiro return e retorna valor correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, console para testes.",
                                  "tips": "Use return early para reduzir indentação e melhorar legibilidade.",
                                  "learningObjective": "Aplicar return para controlar fluxo em cenários reais.",
                                  "commonMistakes": "Colocar código após return que nunca executa, sem remover."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir compatibilidade com tipo declarado e testar",
                                  "subSteps": [
                                    "Defina assinatura da função com tipo de retorno explícito.",
                                    "Verifique que todos os returns retornem o tipo correto.",
                                    "Use type checking (ex: mypy em Python) ou compilador tipado.",
                                    "Escreva testes unitários para cobrir todos os paths de return.",
                                    "Depure erros de tipo e ajuste returns inconsistentes."
                                  ],
                                  "verification": "Testes passam e type checker aprova sem warnings.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramentas de type checking, framework de testes (unittest, pytest).",
                                  "tips": "Mantenha consistência: todos returns devem matching o tipo da assinatura.",
                                  "learningObjective": "Implementar funções tipadas seguras com returns corretos.",
                                  "commonMistakes": "Retornar tipo errado (ex: string em vez de int)."
                                }
                              ],
                              "practicalExample": "Defina def calcular_imc(peso: float, altura: float) -> float: if peso <= 0 or altura <= 0: return 0.0  # Retorno early para inválido return peso / (altura ** 2)  # Calcula IMC normal.",
                              "finalVerifications": [
                                "Função encerra prematuramente com return early em condições inválidas.",
                                "Todos os valores retornados são do tipo declarado na assinatura.",
                                "Testes unitários cobrem 100% dos paths de return.",
                                "Type checker/compilador aprova sem erros de tipo.",
                                "Código é legível, com indentação reduzida por returns early.",
                                "Execução com inputs variados produz saídas esperadas."
                              ],
                              "assessmentCriteria": [
                                "Correta sintaxe e posicionamento de todos os returns.",
                                "Compatibilidade total com tipo de retorno declarado.",
                                "Eficiência no fluxo: evita execução desnecessária.",
                                "Cobertura de testes para todos os cenários de return.",
                                "Ausência de código morto após returns.",
                                "Legibilidade e boas práticas de codificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de funções com domínios restritos via returns.",
                                "Lógica Computacional: Controle de fluxo com condicionais e saídas.",
                                "Engenharia de Software: Refatoração para código mais limpo.",
                                "Análise de Dados: Validação de inputs em funções de processamento."
                              ],
                              "realWorldApplication": "Em APIs web, use return early para validar autenticação ou parâmetros antes de processar requisições, evitando erros e melhorando performance em sistemas como e-commerces ou apps de delivery."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.4",
                            "name": "Aplicar recursividade básica",
                            "description": "Criar funções recursivas simples onde a função chama a si mesma, com caso base para evitar loops infinitos, como cálculo de fatorial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais da recursividade",
                                  "subSteps": [
                                    "Estude a definição de recursividade: uma função que chama a si mesma para resolver problemas menores.",
                                    "Identifique o 'caso base': condição que para a recursão para evitar loops infinitos.",
                                    "Analise a 'chamada recursiva': como a função invoca a si mesma com parâmetros reduzidos.",
                                    "Visualize a pilha de chamadas: desenhe como as chamadas se empilham e desempilham.",
                                    "Compare recursão com iteração: entenda quando usar cada uma."
                                  ],
                                  "verification": "Explique em suas palavras o que é recursão e desenhe o diagrama de pilha para fatorial(3).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Vídeos tutoriais sobre recursão (ex: Khan Academy)",
                                    "Papel e caneta para diagramas",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Comece com exemplos visuais como 'Russos em bonecas' para intuitar empilhamento.",
                                  "learningObjective": "Dominar os componentes essenciais da recursão: caso base e chamada recursiva.",
                                  "commonMistakes": [
                                    "Confundir recursão com loop infinito",
                                    "Esquecer o caso base",
                                    "Não reduzir o problema na chamada recursiva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar função recursiva para cálculo de fatorial",
                                  "subSteps": [
                                    "Defina a assinatura da função: def fatorial(n): em Python ou equivalente.",
                                    "Implemente o caso base: se n == 0 ou n == 1, retorne 1.",
                                    "Adicione a chamada recursiva: return n * fatorial(n-1).",
                                    "Teste manualmente com n=0,1,2 para validar.",
                                    "Adicione tratamento de erro para n negativo."
                                  ],
                                  "verification": "Execute a função para n=5 e confirme resultado 120.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Replit)",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Use print() dentro da função para rastrear chamadas recursivas.",
                                  "learningObjective": "Criar uma função recursiva funcional para fatorial com caso base correto.",
                                  "commonMistakes": [
                                    "Retornar n * fatorial(n) sem decrementar",
                                    "Caso base incorreto como if n <= 0",
                                    "Falta de indentação na recursão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar e debugar a função recursiva",
                                  "subSteps": [
                                    "Crie testes unitários para n=0 (1), n=1 (1), n=5 (120), n=10 (3628800).",
                                    "Use depurador para observar pilha de chamadas.",
                                    "Simule erro removendo caso base e observe stack overflow.",
                                    "Meça performance comparando com versão iterativa.",
                                    "Refatore para otimização simples se necessário (memoização básica)."
                                  ],
                                  "verification": "Todos os testes passam sem erros ou loops infinitos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramentas de teste (unittest em Python)",
                                    "Depurador do IDE"
                                  ],
                                  "tips": "Aumente n gradualmente para detectar problemas de profundidade.",
                                  "learningObjective": "Validar corretude e robustez da recursão através de testes.",
                                  "commonMistakes": [
                                    "Testar apenas valores pequenos",
                                    "Ignorar overflow para grandes n",
                                    "Não simular falhas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar recursividade em outro exemplo simples",
                                  "subSteps": [
                                    "Escolha exemplo: soma de 1 a n (caso base n=0 retorna 0; return n + soma(n-1)).",
                                    "Implemente a função seguindo o mesmo padrão do fatorial.",
                                    "Teste com valores variados e compare com fórmula matemática.",
                                    "Discuta limitações da recursão (profundidade de pilha).",
                                    "Reflita sobre quando preferir recursão vs iteração."
                                  ],
                                  "verification": "Função soma(5) retorna 15 corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Mesmo editor e interpretador do step 2"
                                  ],
                                  "tips": "Escolha problemas que se dividem naturalmente para praticar.",
                                  "learningObjective": "Generalizar o padrão recursivo para novos problemas.",
                                  "commonMistakes": [
                                    "Copiar código sem entender",
                                    "Não adaptar caso base",
                                    "Ignorar limites de recursão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\n```python\ndef fatorial(n):\n    if n <= 1:\n        return 1\n    return n * fatorial(n - 1)\n\nprint(fatorial(5))  # Saída: 120\n```\nEste código demonstra recursão com caso base (n <= 1) e chamada recursiva (n * fatorial(n-1)).",
                              "finalVerifications": [
                                "Função fatorial calcula corretamente para 0 ≤ n ≤ 10.",
                                "Não ocorre stack overflow para n=10.",
                                "Caso base é explicitamente implementado.",
                                "Chamada recursiva reduz o problema (n-1).",
                                "Testes unitários passam 100%.",
                                "Exemplo alternativo (soma) funciona corretamente."
                              ],
                              "assessmentCriteria": [
                                "Presença clara de caso base para evitar loops infinitos.",
                                "Chamada recursiva correta que progride para o caso base.",
                                "Código limpo, legível e comentado.",
                                "Testes abrangentes cobrindo casos edge.",
                                "Compreensão demonstrada via explicação ou diagrama.",
                                "Aplicação bem-sucedida em pelo menos um exemplo adicional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e indução matemática.",
                                "Lógica: Provas por indução e estruturas condicionais.",
                                "Física: Modelagem de fractais e sistemas recursivos naturais.",
                                "Artes: Padrões fractais em design gráfico."
                              ],
                              "realWorldApplication": "Recursão é usada em algoritmos de árvores (ex: busca em diretórios de arquivos), parsing de expressões matemáticas, geração de fractais em gráficos computacionais e jogos (labirintos), otimizando soluções em linguagens funcionais como Haskell."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.1",
                              "10.1.6.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Passagem de Parâmetros por Valor",
                    "description": "Mecanismo de cópia do valor dos argumentos para os parâmetros formais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Parâmetros Formais e Argumentos Atuais",
                        "description": "Distinção entre os parâmetros formais, declarados na definição da sub-rotina (função ou procedimento), e os argumentos atuais, fornecidos na chamada da sub-rotina, no contexto da passagem por valor.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Identificar parâmetros formais",
                            "description": "Reconhecer e listar os parâmetros formais em uma declaração de função ou procedimento em pseudocódigo ou linguagem procedimental simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de parâmetros formais",
                                  "subSteps": [
                                    "Defina parâmetros formais como as variáveis declaradas na cabeça da função ou procedimento.",
                                    "Compare com argumentos atuais, que são os valores passados na chamada.",
                                    "Leia exemplos simples de pseudocódigo para fixar a diferença.",
                                    "Anote a posição dos parâmetros formais na declaração.",
                                    "Discuta com um colega ou anote por que eles são 'placeholders'."
                                  ],
                                  "verification": "Explique em suas palavras o que são parâmetros formais e dê um exemplo simples.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de pseudocódigo impressos ou digitais"
                                  ],
                                  "tips": "Use analogia: parâmetros formais são como 'caixas vazias' rotuladas na função.",
                                  "learningObjective": "Compreender a definição e o papel dos parâmetros formais na subprogramação.",
                                  "commonMistakes": [
                                    "Confundir com argumentos atuais",
                                    "Ignorar a sintaxe da declaração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a sintaxe de declarações de funções e procedimentos",
                                  "subSteps": [
                                    "Identifique a palavra-chave de início (função, procedimento, def, etc.).",
                                    "Localize a cabeça da declaração (parte entre parênteses após o nome).",
                                    "Observe os separadores (vírgulas) entre parâmetros.",
                                    "Note tipos de dados se especificados (ex: inteiro a, real b).",
                                    "Destaque a posição exata dos parâmetros formais."
                                  ],
                                  "verification": "Marque em um exemplo impresso os parâmetros formais com highlighter.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de pseudocódigo variados",
                                    "Marcador ou editor de texto"
                                  ],
                                  "tips": "Sempre procure pelos parênteses após o nome da função – é ali que estão!",
                                  "learningObjective": "Reconhecer a estrutura sintática onde parâmetros formais aparecem.",
                                  "commonMistakes": [
                                    "Confundir corpo da função com cabeça",
                                    "Omitir parâmetros sem tipo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar identificação e listagem de parâmetros formais",
                                  "subSteps": [
                                    "Escolha 3-5 declarações de funções/procedimentos aleatórias.",
                                    "Liste os parâmetros formais em uma tabela: nome, tipo (se houver), ordem.",
                                    "Compare sua lista com uma chave de resposta.",
                                    "Repita com pseudocódigo mais complexo (múltiplos parâmetros).",
                                    "Escreva uma declaração simples e identifique seus próprios parâmetros."
                                  ],
                                  "verification": "Liste corretamente parâmetros de 5 exemplos sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de exercícios com 10 declarações",
                                    "Chave de respostas"
                                  ],
                                  "tips": "Ordene a lista exatamente como na declaração para evitar confusões.",
                                  "learningObjective": "Aplicar o reconhecimento para listar parâmetros de forma precisa.",
                                  "commonMistakes": [
                                    "Listar variáveis do corpo como parâmetros",
                                    "Trocar ordem dos parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar parâmetros formais de outros elementos e verificar",
                                  "subSteps": [
                                    "Compare declarações com e sem parâmetros.",
                                    "Identifique argumentos atuais em chamadas de função.",
                                    "Crie um fluxograma: declaração → parâmetros → chamada → argumentos.",
                                    "Teste com variações (parâmetros opcionais se aplicável).",
                                    "Autoavalie listagens anteriores corrigindo erros."
                                  ],
                                  "verification": "Diferencie corretamente em 3 pares de declaração/chamada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de chamadas de funções",
                                    "Fluxograma em branco"
                                  ],
                                  "tips": "Lembre: formais estão na definição, atuais na invocação.",
                                  "learningObjective": "Distinguir parâmetros formais de argumentos e outros elementos.",
                                  "commonMistakes": [
                                    "Misturar formais com retornos ou variáveis locais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em pseudocódigo: FUNÇÃO calcularArea(retangulo: forma, largura: real, altura: real) RETORNA real. Parâmetros formais: retangulo (forma), largura (real), altura (real). Na chamada: calcularArea(meuRet, 5.0, 3.0), os argumentos atuais são meuRet, 5.0, 3.0.",
                              "finalVerifications": [
                                "Lista todos os parâmetros formais de uma declaração complexa sem omissões.",
                                "Identifica corretamente tipos e ordem dos parâmetros.",
                                "Diferencia parâmetros formais de argumentos atuais em exemplos mistos.",
                                "Explica o papel dos parâmetros em uma chamada de função.",
                                "Aplica o conceito em pseudocódigo de linguagens procedimentais simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação (100% dos parâmetros listados corretamente).",
                                "Correta distinção entre formais e outros elementos (sem confusões).",
                                "Lista inclui ordem, nomes e tipos quando presentes.",
                                "Explicação conceitual clara e concisa.",
                                "Consistência em múltiplos exemplos variados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com funções matemáticas (ex: f(x,y)).",
                                "Língua Portuguesa: Análise sintática de estruturas declarativas.",
                                "Lógica: Entender placeholders em raciocínio formal.",
                                "Inglês Técnico: Vocabulário de programação (formal parameters)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, identificar parâmetros formais é essencial para entender APIs (ex: função fetch(url, options) no JavaScript), debugar erros de chamada e documentar funções em equipes, evitando falhas em sistemas como apps web ou jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Identificar argumentos atuais",
                            "description": "Analisar uma chamada de sub-rotina e identificar os argumentos atuais passados, associando-os aos parâmetros formais correspondentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e analisar a declaração da sub-rotina",
                                  "subSteps": [
                                    "Examine o código fonte para encontrar a declaração da procedure ou function (ex: 'procedure Nome(params);').",
                                    "Identifique o cabeçalho da sub-rotina, focando na lista de parâmetros formais entre parênteses.",
                                    "Liste os parâmetros formais em ordem, anotando nome, tipo e posição (ex: 1: a: integer, 2: b: real).",
                                    "Confirme o número total de parâmetros formais esperados.",
                                    "Anote se a passagem é por valor (varausência de 'var' antes dos params)."
                                  ],
                                  "verification": "Crie uma tabela com posição, nome e tipo de cada parâmetro formal; compare com o código original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Código fonte da sub-rotina, papel/caneta ou editor de texto para anotações.",
                                  "tips": "Sempre comece pela declaração mais próxima no escopo; ignore chamadas inicialmente.",
                                  "learningObjective": "Reconhecer e documentar precisamente os parâmetros formais de uma sub-rotina.",
                                  "commonMistakes": "Confundir parâmetros com variáveis locais; ignorar tipos ou ordem posicional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar todas as chamadas da sub-rotina no código",
                                  "subSteps": [
                                    "Procure por invocações do nome da sub-rotina no código principal ou em outras sub-rotinas.",
                                    "Marque cada linha de chamada (ex: Nome(5, 10.5);).",
                                    "Conte o número de argumentos passados em cada chamada.",
                                    "Verifique se o número de argumentos corresponde ao número de parâmetros formais.",
                                    "Ignore chamadas com sintaxe inválida para este exercício."
                                  ],
                                  "verification": "Liste todas as linhas de código com chamadas e o número de argumentos cada uma.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Código fonte completo, marcador de texto ou IDE com busca (Ctrl+F).",
                                  "tips": "Use busca por nome da sub-rotina; considere maiúsculas/minúsculas se aplicável.",
                                  "learningObjective": "Localizar eficientemente todas as ocorrências de chamadas de uma sub-rotina.",
                                  "commonMistakes": "Perder chamadas em blocos condicionais ou loops; confundir com outras sub-rotinas semelhantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair os argumentos atuais de uma chamada específica",
                                  "subSteps": [
                                    "Selecione uma chamada identificada (ex: Soma(5, 10.5);).",
                                    "Liste os argumentos na ordem de aparição, entre parênteses e separados por vírgulas.",
                                    "Anote o valor ou expressão de cada argumento (ex: arg1: 5 (constante inteira), arg2: 10.5 (constante real)).",
                                    "Identifique o tipo inferido de cada argumento.",
                                    "Verifique separadores e ausência de argumentos extras ou faltantes."
                                  ],
                                  "verification": "Escreva a lista numerada de argumentos com valores e tipos inferidos; cruze com a chamada original.",
                                  "estimatedTime": "7 minutos",
                                  "materials": "Linha de código da chamada selecionada, tabela de tipos da linguagem.",
                                  "tips": "Argumentos podem ser variáveis, constantes ou expressões; trate expressões como um todo.",
                                  "learningObjective": "Isolar e descrever com precisão os argumentos atuais em uma chamada.",
                                  "commonMistakes": "Interpretar vírgulas dentro de expressões como separadores de args; ignorar tipos dinâmicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Associar argumentos atuais aos parâmetros formais",
                                  "subSteps": [
                                    "Alinhe a lista de parâmetros formais com a lista de argumentos atuais por posição (1º arg -> 1º param).",
                                    "Crie um mapeamento: 'arg1 (5) -> param1 (a: integer)'.",
                                    "Verifique compatibilidade básica de tipos (ex: inteiro para inteiro em passagem por valor).",
                                    "Repita para todos os argumentos e anote mismatches potenciais.",
                                    "Documente o mapeamento completo em uma tabela."
                                  ],
                                  "verification": "Construa uma tabela de correspondência e valide contra código; simule execução mental.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Listas do Step 1 e 3, tabela para mapeamento.",
                                  "tips": "Associação é estritamente posicional em passagem por valor sem nomes nomeados.",
                                  "learningObjective": "Estabelecer correspondências precisas entre argumentos e parâmetros.",
                                  "commonMistakes": "Associar por nome em vez de posição; ignorar incompatibilidades de tipo."
                                }
                              ],
                              "practicalExample": "Considere o código em Pascal:\n\nprocedure Soma(a, b: integer);\nbegin\n  writeln(a + b);\nend;\n\nvar x: integer;\nbegin\n  x := 3;\n  Soma(x, 5);  // Chamada 1: args atuais = x (integer=3), 5 (integer)\n  Soma(10, 20); // Chamada 2: args atuais = 10 (integer), 20 (integer)\nend.\n\nParams formais: 1-a:integer, 2-b:integer.\nAssociações: Chamada1 arg1->a, arg2->b; mesma para Chamada2.",
                              "finalVerifications": [
                                "Liste corretamente todos os parâmetros formais com ordem e tipos.",
                                "Identifique todas as chamadas e seus argumentos atuais.",
                                "Mapeie precisamente cada argumento ao parâmetro correspondente por posição.",
                                "Detecte e explique qualquer incompatibilidade de número ou tipo de argumentos.",
                                "Simule o fluxo de valores na passagem por valor para uma chamada.",
                                "Documente o processo em tabela sem erros de transcrição."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de parâmetros formais (100% match com código).",
                                "Completude na localização de todas as chamadas (nenhuma omitida).",
                                "Correção no mapeamento posicional (sem inversões).",
                                "Análise de tipos inferidos e compatibilidade (acertividade >90%).",
                                "Clareza e organização da documentação (tabelas legíveis).",
                                "Detecção de potenciais erros de chamada (ex: número incorreto de args)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Correspondência biunívoca e funções (mapeamento 1:1).",
                                "Lógica: Análise sequencial e dedução por posição.",
                                "Linguagem Portuguesa: Interpretação precisa de sintaxe técnica.",
                                "Física/Engenharia: Modelagem de entradas/saídas em sistemas modulares."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, identificar argumentos atuais é crucial para depurar chamadas de funções em APIs (ex: chamar uma função de banco de dados com parâmetros errados causa falhas); essencial em equipes para revisar código e integrar módulos sem erros de passagem por valor."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Associar argumentos a parâmetros",
                            "description": "Mapear argumentos atuais aos parâmetros formais por posição ou nome em chamadas de funções, entendendo a preparação para passagem por valor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de parâmetros e argumentos",
                                  "subSteps": [
                                    "Ler definições: parâmetro formal é a variável na assinatura da função; argumento atual é o valor passado na chamada.",
                                    "Estudar passagem por valor: o argumento é copiado para o parâmetro, alterações no parâmetro não afetam o original.",
                                    "Analisar diagrama de fluxo: desenhar seta de argumento para parâmetro formal.",
                                    "Identificar exemplos simples em código: função com um parâmetro.",
                                    "Diferenciar em contexto de subprogramação."
                                  ],
                                  "verification": "Escrever definições em próprias palavras e desenhar um diagrama simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação da linguagem (ex: Python), papel e caneta ou ferramenta de diagramação"
                                  ],
                                  "tips": "Use analogia de 'caixa de correio': argumento é a carta enviada, parâmetro é a caixa que recebe a cópia.",
                                  "learningObjective": "Diferenciar parâmetro formal de argumento atual e explicar passagem por valor.",
                                  "commonMistakes": [
                                    "Confundir parâmetro formal com argumento atual; achar que passagem por valor altera o original."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar associação por posição",
                                  "subSteps": [
                                    "Criar função com 3 parâmetros: def soma(a, b, c): ...",
                                    "Chamar por ordem: soma(1, 2, 3) e observar mapeamento 1->a, 2->b, 3->c.",
                                    "Testar com tipos diferentes: soma('x', 5, True).",
                                    "Executar e imprimir valores dentro da função para verificar.",
                                    "Modificar ordem dos argumentos e observar erro."
                                  ],
                                  "verification": "Executar 3 chamadas corretas e 1 incorreta, explicando o erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Replit), interpretador Python"
                                  ],
                                  "tips": "Sempre conte a posição a partir de 1: primeiro argumento para primeiro parâmetro.",
                                  "learningObjective": "Mapear argumentos a parâmetros pela sequência posicional.",
                                  "commonMistakes": [
                                    "Trocar ordem de argumentos; ignorar tipos incompatíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar associação por nome",
                                  "subSteps": [
                                    "Modificar chamada: soma(a=1, c=3, b=2) e verificar independência de ordem.",
                                    "Misturar posição e nome: soma(10, b=20, c=30).",
                                    "Testar erro: usar nome duplicado ou faltante.",
                                    "Comparar saída com associação por posição.",
                                    "Analisar legibilidade: por que nomes melhoram clareza."
                                  ],
                                  "verification": "Criar 4 chamadas variadas e confirmar mapeamento correto via prints.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código, documentação Python sobre keyword arguments"
                                  ],
                                  "tips": "Nomes explícitos evitam erros em funções com muitos parâmetros.",
                                  "learningObjective": "Associar argumentos explicitamente por nome de parâmetro.",
                                  "commonMistakes": [
                                    "Usar nome errado; misturar sem entender precedência (posição primeiro)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar cenários integrados e verificar passagem por valor",
                                  "subSteps": [
                                    "Criar função que modifica parâmetro: def incremento(x): x += 1; print(x)",
                                    "Chamar com variável: y=5; incremento(y); print(y) e observar que y não muda.",
                                    "Combinar posição e nome em função complexa com 4 parâmetros.",
                                    "Debugar código com erros de associação.",
                                    "Refatorar função real para usar nomes explícitos."
                                  ],
                                  "verification": "Resolver 5 exercícios mistos e confirmar que passagem por valor funciona.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código, exemplos de código online (ex: GeeksforGeeks)"
                                  ],
                                  "tips": "Sempre teste com prints para visualizar o mapeamento e cópia por valor.",
                                  "learningObjective": "Integrar associações e demonstrar imutabilidade por valor.",
                                  "commonMistakes": [
                                    "Esperar que alterações afetem o chamador; erros de sintaxe em nomes."
                                  ]
                                }
                              ],
                              "practicalExample": "Defina def calcular_preco(produto, quantidade, desconto=0): preco_final = produto * quantidade * (1 - desconto); return preco_final\nChamadas: calcular_preco(10.0, 5)  # posição: produto=10, qtd=5, desc=0\ncalcular_preco(quantidade=3, produto=20.0, desconto=0.1)  # nomes: ordem irrelevante, valores copiados por valor.",
                              "finalVerifications": [
                                "Explicar verbalmente o mapeamento em uma chamada mista.",
                                "Identificar e corrigir erro em código com associação errada.",
                                "Demonstrar que alteração de parâmetro não afeta argumento original.",
                                "Criar função própria com 3+ parâmetros e chamá-la de 3 formas.",
                                "Comparar prós/contras de posição vs. nome.",
                                "Debugar função com parâmetros default."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento posicional (100% correto em testes).",
                                "Uso correto de nomes sem erros de sintaxe (90%+ acertos).",
                                "Compreensão de passagem por valor via experimentos (sem confusão com referência).",
                                "Clareza em explicações e diagramas.",
                                "Criatividade em exemplos práticos.",
                                "Eficiência no debug de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Correspondência biunívoca em funções (domínio para imagem).",
                                "Lógica: Mapeamento de variáveis em algoritmos.",
                                "Português/Inglês: Terminologia técnica precisa em documentação.",
                                "Física: Analogia com conservação de energia (cópia sem perda original)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, ao chamar APIs como requests.get(url='https://api.exemplo.com', params={'id': 123}, headers={'Auth': 'token'}), garantindo que argumentos sejam mapeados corretamente por nome para evitar erros em integrações, e entendendo que valores são copiados, preservando dados originais em pipelines de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Mecanismo de Cópia por Valor",
                        "description": "Processo pelo qual o valor do argumento atual é copiado para o parâmetro formal no momento da chamada da sub-rotina, criando uma cópia independente.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Descrever o processo de cópia",
                            "description": "Explicar passo a passo como o valor do argumento é duplicado para o parâmetro formal, ilustrando com diagrama de memória simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de argumentos e parâmetros",
                                  "subSteps": [
                                    "Defina argumento como o valor real fornecido na chamada da função.",
                                    "Defina parâmetro formal como a variável declarada na assinatura da função.",
                                    "Explique que na passagem por valor, o argumento é copiado para o parâmetro.",
                                    "Diferencie passagem por valor de passagem por referência.",
                                    "Anote exemplos simples em pseudocódigo."
                                  ],
                                  "verification": "Explique oralmente ou por escrito a diferença entre argumento e parâmetro formal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Use analogia: argumento é o original, parâmetro é uma fotocópia.",
                                  "learningObjective": "Dominar a terminologia essencial para passagem de parâmetros por valor.",
                                  "commonMistakes": "Confundir argumento (valor passado) com parâmetro (variável local da função)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o mecanismo de duplicação do valor",
                                  "subSteps": [
                                    "Explique que o compilador cria uma cópia exata do valor do argumento.",
                                    "Descreva que essa cópia é armazenada na memória local da função.",
                                    "Afirme que alterações no parâmetro não afetam o argumento original.",
                                    "Ilustre verbalmente o fluxo: cópia → uso na função → descarte ao retornar.",
                                    "Compare com uma pilha de memória (stack frame)."
                                  ],
                                  "verification": "Redija um parágrafo descrevendo o processo de cópia sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para esboços",
                                    "Documentação de linguagem como C"
                                  ],
                                  "tips": "Pense na cópia como clonar um número: o clone muda, o original não.",
                                  "learningObjective": "Explicar precisamente como ocorre a duplicação do valor na memória.",
                                  "commonMistakes": "Achar que o parâmetro aponta para o argumento em vez de copiá-lo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir um diagrama de memória simples",
                                  "subSteps": [
                                    "Desenhe a memória antes da chamada: variável main com valor inicial.",
                                    "Mostre a alocação de memória para o parâmetro com cópia do valor.",
                                    "Desenhe após modificação: parâmetro alterado, original intacto.",
                                    "Indique o descarte da cópia ao final da função.",
                                    "Rotule pilhas: main stack e função stack."
                                  ],
                                  "verification": "Desenhe e label o diagrama corretamente para um exemplo dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Marcadores coloridos",
                                    "Ferramenta online como draw.io"
                                  ],
                                  "tips": "Use setas para indicar cópia e cores diferentes para original vs. cópia.",
                                  "learningObjective": "Representar visualmente o processo de cópia na memória.",
                                  "commonMistakes": "Desenhar setas de referência em vez de blocos separados para cópia."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conceito em um exemplo prático",
                                  "subSteps": [
                                    "Escreva uma função simples que modifica um parâmetro por valor.",
                                    "Chame a função e observe o valor original inalterado.",
                                    "Compile e execute o código para validar.",
                                    "Explique o diagrama aplicado ao exemplo.",
                                    "Teste com diferentes tipos de dados (int, float)."
                                  ],
                                  "verification": "Execute o código e confirme que o argumento original não muda.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C ou IDE online como Replit",
                                    "Exemplo de código base"
                                  ],
                                  "tips": "Comece com inteiros simples antes de tipos compostos.",
                                  "learningObjective": "Integrar descrição teórica com prática computacional.",
                                  "commonMistakes": "Esquecer de imprimir o valor original após a chamada."
                                }
                              ],
                              "practicalExample": "Em C: void incrementa(int x) { x = x + 1; } int main() { int a = 5; incrementa(a); printf(\"%d\", a); } Saída: 5. Diagrama: main|a=5| → cópia |x=5| → |x=6| → descarte, a=5 permanece.",
                              "finalVerifications": [
                                "Desenhar diagrama de memória correto antes/depois da chamada.",
                                "Explicar verbalmente por que o original não muda.",
                                "Executar exemplo de código confirmando passagem por valor.",
                                "Identificar erros em diagramas incorretos de colegas.",
                                "Descrever o processo em 3-5 frases concisas."
                              ],
                              "assessmentCriteria": [
                                "Clareza na distinção entre cópia e referência.",
                                "Precisão no diagrama de memória (alocações separadas).",
                                "Correção conceitual no mecanismo de duplicação.",
                                "Uso adequado de exemplos práticos e verificáveis.",
                                "Capacidade de evitar confusões comuns como modificação acidental."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Diagramas de estados e transformações discretas.",
                                "Física: Analogia com clonagem molecular ou fotocópia física.",
                                "Lógica e Filosofia: Independência de entidades duplicadas.",
                                "Artes: Representação visual através de diagramas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, assegura que funções utilitárias (ex: cálculos) não corrompam dados originais, promovendo código modular, seguro e reutilizável em sistemas bancários ou jogos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Implementar função com passagem por valor",
                            "description": "Escrever uma função simples em pseudocódigo que receba parâmetros por valor e realize operações básicas neles.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de passagem por valor",
                                  "subSteps": [
                                    "Leia a definição: passagem por valor cria uma cópia local do parâmetro na função.",
                                    "Compare com passagem por referência: na por valor, alterações afetam só a cópia.",
                                    "Desenhe um diagrama simples mostrando memória original e cópia na função.",
                                    "Identifique cenários onde usar passagem por valor para evitar efeitos colaterais.",
                                    "Explique verbalmente ou por escrito a diferença em 2 exemplos."
                                  ],
                                  "verification": "Desenhe e explique o diagrama para um colega ou grave um áudio resumindo o conceito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Visualize a memória como caixas separadas: original e cópia.",
                                  "learningObjective": "Entender que parâmetros por valor são copiados, isolando mudanças na função.",
                                  "commonMistakes": [
                                    "Confundir com referência, achando que altera o original",
                                    "Ignorar o custo de cópia para tipos grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a assinatura da função em pseudocódigo",
                                  "subSteps": [
                                    "Escolha um nome descritivo para a função, como 'somarNumeros'.",
                                    "Declare parâmetros por valor: função somarNumeros(a, b).",
                                    "Especifique o tipo de retorno, se aplicável: retorna inteiro.",
                                    "Escreva um exemplo de chamada: resultado = somarNumeros(5, 3).",
                                    "Verifique sintaxe básica do pseudocódigo para funções."
                                  ],
                                  "verification": "Escreva a assinatura e mostre que ela declara parâmetros explicitamente por valor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou papel",
                                    "Referência de pseudocódigo"
                                  ],
                                  "tips": "Use nomes de parâmetros curtos mas claros para facilitar leitura.",
                                  "learningObjective": "Criar corretamente o cabeçalho de uma função com parâmetros passados por valor.",
                                  "commonMistakes": [
                                    "Esquecer o tipo de retorno",
                                    "Usar sintaxe de referência acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o corpo da função com operações básicas",
                                  "subSteps": [
                                    "Dentro da função, realize operações como soma: resultado = a + b.",
                                    "Modifique cópias dos parâmetros: a = a * 2 (não afeta original).",
                                    "Inclua lógica condicional simples: se a > b então ...",
                                    "Retorne o resultado final: retorna resultado.",
                                    "Adicione comentários explicando cada operação."
                                  ],
                                  "verification": "Execute mentalmente a função com valores de teste e confirme o retorno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Calculadora para testes manuais"
                                  ],
                                  "tips": "Sempre comente linhas para reforçar que mudanças são locais.",
                                  "learningObjective": "Realizar operações em cópias de parâmetros sem afetar variáveis externas.",
                                  "commonMistakes": [
                                    "Tentar acessar variáveis globais desnecessariamente",
                                    "Esquecer o 'retorna'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o comportamento da função",
                                  "subSteps": [
                                    "Declare variáveis originais: x = 10, y = 20.",
                                    "Chame a função: z = minhaFuncao(x, y).",
                                    "Verifique: x e y permanecem inalterados após chamada.",
                                    "Compare z com expectativa e registre discrepâncias.",
                                    "Repita com 3 conjuntos de dados diferentes."
                                  ],
                                  "verification": "Mostre antes/depois das variáveis originais em uma tabela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para tabela de testes",
                                    "Simulador de pseudocódigo se disponível"
                                  ],
                                  "tips": "Use asserts mentais: 'x deve ser igual antes e depois'.",
                                  "learningObjective": "Confirmar empiricamente que passagem por valor isola modificações.",
                                  "commonMistakes": [
                                    "Não testar múltiplos casos",
                                    "Confundir retorno com alteração de parâmetros"
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva função 'duplicarEAdicionar(valor1, valor2)' que duplica valor1 (cópia), soma com valor2 e retorna. Chamada: original1=5, original2=3; após chamada, original1 permanece 5, retorno=13.",
                              "finalVerifications": [
                                "Escreva uma função completa em pseudocódigo com 2 parâmetros por valor.",
                                "Demonstre com diagrama que parâmetros são copiados.",
                                "Teste e prove que originais não mudam após execução.",
                                "Explique verbalmente por que usar por valor aqui.",
                                "Crie variação com operação diferente e valide.",
                                "Identifique quando NÃO usar por valor (ex: grandes estruturas)."
                              ],
                              "assessmentCriteria": [
                                "Assinatura da função declara parâmetros por valor corretamente (20%)",
                                "Corpo realiza operações apenas em cópias locais (25%)",
                                "Testes comprovam isolamento de originais (20%)",
                                "Pseudocódigo é claro, comentado e sintaticamente válido (15%)",
                                "Explicação conceitual precisa e completa (10%)",
                                "Inclui pelo menos 3 testes variados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções como mapeamentos de entrada para saída sem alterar domínio.",
                                "Lógica: Conceito de escopo local similar a blocos lógicos isolados.",
                                "Física: Analogia com cópias de partículas independentes em experimentos.",
                                "Língua Portuguesa: Estrutura textual clara em pseudocódigo como redação técnica."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, funções com passagem por valor (como em C ou Java para primitivos) previnem bugs de efeitos colaterais, facilitando depuração e reutilização de código em sistemas bancários ou jogos onde integridade de dados é crucial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Simular cópia em memória",
                            "description": "Simular o estado da memória antes e após a chamada de função, destacando a criação da cópia do valor no parâmetro formal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e compreender um exemplo simples de função com passagem por valor",
                                  "subSteps": [
                                    "Escreva um código exemplo em pseudocódigo ou C: int a = 5; chamarFuncao(a); onde chamarFuncao(int x) { x = x + 1; }",
                                    "Identifique as variáveis: a (na main) e x (parâmetro formal na função)",
                                    "Explique verbalmente o que o código faz: tenta incrementar o valor passado",
                                    "Compile e execute o código para observar o resultado (a permanece 5)",
                                    "Anote o objetivo: demonstrar que alterações em x não afetam a"
                                  ],
                                  "verification": "Código escrito e executado corretamente, com saída confirmando que 'a' não muda",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Compilador C ou interpretador pseudocódigo",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Use valores simples como 5 para facilitar visualização; teste com printf para imprimir valores",
                                  "learningObjective": "Compreender a sintaxe e o comportamento esperado de passagem por valor",
                                  "commonMistakes": [
                                    "Confundir parâmetro formal com referência",
                                    "Esquecer de imprimir o valor original após a chamada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar o estado inicial da memória antes da chamada da função",
                                  "subSteps": [
                                    "Desenhe um diagrama de memória: caixa 'main' com variável 'a' contendo valor 5 (endereço fictício 0x100)",
                                    "Marque pilha de chamadas vazia ou apenas main ativa",
                                    "Anote tipos e valores explicitamente: int a = 5",
                                    "Verifique se o diagrama mostra apenas dados da main",
                                    "Compare com execução real para validar"
                                  ],
                                  "verification": "Diagrama desenhado mostrando apenas 'a=5' na memória da main",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama (Draw.io, Lucidchart)",
                                    "Código do passo 1"
                                  ],
                                  "tips": "Use setas para endereços e valores separados; mantenha simples, foque em pilha",
                                  "learningObjective": "Visualizar o estado da memória no escopo da main antes da invocação",
                                  "commonMistakes": [
                                    "Incluir função na memória inicial",
                                    "Confundir valor com endereço"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular a cópia do valor para o parâmetro formal durante a chamada",
                                  "subSteps": [
                                    "No diagrama, adicione frame da função na pilha ao chamar chamarFuncao(a)",
                                    "Desenhe cópia: 'x' recebe valor 5 de 'a' (nova caixa com valor copiado)",
                                    "Indique seta de cópia: valor de a -> valor de x (não endereço)",
                                    "Explique: mecanismo de cópia cria duplicata independente",
                                    "Atualize pilha: main embaixo, função em cima"
                                  ],
                                  "verification": "Diagrama atualizado com cópia de x=5 no frame da função",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama do passo 2",
                                    "Marcadores coloridos para diferenciar cópia (ex: azul para original, vermelho para cópia)"
                                  ],
                                  "tips": "Use cores diferentes para original e cópia; anote 'cópia por valor' na seta",
                                  "learningObjective": "Entender como o parâmetro formal recebe uma cópia independente do argumento",
                                  "commonMistakes": [
                                    "Desenhar seta de referência (endereço compartilhado)",
                                    "Mostrar x apontando para a"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar a função e observar alteração apenas na cópia",
                                  "subSteps": [
                                    "No frame da função, altere x para 6 (x = x + 1)",
                                    "Mantenha a=5 inalterado na main",
                                    "Simule retorno: frame da função é destruído, x some",
                                    "Pilha volta só com main",
                                    "Explique independência: mudanças locais não propagam"
                                  ],
                                  "verification": "Diagrama final mostra a=5 inalterado após destruição do frame da função",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do passo 3",
                                    "Código executável para comparação"
                                  ],
                                  "tips": "Anime o processo verbalmente ou com setas temporais; execute debugger se possível",
                                  "learningObjective": "Demonstrar isolamento da cópia durante execução",
                                  "commonMistakes": [
                                    "Alterar o valor original a",
                                    "Manter frame da função após retorno"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e contrastar estados antes/depois da chamada",
                                  "subSteps": [
                                    "Compare diagramas inicial e final lado a lado",
                                    "Liste diferenças: só cópia temporária mudou",
                                    "Teste com outro valor (ex: 10) e repita simulação",
                                    "Discuta implicações: previsibilidade e segurança",
                                    "Documente em relatório curto"
                                  ],
                                  "verification": "Relatório ou diagrama comparativo completo e correto",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Todos os diagramas anteriores",
                                    "Folha para relatório"
                                  ],
                                  "tips": "Use tabela para comparação: Antes | Durante | Depois",
                                  "learningObjective": "Consolidar compreensão do mecanismo de cópia por valor",
                                  "commonMistakes": [
                                    "Achar que cópia afeta original",
                                    "Ignorar destruição do frame"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C: #include <stdio.h> void incrementa(int x) { x++; printf('Dentro: %d\\n', x); } int main() { int a = 5; printf('Antes: %d\\n', a); incrementa(a); printf('Depois: %d\\n', a); return 0; } Saída: Antes: 5, Dentro: 6, Depois: 5. Diagrama mostra cópia de 5 para x, alteração só em x.",
                              "finalVerifications": [
                                "Diagrama completo da memória antes, durante e após a chamada está correto",
                                "Explicação oral ou escrita diferencia cópia de referência",
                                "Simulação com código executado confirma que argumento original não muda",
                                "Identificação precisa do momento da cópia (na ativação da função)",
                                "Teste com múltiplos parâmetros por valor funciona igual",
                                "Relatório resume mecanismo sem erros conceituais"
                              ],
                              "assessmentCriteria": [
                                "Precisão dos diagramas de memória (cópia vs. original)",
                                "Completude dos subpassos em cada step (mínimo 4/5)",
                                "Correção na explicação verbal do processo de cópia",
                                "Uso adequado de verificações em cada step",
                                "Criatividade e clareza nos diagramas (cores, labels)",
                                "Aplicação correta em exemplo alternativo"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de funções e transformações independentes de variáveis",
                                "Física: Analogia com clonagem de partículas (cópia vs. ligação)",
                                "Lógica: Princípios de isolamento em provas formais",
                                "Engenharia: Diagramas de fluxo em sistemas embarcados"
                              ],
                              "realWorldApplication": "Em desenvolvimento de software seguro, passagem por valor previne bugs acidentais de modificação de dados compartilhados, como em funções de validação de entrada de usuário ou cálculos temporários em finanças, garantindo que valores originais permaneçam íntegros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Implicações das Modificações por Valor",
                        "description": "Compreensão de que alterações realizadas no parâmetro formal durante a execução da sub-rotina não afetam o valor do argumento atual original.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Prever efeito de modificações",
                            "description": "Analisar código com função por valor e prever o valor final das variáveis originais após a chamada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Passagem por Valor",
                                  "subSteps": [
                                    "Defina passagem de parâmetros por valor: uma cópia do valor é passada para a função.",
                                    "Explique que modificações na função afetam apenas a cópia local, não a variável original.",
                                    "Compare com passagem por referência usando um diagrama mental de memória.",
                                    "Identifique exemplos simples em pseudocódigo.",
                                    "Liste cenários onde isso é comum em linguagens como C ou Java."
                                  ],
                                  "verification": "Escreva uma definição precisa em suas próprias palavras e dê um exemplo correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notas de aula sobre subprogramação, quadro branco ou papel para diagramas.",
                                  "tips": "Use diagramas de pilha de memória para visualizar cópias.",
                                  "learningObjective": "Compreender o mecanismo fundamental de passagem por valor.",
                                  "commonMistakes": "Confundir com passagem por referência; assumir que variáveis mudam sempre."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estrutura do Código",
                                  "subSteps": [
                                    "Identifique as variáveis originais fora da função e seus valores iniciais.",
                                    "Localize a chamada da função e os argumentos passados.",
                                    "Examine os parâmetros formais na declaração da função.",
                                    "Anote todas as operações de modificação dentro da função.",
                                    "Marque pontos de retorno ou saída da função."
                                  ],
                                  "verification": "Crie um mapa anotado do código destacando variáveis e modificações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código fonte impresso ou editor de texto com realce de sintaxe.",
                                  "tips": "Use cores diferentes para variáveis originais e cópias.",
                                  "learningObjective": "Mapear precisamente o fluxo de dados no código.",
                                  "commonMistakes": "Ignorar valores iniciais ou confundir nomes de parâmetros com variáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Execução Passo a Passo",
                                  "subSteps": [
                                    "Atribua valores iniciais às variáveis originais.",
                                    "Copie valores para parâmetros ao entrar na função.",
                                    "Execute linha por linha dentro da função, atualizando apenas parâmetros.",
                                    "Ao sair da função, liste valores finais das variáveis originais.",
                                    "Registre previsões em uma tabela de rastreamento."
                                  ],
                                  "verification": "Preencha uma tabela de valores antes/depois que corresponda à simulação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela em Excel ou papel para rastrear valores por linha.",
                                  "tips": "Simule como um depurador: avance uma instrução por vez.",
                                  "learningObjective": "Prever com precisão o estado final das variáveis originais.",
                                  "commonMistakes": "Atualizar variáveis originais durante a simulação interna."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Previsão com Execução Real",
                                  "subSteps": [
                                    "Compile e execute o código em um ambiente de programação.",
                                    "Compare valores reais impressos com suas previsões.",
                                    "Analise discrepâncias e identifique erros na previsão.",
                                    "Teste variações: mude valores iniciais e repita.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Execução produz saída idêntica à previsão em pelo menos 3 testes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador/interpretador (ex: Python, C online IDE).",
                                  "tips": "Use print statements para depuração se necessário.",
                                  "learningObjective": "Confirmar previsões e refinar habilidades de análise.",
                                  "commonMistakes": "Não testar múltiplos cenários; ignorar efeitos colaterais."
                                }
                              ],
                              "practicalExample": "Considere o código em pseudocódigo:\nint a = 10;\nvoid modificar(int b) {\n  b = b + 5;\n  print(b);  // Imprime 15\n}\nmodificar(a);\nprint(a);  // Imprime 10\nPrevisão: 'a' permanece 10 porque 'b' é uma cópia.",
                              "finalVerifications": [
                                "Pode prever corretamente o valor final de variáveis originais em 5 códigos diferentes?",
                                "Explica verbalmente por que modificações na função não afetam originais?",
                                "Identifica cópias vs. originais em diagramas de memória?",
                                "Simula execução sem erros em código com múltiplos parâmetros?",
                                "Aplica o conceito a linguagens reais como Python ou C?",
                                "Distingue passagem por valor de por referência?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na previsão de valores finais (100% correto).",
                                "Qualidade da simulação passo a passo (tabela completa e lógica).",
                                "Explicação conceitual clara e sem confusões.",
                                "Identificação correta de variáveis e cópias.",
                                "Aplicação consistente em exemplos variados.",
                                "Análise de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de funções e variáveis como equações.",
                                "Lógica: Raciocínio dedutivo em sequências de operações.",
                                "Física: Analogia com conservação de massa (cópias independentes).",
                                "Inglês: Leitura técnica de código e documentação."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, prever efeitos de modificações por valor previne bugs em funções utilitárias, como cálculos em APIs financeiras onde valores originais de saldos não devem alterar inadvertidamente, garantindo integridade de dados em sistemas bancários ou jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Debugar exemplos de passagem por valor",
                            "description": "Identificar e corrigir equívocos em códigos onde se espera modificação do original, mas usa-se passagem por valor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Conceito de Passagem por Valor",
                                  "subSteps": [
                                    "Leia a definição de passagem por valor: uma cópia do argumento é passada para a função, modificações afetam apenas a cópia.",
                                    "Compare com passagem por referência usando diagramas de memória.",
                                    "Execute um exemplo simples de passagem por valor em um editor de código.",
                                    "Anote diferenças observadas no valor original após a chamada da função.",
                                    "Discuta com um colega ou tutor por que o original não muda."
                                  ],
                                  "verification": "Resuma em uma frase o que acontece com o original; confirme que entende que modificações não propagam.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (ex: VS Code), compilador (ex: GCC para C), diagrama de pilha de memória impresso.",
                                  "tips": "Desenhe setas representando cópias na memória para visualizar melhor.",
                                  "learningObjective": "Compreender mecanicamente como a passagem por valor cria uma cópia isolada.",
                                  "commonMistakes": "Confundir com passagem por referência; assumir que funções sempre modificam o original."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenários de Equívoco Comum",
                                  "subSteps": [
                                    "Analise códigos onde o programador espera que o original seja alterado (ex: incrementadores, swaps).",
                                    "Liste 3 exemplos reais de funções que falham por passagem por valor.",
                                    "Marque linhas onde a modificação interna ocorre, mas não afeta o chamador.",
                                    "Preveja o output antes de executar, comparando com expectativa errônea.",
                                    "Registre o 'equívoco' em um log de debug."
                                  ],
                                  "verification": "Liste pelo menos 2 equívocos identificados e explique por que ocorrem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplos de código preparados, debugger (ex: GDB), papel para anotações.",
                                  "tips": "Procure por funções que recebem variáveis simples (int, char) sem ponteiros.",
                                  "learningObjective": "Reconhecer padrões onde passagem por valor causa falhas inesperadas.",
                                  "commonMistakes": "Ignorar que arrays ou structs podem se comportar diferente; focar só em prints."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Debugar o Código Passo a Passo",
                                  "subSteps": [
                                    "Coloque breakpoints na entrada e saída da função usando um debugger.",
                                    "Inspecione valores de parâmetros antes e após modificações internas.",
                                    "Trace o fluxo de execução, verificando cópias na pilha.",
                                    "Identifique o ponto exato onde a expectativa diverge da realidade.",
                                    "Adicione prints ou logs temporários para confirmar observações."
                                  ],
                                  "verification": "Gere um relatório de debug com valores antes/depois e screenshot do debugger.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Debugger integrado (ex: em IDE como Code::Blocks), código exemplo compilado.",
                                  "tips": "Use 'step into' no debugger para ver cópias sendo criadas.",
                                  "learningObjective": "Aplicar ferramentas de debug para isolar problemas de passagem por valor.",
                                  "commonMistakes": "Não usar debugger e confiar só em intuição; pular verificação de memória."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Corrigir e Testar a Solução",
                                  "subSteps": [
                                    "Substitua passagem por valor por referência (ex: ponteiros em C).",
                                    "Reescreva a função corrigida e teste com múltiplos inputs.",
                                    "Compare outputs antes/depois da correção.",
                                    "Crie testes unitários para validar modificação do original.",
                                    "Documente a correção em comentários no código."
                                  ],
                                  "verification": "Execute testes: original deve mudar; forneça código corrigido e resultados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Framework de testes (ex: Unity para C), editor de código.",
                                  "tips": "Sempre inicialize ponteiros corretamente para evitar segfaults.",
                                  "learningObjective": "Corrigir bugs de passagem por valor implementando referência adequadamente.",
                                  "commonMistakes": "Esquecer de dereferenciar ponteiros; introduzir novos bugs na correção."
                                }
                              ],
                              "practicalExample": "Em C:\nvoid increment(int x) {\n    x++;\n}\nint main() {\n    int count = 5;\n    increment(count);\n    printf(\"%d\\n\", count);  // Output: 5 (esperado: 6)\n    return 0;\n}\nDebug: Use ponteiro - void increment(int* x) { (*x)++; } e chame increment(&count); // Output: 6",
                              "finalVerifications": [
                                "O aluno explica corretamente por que o original não muda em passagem por valor.",
                                "Identifica o erro em pelo menos 3 exemplos fornecidos.",
                                "Usa debugger para demonstrar cópia na memória.",
                                "Corrige código para usar referência/ponteiro com testes passando.",
                                "Documenta solução com comentários claros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do problema (30%)",
                                "Uso correto de ferramentas de debug (25%)",
                                "Qualidade da correção implementada (20%)",
                                "Cobertura de testes unitários (15%)",
                                "Clareza na documentação e explicação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Raciocínio: Análise de fluxo de dados como em matemática discreta.",
                                "Matemática: Modelagem de memória como funções injetoras/não-injetoras.",
                                "Física: Analogia com cópias de partículas vs. referências compartilhadas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, debuggar passagem por valor previne bugs críticos em funções como atualizadores de contadores em jogos, processadores de dados em apps financeiros ou manipuladores de estado em sistemas embarcados, economizando horas de depuração em equipes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Comparar com variáveis locais",
                            "description": "Relacionar o comportamento do parâmetro por valor com o de uma variável local, enfatizando independência do argumento original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de variáveis locais",
                                  "subSteps": [
                                    "Defina o que é uma variável local: declarada dentro de uma função ou escopo e só acessível ali.",
                                    "Explique o ciclo de vida: criada na entrada da função, destruída na saída.",
                                    "Diferencie de variáveis globais: escopo limitado à função.",
                                    "Exemplo simples: crie uma função que declara e modifica uma variável local.",
                                    "Teste acessando a variável fora da função para confirmar erro de escopo."
                                  ],
                                  "verification": "Criar e executar um código onde uma variável local é modificada e confirmada inacessível fora da função.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Replit)",
                                    "Linguagem de programação com funções (ex: Python, C)"
                                  ],
                                  "tips": "Sempre declare variáveis dentro da função para praticar escopo local.",
                                  "learningObjective": "Compreender o escopo e independência das variáveis locais em relação ao resto do programa.",
                                  "commonMistakes": [
                                    "Confundir com variáveis globais",
                                    "Tentar acessar local fora do escopo",
                                    "Esquecer de passar parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a passagem de parâmetros por valor",
                                  "subSteps": [
                                    "Explique passagem por valor: uma cópia do valor do argumento é passada para o parâmetro.",
                                    "Descreva o que acontece na modificação: só a cópia é alterada, original permanece intacto.",
                                    "Crie um exemplo: função que recebe um número, dobra-o e imprime, mas original não muda.",
                                    "Execute o código e observe o valor original antes e depois da chamada.",
                                    "Compare com atribuição simples: parâmetro age como variável local inicializada com cópia."
                                  ],
                                  "verification": "Executar função que modifica parâmetro e imprimir argumento original para confirmar imutação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Documentação da linguagem sobre passagem de parâmetros"
                                  ],
                                  "tips": "Use print() antes e depois da chamada para visualizar valores.",
                                  "learningObjective": "Identificar que parâmetros por valor são cópias independentes do argumento.",
                                  "commonMistakes": [
                                    "Achar que modificação afeta o original",
                                    "Confundir com referência",
                                    "Não imprimir valores para verificar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar comportamentos entre parâmetros por valor e variáveis locais",
                                  "subSteps": [
                                    "Liste similaridades: ambos têm escopo local à função e são independentes do chamador.",
                                    "Liste diferenças: variável local é declarada internamente; parâmetro é inicializado com cópia externa.",
                                    "Crie tabela comparativa: modificação, escopo, inicialização.",
                                    "Simule cenários: modifique ambos e observe impactos (nenhum no original).",
                                    "Discuta implicações: segurança de dados e previsibilidade."
                                  ],
                                  "verification": "Criar tabela ou diagrama comparando os dois conceitos e explicar oralmente ou por escrito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel ou ferramenta de diagramação (ex: Draw.io)",
                                    "Editor de código para testes"
                                  ],
                                  "tips": "Desenhe fluxogramas para visualizar cópias e escopos.",
                                  "learningObjective": "Relacionar parâmetros por valor como variáveis locais 'pré-inicializadas' com cópia.",
                                  "commonMistakes": [
                                    "Ignorar a origem da inicialização do parâmetro",
                                    "Achar parâmetros 'globais'",
                                    "Não considerar destruição no fim da função"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar com exemplos integrados",
                                  "subSteps": [
                                    "Implemente função com parâmetro por valor e variável local lado a lado.",
                                    "Modifique ambos e verifique original inalterado.",
                                    "Varie tipos: inteiros, strings, para reforçar generalidade.",
                                    "Refatore código: substitua variável local por parâmetro onde possível.",
                                    "Debugue cenários de erro para reforçar compreensão."
                                  ],
                                  "verification": "Executar código completo com prints e confirmar independência em múltiplos testes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de código preparados"
                                  ],
                                  "tips": "Use asserts ou testes unitários para automação de verificações.",
                                  "learningObjective": "Aplicar comparação em código real, prevendo e confirmando comportamentos.",
                                  "commonMistakes": [
                                    "Usar passagem por referência acidentalmente",
                                    "Esquecer prints de verificação",
                                    "Não testar múltiplos tipos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\ndef modificar_parametro(valor_original):\n    valor_local = valor_original  # Parâmetro por valor (cópia)\n    variavel_local = 100  # Declarada internamente\n    valor_parametro = valor_original * 2  # Modifica cópia\n    variavel_local += 50  # Modifica local\n    print('Parâmetro modificado:', valor_parametro)\n    print('Variável local:', variavel_local)\n\nx = 5\nmodificar_parametro(x)\nprint('Original após chamada:', x)  # Sai 5, não alterado\n# Comportamentos idênticos: ambos independentes de x.",
                              "finalVerifications": [
                                "Explicar verbalmente por que modificar parâmetro não afeta argumento original.",
                                "Prever e codificar output de função com modificações em parâmetro e local.",
                                "Identificar em código dado se uma variável é local ou parâmetro.",
                                "Criar função que usa ambos e confirma independência com testes.",
                                "Diferenciar de passagem por referência em exemplo contrastante.",
                                "Refatorar código substituindo locais por parâmetros sem alterar lógica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação da independência (cópia vs. original).",
                                "Correção nos códigos de exemplo e testes (sem erros de escopo).",
                                "Profundidade na comparação (similaridades e diferenças claras).",
                                "Uso de verificações práticas (prints, asserts).",
                                "Generalização para diferentes tipos de dados.",
                                "Identificação de erros comuns em cenários dados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com funções matemáticas (argumento vs. variável interna).",
                                "Lógica e Filosofia: Conceitos de escopo e independência ontológica.",
                                "Engenharia de Software: Princípios de modularidade e encapsulamento.",
                                "Física: Conservação de propriedades (original inalterado como lei física).",
                                "Linguagens: Comparação com escopo em outras linguagens."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, garante que funções como processadores de dados (ex: calculadoras financeiras) não corrompam entradas originais, promovendo código seguro, reutilizável e livre de side-effects inesperados em sistemas bancários ou jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Passagem de Parâmetros por Referência",
                    "description": "Mecanismo de passagem de endereço de memória dos argumentos aos parâmetros.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Ponteiros e Endereços de Memória",
                        "description": "Ponteiros são variáveis que armazenam o endereço de memória de outras variáveis, permitindo acesso indireto e sendo a base para a passagem de parâmetros por referência.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Declarar uma variável ponteiro",
                            "description": "Identificar e utilizar a sintaxe correta para declarar ponteiros em linguagens procedimentais como C ou C++, associando tipos adequados ao endereço de memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Ponteiros e Memória",
                                  "subSteps": [
                                    "Estude o conceito de endereço de memória: cada variável tem um endereço único acessível via operador &. Exemplo: &variavel retorna o endereço.",
                                    "Diferencie valor da variável do seu endereço: o ponteiro armazena endereços, não valores.",
                                    "Revise tipos de dados básicos em C/C++ (int, char, float) e como eles ocupam espaço na memória.",
                                    "Entenda o papel do ponteiro: permite manipular dados indiretamente via endereço.",
                                    "Visualize com diagrama: desenhe uma variável na memória com seu endereço e valor."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre uma variável e seu ponteiro, incluindo um exemplo com &.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE como VS Code",
                                    "Compilador GCC/Clang",
                                    "Diagrama de memória impresso ou digital"
                                  ],
                                  "tips": [
                                    "Use ferramentas como gdb para visualizar endereços reais durante depuração.",
                                    "Pense em ponteiros como 'setas' apontando para locais na memória."
                                  ],
                                  "learningObjective": "Compreender o que são endereços de memória e o propósito de ponteiros em linguagens como C/C++.",
                                  "commonMistakes": [
                                    "Confundir endereço com valor da variável.",
                                    "Ignorar que ponteiros precisam de tipo compatível com o dado apontado."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Sintaxe Correta de Declaração de Ponteiro",
                                  "subSteps": [
                                    "Memorize a sintaxe base: tipo * nomePonteiro; Exemplo: int *ptr; declara um ponteiro para inteiro.",
                                    "Identifique componentes: 'tipo' define o tipo do dado apontado, '*' indica ponteiro, 'nome' é o identificador.",
                                    "Pratique declaração sem inicialização: int *ptr; // ptr é indefinido até &algo.",
                                    "Aprenda a declarar múltiplos ponteiros: int *ptr1, *ptr2; // Nota: sem *, ptr2 seria int normal.",
                                    "Teste em código simples: escreva declarações e compile para verificar erros de sintaxe."
                                  ],
                                  "verification": "Compile um programa com pelo menos 3 declarações de ponteiros diferentes sem erros de compilação.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Compilador GCC (gcc -o programa programa.c)",
                                    "Exemplos de código preparados"
                                  ],
                                  "tips": [
                                    "Sempre coloque o * junto ao nome do ponteiro para clareza: int* ptr; é aceitável, mas int *ptr; é padrão.",
                                    "Evite declarar ponteiros sem inicializar para prevenir bugs."
                                  ],
                                  "learningObjective": "Dominar a sintaxe exata para declarar variáveis ponteiro associadas a tipos específicos.",
                                  "commonMistakes": [
                                    "Esquecer o '*'.",
                                    "Declarar int *a, b; achando que b é ponteiro (b é int).",
                                    "Usar tipo incompatível, como char* para int."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Declaração de Ponteiros para Diferentes Tipos",
                                  "subSteps": [
                                    "Declare ponteiro para int: int x = 10; int *ptr = &x;",
                                    "Estenda para char: char c = 'A'; char *pchar = &c;",
                                    "Pratique com float e double: float f = 3.14; float *pf = &f;",
                                    "Declare ponteiro para array: int arr[5]; int *parr = arr; // ou &arr[0]",
                                    "Compile e execute um programa que declara ponteiros para múltiplos tipos e imprime endereços com printf('%p', ptr)."
                                  ],
                                  "verification": "Crie e execute um programa que declara ponteiros para int, char e array, imprimindo endereços corretamente.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "IDE com suporte a C/C++ (Code::Blocks ou CLion)",
                                    "Referência de sintaxe C (man pages ou online)"
                                  ],
                                  "tips": [
                                    "Use %p no printf para imprimir endereços.",
                                    "Inicialize sempre com & para evitar ponteiros selvagens."
                                  ],
                                  "learningObjective": "Aplicar declaração de ponteiros para diversos tipos de dados, garantindo associação correta.",
                                  "commonMistakes": [
                                    "Não usar & na inicialização.",
                                    "Confundir ponteiro para array com ponteiro simples."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Debugar Declarações de Ponteiros",
                                  "subSteps": [
                                    "Identifique erros comuns: compile códigos com falhas intencionais (ex: int* ptr sem *) e corrija.",
                                    "Use warnings do compilador: compile com -Wall -Wextra para detectar problemas.",
                                    "Teste dereferência segura: após declarar, use *ptr para acessar valor e verifique.",
                                    "Crie um checklist: tipo correto? * presente? Inicializado com &? Compile OK?",
                                    "Documente 3 exemplos funcionais e 3 erros corrigidos em um relatório."
                                  ],
                                  "verification": "Gere um relatório com códigos corretos e corrigidos, comprovando compilação e execução sem crashes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Debugger GDB (gdb programa)",
                                    "Lista de erros comuns impressa"
                                  ],
                                  "tips": [
                                    "Ative address sanitizer (-fsanitize=address) para detectar ponteiros inválidos.",
                                    "Sempre inicialize ponteiros para NULL se não usado imediatamente."
                                  ],
                                  "learningObjective": "Saber debugar e validar declarações de ponteiros para uso seguro.",
                                  "commonMistakes": [
                                    "Ponteiros não inicializados (dangling/wild pointers).",
                                    "Misturar tipos (int* para float)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em C: #include <stdio.h> int main() { int valor = 42; int *ponteiro = &valor; printf('Endereço: %p, Valor indireto: %d\\n', (void*)ponteiro, *ponteiro); return 0; } // Saída mostra endereço e 42, provando declaração correta.",
                              "finalVerifications": [
                                "Declara corretamente ponteiro para int, char e array sem erros de sintaxe.",
                                "Inicializa ponteiro com operador & e acessa via * sem crash.",
                                "Explica a diferença entre declaração e inicialização de ponteiro.",
                                "Compila e executa programa com múltiplas declarações de ponteiros.",
                                "Identifica e corrige 3 erros comuns em declarações.",
                                "Usa printf corretamente para exibir endereços (%p)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da sintaxe: * e tipo corretos em todas declarações (40%).",
                                "Correta associação de tipos ao ponteiro (20%).",
                                "Inicialização e uso básico sem erros de runtime (20%).",
                                "Capacidade de debugar e explicar conceitos (10%).",
                                "Código limpo, comentado e compilável (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética de ponteiros (ptr + 1 avança sizeof(tipo)).",
                                "Física: Representação binária de endereços de memória em hardware.",
                                "Engenharia de Software: Gerenciamento de memória dinâmica em sistemas embarcados.",
                                "Lógica Computacional: Abstrações de referência vs valor.",
                                "Algoritmos: Base para estruturas como listas ligadas."
                              ],
                              "realWorldApplication": "Ponteiros são essenciais em C/C++ para linked lists, árvores binárias, alocação dinâmica (malloc/free) em jogos, sistemas operacionais e software de alto desempenho como engines gráficas (Unity/Unreal) ou kernels Linux, permitindo acesso eficiente a memória sem cópias desnecessárias."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Obter o endereço de uma variável",
                            "description": "Aplicar o operador de endereço (&) para capturar o endereço de memória de uma variável e atribuí-lo a um ponteiro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de endereços de memória e ponteiros",
                                  "subSteps": [
                                    "Estude o que é um endereço de memória: localização única de uma variável na RAM.",
                                    "Aprenda a diferença entre valor de uma variável e seu endereço.",
                                    "Revise a sintaxe de declaração de ponteiros em C (ex: int *ptr;).",
                                    "Entenda o operador & como 'endereço de'.",
                                    "Visualize com diagramas de memória como uma variável ocupa bytes e tem endereço."
                                  ],
                                  "verification": "Explique em suas palavras o que o operador & faz e desenhe um diagrama simples de memória.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de C sobre ponteiros",
                                    "Editor de texto para anotações",
                                    "Diagramas online de memória"
                                  ],
                                  "tips": "Use ferramentas como o site 'Beej's Guide to C' para visualizações claras.",
                                  "learningObjective": "Dominar os fundamentos teóricos de endereços e ponteiros antes da prática.",
                                  "commonMistakes": [
                                    "Confundir endereço com valor da variável",
                                    "Ignorar que ponteiros precisam de tipo compatível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma variável e um ponteiro compatível",
                                  "subSteps": [
                                    "Declare uma variável simples, como int numero = 42;.",
                                    "Declare um ponteiro do mesmo tipo: int *ptr;.",
                                    "Compile um código mínimo apenas com essas declarações para verificar sintaxe.",
                                    "Anote os tipos: variável é int, ponteiro é int*.",
                                    "Evite inicializar o ponteiro ainda (deixe dangling para entender risco)."
                                  ],
                                  "verification": "Código compila sem erros de declaração.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador GCC ou online como Replit",
                                    "Editor VS Code ou similar"
                                  ],
                                  "tips": "Sempre especifique o tipo exato do ponteiro para evitar warnings.",
                                  "learningObjective": "Saber declarar corretamente variáveis e ponteiros.",
                                  "commonMistakes": [
                                    "Declarar ponteiro com tipo errado (ex: char* para int)",
                                    "Esquecer o asterisco *"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o operador & para obter e atribuir o endereço",
                                  "subSteps": [
                                    "Use ptr = &numero; para capturar o endereço.",
                                    "Inclua <stdio.h> e use printf(\"Endereço: %p\\n\", ptr); para imprimir.",
                                    "Compile e execute para ver o endereço em formato hexadecimal.",
                                    "Compare &numero diretamente no printf para confirmar igualdade.",
                                    "Teste com múltiplas variáveis para observar endereços diferentes."
                                  ],
                                  "verification": "Programa imprime o endereço corretamente e compila sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use %p para imprimir ponteiros; cast para (void*) se necessário.",
                                  "learningObjective": "Aplicar o operador & corretamente em atribuições a ponteiros.",
                                  "commonMistakes": [
                                    "Esquecer o & (atribui valor ao ponteiro)",
                                    "Desreferenciar ponteiro não inicializado (*ptr)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e manipular o endereço via ponteiro",
                                  "subSteps": [
                                    "Altere o valor via ponteiro: *ptr = 100; e verifique numero.",
                                    "Imprima valor e endereço antes/depois para confirmar ligação.",
                                    "Teste em função para simular passagem por referência.",
                                    "Use gdb ou debugger para inspecionar endereço em runtime.",
                                    "Documente observações sobre endereços crescentes em arrays."
                                  ],
                                  "verification": "Alteração via ponteiro reflete na variável original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Debugger GDB",
                                    "Compilador com flags -g"
                                  ],
                                  "tips": "Compile com -Wall -g para detectar issues cedo.",
                                  "learningObjective": "Confirmar funcionalidade do ponteiro com endereço obtido.",
                                  "commonMistakes": [
                                    "Não desreferenciar com * ao alterar valor",
                                    "Acessar ponteiro nulo"
                                  ]
                                }
                              ],
                              "practicalExample": "#include <stdio.h>\nint main() {\n    int numero = 42;\n    int *ptr = &numero;\n    printf(\"Valor: %d, Endereço: %p\\n\", numero, (void*)ptr);\n    printf(\"Endereço via &: %p\\n\", (void*)&numero);\n    *ptr = 100;\n    printf(\"Novo valor: %d\\n\", numero);\n    return 0;\n}",
                              "finalVerifications": [
                                "Código compila e executa sem erros ou warnings.",
                                "Endereços impressos são idênticos para ptr e &numero.",
                                "Alteração via *ptr modifica a variável original.",
                                "Endereços são válidos (não 0x0 ou lixo).",
                                "Teste com pelo menos 3 variáveis diferentes.",
                                "Uso correto de %p em printf."
                              ],
                              "assessmentCriteria": [
                                "Explicação precisa do operador & e ponteiros.",
                                "Código funcional sem erros de sintaxe ou runtime.",
                                "Demonstração de impressão e manipulação correta de endereço.",
                                "Identificação de erros comuns em códigos de pares.",
                                "Aplicação em contexto de passagem por referência.",
                                "Uso de debugger para validar endereços."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação hexadecimal de endereços.",
                                "Física: Conceitos de memória RAM e acessos binários.",
                                "Engenharia: Gerenciamento de memória em sistemas embarcados.",
                                "Lógica: Diagramas de fluxo para rastrear endereços."
                              ],
                              "realWorldApplication": "Essencial para implementação de listas encadeadas, árvores binárias, alocação dinâmica com malloc/free e passagem eficiente de parâmetros por referência em funções, otimizando performance em jogos, bancos de dados e sistemas operacionais."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Dereferenciar um ponteiro",
                            "description": "Utilizar o operador de dereferência (*) para acessar e modificar o valor armazenado no endereço apontado pelo ponteiro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de ponteiro e operador de dereferência",
                                  "subSteps": [
                                    "Estude a definição de ponteiro: variável que armazena endereço de memória.",
                                    "Identifique o operador * como dereferência, que acessa o valor no endereço.",
                                    "Diferencie declaração (* no tipo) de dereferência (* antes da variável).",
                                    "Revise operador & para obter endereço.",
                                    "Analise diagrama de memória com variável, endereço e ponteiro."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre ponteiro e dereferência, com exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de C sobre ponteiros",
                                    "Editor de texto para anotações",
                                    "Diagrama de memória impresso ou digital"
                                  ],
                                  "tips": "Use desenhos de setas para visualizar endereço → ponteiro → valor.",
                                  "learningObjective": "Entender o papel do operador * na dereferência.",
                                  "commonMistakes": [
                                    "Confundir * na declaração com dereferência",
                                    "Esquecer que ponteiro não inicializado é perigoso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e inicializar um ponteiro corretamente",
                                  "subSteps": [
                                    "Declare uma variável inteira: int x = 5;",
                                    "Declare ponteiro: int *p;",
                                    "Inicialize ponteiro com endereço: p = &x;",
                                    "Verifique se o ponteiro aponta para endereço válido usando printf(\"%p\", p);",
                                    "Evite ponteiros nulos: if(p != NULL)."
                                  ],
                                  "verification": "Compile e execute código que imprime o endereço sem erros de segmentação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C (GCC)",
                                    "Editor de código (VS Code ou similar)"
                                  ],
                                  "tips": "Sempre inicialize ponteiros para evitar undefined behavior.",
                                  "learningObjective": "Criar ponteiros válidos apontando para memória acessível.",
                                  "commonMistakes": [
                                    "Usar ponteiro não inicializado",
                                    "Confundir &x com x"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dereferenciar ponteiro para ler o valor armazenado",
                                  "subSteps": [
                                    "Escreva printf(\"%d\", *p); para acessar valor via ponteiro.",
                                    "Compare printf(\"%d\", x); e printf(\"%d\", *p); para verificar igualdade.",
                                    "Teste com múltiplas variáveis e ponteiros.",
                                    "Use debugger para inspecionar valor em *p.",
                                    "Registre saída no console."
                                  ],
                                  "verification": "Saída do programa mostra valor correto de x via *p.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Lembre-se: *p é sinônimo de x quando p = &x.",
                                  "learningObjective": "Acessar valores indiretos via ponteiro.",
                                  "commonMistakes": [
                                    "Dereferenciar ponteiro NULL",
                                    "Imprimir ponteiro com %d em vez de %p"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dereferenciar ponteiro para modificar o valor original",
                                  "subSteps": [
                                    "Atribua novo valor: *p = 10;",
                                    "Verifique mudança em x: printf(\"%d\", x); deve mostrar 10.",
                                    "Teste em loop: alterne valores via *p e observe efeitos.",
                                    "Compare com atribuição direta x = 10.",
                                    "Compile e execute para confirmação."
                                  ],
                                  "verification": "Variável original x é alterada após *p = novo_valor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de código"
                                  ],
                                  "tips": "Isso demonstra passagem por referência em funções.",
                                  "learningObjective": "Modificar memória via ponteiro.",
                                  "commonMistakes": [
                                    "Achar que *p cria cópia em vez de modificar original"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar dereferência em contexto de função",
                                  "subSteps": [
                                    "Crie função void incrementa(int *p) { *p += 1; }",
                                    "Chame de main: int x=5; incrementa(&x); printf(\"%d\", x); //6",
                                    "Teste com múltiplos parâmetros ponteiro.",
                                    "Analise stack frame no debugger.",
                                    "Refatore código anterior para usar função."
                                  ],
                                  "verification": "Função modifica variável original via ponteiro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C com suporte a debug (GDB)",
                                    "Editor avançado"
                                  ],
                                  "tips": "Ponteiros permitem passagem por referência em C.",
                                  "learningObjective": "Integrar dereferência em subprogramas.",
                                  "commonMistakes": [
                                    "Passar x em vez de &x",
                                    "Não dereferenciar dentro da função"
                                  ]
                                }
                              ],
                              "practicalExample": "```c\n#include <stdio.h>\nint main() {\n    int x = 10;\n    int *p = &x;\n    printf(\"Valor via variavel: %d\\n\", x);      // 10\n    printf(\"Valor via ponteiro: %d\\n\", *p);    // 10\n    *p = 20;\n    printf(\"Novo valor via variavel: %d\\n\", x); // 20\n    return 0;\n}\n``` Saída demonstra leitura e modificação.",
                              "finalVerifications": [
                                "Explicar diferença entre p e *p.",
                                "Escrever código que modifica variável via ponteiro sem erros.",
                                "Identificar e corrigir código com dereferência inválida.",
                                "Usar em função para passagem por referência.",
                                "Visualizar memória com diagrama correto.",
                                "Executar programa sem warnings ou crashes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação conceitual (80%+ correto).",
                                "Código compila e executa com saídas esperadas.",
                                "Uso correto de operadores * e &.",
                                "Identificação de erros comuns em exemplos dados.",
                                "Aplicação em função com modificação bem-sucedida.",
                                "Diagrama de memória claro e preciso."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como coordenadas em espaço de memória.",
                                "Física: Analogia com ponteiros laser apontando para objetos.",
                                "Lógica e Algoritmos: Indireção em estruturas de dados.",
                                "Engenharia: Gerenciamento de memória em sistemas embarcados."
                              ],
                              "realWorldApplication": "Em listas ligadas (next pointer dereferenciado para nó seguinte), alocação dinâmica (malloc retorna ponteiro dereferenciado), gráficos (acesso a vértices via ponteiro), e otimização de performance em jogos e bancos de dados."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Mecanismo de Passagem por Referência",
                        "description": "Processo pelo qual o endereço de memória do argumento é copiado para o parâmetro formal da sub-rotina, permitindo que alterações no parâmetro afetem a variável original.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Definir parâmetros por referência em funções",
                            "description": "Especificar parâmetros formais como referências ou ponteiros em uma função (ex.: usando & em C++ ou * em C), garantindo que recebam endereços.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Passagem por Valor e a Necessidade de Referência",
                                  "subSteps": [
                                    "Revise como a passagem por valor cria cópias locais dos argumentos, impedindo modificações no chamador.",
                                    "Identifique cenários onde modificações são necessárias, como trocar valores entre variáveis.",
                                    "Compare com passagem por referência, que usa aliases para acessar a memória original.",
                                    "Estude diagramas de pilha de memória para visualizar endereços vs. valores.",
                                    "Discuta limitações da passagem por valor em termos de eficiência e funcionalidade."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre passagem por valor e referência, com um exemplo de código que falha por valor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Documentação C/C++ online",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Desenhe pilhas de memória para visualizar: valor copia dados, referência aponta para o original.",
                                  "learningObjective": "Diferenciar passagem por valor de referência e identificar quando usar referência.",
                                  "commonMistakes": [
                                    "Achar que passagem por valor sempre modifica o original",
                                    "Confundir referência com cópia de endereço"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Sintaxe de Parâmetros por Referência em C++",
                                  "subSteps": [
                                    "Memorize a sintaxe: void func(int &param) {} onde & indica referência.",
                                    "Compare com C usando ponteiros: void func(int *param) {} e passagem de &var.",
                                    "Pratique declarando funções simples com 1-2 parâmetros por referência.",
                                    "Analise erros comuns de sintaxe, como esquecer o & ou usar * incorretamente.",
                                    "Teste compilação de snippets básicos no compilador."
                                  ],
                                  "verification": "Escreva e compile uma função vazia com parâmetro por referência sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C++ (g++)",
                                    "IDE como Code::Blocks",
                                    "Referência rápida de sintaxe C++"
                                  ],
                                  "tips": "Lembre-se: & em C++ é referência (alias), * em C é ponteiro (endereço explícito).",
                                  "learningObjective": "Dominar a sintaxe exata para definir parâmetros por referência em C++ e ponteiros em C.",
                                  "commonMistakes": [
                                    "Usar & no argumento ao chamar (não necessário em C++)",
                                    "Confundir & com endereço (&var)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Funções com Parâmetros por Referência",
                                  "subSteps": [
                                    "Crie uma função swap(int &a, int &b) que troca valores usando uma temp.",
                                    "Implemente uma função increment(int &x) que aumenta x em 1.",
                                    "Chame as funções no main() passando variáveis comuns e verifique modificações.",
                                    "Adapte para C usando ponteiros: swap(int *a, int *b) com *a e *b.",
                                    "Adicione prints antes/depois para observar mudanças na memória."
                                  ],
                                  "verification": "Execute o código e confirme que variáveis no main() são modificadas após a chamada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador g++",
                                    "Terminal para execução",
                                    "Debugger opcional (gdb)"
                                  ],
                                  "tips": "Sempre inicialize variáveis no main() para testes claros; use cout para depuração.",
                                  "learningObjective": "Implementar funções funcionais que modificam variáveis via referência.",
                                  "commonMistakes": [
                                    "Esquecer de desreferenciar ponteiros em C (*a = *b)",
                                    "Passar literais como argumentos (int x = 5; func(x))"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Otimizar Funções por Referência",
                                  "subSteps": [
                                    "Teste casos edge: valores zero, negativos, ponteiros nulos em C.",
                                    "Use debugger para inspecionar endereços (&var) e valores.",
                                    "Otimize evitando cópias desnecessárias em funções grandes.",
                                    "Refatore uma função por valor existente para usar referência.",
                                    "Documente o código com comentários explicando o & ou *."
                                  ],
                                  "verification": "Código passa em 5 testes unitários variados sem crashes ou erros lógicos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Testes unitários simples (assert ou if)",
                                    "Debugger gdb",
                                    "Exemplos de código anteriores"
                                  ],
                                  "tips": "Evite retornar referências locais (dangling refs); foque em parâmetros.",
                                  "learningObjective": "Depurar e validar funções por referência em cenários reais.",
                                  "commonMistakes": [
                                    "Modificar referência acidentalmente",
                                    "Usar referência em arrays (use ponteiros)"
                                  ]
                                }
                              ],
                              "practicalExample": "Função swap em C++: void swap(int &a, int &b) { int temp = a; a = b; b = temp; } No main: int x=10, y=20; swap(x,y); // Agora x=20, y=10. Em C: void swap(int *a, int *b) { int temp=*a; *a=*b; *b=temp; } swap(&x, &y);",
                              "finalVerifications": [
                                "Escreve uma função que modifica múltiplos parâmetros por referência corretamente.",
                                "Explica a diferença de memória entre & em C++ e * em C.",
                                "Compila e executa código sem warnings de referência não inicializada.",
                                "Identifica e corrige um bug em código por valor convertido para referência.",
                                "Demonstra eficiência: sem cópias extras em funções com structs grandes.",
                                "Usa debugger para mostrar endereço igual entre argumento e parâmetro."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa: & ou * usado corretamente em 100% dos parâmetros.",
                                "Funcionalidade: Modificações refletem no chamador em todos os testes.",
                                "Eficiência: Nenhuma cópia desnecessária de dados grandes.",
                                "Robustez: Trata casos edge sem segfaults ou undefined behavior.",
                                "Clareza: Código comentado e legível, com nomes descritivos.",
                                "Correção: Compila sem erros/warnings em g++ padrão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de funções injetivas e endereços como mapeamentos.",
                                "Física: Analogia com forças que afetam objetos reais vs. sombras.",
                                "Lógica: Evitar mutabilidade excessiva como em programação funcional.",
                                "Administração: Otimização de recursos (memória como orçamento).",
                                "Design: Padrões de interface limpa em APIs."
                              ],
                              "realWorldApplication": "Em jogos, modificar posições de objetos diretamente (ex.: player.x += speed via ref) sem copiar structs inteiros; em editores, alterar strings ou buffers em memória compartilhada para performance em apps como Photoshop ou navegadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Chamar função com passagem por referência",
                            "description": "Passar argumentos comuns para funções com parâmetros por referência, observando que o endereço é automaticamente fornecido pelo compilador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de passagem por valor e por referência",
                                  "subSteps": [
                                    "Diferencie passagem por valor (cópia do valor, alterações não afetam original) de passagem por referência (alias para a variável original, alterações afetam original).",
                                    "Analise exemplos simples de código em C++ para passagem por valor.",
                                    "Analise exemplos de código com referência usando '&' na declaração do parâmetro.",
                                    "Explique como o compilador fornece automaticamente o endereço sem necessidade de '&' na chamada."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre diferenças entre os mecanismos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código como Code::Blocks ou VS Code",
                                    "Documentação C++ sobre referências (cppreference.com)"
                                  ],
                                  "tips": [
                                    "Visualize referência como um apelido para a variável, não uma cópia."
                                  ],
                                  "learningObjective": "Diferenciar e explicar passagem por valor e referência.",
                                  "commonMistakes": [
                                    "Confundir referência com ponteiro (referência não requer '*')",
                                    "Acreditar que sempre precisa passar endereço manualmente na chamada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma função com parâmetros por referência",
                                  "subSteps": [
                                    "Escreva a assinatura de uma função simples, como 'void incremento(int& valor)'.",
                                    "Implemente o corpo da função para modificar o parâmetro (ex: valor++).",
                                    "Compile o código para verificar sintaxe correta.",
                                    "Teste com main() passando uma variável por valor primeiro para comparar."
                                  ],
                                  "verification": "Função declara sem erros de compilação e altera variável corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C++ (g++)",
                                    "Ambiente online como Replit ou Compiler Explorer"
                                  ],
                                  "tips": [
                                    "Use sempre '&' apenas na declaração do parâmetro, não na chamada."
                                  ],
                                  "learningObjective": "Criar funções que modifiquem variáveis originais via referência.",
                                  "commonMistakes": [
                                    "Esquecer '&' na declaração",
                                    "Usar '&' na chamada da função"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Chamar a função passando argumentos comuns por referência",
                                  "subSteps": [
                                    "No main(), declare variáveis normais (ex: int x = 5).",
                                    "Chame a função sem '&' no argumento: incremento(x).",
                                    "Imprima o valor de x antes e depois para observar mudança.",
                                    "Experimente com múltiplos parâmetros por referência."
                                  ],
                                  "verification": "Variável original é modificada após a chamada da função.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Mesmo compilador e editor do step anterior",
                                    "Papel e caneta para diagramas de memória"
                                  ],
                                  "tips": [
                                    "O compilador cuida do endereço; foque no comportamento.",
                                    "Desenhe fluxogramas de memória para visualizar."
                                  ],
                                  "learningObjective": "Executar chamadas corretas observando modificações automáticas.",
                                  "commonMistakes": [
                                    "Passar endereço manualmente (&x na chamada)",
                                    "Esperar que funcione como cópia por valor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e debugar funções com passagem por referência",
                                  "subSteps": [
                                    "Crie uma função swap(int& a, int& b) para trocar valores.",
                                    "Chame swap em duas variáveis e verifique troca.",
                                    "Introduza erro intencional (sem '&') e corrija.",
                                    "Otimize com exemplo prático como função para somar a um acumulador."
                                  ],
                                  "verification": "Código completo compila, executa e produz saída esperada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Debugger integrado (GDB ou IDE)",
                                    "Exemplos de código prontos para modificação"
                                  ],
                                  "tips": [
                                    "Use debugger para inspecionar endereços e valores durante execução."
                                  ],
                                  "learningObjective": "Integrar e debugar chamadas por referência em programas reais.",
                                  "commonMistakes": [
                                    "Inicializar referências inválidas",
                                    "Ignorar warnings do compilador sobre referências"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar com cenários avançados e verificações finais",
                                  "subSteps": [
                                    "Implemente função que modifique string ou array via referência.",
                                    "Teste com const int& para parâmetros de leitura.",
                                    "Compare performance com cópias desnecessárias.",
                                    "Refatore código existente para usar referências onde apropriado."
                                  ],
                                  "verification": "Todos os testes passam sem vazamentos ou erros lógicos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Projeto de teste com múltiplas funções",
                                    "Ferramentas de profiling básicas"
                                  ],
                                  "tips": [
                                    "Prefira referências para evitar cópias caras de objetos grandes."
                                  ],
                                  "learningObjective": "Aplicar referências em contextos variados com boas práticas.",
                                  "commonMistakes": [
                                    "Usar referência não-const em parâmetros de entrada apenas",
                                    "Confundir com rvalue references (C++11+)"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo em C++:\n\nvoid swap(int& a, int& b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nint main() {\n    int x = 10, y = 20;\n    cout << \"Antes: x=\" << x << \", y=\" << y << endl;\n    swap(x, y);\n    cout << \"Depois: x=\" << x << \", y=\" << y << endl;  // x=20, y=10\n    return 0;\n}\nO compilador passa os endereços automaticamente na chamada swap(x, y).",
                              "finalVerifications": [
                                "O código compila sem erros de sintaxe relacionados a referências.",
                                "Variáveis originais são modificadas após chamadas de funções.",
                                "Não há uso incorreto de '&' nas chamadas (apenas na declaração).",
                                "Testes com múltiplos parâmetros funcionam corretamente.",
                                "Debugger confirma que endereços são os mesmos dentro e fora da função.",
                                "Função com const int& compila e não permite modificação.",
                                "Performance é melhor que cópia por valor para objetos grandes."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta de declaração e chamada (100% precisão).",
                                "Comportamento observado: modificação persiste no escopo chamador (verificado em testes).",
                                "Ausência de erros comuns como cópias desnecessárias ou referências pendentes.",
                                "Explicação clara do papel do compilador no fornecimento de endereços.",
                                "Capacidade de debugar e corrigir problemas em 2 minutos por erro.",
                                "Integração em programa maior sem side-effects indesejados.",
                                "Uso apropriado de const para parâmetros de leitura (boas práticas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de funções como transformações em variáveis (álgebra).",
                                "Física: Simulações onde estados (posição, velocidade) são atualizados via referências.",
                                "Design de Software: Princípios de modularidade e encapsulamento em subprogramas.",
                                "Lógica e Algoritmos: Otimização de passagem de parâmetros em recursão.",
                                "Banco de Dados: Atualizações em cursores ou handles sem cópias."
                              ],
                              "realWorldApplication": "Em jogos, atualizar posições de objetos diretamente (ex: player.move() altera coordenadas reais sem recópia). Em sistemas bancários, funções que debitam/créditam saldos de contas via referência evitam erros de sincronização e otimizam performance em transações de alto volume."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Verificar modificação da variável original",
                            "description": "Implementar e testar código que demonstre como alterações nos parâmetros por referência modificam os valores das variáveis argumentos no escopo chamador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de passagem por referência",
                                  "subSteps": [
                                    "Estude a diferença entre passagem por valor e por referência, focando em como a referência atua como um alias da variável original.",
                                    "Leia exemplos na documentação da linguagem (ex: C++ com '&' ou Python com objetos mutáveis).",
                                    "Anote em suas palavras: o que acontece com a variável original quando modificada dentro da função?",
                                    "Compare com passagem por valor usando diagramas mentais de memória.",
                                    "Responda a perguntas de autoavaliação: 'Por que a modificação persiste após a chamada?'"
                                  ],
                                  "verification": "Escreva um parágrafo explicando o conceito e a diferença com passagem por valor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem (C++ ou similar)",
                                    "Bloco de notas ou editor de texto",
                                    "Vídeo tutorial curto sobre referências"
                                  ],
                                  "tips": "Visualize a referência como um ponteiro para o endereço da variável original, não uma cópia.",
                                  "learningObjective": "Diferenciar passagem por valor e referência, entendendo o impacto na variável original.",
                                  "commonMistakes": [
                                    "Confundir referência com cópia de valor",
                                    "Ignorar que referências não podem ser nulas em C++",
                                    "Esquecer que objetos mutáveis em Python se comportam similarmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar uma função com parâmetro por referência",
                                  "subSteps": [
                                    "Crie um programa base com uma variável no escopo principal (ex: int x = 5;).",
                                    "Defina uma função que receba parâmetro por referência (ex: void modificar(int& ref) { ref += 10; }).",
                                    "Compile o código inicial sem chamar a função para verificar sintaxe.",
                                    "Adicione prints ou saídas para mostrar o valor antes da modificação.",
                                    "Teste a compilação e corrija erros de sintaxe relacionados a referências."
                                  ],
                                  "verification": "O código compila sem erros e exibe o valor inicial corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Code::Blocks)",
                                    "Compilador C++ (g++)",
                                    "Exemplo de código boilerplate"
                                  ],
                                  "tips": "Sempre use '&' explicitamente no parâmetro para clareza em C++; evite funções void desnecessárias.",
                                  "learningObjective": "Criar uma função que utilize passagem por referência corretamente.",
                                  "commonMistakes": [
                                    "Esquecer o '&' no parâmetro",
                                    "Modificar sem inicializar a variável",
                                    "Usar tipo errado (ponteiro vs referência)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Chamar a função e verificar a modificação da variável original",
                                  "subSteps": [
                                    "Chame a função passando a variável original (ex: modificar(x);).",
                                    "Adicione saída após a chamada para imprimir o novo valor (ex: cout << x;).",
                                    "Execute o programa e confirme que o valor original foi alterado.",
                                    "Use um debugger para inspecionar o endereço de memória da variável antes e depois.",
                                    "Repita com múltiplas chamadas para observar acumulatividade das mudanças."
                                  ],
                                  "verification": "A saída mostra que o valor da variável no escopo chamador foi modificado após a chamada da função.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador com suporte a debug (gdb)",
                                    "Editor com debugger integrado"
                                  ],
                                  "tips": "Use breakpoints no debugger para pausar e inspecionar valores em tempo real.",
                                  "learningObjective": "Observar e confirmar empiricamente a modificação da variável original via referência.",
                                  "commonMistakes": [
                                    "Passar cópia acidentalmente",
                                    "Não imprimir após a chamada",
                                    "Ignorar warnings do compilador sobre referências"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar cenários avançados e contrastar com passagem por valor",
                                  "subSteps": [
                                    "Implemente a mesma função com passagem por valor e compare saídas.",
                                    "Teste com arrays ou structs por referência para generalizar.",
                                    "Crie unit tests automatizados (ex: assert(x == 15) após modificações).",
                                    "Analise performance: discuta por que referência evita cópias desnecessárias.",
                                    "Documente os resultados em um relatório curto com capturas de tela."
                                  ],
                                  "verification": "Testes passam e relatório explica diferenças observadas entre por valor e por referência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Framework de testes simples (Google Test ou asserts manuais)",
                                    "Planilha para log de testes"
                                  ],
                                  "tips": "Comece com casos simples antes de complexos; sempre limpe variáveis entre testes.",
                                  "learningObjective": "Aplicar o conceito em cenários variados e validar robustez.",
                                  "commonMistakes": [
                                    "Não resetar variáveis entre testes",
                                    "Confundir arrays (sempre por referência em C)",
                                    "Sobrecarregar com casos irrelevantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em C++:\n\n#include <iostream>\nusing namespace std;\n\nvoid dobra(int& valor) {\n    valor *= 2;\n}\n\nint main() {\n    int numero = 5;\n    cout << \"Antes: \" << numero << endl;  // 5\n    dobra(numero);\n    cout << \"Depois: \" << numero << endl; // 10\n    return 0;\n}\n\nA variável 'numero' no main é modificada permanentemente.",
                              "finalVerifications": [
                                "A variável original no escopo chamador apresenta o valor modificado após a execução da função.",
                                "Uso de debugger confirma que o mesmo endereço de memória é acessado dentro e fora da função.",
                                "Comparação com versão por valor mostra ausência de mudança na original.",
                                "Código executa sem erros de compilação ou runtime relacionados a referências.",
                                "Múltiplas chamadas acumulam modificações corretamente.",
                                "Testes unitários passam para pelo menos 3 cenários diferentes."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual: Explicação precisa da modificação por referência (80% acerto em quiz).",
                                "Implementação funcional: Código compila e produz saída esperada em todos os testes.",
                                "Qualidade do código: Uso limpo de referências, sem vazamentos ou warnings.",
                                "Análise crítica: Identificação correta de erros comuns e contrastes com por valor.",
                                "Documentação: Relatório claro com evidências (prints, diagramas).",
                                "Eficiência: Evidência de compreensão de benefícios (ex: performance em grandes dados)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções como transformações mutáveis em conjuntos.",
                                "Lógica e Raciocínio: Dedução de fluxos de memória e causalidade.",
                                "Física: Modelagem de estados mutáveis em simulações (ex: posição de partículas).",
                                "Engenharia: Otimização de passagem de dados em sistemas embarcados.",
                                "Banco de Dados: Atualizações em transações ACID via referências."
                              ],
                              "realWorldApplication": "Em jogos, modificar a saúde de um personagem diretamente (ex: void dano(Jogador& player) { player.vida -= 10; }) sem copiar todo o objeto, otimizando performance em engines como Unity ou Unreal."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Diferenças e Aplicações da Passagem por Referência",
                        "description": "Comparação com a passagem por valor, destacando vantagens como eficiência em grandes estruturas de dados e riscos como aliasing, além de cenários de uso apropriados.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Comparar passagem por valor e por referência",
                            "description": "Analisar exemplos de código para distinguir os efeitos de cada mecanismo, identificando quando a cópia é feita versus quando o endereço é passado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Passagem por Valor",
                                  "subSteps": [
                                    "Defina passagem por valor: uma cópia do valor do argumento é passada para o parâmetro da função.",
                                    "Analise um exemplo simples em pseudocódigo: função que recebe um inteiro e o incrementa internamente.",
                                    "Visualize na memória: o parâmetro recebe uma cópia independente do argumento original.",
                                    "Execute mentalmente: modifique o parâmetro e observe que o argumento original permanece inalterado.",
                                    "Registre a mudança na pilha de execução para passagem por valor."
                                  ],
                                  "verification": "Crie um diagrama simples da memória mostrando que o original não muda após a chamada da função.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": [
                                    "Sempre desenhe a memória para visualizar cópias.",
                                    "Use variáveis primitivas como inteiros para exemplos iniciais."
                                  ],
                                  "learningObjective": "Compreender que passagem por valor cria uma cópia independente, sem afetar o original.",
                                  "commonMistakes": [
                                    "Confundir com atribuição de variáveis locais.",
                                    "Achar que modificações sempre afetam o chamador."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Passagem por Referência",
                                  "subSteps": [
                                    "Defina passagem por referência: o endereço de memória do argumento é passado para o parâmetro.",
                                    "Analise um exemplo em pseudocódigo usando ponteiros ou referências: função que modifica uma variável via endereço.",
                                    "Visualize na memória: parâmetro aponta para o mesmo local do argumento original.",
                                    "Execute mentalmente: modifique via parâmetro e confirme alteração no original.",
                                    "Compare com ponteiros em linguagens como C ou referências em C++."
                                  ],
                                  "verification": "Desenhe um diagrama da memória mostrando ponteiro apontando para o original e modificação refletida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Editor de texto para pseudocódigo com ponteiros"
                                  ],
                                  "tips": [
                                    "Pense em 'endereço' como um ponteiro para o original.",
                                    "Evite confundir com passagem de objetos em Python."
                                  ],
                                  "learningObjective": "Compreender que passagem por referência permite modificações no original via endereço compartilhado.",
                                  "commonMistakes": [
                                    "Ignorar desreferenciação (ex: *ptr em C).",
                                    "Achar que sempre copia o valor do ponteiro."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar os Dois Mecanismos com Exemplos Paralelos",
                                  "subSteps": [
                                    "Escreva funções idênticas lado a lado: uma por valor e outra por referência, com o mesmo incremento.",
                                    "Compile e execute ambos em um ambiente simulado ou IDE (ex: C++).",
                                    "Registre saídas: confirme que por valor não altera original, por referência altera.",
                                    "Analise overhead: cópia por valor vs. apenas endereço por referência.",
                                    "Discuta cenários: quando usar cada (ex: leitura vs. escrita)."
                                  ],
                                  "verification": "Produza um relatório curto com códigos, saídas e diagramas comparativos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "IDE como Code::Blocks ou online como Replit",
                                    "Pseudocódigo comparativo"
                                  ],
                                  "tips": [
                                    "Use printf ou cout para imprimir antes/depois.",
                                    "Teste com tipos compostos como arrays para referência."
                                  ],
                                  "learningObjective": "Distinguir efeitos práticos e identificar mecanismos em código.",
                                  "commonMistakes": [
                                    "Esquecer de imprimir o original após chamada.",
                                    "Confundir sintaxe de referência com valor."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Identificar em Códigos Reais",
                                  "subSteps": [
                                    "Receba exemplos de código mistos e identifique declaração de parâmetros (ex: int& vs int).",
                                    "Trace execução passo a passo com debugger ou manualmente.",
                                    "Classifique cada função como por valor ou referência e preveja efeitos.",
                                    "Corrija códigos errados: converta valor para referência onde modificação é necessária.",
                                    "Debata trade-offs: performance, segurança e legibilidade."
                                  ],
                                  "verification": "Analise 3 códigos fornecidos e acerte 100% na identificação e previsão de saída.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de código prontos",
                                    "Debugger em IDE"
                                  ],
                                  "tips": [
                                    "Procure símbolos como &, *, & na declaração.",
                                    "Sempre trace o fluxo de dados na memória."
                                  ],
                                  "learningObjective": "Identificar e analisar mecanismos em código real, prevendo comportamentos.",
                                  "commonMistakes": [
                                    "Não notar passagem implícita em arrays.",
                                    "Ignorar convenções de linguagem específicas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em C++: void porValor(int x) { x++; } vs void porRef(int& x) { x++; }. Chame com int a=5; porValor(a); //a=5 vs porRef(a); //a=6. Demonstra distinção clara em modificação.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença com diagrama de memória.",
                                "Prever saída de 5 códigos mistos corretamente.",
                                "Converter função por valor para referência sem erros.",
                                "Identificar overhead de cada em cenários de performance.",
                                "Discutir quando evitar referência (ex: funções puras)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção conceitual (90%+).",
                                "Correção em análises de código (todos os exemplos).",
                                "Qualidade de diagramas de memória.",
                                "Compreensão de trade-offs práticos.",
                                "Criatividade em exemplos personalizados.",
                                "Clareza na explicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como funções de mapeamento memória.",
                                "Algoritmos: Impacto na complexidade de tempo/espaço.",
                                "Estruturas de Dados: Referências em listas ligadas.",
                                "Lógica: Predicados de mutabilidade vs imutabilidade."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usar por referência para eficiência em grandes estruturas (ex: vetores em simulações), evitando cópias desnecessárias; por valor para segurança em funções de cálculo puro, prevenindo efeitos colaterais inesperados em equipes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Identificar usos apropriados da passagem por referência",
                            "description": "Determinar cenários ideais para passagem por referência, como modificação de variáveis grandes ou múltiplas saídas de uma função, evitando uso desnecessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de passagem por valor e por referência",
                                  "subSteps": [
                                    "Defina passagem por valor: cópia do valor é passada, alterações não afetam o original.",
                                    "Defina passagem por referência: endereço da variável é passado, alterações afetam o original.",
                                    "Compare com exemplos simples em linguagens como Python (listas mutáveis) ou C++ (ponteiros).",
                                    "Desenhe diagramas de pilha e heap para visualizar a diferença.",
                                    "Liste prós e contras de cada abordagem."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença com um exemplo correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação oficial da linguagem (Python/C++), papel e caneta para diagramas.",
                                  "tips": "Use ferramentas online como Python Tutor para simular execução.",
                                  "learningObjective": "Diferenciar precisamente passagem por valor de por referência.",
                                  "commonMistakes": "Assumir que todas as linguagens se comportam igual; ignorar mutabilidade de tipos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar vantagens e desvantagens da passagem por referência",
                                  "subSteps": [
                                    "Identifique vantagens: eficiência com dados grandes, modificação direta, simulação de múltiplos retornos.",
                                    "Liste desvantagens: efeitos colaterais inesperados, difícil depuração, quebra de imutabilidade.",
                                    "Calcule overhead: compare tempo/memória para passar int vs array de 1MB.",
                                    "Discuta quando eficiência importa (ex: loops intensivos).",
                                    "Crie tabela comparativa de cenários."
                                  ],
                                  "verification": "Criar tabela com pelo menos 4 vantagens/desvantagens corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto ou planilha (Google Sheets), exemplos de código.",
                                  "tips": "Meça tempo real de execução com funções de benchmark.",
                                  "learningObjective": "Avaliar trade-offs da passagem por referência.",
                                  "commonMistakes": "Superestimar ganhos de performance em dados pequenos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar cenários ideais para uso de passagem por referência",
                                  "subSteps": [
                                    "Liste cenários: modificar estruturas grandes (listas, objetos), funções com múltiplas saídas.",
                                    "Exemplo: função swap(a, b) por referência para trocar valores.",
                                    "Exemplo: função append_to_list(lista) que adiciona itens in-place.",
                                    "Analise código: dado um snippet, decida se referência é apropriada e justifique.",
                                    "Crie 3 exemplos próprios de uso apropriado."
                                  ],
                                  "verification": "Classificar 5 cenários fornecidos como 'apropriado' ou 'inapropriado' com justificativa.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Snippets de código de exemplo, IDE para testes.",
                                  "tips": "Pergunte: 'A função precisa modificar o original ou retornar novo valor?'",
                                  "learningObjective": "Reconhecer contextos onde referência otimiza e é segura.",
                                  "commonMistakes": "Usar referência para tudo, ignorando legibilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em cenários reais e evitar usos desnecessários",
                                  "subSteps": [
                                    "Analise códigos ruins: refatorar função que usa referência para int simples.",
                                    "Identifique anti-padrões: funções puras que alteram estado global.",
                                    "Crie fluxograma de decisão: 'Dados grandes? Múltiplas mods? Sim -> referência'.",
                                    "Teste em projeto: aplique em função existente e meça impacto.",
                                    "Revise pares de código (valor vs referência) e escolha melhor."
                                  ],
                                  "verification": "Refatorar 2 códigos com decisão correta e explicação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Projeto de código simples (ex: gerenciador de lista), debugger.",
                                  "tips": "Priorize legibilidade sobre micro-otimizações.",
                                  "learningObjective": "Decidir apropriadamente evitando overuse.",
                                  "commonMistakes": "Usar referência por hábito em vez de necessidade."
                                }
                              ],
                              "practicalExample": "Em Python, função para processar uma lista grande de usuários: def process_users(users): users.append(novo_usuario)  # Modifica lista original, eficiente para 10k+ itens, evitando cópia desnecessária.",
                              "finalVerifications": [
                                "Explicar 3 cenários ideais para referência com exemplos de código.",
                                "Identificar incorretamente uso em 80% dos casos de teste fornecidos.",
                                "Refatorar snippet usando referência apropriadamente sem efeitos colaterais.",
                                "Calcular economia de memória em exemplo com array grande.",
                                "Criar fluxograma de decisão pessoal correto.",
                                "Discutir trade-offs em relatório curto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (90% acerto).",
                                "Justificativas claras e baseadas em performance/legibilidade.",
                                "Uso correto de exemplos concretos sem erros conceituais.",
                                "Análise de trade-offs abrangente.",
                                "Criatividade em exemplos próprios acionáveis.",
                                "Ausência de common mistakes identificados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de endereços e ponteiros como funções lineares.",
                                "Design de Software: Princípios SOLID e imutabilidade funcional.",
                                "Eficiência Computacional: Algoritmos e complexidade Big O.",
                                "Lógica e Raciocínio: Tomada de decisão baseada em critérios."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps web (ex: atualizar banco de dados sem copiar queries grandes), jogos (modificar estado do jogador compartilhado) ou APIs (processar payloads JSON grandes in-place para performance)."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Escopo de Variáveis",
                    "description": "Regras de visibilidade, acessibilidade e tempo de vida das variáveis em subprogramas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Visibilidade de Variáveis",
                        "description": "Regras que definem as regiões do código onde uma variável declarada em subprogramas pode ser vista e referenciada, incluindo escopo local, global e de parâmetros.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Identificar escopo local em subprogramas",
                            "description": "Reconhecer que variáveis declaradas dentro de um subprograma (função ou procedimento) são visíveis apenas dentro desse subprograma e não em outros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de escopo local",
                                  "subSteps": [
                                    "Estude a definição de escopo: região do código onde uma variável é visível e acessível.",
                                    "Diferencie escopo local (dentro de função/procedimento) de escopo global (fora).",
                                    "Leia exemplos de documentação sobre visibilidade de variáveis em linguagens como Python ou Pascal.",
                                    "Anote as regras: variáveis locais morrem ao sair do subprograma.",
                                    "Discuta com um colega ou tutor o porquê de limitar a visibilidade."
                                  ],
                                  "verification": "Explique em suas palavras o que é escopo local e dê um exemplo verbal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagem de programação (ex: Python docs)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'quarto privado' para variáveis locais.",
                                  "learningObjective": "Definir e diferenciar escopo local de outros escopos.",
                                  "commonMistakes": [
                                    "Confundir escopo local com global",
                                    "Achar que variáveis locais persistem após a função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar exemplos de código com escopo local",
                                  "subSteps": [
                                    "Examine um código simples com variável declarada dentro de uma função.",
                                    "Identifique todas as variáveis locais no código fornecido.",
                                    "Tente acessar a variável local fora da função e observe o erro.",
                                    "Compare com uma variável global no mesmo código.",
                                    "Marque no código as regiões de visibilidade com setas ou highlights."
                                  ],
                                  "verification": "Apresente o código anotado mostrando regiões de escopo local.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Exemplos de código prontos"
                                  ],
                                  "tips": "Execute o código passo a passo usando debugger para ver o escopo.",
                                  "learningObjective": "Reconhecer visualmente variáveis locais em código fonte.",
                                  "commonMistakes": [
                                    "Ignorar blocos aninhados",
                                    "Não testar o acesso fora da função"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e testar código próprio com escopo local",
                                  "subSteps": [
                                    "Escreva uma função simples que declare uma variável local.",
                                    "Chame a função e tente imprimir a variável fora dela.",
                                    "Corrija erros de escopo passando parâmetros se necessário.",
                                    "Adicione múltiplas funções e verifique independência de variáveis locais.",
                                    "Teste com chamadas recursivas para reforçar o conceito."
                                  ],
                                  "verification": "Execute o código e demonstre erro ao acessar variável local externamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente de programação online (ex: Replit)",
                                    "Templates de código"
                                  ],
                                  "tips": "Comece com funções pequenas para evitar complexidade.",
                                  "learningObjective": "Implementar e validar escopo local em código prático.",
                                  "commonMistakes": [
                                    "Declarar variável global por engano",
                                    "Esquecer de indentar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e debugar cenários reais de escopo",
                                  "subSteps": [
                                    "Analise um código com erro de escopo local comum (ex: ReferenceError).",
                                    "Identifique o problema e reescreva usando escopo local correto.",
                                    "Crie um programa com várias funções compartilhando nomes de variáveis locais.",
                                    "Verifique se não há vazamento de escopo entre funções.",
                                    "Documente lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Submeta código corrigido sem erros de escopo e relatório.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Códigos com bugs intencionais",
                                    "Ferramenta de linting (ex: pylint)"
                                  ],
                                  "tips": "Use print statements para rastrear valores durante execução.",
                                  "learningObjective": "Diagnosticar e resolver problemas de visibilidade local.",
                                  "commonMistakes": [
                                    "Não usar parâmetros para compartilhar dados",
                                    "Reutilizar nomes globalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\n\ndef calcular_idade(anos):\n    idade_futura = anos + 10  # Variável local\n    print(idade_futura)\n\ncalcular_idade(20)\nprint(idade_futura)  # Erro: NameError, pois idade_futura é local à função.",
                              "finalVerifications": [
                                "Explicar verbalmente por que uma variável local não é acessível fora da função.",
                                "Identificar corretamente todas as variáveis locais em um código de 20 linhas.",
                                "Executar e corrigir um código com erro de escopo local.",
                                "Diferenciar escopo local de parâmetros e globais em exemplos mistos.",
                                "Criar uma função com variável local sem vazamentos de escopo.",
                                "Discutir vantagens do escopo local em um contexto de programa maior."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de escopo local (100% correto).",
                                "Capacidade de explicar conceito com exemplos próprios.",
                                "Código produzido executa sem erros de visibilidade.",
                                "Uso correto de substeps em análises e criações.",
                                "Relatório demonstra compreensão de erros comuns.",
                                "Tempo de resolução de debugs abaixo de 10 minutos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com domínio de funções matemáticas limitadas.",
                                "Lógica e Filosofia: Conceito de encapsulamento e modularidade.",
                                "Engenharia: Princípios de design modular em sistemas.",
                                "Linguagem Portuguesa: Precisão terminológica em definições técnicas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, o escopo local previne conflitos de nomes em equipes grandes, permitindo módulos independentes como funções de autenticação ou cálculos isolados em apps bancários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Diferenciar escopo local de global",
                            "description": "Comparar a visibilidade de variáveis locais (limitadas ao subprograma) com variáveis globais (visíveis em todo o programa, incluindo subprogramas).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito básico de escopo de variáveis",
                                  "subSteps": [
                                    "Defina escopo como a região do código onde uma variável pode ser acessada.",
                                    "Explique que o escopo determina a visibilidade e vida útil de uma variável.",
                                    "Discuta por que o escopo é importante para evitar conflitos e bugs.",
                                    "Identifique tipos comuns de escopo: local e global.",
                                    "Revise a estrutura de um programa com subprogramas (funções ou procedimentos)."
                                  ],
                                  "verification": "Escreva uma definição curta de escopo e liste dois motivos para seu uso.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto ou IDE simples (ex: VS Code, IDLE Python)",
                                  "tips": "Use analogias como 'quarto local' vs 'casa inteira' para visualizar.",
                                  "learningObjective": "Compreender o escopo como delimitador de visibilidade de variáveis.",
                                  "commonMistakes": "Confundir escopo com tipo de dado ou valor da variável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar variáveis locais em subprogramas",
                                  "subSteps": [
                                    "Crie uma função simples que declare uma variável dentro dela.",
                                    "Tente acessar essa variável fora da função e observe o erro.",
                                    "Execute o código passo a passo usando um depurador.",
                                    "Modifique a função para retornar o valor e acesse fora dela.",
                                    "Crie duas funções com variáveis locais de mesmo nome para demonstrar independência."
                                  ],
                                  "verification": "Execute código onde uma variável local não é acessível fora da função, confirmando erro.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python instalado ou online IDE (Replit, Google Colab)",
                                  "tips": "Sempre declare variáveis dentro de funções para limitar seu escopo inicialmente.",
                                  "learningObjective": "Identificar e usar corretamente variáveis limitadas a subprogramas.",
                                  "commonMistakes": "Acessar variável local fora do subprograma sem retornar seu valor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar variáveis globais no programa principal",
                                  "subSteps": [
                                    "Declare uma variável no escopo principal (fora de funções).",
                                    "Acesse essa variável dentro de múltiplas funções.",
                                    "Modifique o valor global dentro de uma função usando 'global' keyword (em Python).",
                                    "Observe como mudanças propagam para todo o programa.",
                                    "Compare com o comportamento de variáveis locais."
                                  ],
                                  "verification": "Altere uma variável global em uma função e confirme que o valor muda no escopo principal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo IDE do passo anterior, com exemplos de código preparados",
                                  "tips": "Use 'print' statements para rastrear valores em diferentes escopos.",
                                  "learningObjective": "Demonstrar visibilidade e modificação de variáveis em todo o programa.",
                                  "commonMistakes": "Esquecer a palavra-chave 'global' ao modificar dentro de função, criando uma local acidental."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e diferenciar escopo local vs global",
                                  "subSteps": [
                                    "Crie um programa com ambas as variáveis e anote diferenças em uma tabela.",
                                    "Identifique em código fornecido qual variável é local ou global.",
                                    "Discuta prós e contras: local (segurança, modularidade) vs global (facilidade, risco de conflitos).",
                                    "Refatore código usando globais para locais onde possível.",
                                    "Teste cenários de conflito de nomes entre local e global."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e execute código sem erros de escopo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel ou planilha para tabela, código de exemplo misto",
                                  "tips": "Priorize locais para boas práticas; use globais só quando necessário (ex: configurações).",
                                  "learningObjective": "Diferenciar precisamente visibilidade local vs global com exemplos práticos.",
                                  "commonMistakes": "Achar que globais são sempre melhores ou ignorar riscos de mutação acidental."
                                }
                              ],
                              "practicalExample": "Em Python:\ndef funcao_local():\n    x_local = 10  # Local: só visível aqui\n    print(x_local)\n\nx_global = 5  # Global: visível em todo lugar\nfuncao_local()\nprint(x_global)  # Funciona\n#print(x_local)  # Erro! Não acessível.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre local e global sem hesitação.",
                                "Identificar corretamente escopo de 5 variáveis em um código dado.",
                                "Criar um programa funcional com 2 locais e 1 global sem erros.",
                                "Prever o output de um programa misto antes de executar.",
                                "Refatorar código com global desnecessário para local.",
                                "Discutir um risco de usar globais em equipe."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de escopo local/global (90%+ correto).",
                                "Capacidade de depurar erros de escopo em código fornecido.",
                                "Uso correto de keywords como 'global' em linguagens que exigem.",
                                "Tabela comparativa completa com prós/contras.",
                                "Código prático executável sem erros e bem comentado.",
                                "Explicação clara de aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com funções e domínios de definição.",
                                "Lógica: Encadeamento de regras de visibilidade como silogismos.",
                                "Inglês: Leitura e interpretação de documentação de linguagens.",
                                "Física: Modelos hierárquicos como sistemas locais vs globais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usar escopo local previne bugs em equipes grandes (ex: apps web como Django usam funções modulares); globais para configs compartilhadas (ex: API keys), mas com cuidado para evitar side-effects em sistemas distribuídos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Analisar visibilidade de parâmetros",
                            "description": "Determinar que parâmetros de funções são visíveis apenas dentro do subprograma e atuam como variáveis locais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de escopo e visibilidade",
                                  "subSteps": [
                                    "Defina escopo como a região do código onde uma variável é acessível.",
                                    "Explique visibilidade de parâmetros: eles são visíveis apenas dentro da função que os recebe.",
                                    "Diferencie variáveis locais (criadas dentro da função, incluindo parâmetros) de globais.",
                                    "Estude a definição de subprograma (função ou procedimento).",
                                    "Revise exemplos simples de funções sem parâmetros."
                                  ],
                                  "verification": "Resuma em suas palavras a diferença entre escopo local e global, citando parâmetros como exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de linguagem de programação (ex: Python docs sobre funções), editor de código.",
                                  "tips": "Use analogia: parâmetros são como convidados em uma festa (visíveis só dentro da casa/função).",
                                  "learningObjective": "Entender que parâmetros têm escopo local por definição.",
                                  "commonMistakes": "Confundir parâmetros com variáveis globais; achar que parâmetros persistem após a função terminar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar parâmetros em código de função",
                                  "subSteps": [
                                    "Analise a assinatura de uma função: def func(parametro):",
                                    "Marque todos os parâmetros na definição da função.",
                                    "Trace o uso do parâmetro dentro do corpo da função.",
                                    "Anote onde o parâmetro é lido ou modificado.",
                                    "Compare com variáveis locais declaradas dentro da função (ex: x = 5)."
                                  ],
                                  "verification": "Destaque em um código fornecido todos os parâmetros e confirme seu escopo local.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplos de código simples em Python ou pseudocódigo, highlighter ou editor com syntax highlighting.",
                                  "tips": "Sempre procure a palavra 'def' ou equivalente para achar funções e seus parâmetros.",
                                  "learningObjective": "Reconhecer parâmetros como variáveis locais automáticas.",
                                  "commonMistakes": "Ignorar parâmetros opcionais ou com valores default; confundi-los com retornos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar acessibilidade de parâmetros dentro e fora da função",
                                  "subSteps": [
                                    "Escreva uma função simples com parâmetro: def soma(a, b): return a + b",
                                    "Chame a função e tente imprimir o parâmetro dentro dela.",
                                    "Após a chamada, tente acessar o parâmetro fora da função.",
                                    "Observe o erro de 'NameError' ou equivalente.",
                                    "Repita com múltiplas chamadas para ver que o escopo reseta."
                                  ],
                                  "verification": "Execute o código e capture o erro ao tentar acessar parâmetro fora; explique o motivo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code, PyCharm), interpretador Python online (Replit).",
                                  "tips": "Use print() statements dentro e fora para visualizar escopo.",
                                  "learningObjective": "Verificar empiricamente que parâmetros não são visíveis fora do subprograma.",
                                  "commonMistakes": "Usar global/ nonlocal incorretamente; esquecer de indentar código dentro da função."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar visibilidade em funções aninhadas e complexas",
                                  "subSteps": [
                                    "Crie uma função externa chamando função interna com parâmetros.",
                                    "Teste se parâmetro da interna é visível na externa (não é).",
                                    "Analise passagem de parâmetros entre funções.",
                                    "Identifique shadowing (parâmetro com mesmo nome que global).",
                                    "Desenhe um diagrama de escopo para o código."
                                  ],
                                  "verification": "Crie e teste um exemplo com funções aninhadas; diagrama deve mostrar escopos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta para diagrama, código complexo de exemplo.",
                                  "tips": "Desenhe caixas para cada função mostrando variáveis visíveis dentro.",
                                  "learningObjective": "Aplicar análise de visibilidade em cenários reais de subprogramação.",
                                  "commonMistakes": "Achar que parâmetros de função interna herdam visibilidade da externa."
                                }
                              ],
                              "practicalExample": "Em Python: def calcular_idade(ano_nascimento): idade = 2023 - ano_nascimento; return idade. Dentro da função, 'ano_nascimento' e 'idade' são visíveis. Fora: print(ano_nascimento) gera NameError, provando escopo local.",
                              "finalVerifications": [
                                "Explica corretamente por que parâmetros não são acessíveis fora da função.",
                                "Identifica todos os parâmetros em um código dado.",
                                "Prevê e reproduz erros de escopo em testes.",
                                "Diferencia parâmetros de variáveis globais/locais em diagramas.",
                                "Analisa corretamente funções aninhadas.",
                                "Aplica conceito em código próprio sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de escopos (100% dos parâmetros corretos).",
                                "Explicação clara e sem confusões conceituais.",
                                "Código de teste executável com verificações empíricas.",
                                "Diagrama de escopo completo e legível.",
                                "Tratamento correto de casos edge (shadowing, defaults).",
                                "Tempo de resolução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com domínio de funções matemáticas.",
                                "Lógica: Princípios de encapsulamento em raciocínio dedutivo.",
                                "Física: Conceitos de 'localização' e 'alcance' em sistemas confinados.",
                                "Língua Portuguesa: Análise de escopo em textos (contexto local vs global)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, parâmetros locais garantem encapsulamento, evitando bugs por colisão de nomes e protegendo dados sensíveis (ex: senhas em funções de autenticação não vazam para escopo global)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Acessibilidade de Variáveis",
                        "description": "Mecanismos para acessar variáveis de diferentes escopos em subprogramas, como passagem de parâmetros por valor ou referência e uso de variáveis globais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Acessar variáveis via parâmetros por valor",
                            "description": "Entender que parâmetros passados por valor criam cópias locais acessíveis apenas no subprograma, sem alterar o original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de passagem de parâmetros por valor",
                                  "subSteps": [
                                    "Leia a definição: parâmetros passados por valor criam uma cópia local da variável, acessível apenas dentro do subprograma.",
                                    "Compare com escopo global: a variável original permanece inalterada fora do subprograma.",
                                    "Visualize com analogia: imagine passar uma cópia de uma nota fiscal para uma função; alterações na cópia não afetam o original.",
                                    "Anote diferenças com passagem por referência (se conhecida).",
                                    "Resuma em 2-3 frases o que significa 'cópia local'."
                                  ],
                                  "verification": "Explique oralmente ou por escrito por que o valor original não é alterado após a chamada da função.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem (ex: Python 'def func(x):', C 'void func(int x)')",
                                    "Bloco de notas para anotações"
                                  ],
                                  "tips": "Use desenhos de pilha de memória para visualizar cópias: original na memória global, cópia na pilha da função.",
                                  "learningObjective": "Diferenciar passagem por valor de outros mecanismos de escopo.",
                                  "commonMistakes": [
                                    "Confundir com alteração direta da variável global",
                                    "Acreditar que ponteiros alteram o original em passagem por valor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar uma função simples com parâmetro por valor",
                                  "subSteps": [
                                    "Defina uma variável fora da função (ex: numero = 10).",
                                    "Crie uma função que receba um parâmetro por valor e o modifique internamente (ex: def incrementa(x): x += 1).",
                                    "Adicione prints: antes da chamada, dentro da função e após a chamada.",
                                    "Compile ou execute o código em um ambiente de teste.",
                                    "Registre os valores impressos."
                                  ],
                                  "verification": "O código executa sem erros e mostra que o valor original não mudou após a função.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Replit)",
                                    "Interpretador da linguagem (Python IDLE, GCC para C)"
                                  ],
                                  "tips": "Sempre imprima valores em pontos chave para depuração visual.",
                                  "learningObjective": "Criar subprograma que demonstra isolamento de cópia local.",
                                  "commonMistakes": [
                                    "Esquecer de imprimir após a chamada",
                                    "Usar palavra-chave errada para passagem por referência acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar e analisar o comportamento da cópia",
                                  "subSteps": [
                                    "Execute o código múltiplas vezes com valores diferentes (ex: 5, 0, -3).",
                                    "Altere o parâmetro dentro da função de formas variadas (soma, atribuição, operação complexa).",
                                    "Use debugger para inspecionar memória: verifique se há duas cópias distintas.",
                                    "Compare saídas esperadas vs. reais em uma tabela.",
                                    "Explique o resultado com base no conceito de cópia."
                                  ],
                                  "verification": "Crie uma tabela comprovando que original == antes e depois da função em todos testes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Debugger integrado (pdb em Python, gdb em C)",
                                    "Planilha para tabela de testes"
                                  ],
                                  "tips": "Teste com tipos primitivos primeiro (int, float) antes de compostos.",
                                  "learningObjective": "Validar empiricamente o isolamento do escopo local.",
                                  "commonMistakes": [
                                    "Ignorar tipos mutáveis como listas, que podem confundir",
                                    "Não testar valores edge como zero ou negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em cenário com múltiplos parâmetros",
                                  "subSteps": [
                                    "Modifique a função para receber 2-3 parâmetros por valor.",
                                    "Altere todos internamente e observe impactos no original.",
                                    "Crie uma função que retorne o valor modificado para uso opcional.",
                                    "Integre em um programa maior com chamadas encadeadas.",
                                    "Documente o código com comentários sobre escopo."
                                  ],
                                  "verification": "Programa completo executa corretamente, com todos originais inalterados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo editor e interpretador",
                                    "Exemplos de código online para referência"
                                  ],
                                  "tips": "Prefira funções puras: entrada -> saída sem side-effects.",
                                  "learningObjective": "Estender o conceito a funções realistas com múltiplas variáveis.",
                                  "commonMistakes": [
                                    "Retornar implicitamente alterando global",
                                    "Confundir retorno com alteração por valor"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\nnumero = 10\nprint('Antes:', numero)  # 10\ndef incrementa(x):\n    x += 1\n    print('Dentro:', x)  # 11\nincrementa(numero)\nprint('Depois:', numero)  # 10\nResultado comprova: cópia local não afeta original.",
                              "finalVerifications": [
                                "Explicar corretamente por que o original não muda.",
                                "Código executa sem erros em pelo menos 3 testes variados.",
                                "Identificar cópia na pilha de memória via debugger.",
                                "Criar função com múltiplos params por valor funcionando.",
                                "Documentar código com comentários sobre escopo."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% correto sobre cópias locais.",
                                "Código funcional: compila/executa, prints corretos.",
                                "Análise de testes: tabela com evidências empíricas.",
                                "Extensão prática: função com 2+ params isolada.",
                                "Documentação: comentários claros sobre mecanismo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções como mapeamentos injetores (entrada isolada).",
                                "Lógica: Princípios de encapsulamento e modularidade.",
                                "Física: Analogia com conservação de massa (original preservado)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, funções por valor garantem imutabilidade, evitando bugs em APIs REST (ex: processar dados de usuário sem alterar banco) e promovendo código previsível em equipes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Acessar variáveis via parâmetros por referência",
                            "description": "Compreender que passagem por referência permite acesso e modificação da variável original de fora do subprograma.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de passagem por referência",
                                  "subSteps": [
                                    "Estude a definição: passagem por referência passa o endereço da variável, permitindo modificação da original.",
                                    "Compare com passagem por valor: cópia do valor não altera o original.",
                                    "Analise diagramas de memória mostrando endereço vs cópia.",
                                    "Identifique linguagens que suportam: Python (listas), C++ (ponteiros).",
                                    "Leia documentação oficial de uma linguagem exemplo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre referência e valor, com um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de Python ou C++",
                                    "Papel e caneta para diagramas",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use analogias como 'endereço de casa' para referência vs 'foto da casa' para valor.",
                                  "learningObjective": "Diferenciar conceitualmente passagem por valor e por referência.",
                                  "commonMistakes": [
                                    "Confundir com cópia sempre, ignorando tipos mutáveis.",
                                    "Achar que todas as variáveis em Python são por referência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar passagem por referência em código simples",
                                  "subSteps": [
                                    "Crie uma função que receba uma lista por parâmetro.",
                                    "Modifique a lista dentro da função (ex: adicionar elemento).",
                                    "Chame a função e imprima a lista original antes e depois.",
                                    "Teste com diferentes tipos: lista vs inteiro.",
                                    "Adicione comentários explicando o endereço compartilhado."
                                  ],
                                  "verification": "Execute o código e confirme que a modificação persiste fora da função.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Interpretador Python"
                                  ],
                                  "tips": "Use print(id(variavel)) para verificar o mesmo endereço de memória.",
                                  "learningObjective": "Codificar uma função que modifique variáveis por referência.",
                                  "commonMistakes": [
                                    "Usar tipos imutáveis como int ou str, que se comportam como por valor.",
                                    "Esquecer de testar com print antes/depois."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e debugar passagem por valor vs referência",
                                  "subSteps": [
                                    "Implemente a mesma função com passagem por valor (cópia de lista).",
                                    "Compare saídas lado a lado.",
                                    "Introduza um bug intencional (modificar cópia) e corrija.",
                                    "Discuta cenários onde referência é necessária.",
                                    "Refatore código para usar referência explicitamente."
                                  ],
                                  "verification": "Crie um relatório curto com códigos e saídas comparativas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Copie listas com lista.copy() ou [:] para simular por valor.",
                                  "learningObjective": "Identificar e corrigir erros relacionados a escopo e passagem.",
                                  "commonMistakes": [
                                    "Não perceber que strings e tuplas são imutáveis.",
                                    "Confundir referência com ponteiros explícitos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em um exemplo prático e avaliar impactos",
                                  "subSteps": [
                                    "Crie um programa com subprograma que modifique um contador por referência.",
                                    "Simule um cenário real: função que atualiza saldo em conta.",
                                    "Meça performance (referência evita cópias grandes).",
                                    "Adicione validações para evitar modificações indesejadas.",
                                    "Documente o código com explicações."
                                  ],
                                  "verification": "O programa executa corretamente e o contador/saldo é modificado globalmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python instalado"
                                  ],
                                  "tips": "Use funções como def modificar_saldo(conta): conta[0] += 100",
                                  "learningObjective": "Aplicar passagem por referência em contexto funcional.",
                                  "commonMistakes": [
                                    "Modificar variáveis locais em vez de parâmetros.",
                                    "Ignorar efeitos colaterais em código multi-thread."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: def adicionar_item(carrinho): carrinho.append('item'); carrinho = ['maçã']; adicionar_item(carrinho); print(carrinho)  # Saída: ['maçã', 'item'] - modificou original.",
                              "finalVerifications": [
                                "Explicar por que listas em Python são modificadas por referência.",
                                "Identificar código que usa referência vs valor.",
                                "Criar função que dobre tamanho de uma lista por referência.",
                                "Debugar erro onde modificação não persiste.",
                                "Discutir prós/contras da referência (eficiência vs efeitos colaterais)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na explicação de referência.",
                                "Código funcional sem erros de escopo.",
                                "Uso correto de verificações de memória (id()).",
                                "Identificação de 3+ cenários de aplicação.",
                                "Relatório claro com diagramas e testes.",
                                "Evitar common mistakes listados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de ponteiros e endereços como funções lineares.",
                                "Banco de Dados: Referências em JOINs e chaves estrangeiras.",
                                "Física/Engenharia: Modelagem de sistemas dinâmicos compartilhados.",
                                "Lógica: Raciocínio sobre mutabilidade em provas formais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (modificar estado do jogador em funções), APIs web (atualizar objetos de usuário sem recriar), ou simulações científicas (alterar arrays de dados compartilhados eficientemente)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Usar variáveis globais para acessibilidade",
                            "description": "Demonstrar acesso a variáveis globais dentro de subprogramas, identificando riscos de dependência indesejada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de escopo e variáveis globais",
                                  "subSteps": [
                                    "Defina o que é escopo local e global em programação.",
                                    "Explique como variáveis globais são acessíveis em todo o programa, incluindo subprogramas.",
                                    "Diferencie acessibilidade de variáveis globais versus locais.",
                                    "Identifique cenários onde globais facilitam acessibilidade.",
                                    "Discuta brevemente riscos iniciais de dependência."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos de escopo global e local, citando exemplos simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de Python sobre escopo (global keyword)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use diagramas de escopo para visualizar a hierarquia de acessibilidade.",
                                  "learningObjective": "Entender a definição e o propósito de variáveis globais para acessibilidade em subprogramas.",
                                  "commonMistakes": "Confundir escopo global com escopo local, assumindo que todas as variáveis são globais por padrão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar acesso a variável global em subprograma",
                                  "subSteps": [
                                    "Crie um script Python com uma variável global (ex: contador = 0).",
                                    "Defina uma função (subprograma) que leia e imprima o valor da global.",
                                    "Chame a função do programa principal e verifique o acesso.",
                                    "Adicione uma segunda função que também acesse a mesma global.",
                                    "Execute e confirme que ambas funções acessam corretamente."
                                  ],
                                  "verification": "O código executa sem erros e as funções imprimem o valor da variável global corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "Editor de código como VS Code ou IDLE"
                                  ],
                                  "tips": "Use a palavra-chave 'global' dentro da função se precisar modificar a variável.",
                                  "learningObjective": "Demonstrar acesso bem-sucedido a variáveis globais dentro de subprogramas.",
                                  "commonMistakes": "Esquecer de declarar 'global nome_var' ao modificar dentro da função, criando uma local acidental."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar riscos de dependência indesejada",
                                  "subSteps": [
                                    "Modifique uma função para alterar o valor da variável global inesperadamente.",
                                    "Execute o programa e observe mudanças não intencionais em outras partes.",
                                    "Crie um cenário onde duas funções dependem da mesma global, causando conflito.",
                                    "Registre o estado antes/depois de cada chamada de função.",
                                    "Analise como isso cria dependência indesejada entre subprogramas."
                                  ],
                                  "verification": "O log mostra alterações inesperadas na variável global afetando múltiplas funções.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmo script Python do step anterior",
                                    "Terminal para execução e depuração"
                                  ],
                                  "tips": "Use print() statements para rastrear mudanças em tempo real.",
                                  "learningObjective": "Identificar e reproduzir riscos de dependência causados por variáveis globais.",
                                  "commonMistakes": "Não simular cenários reais de concorrência, subestimando o impacto das alterações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e propor alternativas",
                                  "subSteps": [
                                    "Liste 3 riscos principais observados (ex: difícil depuração, threading issues).",
                                    "Refatore o código usando passagem de parâmetros em vez de global.",
                                    "Compare o código original com o refatorado em termos de clareza e segurança.",
                                    "Teste o código refatorado para confirmar eliminação de dependências.",
                                    "Documente lições aprendidas sobre quando usar globais."
                                  ],
                                  "verification": "Código refatorado funciona igual ao original, mas sem dependências globais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código refatorado",
                                    "Ferramentas de diff como Git para comparar versões"
                                  ],
                                  "tips": "Prefira parâmetros e retornos para manter subprogramas independentes.",
                                  "learningObjective": "Avaliar riscos e adotar práticas melhores para acessibilidade sem globais.",
                                  "commonMistakes": "Manter globais desnecessárias no refator, não eliminando completamente a dependência."
                                }
                              ],
                              "practicalExample": "Em Python:\ncontador_global = 0\ndef funcao1():\n    global contador_global\n    print('F1:', contador_global)\n    contador_global += 1\ndef funcao2():\n    print('F2:', contador_global)\n# Chamadas: funcao1(); funcao2() → Mostra dependência: F2 vê mudança de F1.",
                              "finalVerifications": [
                                "Pode acessar variável global em múltiplas funções sem erros.",
                                "Demonstra alteração inesperada em uma função afetando outra.",
                                "Identifica pelo menos 3 riscos de dependência indesejada.",
                                "Refatora código removendo global com sucesso.",
                                "Explica verbalmente quando globais são aceitáveis (ex: constantes).",
                                "Código testado roda corretamente em cenários originais e refatorados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de escopo e acessibilidade (80% correta).",
                                "Código funcional demonstrando acesso e riscos (compila e executa).",
                                "Identificação clara de dependências indesejadas com evidências.",
                                "Refatoração eficaz eliminando globais desnecessárias.",
                                "Análise reflexiva com lições aprendidas documentadas.",
                                "Uso adequado de boas práticas em exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de estados compartilhados em equações diferenciais.",
                                "Física: Simulações onde variáveis globais representam constantes universais (ex: G na gravidade).",
                                "Lógica: Análise de dependências em provas formais.",
                                "Design de Sistemas: Arquitetura de software modular."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos, variáveis globais para placar facilitam acessibilidade, mas causam bugs em multiplayer; em apps web, sessões globais levam a vazamentos de dados entre usuários, enfatizando uso de estados locais ou bancos de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.4",
                            "name": "Detectar erros de acessibilidade",
                            "description": "Identificar e corrigir tentativas de acesso a variáveis fora de seu escopo em código com subprogramas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos de Escopo e Acessibilidade de Variáveis",
                                  "subSteps": [
                                    "Defina escopo local: variáveis declaradas dentro de uma função ou subprograma, acessíveis apenas ali.",
                                    "Defina escopo global: variáveis declaradas fora de funções, acessíveis em todo o programa.",
                                    "Explique acessibilidade: regra que impede acesso a variáveis locais de fora do subprograma.",
                                    "Estude exemplos em pseudocódigo ou Python: declare uma variável local e tente acessá-la globalmente.",
                                    "Revise hierarquia de escopos: blocos aninhados herdam escopo externo se não redeclarados."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos de escopo local e global, com um exemplo correto e um incorreto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de Python sobre escopo (docs.python.org), editor de código como VS Code.",
                                  "tips": "Use diagramas de escopo (caixas representando funções) para visualizar visivelmente.",
                                  "learningObjective": "Compreender a diferença entre escopos local e global e regras de acessibilidade.",
                                  "commonMistakes": "Confundir escopo local com global; assumir que variáveis locais 'vazam' para fora da função."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Tipos Comuns de Erros de Acessibilidade",
                                  "subSteps": [
                                    "Liste erros comuns: referência a variável local dentro de outra função; uso de variável global não declarada.",
                                    "Analise sintoma: erro de 'NameError' ou 'undefined variable' em linguagens como Python.",
                                    "Classifique violações: acesso direto de fora do subprograma; shadowing de variáveis externas.",
                                    "Pratique com snippets: identifique em 3 códigos curtos onde o erro ocorre.",
                                    "Diferencie de outros erros: não confundir com erros de sintaxe ou tipo."
                                  ],
                                  "verification": "Classifique corretamente 5 snippets de código com erros de escopo anotados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Snippets de código preparados (Python ou pseudocódigo), debugger integrado no IDE.",
                                  "tips": "Procure por referências a variáveis antes de sua declaração no escopo atual.",
                                  "learningObjective": "Reconhecer padrões de erros de acessibilidade em código.",
                                  "commonMistakes": "Ignorar indentação como pista de escopo; confundir com erros de importação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Erros de Acessibilidade em Código Completo",
                                  "subSteps": [
                                    "Leia código inteiro: trace o fluxo de execução e escopos aninhados.",
                                    "Marque referências: anote onde cada variável é declarada e usada.",
                                    "Execute no debugger: observe stack trace para erros de escopo.",
                                    "Use ferramentas: linters como pylint para Python destacam warnings de escopo.",
                                    "Teste casos edge: funções recursivas ou lambdas com escopo fechado."
                                  ],
                                  "verification": "Detecte e anote todos os erros de escopo em um programa de 50 linhas fornecido.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "IDE com debugger (PyCharm ou VS Code), linter pylint instalado.",
                                  "tips": "Comente o código linha por linha focando em declarações e usos de variáveis.",
                                  "learningObjective": "Aplicar detecção sistemática de erros de acessibilidade em programas reais.",
                                  "commonMistakes": "Pular leitura completa do código; focar só em erros óbvios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Corrigir Erros de Acessibilidade e Verificar Correções",
                                  "subSteps": [
                                    "Corrija passando parâmetros: torne variáveis locais acessíveis via argumentos.",
                                    "Use globais com cautela: declare global explicitamente se necessário.",
                                    "Refatore para retorno: funções retornam valores em vez de depender de globais.",
                                    "Teste após correção: execute unit tests para confirmar resolução.",
                                    "Documente mudanças: adicione comentários explicando a correção de escopo."
                                  ],
                                  "verification": "Corrija um código com 3 erros de escopo e passe em todos os testes automatizados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Framework de testes como pytest, código com erros pré-definidos.",
                                  "tips": "Prefira passar parâmetros a globais para modularidade.",
                                  "learningObjective": "Corrigir erros de acessibilidade de forma idiomática e testável.",
                                  "commonMistakes": "Introduzir novos erros ao corrigir; usar globais excessivamente."
                                }
                              ],
                              "practicalExample": "Em Python: def func(): x = 10; return x. Erro: y = func(); print(x) → NameError. Correção: def func(): x = 10; return x; y = func(); print(y). Isso corrige acesso fora do escopo local.",
                              "finalVerifications": [
                                "Identifica corretamente escopo de todas as variáveis em um código de 100 linhas.",
                                "Lista e corrige pelo menos 4 erros de acessibilidade sem introduzir novos.",
                                "Explica verbalmente ou por escrito por que uma correção resolve o erro.",
                                "Passa em testes unitários cobrindo cenários de escopo.",
                                "Usa linter sem warnings de escopo.",
                                "Refatora código para evitar dependência de globais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% dos erros identificados.",
                                "Qualidade da correção: Soluções modulares e sem side-effects.",
                                "Explicação clara: Justificativa técnica para cada mudança.",
                                "Eficiência: Tempo de execução e legibilidade melhoradas.",
                                "Testes abrangentes: Cobertura de casos edge.",
                                "Conformidade com boas práticas: Evita globais desnecessárias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de conjuntos para escopos aninhados.",
                                "Língua Portuguesa: Leitura analítica de código como texto estruturado.",
                                "Física/Engenharia: Modularidade como encapsulamento em sistemas.",
                                "Ética: Importância de código limpo para colaboração em equipe."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, detectar erros de escopo previne crashes em produção, como em apps web onde funções assíncronas acessam variáveis erradas, economizando horas de debug em equipes grandes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Tempo de Vida das Variáveis",
                        "description": "Duração em que uma variável alocada em memória mantém seu valor durante a execução de subprogramas, distinguindo estático e dinâmico.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Determinar tempo de vida local",
                            "description": "Explicar que variáveis locais em subprogramas têm tempo de vida limitado à execução do subprograma (automático).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Tempo de Vida de Variáveis",
                                  "subSteps": [
                                    "Defina tempo de vida como o período em que uma variável existe na memória durante a execução do programa.",
                                    "Explique que o tempo de vida é determinado pelo escopo onde a variável é declarada.",
                                    "Diferencie alocação (criação) e desalocação (destruição) automática vs manual.",
                                    "Estude o ciclo de vida: declaração → uso → fim do escopo → destruição.",
                                    "Anote exemplos simples de variáveis em blocos principais vs subprogramas."
                                  ],
                                  "verification": "Resuma o conceito em uma frase própria e liste 3 diferenças entre alocação automática e manual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notebook para anotações, diagrama de ciclo de vida impresso ou digital.",
                                  "tips": "Use analogia de 'quarto alugado': existe só enquanto a estadia dura.",
                                  "learningObjective": "Identificar o que é tempo de vida e seu ciclo básico.",
                                  "commonMistakes": "Confundir tempo de vida com visibilidade (escopo)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Variáveis Locais em Subprogramas",
                                  "subSteps": [
                                    "Revise sintaxe de subprogramas (funções/procedimentos) e declaração de variáveis dentro deles.",
                                    "Marque variáveis declaradas dentro do corpo do subprograma como 'locais'.",
                                    "Compare com variáveis declaradas fora (globais).",
                                    "Escreva pseudocódigo simples de uma função com variável local.",
                                    "Explique que o tempo de vida local inicia na chamada e termina no retorno."
                                  ],
                                  "verification": "Identifique corretamente 5 variáveis como locais em um código fornecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto ou IDE simples (ex: VS Code), pseudocódigo de exemplo.",
                                  "tips": "Pense em 'local' como pertencente só àquele subprograma, como um espaço privado.",
                                  "learningObjective": "Reconhecer variáveis locais e seu escopo limitado.",
                                  "commonMistakes": "Achar que variáveis locais persistem após o retorno da função."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Execução e Visualizar Tempo de Vida Local",
                                  "subSteps": [
                                    "Execute mentalmente ou em debugger: chame subprograma, crie variável local, use-a, retorne.",
                                    "Desenhe pilha de execução mostrando alocação na chamada e pop no retorno.",
                                    "Teste código real: função que imprime variável local e tenta acessá-la fora (erro esperado).",
                                    "Registre o momento exato de criação e destruição.",
                                    "Repita com múltiplas chamadas para ver recriação."
                                  ],
                                  "verification": "Desenhe diagrama de pilha para 2 chamadas de função e explique destruição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "IDE com debugger (ex: Python IDLE ou PyCharm), papel para diagramas de pilha.",
                                  "tips": "Use print statements para rastrear: 'Variável local criada!' e observe após retorno.",
                                  "learningObjective": "Visualizar dinamicamente o tempo de vida durante execução.",
                                  "commonMistakes": "Ignorar que cada chamada recria a variável independentemente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Desalocação Automática",
                                  "subSteps": [
                                    "Modifique código para tentar acessar variável local após retorno (deve falhar).",
                                    "Compare com variável global que persiste.",
                                    "Discuta benefícios: evita vazamentos de memória, isolamento de dados.",
                                    "Crie exercício: escreva função com local e global, trace tempos de vida.",
                                    "Explique 'automático' como gerenciado pelo compilador/runtime."
                                  ],
                                  "verification": "Código roda sem erros, acesso pós-retorno gera erro, explique por quê.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE para execução, exemplos de código com globais/locais.",
                                  "tips": "Compile com warnings ativados para detectar acessos inválidos.",
                                  "learningObjective": "Confirmar desalocação automática e benefícios.",
                                  "commonMistakes": "Confundir com passagem de parâmetros (que podem estender vida)."
                                }
                              ],
                              "practicalExample": "Em Python: def soma(a, b): total = a + b; print(total); return total. Após chamada soma(2,3), 'total' é destruída. Tentar print(total) fora gera NameError, provando tempo de vida limitado à função.",
                              "finalVerifications": [
                                "Explique verbalmente o tempo de vida local em 1 minuto.",
                                "Desenhe diagrama de pilha para uma função com 2 variáveis locais.",
                                "Execute código teste e identifique erro de acesso pós-retorno.",
                                "Compare tempo de vida local vs global em tabela.",
                                "Resolva quiz com 5 perguntas sobre cenários de execução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de tempo de vida local (100% correta).",
                                "Correta identificação de variáveis locais em código (sem erros).",
                                "Diagrama de pilha completo e rotulado.",
                                "Explicação clara de desalocação automática.",
                                "Aplicação correta em exemplo prático sem falhas lógicas.",
                                "Identificação de pelo menos 3 benefícios do escopo local."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções e domínios limitados.",
                                "Sistemas Operacionais: Gerenciamento de pilha e memória dinâmica.",
                                "Lógica: Encapsulamento e modularidade em programação.",
                                "Física: Ciclos de vida e entropia em sistemas finitos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, variáveis locais em funções evitam colisões de dados em apps multiusuário (ex: servidores web), otimizam memória em mobile apps e facilitam depuração em equipes grandes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Comparar tempo de vida global e local",
                            "description": "Contrastar o tempo de vida estático das variáveis globais (durante todo o programa) com o dinâmico das locais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o tempo de vida de variáveis globais",
                                  "subSteps": [
                                    "Ler a definição: variáveis globais são declaradas fora de funções e existem durante toda a execução do programa.",
                                    "Analisar um exemplo simples de código com uma variável global.",
                                    "Executar o código e observar que a variável persiste após chamadas de funções.",
                                    "Modificar o valor da global dentro e fora de uma função e verificar a persistência.",
                                    "Documentar as observações em um caderno de notas."
                                  ],
                                  "verification": "Criar e executar um programa onde uma variável global mantém seu valor após múltiplas funções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (ex: VS Code), interpretador Python ou similar",
                                  "tips": "Use print() para rastrear o valor da variável em diferentes pontos do programa.",
                                  "learningObjective": "Identificar e demonstrar que o tempo de vida de globais é estático e abrange todo o programa.",
                                  "commonMistakes": "Confundir tempo de vida com escopo de visibilidade; globais são visíveis e vivas em todo lugar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o tempo de vida de variáveis locais",
                                  "subSteps": [
                                    "Ler a definição: variáveis locais são declaradas dentro de funções e existem apenas durante a execução daquela função.",
                                    "Analisar um exemplo de código com variável local dentro de uma função.",
                                    "Executar o código e tentar acessar a local fora da função, observando o erro.",
                                    "Criar variações com funções aninhadas para ver o escopo dinâmico.",
                                    "Comparar notas com o step anterior."
                                  ],
                                  "verification": "Executar um programa que gere erro ao tentar acessar uma variável local fora de sua função.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, interpretador Python",
                                  "tips": "Lembre-se: locais são 'descartadas' ao sair da função, liberando memória.",
                                  "learningObjective": "Demonstrar que o tempo de vida de locais é dinâmico, limitado à função.",
                                  "commonMistakes": "Achar que locais persistem se a função for chamada múltiplas vezes; cada chamada cria uma nova."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar os tempos de vida global e local",
                                  "subSteps": [
                                    "Criar uma tabela comparativa: duração, criação/destruição, acessibilidade.",
                                    "Escrever pseudocódigo misturando globais e locais.",
                                    "Executar e debugar cenários onde confusão pode ocorrer (ex: modificar global de local).",
                                    "Explicar verbalmente ou por escrito as diferenças chave.",
                                    "Identificar prós e contras de cada (globais: persistência vs poluição; locais: segurança vs limitação)."
                                  ],
                                  "verification": "Produzir uma tabela ou diagrama comparativo correto e testá-lo com código.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel/caderno para tabela, editor de código",
                                  "tips": "Pense em 'global = vida eterna do programa; local = vida curta da função'.",
                                  "learningObjective": "Contrastar estático (global) vs dinâmico (local) de forma clara.",
                                  "commonMistakes": "Ignorar que globais podem ser modificadas de locais, mas não vice-versa sem declaração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e testar em um exemplo prático",
                                  "subSteps": [
                                    "Implementar um programa com contador global (acumula chamadas) e cálculo local (por chamada).",
                                    "Executar múltiplas vezes e analisar saídas.",
                                    "Introduzir bug intencional (usar local como global) e corrigir.",
                                    "Refatorar para melhor prática (evitar globals desnecessárias).",
                                    "Registrar lições aprendidas."
                                  ],
                                  "verification": "Código funcional que demonstra diferenças e passa em testes de comportamento esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, interpretador",
                                  "tips": "Use global keyword em Python para modificar globals de dentro de funções.",
                                  "learningObjective": "Aplicar conceitos em código real, prevendo e verificando comportamentos.",
                                  "commonMistakes": "Esquecer de declarar 'global' ao modificar de função, causando criação de local homônima."
                                }
                              ],
                              "practicalExample": "Em Python:\nglobal_var = 0\ndef incrementa():\n    global global_var\n    global_var += 1\n    local_var = 10\n    print(local_var)  # OK\nprint(global_var)  # 0\nincrementa()       # global_var vira 1\nprint(global_var)  # 1 (persiste)\nprint(local_var)  # NameError (não existe mais)",
                              "finalVerifications": [
                                "Explicar em palavras próprias a diferença entre tempos de vida global e local.",
                                "Identificar corretamente globais/locais em um código fornecido.",
                                "Prever o comportamento de um programa misto sem executá-lo.",
                                "Debugar um erro causado por confusão de escopo/tempo de vida.",
                                "Criar um exemplo próprio demonstrando o contraste.",
                                "Discutir quando usar cada tipo com justificativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de estático vs dinâmico (30%)",
                                "Qualidade dos exemplos: códigos executáveis e ilustrativos (25%)",
                                "Análise comparativa: tabela/diagrama clara e completa (20%)",
                                "Aplicação prática: código funcional com testes (15%)",
                                "Profundidade: menção a prós/contras e melhores práticas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: contadores persistentes (globais) vs cálculos temporários (locais) em algoritmos.",
                                "Física: ciclo de vida de partículas (local) vs conservação de energia global.",
                                "Lógica e Filosofia: persistência de estados vs efemeridade em sistemas.",
                                "Gestão de Projetos: recursos globais (orçamento total) vs locais (tarefas específicas)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, variáveis globais para configurações compartilhadas (ex: banco de dados de conexão em apps web), enquanto locais para processamento temporário (ex: loop de soma em relatórios), evitando vazamentos de memória e bugs de concorrência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Analisar impacto em recursividade",
                            "description": "Entender como o tempo de vida local permite múltiplas instâncias em chamadas recursivas de subprogramas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de recursão e tempo de vida de variáveis",
                                  "subSteps": [
                                    "Defina recursão como uma função que chama a si mesma.",
                                    "Explique tempo de vida local: variável criada na entrada da sub-rotina e destruída na saída.",
                                    "Diferencie de tempo de vida global ou estático.",
                                    "Desenhe um diagrama de pilha de chamadas para uma recursão simples.",
                                    "Liste exemplos de funções recursivas básicas como fatorial."
                                  ],
                                  "verification": "Crie um diagrama de pilha para fatorial(3) e confirme ativações locais separadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho como Draw.io",
                                    "Documentação de linguagem de programação (ex: Python ou C)"
                                  ],
                                  "tips": "Use analogia de pilha de pratos: cada chamada empilha um novo 'prato' com suas próprias variáveis.",
                                  "learningObjective": "Compreender a base teórica de recursão e escopo local.",
                                  "commonMistakes": [
                                    "Confundir recursão com iteração",
                                    "Achar que variáveis locais são compartilhadas entre chamadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar uma função recursiva simples com variável local",
                                  "subSteps": [
                                    "Escreva uma função recursiva para calcular fatorial com um contador local de profundidade.",
                                    "Execute a função com entrada pequena (n=4) e observe saídas de depuração.",
                                    "Adicione prints para mostrar o valor da variável local em cada chamada.",
                                    "Rastreie manualmente a pilha de chamadas no papel.",
                                    "Compile e execute em um debugger passo a passo."
                                  ],
                                  "verification": "Os prints mostram contadores diferentes em cada nível de recursão (ex: depth=0,1,2,3).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Interpretador Python ou compilador C"
                                  ],
                                  "tips": "Use print statements ou debugger para visualizar o estado da pilha em tempo real.",
                                  "learningObjective": "Observar múltiplas instâncias de variáveis locais na pilha de recursão.",
                                  "commonMistakes": [
                                    "Esquecer de passar parâmetros corretamente",
                                    "Usar variável global por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar com variáveis de tempo de vida diferente",
                                  "subSteps": [
                                    "Modifique a função para usar uma variável global ou estática no lugar da local.",
                                    "Execute novamente e compare as saídas com a versão anterior.",
                                    "Analise por que o comportamento muda (ex: contador compartilhado vs independente).",
                                    "Desenhe diagramas comparativos das pilhas.",
                                    "Teste com entrada maior para observar estouro de pilha ou resultados errados."
                                  ],
                                  "verification": "Na versão global/estática, o contador é o mesmo em todas as chamadas; na local, é único por frame.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo editor e interpretador do passo anterior",
                                    "Debugger integrado"
                                  ],
                                  "tips": "Em C, use 'static int counter;' para simular; em Python, use módulo-level variable.",
                                  "learningObjective": "Identificar o impacto do tempo de vida no comportamento recursivo.",
                                  "commonMistakes": [
                                    "Não resetar variáveis entre testes",
                                    "Ignorar limites de profundidade de recursão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impacto em um exemplo complexo e debugar",
                                  "subSteps": [
                                    "Implemente Torres de Hanoi recursiva com variáveis locais para rastreio.",
                                    "Simule falhas intencionais mudando escopo e corrija.",
                                    "Calcule complexidade e discuta como escopo afeta memória.",
                                    "Escreva um relatório curto sobre lições aprendidas.",
                                    "Teste com diferentes linguagens se possível."
                                  ],
                                  "verification": "Relatório explica corretamente 3 diferenças de impacto entre escopos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Referências online sobre Torres de Hanoi recursiva"
                                  ],
                                  "tips": "Limite recursão a n=4 para evitar stack overflow em testes.",
                                  "learningObjective": "Aplicar análise em cenários reais e sintetizar conhecimentos.",
                                  "commonMistakes": [
                                    "Stack overflow por recursão profunda",
                                    "Confundir escopo léxico com dinâmico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python:\n\ndef fatorial_recursivo(n, profundidade=0):\n    print(f'Chamando fatorial({n}) na profundidade {profundidade}')\n    if n <= 1:\n        return 1\n    return n * fatorial_recursivo(n-1, profundidade+1)\n\nfatorial_recursivo(3)\n# Saída mostra profundidade 0,1,2,3 independentemente por causa do parâmetro local equivalente a variável local.",
                              "finalVerifications": [
                                "Explicar verbalmente como uma variável local cria instância única por chamada recursiva.",
                                "Desenhar pilha para recursão de profundidade 4 com variáveis locais corretas.",
                                "Identificar erro em código onde variável global causa falha em recursão.",
                                "Simular execução de fatorial(4) rastreando 4 frames de pilha.",
                                "Comparar uso de memória entre local e estática em recursão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de múltiplas instâncias locais (90% correto).",
                                "Diagramas de pilha claros e rotulados corretamente.",
                                "Código executável sem erros e com depuração funcional.",
                                "Análise escrita identifica pelo menos 3 impactos no comportamento.",
                                "Tempo de execução e memória respeitam limites esperados.",
                                "Relatório demonstra compreensão profunda sem jargões errados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções recursivas como sequências (fatorial, Fibonacci).",
                                "Algoritmos: Análise de complexidade temporal/espacial em recursão.",
                                "Lógica de Programação: Depuração e rastreio de execução.",
                                "Engenharia de Software: Gerenciamento de memória e stack overflow."
                              ],
                              "realWorldApplication": "Em compiladores e parsers (ex: árvore de sintaxe em linguagens como JavaScript), recursão com variáveis locais permite descida segura em árvores profundas sem perda de contexto por frame, evitando vazamentos de estado em processadores XML/JSON ou jogos com buscas em grafos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Recursividade",
                    "description": "Chamada de uma função por ela mesma, com condições base e de parada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Definição de Recursividade",
                        "description": "Recursividade é o mecanismo em que uma função ou procedimento chama a si mesmo durante sua execução, permitindo resolver problemas dividindo-os em subproblemas menores da mesma natureza.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar recursividade em código fonte",
                            "description": "Analisar um trecho de código para reconhecer quando uma função se chama recursivamente, distinguindo de chamadas a outras funções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Recursividade",
                                  "subSteps": [
                                    "Leia a definição formal de recursividade: uma técnica onde uma função invoca a si mesma para resolver subproblemas menores.",
                                    "Identifique os dois elementos essenciais: o caso base (condição de parada) e a chamada recursiva.",
                                    "Estude um diagrama de pilha de chamadas recursivas para visualizar o processo.",
                                    "Compare recursividade com iteração para destacar diferenças.",
                                    "Anote exemplos clássicos como cálculo de fatorial ou Fibonacci."
                                  ],
                                  "verification": "Explique em suas próprias palavras os componentes de uma recursão válida e forneça um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Slides ou vídeo introdutório sobre recursividade",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Sempre pergunte: 'Onde para?' – foque no caso base primeiro.",
                                  "learningObjective": "Dominar o conceito teórico de recursividade e seus componentes obrigatórios.",
                                  "commonMistakes": [
                                    "Confundir recursão com chamadas a funções auxiliares",
                                    "Ignorar o risco de recursão infinita sem caso base"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Assinatura e Estrutura da Função",
                                  "subSteps": [
                                    "Localize a declaração da função (nome, parâmetros e tipo de retorno).",
                                    "Identifique o escopo do corpo da função (bloco de código delimitado por chaves ou indentação).",
                                    "Marque todas as chamadas de funções dentro do corpo.",
                                    "Verifique se o nome da função atual aparece como chamador.",
                                    "Destaque parâmetros passados na chamada para si mesma."
                                  ],
                                  "verification": "Anote a assinatura da função e liste todas as chamadas internas, circundando a auto-chamada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código ou visualizador de sintaxe",
                                    "Trecho de código fonte fornecido"
                                  ],
                                  "tips": "Use realce de sintaxe para tornar chamadas de funções visíveis rapidamente.",
                                  "learningObjective": "Localizar precisamente a estrutura de uma função em código fonte.",
                                  "commonMistakes": [
                                    "Confundir nome da função com variáveis locais",
                                    "Ignorar chamadas em condicionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Chamadas Recursivas e Distinguir de Outras",
                                  "subSteps": [
                                    "Procure por invocações do nome exato da função atual dentro de seu próprio corpo.",
                                    "Diferencie auto-chamadas de chamadas a funções externas ou auxiliares.",
                                    "Confirme se a chamada recursiva altera os parâmetros para aproximar do caso base.",
                                    "Verifique a presença de um caso base (if/condição que não chama recursivamente).",
                                    "Compare com exemplos não-recursivos para reforçar distinção."
                                  ],
                                  "verification": "Classifique 3 trechos de código como 'recursivo' ou 'não-recursivo' com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código recursivo e iterativo",
                                    "Ferramenta de debug como debugger stepwise"
                                  ],
                                  "tips": "Siga o fluxo: simule execução manualmente para ver se volta a si mesma.",
                                  "learningObjective": "Reconhecer padrões de chamadas recursivas versus não-recursivas.",
                                  "commonMistakes": [
                                    "Considerar funções auxiliares como recursão principal",
                                    "Não notar chamadas indiretas via ponteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Recursividade Completa e Praticar Análise",
                                  "subSteps": [
                                    "Confirme que existe pelo menos um caso base para evitar loop infinito.",
                                    "Avalie se a recursão progride (parâmetros diminuem/aumentam corretamente).",
                                    "Analise múltiplos trechos de código variados (simples, aninhado, múltiplas chamadas).",
                                    "Documente achados em um relatório curto: 'Recursivo? Por quê?'.",
                                    "Teste com depurador para observar pilha de chamadas."
                                  ],
                                  "verification": "Produza um relatório de análise para 5 códigos diferentes, indicando recursividade corretamente em todos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Depurador integrado (ex: VS Code, PyCharm)",
                                    "Conjunto de 5 trechos de código teste"
                                  ],
                                  "tips": "Use breakpoints em chamadas para visualizar a pilha recursiva.",
                                  "learningObjective": "Aplicar análise completa para validar recursividade em código real.",
                                  "commonMistakes": [
                                    "Declarar recursivo sem caso base",
                                    "Confundir recursão mútua com simples"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere este código Python:\n\ndef fatorial(n):\n    if n <= 1:\n        return 1\n    return n * fatorial(n - 1)\n\nAqui, 'fatorial' chama 'fatorial(n-1)' dentro de si mesma, com caso base 'if n <= 1'. É recursivo.\n\nComparação não-recursiva:\n\ndef fatorial_iterativo(n):\n    resultado = 1\n    for i in range(2, n+1):\n        resultado *= i\n    return resultado\n\nNão há auto-chamada; usa loop.",
                              "finalVerifications": [
                                "Identificar corretamente recursividade em 90% dos trechos de código fornecidos.",
                                "Explicar presença/ausência de caso base em análises.",
                                "Distinguir recursão de chamadas a funções auxiliares em exemplos complexos.",
                                "Simular pilha de chamadas manualmente para um código recursivo.",
                                "Produzir relatório de análise sem erros conceituais.",
                                "Detectar recursão indireta ou mútua em código avançado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de auto-chamadas (100% obrigatório).",
                                "Correta detecção de caso base em todos os exemplos.",
                                "Distinção clara entre recursão e iteração/chamadas externas.",
                                "Qualidade da justificativa escrita (detalhada e lógica).",
                                "Eficiência na análise (tempo dentro do estimado).",
                                "Capacidade de lidar com variações linguísticas (Python, C++, Java)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções recursivas como sequências definidas por si mesmas (ex: Fibonacci).",
                                "Biologia: Modelagem de estruturas hierárquicas como árvores genealógicas ou ramificações celulares.",
                                "Linguística Computacional: Parsing recursivo de gramáticas em processamento de linguagem natural.",
                                "Física: Simulações de fractais e padrões auto-similares (ex: curvas de Koch).",
                                "Economia: Modelos de crescimento recursivo em finanças compostas."
                              ],
                              "realWorldApplication": "Em engenharia de software, identificar recursividade é crucial para depurar algoritmos de árvore (ex: busca em diretórios de arquivos no Linux 'find' command), parsing de JSON/XML, jogos (pathfinding em mapas), e otimizar performance evitando stack overflow em aplicações como navegadores web ou editores de texto."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Diferenciar recursão de iteração",
                            "description": "Comparar soluções recursivas e iterativas para o mesmo problema, identificando vantagens e desvantagens de cada abordagem em termos de legibilidade e eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de iteração",
                                  "subSteps": [
                                    "Defina iteração como um processo que repete uma sequência de instruções usando loops (for, while).",
                                    "Identifique componentes chave: inicialização, condição de parada e atualização.",
                                    "Analise como o controle de fluxo é gerenciado pelo programa sem chamadas de função adicionais.",
                                    "Examine o uso de variáveis acumuladoras para manter o estado.",
                                    "Compare com sequências lineares simples."
                                  ],
                                  "verification": "Escreva uma definição clara e liste os componentes de um loop iterativo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (ex: VS Code)",
                                    "Documentação de loops em Python ou C"
                                  ],
                                  "tips": "Sempre pense no estado mantido por variáveis locais no loop.",
                                  "learningObjective": "Entender iteração como repetição controlada por loops com estado explícito.",
                                  "commonMistakes": [
                                    "Confundir iteração com chamadas de função",
                                    "Ignorar condição de parada levando a loops infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de recursão",
                                  "subSteps": [
                                    "Defina recursão como uma função que chama a si mesma para resolver subproblemas menores.",
                                    "Identifique caso base (condição de parada) e caso recursivo.",
                                    "Explique o papel da pilha de chamadas (call stack) para gerenciar múltiplas invocações.",
                                    "Discuta como o estado é passado via parâmetros e retornado via valores.",
                                    "Visualize a árvore de recursão para problemas como fatorial ou Fibonacci."
                                  ],
                                  "verification": "Desenhe o diagrama da pilha de chamadas para uma recursão simples de fatorial(3).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Simulador de pilha online ou debugger"
                                  ],
                                  "tips": "Sempre defina o caso base primeiro para evitar estouro de pilha.",
                                  "learningObjective": "Dominar recursão como divisão de problemas em subproblemas idênticos menores.",
                                  "commonMistakes": [
                                    "Esquecer o caso base",
                                    "Não entender o uso da pilha de execução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar soluções iterativa e recursiva para um problema comum",
                                  "subSteps": [
                                    "Escolha um problema simples: cálculo de fatorial.",
                                    "Implemente versão iterativa usando um loop while ou for.",
                                    "Implemente versão recursiva com caso base e chamada recursiva.",
                                    "Execute ambas com entrada n=5 e compare saídas.",
                                    "Use um debugger para observar execução passo a passo em cada versão."
                                  ],
                                  "verification": "Forneça códigos funcionais para ambas as implementações e resultados idênticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python recomendado)",
                                    "Ambiente de execução online como Replit"
                                  ],
                                  "tips": "Teste com valores pequenos primeiro para validar.",
                                  "learningObjective": "Aplicar ambos os métodos ao mesmo problema para observação direta.",
                                  "commonMistakes": [
                                    "Erro em inicialização iterativa",
                                    "Recursão sem retorno no caso recursivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar vantagens e desvantagens em legibilidade e eficiência",
                                  "subSteps": [
                                    "Avalie legibilidade: recursão mais elegante para problemas naturais (ex: árvores), iteração mais direta.",
                                    "Meça eficiência: recursão O(n) espaço na pilha vs iteração O(1) espaço.",
                                    "Discuta tempo: ambos O(n) geralmente, mas recursão pode ser mais lenta por overhead de chamadas.",
                                    "Considere cenários: recursão para divide-and-conquer, iteração para acumulação simples.",
                                    "Registre prós/contras em uma tabela comparativa."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 4 critérios comparativos preenchida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Markdown",
                                    "Ferramentas de profiling como timeit em Python"
                                  ],
                                  "tips": "Meça tempo real com grandes n para evidenciar overhead recursivo.",
                                  "learningObjective": "Identificar quando escolher cada abordagem baseado em trade-offs.",
                                  "commonMistakes": [
                                    "Ignorar custo de pilha em recursão",
                                    "Achar recursão sempre mais eficiente"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o cálculo do fatorial de 10: iterativamente com um loop acumulando resultado (facilmente legível e eficiente em memória); recursivamente chamando fatorial(n-1) * n (elegante mas consome pilha, risco de StackOverflow para n grande).",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre loop iterativo e chamada recursiva.",
                                "Implementar fatorial em ambas formas sem erros.",
                                "Identificar StackOverflow em recursão profunda (n>1000).",
                                "Listar 3 vantagens da iteração sobre recursão.",
                                "Converter uma função recursiva simples para iterativa.",
                                "Prever qual método usa menos memória para soma de array."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de iteração vs recursão (100% correta).",
                                "Códigos funcionais e corretos em ambas abordagens.",
                                "Análise correta de trade-offs (legibilidade, tempo O(n), espaço).",
                                "Identificação de cenários ideais para cada (ex: recursão em árvores).",
                                "Uso de verificações empíricas (tempo/memória).",
                                "Tabela comparativa completa e bem fundamentada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções recursivas e indução matemática.",
                                "Algoritmos: Análise de complexidade Big O para espaço e tempo.",
                                "Engenharia de Software: Otimização de código e refatoração.",
                                "Lógica: Estruturas de controle e fluxogramas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, use iteração para loops simples como soma de arrays em apps web (eficiência); recursão para parsing de árvores JSON/XML ou buscas em grafos (legibilidade natural), otimizando com memoização para evitar ineficiências em ferramentas como navegadores ou bancos de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Explicar o fluxo de execução recursiva",
                            "description": "Descrever passo a passo como ocorre a execução de uma chamada recursiva, incluindo empilhamento e desempilhamento de chamadas na pilha de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos da Pilha de Execução",
                                  "subSteps": [
                                    "Defina o que é uma pilha (stack) de execução em programação.",
                                    "Explique o que é um frame de pilha (stack frame), incluindo parâmetros, variáveis locais e endereço de retorno.",
                                    "Descreva o princípio LIFO (Last In, First Out) aplicado à pilha de chamadas.",
                                    "Diferencie empilhamento (push) de desempilhamento (pop).",
                                    "Identifique o papel da pilha em funções não-recursivas simples."
                                  ],
                                  "verification": "Desenhe um diagrama simples de uma pilha com duas chamadas de função não-recursivas e explique o fluxo.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Documentação de pilha de chamadas em Python ou JavaScript"
                                  ],
                                  "tips": [
                                    "Use analogia de pratos empilhados para visualizar LIFO.",
                                    "Consulte diagramas online de stack traces para inspiração."
                                  ],
                                  "learningObjective": "Entender a estrutura e operação fundamental da pilha de execução antes da recursão.",
                                  "commonMistakes": [
                                    "Confundir pilha com fila (FIFO).",
                                    "Ignorar o endereço de retorno no frame."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar uma Função Recursiva Simples",
                                  "subSteps": [
                                    "Escolha um exemplo clássico: função fatorial recursiva (ex: fact(n) = n * fact(n-1) se n > 0, else 1).",
                                    "Identifique o caso base (base case) e a chamada recursiva.",
                                    "Escreva o pseudocódigo ou código em uma linguagem familiar.",
                                    "Explique verbalmente o que acontece na primeira chamada.",
                                    "Preveja o número de chamadas para fact(4)."
                                  ],
                                  "verification": "Escreva e anote o código do fatorial recursivo, destacando caso base e recursivo.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Replit)",
                                    "Pseudocódigo impresso"
                                  ],
                                  "tips": [
                                    "Sempre priorize funções com caso base claro para evitar confusão.",
                                    "Teste o código com valores pequenos (n=0,1,2)."
                                  ],
                                  "learningObjective": "Reconhecer componentes essenciais de uma função recursiva.",
                                  "commonMistakes": [
                                    "Esquecer o caso base, levando a recursão infinita.",
                                    "Confundir parâmetros na chamada recursiva."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular o Empilhamento de Chamadas Recursivas",
                                  "subSteps": [
                                    "Inicie com fact(4): crie o frame inicial na pilha.",
                                    "Simule a chamada recursiva para fact(3), empilhando novo frame.",
                                    "Continue até fact(1), registrando parâmetros e estado em cada frame.",
                                    "Descreva como a pilha cresce a cada chamada recursiva.",
                                    "Anote o estado da pilha em cada momento."
                                  ],
                                  "verification": "Desenhe a pilha completa com 4 frames para fact(4), mostrando parâmetros e valores locais.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Papel quadriculado para diagramas de pilha",
                                    "Marcadores coloridos"
                                  ],
                                  "tips": [
                                    "Use setas para mostrar o fluxo de execução entre frames.",
                                    "Simule manualmente antes de usar depurador."
                                  ],
                                  "learningObjective": "Visualizar como chamadas recursivas se acumulam na pilha.",
                                  "commonMistakes": [
                                    "Perder o rastreamento de parâmetros em frames profundos.",
                                    "Assumir execução sequencial em vez de empilhada."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular o Desempilhamento e o Retorno dos Valores",
                                  "subSteps": [
                                    "Alcance o caso base fact(1) = 1 e retorne o valor.",
                                    "Desempilhe fact(1), calcule e retorne para fact(2).",
                                    "Continue desempilhando até fact(4), multiplicando valores retornados.",
                                    "Registre como o resultado final é construído de baixo para cima.",
                                    "Compare o estado final da pilha (vazia) com o inicial."
                                  ],
                                  "verification": "Complete o diagrama da pilha mostrando desempilhamento passo a passo com valores retornados.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Mesmos diagramas do step 3",
                                    "Calculadora para verificação numérica"
                                  ],
                                  "tips": [
                                    "Pense no retorno como 'preencher lacunas' nos frames superiores.",
                                    "Use um depurador (ex: Python debugger) para validar a simulação."
                                  ],
                                  "learningObjective": "Compreender como os retornos recursivos constroem o resultado final.",
                                  "commonMistakes": [
                                    "Calcular resultados incorretamente durante desempilhamento.",
                                    "Esquecer de limpar a pilha após retorno."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Visualizar e Generalizar o Fluxo Completo",
                                  "subSteps": [
                                    "Revise o ciclo completo: empilhamento até base, desempilhamento com cálculos.",
                                    "Aplique a outro exemplo, como Fibonacci recursivo simples.",
                                    "Discuta limitações (stack overflow com profundidade excessiva).",
                                    "Crie um fluxograma geral para qualquer recursão.",
                                    "Explique verbalmente para um 'parceiro de estudo'."
                                  ],
                                  "verification": "Crie e explique um fluxograma genérico de execução recursiva.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (Draw.io, Lucidchart)",
                                    "Exemplo de código Fibonacci"
                                  ],
                                  "tips": [
                                    "Generalize: 'Empilhe até base, desempilhe computando'.",
                                    "Registre stack trace de uma execução real."
                                  ],
                                  "learningObjective": "Generalizar o fluxo recursivo para qualquer função.",
                                  "commonMistakes": [
                                    "Superestimar profundidade sem considerar overflow.",
                                    "Não generalizar além do exemplo específico."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a função fatorial recursiva em Python:\n\ndef fact(n):\n    if n <= 1:\n        return 1\n    return n * fact(n-1)\n\nExecução de fact(4):\n1. fact(4): empilha frame com n=4, chama fact(3)\n2. fact(3): empilha n=3, chama fact(2)\n3. fact(2): empilha n=2, chama fact(1)\n4. fact(1): base case, retorna 1 (desempilha)\n5. fact(2): 2*1=2, retorna (desempilha)\n6. fact(3): 3*2=6, retorna (desempilha)\n7. fact(4): 4*6=24, retorna (desempilha)\nResultado: 24.",
                              "finalVerifications": [
                                "Desenhar corretamente a pilha para fact(3) com empilhamento e desempilhamento.",
                                "Explicar verbalmente o fluxo para um ouvinte sem erros.",
                                "Simular execução de Fibonacci(4) usando pilha manualmente.",
                                "Identificar e corrigir um código recursivo sem caso base.",
                                "Prever stack overflow para fact(10000) e propor solução (iterativo).",
                                "Comparar recursão com iteração em termos de pilha."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de stack frames (parâmetros, retorno).",
                                "Correta sequência de empilhamento/desempilhamento em simulações.",
                                "Identificação clara de caso base e chamadas recursivas.",
                                "Uso de diagramas visuais claros e rotulados.",
                                "Generalização para exemplos além do fatorial.",
                                "Compreensão de limitações como stack overflow."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática (base + passo recursivo).",
                                "Biologia: Estruturas hierárquicas como árvores genealógicas (ancestrais recursivos).",
                                "Física: Movimento de projéteis em órbitas (simulações recursivas de trajetórias).",
                                "Lógica: Provas por indução estrutural em Teoria da Computação."
                              ],
                              "realWorldApplication": "Em compiladores, parsing de expressões matemáticas usa recursão descendente (empilhamento de regras gramaticais); em jogos, geração de labirintos via backtracking (explorar caminhos recursivos até solução); em sistemas de arquivos, listagem recursiva de diretórios (traverse árvore de pastas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Caso Base e Condição de Parada",
                        "description": "O caso base é a condição que define o ponto de parada da recursão, evitando chamadas infinitas, enquanto a condição recursiva permite a divisão do problema.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Definir e implementar o caso base",
                            "description": "Identificar e codificar a condição que retorna um valor direto sem chamadas recursivas, garantindo terminação do algoritmo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de caso base em recursão",
                                  "subSteps": [
                                    "Estude a definição: o caso base é a condição que para a recursão retornando um valor direto.",
                                    "Analise exemplos clássicos como fatorial (n=0 ou 1 retorna 1) e sequência de Fibonacci (n=0 retorna 0, n=1 retorna 1).",
                                    "Identifique por que o caso base garante terminação: evita chamadas recursivas infinitas.",
                                    "Discuta com um colega ou anote: 'Sem caso base, recursão explode em stack overflow'.",
                                    "Revise diagramas de chamadas recursivas com e sem caso base."
                                  ],
                                  "verification": "Explique em suas palavras o que é caso base e dê 2 exemplos; grave um áudio ou escreva um resumo de 100 palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de recursão (ex: MDN Web Docs ou livro 'Introduction to Algorithms'), papel e caneta para diagramas.",
                                  "tips": "Use analogia: caso base é como o 'fim da escada' em uma escada descendente.",
                                  "learningObjective": "Dominar a definição e importância do caso base para terminação recursiva.",
                                  "commonMistakes": "Confundir caso base com caso recursivo; ignorar múltiplos casos base."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o problema para identificar o caso base",
                                  "subSteps": [
                                    "Leia o problema recursivo (ex: calcular fatorial ou soma de lista).",
                                    "Pergunte: 'Qual entrada mais simples retorna resposta conhecida sem recursão?'",
                                    "Liste entradas mínimas: para fatorial, n=0; para árvore, nó folha.",
                                    "Desenhe fluxograma: se condição base verdadeira → retorne valor; senão → recursão.",
                                    "Valide com testes manuais: simule execução para entradas base."
                                  ],
                                  "verification": "Crie uma tabela com 3 problemas recursivos e seus casos base identificados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto ou quadro branco, exemplos de problemas recursivos impressos.",
                                  "tips": "Pense em indução matemática: caso base é o primeiro passo da prova.",
                                  "learningObjective": "Desenvolver habilidade de mapear problemas para casos base apropriados.",
                                  "commonMistakes": "Escolher caso base muito complexo que ainda precise de recursão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a condição de caso base no código",
                                  "subSteps": [
                                    "Escreva a estrutura if/else: if (condição_base) return valor_base; else { recursão }.",
                                    "Use linguagem escolhida (ex: JavaScript: if (n <= 1) return 1;).",
                                    "Adicione comentários explicando por que essa é a condição base.",
                                    "Integre com chamada recursiva existente.",
                                    "Formate o código com indentação clara para visibilidade."
                                  ],
                                  "verification": "Execute o código com entrada base e confirme retorno correto sem recursão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE ou editor de código (VS Code, Replit), compilador/interpreter da linguagem.",
                                  "tips": "Teste a condição isoladamente primeiro: crie função só com if base.",
                                  "learningObjective": "Codificar condições de caso base de forma precisa e comentada.",
                                  "commonMistakes": "Erro lógico na condição (ex: <=0 em vez de ==0); esquecer return."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar o caso base",
                                  "subSteps": [
                                    "Crie testes unitários para entradas base (ex: assert(fatorial(0) === 1)).",
                                    "Use debugger para pausar na condição base e inspecionar.",
                                    "Simule stack trace manualmente para entradas pequenas.",
                                    "Corrija erros: verifique stack overflow ou valores errados.",
                                    "Documente testes em um relatório simples."
                                  ],
                                  "verification": "Todos testes de caso base passam; sem warnings de recursão infinita.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de teste (Jest para JS, JUnit para Java), debugger do IDE.",
                                  "tips": "Aumente gradualmente entradas: base → pequena recursão → maior.",
                                  "learningObjective": "Garantir que o caso base funcione corretamente via testes.",
                                  "commonMistakes": "Não testar com entradas exatas do caso base; ignorar edge cases como valores negativos."
                                }
                              ],
                              "practicalExample": "No fatorial recursivo em JavaScript: function fatorial(n) { if (n <= 1) return 1; // Caso base return n * fatorial(n-1); }. Teste fatorial(0) deve retornar 1 imediatamente, sem chamadas adicionais.",
                              "finalVerifications": [
                                "Função retorna valor correto para todas entradas de caso base sem recursão.",
                                "Não há stack overflow em execuções com entradas base.",
                                "Comentários no código explicam claramente o caso base.",
                                "Testes unitários cobrem 100% dos casos base identificados.",
                                "Fluxograma ou diagrama valida a terminação.",
                                "Simulação manual confirma execução correta."
                              ],
                              "assessmentCriteria": [
                                "Condição de caso base é precisa e retorna valor direto (sem recursão).",
                                "Identificação correta de todos os casos base necessários (múltiplos se aplicável).",
                                "Código é legível, comentado e indentado adequadamente.",
                                "Testes abrangentes passam sem erros.",
                                "Explicação escrita demonstra compreensão conceitual.",
                                "Tempo de execução para caso base é O(1), não recursivo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática (caso base como P(1)).",
                                "Lógica: Provas por casos e condicionais booleanas.",
                                "Engenharia de Software: Design de algoritmos e análise de complexidade.",
                                "Física: Modelos recursivos em fractais ou sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em busca em árvores binárias (nó nulo é caso base, retorna false), processamento de JSON aninhado (objeto vazio retorna valor padrão), ou validação de expressões matemáticas (números literais como base), garantindo eficiência e evitando crashes em aplicações web e de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Detectar ausência de caso base",
                            "description": "Analisar código recursivo para identificar riscos de recursão infinita devido à falta ou erro no caso base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Recursão e Caso Base",
                                  "subSteps": [
                                    "Defina recursão como uma técnica onde uma função chama a si mesma.",
                                    "Explique o caso base como a condição que para a recursão, evitando loop infinito.",
                                    "Discuta a condição de parada como o mecanismo que garante progressão para o caso base.",
                                    "Identifique componentes: caso recursivo (chamada a si mesmo) e caso base (condição de saída).",
                                    "Estude exemplos simples como fatorial ou soma de números."
                                  ],
                                  "verification": "Resuma em suas palavras os papéis do caso base e do caso recursivo, com um diagrama de fluxo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de recursão (ex: MDN ou livro de algoritmos), papel e caneta para diagrama.",
                                  "tips": "Use analogia de 'escada descendente' para visualizar progressão ao caso base.",
                                  "learningObjective": "Compreender a estrutura essencial de recursão e o risco de ausência de caso base.",
                                  "commonMistakes": "Confundir caso base com condição recursiva; ignorar que múltiplos casos base podem existir."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estrutura Sintática de Funções Recursivas",
                                  "subSteps": [
                                    "Localize todas as chamadas recursivas na função (procure por nome da função dentro dela).",
                                    "Identifique condicionais (if/else) que possam servir como caso base.",
                                    "Verifique se há uma condição que retorne sem chamar recursivamente.",
                                    "Examine parâmetros para garantir redução progressiva (ex: n-1 em fatorial).",
                                    "Anote fluxos possíveis: com e sem entrada que atinja caso base."
                                  ],
                                  "verification": "Marque em um código exemplo todas as chamadas recursivas e potenciais casos base.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code), exemplos de código recursivo com e sem caso base.",
                                  "tips": "Use indentação e setas para mapear fluxo de execução manualmente.",
                                  "learningObjective": "Reconhecer padrões sintáticos que indicam presença ou ausência de caso base.",
                                  "commonMistakes": "Ignorar chamadas recursivas em loops ou condições aninhadas; assumir que qualquer 'if' é caso base."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Checklist para Detecção de Ausência de Caso Base",
                                  "subSteps": [
                                    "Pergunte: Há pelo menos um 'return' sem chamada recursiva?",
                                    "Verifique: Todos os caminhos de execução levam a recursão infinita?",
                                    "Teste logicamente: Simule com entrada pequena (ex: n=0 ou n=1).",
                                    "Avalie parâmetros: Eles diminuem consistentemente?",
                                    "Documente riscos: Stack overflow, performance infinita."
                                  ],
                                  "verification": "Crie um checklist preenchido para 2 códigos: um correto e um com erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Lista de checklist impressa ou digital, exemplos de código buggy.",
                                  "tips": "Priorize caminhos de entrada zero ou mínima para testes rápidos.",
                                  "learningObjective": "Desenvolver um método sistemático para inspecionar código recursivo.",
                                  "commonMistakes": "Pular verificação de condições compostas (&&/||); não considerar entradas inválidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Detecção com Testes e Debugging",
                                  "subSteps": [
                                    "Execute o código com entradas que deveriam parar (ex: base case).",
                                    "Use debugger para observar chamadas recursivas e stack trace.",
                                    "Monitore stack size ou adicione logs para contar profundidade.",
                                    "Corrija adicionando caso base e reteste.",
                                    "Compare antes/depois para confirmar impacto."
                                  ],
                                  "verification": "Registre stack trace ou logs mostrando recursão infinita antes da correção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ambiente de execução (Python/Node.js REPL), debugger (Chrome DevTools ou pdb).",
                                  "tips": "Defina limite de recursão sys.setrecursionlimit() para testes seguros.",
                                  "learningObjective": "Confirmar detecção empiricamente e entender consequências práticas.",
                                  "commonMistakes": "Executar só com entradas grandes; ignorar warnings de stack overflow."
                                }
                              ],
                              "practicalExample": "Considere esta função fatorial sem caso base:\n```python\ndef factorial(n):\n    return n * factorial(n-1)\n```\nSimulação com n=3: factorial(3) → 3*factorial(2) → 2*factorial(1) → 1*factorial(0) → 0*factorial(-1) → infinito, causando StackOverflowError.",
                              "finalVerifications": [
                                "Identifica corretamente ausência em 5 exemplos variados de código recursivo.",
                                "Explica verbalmente o risco de recursão infinita com diagrama de stack.",
                                "Aplica checklist em código desconhecido sem erros em <5 minutos.",
                                "Corrige código ausente adicionando caso base funcional.",
                                "Distingue erro em caso base de outros bugs recursivos (ex: não progressivo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 100% em detecção de ausência.",
                                "Explicação clara: Descreve mecanismo de parada em termos lógicos.",
                                "Eficiência: Analisa estrutura em <2 minutos por função.",
                                "Criatividade em testes: Usa múltiplas entradas para validar.",
                                "Documentação: Registra checklist e evidências de forma organizada.",
                                "Generalização: Aplica a funções em linguagens diferentes (Python/JS)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática (caso base como P(0)).",
                                "Lógica: Análise de fluxogramas e provas por casos.",
                                "Engenharia de Software: Debugging e análise estática de código.",
                                "Ciência da Computação: Teoria da Computabilidade e halting problem."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, detectar casos base ausentes previne crashes por StackOverflow em algoritmos recursivos como tree traversals em apps web, parsers em compiladores ou pathfinding em games, economizando tempo de debug e melhorando robustez de sistemas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Implementar condição recursiva",
                            "description": "Criar a lógica que chama a função recursivamente com parâmetros modificados para aproximar do caso base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a condição recursiva no problema",
                                  "subSteps": [
                                    "Analise o problema para determinar quando a solução requer decomposição em subproblemas semelhantes.",
                                    "Defina claramente o que diferencia o caso recursivo do caso base.",
                                    "Escreva em pseudocódigo a estrutura if/else onde o 'else' será o recursivo.",
                                    "Verifique se o subproblema está mais próximo do caso base.",
                                    "Documente a condição lógica que ativa a recursão (ex: n > 1)."
                                  ],
                                  "verification": "Pseudocódigo com condição recursiva identificada e anotada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Problema de exemplo (fatorial ou Fibonacci)",
                                    "Editor de texto ou papel"
                                  ],
                                  "tips": "Sempre pergunte: 'Este subproblema é menor e leva ao caso base?'",
                                  "learningObjective": "Reconhecer padrões que demandam recursão e diferenciá-los do caso base.",
                                  "commonMistakes": [
                                    "Confundir condição recursiva com caso base",
                                    "Não garantir redução do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir modificações nos parâmetros para a chamada recursiva",
                                  "subSteps": [
                                    "Identifique os parâmetros da função original (ex: n em fatorial(n)).",
                                    "Determine como alterá-los para aproximar do caso base (ex: n-1).",
                                    "Considere parâmetros auxiliares se necessário (ex: acumulador).",
                                    "Escreva a expressão da chamada recursiva sem o corpo completo.",
                                    "Valide manualmente com valores pequenos se a progressão ocorre."
                                  ],
                                  "verification": "Lista de parâmetros originais vs. modificados com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de função recursiva simples",
                                    "Calculadora para simulações manuais"
                                  ],
                                  "tips": "Garanta que cada chamada reduza o 'tamanho' do problema monotonicamente.",
                                  "learningObjective": "Projetar parâmetros que garantam convergência ao caso base.",
                                  "commonMistakes": [
                                    "Modificação que não reduz o problema (ex: n+1)",
                                    "Esquecer parâmetros auxiliares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a lógica da condição recursiva no código",
                                  "subSteps": [
                                    "Estruture o if para o caso base e else para recursão.",
                                    "Insira a chamada recursiva no corpo do else com parâmetros modificados.",
                                    "Adicione comentários explicando a lógica de progressão.",
                                    "Compile ou execute sintaxe para checar erros iniciais.",
                                    "Teste com entrada que acione recursão (ex: fatorial(3))."
                                  ],
                                  "verification": "Código compilável com chamada recursiva executando sem erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE ou editor de código (Python, JavaScript)",
                                    "Exemplos de código base"
                                  ],
                                  "tips": "Use print/debug para rastrear chamadas recursivas durante testes.",
                                  "learningObjective": "Codificar corretamente a bifurcação entre base e recursão.",
                                  "commonMistakes": [
                                    "Chamada recursiva sem modificação de parâmetros",
                                    "Erro de sintaxe na condição if"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar integração e progressão da recursão",
                                  "subSteps": [
                                    "Integre completamente com o caso base implementado anteriormente.",
                                    "Execute com múltiplos valores e observe pilha de chamadas.",
                                    "Verifique se atinge o caso base sem loop infinito.",
                                    "Meça profundidade de recursão e otimize se excessiva.",
                                    "Refatore com base em testes falhos."
                                  ],
                                  "verification": "Função retorna resultados corretos para 5 entradas variadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de debug (debugger ou prints)",
                                    "Casos de teste pré-definidos"
                                  ],
                                  "tips": "Comece com valores pequenos (n=0 a 5) para evitar stack overflow.",
                                  "learningObjective": "Garantir que a recursão termine corretamente em todos os cenários.",
                                  "commonMistakes": [
                                    "Stack overflow por falta de progressão",
                                    "Ignorar casos edge"
                                  ]
                                }
                              ],
                              "practicalExample": "Para fatorial(n): Se n > 1 (condição recursiva), retorne n * fatorial(n-1), onde n-1 aproxima do caso base n==0 ou n==1.",
                              "finalVerifications": [
                                "A função chama a si mesma apenas quando fora do caso base.",
                                "Parâmetros são modificados corretamente em cada chamada.",
                                "Execução atinge o caso base em todas as entradas válidas.",
                                "Não ocorre loop infinito ou stack overflow em testes.",
                                "Resultados coincidem com solução iterativa equivalente.",
                                "Código está comentado explicando a condição recursiva."
                              ],
                              "assessmentCriteria": [
                                "Condição recursiva lógica e alinhada ao problema (30%)",
                                "Modificação de parâmetros garante convergência (25%)",
                                "Implementação sem erros sintáticos ou lógicos (20%)",
                                "Testes demonstram progressão correta (15%)",
                                "Comentários e clareza no código (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática para provar corretude.",
                                "Lógica: Estruturas condicionais e provas por casos.",
                                "Algoritmos: Padrões divide-and-conquer como quicksort.",
                                "Engenharia de Software: Gerenciamento de pilha de chamadas."
                              ],
                              "realWorldApplication": "Usado em travessia de árvores genealógicas, cálculo de combinações em jogos, parsing de expressões matemáticas em compiladores e busca em estruturas hierárquicas como sistemas de arquivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Exemplos e Implementação Prática",
                        "description": "Aplicação da recursividade em problemas clássicos como cálculo de fatorial e sequência de Fibonacci, demonstrando passagem de parâmetros e escopo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Implementar fatorial recursivo",
                            "description": "Desenvolver uma função recursiva para calcular o fatorial de um número inteiro positivo, incluindo caso base (n=0 ou n=1) e chamada recursiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Fatorial e Recursão",
                                  "subSteps": [
                                    "Defina fatorial: n! = n × (n-1) × ... × 1, com 0! = 1.",
                                    "Calcule manualmente 3! e 4! para visualizar o padrão.",
                                    "Explique recursão: função chama a si mesma com entrada menor.",
                                    "Desenhe a árvore de chamadas para factorial(3).",
                                    "Identifique o caso base: quando parar a recursão (n=0 ou n=1)."
                                  ],
                                  "verification": "Desenhe e explique a pilha de chamadas para factorial(3) em um diagrama.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos matemáticos impressos"
                                  ],
                                  "tips": "Pense na recursão como uma escada: desça até o chão (caso base) e suba multiplicando.",
                                  "learningObjective": "Dominar a definição matemática de fatorial e o mecanismo de recursão.",
                                  "commonMistakes": [
                                    "Confundir fatorial com potência",
                                    "Esquecer que 0! = 1",
                                    "Não visualizar a pilha de chamadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Assinatura da Função e o Caso Base",
                                  "subSteps": [
                                    "Escreva a assinatura: def factorial(n): ou int factorial(int n).",
                                    "Adicione verificação para n < 0 (opcional: lançar erro).",
                                    "Implemente caso base: if n == 0 or n == 1: return 1.",
                                    "Teste isoladamente o caso base com n=0 e n=1.",
                                    "Compile ou execute para confirmar sem erros."
                                  ],
                                  "verification": "Execute factorial(0) e factorial(1); ambos devem retornar 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Interpretador Python ou compilador C"
                                  ],
                                  "tips": "Sempre teste o caso base primeiro para evitar recursão infinita.",
                                  "learningObjective": "Implementar corretamente o ponto de parada da recursão.",
                                  "commonMistakes": [
                                    "Retornar 0 para n=0",
                                    "Usar if n <= 1 sem or",
                                    "Esquecer return no caso base"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Lógica Recursiva",
                                  "subSteps": [
                                    "Adicione a chamada recursiva: return n * factorial(n-1).",
                                    "Garanta que n seja inteiro positivo na chamada.",
                                    "Explique o fluxo: para n=3, 3 * factorial(2) → 3*2*factorial(1).",
                                    "Adicione print ou log para rastrear chamadas (debugging).",
                                    "Remova logs após confirmar o fluxo."
                                  ],
                                  "verification": "Execute factorial(3); deve retornar 6 com logs mostrando chamadas corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para debugging"
                                  ],
                                  "tips": "Use prints temporários para ver a profundidade da recursão.",
                                  "learningObjective": "Construir a redução progressiva do problema via recursão.",
                                  "commonMistakes": [
                                    "Chamar factorial(n) em vez de (n-1)",
                                    "Multiplicar por n+1",
                                    "Recursão infinita por falta de caso base"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Função Completamente",
                                  "subSteps": [
                                    "Crie testes unitários para n=0,1,5,10.",
                                    "Teste bordas: n=1, n grande (cuidado com overflow).",
                                    "Compare com versão iterativa para validar.",
                                    "Meça performance (opcional: tempo de execução).",
                                    "Documente a função com comentários."
                                  ],
                                  "verification": "Todos os testes passam; factorial(5) == 120.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Framework de testes (unittest em Python)",
                                    "Calculadora para valores esperados"
                                  ],
                                  "tips": "Escreva testes antes de rodar para TDD (Test-Driven Development).",
                                  "learningObjective": "Garantir robustez e corretude da implementação recursiva.",
                                  "commonMistakes": [
                                    "Não testar n=0",
                                    "Ignorar overflow em linguagens como C",
                                    "Falta de testes variados"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva def factorial(n): para n=5. Execução: factorial(5) chama 5*factorial(4) → 5*4*factorial(3) → ... → 5*4*3*2*1 = 120. Teste em Python: print(factorial(5)) deve imprimir 120.",
                              "finalVerifications": [
                                "factorial(0) retorna 1",
                                "factorial(1) retorna 1",
                                "factorial(5) retorna 120",
                                "factorial(10) retorna 3628800",
                                "Nenhum erro de recursão infinita ou stack overflow para n<=10",
                                "Função lida graciosamente com n negativo (ex: raise ValueError)"
                              ],
                              "assessmentCriteria": [
                                "Caso base implementado corretamente para n=0 e n=1",
                                "Chamada recursiva usa exatamente n * factorial(n-1)",
                                "Assinatura da função correta com parâmetro inteiro",
                                "Sem uso de loops ou estruturas iterativas",
                                "Código limpo com comentários explicando recursão",
                                "Testes unitários cobrem casos base e exemplos médios"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de permutações (n! / (n-k)!) e combinações",
                                "Algoritmos: Comparação com implementações iterativas e memoização",
                                "Lógica e Filosofia: Pensamento recursivo em fractais e estruturas auto-similares",
                                "Física: Modelagem de decaimentos exponenciais aproximados por fatoriais"
                              ],
                              "realWorldApplication": "Usado em estatística para coeficientes binomiais (probabilidades), em criptografia para chaves fatoriais grandes, em jogos para calcular arranjos de cartas e em análise combinatória para otimização de rotas (Traveling Salesman aproximado)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Implementar Fibonacci recursivo",
                            "description": "Criar uma função recursiva para a sequência de Fibonacci, definindo casos base (F(0)=0, F(1)=1) e recursão (F(n)=F(n-1)+F(n-2)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a sequência de Fibonacci e conceitos de recursão",
                                  "subSteps": [
                                    "Estude a definição da sequência: F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) para n > 1",
                                    "Calcule manualmente os primeiros termos: F(0) até F(5)",
                                    "Explique recursão: uma função que chama a si mesma com parâmetros menores",
                                    "Identifique casos base (F(0) e F(1)) e o caso recursivo",
                                    "Desenhe a árvore de chamadas recursivas para F(4)"
                                  ],
                                  "verification": "Capacidade de calcular F(5) = 5 manualmente e esboçar a árvore de recursão sem erros",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para diagramas",
                                    "Referências online sobre recursão (ex: GeeksforGeeks)"
                                  ],
                                  "tips": [
                                    "Visualize a recursão como uma árvore para evitar confusão com loops infinitos",
                                    "Comece sempre pelos casos base"
                                  ],
                                  "learningObjective": "Dominar os fundamentos teóricos da sequência de Fibonacci e recursão",
                                  "commonMistakes": [
                                    "Confundir F(0)=1 em vez de 0",
                                    "Ignorar a necessidade de múltiplos casos base",
                                    "Pensar em iteração ao invés de recursão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a assinatura da função e implementar casos base",
                                  "subSteps": [
                                    "Escolha uma linguagem de programação (ex: Python)",
                                    "Crie a assinatura da função: def fibonacci(n: int) -> int:",
                                    "Implemente o caso base para n == 0: return 0",
                                    "Implemente o caso base para n == 1: return 1",
                                    "Adicione validação básica: if n < 0: raise ValueError('n deve ser não-negativo')"
                                  ],
                                  "verification": "Execute a função com n=0 (retorna 0) e n=1 (retorna 1) sem erros",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, PyCharm)",
                                    "Interpretador Python"
                                  ],
                                  "tips": [
                                    "Use tipagem para clareza",
                                    "Teste casos base isoladamente antes de prosseguir"
                                  ],
                                  "learningObjective": "Estruturar corretamente uma função recursiva com casos base robustos",
                                  "commonMistakes": [
                                    "Esquecer validação para n negativo",
                                    "Usar return None por engano",
                                    "Erro de indentação nos ifs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a lógica recursiva",
                                  "subSteps": [
                                    "Adicione o caso recursivo: else: return fibonacci(n-1) + fibonacci(n-2)",
                                    "Adicione comentários explicando o fluxo de chamadas",
                                    "Simule mentalmente o cálculo para n=3: F(3) = F(2) + F(1) = (F(1)+F(0)) + F(1) = 2",
                                    "Discuta limitações: recursão exponencial O(2^n) e risco de stack overflow",
                                    "Opcionalmente, adicione memoização básica com dicionário (avançado)"
                                  ],
                                  "verification": "Função retorna 2 para n=3 e 3 para n=4 corretamente",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Debugger integrado (ex: pdb no Python)"
                                  ],
                                  "tips": [
                                    "Use print() temporário para rastrear chamadas recursivas",
                                    "Evite n muito grande (>30) sem memoização"
                                  ],
                                  "learningObjective": "Implementar a recursão corretamente, entendendo dependências entre chamadas",
                                  "commonMistakes": [
                                    "Chamar fibonacci(n) + fibonacci(n-1) em vez de (n-1)+(n-2)",
                                    "Falta de else levando a recursão infinita",
                                    "Não tratar n=2 corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, depurar e analisar a implementação",
                                  "subSteps": [
                                    "Crie testes unitários para n=0 até n=10",
                                    "Meça o tempo de execução para n=30 e observe lentidão",
                                    "Use debugger para inspecionar pilha de chamadas",
                                    "Compare com versão iterativa para validar resultados",
                                    "Documente limitações e sugestões de melhoria (ex: memoização)"
                                  ],
                                  "verification": "Todos os testes passam e performance é observada (lento para n grande)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Framework de testes (ex: unittest no Python)",
                                    "Cronômetro para performance"
                                  ],
                                  "tips": [
                                    "Escreva testes primeiro (TDD)",
                                    "Registre chamadas para visualizar redundâncias"
                                  ],
                                  "learningObjective": "Validar a corretude e analisar trade-offs da recursão",
                                  "commonMistakes": [
                                    "Testar apenas valores pequenos",
                                    "Ignorar stack overflow",
                                    "Confundir saída com iteração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: def fibonacci(n: int) -> int:\n    if n == 0: return 0\n    if n == 1: return 1\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(5))  # Saída: 5\n\nÁrvore para n=4: fibonacci(4) chama fibonacci(3)+fibonacci(2), etc., totalizando 5 chamadas leaf.",
                              "finalVerifications": [
                                "Função retorna valores corretos para n=0 (0), n=1 (1), n=5 (5), n=10 (55)",
                                "Não entra em loop infinito ou stack overflow para n<=20",
                                "Casos base são priorizados corretamente",
                                "Validação de entrada rejeita n negativo",
                                "Código é legível com comentários",
                                "Testes unitários cobrem 80% dos cenários"
                              ],
                              "assessmentCriteria": [
                                "Corretude: valores exatos da sequência Fibonacci",
                                "Estrutura: casos base e recursão bem definidos",
                                "Robustez: tratamento de erros e validações",
                                "Clareza: código comentado e indentado corretamente",
                                "Análise: reconhecimento de ineficiência exponencial",
                                "Testes: cobertura completa de casos edge e normais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências recursivas e análise combinatoria",
                                "Algoritmos: Complexidade temporal (O(2^n)) e otimização com DP",
                                "Engenharia de Software: Design de funções modulares e depuração",
                                "Biologia: Modelos de crescimento populacional (ex: coelhos)",
                                "Física: Fenômenos naturais com recorrência (ex: ondas)"
                              ],
                              "realWorldApplication": "Modelagem de crescimento populacional (problema original de coelhos de Fibonacci), algoritmos em finanças para séries temporais, geração de curvas em gráficos computacionais (ex: phyllotaxis em plantas), e base para programação dinâmica em problemas de otimização como caminhos em grafos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Analisar eficiência de recursão",
                            "description": "Avaliar o número de chamadas recursivas e uso de memória em exemplos como Fibonacci, comparando com versões otimizadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Recursão e Árvore de Chamadas",
                                  "subSteps": [
                                    "Defina recursão e identifique os componentes: caso base e chamada recursiva.",
                                    "Desenhe manualmente a árvore de chamadas para uma função recursiva simples como fatorial(3).",
                                    "Explique como cada nó na árvore representa uma chamada de função.",
                                    "Identifique o número total de chamadas contando os nós da árvore.",
                                    "Discuta o uso de pilha de memória para cada chamada pendente."
                                  ],
                                  "verification": "Desenhe corretamente a árvore de chamadas para fatorial(3) com 4 nós e explique o uso de memória.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Editor de código (VS Code ou similar)"
                                  ],
                                  "tips": "Comece sempre pelo caso base para evitar confusão na árvore.",
                                  "learningObjective": "Entender visualmente como a recursão se expande em chamadas múltiplas e consome memória.",
                                  "commonMistakes": [
                                    "Confundir chamadas com retornos",
                                    "Ignorar o caso base na contagem",
                                    "Não considerar chamadas duplicadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Eficiência no Exemplo Fibonacci Recursivo",
                                  "subSteps": [
                                    "Implemente a função Fibonacci recursiva clássica em Python ou JavaScript.",
                                    "Execute para n=5 e trace manualmente todas as chamadas recursivas.",
                                    "Conte o número total de chamadas (fib(n) chama fib(n-1) e fib(n-2)).",
                                    "Calcule a profundidade máxima da pilha de chamadas (igual a n).",
                                    "Estime o uso de memória como O(n) para pilha."
                                  ],
                                  "verification": "Liste todas as chamadas para fib(5), totalizando 15 chamadas, e identifique profundidade 5.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código com depurador",
                                    "Papel para anotar chamadas",
                                    "Calculadora para contagens grandes"
                                  ],
                                  "tips": "Use print statements para logar chamadas durante execução.",
                                  "learningObjective": "Quantificar ineficiências específicas do Fibonacci recursivo puro.",
                                  "commonMistakes": [
                                    "Subestimar chamadas duplicadas (fib(3) chamado múltiplas vezes)",
                                    "Confundir tempo com espaço",
                                    "Não notar crescimento exponencial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Medir Métricas de Eficiência",
                                  "subSteps": [
                                    "Adicione contadores de chamadas e profundidade máxima no código recursivo.",
                                    "Execute para vários n (3,5,7) e registre número de chamadas e pico de memória.",
                                    "Compare com complexidade teórica: O(2^n) tempo, O(n) espaço.",
                                    "Use ferramentas como profiler (cProfile em Python) para validar medições.",
                                    "Registre tempos de execução reais."
                                  ],
                                  "verification": "Relatório com dados: fib(7) ~21 chamadas, tempo >1s, memória pico 7 frames.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python com cProfile ou Node.js profiler",
                                    "Planilha para registrar dados"
                                  ],
                                  "tips": "Teste com n pequeno primeiro para evitar stack overflow.",
                                  "learningObjective": "Medir empiricamente eficiência para validar teoria.",
                                  "commonMistakes": [
                                    "Executar n muito grande causando overflow",
                                    "Ignorar overhead de chamadas de função",
                                    "Confundir medições com otimizações do compilador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Versões Otimizadas e Concluir Análise",
                                  "subSteps": [
                                    "Implemente Fibonacci com memoization (cache de resultados).",
                                    "Meça chamadas, memória e tempo para mesmo n.",
                                    "Compare métricas: recursivo vs memoizado vs iterativo.",
                                    "Discuta trade-offs: memoização reduz tempo para O(n), mas aumenta memória O(n).",
                                    "Aplique análise a outro exemplo como Hanoi ou árvore binária."
                                  ],
                                  "verification": "Tabela comparativa mostrando memoização com ~2n chamadas vs 2^n recursivo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Mesmo editor e profiler",
                                    "Exemplos de código online para referência"
                                  ],
                                  "tips": "Use dicionário para memo em Python; teste com asserts para corretude.",
                                  "learningObjective": "Avaliar quando recursão é viável e como otimizá-la.",
                                  "commonMistakes": [
                                    "Esquecer de limpar cache entre testes",
                                    "Não validar resultados numéricos",
                                    "Superestimar ganhos sem medição"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Fibonacci(5): recursivo puro faz 15 chamadas (fib(5)->fib(4)+fib(3)->... com duplicatas), profundidade 5, tempo exponencial. Memoizado: 9 chamadas únicas, cache armazena valores, tempo linear.",
                              "finalVerifications": [
                                "Desenha árvore de chamadas completa para fib(6).",
                                "Calcula corretamente número de chamadas: 2*fib(n+1)-1.",
                                "Identifica stack overflow risk para n>1000.",
                                "Compara métricas memo vs puro em tabela.",
                                "Aplica análise a fatorial ou potências.",
                                "Explica quando usar recursão vs iteração."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de chamadas recursivas (>95% correto).",
                                "Correta identificação de uso de memória e profundidade.",
                                "Uso adequado de ferramentas de profiling.",
                                "Análise comparativa clara com evidências empíricas.",
                                "Identificação de otimizações relevantes.",
                                "Clareza na explicação de trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de sequências e árvores binárias.",
                                "Algoritmos: Estudo de complexidade temporal e espacial.",
                                "Engenharia de Software: Otimização de performance e debugging.",
                                "Ciência da Computação: Estruturas de dados (hash para memo).",
                                "Física: Modelos recursivos em fractais ou simulações."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (cálculo de caminhos em mapas recursivos), parsing de HTML/XML (árvores), otimização de queries em bancos de dados, evitando stack overflow em servidores de alta carga."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Ponteiros",
                "description": "Introduz o conceito de ponteiros e seu uso em linguagens de programação.",
                "totalSkills": 34,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Definição de Ponteiro",
                    "description": "Conceito de ponteiro como variável que armazena o endereço de memória de outra variável.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Endereço de Memória",
                        "description": "Cada variável alocada na memória possui um endereço único identificado numericamente, que serve como referência para acessar seu conteúdo.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Explicar o conceito de endereço de memória",
                            "description": "Descrever que a memória RAM é organizada em células numeradas sequencialmente e que cada variável ocupa uma ou mais células com um endereço base único.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura básica da memória RAM",
                                  "subSteps": [
                                    "Explique que a RAM é um armazenamento volátil de dados acessível pela CPU.",
                                    "Descreva a RAM como composta por milhões de células individuais, cada uma capaz de armazenar um bit ou byte.",
                                    "Ilustre com um diagrama simples mostrando células alinhadas em uma grade ou linha.",
                                    "Discuta que cada célula tem uma capacidade fixa, tipicamente 1 byte (8 bits).",
                                    "Compare com uma estante de livros onde cada prateleira é uma célula numerada."
                                  ],
                                  "verification": "Desenhe um diagrama de 10 células de memória e rotule-as corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta, quadro branco ou software de desenho como Draw.io",
                                  "tips": "Use analogias cotidianas como caixas numeradas em um armazém para fixar o conceito.",
                                  "learningObjective": "Compreender que a RAM é organizada em células discretas de armazenamento.",
                                  "commonMistakes": "Confundir RAM com disco rígido (persistente vs. volátil); achar que células armazenam dados ilimitados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o endereçamento sequencial das células",
                                  "subSteps": [
                                    "Defina endereço de memória como um número único (geralmente hexadecimal ou binário) atribuído a cada célula.",
                                    "Mostre como os endereços são sequenciais: célula 0, 1, 2, etc., até bilhões.",
                                    "Demonstre com um exemplo: endereço 0x1000, 0x1001, 0x1002.",
                                    "Explique que a CPU usa esses endereços para ler/escrever dados específicos.",
                                    "Pratique convertendo decimal para hexadecimal para representar endereços."
                                  ],
                                  "verification": "Liste 5 endereços sequenciais e explique como acessá-los.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora hexadecimal, tabela de conversão decimal-hexadecimal",
                                  "tips": "Lembre-se: endereços são como números de casas em uma rua numerada sequencialmente.",
                                  "learningObjective": "Identificar e representar endereços de memória de forma sequencial.",
                                  "commonMistakes": "Pensar que endereços são aleatórios; ignorar representação em base 16."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a ocupação de células por variáveis",
                                  "subSteps": [
                                    "Explique que uma variável ocupa uma ou mais células consecutivas dependendo do seu tipo (ex: int = 4 bytes).",
                                    "Ilustre com exemplo: variável 'int x' em endereço 0x1000 ocupa 0x1000 a 0x1003.",
                                    "Discuta alinhamento de memória: variáveis alinhadas em múltiplos de seu tamanho.",
                                    "Mostre como múltiplas variáveis são alocadas sequencialmente na memória.",
                                    "Simule alocação com um programa simples em C ou pseudocódigo."
                                  ],
                                  "verification": "Desenhe alocação de 3 variáveis (char, int, double) mostrando células ocupadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C online (como Replit), simulador de memória (ex: Memory Visualizer)",
                                  "tips": "Sempre some o tamanho da variável para encontrar o próximo endereço disponível.",
                                  "learningObjective": "Calcular o espaço ocupado por variáveis na memória.",
                                  "commonMistakes": "Subestimar tamanho de tipos (ex: achar char=1 byte, mas int=2); ignorar padding."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir o conceito de endereço base único",
                                  "subSteps": [
                                    "Defina endereço base como o endereço inicial da primeira célula ocupada pela variável.",
                                    "Explique que ponteiros armazenam esse endereço base para acessar a variável.",
                                    "Diferencie endereço base de endereços subsequentes ocupados pela variável.",
                                    "Exemplo: array de 5 ints tem base no primeiro, mas ocupa 20 bytes.",
                                    "Pratique identificando endereço base em um dump de memória simulado."
                                  ],
                                  "verification": "Identifique o endereço base de uma variável em um exemplo de código com output de endereços.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código C simples com printf de &variavel, debugger como GDB ou online IDE",
                                  "tips": "Use &variavel em C para ver o endereço base na prática.",
                                  "learningObjective": "Reconhecer o endereço base como identificador único de uma variável na memória.",
                                  "commonMistakes": "Confundir endereço base com tamanho total; achar que todas as células têm o mesmo endereço."
                                }
                              ],
                              "practicalExample": "Em um programa C: int x = 42; printf(\"Endereço base de x: %p\\n\", &x); Isso mostra o endereço base único de x (ex: 0x7ffd1234), que ocupa 4 células sequenciais na RAM, ilustrando como a variável é armazenada em células numeradas.",
                              "finalVerifications": [
                                "Desenhar diagrama preciso de RAM com 3 variáveis alocadas e endereços rotulados.",
                                "Explicar verbalmente ou por escrito o que é endereço base com exemplo.",
                                "Identificar endereço base em output de programa C real.",
                                "Calcular células ocupadas por uma variável de tamanho conhecido.",
                                "Diferenciar RAM de outros storages e endereçamento sequencial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de células e endereços sequenciais (80% correto).",
                                "Correta representação de alocação de variáveis com tamanhos reais.",
                                "Uso correto de analogias e diagramas claros.",
                                "Compreensão de endereço base vs. células ocupadas.",
                                "Capacidade de aplicar em exemplo prático com código.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas numéricos (binário, hexadecimal) e aritmética modular.",
                                "Física: Conceitos de circuitos digitais e flip-flops em hardware de memória.",
                                "Engenharia: Gerenciamento de recursos limitados similar a alocação de espaço em projetos.",
                                "Lógica: Representação de estados discretos como em autômatos finitos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, entender endereços de memória é essencial para debugging de ponteiros, evitar vazamentos de memória em linguagens como C/C++, otimizar alocações em sistemas embarcados e analisar dumps de memória em investigações de falhas de segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Identificar o endereço de uma variável",
                            "description": "Usar o operador de enderçamento '&' em linguagens como C ou C++ para obter o endereço de uma variável específica, como int x; &x.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Endereço de Memória",
                                  "subSteps": [
                                    "Leia a documentação sobre como variáveis são armazenadas na memória RAM em C/C++.",
                                    "Visualize a memória como uma sequência de bytes com endereços únicos, como casas em uma rua.",
                                    "Entenda que o endereço é o 'local' onde o valor da variável reside.",
                                    "Aprenda que endereços são tipicamente representados em formato hexadecimal (ex: 0x7fff5fbff8ac).",
                                    "Compare endereço com valor: endereço é 'onde', valor é 'o quê'."
                                  ],
                                  "verification": "Escreva uma explicação em 2-3 frases definindo endereço de memória e dê um exemplo analógico.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Documentação C/C++ (man pages ou online)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use analogias cotidianas como 'endereço de casa' para fixar o conceito.",
                                    "Lembre-se: endereços mudam a cada execução do programa."
                                  ],
                                  "learningObjective": "Definir e diferenciar endereço de memória do valor de uma variável.",
                                  "commonMistakes": [
                                    "Confundir endereço com o valor armazenado.",
                                    "Acreditar que endereços são fixos entre execuções do programa."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma Variável Simples",
                                  "subSteps": [
                                    "Abra um editor de código e crie um programa C básico com #include <stdio.h>.",
                                    "Declare uma variável inteira: int x = 42;.",
                                    "Adicione uma função main() e imprima o valor de x usando printf(\"Valor de x: %d\\n\", x);.",
                                    "Compile e execute o código para confirmar que o valor é exibido corretamente.",
                                    "Experimente alterar o valor de x e reexecute."
                                  ],
                                  "verification": "O programa compila sem erros e imprime o valor correto da variável.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Compilador GCC ou online como Replit/CodePen",
                                    "Editor de texto (VS Code, Notepad++)"
                                  ],
                                  "tips": [
                                    "Sempre inclua return 0; no final de main().",
                                    "Teste com valores diferentes para observar mudanças."
                                  ],
                                  "learningObjective": "Declarar e manipular uma variável básica em C.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula após a declaração.",
                                    "Usar %d incorretamente no printf."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Operador de Endereçamento '&'",
                                  "subSteps": [
                                    "No código existente, adicione uma linha: printf(\"Endereço de x: %p\\n\", &x);.",
                                    "Entenda que &x retorna o endereço de x na memória.",
                                    "Compile o código atualizado.",
                                    "Execute e observe a saída: um endereço hexadecimal como 0x7ffd1b2c4a4c.",
                                    "Anote o endereço exibido e compare com múltiplas execuções."
                                  ],
                                  "verification": "O programa imprime tanto o valor quanto o endereço corretamente sem erros de compilação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Terminal para execução"
                                  ],
                                  "tips": [
                                    "Use %p para imprimir ponteiros (endereços).",
                                    "Não esqueça o & antes da variável!"
                                  ],
                                  "learningObjective": "Usar o operador & para obter o endereço de uma variável.",
                                  "commonMistakes": [
                                    "Omitir o & e imprimir o valor em vez do endereço.",
                                    "Usar %d em vez de %p para endereços."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Experimentar com Endereços",
                                  "subSteps": [
                                    "Declare múltiplas variáveis (int y = 10; char z = 'A';) e imprima seus endereços.",
                                    "Observe se os endereços são próximos (devido a alocação sequencial na stack).",
                                    "Crie uma função que receba o endereço de uma variável e a modifique.",
                                    "Execute várias vezes e note variações nos endereços.",
                                    "Pesquise brevemente sobre stack vs heap para contexto futuro."
                                  ],
                                  "verification": "Crie e execute um programa com endereços de 3 variáveis diferentes, explicando as saídas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Referências online sobre memória em C"
                                  ],
                                  "tips": [
                                    "Endereços em stack são relativos e mudam por execução.",
                                    "Use gdb ou debugger para inspecionar memória (opcional)."
                                  ],
                                  "learningObjective": "Interpretar saídas de endereços e aplicar em cenários múltiplos.",
                                  "commonMistakes": [
                                    "Assumir endereços fixos para hardcoding.",
                                    "Ignorar diferenças por tipo de variável (tamanhos afetam offsets)."
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo de código C completo:\n#include <stdio.h>\nint main() {\n    int x = 42;\n    printf(\"Valor de x: %d\\n\", x);\n    printf(\"Endereço de x: %p\\n\", &x);\n    return 0;\n}\nSaída esperada:\nValor de x: 42\nEndereço de x: 0x7fff5fbff8ac\n(Este endereço varia por execução).",
                              "finalVerifications": [
                                "Explicar verbalmente o que o operador & faz.",
                                "Escrever código que imprime endereço de uma variável sem erros.",
                                "Diferenciar saída de valor vs endereço em printf.",
                                "Identificar endereço em uma saída de programa fornecida.",
                                "Aplicar & em variável de tipo float ou char corretamente.",
                                "Prever que endereços mudam entre execuções."
                              ],
                              "assessmentCriteria": [
                                "Uso correto e consistente do operador &.",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Código compila e executa produzindo endereços válidos.",
                                "Interpretação precisa de saídas hexadecimais.",
                                "Identificação e correção de erros comuns.",
                                "Criatividade em extensões do exemplo básico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão e interpretação de números hexadecimais.",
                                "Física: Analogias com localizações físicas e endereçamento em circuitos.",
                                "Engenharia de Software: Fundamentos para ponteiros e gerenciamento de memória.",
                                "Lógica e Algoritmos: Conceitos de referência indireta.",
                                "Informática Geral: Modelos de memória von Neumann."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software de sistemas, jogos (gerenciamento de assets via ponteiros), embedded systems (controle preciso de memória limitada) e debugging (usar endereços para rastrear vazamentos de memória com ferramentas como Valgrind)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Diferenciar endereço de valor da variável",
                            "description": "Compreender a distinção entre o valor armazenado na variável (conteúdo) e seu endereço de memória (localização).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variável e seu valor",
                                  "subSteps": [
                                    "Defina o que é uma variável em programação: um nome que representa um espaço na memória.",
                                    "Explique que o valor é o conteúdo armazenado nesse espaço (ex: número, texto).",
                                    "Crie uma analogia: a variável é como uma caixa, o valor é o que está dentro dela.",
                                    "Declare uma variável simples em C: int idade = 25; e discuta o que 'idade' armazena."
                                  ],
                                  "verification": "Escreva uma definição curta e declare uma variável com valor, explicando o conteúdo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto, compilador C (como GCC), terminal.",
                                  "tips": "Sempre pense na variável como um 'rótulo' para o conteúdo, não o conteúdo em si.",
                                  "learningObjective": "Identificar que o valor é o dado armazenado na variável.",
                                  "commonMistakes": "Confundir o nome da variável com o valor (ex: achar que 'idade' é 25, não o conteúdo)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de endereço de memória",
                                  "subSteps": [
                                    "Explique que toda variável tem um endereço único na memória RAM, como um número de casa.",
                                    "Use o operador & para obter o endereço: &idade retorna o local da memória.",
                                    "Compile e execute código que imprime o endereço com printf(\"%p\", &idade);.",
                                    "Observe que o endereço é um número hexadecimal único por execução.",
                                    "Discuta que o endereço muda a cada execução do programa."
                                  ],
                                  "verification": "Execute código que imprima o endereço de uma variável e anote o resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C, terminal para execução.",
                                  "tips": "Lembre-se: endereço é 'onde' está, valor é 'o que' está lá.",
                                  "learningObjective": "Reconhecer o endereço como localização física na memória.",
                                  "commonMistakes": "Achar que o endereço é fixo ou que pode ser alterado diretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar endereço e valor na prática com código",
                                  "subSteps": [
                                    "Escreva código comparando: printf(\"Valor: %d, Endereço: %p\", idade, &idade);.",
                                    "Crie um ponteiro: int *p = &idade; e imprima *p (valor) vs p (endereço).",
                                    "Altere o valor de idade e observe que *p muda, mas p permanece o mesmo.",
                                    "Teste múltiplas variáveis para ver endereços diferentes.",
                                    "Explique verbalmente: endereço aponta para o local, valor é lido/desgravado dali."
                                  ],
                                  "verification": "Modifique o valor via variável e via ponteiro, confirmando que endereço não muda.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C, IDE como Code::Blocks ou VS Code com extensão C.",
                                  "tips": "Use %p para endereços e converta ponteiros para void* se necessário.",
                                  "learningObjective": "Distinguir visualmente endereço (hex) de valor (int/string).",
                                  "commonMistakes": "Confundir *p (valor) com p (endereço) ao imprimir."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a diferenciação em cenários comuns",
                                  "subSteps": [
                                    "Simule um erro comum: tentar atribuir valor a endereço diretamente.",
                                    "Crie função que recebe ponteiro e modifica valor original via endereço.",
                                    "Debugue código onde alguém confunde endereço com valor.",
                                    "Compare com arrays: nome do array é endereço da primeira posição.",
                                    "Resuma em um diagrama: caixa com endereço e valor."
                                  ],
                                  "verification": "Desenhe um diagrama de memória para uma variável e ponteiro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel/caneta para diagrama, compilador C.",
                                  "tips": "Desenhe sempre: [Endereço: 0x100] -> valor: 25.",
                                  "learningObjective": "Aplicar distinção em funções e debugging.",
                                  "commonMistakes": "Esquecer que ponteiro armazena endereço, não valor."
                                }
                              ],
                              "practicalExample": "Em C: int x = 10; int *ptr = &x; printf(\"Valor de x: %d\\n\", x); printf(\"Endereço de x: %p\\n\", &x); printf(\"Valor via ptr: %d\\n\", *ptr); printf(\"Endereço em ptr: %p\\n\", ptr); Saída mostra valor=10 e endereço=0x7ffd... (hex), provando distinção.",
                              "finalVerifications": [
                                "Explica corretamente a diferença entre endereço e valor sem hesitação.",
                                "Imprime endereço e valor de uma variável usando & e variável diretamente.",
                                "Usa ponteiro para acessar valor sem alterar endereço.",
                                "Identifica em código qual linha acessa endereço vs valor.",
                                "Desenha diagrama de memória correto para variável + ponteiro.",
                                "Detecta erro em código que confunde os dois conceitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação conceitual (80%+ correto).",
                                "Execução correta de código com operadores & e *.",
                                "Identificação de 3+ diferenças chave entre endereço e valor.",
                                "Criação de diagrama de memória sem erros.",
                                "Aplicação em exemplo prático sem confusão.",
                                "Detecção de erros comuns em cenários dados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como coordenadas em um espaço de memória.",
                                "Física: Analogia com localização física de objetos no espaço.",
                                "Lógica: Distinção entre referência e conteúdo, como em conjuntos.",
                                "Informática Geral: Base para estruturas de dados como listas ligadas."
                              ],
                              "realWorldApplication": "Essencial em programação de baixo nível (sistemas embarcados, jogos), debugging de vazamentos de memória, otimização de performance e desenvolvimento de linguagens como C/C++ onde ponteiros gerenciam alocação dinâmica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Declaração de Ponteiro",
                        "description": "Uma variável ponteiro é declarada especificando o tipo de dado que ela aponta, seguido de '*' e o nome da variável.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Declarar uma variável ponteiro",
                            "description": "Escrever a sintaxe correta para declarar um ponteiro, como 'int *ptr;' em C/C++, indicando que ptr pode armazenar o endereço de uma variável int.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Ponteiros e Endereços de Memória",
                                  "subSteps": [
                                    "Estude o conceito de endereço de memória: cada variável tem um endereço único na RAM.",
                                    "Aprenda o operador '&' (endereço de) que retorna o endereço de uma variável.",
                                    "Diferencie valor de uma variável do seu endereço usando exemplos simples como int x = 5;.",
                                    "Visualize memória como uma rua com casas numeradas, onde ponteiros são 'placas' apontando para casas.",
                                    "Leia documentação oficial de C/C++ sobre ponteiros (ex: cppreference.com)."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre uma variável e seu endereço, e escreva um exemplo com '&'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (VS Code, Code::Blocks)",
                                    "Compilador C/C++ (GCC)",
                                    "Documentação de ponteiros em C (cppreference.com/pointers)"
                                  ],
                                  "tips": [
                                    "Use um depurador para visualizar endereços reais durante a execução.",
                                    "Desenhe diagramas de memória à mão para fixar o conceito."
                                  ],
                                  "learningObjective": "Compreender que ponteiros armazenam endereços de memória, não valores.",
                                  "commonMistakes": [
                                    "Confundir ponteiro com a variável apontada.",
                                    "Esquecer que endereços são números hexadecimais grandes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Sintaxe Básica de Declaração de Ponteiro",
                                  "subSteps": [
                                    "Memorize a sintaxe: tipo *nomePonteiro; ex: int *ptr;.",
                                    "Entenda o papel do '*': indica que a variável é um ponteiro para o tipo especificado.",
                                    "Escreva declarações para ponteiro de int, char e float.",
                                    "Note que o ponteiro é inicializado como NULL ou lixo até atribuir um endereço.",
                                    "Pratique em um editor: declare múltiplos ponteiros na mesma linha (int *ptr1, *ptr2;)."
                                  ],
                                  "verification": "Escreva corretamente 'int *ptr;' e compile um código vazio com essa declaração sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto/IDE",
                                    "Compilador C/C++"
                                  ],
                                  "tips": [
                                    "Sempre declare ponteiros com tipo explícito para evitar ambiguidades.",
                                    "Use espaços ao redor do '*' para legibilidade: int * ptr;"
                                  ],
                                  "learningObjective": "Dominar a sintaxe exata para declarar um ponteiro simples.",
                                  "commonMistakes": [
                                    "Escrever 'int& ptr' (referência C++ em vez de ponteiro).",
                                    "Omitir o ';' no final da declaração."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Declaração de Ponteiros para Diferentes Tipos e Estruturas",
                                  "subSteps": [
                                    "Declare ponteiro para int: int *ptr_int;.",
                                    "Declare para char: char *ptr_char; e para double: double *ptr_double;.",
                                    "Declare ponteiro para array: int arr[5]; int *ptr_arr = arr;.",
                                    "Declare ponteiro para ponteiro: int **ptr_ptr;.",
                                    "Escreva um programa declarando 5 ponteiros diferentes e imprima seus valores (devem ser lixo ou NULL)."
                                  ],
                                  "verification": "Compile e execute um código com declarações variadas sem warnings ou erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "IDE com suporte a C/C++",
                                    "Terminal para compilar (gcc arquivo.c -o saida)"
                                  ],
                                  "tips": [
                                    "Inicialize ponteiros com NULL: int *ptr = NULL; para segurança.",
                                    "Teste em C e C++ para notar diferenças sutis."
                                  ],
                                  "learningObjective": "Aplicar declaração de ponteiros em contextos variados de tipos.",
                                  "commonMistakes": [
                                    "Declarar array como ponteiro sem entender decay: int *arr vs int arr[].",
                                    "Confundir tamanho do ponteiro com o tipo apontado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Testar Declarações em Código Real",
                                  "subSteps": [
                                    "Crie um programa main() declarando uma variável int x = 10; e ponteiro int *ptr = &x;.",
                                    "Compile com gcc e execute, imprimindo &x e ptr para confirmar igualdade.",
                                    "Use gdb ou depurador para inspecionar valores de ponteiros.",
                                    "Teste erros comuns: declare sem '*' e veja falha de compilação.",
                                    "Refatore o código adicionando mais declarações e verifique com valgrind por leaks (mesmo sem alocação)."
                                  ],
                                  "verification": "Programa compila, executa e demonstra ponteiro apontando corretamente via printf.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador GCC/Clang",
                                    "Depurador GDB ou IDE debugger",
                                    "Valgrind para análise de memória"
                                  ],
                                  "tips": [
                                    "Sempre compile com -Wall -Wextra para pegar warnings em ponteiros não inicializados.",
                                    "Imprima ponteiros com %p em printf."
                                  ],
                                  "learningObjective": "Validar declarações através de compilação e execução prática.",
                                  "commonMistakes": [
                                    "Desreferenciar ponteiro não inicializado (*ptr sem ptr = &x).",
                                    "Imprimir ponteiro como %d em vez de %p."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de gerenciamento de estoque, declare int estoque = 100; int *ptr_estoque = &estoque; para permitir modificações indiretas via funções, simulando passagem por referência.",
                              "finalVerifications": [
                                "Declara corretamente 'int *ptr;' sem erros de sintaxe.",
                                "Diferencia endereço (&var) do valor da variável.",
                                "Compila código com ponteiros para múltiplos tipos sem warnings.",
                                "Explica o papel do '*' na declaração.",
                                "Inicializa ponteiro com NULL ou endereço válido.",
                                "Identifica erros comuns como falta de '*' ou ';'."
                              ],
                              "assessmentCriteria": [
                                "Precisão da sintaxe em 100% das declarações testadas.",
                                "Correta distinção entre ponteiro, endereço e valor (entrevista oral).",
                                "Código compilável e executável sem erros ou warnings.",
                                "Uso consistente de inicialização segura (NULL).",
                                "Explicação clara de conceitos em relatório curto.",
                                "Aplicação em exemplo prático sem falhas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como números hexadecimais e aritmética de ponteiros.",
                                "Física: Analogia de memória como endereços físicos em circuitos.",
                                "Engenharia: Otimização de memória em sistemas embarcados.",
                                "Lógica: Fluxo de dados indiretos similar a funções matemáticas compostas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (Unity/C++), ponteiros declaram handles para objetos gráficos; em sistemas operacionais, gerenciam tabelas de páginas de memória para alocação dinâmica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Atribuir endereço a um ponteiro",
                            "description": "Realizar a atribuição de um endereço de memória a uma variável ponteiro, como 'ptr = &x;', onde x é uma variável existente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e declarar a variável base",
                                  "subSteps": [
                                    "Instale ou abra um compilador C (ex: GCC no Linux ou Code::Blocks).",
                                    "Crie um novo arquivo .c com #include <stdio.h> e int main().",
                                    "Declare uma variável inteira: int x = 10;",
                                    "Compile e execute para verificar que a variável funciona isoladamente.",
                                    "Adicione printf(\"Valor de x: %d\\n\", x); para testar."
                                  ],
                                  "verification": "O programa compila e imprime o valor de x corretamente sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Compilador C (GCC ou IDE como Code::Blocks)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use valores simples como 10 para facilitar depuração.",
                                  "learningObjective": "Compreender que toda variável tem um endereço de memória associado.",
                                  "commonMistakes": [
                                    "Esquecer #include <stdio.h>",
                                    "Falta de ponto e vírgula",
                                    "Não compilar antes de prosseguir"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar a variável ponteiro",
                                  "subSteps": [
                                    "Dentro de main(), declare o ponteiro: int *ptr;",
                                    "Não inicialize ainda; apenas declare para entender a sintaxe.",
                                    "Compile o código atualizado para verificar a declaração.",
                                    "Adicione um comentário explicando: // ptr é um ponteiro para int.",
                                    "Teste compilação sem atribuição."
                                  ],
                                  "verification": "Compilação bem-sucedida sem warnings sobre ptr não inicializado.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Mesmo compilador e editor do passo anterior"
                                  ],
                                  "tips": "Lembre-se: * indica ponteiro; o tipo deve coincidir com a variável base.",
                                  "learningObjective": "Dominar a sintaxe de declaração de ponteiros.",
                                  "commonMistakes": [
                                    "Esquecer o *",
                                    "Usar tipo errado (ex: char* para int)",
                                    "Inicializar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter e atribuir o endereço da variável ao ponteiro",
                                  "subSteps": [
                                    "Use o operador &: ptr = &x;",
                                    "Adicione printf(\"Endereço armazenado em ptr: %p\\n\", (void*)ptr);",
                                    "Compile e execute para observar o endereço.",
                                    "Compare com printf(\"Endereço de x: %p\\n\", (void*)&x);",
                                    "Verifique se os endereços são iguais."
                                  ],
                                  "verification": "Os valores impressos para &x e ptr são idênticos.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de texto"
                                  ],
                                  "tips": "O operador & sempre retorna o endereço; não confunda com valor.",
                                  "learningObjective": "Executar corretamente a atribuição de endereço usando &.",
                                  "commonMistakes": [
                                    "Esquecer &, atribuindo valor: ptr = x",
                                    "Falta de cast (void*) em %p",
                                    "Não comparar endereços"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e dereferenciar o ponteiro",
                                  "subSteps": [
                                    "Adicione printf(\"Valor via ponteiro: %d\\n\", *ptr);",
                                    "Execute e confirme que *ptr == x (10).",
                                    "Altere x para 20 e reexecute para ver mudança refletida em *ptr.",
                                    "Compile e teste cenários de erro (ex: atribuir sem &).",
                                    "Documente o que aprendeu em um comentário."
                                  ],
                                  "verification": "Alterações em x afetam *ptr; código sem erros de segmentação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use * para acessar o valor no endereço; evite dereferenciar ponteiros nulos.",
                                  "learningObjective": "Confirmar que a atribuição funcionou acessando o valor indireto.",
                                  "commonMistakes": [
                                    "Dereferenciar ponteiro não inicializado",
                                    "Confundir ptr com *ptr",
                                    "Não testar modificações"
                                  ]
                                }
                              ],
                              "practicalExample": "#include <stdio.h>\\nint main() {\\n    int x = 10;\\n    int *ptr;\\n    ptr = &x;\\n    printf(\"Endereço de x: %p\\n\", (void*)&x);\\n    printf(\"Valor de ptr: %p\\n\", (void*)ptr);\\n    printf(\"Valor via ponteiro: %d\\n\", *ptr);\\n    x = 20;\\n    printf(\"Novo valor via ponteiro: %d\\n\", *ptr);\\n    return 0;\\n}\\n/* Saída esperada: endereços iguais, valores 10 e 20 */",
                              "finalVerifications": [
                                "Código compila sem erros ou warnings.",
                                "Endereços de &x e ptr são idênticos.",
                                "Dereferência (*ptr) retorna o valor correto de x.",
                                "Modificações em x são refletidas em *ptr.",
                                "Sem falhas de segmentação ao executar.",
                                "Compreensão verbal: explicar o que & e * fazem."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe correta de declaração e atribuição (100% precisão).",
                                "Correta interpretação de saída de printf com %p e *.",
                                "Identificação de erros comuns (ex: ptr = x vs ptr = &x).",
                                "Capacidade de modificar e testar variações.",
                                "Explicação conceitual clara do endereço de memória.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como números hexadecimais e aritmética de ponteiros.",
                                "Física: Analogia de ponteiros com referências a locais físicos na memória.",
                                "Engenharia de Software: Base para alocação dinâmica (malloc/free).",
                                "Algoritmos: Uso em listas ligadas e árvores.",
                                "Sistemas Operacionais: Gerenciamento de memória virtual."
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos (Unity/C++ para otimizar performance), sistemas embarcados (controle de sensores via ponteiros para economizar RAM), bancos de dados (acesso indireto a registros) e engines de software como Chromium para manipulação eficiente de dados em heap."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1.1",
                              "10.1.7.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.1.2.3",
                            "name": "Verificar tipos compatíveis para ponteiros",
                            "description": "Entender que o tipo do ponteiro deve corresponder ao tipo da variável apontada para evitar erros de compilação ou comportamento indefinido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Tipos e Declarações de Ponteiros",
                                  "subSteps": [
                                    "Leia a sintaxe de declaração de ponteiro: tipo* nomePonteiro;",
                                    "Identifique exemplos de ponteiros para tipos primitivos como int*, char*, float*;",
                                    "Explique por que o tipo do ponteiro especifica o tamanho e interpretação dos dados apontados;",
                                    "Compare ponteiro void* (genérico) com ponteiros tipados para entender limitações iniciais;",
                                    "Anote diferenças entre ponteiro para int e ponteiro para char em termos de bytes."
                                  ],
                                  "verification": "Resuma em uma frase por que tipos devem combinar e liste 3 exemplos de declarações corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto, documentação de C/C++ sobre ponteiros (ex: cppreference.com)",
                                  "tips": "Sempre leia a declaração de ponteiro da direita para a esquerda: nome é ponteiro para tipo.",
                                  "learningObjective": "Compreender a relação fundamental entre tipo do ponteiro e tipo apontado.",
                                  "commonMistakes": "Confundir ponteiro com o tipo apontado; ignorar que void* requer cast explícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Incompatibilidades de Tipos em Declarações",
                                  "subSteps": [
                                    "Declare uma variável int e tente atribuir seu endereço a um char* sem cast.",
                                    "Tente compilar o código e observe mensagens de erro do compilador.",
                                    "Repita com float* apontando para int e double* para short.",
                                    "Registre os erros comuns como 'incompatible pointer type' ou 'invalid conversion'.",
                                    "Teste atribuição de ponteiro tipado para void* (deve compilar sem aviso)."
                                  ],
                                  "verification": "Compile 3 códigos incompatíveis e capture screenshots dos erros de compilação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador C/C++ (GCC/Clang), IDE como VS Code ou Code::Blocks",
                                  "tips": "Use flags -Wall -Wextra no GCC para erros mais detalhados.",
                                  "learningObjective": "Reconhecer padrões de erros causados por mismatch de tipos em ponteiros.",
                                  "commonMistakes": "Assumir que todos os ponteiros são intercambiáveis; esquecer de incluir headers."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Comportamento em Tempo de Execução com Tipos Incompatíveis",
                                  "subSteps": [
                                    "Use cast explícito (int*) para atribuir endereço de char a int* e compile com warnings.",
                                    "Execute código que dereferencia ponteiro incompatível e observe valores garbage ou crashes.",
                                    "Compare saída de dereferência correta vs. incorreta (ex: int* em char resulta em múltiplos bytes).",
                                    "Teste alinhamento de memória: declare structs e ponteiros para campos de tamanhos diferentes.",
                                    "Documente cenários de comportamento indefinido (UB) como acessar bytes errados."
                                  ],
                                  "verification": "Execute 2 programas: um correto e um com cast forçado; compare saídas e explique diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador com debugger (GDB), terminal para execução",
                                  "tips": "Evite dereferenciar ponteiros nulos; use printf para inspecionar valores.",
                                  "learningObjective": "Entender riscos de runtime além de erros de compilação.",
                                  "commonMistakes": "Ignorar warnings de cast; assumir que cast resolve todos os problemas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Correções e Verificações em Códigos Reais",
                                  "subSteps": [
                                    "Pegue um código com múltiplos ponteiros e identifique/corriga 3 mismatches de tipo.",
                                    "Implemente uma função que valida compatibilidade de ponteiro e variável via comparação de tipos.",
                                    "Teste com arrays: int[] vs. char* para strings binárias.",
                                    "Crie um checklist pessoal para declarações: 'Tipo ponteiro == tipo variável?'.",
                                    "Refatore código legado com ponteiros void* para tipados onde possível."
                                  ],
                                  "verification": "Corrija e compile com sucesso um código fornecido com 5 erros de tipo de ponteiro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplos de código com erros (GitHub snippets), linter como cppcheck",
                                  "tips": "Use typedef para tipos complexos para reduzir erros de digitação.",
                                  "learningObjective": "Aplicar verificação de tipos em cenários práticos de codificação.",
                                  "commonMistakes": "Overuse de void* sem casts; não testar após correções."
                                }
                              ],
                              "practicalExample": "Declare int x = 42; int* p = &x; // Correto. char* q = &x; // Erro de compilação. Com cast: char* q = (char*)&x; // Compila, mas deref q lê apenas 1 byte, causando UB em printf('%d', *p).",
                              "finalVerifications": [
                                "Declara ponteiro correto sem erros de compilação para 5 tipos diferentes.",
                                "Identifica e explica erro em código com mismatch int* e float.",
                                "Demonstra UB em runtime com cast forçado e compara com versão correta.",
                                "Cria função que usa ponteiro tipado corretamente para swap de variáveis.",
                                "Lista 3 consequências de tipos incompatíveis (erro compile, misaligned access, UB)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de mismatches (100% em testes).",
                                "Explicação clara de erros de compilação vs. runtime.",
                                "Códigos corrigidos compilam e executam sem warnings ou UB.",
                                "Uso correto de casts apenas quando intencional e documentado.",
                                "Checklist pessoal demonstra verificação proativa de tipos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Alinhamento de memória e tamanhos de tipos (aritmética de ponteiros).",
                                "Lógica e Algoritmos: Validação de tipos como pré-condição em funções.",
                                "Engenharia de Software: Boas práticas de tipagem estática para robustez.",
                                "Física/Computação: Modelagem de endereços de memória como vetores físicos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de kernels de SO ou embedded systems, tipos incompatíveis causam crashes; verificação previne bugs em gerenciamento de memória como malloc/free ou drivers de hardware."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.3",
                        "name": "Desreferenciamento de Ponteiro",
                        "description": "Acessar o valor armazenado no endereço guardado pelo ponteiro usando o operador '*'.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.3.1",
                            "name": "Usar o operador de desreferenciamento",
                            "description": "Aplicar '*' para acessar o conteúdo da variável apontada, como '*ptr' que retorna o valor de x quando ptr = &x.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a declaração e inicialização de um ponteiro",
                                  "subSteps": [
                                    "Declare uma variável inteira simples, como 'int x = 42;'.",
                                    "Declare um ponteiro para inteiro usando 'int *ptr;'.",
                                    "Inicialize o ponteiro com o endereço da variável usando 'ptr = &x;'.",
                                    "Explique verbalmente ou anote o que '&' faz (operador de endereço).",
                                    "Compile um código básico que declara e inicializa sem desreferenciar."
                                  ],
                                  "verification": "O código compila sem erros e o ponteiro é inicializado corretamente (use printf para mostrar endereço com %p).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C/C++ (GCC ou online como Replit)",
                                    "Editor de texto (VS Code)"
                                  ],
                                  "tips": "Sempre inicialize ponteiros para evitar 'dangling pointers'.",
                                  "learningObjective": "Compreender como criar e apontar um ponteiro para uma variável válida.",
                                  "commonMistakes": [
                                    "Esquecer o '&' na inicialização",
                                    "Declarar ponteiro sem tipo correto",
                                    "Usar ponteiro não inicializado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o operador '*' para ler o valor desreferenciado",
                                  "subSteps": [
                                    "Adicione uma instrução printf('*ptr = %d\\n', *ptr); ao código.",
                                    "Compile e execute para verificar se o valor de x é exibido corretamente.",
                                    "Teste alterando o valor de x e observe se *ptr reflete a mudança.",
                                    "Compare printf('%d', x) e printf('%d', *ptr) para confirmar igualdade.",
                                    "Anote a diferença entre ptr (endereço) e *ptr (valor)."
                                  ],
                                  "verification": "A saída do programa mostra o valor correto de x via *ptr, igual a x diretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C/C++",
                                    "Editor de texto"
                                  ],
                                  "tips": "Lembre-se: *ptr é sinônimo de x quando ptr = &x.",
                                  "learningObjective": "Usar '*' para acessar e ler o conteúdo apontado pelo ponteiro.",
                                  "commonMistakes": [
                                    "Confundir ptr com *ptr na impressão",
                                    "Desreferenciar ponteiro NULL",
                                    "Erro de sintaxe no *"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Usar o operador '*' para modificar o valor via ponteiro",
                                  "subSteps": [
                                    "Adicione '*ptr = 100;' após a inicialização.",
                                    "Imprima x e *ptr antes e depois da modificação.",
                                    "Execute e confirme que x foi alterado indiretamente.",
                                    "Teste com múltiplas variáveis para observar o efeito.",
                                    "Escreva um comentário explicando por que x muda."
                                  ],
                                  "verification": "O valor de x é alterado corretamente após '*ptr = novo_valor' e exibido como esperado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C/C++",
                                    "Editor de texto"
                                  ],
                                  "tips": "Desreferenciar permite modificação indireta, útil para funções.",
                                  "learningObjective": "Modificar valores através de ponteiros usando desreferenciamento.",
                                  "commonMistakes": [
                                    "Modificar ptr em vez de *ptr",
                                    "Não inicializar antes de desreferenciar",
                                    "Overflow em tipos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar verificações de segurança e exemplos compostos",
                                  "subSteps": [
                                    "Adicione verificação if(ptr != NULL) antes de desreferenciar.",
                                    "Crie um exemplo com array: int arr[3] = {1,2,3}; int *p = arr; printf('%d', *p);",
                                    "Teste desreferenciamento em função: void func(int *p) { *p = 50; }",
                                    "Compile e depure qualquer erro de segmentação.",
                                    "Registre 3 cenários onde desreferenciamento falha."
                                  ],
                                  "verification": "Código roda sem crashes, verificações previnem erros e função modifica via ponteiro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C/C++ com debugger (GDB opcional)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Sempre cheque NULL para ponteiros de entrada em funções.",
                                  "learningObjective": "Aplicar desreferenciamento de forma segura em contextos reais.",
                                  "commonMistakes": [
                                    "Desreferenciar NULL ou ponteiro inválido",
                                    "Off-by-one em arrays",
                                    "Não passar endereço para funções"
                                  ]
                                }
                              ],
                              "practicalExample": "```c\n#include <stdio.h>\nint main() {\n    int x = 10;\n    int *ptr = &x;\n    printf(\"Valor de x: %d\\n\", x);          // 10\n    printf(\"Via ponteiro: %d\\n\", *ptr);    // 10\n    *ptr = 20;\n    printf(\"Novo x: %d\\n\", x);             // 20\n    return 0;\n}\n```\nSaída esperada: 10, 10, 20. Demonstra leitura e escrita via *.",
                              "finalVerifications": [
                                "Código compila sem warnings ou erros.",
                                "Desreferenciamento lê o valor correto da variável.",
                                "Desreferenciamento modifica a variável original.",
                                "Programa executa sem segmentation fault.",
                                "Diferença entre endereço (ptr) e valor (*ptr) é clara na saída.",
                                "Verificação de NULL é implementada em exemplos avançados."
                              ],
                              "assessmentCriteria": [
                                "Explica corretamente o papel do '*' como operador de desreferenciamento.",
                                "Escreve código funcional que lê e modifica via ponteiro sem erros.",
                                "Identifica e corrige erros comuns como desreferenciar NULL.",
                                "Demonstra uso em funções ou arrays.",
                                "Tempo de execução de exemplos é eficiente e sem leaks.",
                                "Comunica conceitos com exemplos próprios corretos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceito de indireção similar a funções compostas ou vetores.",
                                "Lógica e Algoritmos: Base para estruturas como listas encadeadas e árvores.",
                                "Física/Engenharia: Analogia com endereços físicos e referências.",
                                "Desenvolvimento de Software: Essencial para passagem por referência em funções."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, o desreferenciamento é crucial para alocação dinâmica de memória (malloc/free), implementação de listas encadeadas, árvores binárias e passagem eficiente de parâmetros em funções, otimizando performance em sistemas embarcados, jogos e bancos de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.1.3.2",
                            "name": "Modificar valor via ponteiro",
                            "description": "Alterar o valor da variável original através do ponteiro, demonstrando como '*ptr = 10;' modifica x.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar e inicializar variável e ponteiro",
                                  "subSteps": [
                                    "Declare uma variável inteira, por exemplo: int x = 5;",
                                    "Declare um ponteiro para inteiro: int *ptr;",
                                    "Inicialize o ponteiro com o endereço da variável: ptr = &x;",
                                    "Imprima o valor inicial de x e o endereço armazenado em ptr para confirmação.",
                                    "Compile e execute o código para verificar a inicialização."
                                  ],
                                  "verification": "Execute o programa e confirme que o valor de x é exibido corretamente e que ptr contém o endereço de x (use printf('%p', ptr) e &x).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto (VS Code ou similar), compilador GCC, terminal.",
                                  "tips": "Sempre use & para obter o endereço; evite ponteiros não inicializados.",
                                  "learningObjective": "Compreender como associar um ponteiro a uma variável existente.",
                                  "commonMistakes": "Esquecer o & ao atribuir endereço; declarar ponteiro sem tipo correto (ex: int* em vez de int *)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desreferenciar o ponteiro para leitura",
                                  "subSteps": [
                                    "Use *ptr para acessar o valor de x sem modificar: printf('%d', *ptr);",
                                    "Compare *ptr com x diretamente no código.",
                                    "Adicione uma instrução para imprimir *ptr e x lado a lado.",
                                    "Compile e execute para observar que *ptr == x.",
                                    "Experimente imprimir o endereço de ptr para diferenciar de *ptr."
                                  ],
                                  "verification": "Saída do programa mostra que *ptr tem o mesmo valor que x.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Mesmo do step anterior.",
                                  "tips": "Lembre-se: ptr é o endereço, *ptr é o valor no endereço.",
                                  "learningObjective": "Diferenciar entre ponteiro (endereço) e desreferenciamento (valor).",
                                  "commonMistakes": "Confundir ptr com *ptr; tentar imprimir ptr como valor inteiro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar o valor original via desreferenciamento",
                                  "subSteps": [
                                    "Após inicialização, adicione a linha: *ptr = 10;",
                                    "Imprima x e *ptr novamente após a modificação.",
                                    "Compile e execute para ver a mudança em x.",
                                    "Teste atribuindo outro valor, como *ptr = 20, e observe o efeito.",
                                    "Confirme que x reflete todas as mudanças feitas via *ptr."
                                  ],
                                  "verification": "Valor de x muda para 10 (ou o valor atribuído) após *ptr = 10.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo do step anterior.",
                                  "tips": "A desreferência permite escrita no endereço apontado; é bidirecional.",
                                  "learningObjective": "Demonstrar que modificar *ptr altera a variável original.",
                                  "commonMistakes": "Esquecer o * na atribuição (ptr = 10 muda o ponteiro, não o valor); atribuir a ponteiro nulo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e debugar o código completo",
                                  "subSteps": [
                                    "Escreva um programa completo com declaração, inicialização, modificação e múltiplas impressões.",
                                    "Adicione verificações condicionais (if (*ptr == 10)) para validar.",
                                    "Use gdb ou printf para debugar se houver erros de segmentação.",
                                    "Teste com diferentes valores iniciais e modificações.",
                                    "Documente o antes/depois em comentários no código."
                                  ],
                                  "verification": "Programa compila sem warnings, executa corretamente e x é modificado via ponteiro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador GCC, debugger gdb (opcional), terminal.",
                                  "tips": "Compile com -Wall -g para detectar erros precocemente.",
                                  "learningObjective": "Integrar o conceito em um fluxo completo e identificar problemas comuns.",
                                  "commonMistakes": "Ponteiro dangling (apontando para variável fora de escopo); overflow em valores."
                                }
                              ],
                              "practicalExample": "int main() { int x = 5; int *ptr = &x; printf('x: %d, *ptr: %d\\n', x, *ptr); *ptr = 10; printf('Após modificação - x: %d, *ptr: %d\\n', x, *ptr); return 0; } // Saída: x:5,*ptr:5 | x:10,*ptr:10",
                              "finalVerifications": [
                                "Valor de x é alterado permanentemente após *ptr = novo_valor.",
                                "Impressões antes/depois confirmam a modificação bidirecional.",
                                "Não há erros de compilação ou runtime (segmentation fault).",
                                "Ponteiro mantém o endereço correto após modificação.",
                                "Teste com múltiplas atribuições via *ptr funciona.",
                                "Comparação *ptr == x é sempre verdadeira."
                              ],
                              "assessmentCriteria": [
                                "Código declara corretamente variável e ponteiro com &.",
                                "Desreferenciamento (*ptr) é usado para modificação, não ptr.",
                                "Programa demonstra mudança no valor original com evidência (prints).",
                                "Ausência de erros comuns como ponteiro não inicializado.",
                                "Explicação clara do mecanismo em comentários.",
                                "Testes com variações mostram compreensão profunda."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de endereçamento como funções de mapeamento.",
                                "Lógica de Programação: Passagem por referência vs valor.",
                                "Estruturas de Dados: Base para linked lists e árvores.",
                                "Algoritmos: Otimização de memória em swaps e recursão."
                              ],
                              "realWorldApplication": "Em funções para modificar variáveis sem retornar (passagem por referência simulada em C), alocação dinâmica (malloc/free), implementação de estruturas como listas encadeadas e árvores, e otimização de performance em sistemas embarcados onde memória é crítica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.2.2",
                              "10.1.7.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Declaração e Inicialização de Ponteiros",
                    "description": "Sintaxe para declarar variáveis ponteiro e inicializá-las com endereços de memória.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Declaração de Variáveis Ponteiro",
                        "description": "A declaração de uma variável ponteiro define o tipo de dado apontado e reserva memória para armazenar um endereço de memória, utilizando a sintaxe 'tipo* nome;' em linguagens como C ou C++.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Sintaxe básica de declaração de ponteiro",
                            "description": "Reconhecer e escrever a sintaxe fundamental para declarar um ponteiro, como 'int *ptr;', onde 'int' é o tipo base e '*' indica que é um ponteiro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Ponteiro",
                                  "subSteps": [
                                    "Defina o que é um ponteiro: uma variável que armazena o endereço de memória de outra variável.",
                                    "Diferencie ponteiro de variável comum: ponteiro guarda endereço, não valor.",
                                    "Visualize graficamente: desenhe uma caixa para variável e seta para endereço do ponteiro.",
                                    "Entenda o operador '*': indica que a variável é um ponteiro.",
                                    "Explique por que ponteiros são úteis: acesso indireto e eficiência de memória."
                                  ],
                                  "verification": "Explique em suas palavras o que é um ponteiro e desenhe um diagrama simples.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": [
                                    "Use analogia de endereço de casa (ponteiro) vs conteúdo da casa (valor)."
                                  ],
                                  "learningObjective": "Dominar o conceito fundamental de ponteiro e sua representação.",
                                  "commonMistakes": [
                                    "Confundir ponteiro com o valor apontado.",
                                    "Esquecer que ponteiro ocupa espaço em memória."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Sintaxe Fundamental de Declaração",
                                  "subSteps": [
                                    "Identifique os componentes: tipo_base * nome_ponteiro;",
                                    "Escreva o exemplo básico: int *ptr; (onde 'int' é tipo base e '*' declara ponteiro).",
                                    "Leia a sintaxe da direita para esquerda: ptr é ponteiro para int.",
                                    "Pratique declaração sem inicialização: float *fptr; char *cptr;",
                                    "Entenda convenções: use 'p' ou 'ptr' no nome para clareza."
                                  ],
                                  "verification": "Escreva corretamente a declaração de um ponteiro para double.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C online (como Replit ou Code::Blocks)",
                                    "Referência de sintaxe C"
                                  ],
                                  "tips": [
                                    "Sempre leia declarações da direita para a esquerda para evitar confusão."
                                  ],
                                  "learningObjective": "Reconhecer e reproduzir a sintaxe exata de declaração de ponteiro.",
                                  "commonMistakes": [
                                    "Omitir o espaço após '*': int*ptr (aceitável, mas int *ptr é padrão).",
                                    "Usar '&' na declaração (é para endereço, não declaração)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Variações e Múltiplas Declarações",
                                  "subSteps": [
                                    "Declare ponteiros para tipos diferentes: int *pi, double *pd, char *pc;",
                                    "Pratique declaração múltipla na mesma linha: int *a, *b, c; (c não é ponteiro).",
                                    "Identifique erro comum: int *a, b; (b é int, não ponteiro).",
                                    "Use typedef para ponteiros: typedef int* IntPtr; IntPtr p;",
                                    "Teste em código vazio: escreva 5 declarações variadas."
                                  ],
                                  "verification": "Corrija declarações erradas como 'int *x, y;' para torná-las ambas ponteiros.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Editor de código C",
                                    "Lista de tipos primitivos C"
                                  ],
                                  "tips": [
                                    "Repita '*' para cada ponteiro em declarações múltiplas."
                                  ],
                                  "learningObjective": "Aplicar sintaxe em contextos variados e múltiplos.",
                                  "commonMistakes": [
                                    "Esquecer '*' em declarações múltiplas.",
                                    "Confundir com arrays: int *arr vs int arr[10];"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Verificar em Código Real",
                                  "subSteps": [
                                    "Crie um programa simples: inclua <stdio.h> e declare ponteiros.",
                                    "Compile o código com apenas declarações: gcc programa.c -o programa.",
                                    "Adicione comentários explicando cada declaração.",
                                    "Teste varredura de erros do compilador em declarações inválidas.",
                                    "Salve exemplos funcionais para revisão futura."
                                  ],
                                  "verification": "Compile um código com 3 declarações de ponteiros sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC ou compilador online",
                                    "Terminal ou IDE"
                                  ],
                                  "tips": [
                                    "Use -Wall no gcc para detectar problemas sutis."
                                  ],
                                  "learningObjective": "Consolidar sintaxe através de prática compilável.",
                                  "commonMistakes": [
                                    "Não compilar para verificar sintaxe.",
                                    "Ignorar warnings sobre ponteiros não inicializados."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa C, declare um ponteiro para inteiro: int numero = 10; int *ptr; // ptr pode apontar para numero mais tarde. Compile e verifique sem erros.",
                              "finalVerifications": [
                                "Escrever corretamente 'int *ptr;' sem erros sintáticos.",
                                "Explicar leitura da declaração: 'ptr é ponteiro para int'.",
                                "Corrigir declaração múltipla errada: 'int *a, b;' para 'int *a, *b;'.",
                                "Identificar '*' como operador de ponteiro em código.",
                                "Declarar ponteiro para tipo não-int (ex: char *str;).",
                                "Compilar código com declarações sem warnings."
                              ],
                              "assessmentCriteria": [
                                "Precisão sintática: ausência de erros de compilação.",
                                "Clareza na nomenclatura: uso de nomes descritivos como 'ptr' ou 'pNumero'.",
                                "Compreensão conceitual: explicação correta de leitura da declaração.",
                                "Variedade: demonstração com múltiplos tipos base.",
                                "Correção de erros: identificação e fix de comuns pitfalls.",
                                "Prática compilável: código executável sem falhas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços de memória como números hexadecimais e aritmética de ponteiros.",
                                "Física: Analogia de ponteiros com vetores de posição e endereços físicos.",
                                "Lógica e Algoritmos: Abstração de referências em estruturas de dados.",
                                "Engenharia: Gerenciamento de memória em sistemas embarcados."
                              ],
                              "realWorldApplication": "Declaração de ponteiros é essencial para linked lists, árvores, alocação dinâmica com malloc/free em aplicativos como jogos, bancos de dados e sistemas operacionais, otimizando uso de memória."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Declaração de ponteiros para tipos escalares",
                            "description": "Declarar ponteiros para tipos primitivos como inteiro ('int *p'), caractere ('char *c') e real ('float *f'), entendendo que o ponteiro armazena o endereço de uma variável desse tipo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Ponteiros e Tipos Escalares",
                                  "subSteps": [
                                    "Estude o conceito de endereço de memória como um número único que identifica uma localização na RAM",
                                    "Aprenda que um ponteiro é uma variável que armazena esse endereço, não o valor em si",
                                    "Identifique tipos escalares primitivos em C: int (inteiro), char (caractere) e float (ponto flutuante)",
                                    "Diferencie o tipo do ponteiro (ex: int*) do tipo do valor apontado (int)",
                                    "Visualize com diagrama: caixa para variável, seta para ponteiro apontando para ela"
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando uma variável int e seu ponteiro associado",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou papel para diagramas",
                                    "Documentação oficial da linguagem C sobre ponteiros"
                                  ],
                                  "tips": "Pense na memória como uma rua com casas numeradas; o ponteiro é o número da casa.",
                                  "learningObjective": "Dominar os fundamentos conceituais de ponteiros e sua relação com tipos escalares.",
                                  "commonMistakes": [
                                    "Confundir o valor do ponteiro com o valor da variável apontada",
                                    "Ignorar que ponteiros têm tipos específicos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Sintaxe de Declaração de Ponteiros",
                                  "subSteps": [
                                    "Memorize a sintaxe geral: tipo* nome_do_ponteiro; (ex: int *p;)",
                                    "Note que o asterisco (*) fica após o tipo e antes do nome",
                                    "Pratique declarando sem inicializar: int *p; char *c; float *f;",
                                    "Entenda que múltiplas declarações em uma linha usam * apenas no primeiro: int *p, q; (q é int, não ponteiro)",
                                    "Compile um código vazio com essas declarações para verificar sintaxe"
                                  ],
                                  "verification": "Escreva e compile um programa com declarações de ponteiros para int, char e float sem erros",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C online (como Replit ou GCC)",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Sempre coloque espaço após o tipo antes do *: int *p, não int*p para legibilidade.",
                                  "learningObjective": "Aplicar corretamente a sintaxe de declaração de ponteiros para tipos escalares.",
                                  "commonMistakes": [
                                    "Esquecer o ponto e vírgula no final",
                                    "Declarar int* p, q como dois ponteiros (q vira int)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Declarações com Exemplos Concretos",
                                  "subSteps": [
                                    "Declare uma variável int x = 10; e um ponteiro int *p;",
                                    "Declare char y = 'A'; e char *c;",
                                    "Declare float z = 3.14; e float *f;",
                                    "Escreva um programa main() com todas as declarações lado a lado",
                                    "Use printf para mostrar que os ponteiros são inicializados como NULL ou lixo (não usar sem &)"
                                  ],
                                  "verification": "Execute o código e confirme que compila sem warnings de sintaxe",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Referência de funções printf para ponteiros"
                                  ],
                                  "tips": "Não dereferencie ponteiros não inicializados para evitar segmentation fault.",
                                  "learningObjective": "Criar declarações funcionais de ponteiros para diferentes tipos escalares em contexto de código.",
                                  "commonMistakes": [
                                    "Usar ponteiro sem inicializar com endereço (&variavel)",
                                    "Confundir declaração com alocação dinâmica (malloc)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Entendimento e Explorar Variações",
                                  "subSteps": [
                                    "Inicialize ponteiros com endereço de variáveis: p = &x; c = &y; f = &z;",
                                    "Compare tamanhos com sizeof: sizeof(int*) vs sizeof(int)",
                                    "Teste declarações const: const int *p; (ponteiro para const int)",
                                    "Identifique erros comuns em códigos de exemplo fornecidos",
                                    "Refatore um código simples substituindo variáveis por ponteiros"
                                  ],
                                  "verification": "Modifique um programa existente para usar ponteiros corretamente e teste com diferentes valores",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Códigos de exemplo de ponteiros",
                                    "Debugger como GDB ou printf para inspeção"
                                  ],
                                  "tips": "Use & para obter endereço apenas em inicialização de ponteiros.",
                                  "learningObjective": "Validar e estender o conhecimento de declarações de ponteiros em cenários reais.",
                                  "commonMistakes": [
                                    "Atribuir valor direto a ponteiro sem &: p = 10;",
                                    "Misturar tipos de ponteiro (int* para float)"
                                  ]
                                }
                              ],
                              "practicalExample": "```c\n#include <stdio.h>\nint main() {\n    int x = 42;\n    int *p = &x;  // Ponteiro para int\n    char y = 'Z';\n    char *c = &y; // Ponteiro para char\n    float z = 3.14159f;\n    float *f = &z; // Ponteiro para float\n    printf(\"Endereço de x: %p\\n\", (void*)p);\n    return 0;\n}\n``` Este código declara e inicializa ponteiros para tipos escalares, imprimindo um endereço de exemplo.",
                              "finalVerifications": [
                                "Declara corretamente int *p; sem erros de sintaxe",
                                "Explica que *p armazena endereço de um int, não o valor inteiro",
                                "Distingue char *c de float *f em termos de tipo apontado",
                                "Identifica que ponteiro não inicializado contém valor indefinido",
                                "Compila e executa código com três ponteiros escalares",
                                "Descreve diagrama memória para variável e ponteiro"
                              ],
                              "assessmentCriteria": [
                                "Precisão da sintaxe em todas as declarações (100% correto)",
                                "Compreensão conceitual demonstrada em explicações ou diagramas",
                                "Capacidade de compilar e executar códigos sem erros ou warnings",
                                "Identificação correta de erros comuns em exemplos fornecidos",
                                "Aplicação em variações como const pointers",
                                "Uso adequado de & para endereços em inicializações"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços de memória como valores hexadecimais e aritmética de ponteiros",
                                "Lógica e Algoritmos: Abstrações de referência vs valor em programação funcional",
                                "Engenharia de Software: Gerenciamento de memória em sistemas embarcados",
                                "Física/Computação: Analogia de ponteiros com vetores de posição em simulações",
                                "Banco de Dados: Ponteiros como chaves estrangeiras em estruturas relacionais"
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, declarações de ponteiros para tipos escalares são fundamentais para funções que modificam variáveis originais (passagem por referência), alocação dinâmica de memória em listas ligadas, árvores e gráficos, otimizando performance em aplicações como jogos, bancos de dados e sistemas operacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Declaração de múltiplos ponteiros",
                            "description": "Declarar múltiplas variáveis ponteiro em uma única linha, como 'int *p1, *p2;', garantindo que todas sejam ponteiros e evitando confusões com variáveis normais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar declaração de ponteiro único",
                                  "subSteps": [
                                    "Estude a sintaxe básica: tipo *nome; como int *p;",
                                    "Compile e execute um programa simples que declara um ponteiro único e o usa para acessar uma variável int;",
                                    "Explique verbalmente ou por escrito o que o '*' representa na declaração;",
                                    "Identifique o tipo da variável ponteiro (ex: ponteiro para int);",
                                    "Pratique declarando ponteiros para char e float."
                                  ],
                                  "verification": "Compilar e executar código com ponteiro único sem erros e imprimir valor correto via ponteiro.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C (GCC)",
                                    "Editor de texto (VS Code ou similar)",
                                    "Documentação C sobre ponteiros"
                                  ],
                                  "tips": "Sempre leia a declaração da direita para a esquerda: p é um ponteiro para int.",
                                  "learningObjective": "Compreender a sintaxe fundamental de um ponteiro único para preparar múltiplas declarações.",
                                  "commonMistakes": [
                                    "Esquecer o '*' na declaração",
                                    "Confundir ponteiro com a variável apontada",
                                    "Não inicializar antes de usar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender sintaxe de declaração múltipla correta",
                                  "subSteps": [
                                    "Analise exemplos corretos: int *p1, *p2; (ambos ponteiros)",
                                    "Declare três ponteiros na mesma linha: int *a, *b, *c;",
                                    "Inicialize-os apontando para variáveis int existentes;",
                                    "Compile o código para verificar se todos são ponteiros;",
                                    "Teste atribuindo valores via ponteiros e imprimindo."
                                  ],
                                  "verification": "Código compila sem erros e todos os identificadores são reconhecidos como ponteiros (use sizeof(*p1) para confirmar).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de texto",
                                    "Exemplos de código prontos para modificação"
                                  ],
                                  "tips": "O '*' deve preceder cada nome de variável para torná-la ponteiro; posicione-o antes de cada identificador.",
                                  "learningObjective": "Dominar a sintaxe exata para declarar múltiplos ponteiros em uma linha única.",
                                  "commonMistakes": [
                                    "Escrever int *p1, p2; (p2 vira int)",
                                    "Colocar '*' só no início sem repetir",
                                    "Usar vírgulas incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e corrigir erros comuns",
                                  "subSteps": [
                                    "Escreva código errado: int *p1, p2; e compile para ver o erro;",
                                    "Corrija para int *p1, *p2; e recompile;",
                                    "Teste com tipos mistos: int *p1, *p2, char *p3;",
                                    "Explique por que o compilador reclama em casos incorretos;",
                                    "Crie uma tabela comparando declarações corretas vs. erradas."
                                  ],
                                  "verification": "Identificar e corrigir 5 exemplos errados fornecidos ou criados, com explicação escrita.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C com flags de warning (-Wall)",
                                    "Lista de exemplos errados pré-preparados"
                                  ],
                                  "tips": "Ative warnings no compilador para detectar mismatches de tipo imediatamente.",
                                  "learningObjective": "Reconhecer armadilhas na declaração múltipla e evitá-las.",
                                  "commonMistakes": [
                                    "Declaração assimétrica (um ponteiro e um não)",
                                    "Confusão com arrays (int p1[2], *p2;)",
                                    "Ignorar warnings do compilador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar em contexto real com programa completo",
                                  "subSteps": [
                                    "Crie um programa que declara múltiplos ponteiros para int e usa-os para trocar valores de variáveis (swap via ponteiros);",
                                    "Expanda para ponteiros de tipos diferentes: int*, char*, double*;",
                                    "Adicione funções que recebem múltiplos ponteiros como parâmetros;",
                                    "Compile, execute e depure qualquer erro;",
                                    "Documente o código com comentários explicando as declarações."
                                  ],
                                  "verification": "Programa executa corretamente, manipulando valores via ponteiros múltiplos sem leaks ou erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor com debugger (GDB opcional)",
                                    "Template de programa main()"
                                  ],
                                  "tips": "Use printf para debugar valores e endereços (*p e &p).",
                                  "learningObjective": "Aplicar declarações múltiplas em um programa funcional.",
                                  "commonMistakes": [
                                    "Desreferenciar ponteiros não inicializados",
                                    "Passar ponteiro errado para função",
                                    "Overflow em tipos mistos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de gerenciamento de estoque, declare int *estoqueAtual, *estoqueMax, *vendasDiarias; inicialize-os apontando para arrays de inteiros representando quantidades, e use-os para calcular totais e atualizar valores em uma função de venda.",
                              "finalVerifications": [
                                "Compilar código com múltiplos ponteiros sem warnings ou erros.",
                                "Explicar corretamente por que 'int *p1, p2;' declara p2 como int.",
                                "Criar e executar programa que usa 4 ponteiros declarados em uma linha.",
                                "Identificar tipos de 5 declarações múltiplas variadas.",
                                "Debugar e corrigir código com erro de declaração múltipla.",
                                "Usar gdb ou printf para verificar endereços e valores de ponteiros múltiplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe: todos os '*' posicionados corretamente.",
                                "Compreensão conceitual: distinção clara entre ponteiro e variável normal.",
                                "Capacidade de depuração: identificar e fixar erros comuns rapidamente.",
                                "Aplicação prática: uso correto em funções e programas.",
                                "Documentação: comentários explicativos nas declarações.",
                                "Eficiência: código limpo sem variáveis desnecessárias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de endereços de memória como números hexadecimais e aritmética de ponteiros.",
                                "Lógica e Algoritmos: Sequência de declaradores e precedência de operadores (* e ,).",
                                "Engenharia de Software: Boas práticas de declaração para legibilidade e manutenção de código.",
                                "Física/Computação: Analogia com endereços físicos em sistemas reais."
                              ],
                              "realWorldApplication": "Em bibliotecas de gerenciamento de memória dinâmica (como malloc para múltiplos ponteiros em linked lists ou árvores), ou em kernels de SO para manipular estruturas de dados com ponteiros para next/prev nodes, evitando erros de tipo que causam crashes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Inicialização de Ponteiros",
                        "description": "A inicialização atribui um endereço de memória válido ou um valor nulo (NULL) a um ponteiro declarado, prevenindo acessos a memória indefinida.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Inicialização com NULL",
                            "description": "Inicializar um ponteiro com NULL usando 'int *ptr = NULL;', o que indica que o ponteiro não aponta para nenhum endereço válido, útil para verificações de segurança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Ponteiros Não Inicializados e NULL",
                                  "subSteps": [
                                    "Estude o que acontece quando um ponteiro é declarado sem inicialização (contém lixo).",
                                    "Aprenda que NULL é uma constante definida em <stdio.h> ou <stdlib.h> representando endereço inválido (geralmente 0).",
                                    "Discuta riscos de dereferenciar ponteiro não inicializado (comportamento indefinido, crashes).",
                                    "Leia exemplos de código com ponteiro lixo vs. NULL.",
                                    "Anote definições chave: ponteiro, NULL, inicialização."
                                  ],
                                  "verification": "Explique em suas palavras por que inicializar com NULL é uma boa prática e dê um exemplo de risco.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro ou tutorial sobre ponteiros em C",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use analogia: ponteiro sem init é como uma chave aleatória; NULL é 'sem chave válida'.",
                                  "learningObjective": "Entender o propósito de NULL para segurança em ponteiros.",
                                  "commonMistakes": [
                                    "Confundir NULL com 0 (NULL é mais semântico)",
                                    "Achar que NULL aloca memória"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Sintaxe de Declaração e Inicialização com NULL",
                                  "subSteps": [
                                    "#include <stdio.h> no topo do arquivo.",
                                    "Declare: int *ptr = NULL;",
                                    "Compile com gcc para verificar sintaxe.",
                                    "Teste printf(\"Ptr value: %p\\n\", (void*)ptr); para ver NULL.",
                                    "Experimente variações: char *str = NULL; etc."
                                  ],
                                  "verification": "Escreva e compile 3 declarações diferentes de ponteiros inicializados com NULL sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador GCC ou online como Replit",
                                    "Arquivo .c básico"
                                  ],
                                  "tips": "Sempre inclua headers necessários; use %p para imprimir ponteiros.",
                                  "learningObjective": "Dominar a sintaxe exata para inicializar qualquer ponteiro com NULL.",
                                  "commonMistakes": [
                                    "Esquecer = NULL",
                                    "Usar int *ptr; ptr = NULL; sem declaração inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Inicialização em um Programa Simples",
                                  "subSteps": [
                                    "Crie programa com função que recebe ponteiro e verifica if(ptr == NULL).",
                                    "Inicialize ptr = NULL; chame função (deve tratar como nulo).",
                                    "Altere para ptr = malloc(sizeof(int)); use e free().",
                                    "Compile e execute cenários: NULL vs. válido.",
                                    "Adicione printf para debug."
                                  ],
                                  "verification": "Programa roda sem crashes e imprime mensagens corretas para NULL e válido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GCC",
                                    "stdlib.h para malloc/free"
                                  ],
                                  "tips": "Use (ptr != NULL) antes de *ptr = valor; para segurança.",
                                  "learningObjective": "Aplicar inicialização com NULL em código funcional.",
                                  "commonMistakes": [
                                    "Dereferenciar NULL acidentalmente",
                                    "Não incluir <stdlib.h> para malloc"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Verificações de Segurança e Boas Práticas",
                                  "subSteps": [
                                    "Escreva função que retorna ponteiro; inicialize com NULL se falhar.",
                                    "Implemente loop que verifica NULL antes de processar lista ligada.",
                                    "Refatore código anterior adicionando checks em todos os ponteiros.",
                                    "Teste com valgrind para leaks ou erros.",
                                    "Documente comentários explicando por que NULL é usado."
                                  ],
                                  "verification": "Código passa em testes unitários para casos NULL e roda sem warnings/valgrind errors.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Valgrind (opcional)",
                                    "Testes manuais"
                                  ],
                                  "tips": "Adote regra: todo ponteiro novo começa como NULL.",
                                  "learningObjective": "Integrar verificações NULL para código robusto.",
                                  "commonMistakes": [
                                    "if(ptr) ao invés de if(ptr != NULL) (booleano implícito OK mas explícito melhor)",
                                    "Ignorar NULL após malloc falha"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa de lista ligada: struct Node *head = NULL; // Inicializa lista vazia. Antes de inserir: if(head == NULL) { head = malloc(...); } else { ... } Evita derefência inválida.",
                              "finalVerifications": [
                                "Declara ponteiro corretamente com = NULL sem erros de compilação.",
                                "Programa imprime endereço NULL corretamente com %p.",
                                "Verificação if(ptr == NULL) funciona e previne crash.",
                                "Código usa NULL em múltiplos tipos de ponteiro (int*, char*).",
                                "Refatoração de código legado adiciona inicializações NULL.",
                                "Valgrind mostra no leaks ou invalid reads."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe de inicialização (100% correto).",
                                "Uso consistente de verificações NULL antes de dereferência.",
                                "Programa compila e executa sem crashes em cenários NULL/válido.",
                                "Explicação clara do porquê NULL previne undefined behavior.",
                                "Boas práticas: includes corretos, comentários, free() quando aplicável.",
                                "Criatividade em exemplos práticos além do básico."
                              ],
                              "crossCurricularConnections": [
                                "Segurança de Software: Prevenção de buffer overflows via checks.",
                                "Debugging: Uso de NULL para identificar falhas de alocação.",
                                "Estruturas de Dados: Inicialização de heads/tails em listas/árvores.",
                                "Boas Práticas de Programação: Padrões C99/C11 para portabilidade."
                              ],
                              "realWorldApplication": "Em sistemas embarcados ou servidores (ex: Apache/Nginx), ponteiros NULL evitam segfaults em alocações falhas, melhorando estabilidade e facilitando debugging em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Inicialização com operador de endereço (&)",
                            "description": "Obter o endereço de uma variável usando '&' e atribuí-lo ao ponteiro, como 'int x = 10; int *ptr = &x;', ligando o ponteiro à localização em memória da variável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de endereço de memória",
                                  "subSteps": [
                                    "Explique o que é uma variável em termos de memória: uma variável ocupa um endereço específico na RAM.",
                                    "Diferencie o valor da variável do seu endereço: o valor é o conteúdo, o endereço é a localização.",
                                    "Visualize a memória como uma rua com casas numeradas, onde cada variável é uma casa com número (endereço).",
                                    "Discuta por que acessar endereços é útil: permite manipular dados indiretamente.",
                                    "Pratique identificando endereços em diagramas simples de memória."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando uma variável 'x' com seu endereço e valor, e explique verbalmente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Editor de texto ou quadro branco"
                                  ],
                                  "tips": "Use analogias cotidianas como 'endereço de casa' para fixar o conceito.",
                                  "learningObjective": "Entender que toda variável tem um endereço único na memória.",
                                  "commonMistakes": [
                                    "Confundir valor com endereço",
                                    "Achar que endereço muda quando valor muda"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o operador de endereço '&'",
                                  "subSteps": [
                                    "Estude a sintaxe: '&variavel' retorna o endereço da variável.",
                                    "Compile e execute um programa simples que imprime o endereço de uma variável usando printf('%p', &x);.",
                                    "Compare o endereço impresso em execuções diferentes para notar que pode variar.",
                                    "Explique o tipo retornado: '&int' retorna 'int*'.",
                                    "Pratique com diferentes tipos: int, char, float."
                                  ],
                                  "verification": "Escreva e execute código que imprima o endereço de pelo menos três variáveis diferentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C (GCC)",
                                    "Editor de código (VS Code ou similar)"
                                  ],
                                  "tips": "Use %p no printf para imprimir ponteiros; cast para void* se necessário.",
                                  "learningObjective": "Dominar o uso do operador & para obter endereços.",
                                  "commonMistakes": [
                                    "Esquecer o &",
                                    "Usar %d em vez de %p para endereços"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Declarar e inicializar um ponteiro com '&'",
                                  "subSteps": [
                                    "Declare um ponteiro: int *ptr; (não inicializado).",
                                    "Inicialize: int x = 10; int *ptr = &x;.",
                                    "Compile e execute código que atribui &x a ptr e imprime ambos.",
                                    "Verifique que ptr armazena o endereço de x usando printf.",
                                    "Teste acessando *ptr para confirmar que aponta para x."
                                  ],
                                  "verification": "Código compila sem warnings e imprime endereço correto e valor via *ptr.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Sempre inicialize ponteiros para evitar dangling pointers.",
                                  "learningObjective": "Inicializar corretamente um ponteiro com o endereço de uma variável.",
                                  "commonMistakes": [
                                    "Declarar sem *",
                                    "Atribuir valor em vez de endereço",
                                    "Esquecer inicialização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e testar a inicialização do ponteiro",
                                  "subSteps": [
                                    "Modifique o valor de x e veja *ptr refletir a mudança.",
                                    "Imprima &x e ptr para confirmar que são iguais.",
                                    "Crie um programa que use o ponteiro para alterar x indiretamente.",
                                    "Teste cenários de erro: inicializar com endereço inválido e observe crash.",
                                    "Refatore o código para múltiplas variáveis."
                                  ],
                                  "verification": "Execute testes: mudança em x afeta *ptr, endereços iguais, sem segfaults.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Debugger opcional (GDB)"
                                  ],
                                  "tips": "Use valgrind para detectar erros de memória em Linux.",
                                  "learningObjective": "Validar que o ponteiro foi inicializado corretamente e funciona.",
                                  "commonMistakes": [
                                    "Desreferenciar ponteiro não inicializado",
                                    "Confundir ptr com *ptr"
                                  ]
                                }
                              ],
                              "practicalExample": "int main() { int x = 10; int *ptr = &x; printf(\"Valor de x: %d\\n\", x); printf(\"Endereco de x: %p\\n\", &x); printf(\"Valor de ptr: %p\\n\", ptr); printf(\"Valor apontado por ptr: %d\\n\", *ptr); *ptr = 20; printf(\"Novo valor de x: %d\\n\", x); return 0; } // Saída mostra endereços iguais e x alterado via ptr.",
                              "finalVerifications": [
                                "Explica corretamente o que '&x' retorna.",
                                "Escreve código de inicialização sem erros de sintaxe.",
                                "Demonstra que *ptr == x e ptr == &x.",
                                "Identifica e corrige erros comuns como ponteiro não inicializado.",
                                "Aplica em exemplo com múltiplas variáveis.",
                                "Usa printf corretamente para depuração."
                              ],
                              "assessmentCriteria": [
                                "Código compila e executa sem erros ou warnings.",
                                "Endereços de ptr e &x são idênticos na saída.",
                                "Alteração via *ptr reflete no valor original.",
                                "Explicação verbal demonstra compreensão conceitual.",
                                "Tempo de execução dentro do estimado sem ajuda excessiva.",
                                "Identifica pelo menos 2 erros comuns em códigos de pares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como valores hexadecimais e aritmética de ponteiros.",
                                "Física: Analogia com endereços físicos e localização de partículas.",
                                "Algoritmos: Base para estruturas de dados dinâmicas como listas ligadas.",
                                "Engenharia de Software: Gerenciamento de memória em sistemas embarcados."
                              ],
                              "realWorldApplication": "Essencial para alocação dinâmica de memória (malloc/free), implementação de estruturas como árvores e grafos, otimização de performance em jogos e sistemas operacionais, e passagem de parâmetros por referência em funções."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.2",
                              "10.1.7.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Inicialização em declaração combinada",
                            "description": "Combinar declaração e inicialização em uma linha, como 'int x = 5; int *ptr = &x;', demonstrando boas práticas para ponteiros seguros desde o início.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Variáveis e Ponteiros",
                                  "subSteps": [
                                    "Explique a diferença entre declaração (int x;) e inicialização (x = 5;) de variáveis.",
                                    "Descreva o que é um ponteiro: uma variável que armazena o endereço de outra variável.",
                                    "Identifique o operador & para obter o endereço de uma variável.",
                                    "Discuta por que ponteiros não inicializados são perigosos (dangling pointers).",
                                    "Escreva exemplos simples de declaração de ponteiro sem inicialização."
                                  ],
                                  "verification": "Liste corretamente os conceitos em um documento ou comentário no código sem erros conceituais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto ou IDE (VS Code, Code::Blocks), compilador GCC.",
                                  "tips": "Use diagramas mentais para visualizar endereços de memória como caixas numeradas.",
                                  "learningObjective": "Compreender os fundamentos para evitar erros em inicializações de ponteiros.",
                                  "commonMistakes": "Confundir ponteiro com a variável apontada; esquecer que ponteiros precisam de endereço válido."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar Declaração e Inicialização Separadas",
                                  "subSteps": [
                                    "Declare uma variável inteira: int x; e inicialize: x = 5;.",
                                    "Declare um ponteiro: int *ptr; sem inicializar.",
                                    "Inicialize o ponteiro separadamente: ptr = &x;.",
                                    "Compile e execute um programa simples que imprime o valor de x e o endereço via ptr.",
                                    "Observe o output para confirmar que ptr aponta corretamente para x."
                                  ],
                                  "verification": "Código compila e executa sem warnings, imprimindo valor e endereço corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Compilador C (GCC), terminal para compilar (gcc arquivo.c -o exec), IDE com debugger.",
                                  "tips": "Sempre use printf(\"%d\", *ptr); para dereferenciar e verificar o valor.",
                                  "learningObjective": "Executar declaração e inicialização em passos separados para ponteiros.",
                                  "commonMistakes": "Esquecer o & ao atribuir endereço; tentar dereferenciar ponteiro não inicializado (segmentation fault)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Combinar Declaração e Inicialização em Uma Linha",
                                  "subSteps": [
                                    "Reescreva o código combinando: int x = 5; int *ptr = &x;.",
                                    "Teste acessando *ptr e comparando com x no printf.",
                                    "Modifique x e verifique se *ptr reflete a mudança (demonstrando ponteiro ativo).",
                                    "Adicione uma função que receba ptr como parâmetro para testar passagem por referência indireta.",
                                    "Compile e execute, garantindo ausência de warnings sobre variáveis não inicializadas."
                                  ],
                                  "verification": "Programa executa corretamente, mostrando que ptr foi inicializado na declaração e acessa x.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmo ambiente do step anterior, mais exemplos de código preparados.",
                                  "tips": "Coloque a inicialização próxima à declaração para minimizar riscos de uso prematuro.",
                                  "learningObjective": "Aplicar sintaxe de inicialização combinada para ponteiros seguros.",
                                  "commonMistakes": "Escrever int *ptr = x; em vez de &x (aponta para valor, não endereço); erros de sintaxe em linhas múltiplas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Boas Práticas e Verificar Segurança",
                                  "subSteps": [
                                    "Identifique cenários onde inicialização combinada previne erros (ex: funções longas).",
                                    "Refatore código anterior para múltiplas variáveis: int a=1, b=2; int *p1=&a, *p2=&b;.",
                                    "Use const onde aplicável: const int x=5; int *ptr = &x; (note limitações).",
                                    "Teste com valgrind ou debugger para leaks ou acessos inválidos.",
                                    "Documente o código com comentários explicando benefícios da prática."
                                  ],
                                  "verification": "Código refatorado compila sem warnings, valgrind limpo, e documentação completa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Valgrind (para Linux/Mac), debugger no IDE, guia de boas práticas C.",
                                  "tips": "Inicialize ponteiros imediatamente para seguir o princípio 'initialize before use'.",
                                  "learningObjective": "Adotar práticas seguras de ponteiros desde a declaração.",
                                  "commonMistakes": "Reatribuir ptr para NULL sem necessidade; ignorar warnings do compilador."
                                }
                              ],
                              "practicalExample": "int main() {\n    int x = 5;\n    int *ptr = &x;\n    printf(\"Valor de x: %d, Endereço: %p, Via ptr: %d\\n\", x, (void*)&x, *ptr);\n    x = 10;\n    printf(\"Após mudança: Via ptr: %d\\n\", *ptr);\n    return 0;\n}\n// Output: Valor de x: 5, Endereço: 0x7ffd..., Via ptr: 5\n// Após mudança: Via ptr: 10",
                              "finalVerifications": [
                                "Escreve código com ponteiro inicializado na declaração sem erros de compilação.",
                                "Explica verbalmente por que int *ptr = &x; é mais seguro que separadamente.",
                                "Modifica valor via ponteiro e verifica reflexão na variável original.",
                                "Identifica e corrige código com ponteiro não inicializado.",
                                "Usa corretamente em função com passagem de ponteiro.",
                                "Documenta código com comentários sobre boas práticas."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática: declaração e inicialização combinadas sem erros.",
                                "Compreensão conceitual: diferencia endereço de valor.",
                                "Execução prática: código compila e roda com outputs esperados.",
                                "Segurança: ausência de acessos inválidos ou warnings.",
                                "Eficiência: aplica em contextos múltiplos sem redundâncias.",
                                "Documentação: explica benefícios em comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços de memória como funções de mapeamento (aritmética de ponteiros).",
                                "Física/Engenharia: Analogia com referências em circuitos (ponteiros como fios conectando componentes).",
                                "Lógica/Algoritmos: Pré-requisito para estruturas de dados como listas ligadas.",
                                "Segurança da Informação: Práticas para evitar buffer overflows via ponteiros seguros."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software embarcado ou jogos, inicializar ponteiros combinados previne crashes por ponteiros selvagens, como em gerenciamento de sprites em engines de games (Unity C++ backend) ou drivers de dispositivos onde memória é crítica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Operadores de Endereço e Dereferência",
                    "description": "Uso dos operadores & (endereço de) e * (dereferência) para manipular ponteiros.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Operador de Endereço (&)",
                        "description": "O operador & (endereço de) é utilizado para obter o endereço de memória de uma variável, permitindo a criação de ponteiros que apontam para essa localização específica na memória do computador.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Identificar a sintaxe do operador &",
                            "description": "Reconhecer e aplicar a sintaxe básica do operador & aplicada a variáveis escalares, como inteiros ou floats, para retornar o endereço de memória em formato hexadecimal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de endereço de memória",
                                  "subSteps": [
                                    "Revise o que é uma variável escalar (ex: int, float) e seu armazenamento na memória RAM.",
                                    "Explique que cada variável tem um endereço único na memória, representado em hexadecimal.",
                                    "Diferencie o valor da variável do seu endereço de memória.",
                                    "Visualize um diagrama simples de memória com uma variável e seu endereço.",
                                    "Identifique por que endereços são úteis para ponteiros."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a diferença entre valor e endereço de uma variável exemplo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Diagrama de memória impresso ou desenhado, editor de texto para anotações.",
                                  "tips": "Pense na memória como uma rua: endereço é o número da casa, valor é o que está dentro.",
                                  "learningObjective": "Compreender o papel dos endereços de memória em variáveis escalares.",
                                  "commonMistakes": "Confundir endereço com valor da variável ou assumir que endereços são sequenciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a sintaxe básica do operador &",
                                  "subSteps": [
                                    "Memorize a sintaxe: &nome_da_variavel para obter o endereço.",
                                    "Escreva exemplos: &x para int x; &y para float y.",
                                    "Note que & é unário (prefixado à variável) e retorna um ponteiro (void* ou tipo específico).",
                                    "Diferencie & de outros operadores como + ou &&.",
                                    "Pratique escrevendo 5 variações em um editor."
                                  ],
                                  "verification": "Escreva corretamente a sintaxe para obter endereço de 3 variáveis diferentes (int, float, char).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto ou papel para prática de sintaxe.",
                                  "tips": "Sempre leia como 'endereço de' antes do nome da variável para fixar.",
                                  "learningObjective": "Identificar e escrever a sintaxe exata do operador &.",
                                  "commonMistakes": "Usar & como bitwise AND (&& ou & sem contexto de endereço)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e compilar exemplo com variáveis inteiras",
                                  "subSteps": [
                                    "Crie código C: inclua <stdio.h>, declare int x = 42; printf(\"%p\\n\", &x);",
                                    "Compile com gcc: gcc arquivo.c -o exec.",
                                    "Execute e observe saída em hexadecimal (ex: 0x7ffd12345678).",
                                    "Compare endereço múltiplas execuções (pode variar).",
                                    "Adicione printf(\"%d\\n\", x); para contrastar valor vs endereço."
                                  ],
                                  "verification": "Código compila sem erros e imprime endereço hexadecimal válido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador GCC instalado, terminal, editor de código (VS Code ou similar).",
                                  "tips": "Use %p para imprimir ponteiros; cast para void* se necessário.",
                                  "learningObjective": "Aplicar & em código funcional com inteiros.",
                                  "commonMistakes": "Esquecer #include <stdio.h> ou usar %d para endereço."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para floats e verificar padrões",
                                  "subSteps": [
                                    "Modifique código: declare float y = 3.14f; printf(\"%p\\n\", &y);",
                                    "Compile, execute e compare endereços de int e float.",
                                    "Observe que endereços podem ser adjacentes em stack.",
                                    "Teste com múltiplas variáveis para ver variação.",
                                    "Anote se endereço muda com redeclaração ou escopo."
                                  ],
                                  "verification": "Saída mostra endereços hex válidos para int e float, sem crashes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo ambiente do step 3.",
                                  "tips": "Endereços em stack crescem para baixo em muitas arquiteturas.",
                                  "learningObjective": "Generalizar sintaxe & para diferentes tipos escalares.",
                                  "commonMistakes": "Ignorar 'f' em float literal ou usar %f para endereço."
                                }
                              ],
                              "practicalExample": "```c\n#include <stdio.h>\nint main() {\n    int x = 10;\n    float y = 3.14f;\n    printf(\"Valor de x: %d, Endereço: %p\\n\", x, &x);\n    printf(\"Valor de y: %f, Endereço: %p\\n\", y, &y);\n    return 0;\n}\n```\nSaída exemplo: Valor de x: 10, Endereço: 0x7ffe12345678\nValor de y: 3.140000, Endereço: 0x7ffe12345674",
                              "finalVerifications": [
                                "Identifica &x como endereço de x em qualquer código snippet.",
                                "Explica que saída %p é hexadecimal sem erros.",
                                "Distingue sintaxe & de operadores bitwise ou lógicos.",
                                "Compila e executa código com & sem warnings/erros.",
                                "Compara endereços de múltiplas variáveis corretamente.",
                                "Reconhece que & retorna ponteiro para o tipo da variável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da sintaxe &variavel (100% correto).",
                                "Capacidade de compilar/executar exemplos sem erros (funcionalidade).",
                                "Explicação clara de endereço vs valor (compreensão conceitual).",
                                "Uso correto de %p em printf (formatação).",
                                "Generalização para int/float sem confusão de tipos.",
                                "Detecção de erros comuns em códigos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conversão decimal-hexadecimal para interpretar endereços.",
                                "Hardware: Conceitos de arquitetura de computadores e memória RAM.",
                                "Matemática computacional: Representação binária de endereços.",
                                "Física: Analogia com endereços físicos em sistemas reais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, o operador & é essencial para ponteiros em alocação dinâmica (malloc), passagem por referência em funções, debugging de vazamentos de memória e implementação de estruturas de dados como listas ligadas em C."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Atribuir endereço de variável a um ponteiro",
                            "description": "Declarar um ponteiro do tipo adequado e atribuir a ele o endereço de uma variável usando o operador &, demonstrando compatibilidade de tipos entre ponteiro e variável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar e inicializar uma variável simples",
                                  "subSteps": [
                                    "Escolha um tipo de dado básico compatível com ponteiros, como int ou char.",
                                    "Declare a variável com um nome descritivo, por exemplo: int numero = 42;",
                                    "Compile o código isoladamente para verificar a declaração.",
                                    "Inicialize a variável com um valor conhecido para facilitar testes posteriores.",
                                    "Adicione um comentário explicando o propósito da variável."
                                  ],
                                  "verification": "O código compila sem erros e a variável pode ser acessada em uma função main simples.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE (ex: VS Code, Code::Blocks)",
                                    "Compilador C/C++ (gcc)"
                                  ],
                                  "tips": "Sempre inicialize variáveis para evitar valores indefinidos (garbage).",
                                  "learningObjective": "Compreender a declaração e inicialização de variáveis como base para manipulação de endereços.",
                                  "commonMistakes": [
                                    "Esquecer o ponto e vírgula no final da declaração.",
                                    "Usar tipo incompatível sem planejar o ponteiro."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar um ponteiro do tipo adequado",
                                  "subSteps": [
                                    "Identifique o tipo da variável declarada (ex: int para variável int).",
                                    "Declare o ponteiro usando a sintaxe tipo* nomePonteiro; (ex: int* ptr;).",
                                    "Não inicialize o ponteiro ainda; deixe-o como ponteiro nulo ou indefinido para o próximo passo.",
                                    "Adicione um comentário descrevendo o que o ponteiro apontará.",
                                    "Compile para verificar se a declaração é válida."
                                  ],
                                  "verification": "Declaração do ponteiro compila sem warnings de tipo indefinido.",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Mesmo editor e compilador do step 1",
                                    "Referência rápida de sintaxe C (ex: man page ou cheat sheet)"
                                  ],
                                  "tips": "Lembre-se: o asterisco (*) fica próximo ao nome do ponteiro para clareza (int* ptr).",
                                  "learningObjective": "Dominar a sintaxe de declaração de ponteiros compatíveis com variáveis.",
                                  "commonMistakes": [
                                    "Declarar ponteiro com tipo errado (ex: char* para int).",
                                    "Esquecer o asterisco (*)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atribuir o endereço da variável ao ponteiro usando &",
                                  "subSteps": [
                                    "Use o operador & antes do nome da variável (ex: ptr = &numero;).",
                                    "Certifique-se de que os tipos sejam compatíveis (ponteiro int para variável int).",
                                    "Compile o código completo com main() para testar a atribuição.",
                                    "Evite atribuir endereço de variável local sem ponteiro para demonstrar o propósito.",
                                    "Teste compilando com tipos incompatíveis para observar erros."
                                  ],
                                  "verification": "Código compila sem erros e não há warnings de compatibilidade de tipos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor e compilador",
                                    "Terminal para execução (opcional)"
                                  ],
                                  "tips": "O operador & é 'endereço de', não confunda com bitwise AND (&& é lógico).",
                                  "learningObjective": "Aplicar corretamente o operador & para atribuir endereços a ponteiros.",
                                  "commonMistakes": [
                                    "Atribuir valor da variável ao ponteiro (ptr = numero; em vez de &).",
                                    "Ignorar warnings de tipos incompatíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a atribuição imprimindo endereços",
                                  "subSteps": [
                                    "Inclua <stdio.h> para usar printf.",
                                    "Imprima o endereço do ponteiro com %p (ex: printf(\"%p\\n\", (void*)ptr);).",
                                    "Imprima o endereço da variável (ex: printf(\"%p\\n\", (void*)&numero);).",
                                    "Execute o programa e compare os valores exibidos.",
                                    "Altere o valor da variável e verifique indireção básica (*ptr)."
                                  ],
                                  "verification": "Saída do programa mostra endereços idênticos para ptr e &numero.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Compilador com suporte a stdio.h",
                                    "Terminal para rodar ./a.out"
                                  ],
                                  "tips": "Cast para (void*) em %p para portabilidade.",
                                  "learningObjective": "Validar a atribuição de endereço através de inspeção de memória.",
                                  "commonMistakes": [
                                    "Imprimir o valor em vez do endereço.",
                                    "Esquecer #include <stdio.h>."
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo completo em C:\n#include <stdio.h>\nint main() {\n    int numero = 42;\n    int* ptr;\n    ptr = &numero;\n    printf(\"Endereco da variavel: %p\\n\", (void*)&numero);\n    printf(\"Endereco no ponteiro: %p\\n\", (void*)ptr);\n    printf(\"Valor via ponteiro: %d\\n\", *ptr);\n    return 0;\n}\nSaída esperada: endereços iguais e valor 42.",
                              "finalVerifications": [
                                "Programa compila sem erros ou warnings de tipo.",
                                "Endereços impressos para ponteiro e variável são idênticos.",
                                "Desreferência (*ptr) retorna o valor correto da variável.",
                                "Alteração na variável reflete no valor acessado via ponteiro.",
                                "Tentativa com tipos incompatíveis gera erro de compilação.",
                                "Ponteiro não é NULL após atribuição."
                              ],
                              "assessmentCriteria": [
                                "Declaração correta de ponteiro com tipo matching da variável.",
                                "Uso preciso do operador & na atribuição.",
                                "Compreensão de compatibilidade de tipos demonstrada em testes.",
                                "Verificação efetiva via impressão de endereços.",
                                "Identificação e correção de erros comuns como atribuição de valor ao invés de endereço.",
                                "Código comentado e legível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços de memória como valores numéricos em base hexadecimal.",
                                "Lógica e Algoritmos: Conceitos de referência e indireção semelhantes a funções e recursão.",
                                "Engenharia de Software: Fundamento para gerenciamento de memória dinâmica e estruturas de dados.",
                                "Física/Computação: Analogia com ponteiros como 'apontadores' para locais físicos na RAM."
                              ],
                              "realWorldApplication": "Essa habilidade é essencial para implementar estruturas de dados dinâmicas como listas ligadas, árvores binárias e grafos em aplicações reais, como bancos de dados em memória, jogos (gerenciamento de entidades) e sistemas operacionais (alocação de processos), permitindo acesso eficiente e flexível a dados sem cópias desnecessárias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Exemplificar uso do & em código C++",
                            "description": "Escrever um programa simples em C++ que declare uma variável, obtenha seu endereço com & e armazene em um ponteiro, exibindo o endereço via cout para verificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de programação C++ básico",
                                  "subSteps": [
                                    "Instale ou abra um compilador C++ como g++ ou uma IDE como Code::Blocks ou Visual Studio Code com extensão C++.",
                                    "Crie um novo arquivo .cpp, por exemplo 'endereco.cpp'.",
                                    "Inclua a biblioteca necessária: #include <iostream>.",
                                    "Adicione 'using namespace std;' para simplificar o uso de cout.",
                                    "Inicie a função main: int main() {"
                                  ],
                                  "verification": "Verifique se o esqueleto do programa compila sem erros ao adicionar apenas um return 0; no final.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Compilador C++ (g++ ou IDE)",
                                    "Editor de texto ou IDE"
                                  ],
                                  "tips": "Sempre teste a compilação incremental para evitar erros acumulados.",
                                  "learningObjective": "Entender a estrutura mínima de um programa C++ e bibliotecas essenciais para I/O.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula após include",
                                    "Não fechar chaves corretamente",
                                    "Omitir using namespace std; e usar std::cout manualmente sem prática"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar uma variável simples",
                                  "subSteps": [
                                    "Dentro do main, declare uma variável inteira: int x = 10;",
                                    "Adicione uma linha para imprimir o valor da variável: cout << \"Valor de x: \" << x << endl;",
                                    "Compile e execute o programa para confirmar que exibe 'Valor de x: 10'.",
                                    "Experimente alterar o valor de x e reexecute para observar mudanças."
                                  ],
                                  "verification": "O programa executa e imprime corretamente o valor da variável sem erros de compilação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use endl para flush do buffer e nova linha limpa.",
                                  "learningObjective": "Dominar declaração de variáveis e saída básica com cout.",
                                  "commonMistakes": [
                                    "Declarar sem inicializar (int x;)",
                                    "Esquecer << entre elementos no cout",
                                    "Não usar endl ou \\n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter e armazenar o endereço da variável com &",
                                  "subSteps": [
                                    "Declare um ponteiro para inteiro: int* ptr;",
                                    "Atribua o endereço da variável ao ponteiro: ptr = &x;",
                                    "Imprima o endereço diretamente: cout << \"Endereco de x: \" << &x << endl;",
                                    "Imprima o endereço via ponteiro: cout << \"Endereco via ptr: \" << ptr << endl;",
                                    "Compile e execute para comparar os endereços exibidos."
                                  ],
                                  "verification": "Os dois endereços impressos são idênticos (ex: 0x7ffd12345678).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C++"
                                  ],
                                  "tips": "Endereços são em hexadecimal; não se preocupe com o valor exato, foque na igualdade.",
                                  "learningObjective": "Compreender o operador & como obtentor de endereço e atribuição a ponteiro.",
                                  "commonMistakes": [
                                    "Esquecer * no tipo do ponteiro",
                                    "Usar *ptr = &x em vez de ptr = &x",
                                    "Imprimir ptr como inteiro sem cast"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar, compilar e verificar o programa completo",
                                  "subSteps": [
                                    "Adicione return 0; antes da chave final do main.",
                                    "Salve o arquivo e compile: g++ endereco.cpp -o endereco.",
                                    "Execute: ./endereco (Linux/Mac) ou endereco.exe (Windows).",
                                    "Confirme saídas: valor de x, endereço de x e endereço via ptr iguais.",
                                    "Modifique x e reexecute para ver se endereço permanece o mesmo."
                                  ],
                                  "verification": "Programa compila, executa sem crashes e exibe endereços iguais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Compilador g++",
                                    "Terminal"
                                  ],
                                  "tips": "Use -Wall no g++ para warnings extras durante compilação.",
                                  "learningObjective": "Integrar todos os elementos em um programa funcional e depurá-lo.",
                                  "commonMistakes": [
                                    "Fechar main sem return 0;",
                                    "Erro de digitação em nomes de variáveis",
                                    "Executar sem recompilar após mudanças"
                                  ]
                                }
                              ],
                              "practicalExample": "int main() {\n  int x = 10;\n  int* ptr = &x;\n  cout << \"Valor de x: \" << x << endl;\n  cout << \"Endereco de x: \" << &x << endl;\n  cout << \"Endereco via ptr: \" << ptr << endl;\n  return 0;\n}\nSaída esperada:\nValor de x: 10\nEndereco de x: 0x7ffd5c3e4a4c\nEndereco via ptr: 0x7ffd5c3e4a4c",
                              "finalVerifications": [
                                "Programa compila sem erros ou warnings.",
                                "Executa e imprime valor da variável corretamente.",
                                "Dois endereços exibidos são idênticos.",
                                "Alterar valor de x muda a saída de valor, mas não do endereço.",
                                "Nenhum crash ou comportamento indefinido.",
                                "Código está indentado e legível."
                              ],
                              "assessmentCriteria": [
                                "Uso correto do operador & para obter endereço.",
                                "Declaração precisa de ponteiro (int*) sem dereferência desnecessária.",
                                "Saída via cout demonstra endereço armazenado no ponteiro.",
                                "Programa completo compila e executa como esperado.",
                                "Comentários explicando cada linha principal.",
                                "Tratamento de erros comuns evitado (ex: ponteiro não inicializado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação hexadecimal de endereços como números base-16.",
                                "Física/Engenharia: Analogia de endereços de memória com coordenadas físicas em hardware.",
                                "Lógica/Algoritmos: Base para estruturas como listas ligadas e árvores.",
                                "Segurança da Informação: Entendimento de ponteiros previne buffer overflows."
                              ],
                              "realWorldApplication": "Ponteiros com & são fundamentais em C++ para gerenciamento de memória dinâmica (new/delete), estruturas de dados avançadas como linked lists e árvores binárias, e otimização de performance em jogos, sistemas operacionais e engines gráficas como Unreal Engine."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Operador de Dereferência (*)",
                        "description": "O operador * (dereferência) é usado para acessar ou modificar o valor armazenado no endereço de memória apontado por um ponteiro, permitindo manipulação indireta de dados.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Aplicar sintaxe de dereferência em ponteiros",
                            "description": "Utilizar o operador * prefixado a um ponteiro para acessar o valor no endereço apontado, diferenciando-o do uso de * na declaração de ponteiros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar declaração de ponteiros e o papel do operador *",
                                  "subSteps": [
                                    "Estude a sintaxe básica: int x = 10; int *ptr;",
                                    "Identifique que o * na declaração indica que ptr é um ponteiro para int",
                                    "Compare com declaração de variável normal: int x vs int *ptr",
                                    "Anote exemplos de tipos: char *cptr, double *dptr",
                                    "Pratique declarando 3 ponteiros para diferentes tipos"
                                  ],
                                  "verification": "Escreva 3 declarações corretas de ponteiros e explique o * em cada uma",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code ou similar), documentação de C sobre ponteiros",
                                  "tips": "Sempre leia a declaração da direita para a esquerda: ptr é ponteiro para int",
                                  "learningObjective": "Dominar a sintaxe de declaração diferenciando * declarativo de uso",
                                  "commonMistakes": "Esquecer o tipo base (ex: *ptr em vez de int *ptr), confundir com arrays"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar ponteiro com endereço de variável",
                                  "subSteps": [
                                    "Declare uma variável: int x = 5;",
                                    "Use & para obter endereço: int *ptr = &x;",
                                    "Compile um código simples para verificar se ptr aponta para x",
                                    "Imprima o endereço com %p: printf(\"Endereço: %p\\n\", (void*)ptr);",
                                    "Confirme que &x == ptr com comparação"
                                  ],
                                  "verification": "Execute printf(\"x: %d, &x: %p, ptr: %p\\n\", x, (void*)&x, (void*)ptr); deve mostrar igualdade de endereços",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador C (GCC), terminal para compilar e executar",
                                  "tips": "Use casting (void*) para imprimir endereços de forma segura",
                                  "learningObjective": "Associar ponteiro a um endereço válido usando &",
                                  "commonMistakes": "Atribuir valor direto (*ptr = 5 sem &), ponteiro não inicializado (dangling pointer)"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar operador * para dereferenciar e acessar valor",
                                  "subSteps": [
                                    "Com ponteiro inicializado, use *ptr para ler: printf(\"%d\\n\", *ptr);",
                                    "Modifique via dereferência: *ptr = 20; verifique se x mudou",
                                    "Teste em loop: for(int i=0; i<5; i++) *ptr = i;",
                                    "Combine leitura e escrita em funções simples",
                                    "Evite dereferência sem inicialização"
                                  ],
                                  "verification": "Altere valor de x via *ptr e confirme printf de x reflete mudança",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C, debugger (GDB opcional)",
                                  "tips": "Pense em * como 'vá ao endereço e pegue/coloca o valor'",
                                  "learningObjective": "Usar * prefixado para acessar e modificar o valor apontado",
                                  "commonMistakes": "Dereferenciar NULL ou uninitialized (segmentation fault), esquecer ; após *ptr ="
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar dereferência em cenários compostos e debugar",
                                  "subSteps": [
                                    "Crie função que recebe ponteiro: void increment(int *p) { (*p)++; }",
                                    "Chame: increment(&x); verifique x++",
                                    "Use array: int arr[3] = {1,2,3}; int *p = arr; *p = 10;",
                                    "Debug erro comum: printf(\"*p: %d\\n\", *p); sem init",
                                    "Escreva programa completo com múltiplos ponteiros"
                                  ],
                                  "verification": "Programa compila, executa sem crash e produz saída esperada (ex: valores alterados corretamente)",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C, exemplos de código de ponteiros",
                                  "tips": "Em funções, passe & para permitir modificação via ponteiro",
                                  "learningObjective": "Integrar dereferência em funções e estruturas para uso real",
                                  "commonMistakes": "Confundir ptr++ (move ponteiro) com (*ptr)++ (incrementa valor), off-by-one em arrays"
                                }
                              ],
                              "practicalExample": "#include <stdio.h>\nint main() {\n    int x = 10;\n    int *ptr = &x;\n    printf(\"Original x: %d\\n\", x);\n    printf(\"Via ponteiro: %d\\n\", *ptr);\n    *ptr = 25;\n    printf(\"x modificado: %d\\n\", x);\n    return 0;\n}\n/* Saída esperada:\nOriginal x: 10\nVia ponteiro: 10\nx modificado: 25\n*/",
                              "finalVerifications": [
                                "Escreva e compile um programa que lê valor via *ptr e o modifica corretamente",
                                "Explique em comentário no código a diferença entre int *p e *p = 5",
                                "Use GDB para inspecionar valor de *ptr em breakpoint",
                                "Crie swap de duas variáveis usando ponteiros e dereferência",
                                "Teste dereferência em array e confirme acesso sequencial",
                                "Identifique e corrija segmentation fault em código com ponteiro não init"
                              ],
                              "assessmentCriteria": [
                                "Código compila sem warnings de ponteiro não inicializado",
                                "Saídas de printf mostram acesso e modificação corretos via *",
                                "Explicações diferencia claramente * declarativo vs dereferência",
                                "Manipulação em funções demonstra passagem por referência",
                                "Ausência de crashes ou undefined behavior em testes",
                                "Comentários no código destacam uso de * corretamente"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como números hexadecimais e aritmética de ponteiros",
                                "Estruturas de Dados: Base para linked lists e árvores via nós ponteirados",
                                "Algoritmos: Otimização de passagem de parâmetros por referência",
                                "Engenharia de Software: Gerenciamento de memória dinâmica e alocação",
                                "Sistemas Operacionais: Acesso a memória e ponteiros para registradores"
                              ],
                              "realWorldApplication": "Em desenvolvimento de jogos, ponteiros dereferenciados manipulam posições dinâmicas de objetos; em sistemas embarcados, acessam registradores de hardware diretamente; em bancos de dados, gerenciam estruturas linked lists para índices eficientes; em IA, otimizam arrays grandes para processamento de dados sem cópias desnecessárias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Ler valor via dereferência",
                            "description": "Em um programa C++, usar *ponteiro para ler e exibir o valor de uma variável através do ponteiro que armazena seu endereço obtido com &.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar variável e ponteiro",
                                  "subSteps": [
                                    "Declare uma variável inteira, por exemplo: int numero = 42;",
                                    "Declare um ponteiro para inteiro: int* ptr;",
                                    "Compile o código parcial para garantir que não há erros de sintaxe básica",
                                    "Explique em um comentário o propósito de cada declaração",
                                    "Inicialize a variável com um valor conhecido"
                                  ],
                                  "verification": "Código compila sem erros e variável é acessível via nome",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou similar)",
                                    "Compilador C++ (g++)"
                                  ],
                                  "tips": "Sempre use tipos compatíveis entre variável e ponteiro para evitar warnings.",
                                  "learningObjective": "Compreender a declaração básica de variáveis e ponteiros em C++.",
                                  "commonMistakes": [
                                    "Esquecer o asterisco (*) na declaração do ponteiro",
                                    "Usar tipo errado para o ponteiro",
                                    "Não inicializar a variável"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter e atribuir endereço com &",
                                  "subSteps": [
                                    "Use o operador & para obter o endereço da variável: ptr = &numero;",
                                    "Adicione um cout para imprimir o endereço: cout << ptr << endl;",
                                    "Compile e execute para visualizar o endereço em hexadecimal",
                                    "Compare o endereço impresso com o valor da variável para diferenciar",
                                    "Adicione comentários explicando o operador &"
                                  ],
                                  "verification": "Programa executa e imprime um endereço válido (ex: 0x7ffd...) sem crash",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Endereços são únicos por execução; não se preocupe se mudarem entre runs.",
                                  "learningObjective": "Dominar o uso do operador & para capturar endereços de memória.",
                                  "commonMistakes": [
                                    "Atribuir valor direto ao ponteiro sem &",
                                    "Usar * no lado esquerdo da atribuição",
                                    "Ignorar warnings de ponteiro não inicializado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ler valor via dereferência com *",
                                  "subSteps": [
                                    "Use o operador * para dereferenciar: cout << *ptr << endl;",
                                    "Acesse o valor e armazene em outra variável: int valorLido = *ptr;",
                                    "Imprima valorLido para confirmar igualdade com numero",
                                    "Altere o valor da variável original e verifique se *ptr reflete a mudança",
                                    "Compile, execute e valide múltiplas dereferências"
                                  ],
                                  "verification": "Output mostra o valor correto da variável (ex: 42) via *ptr",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Editor com suporte a C++"
                                  ],
                                  "tips": "O * dereferencia apenas quando usado no lado direito; evite confusão com declaração.",
                                  "learningObjective": "Aplicar o operador * para ler valores indiretos através de ponteiros.",
                                  "commonMistakes": [
                                    "Usar *ptr = algo sem intenção de alterar",
                                    "Dereferenciar ponteiro nulo (mas aqui está inicializado)",
                                    "Confundir * com declaração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e debugar o programa completo",
                                  "subSteps": [
                                    "Escreva o programa completo com includes (#include <iostream>) e main()",
                                    "Execute com diferentes valores na variável e valide saídas",
                                    "Use gdb ou cout para inspecionar ptr e *ptr em runtime",
                                    "Adicione tratamento de erro básico (verificar se ptr != nullptr)",
                                    "Documente o código com explicações de cada linha"
                                  ],
                                  "verification": "Programa completo compila, executa sem erros e outputs corretos consistentemente",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GDB (debugger opcional)",
                                    "Compilador C++"
                                  ],
                                  "tips": "Sempre inclua using namespace std; para simplicidade em exemplos iniciais.",
                                  "learningObjective": "Integrar conceitos em um programa funcional e depurável.",
                                  "commonMistakes": [
                                    "Esquecer return 0; no main()",
                                    "Não incluir headers necessários",
                                    "Ponteiro pendente por escopo errado"
                                  ]
                                }
                              ],
                              "practicalExample": "int main() {\n  int numero = 42;\n  int* ptr = &numero;\n  std::cout << \"Valor direto: \" << numero << std::endl;\n  std::cout << \"Endereco: \" << ptr << std::endl;\n  std::cout << \"Valor via ponteiro: \" << *ptr << std::endl;\n  numero = 100;\n  std::cout << \"Novo valor via ponteiro: \" << *ptr << std::endl;\n  return 0;\n}\nOutput esperado: 42, endereço hex, 42, 100",
                              "finalVerifications": [
                                "Programa compila sem warnings ou erros",
                                "Output exibe valor correto via *ptr igual ao da variável",
                                "Alteração na variável reflete em *ptr",
                                "Endereço impresso é válido e único",
                                "Nenhum segmentation fault ou crash",
                                "Código documentado com comentários"
                              ],
                              "assessmentCriteria": [
                                "Correto uso de & para endereço e * para dereferência",
                                "Ponteiro inicializado antes do uso",
                                "Outputs validados contra valores esperados",
                                "Código limpo, compilável e executável",
                                "Compreensão demonstrada via comentários ou testes extras",
                                "Ausência de vazamentos ou erros comuns de ponteiros"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como valores numéricos em memória (aritmética de ponteiros futura)",
                                "Lógica e Algoritmos: Indireção como abstração em estruturas de dados",
                                "Física/Engenharia: Analogia com referências a locais físicos via coordenadas",
                                "Programação Funcional: Conceitos de referências imutáveis vs mutáveis"
                              ],
                              "realWorldApplication": "Em gerenciamento de memória dinâmica (new/delete), listas ligadas, árvores, ou bibliotecas como STL (iteradores usam ponteiros internamente), permitindo acesso eficiente a dados sem copiar valores grandes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Modificar valor via dereferência",
                            "description": "Alterar o conteúdo de uma variável usando *ponteiro = novo_valor, demonstrando como ponteiros permitem modificação indireta e comparando com atribuição direta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar atribuição direta e introduzir ponteiros",
                                  "subSteps": [
                                    "Declare uma variável inteira e atribua um valor inicial usando atribuição direta (ex: int x = 5; x = 10;)",
                                    "Compile e execute o código para observar a modificação direta",
                                    "Explique verbalmente por que a atribuição direta funciona apenas no escopo local",
                                    "Declare um ponteiro para inteiro (int *p;) e discuta sua relação com endereços de memória",
                                    "Use operador & para obter o endereço da variável e atribua ao ponteiro (p = &x;)"
                                  ],
                                  "verification": "O código compila sem erros e você pode imprimir o endereço da variável via ponteiro (*p mostra valor original).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C++ (GCC ou online como Compiler Explorer)",
                                    "Editor de texto ou IDE como VS Code"
                                  ],
                                  "tips": "Sempre inicialize ponteiros para evitar dangling pointers; use printf para depuração.",
                                  "learningObjective": "Compreender como ponteiros armazenam endereços e permitem acesso indireto.",
                                  "commonMistakes": [
                                    "Esquecer o & ao atribuir endereço",
                                    "Confundir *p (valor) com p (endereço)",
                                    "Não compilar antes de testar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar leitura via dereferência",
                                  "subSteps": [
                                    "Imprima o valor da variável via ponteiro usando *p",
                                    "Compare o output de x e *p para confirmar equivalência",
                                    "Altere o valor de x diretamente e observe mudança em *p",
                                    "Explique que * é o operador de dereferência, acessando o conteúdo do endereço",
                                    "Teste em uma função simples passando por valor para ver limitação"
                                  ],
                                  "verification": "Impressões mostram x == *p antes e após alteração direta.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Mesmo compilador e editor do passo anterior",
                                    "Exemplos de código prontos para copiar"
                                  ],
                                  "tips": "Use %p para imprimir endereços e %d para valores em printf.",
                                  "learningObjective": "Dominar o uso de * para ler valores indiretos.",
                                  "commonMistakes": [
                                    "Usar p em vez de *p para acessar valor",
                                    "Passar ponteiro por valor sem &",
                                    "Ignorar warnings de compilador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar valor via dereferência",
                                  "subSteps": [
                                    "Atribua um novo valor ao ponteiro: *p = 20;",
                                    "Imprima x e *p para verificar que ambos mudaram",
                                    "Crie uma função que recebe ponteiro como parâmetro e modifica via *ptr",
                                    "Chame a função passando &x e observe modificação no escopo principal",
                                    "Compare com versão por valor para destacar diferença"
                                  ],
                                  "verification": "Após *p = novo_valor, x reflete a mudança mesmo fora da função.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Papel e caneta para diagramas de memória"
                                  ],
                                  "tips": "Desenhe diagrama: variável -> endereço -> ponteiro para visualizar.",
                                  "learningObjective": "Aplicar *ponteiro = novo_valor para modificação indireta.",
                                  "commonMistakes": [
                                    "Esquecer * na atribuição (*p vs p)",
                                    "Não passar endereço na chamada de função",
                                    "Segmentation fault por ponteiro não inicializado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e depurar modificações",
                                  "subSteps": [
                                    "Escreva código lado a lado: direto vs via ponteiro",
                                    "Teste cenários de erro: ponteiro nulo, modificação inválida",
                                    "Use gdb ou printf para depurar valores de ponteiro",
                                    "Discuta quando usar cada abordagem (direta para simplicidade, indireta para funções)",
                                    "Refatore um código existente substituindo cópias por ponteiros"
                                  ],
                                  "verification": "Código refatorado funciona corretamente e você explica trade-offs.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Debugger como GDB",
                                    "Exemplos de código com erros intencionais"
                                  ],
                                  "tips": "Sempre cheque if(p != NULL) antes de dereferenciar.",
                                  "learningObjective": "Comparar eficácia e depurar usos de dereferência.",
                                  "commonMistakes": [
                                    "Overhead desnecessário de ponteiros em casos simples",
                                    "Memory leaks por alocações esquecidas",
                                    "Confundir com referências em C++"
                                  ]
                                }
                              ],
                              "practicalExample": "int main() { int x = 5; int *p = &x; printf(\"Antes: %d\\n\", x); *p = 10; printf(\"Depois: %d\\n\", x); // Saída: 5, 10 } Função: void muda(int *ptr) { *ptr = 20; } // Chamar: muda(&x);",
                              "finalVerifications": [
                                "Código compila e executa sem crashes",
                                "Valor de x muda após *p = novo_valor",
                                "Função com ponteiro modifica variável original",
                                "Impressões confirmam x == *p sempre",
                                "Depuração mostra endereço correto",
                                "Comparação com pass-by-value destaca diferença"
                              ],
                              "assessmentCriteria": [
                                "Correto uso de & e * em declarações e atribuições",
                                "Modificação indireta afeta variável original",
                                "Código livre de erros comuns como null pointer",
                                "Explicação clara da indireção vs direta",
                                "Eficiência: evita cópias desnecessárias",
                                "Testes incluem casos edge (valores zero, negativos)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como funções de mapeamento (funções injetoras)",
                                "Física: Analogia com posições em espaço vetorial",
                                "Lógica: Ponteiros como referências em grafos",
                                "Engenharia: Otimização de memória em sistemas embarcados"
                              ],
                              "realWorldApplication": "Em jogos, ponteiros modificam posições de entidades sem copiar structs inteiras; em bancos de dados, alteram registros via handles; em SO, kernels usam para swap de páginas sem duplicação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Passagem de Parâmetros por Referência com Ponteiros",
                    "description": "Aplicação de ponteiros em funções para simular passagem de parâmetros por referência.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Passagem de Parâmetros por Valor versus por Referência",
                        "description": "Compreender a diferença entre passagem por valor, que cria cópias e não altera a variável original, e passagem por referência simulada com ponteiros, permitindo modificações efetivas na variável chamadora em linguagens como C.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Identificar limitações da passagem por valor",
                            "description": "Analisar código em C onde uma função recebe parâmetros por valor e demonstrar que alterações internas não afetam variáveis externas, com exemplos como void soma(int a, int b).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Funções e Passagem de Parâmetros por Valor",
                                  "subSteps": [
                                    "Leia a definição de passagem por valor em C: uma cópia do valor é passada para a função.",
                                    "Estude a sintaxe de declaração de funções com parâmetros primitivos (int, float, etc.).",
                                    "Analise diagramas ou fluxogramas mostrando cópia de valor para o escopo da função.",
                                    "Identifique que variáveis locais na função são independentes das externas.",
                                    "Anote exemplos simples de funções sem parâmetros para reforçar o entendimento."
                                  ],
                                  "verification": "Resuma em suas palavras o que acontece com um parâmetro int passado por valor para uma função.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de C sobre funções",
                                    "Editor de texto ou IDE como VS Code",
                                    "Compilador GCC"
                                  ],
                                  "tips": "Use diagramas mentais para visualizar a pilha de chamadas e cópias de variáveis.",
                                  "learningObjective": "Compreender o mecanismo fundamental de passagem por valor em C.",
                                  "commonMistakes": [
                                    "Confundir com passagem por referência",
                                    "Achar que parâmetros são aliases das variáveis originais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar uma Função com Passagem por Valor",
                                  "subSteps": [
                                    "Escreva uma função void soma(int a, int b) que compute a + b e armazene em a.",
                                    "No main, declare variáveis int x = 5, y = 3; e chame soma(x, y).",
                                    "Imprima x e y antes e depois da chamada da função.",
                                    "Compile e execute o código para observar os valores.",
                                    "Adicione printf dentro da função para mostrar valores de a e b internamente."
                                  ],
                                  "verification": "Confirme que x e y no main permanecem inalterados após a chamada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com suporte a C (Code::Blocks ou CLion)",
                                    "Compilador C instalado"
                                  ],
                                  "tips": "Use printf com formatos %d para depuração clara.",
                                  "learningObjective": "Criar e testar código que demonstra passagem por valor.",
                                  "commonMistakes": [
                                    "Esquecer de imprimir antes/depois",
                                    "Usar ponteiros acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Comportamento e Identificar Limitações",
                                  "subSteps": [
                                    "Compare valores impressos: internos vs. externos à função.",
                                    "Explique por que alterações em a/b não afetam x/y (cópias na pilha).",
                                    "Teste com outros tipos primitivos (float, char) para generalizar.",
                                    "Liste cenários limitados: não alterar caller, ineficiência com structs grandes.",
                                    "Registre 3 limitações principais em um documento."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito as 3 limitações observadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Código do Step 2"
                                  ],
                                  "tips": "Pense em 'cópia = original' no momento da chamada.",
                                  "learningObjective": "Diagnosticar e articular limitações da passagem por valor.",
                                  "commonMistakes": [
                                    "Ignorar overhead de cópia para tipos grandes",
                                    "Confundir com Java pass-by-value de objetos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reforçar com Contraexemplos e Exercícios",
                                  "subSteps": [
                                    "Modifique o código para tentar alterar múltiplos parâmetros e observe falhas.",
                                    "Crie um exercício: função que deveria incrementar um contador mas falha por valor.",
                                    "Compare brevemente com protótipo de ponteiro (sem implementar fully).",
                                    "Resolva 2 variações: uma com array (decaindo para ponteiro), uma primitiva.",
                                    "Autoavalie compreensão respondendo perguntas guiadas."
                                  ],
                                  "verification": "Execute exercícios e confirme que identifica falhas consistentemente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código base expandido",
                                    "Lista de exercícios preparados"
                                  ],
                                  "tips": "Evite ponteiros aqui; foque puramente em valor para isolar conceito.",
                                  "learningObjective": "Aplicar conhecimento para prever e corrigir comportamentos inesperados.",
                                  "commonMistakes": [
                                    "Misturar conceitos de arrays (passados por endereço)",
                                    "Achar que todos os tipos são por valor igual"
                                  ]
                                }
                              ],
                              "practicalExample": "Função void incrementa(int n) { n++; printf('Interno: %d\\n', n); }. No main: int x=10; incrementa(x); printf('Externo: %d\\n', x);. Saída: Interno:11, Externo:10. Demonstra que x não é alterado, limitando uso quando modificação é necessária.",
                              "finalVerifications": [
                                "Explicar mecanismo de cópia na pilha de execução.",
                                "Prever saída de código com passagem por valor sem executar.",
                                "Listar 3 cenários onde passagem por valor falha (ex: swap de variáveis).",
                                "Diferenciar de passagem por referência em um diagrama.",
                                "Identificar limitações em código real fornecido.",
                                "Resolver exercício: por que void swap(int a, int b) não troca valores?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação do mecanismo de cópia (90-100%).",
                                "Capacidade de codificar e depurar exemplo corretamente.",
                                "Identificação completa de pelo menos 3 limitações.",
                                "Uso correto de ferramentas de depuração (printf).",
                                "Generalização para outros tipos primitivos.",
                                "Clareza em verificações finais e autoavaliação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções como mapeamentos de entrada para saída sem side-effects.",
                                "Lógica: Compreensão de escopos e independência de variáveis.",
                                "Física/Engenharia: Analogia com cópias físicas vs. referências (ex: fotocópia vs. espelho)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software seguro, passagem por valor previne side-effects acidentais em funções utilitárias (ex: cálculos em bibliotecas financeiras), mas limita em cenários como ordenação ou modificação de dados do chamador, exigindo ponteiros para eficiência e mutabilidade em sistemas embarcados ou jogos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Reconhecer cenários para passagem por referência",
                            "description": "Identificar situações como troca de valores ou retorno múltiplo de resultados onde ponteiros são necessários para simular referência, justificando com pseudocódigo ou C.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Passagem por Valor e suas Limitações",
                                  "subSteps": [
                                    "Defina passagem por valor: uma cópia do valor é passada para a função.",
                                    "Escreva pseudocódigo simples de uma função que recebe um inteiro por valor e tenta modificá-lo.",
                                    "Execute mentalmente o pseudocódigo e observe que a variável original não é alterada.",
                                    "Compare com expectativa: explique por que modificações locais não propagam.",
                                    "Liste 2 limitações principais da passagem por valor."
                                  ],
                                  "verification": "Escreva e trace um pseudocódigo de passagem por valor confirmando que o original permanece inalterado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Papel e caneta para tracing"
                                  ],
                                  "tips": "Sempre trace o valor da variável antes e depois da chamada da função.",
                                  "learningObjective": "Compreender mecanicamente por que passagem por valor cria uma cópia independente.",
                                  "commonMistakes": [
                                    "Confundir passagem por valor com atribuição simples",
                                    "Ignorar que arrays são passados por referência implícita em C"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Cenário de Troca de Valores (Swap)",
                                  "subSteps": [
                                    "Analise o problema: criar uma função swap(a, b) que troque valores de duas variáveis.",
                                    "Tente implementar swap por valor em pseudocódigo e demonstre falha.",
                                    "Explique por que ponteiros são necessários: passar endereços para acessar as originais.",
                                    "Escreva pseudocódigo com ponteiros simulando referência (*a e *b).",
                                    "Justifique: sem referência, só cópias são trocadas."
                                  ],
                                  "verification": "Implemente swap por valor (falha) e por referência (sucesso) em pseudocódigo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Compilador C para teste opcional"
                                  ],
                                  "tips": "Use diagramas de pilha de memória para visualizar cópias vs endereços.",
                                  "learningObjective": "Reconhecer swap como cenário clássico para passagem por referência.",
                                  "commonMistakes": [
                                    "Esquecer o * na desreferenciação",
                                    "Passar endereço sem ponteiro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Retorno Múltiplo de Valores",
                                  "subSteps": [
                                    "Discuta limitação: funções retornam um valor só; múltiplos requerem referência.",
                                    "Exemplo: função que atualiza max e min de um array, modificando variáveis externas.",
                                    "Escreva pseudocódigo por valor (falha em retornar ambos).",
                                    "Refatore com ponteiros para &max e &min, simulando out-parameters.",
                                    "Justifique em C: use void updateMaxMin(int* max, int* min)."
                                  ],
                                  "verification": "Crie pseudocódigo que modifique duas variáveis externas via ponteiros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Exemplos de código C"
                                  ],
                                  "tips": "Pense em funções como 'saída' para múltiplos resultados.",
                                  "learningObjective": "Identificar cenários onde múltiplas saídas demandam referência.",
                                  "commonMistakes": [
                                    "Usar retorno struct desnecessariamente complexo",
                                    "Confundir ponteiros de entrada/saída"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Justificativa em Código C",
                                  "subSteps": [
                                    "Compile e teste swap em C por valor vs ponteiros.",
                                    "Crie função para retornar múltiplos valores via ponteiros.",
                                    "Analise 2 cenários adicionais: redimensionar array, atualizar contador.",
                                    "Justifique cada um: 'Por valor falha porque...' com código.",
                                    "Resuma regras: use referência quando precisar alterar original ou múltiplas saídas."
                                  ],
                                  "verification": "Escreva código C funcional para 2 cenários com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "IDE como VS Code"
                                  ],
                                  "tips": "Teste sempre com printf para valores antes/depois.",
                                  "learningObjective": "Aplicar reconhecimento em código real, justificando escolhas.",
                                  "commonMistakes": [
                                    "Dereferenciar ponteiro nulo",
                                    "Não inicializar ponteiros"
                                  ]
                                }
                              ],
                              "practicalExample": "Função swap em C: por valor (int swap(int a, int b)) falha; por referência (void swap(int* a, int* b) { int temp = *a; *a = *b; *b = temp; }) succeeds, alterando originais.",
                              "finalVerifications": [
                                "Identificar corretamente swap e retorno múltiplo como cenários para referência.",
                                "Escrever pseudocódigo funcional com ponteiros para 2 cenários.",
                                "Explicar falha da passagem por valor em pelo menos 3 exemplos.",
                                "Compilar e testar código C sem erros de referência.",
                                "Justificar uso de ponteiros vs valor em parágrafo curto.",
                                "Listar 3 erros comuns em cenários de referência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários (100% corretos).",
                                "Qualidade do pseudocódigo e código C (compilável e funcional).",
                                "Profundidade da justificativa (causa-raiz da necessidade).",
                                "Uso correto de terminologia (ponteiro, desreferenciação, endereço).",
                                "Criatividade em exemplos adicionais relevantes.",
                                "Clareza em verificações e diagramas de memória."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços como funções de mapeamento memória-variável.",
                                "Lógica e Algoritmos: Raciocínio sobre estado mutável vs imutável.",
                                "Física: Analogia de ponteiros com endereços físicos de objetos.",
                                "Engenharia de Software: Padrões de design para parâmetros de saída."
                              ],
                              "realWorldApplication": "Em bibliotecas de gerenciamento de memória (ex: malloc/free), editores de texto (swap buffers), ou jogos (atualizar posições múltiplas de entidades via ponteiros para eficiência e mutabilidade compartilhada)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Declaração de Funções com Parâmetros Ponteiro",
                        "description": "Dominar a sintaxe para declarar funções que recebem ponteiros como parâmetros, incluindo o uso de * na assinatura e & na chamada.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Escrever assinatura de função com ponteiro",
                            "description": "Criar protótipos como void incremento(int *p); explicando que *p indica ponteiro para int e permite acesso ao endereço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar componentes de uma assinatura de função em C",
                                  "subSteps": [
                                    "Identifique o tipo de retorno (ex: void, int)",
                                    "Defina o nome da função de forma descritiva",
                                    "Liste os parâmetros entre parênteses, separados por vírgula",
                                    "Finalize com ponto e vírgula (;)"
                                  ],
                                  "verification": "Escreva uma assinatura simples como 'int soma(int a, int b);' e identifique cada componente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou similar)",
                                    "Referência de sintaxe C (site ou PDF)"
                                  ],
                                  "tips": "Assinatura é o protótipo, sem corpo da função. Use nomes claros para parâmetros.",
                                  "learningObjective": "Compreender a estrutura básica de uma assinatura de função.",
                                  "commonMistakes": [
                                    "Esquecer o ponto e vírgula",
                                    "Confundir assinatura com definição completa da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a sintaxe de ponteiros em parâmetros",
                                  "subSteps": [
                                    "Aprenda que 'int *p' declara um ponteiro para inteiro",
                                    "Entenda que '*' antes do nome indica ponteiro",
                                    "Diferencie declaração de ponteiro de desreferenciamento (*p)",
                                    "Explique que ponteiro permite acesso por referência ao endereço de memória",
                                    "Pratique declarando variáveis ponteiro simples"
                                  ],
                                  "verification": "Declare 'int *p;' e explique seu significado em uma frase.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C online (repl.it)",
                                    "Documentação sobre ponteiros em C"
                                  ],
                                  "tips": "Pense no ponteiro como um 'apontador' para o endereço da variável, não o valor.",
                                  "learningObjective": "Dominar a notação de ponteiro em declarações.",
                                  "commonMistakes": [
                                    "Confundir '*' como multiplicação",
                                    "Esquecer o espaço entre tipo e '*p'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir assinatura de função com parâmetro ponteiro",
                                  "subSteps": [
                                    "Combine tipo de retorno e nome da função",
                                    "Insira parâmetro ponteiro como 'int *p' dentro dos parênteses",
                                    "Adicione múltiplos parâmetros se necessário (ex: int *p, int valor)",
                                    "Explique o papel: permite modificar a variável original via endereço",
                                    "Escreva 3 exemplos variados"
                                  ],
                                  "verification": "Crie 'void incremento(int *p);' e justifique o uso do ponteiro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Exemplos de código C com ponteiros"
                                  ],
                                  "tips": "Sempre use '*' imediatamente após o tipo, antes do nome do parâmetro.",
                                  "learningObjective": "Integrar ponteiros na assinatura de funções para passagem por referência.",
                                  "commonMistakes": [
                                    "Colocar '*' após o nome do parâmetro (int p*)",
                                    "Omitir o tipo do ponteiro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e validar assinaturas com ponteiros",
                                  "subSteps": [
                                    "Escreva assinaturas para cenários reais (ex: troca de valores)",
                                    "Compile um protótipo em um programa simples",
                                    "Teste chamadas com '&variavel' para passar endereço",
                                    "Corrija erros de sintaxe comuns",
                                    "Documente o que cada assinatura faz"
                                  ],
                                  "verification": "Implemente e compile um programa usando 'void troca(int *a, int *b);'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador GCC ou online",
                                    "Programa base com main()"
                                  ],
                                  "tips": "Use 'gcc arquivo.c -o saida' para testar. Verifique warnings.",
                                  "learningObjective": "Aplicar e debugar assinaturas de funções com ponteiros.",
                                  "commonMistakes": [
                                    "Passar valor sem '&' na chamada",
                                    "Desreferenciar ponteiro nulo"
                                  ]
                                }
                              ],
                              "practicalExample": "void incremento(int *p) { *p = *p + 1; } // Assinatura: void incremento(int *p); Recebe endereço de um int via ponteiro e incrementa o valor no endereço original.",
                              "finalVerifications": [
                                "Escreve corretamente 'void dobro(int *x);'",
                                "Explica que '*p' permite modificação por referência",
                                "Identifica erro em 'void func(int p*);'",
                                "Cria assinatura com múltiplos ponteiros: 'void soma(int *a, int *b, int *res);'",
                                "Compila um protótipo sem erros de sintaxe"
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa com '*' no lugar correto",
                                "Tipo de retorno apropriado (ex: void para funções sem retorno)",
                                "Explicação clara do papel do ponteiro",
                                "Exemplos variados e corretos",
                                "Ausência de erros comuns como falta de ';'",
                                "Capacidade de debugar assinaturas inválidas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Endereços de memória como referências algébricas",
                                "Lógica: Fluxo de dados por referência vs. valor",
                                "Engenharia de Software: Abstração e modularidade em funções",
                                "Física/Computação: Analogia com ponteiros como 'setas' para locais físicos na memória"
                              ],
                              "realWorldApplication": "Usado em funções que modificam dados originais sem copiar (ex: ordenação de arrays, alocação dinâmica em jogos ou sistemas embarcados, evitando overhead de cópias em estruturas grandes)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Chamar função passando endereço de variável",
                            "description": "Implementar chamadas como incremento(&x); onde & obtém o endereço de x, e depurar erros comuns como esquecer o &.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o operador de endereço (&)",
                                  "subSteps": [
                                    "Explicar o conceito de endereço de memória de uma variável.",
                                    "Identificar que &x retorna o endereço de x.",
                                    "Diferenciar endereço (ponteiro) do valor da variável.",
                                    "Executar um programa simples para imprimir &x e compará-lo com printf(\"%p\", &x);",
                                    "Entender que endereços são únicos para cada variável"
                                  ],
                                  "verification": "Criar e executar um programa que imprima o endereço de pelo menos duas variáveis diferentes e confirme que são distintos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C (ex: gcc)",
                                    "Editor de texto (ex: VS Code)"
                                  ],
                                  "tips": "Use %p no printf para imprimir endereços; nunca tente imprimir endereço sem ponteiro.",
                                  "learningObjective": "Dominar o uso do operador & para obter endereços de variáveis.",
                                  "commonMistakes": [
                                    "Confundir & com operador bitwise AND (&&)",
                                    "Aplicar & em literais ou expressões constantes",
                                    "Ignorar que endereços mudam entre execuções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar a variável e a função para passagem por referência",
                                  "subSteps": [
                                    "Declarar uma variável inteira simples (ex: int x = 10;).",
                                    "Revisar a declaração da função que recebe ponteiro (ex: void incremento(int *p);).",
                                    "Confirmar que a função usa *p para acessar e modificar o valor.",
                                    "Compilar um esboço da função isoladamente para verificar assinatura.",
                                    "Planejar a chamada: incremento(&x);"
                                  ],
                                  "verification": "Escrever o protótipo da função e declarar a variável, compilando sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Documentação de ponteiros em C"
                                  ],
                                  "tips": "Sempre declare funções com protótipos antes de main() para evitar warnings.",
                                  "learningObjective": "Preparar corretamente variáveis e funções para passagem de endereço.",
                                  "commonMistakes": [
                                    "Declarar função sem * no parâmetro",
                                    "Esquecer protótipo da função",
                                    "Usar variável const sem const int*"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a chamada da função passando endereço",
                                  "subSteps": [
                                    "Posicionar a chamada dentro de main(): incremento(&x);",
                                    "Adicionar prints antes e depois para observar mudança em x.",
                                    "Compilar o programa completo com gcc -o programa main.c.",
                                    "Executar e verificar se x foi modificado.",
                                    "Testar com múltiplas chamadas para validar"
                                  ],
                                  "verification": "Executar o programa e confirmar que o valor de x muda após a chamada da função.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use gdb ou printf para depurar se não compilar.",
                                  "learningObjective": "Executar chamadas de funções passando endereços corretamente.",
                                  "commonMistakes": [
                                    "Esquecer o & na chamada (incremento(x);)",
                                    "Passar endereço de variável local fora de escopo",
                                    "Não dereferenciar *p dentro da função"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Depurar erros comuns e validar o aprendizado",
                                  "subSteps": [
                                    "Introduzir erro intencional: chamar sem & e observar falha.",
                                    "Corrigir e recompilar, notando o erro de compilação ou runtime.",
                                    "Testar com array ou struct para generalizar.",
                                    "Usar valgrind para checar acessos inválidos (opcional).",
                                    "Documentar lições aprendidas em comentários no código"
                                  ],
                                  "verification": "Criar versão com erro comum, corrigi-la e confirmar sucesso em pelo menos 3 cenários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Ferramenta de depuração (ex: gdb ou valgrind)"
                                  ],
                                  "tips": "Erros de ponteiro causam segmentation fault; use printf para rastrear endereços.",
                                  "learningObjective": "Identificar e corrigir erros em chamadas por referência com ponteiros.",
                                  "commonMistakes": [
                                    "Dangling pointers (endereço de variável destruída)",
                                    "Confundir passagem por valor vs referência",
                                    "Não inicializar ponteiro"
                                  ]
                                }
                              ],
                              "practicalExample": "#include <stdio.h>\n\nvoid incremento(int *p) {\n    *p += 1;\n}\n\nint main() {\n    int x = 5;\n    printf(\"Antes: %d (endereço: %p)\\n\", x, &x);\n    incremento(&x);\n    printf(\"Depois: %d\\n\", x);\n    return 0;\n}\n/* Saída esperada: Antes: 5, Depois: 6 */",
                              "finalVerifications": [
                                "A variável original x é modificada após a chamada da função?",
                                "O programa compila sem warnings ou erros de ponteiro?",
                                "Impressão de endereço com %p é correta e única?",
                                "Múltiplas chamadas incrementam corretamente?",
                                "Correção de erro comum (sem &) resulta em compilação falha?",
                                "Teste com variável diferente confirma generalização?"
                              ],
                              "assessmentCriteria": [
                                "Código compila e executa sem erros ou crashes.",
                                "Uso correto de & na chamada e * na função.",
                                "Demonstração de modificação da variável original.",
                                "Identificação e correção de pelo menos 2 erros comuns.",
                                "Explicação clara da diferença entre passagem por valor e referência.",
                                "Generalização para outros tipos de variáveis (ex: array)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Analogia com funções de mapeamento e referências variáveis.",
                                "Lógica e Algoritmos: Depuração como resolução de problemas lógicos.",
                                "Física/Engenharia: Endereços como coordenadas em memória (espaço vetorial).",
                                "Desenvolvimento de Software: Padrões de passagem de parâmetros em APIs."
                              ],
                              "realWorldApplication": "Em sistemas embarcados para atualizar sensores sem copiar dados (ex: IoT), bibliotecas gráficas como OpenGL para modificar buffers de vértices, ou jogos para alterar posições de objetos dinamicamente sem recópia de estruturas grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Desreferenciamento e Modificação via Ponteiro em Funções",
                        "description": "Utilizar o operador * para acessar e alterar o conteúdo do endereço apontado dentro da função, simulando passagem por referência.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Desreferenciar ponteiro dentro da função",
                            "description": "Escrever corpo de função como (*p)++; para incrementar o valor apontado, comparando com passagem por valor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Passagem de Parâmetros por Valor",
                                  "subSteps": [
                                    "Escreva uma função simples que recebe um inteiro por valor, como void incrementa(int x) { x++; }",
                                    "Chame a função com uma variável main(), como int valor = 5; incrementa(valor); printf(\"%d\", valor);",
                                    "Compile e execute para observar que o valor original não muda (permanece 5)",
                                    "Explique em comentários por que a modificação é local à função",
                                    "Teste com múltiplas chamadas para reforçar o conceito"
                                  ],
                                  "verification": "O valor na main() permanece inalterado após a chamada da função",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C (GCC)",
                                    "Editor de texto (VS Code ou similar)"
                                  ],
                                  "tips": "Sempre imprima valores antes e depois da chamada para visualizar mudanças",
                                  "learningObjective": "Compreender que parâmetros por valor criam cópias locais, não afetando o original",
                                  "commonMistakes": [
                                    "Achar que x++ modifica o chamador; esquecer de compilar e testar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Ponteiros e Desreferenciamento",
                                  "subSteps": [
                                    "Declare um ponteiro: int *p = &valor; onde valor é uma variável int",
                                    "Escreva expressões como *p para acessar o valor apontado e &p para endereço do ponteiro",
                                    "Teste *p = 10; e verifique se valor muda",
                                    "Pratique com printf(\"%d\", *p); para imprimir o valor desreferenciado",
                                    "Anote a diferença entre p (endereço) e *p (valor)"
                                  ],
                                  "verification": "Alterar *p modifica a variável original; imprimir confirma",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de texto"
                                  ],
                                  "tips": "Lembre: * é 'conteúdo no endereço', & é 'endereço de'",
                                  "learningObjective": "Dominar sintaxe de declaração, endereço e desreferenciamento de ponteiros",
                                  "commonMistakes": [
                                    "Confundir *p++ (incrementa ponteiro) com (*p)++ (incrementa valor)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Função com Desreferenciamento de Ponteiro",
                                  "subSteps": [
                                    "Escreva void incrementa_ptr(int *p) { (*p)++; } destacando parênteses",
                                    "Chame da main(): int valor = 5; incrementa_ptr(&valor); printf(\"%d\", valor);",
                                    "Compile e execute; confirme que valor vira 6",
                                    "Adicione printf dentro da função para mostrar *p antes/depois",
                                    "Compare códigos lado a lado com o da passagem por valor"
                                  ],
                                  "verification": "Valor na main() é incrementado após chamada com ponteiro",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de texto"
                                  ],
                                  "tips": "Parênteses em (*p)++ são cruciais: sem eles, incrementa o ponteiro",
                                  "learningObjective": "Escrever funções que modificam valores originais via desreferenciamento",
                                  "commonMistakes": [
                                    "Esquecer & na chamada; omitir parênteses em (*p)++"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Comparar Comportamentos",
                                  "subSteps": [
                                    "Crie programa com ambas funções: por valor e por ponteiro",
                                    "Execute cenários: múltiplos incrementos, valores negativos, zero",
                                    "Meça 'eficiência' comentando uso de memória (cópia vs. endereço)",
                                    "Refatore uma função existente para usar ponteiro onde modificação é necessária",
                                    "Documente diferenças em um README ou comentários"
                                  ],
                                  "verification": "Programa demonstra modificação apenas com ponteiro; testes passam",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use gdb ou debugger para inspecionar endereços e valores",
                                  "learningObjective": "Aplicar e comparar passagem por valor vs. referência para decidir uso",
                                  "commonMistakes": [
                                    "Passar ponteiro sem &; dereferenciar ponteiro nulo (segfault)"
                                  ]
                                }
                              ],
                              "practicalExample": "int main() {\n  int x = 5;\n  printf(\"Por valor: \");\n  incrementa(x); printf(\"%d\\n\", x); // ainda 5\n  printf(\"Por ponteiro: \");\n  incrementa_ptr(&x); printf(\"%d\\n\", x); // agora 6\n  return 0;\n}\n\nvoid incrementa(int x) { x++; }\nvoid incrementa_ptr(int *p) { (*p)++; }",
                              "finalVerifications": [
                                "Escreve (*p)++ corretamente em função",
                                "Distinguir passagem por valor (sem mudança) vs. ponteiro (com mudança)",
                                "Programa compila e executa sem erros ou segfaults",
                                "Explica sintaxe: & para endereço, * para desreferenciar",
                                "Aplica em função personalizada com sucesso",
                                "Identifica erros comuns como falta de parênteses"
                              ],
                              "assessmentCriteria": [
                                "Código usa (*p)++ com parênteses corretos",
                                "Valor original é modificado apenas via ponteiro",
                                "Comentários explicam diferenças entre abordagens",
                                "Testes incluem casos edge (zero, negativo)",
                                "Sem warnings de compilação ou runtime errors",
                                "Eficiência reconhecida (evita cópias desnecessárias)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Ponteiros como endereços numéricos em memória",
                                "Algoritmos: Modificação in-place para otimização O(1)",
                                "Lógica: Conceitos de referência vs. cópia em programação funcional",
                                "Engenharia de Software: Padrões de passagem de parâmetros em APIs"
                              ],
                              "realWorldApplication": "Em listas ligadas para modificar next/valor de nós; funções swap(int *a, int *b); em jogos para atualizar scores sem retornos múltiplos; bibliotecas como sorting onde arrays são passados por ponteiro para eficiência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Implementar troca de valores com ponteiros",
                            "description": "Desenvolver função void troca(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } e testar com main(), verificando alterações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de ponteiros e passagem por referência",
                                  "subSteps": [
                                    "Estude o que é um ponteiro: uma variável que armazena o endereço de memória de outra variável.",
                                    "Aprenda a desreferenciar com *: *ponteiro acessa o valor no endereço.",
                                    "Entenda passagem por referência: passar endereço permite modificar o original na função.",
                                    "Compare com passagem por valor: cópia não altera original.",
                                    "Exemplo simples: int x = 5; int *p = &x; *p = 10; // x agora é 10"
                                  ],
                                  "verification": "Explique em um comentário no código ou verbalmente como um ponteiro modifica a variável original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Code::Blocks)",
                                    "Compilador C (GCC)",
                                    "Documentação de ponteiros em C"
                                  ],
                                  "tips": "Visualize endereços de memória com diagramas para fixar o conceito.",
                                  "learningObjective": "Dominar a diferença entre passagem por valor e por referência usando ponteiros.",
                                  "commonMistakes": [
                                    "Confundir ponteiro (&) com desreferência (*)",
                                    "Esquecer que ponteiro precisa de & para obter endereço"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar a função void troca(int *a, int *b)",
                                  "subSteps": [
                                    "Escreva a assinatura: void troca(int *a, int *b); no topo do arquivo.",
                                    "Explique parâmetros: int *a recebe endereço de primeira variável, int *b de segunda.",
                                    "Inclua headers necessários: #include <stdio.h>.",
                                    "Crie protótipo antes da main para evitar erros de compilação."
                                  ],
                                  "verification": "Compilar o código com apenas a declaração; deve compilar sem erros de função indefinida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador GCC"
                                  ],
                                  "tips": "Sempre declare funções antes de usá-las ou use protótipos.",
                                  "learningObjective": "Saber declarar funções que recebem ponteiros como parâmetros.",
                                  "commonMistakes": [
                                    "Esquecer o * nos parâmetros",
                                    "Usar int a em vez de int *a"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o corpo da função troca",
                                  "subSteps": [
                                    "Dentro da função: int temp = *a; // Salva valor de a em temp.",
                                    "*a = *b; // Copia valor de b para a.",
                                    "*b = temp; // Copia temp (valor original de a) para b.",
                                    "Adicione printf para debug: printf('Troca: a=%d, b=%d\\n', *a, *b);",
                                    "Não retorne nada, pois é void."
                                  ],
                                  "verification": "Chame a função em um teste simples e veja se valores são trocados via printf.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Compilador"
                                  ],
                                  "tips": "Use variável temporária temp para evitar perda de dados.",
                                  "learningObjective": "Implementar lógica de swap usando desreferenciação de ponteiros.",
                                  "commonMistakes": [
                                    "Fazer *a = b em vez de *a = *b",
                                    "Esquecer temp e tentar trocar diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar main, testar e verificar alterações",
                                  "subSteps": [
                                    "Na main: int x = 5, y = 10; printf('Antes: x=%d, y=%d\\n', x, y);",
                                    "Chame troca(&x, &y); // Passe endereços com &.",
                                    "Após chamada: printf('Depois: x=%d, y=%d\\n', x, y);",
                                    "Compile: gcc arquivo.c -o programa && ./programa",
                                    "Verifique saída: Antes: x=5, y=10; Depois: x=10, y=5"
                                  ],
                                  "verification": "Executar programa e confirmar que valores foram trocados corretamente na main.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal para compilar e executar",
                                    "Compilador GCC"
                                  ],
                                  "tips": "Sempre passe & para enviar endereço na chamada da função.",
                                  "learningObjective": "Testar função completa e validar modificações por referência.",
                                  "commonMistakes": [
                                    "Chamar troca(x, y) sem &, valores não trocam",
                                    "Esquecer printf para verificar"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie programa que declara int idade1 = 25, idade2 = 30; imprime antes, chama troca(&idade1, &idade2), imprime depois. Saída esperada: Antes: 25 30; Depois: 30 25. Demonstra troca efetiva de idades usando ponteiros.",
                              "finalVerifications": [
                                "Programa compila sem warnings ou erros.",
                                "Valores são trocados corretamente na main após chamada da função.",
                                "Uso correto de * para desreferenciar dentro da função.",
                                "Passagem de endereços com & na chamada.",
                                "Saída do printf confirma troca antes/depois.",
                                "Sem vazamento de memória ou crashes."
                              ],
                              "assessmentCriteria": [
                                "Correta declaração de função com ponteiros (int *a, int *b).",
                                "Lógica de swap com temp, *a=*b, *b=temp implementada precisamente.",
                                "Chamada com &x e &y na main.",
                                "Testes com printf antes e depois validam modificação.",
                                "Código limpo, comentado e indentado.",
                                "Compilação e execução bem-sucedidas em ambiente C padrão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de variáveis como em álgebra (troca de valores).",
                                "Lógica e Algoritmos: Base para swaps em ordenação (Bubble Sort).",
                                "Engenharia de Software: Boas práticas de funções modulares.",
                                "Física/Computação: Conceitos de memória como endereços físicos."
                              ],
                              "realWorldApplication": "Essencial em algoritmos de ordenação (ex: QuickSort, onde swap de elementos em arrays), manipulação de estruturas de dados (listas ligadas), jogos (troca de posições de objetos) e sistemas embarcados para otimizar memória sem cópias desnecessárias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Aplicar em funções com múltiplos ponteiros",
                            "description": "Criar funções como void ajuste(int *min, int *max) que modificam duas variáveis via ponteiros, lidando com escopo e recursividade básica se aplicável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de ponteiros e declaração de funções",
                                  "subSteps": [
                                    "Explique o que é passagem por ponteiro em C e por que ela permite modificação de variáveis.",
                                    "Identifique a sintaxe para um ponteiro: int *p; e desreferenciamento: *p = valor;",
                                    "Discuta funções com um ponteiro: void func(int *x) { *x = 10; }",
                                    "Estenda para múltiplos ponteiros: void func(int *a, int *b);",
                                    "Compile um exemplo simples com um ponteiro para verificar entendimento."
                                  ],
                                  "verification": "Compilar e executar um programa de teste que modifique uma variável via ponteiro único sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador C (GCC), editor de texto (VS Code), terminal",
                                  "tips": "Sempre inicialize ponteiros para evitar undefined behavior.",
                                  "learningObjective": "Compreender como ponteiros permitem modificação de argumentos em funções.",
                                  "commonMistakes": "Confundir ponteiro com valor; esquecer o & ao passar endereço."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar função com múltiplos ponteiros",
                                  "subSteps": [
                                    "Defina a assinatura: void ajuste(int *min, int *max);",
                                    "Explique que cada parâmetro é um ponteiro para int, permitindo acesso a diferentes variáveis.",
                                    "Crie variáveis no main: int a = 10, b = 5; e prepare chamadas com &a, &b.",
                                    "Declare a função antes do main ou use protótipo.",
                                    "Verifique sintaxe com compilação seca (gcc -c)."
                                  ],
                                  "verification": "Compilação bem-sucedida sem erros de sintaxe na declaração.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Compilador C, editor de texto",
                                  "tips": "Use nomes descritivos como *min e *max para clareza semântica.",
                                  "learningObjective": "Criar corretamente funções que recebem múltiplos ponteiros como parâmetros.",
                                  "commonMistakes": "Esquecer asterisco (*) nos parâmetros; passar valores em vez de endereços."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar lógica de modificação via desreferenciamento",
                                  "subSteps": [
                                    "No corpo da função, verifique se *min > *max.",
                                    "Se verdadeiro, troque valores: int temp = *min; *min = *max; *max = temp;",
                                    "Garanta que a função modifique as variáveis originais via ponteiros.",
                                    "Adicione prints para depuração: printf(\"Novo min: %d\\n\", *min);",
                                    "Teste chamadas variadas: casos onde min <= max e min > max."
                                  ],
                                  "verification": "Executar e observar que variáveis no main são alteradas corretamente após chamada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C, terminal para execução",
                                  "tips": "Use variáveis temporárias para trocas para evitar perda de dados.",
                                  "learningObjective": "Usar desreferenciamento (*) para ler e modificar múltiplas variáveis dentro da função.",
                                  "commonMistakes": "Desreferenciar ponteiros nulos; confundir *min com min."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Lidar com escopo e introduzir recursividade básica",
                                  "subSteps": [
                                    "Explique escopo: variáveis locais na função não afetam main, mas ponteiros sim.",
                                    "Crie versão recursiva simples: void ajuste_rec(int *min, int *max, int depth) se depth > 0 e ajuste necessário.",
                                    "Implemente base case: if (*min <= *max) return; senão ajuste e recursão.",
                                    "Limite recursão para evitar stack overflow (ex: depth <= 3).",
                                    "Teste com prints de depth para visualizar chamadas."
                                  ],
                                  "verification": "Função recursiva executa sem crash e ajusta valores corretamente em 2-3 níveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C com suporte a recursão, debugger opcional (GDB)",
                                  "tips": "Monitore profundidade recursiva para aprendizado seguro.",
                                  "learningObjective": "Aplicar conceitos de escopo e recursividade básica em funções com ponteiros.",
                                  "commonMistakes": "Recursão infinita sem base case; ignorar escopo de variáveis locais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar o programa completo",
                                  "subSteps": [
                                    "Integre tudo no main: múltiplas chamadas com valores variados.",
                                    "Use assert ou ifs para verificar pós-chamada: assert(*min <= *max);",
                                    "Depure com printf ou GDB para rastrear valores de ponteiros.",
                                    "Teste edge cases: min/max iguais, valores negativos, zero.",
                                    "Refatore código para legibilidade e comente explicações."
                                  ],
                                  "verification": "Programa passa todos testes sem erros ou warnings de compilação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador C, GDB ou Valgrind para memory checks",
                                  "tips": "Sempre valide ponteiros com if (min != NULL) antes de desreferenciar.",
                                  "learningObjective": "Validar e depurar funções com múltiplos ponteiros em cenários reais.",
                                  "commonMistakes": "Não testar edge cases; leaks de memória (raro aqui)."
                                }
                              ],
                              "practicalExample": "```c\n#include <stdio.h>\nvoid ajuste(int *min, int *max) {\n    if (*min > *max) {\n        int temp = *min;\n        *min = *max;\n        *max = temp;\n    }\n}\nint main() {\n    int a = 10, b = 5;\n    printf(\"Antes: a=%d, b=%d\\n\", a, b);\n    ajuste(&a, &b);\n    printf(\"Depois: a=%d, b=%d\\n\", a, b); // Saída: Depois: a=5, b=10\n    return 0;\n}\n```",
                              "finalVerifications": [
                                "Variáveis passadas por ponteiro são modificadas corretamente no escopo do main.",
                                "Função lida com casos onde min > max trocando valores.",
                                "Compilação e execução sem warnings ou erros de runtime.",
                                "Recursão básica (se implementada) termina corretamente sem stack overflow.",
                                "Edge cases como valores iguais ou negativos funcionam.",
                                "Código é legível com comentários explicando ponteiros."
                              ],
                              "assessmentCriteria": [
                                "Correta declaração de parâmetros como ponteiros (uso de *).",
                                "Desreferenciamento apropriado (*min, *max) para modificação.",
                                "Passagem correta de endereços (&var) na chamada.",
                                "Lógica de ajuste implementada sem bugs.",
                                "Tratamento de escopo e recursão básica demonstrado.",
                                "Testes abrangentes incluindo depuração."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções paramétricas e trocas de variáveis.",
                                "Algoritmos: Modificação de estado e recursão.",
                                "Lógica: Condicionais if para validação de condições.",
                                "Engenharia: Gerenciamento de memória e depuração."
                              ],
                              "realWorldApplication": "Em jogos para normalizar limites de movimento de personagens (min/max posição); em interfaces gráficas para sliders de range; em sistemas embarcados para calibração de sensores (ajustar min/max leituras); em processamento de dados para sanitizar intervalos em bancos de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Ponteiros e Arrays",
                    "description": "Relação entre ponteiros e arrays, incluindo aritmética básica de ponteiros.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Nome de Array como Ponteiro",
                        "description": "Compreender que o nome de um array em C/C++ é equivalente a um ponteiro para seu primeiro elemento, permitindo o uso intercambiável em contextos de ponteiros.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Identificar equivalência entre array e ponteiro para primeiro elemento",
                            "description": "Reconhecer que o nome do array 'arr' é equivalente a '&arr[0]' e que '*arr' acessa o primeiro elemento, demonstrando com exemplos simples de declaração e inicialização de arrays.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar e inicializar um array simples",
                                  "subSteps": [
                                    "Abra um ambiente de desenvolvimento C (como Replit ou GCC local).",
                                    "Inclua a biblioteca necessária: #include <stdio.h>.",
                                    "Declare um array de inteiros: int arr[5] = {10, 20, 30, 40, 50};.",
                                    "Adicione um printf para exibir os valores: for(int i=0; i<5; i++) printf(\"arr[%d] = %d\\n\", i, arr[i]);.",
                                    "Compile e execute o código."
                                  ],
                                  "verification": "O programa compila sem erros e imprime os valores do array corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de código C, compilador GCC ou plataforma online como Replit.",
                                  "tips": "Use chaves {} para inicialização direta para evitar valores indeterminados.",
                                  "learningObjective": "Compreender a declaração e inicialização básica de arrays em C.",
                                  "commonMistakes": "Esquecer #include <stdio.h> ou ponto e vírgula após a declaração; não inicializar causando lixo na memória."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o nome do array como endereço de memória",
                                  "subSteps": [
                                    "No código existente, adicione: printf(\"Endereço do array: %p\\n\", (void*)arr);.",
                                    "Adicione: printf(\"Endereço do primeiro elemento: %p\\n\", (void*)&arr[0]);.",
                                    "Compile e execute, observando as saídas.",
                                    "Confirme visualmente se os dois endereços são idênticos.",
                                    "Anote a similaridade em um comentário no código."
                                  ],
                                  "verification": "Os dois printf exibem o mesmo endereço de memória.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo ambiente do Step 1; papel para anotações.",
                                  "tips": "Sempre caste para (void*) em %p para portabilidade.",
                                  "learningObjective": "Reconhecer que o nome 'arr' representa o endereço base do array.",
                                  "commonMistakes": "Confundir valor do elemento com endereço; esquecer cast para void* causando warnings."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar equivalência com ponteiro e acesso via desreferência",
                                  "subSteps": [
                                    "Adicione: printf(\"Primeiro elemento via []: %d\\n\", arr[0]);.",
                                    "Adicione: printf(\"Primeiro elemento via *: %d\\n\", *arr);.",
                                    "Modifique o primeiro elemento via ponteiro: *arr = 100;.",
                                    "Imprima novamente arr[0] para verificar a mudança.",
                                    "Compile, execute e valide as saídas iguais."
                                  ],
                                  "verification": "arr[0] e *arr exibem valores idênticos antes e após modificação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo ambiente; observe mudanças na memória.",
                                  "tips": "Lembre-se: arr é &arr[0], então *arr é arr[0].",
                                  "learningObjective": "Identificar que 'arr' equivale a '&arr[0]' e '*arr' acessa arr[0].",
                                  "commonMistakes": "Usar *arr sem entender que modifica o array; confundir arr[i] com *(arr + i)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar com exemplos variados e consolidação",
                                  "subSteps": [
                                    "Crie um novo array de chars: char str[6] = \"Hello\";.",
                                    "Imprima endereço: printf(\"%p == %p\\n\", (void*)str, (void*)&str[0]);.",
                                    "Acesse: printf(\"*%s = %c\\n\", str, *str); corrigindo para char.",
                                    "Teste modificação: *str = 'W'; printf(\"%s\\n\", str);.",
                                    "Explique em comentários as equivalências observadas."
                                  ],
                                  "verification": "Código executa corretamente, mostrando equivalências e modificações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ambiente C; exemplos de arrays de diferentes tipos.",
                                  "tips": "Teste com tipos diferentes (int, char) para generalizar o conceito.",
                                  "learningObjective": "Aplicar o conceito em cenários variados para fixação.",
                                  "commonMistakes": "Erro com strings (não usar %s com *str); esquecer null terminator em char arrays."
                                }
                              ],
                              "practicalExample": "int main() { int arr[3] = {1, 2, 3}; printf(\"arr: %p, &arr[0]: %p\\n\", (void*)arr, (void*)&arr[0]); printf(\"*arr: %d, arr[0]: %d\\n\", *arr, arr[0]); *arr = 10; printf(\"Após *arr=10: arr[0]=%d\\n\", arr[0]); return 0; } Saída: endereços iguais, valores iguais e modificados corretamente.",
                              "finalVerifications": [
                                "Endereços de 'arr' e '&arr[0]' são idênticos em todos os testes.",
                                "*arr acessa e modifica arr[0] corretamente.",
                                "O conceito funciona com arrays de int e char.",
                                "Nenhum erro de compilação ou runtime.",
                                "Comentários explicam as equivalências.",
                                "Testes com modificação confirmam ponteiro mutável."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual: explica arr == &arr[0] e *arr == arr[0].",
                                "Código compila e executa sem warnings ou erros.",
                                "Saídas dos printf confirmam equivalências numericamente.",
                                "Uso correto de casts e formatos em printf.",
                                "Aplicação em pelo menos dois tipos de array.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética de ponteiros como soma de offsets.",
                                "Lógica e Algoritmos: Equivalências simbólicas em expressões.",
                                "Física Computacional: Modelagem de memória como endereços físicos.",
                                "Engenharia: Otimização de acesso a dados em sistemas embarcados."
                              ],
                              "realWorldApplication": "Em programação de sistemas como kernels Linux ou microcontroladores (Arduino), onde arrays de sensores são tratados como ponteiros para eficiência de memória e passagem para funções, evitando cópias desnecessárias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Usar nome de array em operações de ponteiro",
                            "description": "Aplicar o nome do array diretamente em funções que esperam ponteiros, como imprimir elementos ou passar para subprogramas, comparando com notação de subscrito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de nome de array como ponteiro",
                                  "subSteps": [
                                    "Estude a definição: em C, o nome de um array é equivalente ao endereço do seu primeiro elemento (&arr[0]).",
                                    "Declare um array simples: int arr[5] = {10, 20, 30, 40, 50};",
                                    "Imprima o endereço do array (printf(\"%p\", arr);) e compare com &arr[0].",
                                    "Confirme que arr == &arr[0] usando uma instrução if.",
                                    "Teste que o tipo de arr é int* (ponteiro para int)."
                                  ],
                                  "verification": "Execute o código e verifique se os endereços impressos são iguais e se a comparação retorna true.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Compilador C (GCC ou Clang), editor de código (VS Code ou Dev-C++)",
                                  "tips": "Use %p para imprimir ponteiros e caste para void* se necessário.",
                                  "learningObjective": "Reconhecer que o nome do array decay para um ponteiro constante ao primeiro elemento.",
                                  "commonMistakes": [
                                    "Confundir o nome do array com o valor do primeiro elemento arr[0]",
                                    "Tentar atribuir um novo valor ao nome do array (é constante)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Acessar e imprimir elementos usando aritmética de ponteiros",
                                  "subSteps": [
                                    "Use *(arr + i) para acessar o i-ésimo elemento, onde i varia de 0 a 4.",
                                    "Implemente um loop for para imprimir todos os elementos: for(int i=0; i<5; i++) printf(\"%d \", *(arr + i));",
                                    "Compare o resultado com a notação de subscrito: printf(\"%d \", arr[i]);",
                                    "Teste com diferentes índices e observe os endereços: printf(\"%p \", arr + i);",
                                    "Adicione uma soma incremental: int soma = 0; for(int i=0; i<5; i++) soma += *(arr + i);"
                                  ],
                                  "verification": "Compile e execute; confirme que a saída é idêntica à notação de subscrito e soma correta (150).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C, terminal para execução",
                                  "tips": "Aritmética de ponteiros é escalada pelo tamanho do tipo (int: 4 bytes).",
                                  "learningObjective": "Aplicar aritmética de ponteiros para acessar elementos de array via nome.",
                                  "commonMistakes": [
                                    "Esquecer o asterisco (*) para desreferenciar",
                                    "Índices fora dos limites causando undefined behavior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Passar o nome do array para funções/subprogramas",
                                  "subSteps": [
                                    "Declare uma função: void imprimirArray(int *ptr, int tamanho);",
                                    "Chame a função passando o nome do array: imprimirArray(arr, 5);",
                                    "Na função, use loop com *(ptr + i) para imprimir elementos.",
                                    "Teste modificação: void dobrarArray(int *ptr, int tamanho); que faz * (ptr + i) *= 2;",
                                    "Chame dobrarArray(arr, 5); e imprima para verificar mudanças."
                                  ],
                                  "verification": "Execute e confirme que elementos são impressos corretamente e dobrados após a função (20,40,60,80,100).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Compilador C, debugger opcional (GDB)",
                                  "tips": "Parâmetro é ponteiro, não array; tamanho deve ser passado explicitamente.",
                                  "learningObjective": "Passar arrays para funções usando nome como ponteiro, permitindo modificações.",
                                  "commonMistakes": [
                                    "Esquecer passar o tamanho do array",
                                    "Usar [] na função sem ponteiro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar notação de ponteiro com subscrito e praticar",
                                  "subSteps": [
                                    "Escreva código lado a lado: arr[i] vs *(arr + i) vs *(ptr + i).",
                                    "Implemente uma função que soma elementos usando ambas as notações.",
                                    "Teste com array de chars (strings): char str[] = \"Hello\"; printf(\"%c\", *(str + 2));",
                                    "Debugue erros comuns como overflow de ponteiro.",
                                    "Crie um programa completo que lê array, passa para função e imprime via ponteiro."
                                  ],
                                  "verification": "Programa roda sem erros, saídas idênticas em ambas notações, soma correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador C, exemplos de código online (opcional)",
                                  "tips": "arr[i] é sintaxe açucar para *(arr + i).",
                                  "learningObjective": "Comparar e usar equivalentemente ponteiro e subscrito.",
                                  "commonMistakes": [
                                    "Confundir ++arr (avança ponteiro) com arr++ (undefined)",
                                    "Acessar além do array"
                                  ]
                                }
                              ],
                              "practicalExample": "int main() { int arr[5] = {1,2,3,4,5}; imprimirArray(arr, 5); dobrarArray(arr, 5); imprimirArray(arr, 5); return 0; } void imprimirArray(int *ptr, int n) { for(int i=0; i<n; i++) printf(\"%d \", *(ptr + i)); printf(\"\\n\"); } void dobrarArray(int *ptr, int n) { for(int i=0; i<n; i++) *(ptr + i) *= 2; } Saída: 1 2 3 4 5 \n 2 4 6 8 10",
                              "finalVerifications": [
                                "Nome do array imprime mesmo endereço que &arr[0].",
                                "Loop com *(arr + i) produz saída idêntica a arr[i].",
                                "Função modifica array corretamente ao receber nome como ponteiro.",
                                "Aritmética de ponteiros acessa elementos corretos sem erros.",
                                "Comparação entre notações confirma equivalência.",
                                "Programa completo compila e executa sem warnings ou erros."
                              ],
                              "assessmentCriteria": [
                                "Correta equivalência conceitual demonstrada (arr == &arr[0]).",
                                "Acesso preciso via aritmética de ponteiros sem overflows.",
                                "Funções recebem e modificam array via ponteiro adequadamente.",
                                "Código limpo, comentado e sem erros de compilação.",
                                "Comparação explícita com subscrito em exemplos.",
                                "Uso correto de tipos e casts quando necessário."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética de ponteiros (adição/multiplicação por sizeof(tipo)).",
                                "Lógica de Programação: Loops, funções e passagem de parâmetros.",
                                "Engenharia de Software: Gerenciamento eficiente de memória e buffers.",
                                "Física/Computação: Modelagem de vetores e endereçamento sequencial."
                              ],
                              "realWorldApplication": "Em programação de sistemas (ex: kernels Linux), processamento de imagens (buffers pixel como arrays/ponteiros), strings em bibliotecas (strlen usa ponteiro), e servidores de rede (manipulação de pacotes de dados em arrays para eficiência de performance)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Diferenciar array de ponteiro em atribuições",
                            "description": "Explicar por que não se pode atribuir um array a um ponteiro diretamente como 'arr = ptr', mas sim copiar o endereço, e demonstrar com código compilável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar declarações básicas de arrays e ponteiros em C",
                                  "subSteps": [
                                    "Declare um array de inteiros com tamanho fixo, ex: int arr[5];",
                                    "Inicialize o array com valores, ex: int arr[5] = {1, 2, 3, 4, 5};",
                                    "Declare um ponteiro para inteiro, ex: int *ptr;",
                                    "Inicialize o ponteiro apontando para NULL ou um endereço específico",
                                    "Use printf para exibir o endereço do array com &arr[0]"
                                  ],
                                  "verification": "Confirme que consegue compilar e executar um programa que imprime endereços de array e ponteiro sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C (GCC ou online como Replit)",
                                    "Editor de texto (VS Code)"
                                  ],
                                  "tips": [
                                    "Lembre-se: o nome do array é uma constante, não uma variável.",
                                    "Use %p para imprimir endereços."
                                  ],
                                  "learningObjective": "Diferenciar sintaxe e inicialização de arrays e ponteiros.",
                                  "commonMistakes": [
                                    "Confundir int arr[] com int *arr;",
                                    "Esquecer de incluir <stdio.h>"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o 'array-to-pointer decay'",
                                  "subSteps": [
                                    "Atribua o nome do array a um ponteiro: int *ptr = arr;",
                                    "Compile e execute, imprimindo ptr e arr para ver que são iguais.",
                                    "Passe o array para uma função que recebe ponteiro e observe o comportamento.",
                                    "Explique em comentários no código por que arr decay para &arr[0].",
                                    "Teste com array de chars para simular strings."
                                  ],
                                  "verification": "O ponteiro e o array exibem o mesmo endereço após a atribuição ptr = arr.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Documentação de C sobre ponteiros (ex: cppreference.com)"
                                  ],
                                  "tips": [
                                    "Decay acontece implicitamente em contextos como atribuição ou passagem de parâmetro.",
                                    "arr[i] é equivalente a *(arr + i)."
                                  ],
                                  "learningObjective": "Explicar o mecanismo automático de conversão de array para ponteiro.",
                                  "commonMistakes": [
                                    "Achar que ptr = arr copia os elementos do array.",
                                    "Ignorar que decay só ocorre em certos contextos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar atribuições inválidas: array = ponteiro",
                                  "subSteps": [
                                    "Tente compilar: arr = ptr; e observe o erro do compilador.",
                                    "Analise a mensagem de erro (ex: 'array type is not assignable').",
                                    "Declare outro ponteiro ptr2 e tente arr = ptr2; confirme falha.",
                                    "Compare com ptr2 = arr; que compila.",
                                    "Modifique o código para usar memcpy se quiser copiar conteúdo (mas não endereço)."
                                  ],
                                  "verification": "Código com arr = ptr; falha na compilação, mas ptr = arr; succeeds.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C com flags -Wall -Wextra para erros detalhados"
                                  ],
                                  "tips": [
                                    "Nome de array é l-value constante, não modificável.",
                                    "Use ponteiros para simular arrays redimensionáveis."
                                  ],
                                  "learningObjective": "Identificar por que atribuição direta para nome de array é proibida.",
                                  "commonMistakes": [
                                    "Confundir nome de array com variável.",
                                    "Tentar forçar com casts desnecessários."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar com código compilável e sintetizar diferenças",
                                  "subSteps": [
                                    "Escreva um programa completo comparando as duas atribuições com #ifdef para alternar.",
                                    "Compile ambas as versões e capture saídas/erros.",
                                    "Adicione funções que recebem ponteiros para reforçar decay.",
                                    "Documente as diferenças em um relatório curto no código.",
                                    "Teste em diferentes tamanhos de array."
                                  ],
                                  "verification": "Programa compila e executa corretamente mostrando ptr = arr funciona, arr = ptr não.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use static arrays para evitar alocação dinâmica inicialmente.",
                                    "Estude assembly gerado para ver endereços."
                                  ],
                                  "learningObjective": "Criar e debugar código que ilustra a distinção conceitual.",
                                  "commonMistakes": [
                                    "Usar arrays multidimensionais sem entender decay parcial.",
                                    "Confundir com C++ references."
                                  ]
                                }
                              ],
                              "practicalExample": "int main() {\n  int arr[5] = {1,2,3,4,5};\n  int *ptr = arr;  // OK: decay para endereço\n  printf(\"arr: %p, ptr: %p\\n\", (void*)arr, (void*)ptr);\n  // int *ptr2 = NULL;\n  // arr = ptr2;  // ERRO: array não é l-value atribuível\n  return 0;\n}\nSaída: arr e ptr têm mesmo endereço. Erro de compilação explica 'cannot assign to array'.",
                              "finalVerifications": [
                                "Explicar verbalmente por que ptr = arr funciona mas arr = ptr não.",
                                "Compilar código com atribuição inválida e citar o erro exato.",
                                "Modificar código para usar ponteiro como 'array' dinâmico.",
                                "Identificar decay em passagem de array para função.",
                                "Diferenciar em quiz: array vs ponteiro em 3 cenários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação do decay de array-to-pointer.",
                                "Correta reprodução de código compilável vs não compilável.",
                                "Identificação de erros comuns em atribuições.",
                                "Uso correto de endereços e aritmética de ponteiros.",
                                "Síntese clara das diferenças conceituais.",
                                "Aplicação em exemplo prático sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Memória em Sistemas Operacionais (endereços virtuais).",
                                "Algoritmos e Estruturas de Dados (arrays dinâmicos via ponteiros).",
                                "Programação de Baixo Nível (assembly e registradores).",
                                "Segurança de Software (buffer overflows por confusão array/ponteiro)."
                              ],
                              "realWorldApplication": "Em bibliotecas C como string.h, funções como strcpy recebem ponteiros para arrays (strings), evitando cópias desnecessárias e permitindo manipulação eficiente de buffers em servidores, jogos e embedded systems onde memória é crítica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Aritmética de Ponteiros em Arrays",
                        "description": "Dominar as operações aritméticas básicas em ponteiros que apontam para arrays, considerando o escalonamento automático pelo tamanho do tipo de dado.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Executar soma e subtração em ponteiros de array",
                            "description": "Calcular que 'ptr + i' resulta em '&array[i]' e demonstrar com código que itera sobre um array usando aritmética de ponteiros, sem usar subscritos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a relação entre ponteiros e arrays",
                                  "subSteps": [
                                    "Declare um array de inteiros e um ponteiro para seu primeiro elemento.",
                                    "Verifique que o nome do array é equivalente a um ponteiro para array[0].",
                                    "Demonstre acessando o primeiro elemento via *ptr e array[0].",
                                    "Explique o 'decay' do array para ponteiro.",
                                    "Identifique o tipo do ponteiro (ex: int* para int array[])."
                                  ],
                                  "verification": "Compile e execute um programa que imprime array[0] e *ptr, confirmando igualdade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C (ex: gcc)",
                                    "Editor de texto (ex: VS Code)"
                                  ],
                                  "tips": "Sempre considere o tipo do elemento para calcular deslocamentos corretos.",
                                  "learningObjective": "Entender que arrays se degeneram em ponteiros para o primeiro elemento.",
                                  "commonMistakes": [
                                    "Confundir o ponteiro com o endereço base do array inteiro",
                                    "Usar ponteiro sem inicializar para o array",
                                    "Ignorar o tamanho do tipo apontado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a aritmética de soma em ponteiros",
                                  "subSteps": [
                                    "Calcule manualmente ptr + 1, que avança sizeof(int) bytes.",
                                    "Demonstre que ptr + i resulta em &array[i].",
                                    "Escreva código para imprimir o endereço de array[i] via ptr + i.",
                                    "Compare *(ptr + i) com array[i].",
                                    "Teste com valores i=0,1,2 em um array pequeno."
                                  ],
                                  "verification": "Adicione printf para mostrar &array[2] e (ptr + 2), confirmando igualdade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de texto"
                                  ],
                                  "tips": "Aritmética de ponteiros é em unidades do tipo, não bytes brutos.",
                                  "learningObjective": "Calcular e validar que ptr + i == &array[i].",
                                  "commonMistakes": [
                                    "Somar bytes diretamente em vez de elementos",
                                    "Usar aritmética em ponteiros void*",
                                    "Esquecer de dereferenciar com *"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar subtração em ponteiros de array",
                                  "subSteps": [
                                    "Calcule ptr - i para retroceder i elementos.",
                                    "Demonstre ptr2 - ptr1 para obter a distância em elementos.",
                                    "Escreva código que subtrai ponteiros para contar elementos entre eles.",
                                    "Acesse elementos anteriores via *(ptr - 1).",
                                    "Valide limites para evitar underflow."
                                  ],
                                  "verification": "Execute código que calcula (ptr + 3) - ptr == 3.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de texto"
                                  ],
                                  "tips": "Subtração de ponteiros retorna o número de elementos, não bytes.",
                                  "learningObjective": "Executar subtração segura em ponteiros para navegação reversa.",
                                  "commonMistakes": [
                                    "Subtrair ponteiros de tipos diferentes",
                                    "Acessar além dos limites do array",
                                    "Confundir subtração de ponteiros com ponteiro menos inteiro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar iteração sobre array usando apenas aritmética de ponteiros",
                                  "subSteps": [
                                    "Escreva um loop for com ptr = array; ptr < array + size; ptr++.",
                                    "Some valores do array usando *ptr no loop.",
                                    "Imprima cada elemento sem usar colchetes [].",
                                    "Adapte para subtração iterando reversamente.",
                                    "Teste com array de pelo menos 5 elementos."
                                  ],
                                  "verification": "Compile e execute, verificando soma total e impressões corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use end_ptr = array + size como sentinela para o loop.",
                                  "learningObjective": "Iterar e processar arrays exclusivamente com ponteiros.",
                                  "commonMistakes": [
                                    "Usar array[i] acidentalmente",
                                    "Loop infinito por condição errada",
                                    "Não avançar ptr corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "int arr[] = {10, 20, 30, 40, 50}; int size = 5; int sum = 0; int *ptr = arr; for(; ptr < arr + size; ptr++) { sum += *ptr; } printf(\"Soma: %d\\n\", sum); // Saída: Soma: 150, sem usar []",
                              "finalVerifications": [
                                "Calcule manualmente ptr + 3 para array de 10 elementos e confirme &array[3].",
                                "Escreva e execute código de iteração que imprime array reverso via subtração.",
                                "Explique por que *(arr + 2) == 30 sem rodar código.",
                                "Modifique código para dobrar cada elemento usando apenas ponteiros.",
                                "Identifique erro em código com ptr-- além do início."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual: ptr + i == &array[i] demonstrado.",
                                "Código funcional sem subscritos [], compila e executa corretamente.",
                                "Uso seguro de limites de array em loops.",
                                "Explicação clara de soma/subtração em ponteiros.",
                                "Eficiência: evita depreciações ou avisos do compilador.",
                                "Testes com múltiplos arrays e tamanhos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética vetorial e deslocamentos lineares.",
                                "Algoritmos: Otimização de loops em estruturas de dados.",
                                "Engenharia de Software: Gerenciamento eficiente de memória.",
                                "Física/Engenharia: Modelagem de arrays como vetores em simulações."
                              ],
                              "realWorldApplication": "Em processamento de imagens (ex: OpenCV em C), navegar pixels de um array com ponteiros para filtros rápidos; em sistemas embarcados, iterar sensores sem overhead de subscritos para performance crítica."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Acessar elementos via desreferência aritmética",
                            "description": "Implementar acesso a elementos de array usando '*(ptr + i)' equivalente a 'array[i]', incluindo exemplos com tipos int e char para mostrar escalonamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a relação entre arrays e ponteiros",
                                  "subSteps": [
                                    "Declare um array de inteiros, ex: int arr[5] = {10, 20, 30, 40, 50};",
                                    "Atribua o ponteiro para o primeiro elemento: int *ptr = arr;",
                                    "Imprima o endereço de arr e de ptr para confirmar equivalência",
                                    "Explique verbalmente ou por escrito por que arr decaye para ponteiro",
                                    "Teste acesso ao primeiro elemento: printf(\"%d\", *ptr);"
                                  ],
                                  "verification": "Confirme que &arr[0] == ptr e que *ptr == arr[0]",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Compilador C (GCC ou Clang)",
                                    "Editor de código (VS Code ou similar)"
                                  ],
                                  "tips": [
                                    "O nome do array é um ponteiro constante; não tente modificá-lo.",
                                    "Use %p para imprimir endereços."
                                  ],
                                  "learningObjective": "Compreender que o nome de um array é equivalente ao endereço de seu primeiro elemento",
                                  "commonMistakes": [
                                    "Confundir o valor do ponteiro com o conteúdo do array",
                                    "Tentar atribuir um novo valor a 'arr' (é constante)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar aritmética de ponteiros básicos",
                                  "subSteps": [
                                    "Adicione 1 ao ponteiro: printf(\"%p\", ptr + 1); observe avanço de sizeof(int) bytes",
                                    "Calcule ptr + 2 manualmente: endereço base + 2 * sizeof(int)",
                                    "Desreferencie: printf(\"%d\", *(ptr + 2)); confirme valor de arr[2]",
                                    "Compare com arr[2] no mesmo código para validar equivalência",
                                    "Registre os endereços e valores em uma tabela para visualização"
                                  ],
                                  "verification": "Os valores de arr[i] e *(ptr + i) devem ser idênticos para i=0 a 4",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Calculadora para tamanhos de tipo (sizeof)"
                                  ],
                                  "tips": [
                                    "Aritmética de ponteiros é escalonada pelo tamanho do tipo; int é tipicamente 4 bytes.",
                                    "Use gdb ou debugger para inspecionar memória."
                                  ],
                                  "learningObjective": "Dominar o cálculo de endereços via ptr + i e desreferência",
                                  "commonMistakes": [
                                    "Esquecer escalonamento (achar que +1 avança 1 byte sempre)",
                                    "Desreferenciar ponteiro nulo ou inválido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar acesso em arrays de inteiros",
                                  "subSteps": [
                                    "Escreva um loop for(i=0; i<5; i++) { printf(\"arr[%d]=%d, *(ptr+%d)=%d\\n\", i, arr[i], i, *(ptr+i)); }",
                                    "Compile e execute, capturando saída para comparação",
                                    "Modifique o array e verifique se mudanças refletem via ponteiro",
                                    "Adicione soma dos elementos usando apenas aritmética de ponteiros",
                                    "Teste com array maior (10 elementos) para prática"
                                  ],
                                  "verification": "Saída mostra equivalência perfeita entre array[i] e *(ptr + i)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Terminal para execução"
                                  ],
                                  "tips": [
                                    "Evite off-by-one errors no loop.",
                                    "Use const int * para prática segura."
                                  ],
                                  "learningObjective": "Implementar acesso equivalente a array[i] via ponteiro em código funcional",
                                  "commonMistakes": [
                                    "Índices fora dos limites causando undefined behavior",
                                    "Confundir pré e pós-incremento de ponteiro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em arrays de char e demonstrar escalonamento",
                                  "subSteps": [
                                    "Declare char str[] = \"Hello\"; char *p = str;",
                                    "Imprima str[0] vs *p, str[4] vs *(p+4); note avanço de 1 byte por char",
                                    "Compare com int: crie int nums[3]={1,2,3}; mostre ptr+1 avança 4 bytes vs char 1 byte",
                                    "Escreva função que percorre string via ponteiro até '\\0'",
                                    "Teste com string mais longa e imprima reversa usando aritmética"
                                  ],
                                  "verification": "Valores char acessados via *(p + i) coincidem com str[i]; escalonamento correto via sizeof",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Referência de sizeof para tipos"
                                  ],
                                  "tips": [
                                    "Chars são 1 byte; úteis para strings. Use %s para strings completas.",
                                    "Visualize memória com hex dump (xxd)."
                                  ],
                                  "learningObjective": "Entender impacto do tipo no escalonamento de ponteiros",
                                  "commonMistakes": [
                                    "Assumir escalonamento fixo de 4 bytes para todos os tipos",
                                    "Não lidar com terminador nul em strings"
                                  ]
                                }
                              ],
                              "practicalExample": "#include <stdio.h>\nint main() {\n  int arr[5] = {10,20,30,40,50};\n  int *ptr = arr;\n  char str[] = \"Hello\";\n  char *p = str;\n  for(int i=0; i<5; i++) {\n    printf(\"arr[%d]: %d (ptr+%d: %d)\\n\", i, arr[i], i, *(ptr+i));\n  }\n  for(int i=0; i<5; i++) {\n    printf(\"str[%d]: %c (p+%d: %c)\\n\", i, str[i], i, *(p+i));\n  }\n  return 0;\n}",
                              "finalVerifications": [
                                "Escreva e execute código acessando 5 elementos de array int via *(ptr + i)",
                                "Demonstre equivalência com array[i] em saída impressa",
                                "Repita para array char, confirmando escalonamento de 1 byte",
                                "Calcule endereço de arr[3] manualmente e valide com printf",
                                "Implemente soma de array usando apenas ponteiro aritmética",
                                "Explique diferença de sizeof(int) vs sizeof(char) em relatório curto"
                              ],
                              "assessmentCriteria": [
                                "Correção sintática e semântica do código (compila e roda sem erros)",
                                "Equivalência comprovada entre notações array[i] e *(ptr + i)",
                                "Compreensão de escalonamento por tipo (int vs char)",
                                "Uso correto de loops e desreferenciação sem overflows",
                                "Eficiência e clareza do código com comentários",
                                "Capacidade de debugar erros comuns como ponteiros inválidos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e cálculo de offsets (álgebra linear básica)",
                                "Física/Engenharia de Hardware: Modelagem de endereços de memória física",
                                "Algoritmos: Otimização de acesso sequencial em estruturas de dados",
                                "Segurança da Informação: Entendimento de buffer overflows via aritmética errada"
                              ],
                              "realWorldApplication": "Em processamento de strings (bibliotecas como strlen via ponteiro), manipulação de buffers em redes/sockets, kernels de SO para gerenciamento de memória alocada dinamicamente, e engines de jogos para arrays de pixels ou vértices onde acesso eficiente é crítico."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Aplicar aritmética para percorrer arrays",
                            "description": "Escrever loops que percorrem arrays inteiros incrementando ponteiros ('ptr++'), comparando o tamanho do passo com o sizeof do tipo e evitando erros comuns como overflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Aritmética de Ponteiros e Arrays",
                                  "subSteps": [
                                    "Revise como arrays decayem para ponteiros no C (array name é ponteiro para primeiro elemento).",
                                    "Aprenda que ptr++ incrementa o ponteiro pelo sizeof(tipo), não por 1 byte.",
                                    "Estude comparação de ponteiro com array+size para bounds checking.",
                                    "Pratique visualizando memória: desenhe um array de 5 ints e marque posições com ponteiro.",
                                    "Compile e rode um exemplo simples de ponteiro apontando para array."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como ptr++ avança corretamente pelo array sem acessar bytes errados.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Compilador C (ex: gcc)",
                                    "Editor de código (VS Code ou similar)",
                                    "Documentação C sobre ponteiros (man pages ou online)"
                                  ],
                                  "tips": [
                                    "Use diagramas de memória para visualizar; lembre-se: aritmética é em unidades do tipo, não bytes.",
                                    "Teste com printf para ver valores de ponteiro em cada iteração."
                                  ],
                                  "learningObjective": "Compreender como ponteiros e arrays interagem, incluindo escala automática de aritmética.",
                                  "commonMistakes": [
                                    "Confundir ptr++ com byte-wise increment (leva a acessar elementos errados).",
                                    "Esquecer que comparação é ptr < array + size, não ptr < size."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Loop Básico de Travessia com Ponteiro",
                                  "subSteps": [
                                    "Declare um array de inteiros (ex: int arr[10] = {1,2,3,...}).",
                                    "Inicialize ponteiro: int *ptr = arr; int size = sizeof(arr)/sizeof(arr[0]);",
                                    "Escreva loop while(ptr < arr + size) { processar(*ptr); ptr++; }",
                                    "Adicione printf dentro do loop para imprimir cada elemento.",
                                    "Compile e execute para verificar travessia completa."
                                  ],
                                  "verification": "O loop imprime todos os 10 elementos corretamente sem pular ou repetir.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Editor de código",
                                    "Debugger opcional (gdb)"
                                  ],
                                  "tips": [
                                    "Use sizeof para calcular size dinamicamente, evite hardcode.",
                                    "Insira printf(\"%p: %d\\n\", (void*)ptr, *ptr); para depuração visual."
                                  ],
                                  "learningObjective": "Escrever um loop funcional que percorre todo o array usando aritmética de ponteiros.",
                                  "commonMistakes": [
                                    "Usar for(i=0; i<size; i++) ptr = arr + i; em vez de ptr++ (menos idiomático).",
                                    "Esquecer de dereferenciar *ptr ao processar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Verificações de Bounds e Evitar Overflow",
                                  "subSteps": [
                                    "Modifique o loop para incluir assert ou if(ptr >= arr + size) break; antes de acessar *ptr.",
                                    "Teste com size intencionalmente errado para simular overflow.",
                                    "Implemente soma acumulada: int sum = 0; sum += *ptr; dentro do loop.",
                                    "Use valgrind ou similar para checar acessos inválidos de memória.",
                                    "Refatore para função genérica que aceita qualquer array e size."
                                  ],
                                  "verification": "Executar com array menor que esperado não causa segfault ou soma errada.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Compilador C com valgrind (Linux/Mac) ou AddressSanitizer (-fsanitize=address)",
                                    "Editor"
                                  ],
                                  "tips": [
                                    "Sempre compare ptr < end_ptr onde end_ptr = arr + size.",
                                    "Evite ptr - arr > size; prefira ponteiro final."
                                  ],
                                  "learningObjective": "Garantir segurança do loop contra overflow e acessos inválidos.",
                                  "commonMistakes": [
                                    "Off-by-one: ptr <= arr + size permite acessar além do fim.",
                                    "Overflow em size grande: use size_t para índices."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Aplicar em Cenário Prático",
                                  "subSteps": [
                                    "Crie array de floats e adapte o loop (note mudança em sizeof).",
                                    "Implemente função que encontra máximo usando o loop de ponteiro.",
                                    "Teste com dados reais: array de notas de alunos, calcule média.",
                                    "Depure erros intencionalmente inseridos (ex: ptr-- acidental).",
                                    "Otimize: compare performance com loop index-based."
                                  ],
                                  "verification": "Função encontra max corretamente em múltiplos testes, sem leaks ou crashes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Compilador",
                                    "Valgrind ou sanitizer",
                                    "Conjuntos de teste pré-definidos"
                                  ],
                                  "tips": [
                                    "Escreva unit tests simples com assert(sum == expected).",
                                    "Para genérico: use void* com casts cuidadosos."
                                  ],
                                  "learningObjective": "Aplicar e validar o loop em contextos variados com robustez.",
                                  "commonMistakes": [
                                    "Não ajustar para tipos diferentes (floats precisam de %f em printf).",
                                    "Ignorar endianness ou alinhamento em visualizações."
                                  ]
                                }
                              ],
                              "practicalExample": "Escreva uma função int sumArray(int *arr, size_t size) { int *ptr = arr; int sum = 0; while(ptr < arr + size) { sum += *ptr++; } return sum; } Teste com int grades[5] = {85,92,78,96,88}; assert(sumArray(grades,5) == 439);",
                              "finalVerifications": [
                                "Loop percorre exatamente 'size' elementos sem acessar memória inválida.",
                                "Soma ou processamento acumula valores corretos (teste com known sum).",
                                "Compila sem warnings com -Wall -Wextra e roda sem sanitizers erros.",
                                "Funciona com arrays vazios (size=0) sem crash.",
                                "Performance similar a loop for(i=0;i<size;i++) em benchmarks simples.",
                                "Valgrind relata zero leaks ou invalid reads/writes."
                              ],
                              "assessmentCriteria": [
                                "Código usa ptr++ e comparação ptr < arr+size corretamente (100%).",
                                "Bounds checking previne overflow (testado com size inválido).",
                                "Idiomático C: sem índices manuais, puro pointer arithmetic.",
                                "Funcional: processa todos elementos corretamente em 3+ testes.",
                                "Robusto: lida com edge cases (size=0,1,maxint).",
                                "Documentado: comentários explicam aritmética usada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e offsets lineares.",
                                "Algoritmos: Iteração linear O(n) em estruturas de dados.",
                                "Engenharia de Software: Gerenciamento seguro de memória.",
                                "Física/Engenharia: Simulações numéricas em arrays (ex: vetores de posições)."
                              ],
                              "realWorldApplication": "Em processamento de imagens (percorrer pixels em buffer), análise de dados (somar vendas em array), ou kernels de sistemas operacionais (iterar buffers de rede sem índices para performance máxima)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.4",
                            "name": "Calcular diferenças entre ponteiros em arrays",
                            "description": "Usar subtração de ponteiros 'ptr2 - ptr1' para obter o número de elementos entre eles em um array, aplicando em funções que contam ou medem tamanhos dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Relação entre Ponteiros e Arrays",
                                  "subSteps": [
                                    "Declare um array de inteiros e um ponteiro para o tipo int.",
                                    "Atribua o endereço do primeiro elemento do array ao ponteiro usando &array[0] ou simplesmente array.",
                                    "Imprima os endereços do array e do ponteiro para verificar que são iguais.",
                                    "Acesse elementos do array via ponteiro usando aritmética de ponteiro (ptr + i).",
                                    "Explique em comentários como o nome do array 'decai' para um ponteiro."
                                  ],
                                  "verification": "Compile e execute um programa que demonstra que o ponteiro aponta para o início do array e acessa elementos corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilador C (GCC/Clang)",
                                    "Editor de código (VS Code)",
                                    "Exemplo de código base com array"
                                  ],
                                  "tips": "Sempre inicialize ponteiros para evitar undefined behavior; use printf para depuração de endereços.",
                                  "learningObjective": "Entender que arrays são representados por ponteiros para seus primeiros elementos.",
                                  "commonMistakes": [
                                    "Confundir o ponteiro com o valor do elemento",
                                    "Esquecer de incluir <stdio.h> para printf",
                                    "Usar sizeof(array) incorretamente em funções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Aritmética Básica de Ponteiros",
                                  "subSteps": [
                                    "Aprenda que ponteiros suportam adição e subtração, escalados pelo tamanho do tipo.",
                                    "Escreva código para adicionar um inteiro a um ponteiro (ptr + 3) e imprima o endereço resultante.",
                                    "Calcule a diferença entre dois ponteiros adjacentes (ptr+1 - ptr) e verifique que resulta em 1.",
                                    "Teste com diferentes tipos (int vs char) para observar escalonamento.",
                                    "Documente o resultado: diferença é em unidades de elementos, não bytes."
                                  ],
                                  "verification": "Execute testes onde (ptr + n) - ptr == n para vários n, confirmando aritmética correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Código do Step 1",
                                    "Calculadora para verificar endereços em bytes"
                                  ],
                                  "tips": "Use %p para imprimir ponteiros; divida por sizeof(type) manualmente para validar.",
                                  "learningObjective": "Dominar adição e subtração de ponteiros, entendendo o escalonamento automático.",
                                  "commonMistakes": [
                                    "Subtrair ponteiros de tipos diferentes",
                                    "Aguardar diferença em bytes ao invés de elementos",
                                    "Não castar ponteiros corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Diferenças entre Ponteiros em Arrays",
                                  "subSteps": [
                                    "Crie dois ponteiros: um no início (start = array) e outro no fim (end = array + size).",
                                    "Calcule end - start e imprima: deve igualar o número de elementos.",
                                    "Teste com subarrays: start = array + 2, end = array + 5; diferença deve ser 3.",
                                    "Varra um array com ponteiro inicial e finalize quando encontrar um sentinel (ex: 0).",
                                    "Compare com loop de índices para validar resultados."
                                  ],
                                  "verification": "Programa imprime diferenças corretas para arrays fixos e subarrays, matching com tamanho conhecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Arrays de teste com valores conhecidos",
                                    "Debugger (GDB opcional)"
                                  ],
                                  "tips": "Ponteiros devem apontar para o mesmo array ou bloco contíguo para subtração válida.",
                                  "learningObjective": "Aplicar subtração de ponteiros para medir distâncias em elementos de array.",
                                  "commonMistakes": [
                                    "Subtrair ponteiros apontando para arrays diferentes",
                                    "Confundir com sizeof",
                                    "Overflow em ponteiros próximos ao fim da memória"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Funções Usando Diferenças de Ponteiros",
                                  "subSteps": [
                                    "Escreva uma função int count_elements(int *start, int *end) { return end - start; }.",
                                    "Crie uma função que conta elementos até sentinel: int dynamic_size(int *ptr) { int *end = ptr; while(*end) end++; return end - ptr; }.",
                                    "Teste as funções com arrays de tamanhos variados e subarrays.",
                                    "Integre em um programa principal que usa as funções para processar dados.",
                                    "Otimize evitando passar tamanho explícito, usando ponteiros."
                                  ],
                                  "verification": "Funções retornam tamanhos corretos em testes unitários com asserts ou prints.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador C",
                                    "Código dos steps anteriores",
                                    "Ferramenta de teste (Unity ou manual)"
                                  ],
                                  "tips": "Retorne size_t para tamanhos; valide que end > start em funções.",
                                  "learningObjective": "Usar diferenças de ponteiros em funções para medir tamanhos dinâmicos.",
                                  "commonMistakes": [
                                    "Não verificar null pointers",
                                    "Retornar diferença como int em arrays grandes",
                                    "Modificar dados durante contagem"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma função para calcular o comprimento de um subarray dinâmico: size_t subarray_length(int *begin, int *past_end) { return past_end - begin; }. Uso: int arr[] = {1,2,3,4,5}; printf(\"%zu\", subarray_length(arr+1, arr+4)); // Saída: 3",
                              "finalVerifications": [
                                "Calcula corretamente a diferença ptr2 - ptr1 como número de elementos.",
                                "Entende que a subtração é escalada pelo sizeof(type).",
                                "Aplica em funções sem depender de índices ou sizeof(array).",
                                "Identifica erros comuns como ponteiros não contíguos.",
                                "Usa em cenários reais como iteração até sentinel.",
                                "Valida resultados comparando com métodos tradicionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Diferenças calculadas corretamente em todos os testes.",
                                "Compreensão: Explica escalonamento e limitações da aritmética.",
                                "Aplicação: Implementa funções funcionais e eficientes.",
                                "Robustez: Trata casos edge (arrays vazios, null pointers).",
                                "Eficiência: Evita loops desnecessários usando subtração direta.",
                                "Clareza: Código comentado e legível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de vetores e diferenças em escalas discretas.",
                                "Algoritmos: Similar a std::distance() em C++ iterators.",
                                "Estruturas de Dados: Gerenciamento de memória dinâmica e linked lists.",
                                "Engenharia de Software: Otimização de performance em arrays grandes.",
                                "Física/Computação: Modelagem de posições em simulações numéricas."
                              ],
                              "realWorldApplication": "Em bibliotecas como STL C++ para distâncias entre iterators; parsing de buffers de rede sem tamanho pré-fixado; algoritmos de string processing (strlen usa ponteiro até '\\0'); gerenciamento de memória em kernels ou embedded systems para calcular tamanhos de blocos alocados dinamicamente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 334
          }
        ],
        "totalSkills": 334
      }
    ]
  }
}